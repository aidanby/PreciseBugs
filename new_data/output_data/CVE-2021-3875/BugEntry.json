{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX)\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_stop(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_unlockvar\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_JUMPLIST\n# define ex_jumps\t\tex_ni\n# define ex_clearjumps\t\tex_ni\n# define ex_changes\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = NORMAL;\n    trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t\temsg(_(\"E501: At end-of-file\"));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    --RedrawingDisabled;\n    --no_wait_return;\n    update_screen(CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_endfor));\n\t    else\n\t\temsg(_(e_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw()\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(\"E605: Exception not caught: %s\"),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, options);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROT)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n#endif\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n#if (_MSC_VER == 1200)\n/*\n * Avoid optimisation bug in VC++ version 6.0\n */\n #pragma optimize( \"g\", off )\n#endif\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tmay_have_range;\n    int\t\tvim9script;\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n#ifdef FEAT_EVAL\n    vim9script = in_vim9script();\n#endif\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n#ifdef FEAT_EVAL\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n#endif\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n#endif\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    ea.cmd = cmd;\n#ifdef FEAT_EVAL\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else\n#endif\n\tif (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t    goto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\tif ((*ea.cmd == '|' || (exmode_active && ea.line1 != ea.line2))\n#ifdef FEAT_EVAL\n\t\t&& !vim9script\n#endif\n\t   )\n\t{\n\t    ea.cmdidx = CMD_print;\n\t    ea.argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\t    if ((errormsg = invalid_range(&ea)) == NULL)\n\t    {\n\t\tcorrect_range(&ea);\n\t\tex_print(&ea);\n\t    }\n\t}\n\telse if (ea.addr_count != 0)\n\t{\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// With '-' in 'cpoptions' a line number past the file is an\n\t\t// error, otherwise put it at the end of the file.\n\t\tif (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\t    ea.line2 = -1;\n\t\telse\n\t\t    ea.line2 = curbuf->b_ml.ml_line_count;\n\t    }\n\n\t    if (ea.line2 < 0)\n\t\terrormsg = _(e_invalid_range);\n\t    else\n\t    {\n\t\tif (ea.line2 == 0)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = ea.line2;\n\t\tbeginline(BL_SOL | BL_FIX);\n\t    }\n\t}\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(\"E492: Not an editor command\"));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(\"E981: Command not allowed in rvim\");\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n#endif\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    // no range allowed\n\t    errormsg = _(e_norange);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\t// no <!> allowed\n    {\n\terrormsg = _(e_nobang);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(\"E493: Backwards range given\");\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invarg);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(\"E494: Use w or w>>\");\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n')\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalidreg);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_zerocount);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    ea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_arg, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argreq);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if (ea.argt & EX_XFILE)\n    {\n\tif (expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\t    goto doend;\n    }\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\tea.errmsg = NULL;\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (getline_equal(ea.getline, ea.cookie, getsourceline)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif (sourcing)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n#if (_MSC_VER == 1200)\n #pragma optimize( \"\", on )\n#endif\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !isalpha((*pp)[i])\n\t\t\t   && (*pp)[i] != '_' && (!noparen || (*pp)[i] != '('))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *p;\n    int\t    starts_with_colon = FALSE;\n\n    CLEAR_POINTER(cmod);\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty line works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    eap->cmd = (char_u *)\"+\";\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (in_vim9script())\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = p; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (vim_strchr((char_u *)\".=\", *n) != NULL\n\t\t    || *s == '['\n\t\t    || (*n != NUL && n[1] == '='))\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t\t\t|| *p == NUL || ends_excmd(*p))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (in_vim9script() && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd);\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 1;\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose != 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    return FAIL;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\treturn FAIL;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    return FAIL;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    return OK;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff < IOSIZE - 7)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if (p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.' && (ASCII_ISALPHA(p[1])\n\t\t\t\t\t\t\t     || p[1] == '_'))))\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| eap->skip\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize using a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] == p[1] && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     * Exceptions:\n     * - The 'k' command can directly be followed by any character.\n     *   But it is not used in Vim9 script.\n     * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n     *\t    but :sre[wind] is another command, as are :scr[iptnames],\n     *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n     * - the \"d\" command can directly be followed by 'l' or 'p' flag.\n     */\n    p = eap->cmd;\n    if (!vim9 && *p == 'k')\n    {\n\teap->cmdidx = CMD_k;\n\t++p;\n    }\n    else if (!vim9\n\t    && p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\teap->cmdidx = CMD_substitute;\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL\n\t\t\t   && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// Not not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T  ea;\n    char_u   *name;\n    char_u   *p;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    name = argvars[0].vval.v_string;\n    if (name == NULL)\n\treturn;\n\n    while (*name != NUL && *name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\treturn;\n    if (in_vim9script())\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    return;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    for (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t    idx = (cmdidx_T)((int)idx + 1))\n\tif (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t    break;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_norange));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t\tn = getdigits(&cmd);\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t&& address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t    lnum += n;\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(_(\"INTERNAL: Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\"));\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(\"E319: Sorry, the command is not available in this version\");\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t\t errormsgp, &escaped);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n */\n    void\nseparate_nextcmd(exarg_T *eap)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if (eap->argt & (EX_CTRLV | EX_XFILE))\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tSTRMOVE(p - 1, p);\t// remove the '\\'\n\t\t--p;\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_arg, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\tcomment_char = '#';\n#endif\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n#endif\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(\"E173: %d more file to edit\",\n\t\t\t\"E173: %d more files to edit\", n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn;\n    }\n# endif\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn;\n\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n#endif\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (win == aucmd_win)\n    {\n\temsg(_(e_autocmd_close));\n\treturn;\n    }\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(buf, FALSE);\n\t    if (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\treturn;\n\t    need_hide = FALSE;\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invargval, eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    emsg(_(\"E784: Cannot close last tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\ttp = find_tabpage(tab_number);\n\t\tif (tp == NULL)\n\t\t{\n\t\t    beep_flush();\n\t\t    return;\n\t\t}\n\t\tif (tp != curtab)\n\t\t{\n\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t    return;\n\t\t}\n\t\telse if (!text_locked() && !curbuf_locked())\n\t\t    tabpage_close(eap->forceit);\n\t    }\n\t}\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    msg(_(\"Already only one tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\tgoto_tabpage(tab_number);\n\t\t// Repeat this up to a 1000 times, because autocommands may\n\t\t// mess up the lists.\n\t\tfor (done = 0; done < 1000; ++done)\n\t\t{\n\t\t    FOR_ALL_TABPAGES(tp)\n\t\t\tif (tp->tp_topframe != topframe)\n\t\t\t{\n\t\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t\t    // if we failed to close it quit\n\t\t\t    if (valid_tabpage(tp))\n\t\t\t\tdone = 1000;\n\t\t\t    // start over, \"tp\" is now invalid\n\t\t\t    break;\n\t\t\t}\n\t\t    if (first_tabpage->tp_next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n    int\t\th = tabline_height();\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    win_T   *wp;\n    int\t    wnr;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (!eap->skip)\n    {\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tif (eap->addr_count == 0)\n\t    win_close(curwin, FALSE);\t// don't free buffer\n\telse\n\t{\n\t    int\twinnr = 0;\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t    {\n\t\twinnr++;\n\t\tif (winnr == eap->line2)\n\t\t    break;\n\t    }\n\t    if (win == NULL)\n\t\twin = lastwin;\n\t    win_close(win, FALSE);\n\t}\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    static void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (!check_restricted())\n    {\n\tif (!eap->forceit)\n\t    autowrite_all();\n\tapply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n\twindgoto((int)Rows - 1, 0);\n\tout_char('\\n');\n\tout_flush();\n\tstoptermcap();\n\tout_flush();\t\t// needed for SUN to restore xterm buffer\n#ifdef FEAT_TITLE\n\tmch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n#endif\n\tui_suspend();\t\t// call machine specific function\n#ifdef FEAT_TITLE\n\tmaketitle();\n\tresettitle();\t\t// force updating the title\n#endif\n\tstarttermcap();\n\tscroll_start();\t\t// scroll screen before redrawing\n\tredraw_later_clear();\n\tshell_resized();\t// may have resized window\n\tapply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n    }\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_emptybuf));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = _(e_invalid_command);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\n    char_u\t*fname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n#ifdef FEAT_SEARCHPATH\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else\n# endif\n#endif\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\n# if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\ntheend:\n    vim_free(fname);\n# endif\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screenmode));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win((int)n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win((int)n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    int\t\tcount;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t\t\t\t      TRUE, curbuf->b_ffname);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t\t\t\t     FALSE, curbuf->b_ffname);\n\t}\n    }\n\n    if (fname != NULL)\n    {\n\teap->arg = fname;\n#endif\n\tdo_exedit(eap, NULL);\n#ifdef FEAT_SEARCHPATH\n\tvim_free(fname);\n    }\n#endif\n}\n\n/*\n * \":open\" simulation: for now just work like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tint\trd = RedrawingDisabled;\n\t\tint\tnwr = no_wait_return;\n\t\tint\tms = msg_scroll;\n#ifdef FEAT_GUI\n\t\tint\the = hold_gui_events;\n#endif\n\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tRedrawingDisabled = 0;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\thold_gui_events = 0;\n#endif\n\t\tmust_redraw = CLEAR;\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = rd;\n\t\tno_wait_return = nwr;\n\t\tmsg_scroll = ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit an new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"curbuf_lock\" is set.  Only \":edit\"\n\t// can bring us here, others are stopped earlier.\n\tif (*eap->arg != NUL && curbuf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n#ifdef FEAT_TITLE\n\tn = curwin->w_arg_idx_invalid;\n#endif\n\tcheck_arg_idx(curwin);\n#ifdef FEAT_TITLE\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n#endif\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n    else\n    {\n\tif (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\t    return;\n\n#ifdef FEAT_BROWSE\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    char_u *browseFile;\n\n\t    browseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t    if (browseFile != NULL)\n\t    {\n\t\ti = readfile(browseFile, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t\tvim_free(browseFile);\n\t    }\n\t    else\n\t\ti = OK;\n\t}\n\telse\n#endif\n\t     if (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n\tif (i != OK)\n\t{\n#if defined(FEAT_EVAL)\n\t    if (!aborting())\n#endif\n\t\tsemsg(_(e_notopen), eap->arg);\n\t}\n\telse\n\t{\n\t    if (empty && exmode_active)\n\t    {\n\t\t// Delete the empty line that remains.  Historically ex does\n\t\t// this but vi doesn't.\n\t\tif (eap->line2 == 0)\n\t\t    lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    lnum = 1;\n\t\tif (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t\t{\n\t\t    ml_delete(lnum);\n\t\t    if (curwin->w_cursor.lnum > 1\n\t\t\t\t\t     && curwin->w_cursor.lnum >= lnum)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t    deleted_lines_mark(lnum, 1L);\n\t\t}\n\t    }\n\t    redraw_curbuf_later(VALID);\n\t}\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    shorten_fnames(TRUE);\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*tofree;\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    int\t\tretval = FALSE;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(\"E186: No previous directory\"));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Free the previous directory\n    tofree = get_prevdir(scope);\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n    if (scope == CDSCOPE_WINDOW)\n\tcurwin->w_prevdir = pdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tcurtab->tp_prevdir = pdir;\n    else\n\tprev_dir = pdir;\n\n#if defined(UNIX) || defined(VMS)\n    // for UNIX \":cd\" means: go to home directory\n    if (*new_dir == NUL)\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n#endif\n    dir_differs = new_dir == NULL || pdir == NULL\n\t|| pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (new_dir == NULL || (dir_differs && vim_chdir(new_dir)))\n\temsg(_(e_failed));\n    else\n    {\n\tchar_u  *acmd_fname;\n\n\tpost_chdir(scope);\n\n\tif (dir_differs)\n\t{\n\t    if (scope == CDSCOPE_WINDOW)\n\t\tacmd_fname = (char_u *)\"window\";\n\t    else if (scope == CDSCOPE_TABPAGE)\n\t\tacmd_fname = (char_u *)\"tabpage\";\n\t    else\n\t\tacmd_fname = (char_u *)\"global\";\n\t    apply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE,\n\t\t\t\t\t\t\t\tcurbuf);\n\t}\n\tretval = TRUE;\n    }\n    vim_free(tofree);\n\n    return retval;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory\n    if (*new_dir == NUL)\n\tex_pwd(NULL);\n    else\n#endif\n    {\n\tcdscope_T\tscope = CDSCOPE_GLOBAL;\n\n\tif (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\t    scope = CDSCOPE_WINDOW;\n\telse if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\t    scope = CDSCOPE_TABPAGE;\n\n\tif (changedir_func(new_dir, eap->forceit, scope))\n\t{\n\t    // Echo the new current directory if the command was typed.\n\t    if (KeyTyped || p_verbose >= 5)\n\t\tex_pwd(eap);\n\t}\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(\"E187: Unknown\"));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto((int)n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invarg2), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n        cursor_sleep();\n    else\n        cursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n        cursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invarg2), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(\"E465: :winsize requires two number arguments\"));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invarg));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invarg));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(\"E188: Obtaining window position not implemented for this platform\"));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(\"E466: :winpos requires two number arguments\"));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n    }\n    else\n    {\n\tint\tsave_efr = exec_from_reg;\n\n\texec_from_reg = TRUE;\n\n\t/*\n\t * Execute from the typeahead buffer.\n\t * Continue until the stuff buffer is empty and all added characters\n\t * have been consumed.\n\t */\n\twhile (!stuff_empty() || typebuf.tb_len > prev_len)\n\t    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n\texec_from_reg = save_efr;\n    }\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invarg2), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(\"E930: Cannot use :redir inside execute()\"));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invarg2), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invarg2), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n#ifdef FEAT_TITLE\n    if (need_maketitle)\n\tmaketitle();\n#endif\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    update_screen(VIsual_active ? INVERTED : 0);\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(\"E739: Cannot create directory: %s\"), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_src_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(\"E189: \\\"%s\\\" exists (add ! to override)\"), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(\"E190: Cannot open \\\"%s\\\" for writing\"), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n\temsg(_(e_argreq));\n    else if (eap->arg[1] != NUL)\t// more than one character?\n\tsemsg(_(e_trailing_arg), eap->arg);\n    else\n    {\n\tpos = curwin->w_cursor;\t\t// save curwin->w_cursor\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_WHITE | BL_FIX);\n\tif (setmark(*eap->arg) == FAIL)\t// set mark\n\t    emsg(_(\"E191: Argument must be a letter or forward/backward quote\"));\n\tcurwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n    }\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_secure));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(\"E192: Recursive use of :normal too deep\"));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_arg, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_STACK + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped)\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(\"E809: #< is not available without the +eval feature\");\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(\"E194: No alternate file name to substitute for '#'\");\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n#endif\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(\"E495: no autocommand file name to substitute for \\\"<afile>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(\"E496: no autocommand buffer number to substitute for \\\"<abuf>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(\"E497: no autocommand match name to substitute for \\\"<amatch>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(spec_idx == SPEC_SFILE\n\t\t\t\t\t\t? ESTACK_SFILE : ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = spec_idx == SPEC_SFILE\n\t\t\t? _(\"E498: no :source file name to substitute for \\\"<sfile>\\\"\")\n\t\t\t: _(\"E489: no call stack to substitute for \\\"<stack>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(\"E842: no line number to use for \\\"<slnum>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(\"E961: no line number to use for \\\"<sflnum>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_usingsid);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (valid != VALID_HEAD + VALID_PATH)\n\t    // xgettext:no-c-format\n\t    *errormsg = _(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\");\n\telse\n\t    *errormsg = _(\"E500: Evaluates to an empty string\");\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value((char_u *)\"selection\", 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value((char_u *)\"selectmode\", 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value((char_u *)\"mousemodel\", 0L, (char_u *)\"popup\", 0);\n\tset_option_value((char_u *)\"keymodel\", 0L,\n\t\t\t\t\t     (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value((char_u *)\"selection\", 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value((char_u *)\"mousemodel\", 0L, (char_u *)\"extend\", 0);\n\tset_option_value((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invarg2), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invarg2), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (!did_filetype)\n    {\n\tchar_u *arg = eap->arg;\n\n\tif (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\t    arg += 9;\n\n\tset_option_value((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n\tif (arg != eap->arg)\n\t    did_filetype = FALSE;\n    }\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n#endif\n", "\" Test for the search command\n\nsource shared.vim\nsource screendump.vim\nsource check.vim\n\nfunc Test_search_cmdline()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])\n  \" Test 1\n  \" CTRL-N / CTRL-P skips through the previous search history\n  set noincsearch\n  :1\n  call feedkeys(\"/foobar\\<cr>\", 'tx')\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('the', @/)\n  call feedkeys(\"/thes\\<C-P>\\<C-P>\\<cr>\", 'tx')\n  call assert_equal('foobar', @/)\n\n  \" Test 2\n  \" Ctrl-G goes from one match to the next\n  \" until the end of the buffer\n  set incsearch nowrapscan\n  :1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  :1\n  \" second match\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n  call assert_equal([0, 0, 0, 0], getpos('\"'))\n  :1\n  \" third match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 2).\"\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  :1\n  \" fourth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 3).\"\\<cr>\", 'tx')\n  call assert_equal('  5 there', getline('.'))\n  :1\n  \" fifth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 4).\"\\<cr>\", 'tx')\n  call assert_equal('  6 their', getline('.'))\n  :1\n  \" sixth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 5).\"\\<cr>\", 'tx')\n  call assert_equal('  7 the', getline('.'))\n  :1\n  \" seventh match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 6).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  :1\n  \" eighth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  :1\n  \" no further match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  call assert_equal([0, 0, 0, 0], getpos('\"'))\n\n  \" Test 3\n  \" Ctrl-G goes from one match to the next\n  \" and continues back at the top\n  set incsearch wrapscan\n  :1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  :1\n  \" second match\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n  :1\n  \" third match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 2).\"\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  :1\n  \" fourth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 3).\"\\<cr>\", 'tx')\n  call assert_equal('  5 there', getline('.'))\n  :1\n  \" fifth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 4).\"\\<cr>\", 'tx')\n  call assert_equal('  6 their', getline('.'))\n  :1\n  \" sixth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 5).\"\\<cr>\", 'tx')\n  call assert_equal('  7 the', getline('.'))\n  :1\n  \" seventh match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 6).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  :1\n  \" eighth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  :1\n  \" back at first match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n\n  \" Test 4\n  \" CTRL-T goes to the previous match\n  set incsearch nowrapscan\n  $\n  \" first match\n  call feedkeys(\"?the\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" first match\n  call feedkeys(\"?the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" second match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 1).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n\n  \" Test 5\n  \" CTRL-T goes to the previous match\n  set incsearch wrapscan\n  $\n  \" first match\n  call feedkeys(\"?the\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" first match at the top\n  call feedkeys(\"?the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" second match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 1).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" back at the bottom of the buffer\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n\n  \" Test 6\n  \" CTRL-L adds to the search pattern\n  set incsearch wrapscan\n  1\n  \" first match\n  call feedkeys(\"/the\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to next match of 'thes'\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  1\n  \" wrap around\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" wrap around\n  set nowrapscan\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n\n  \" Test 7\n  \" <bs> remove from match, but stay at current match\n  set incsearch wrapscan\n  1\n  \" first match\n  call feedkeys(\"/thei\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  1\n  \" delete one char, add another\n  call feedkeys(\"/thei\\<bs>s\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" delete one char, add another,  go to previous match, add one char\n  call feedkeys(\"/thei\\<bs>s\\<bs>\\<C-T>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  1\n  \" delete all chars, start from the beginning again\n  call feedkeys(\"/them\". repeat(\"\\<bs>\",4).'the\\>'.\"\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n\n  \" clean up\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline2()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 these', '  3 the theother'])\n  \" Test 1\n  \" Ctrl-T goes correctly back and forth\n  set incsearch\n  1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to next match (on next line)\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to next match (still on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to next match (still on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 2)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<C-T>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to previous match (on line 2)\n  call feedkeys(\"/the\\<C-G>\\<C-R>\\<C-W>\\<cr>\", 'tx')\n  call assert_equal('theother', @/)\n\n  \" Test 2: keep the view,\n  \" after deleting a character from the search cmd\n  call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])\n  resize 5\n  1\n  call feedkeys(\"/foo\\<bs>\\<cr>\", 'tx')\n  redraw\n  call assert_equal({'lnum': 10, 'leftcol': 0, 'col': 4, 'topfill': 0, 'topline': 6, 'coladd': 0, 'skipcol': 0, 'curswant': 4}, winsaveview())\n\n  \" remove all history entries\n  for i in range(11)\n      call histdel('/')\n  endfor\n\n  \" Test 3: reset the view,\n  \" after deleting all characters from the search cmd\n  norm! 1gg0\n  \" unfortunately, neither \"/foo\\<c-w>\\<cr>\", nor \"/foo\\<bs>\\<bs>\\<bs>\\<cr>\",\n  \" nor \"/foo\\<c-u>\\<cr>\" works to delete the commandline.\n  \" In that case Vim should return \"E35 no previous regular expression\",\n  \" but it looks like Vim still sees /foo and therefore the test fails.\n  \" Therefore, disabling this test\n  \"call assert_fails(feedkeys(\"/foo\\<c-w>\\<cr>\", 'tx'), 'E35:')\n  \"call assert_equal({'lnum': 1, 'leftcol': 0, 'col': 0, 'topfill': 0, 'topline': 1, 'coladd': 0, 'skipcol': 0, 'curswant': 0}, winsaveview())\n\n  \" clean up\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_use_sub_pat()\n  split\n  let @/ = ''\n  func X()\n    s/^/a/\n    /\n  endfunc\n  call X()\n  bwipe!\nendfunc\n\nfunc Test_searchpair()\n  new\n  call setline(1, ['other code', 'here [', ' [', ' \" cursor here', ' ]]'])\n\n  \" should not give an error for using \"42\"\n  call assert_equal(0, searchpair('a', 'b', 'c', '', 42))\n\n  4\n  call assert_equal(3, searchpair('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4\n  call assert_equal(2, searchpair('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4\n  call assert_equal(1, searchpair('\\[', '', ']', 'bWm'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4|norm ^\n  call assert_equal(5, searchpair('\\[', '', ']', 'Wn'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n  4\n  call assert_equal(2, searchpair('\\[', '', ']', 'bW',\n        \\                         'getline(\".\") =~ \"^\\\\s*\\[\"'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  set nomagic\n  4\n  call assert_equal(3, searchpair('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  set magic\n  4|norm ^\n  call assert_equal(0, searchpair('{', '', '}', 'bW'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n\n  %d\n  call setline(1, ['if 1', '  if 2', '  else', '  endif 2', 'endif 1'])\n\n  /\\<if 1\n  call assert_equal(5, searchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  /\\<if 2\n  call assert_equal(3, searchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 3, 3, 0], getpos('.'))\n\n  q!\nendfunc\n\nfunc Test_searchpairpos()\n  new\n  call setline(1, ['other code', 'here [', ' [', ' \" cursor here', ' ]]'])\n\n  4\n  call assert_equal([3, 2], searchpairpos('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4|norm ^\n  call assert_equal([5, 2], searchpairpos('\\[', '', ']', 'Wn'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bW',\n        \\                                 'getline(\".\") =~ \"^\\\\s*\\[\"'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  set nomagic\n  4\n  call assert_equal([3, 2], searchpairpos('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  set magic\n  4|norm ^\n  call assert_equal([0, 0], searchpairpos('{', '', '}', 'bW'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n\n  %d\n  call setline(1, ['if 1', '  if 2', '  else', '  endif 2', 'endif 1'])\n  /\\<if 1\n  call assert_equal([5, 1], searchpairpos('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  /\\<if 2\n  call assert_equal([3, 3], searchpairpos('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 3, 3, 0], getpos('.'))\n\n  q!\nendfunc\n\nfunc Test_searchpair_errors()\n  call assert_fails(\"call searchpair([0], 'middle', 'end', 'bW', 'skip', 99, 100)\", 'E730: Using a List as a String')\n  call assert_fails(\"call searchpair('start', {-> 0}, 'end', 'bW', 'skip', 99, 100)\", 'E729: Using a Funcref as a String')\n  call assert_fails(\"call searchpair('start', 'middle', {'one': 1}, 'bW', 'skip', 99, 100)\", 'E731: Using a Dictionary as a String')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'flags', 'skip', 99, 100)\", 'E475: Invalid argument: flags')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'bW', 'func', -99, 100)\", 'E475: Invalid argument: -99')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'bW', 'func', 99, -100)\", 'E475: Invalid argument: -100')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'e')\", 'E475: Invalid argument: e')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'sn')\", 'E475: Invalid argument: sn')\nendfunc\n\nfunc Test_searchpairpos_errors()\n  call assert_fails(\"call searchpairpos([0], 'middle', 'end', 'bW', 'skip', 99, 100)\", 'E730: Using a List as a String')\n  call assert_fails(\"call searchpairpos('start', {-> 0}, 'end', 'bW', 'skip', 99, 100)\", 'E729: Using a Funcref as a String')\n  call assert_fails(\"call searchpairpos('start', 'middle', {'one': 1}, 'bW', 'skip', 99, 100)\", 'E731: Using a Dictionary as a String')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'flags', 'skip', 99, 100)\", 'E475: Invalid argument: flags')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'bW', 'func', -99, 100)\", 'E475: Invalid argument: -99')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'bW', 'func', 99, -100)\", 'E475: Invalid argument: -100')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'e')\", 'E475: Invalid argument: e')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'sn')\", 'E475: Invalid argument: sn')\nendfunc\n\nfunc Test_searchpair_skip()\n    func Zero()\n      return 0\n    endfunc\n    func Partial(x)\n      return a:x\n    endfunc\n    new\n    call setline(1, ['{', 'foo', 'foo', 'foo', '}'])\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', ''))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', '0'))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', {-> 0}))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', function('Zero')))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', function('Partial', [0])))\n    bw!\nendfunc\n\nfunc Test_searchpair_leak()\n  new\n  call setline(1, 'if one else another endif')\n\n  \" The error in the skip expression caused memory to leak.\n  call assert_fails(\"call searchpair('\\\\<if\\\\>', '\\\\<else\\\\>', '\\\\<endif\\\\>', '', '\\\"foo\\\" 2')\", 'E15:')\n\n  bwipe!\nendfunc\n\nfunc Test_searchc()\n  \" These commands used to cause memory overflow in searchc().\n  new\n  norm ixx\n  exe \"norm 0t\\u93cf\"\n  bw!\nendfunc\n\nfunc Cmdline3_prep()\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 the~e', '  3 the theother'])\n  set incsearch\nendfunc\n\nfunc Incsearch_cleanup()\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline3()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  \" first match\n  call feedkeys(\"/the\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  2 the~e', getline('.'))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3s()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":%s/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%subs/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%substitute/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%smagic/the.e/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxx', getline('.'))\n  undo\n  call assert_fails(\":%snomagic/the.e/xxx\\<cr>\", 'E486:')\n  \"\n  call feedkeys(\":%snomagic/the\\\\.e/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxx', getline('.'))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3g()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":g/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline(2))\n  undo\n  call feedkeys(\":global/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline(2))\n  undo\n  call feedkeys(\":g!/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n  undo\n  call feedkeys(\":global!/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3v()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":v/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n  undo\n  call feedkeys(\":vglobal/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline4()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1 the first', '  2 the second', '  3 the third'])\n  set incsearch\n  $\n  call feedkeys(\"?the\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  2 the second', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  2 the second', getline('.'))\n  \" clean up\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline5()\n  CheckOption incsearch\n\n  \" Do not call test_override(\"char_avail\", 1) so that <C-g> and <C-t> work\n  \" regardless char_avail.\n  new\n  call setline(1, ['  1 the first', '  2 the second', '  3 the third', ''])\n  set incsearch\n  1\n  call feedkeys(\"/the\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  \" clean up\n  set noincsearch\n  bw!\nendfunc\n\nfunc Test_search_cmdline6()\n  \" Test that consecutive matches\n  \" are caught by <c-g>/<c-t>\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, [' bbvimb', ''])\n  set incsearch\n  \" first match\n  norm! gg0\n  call feedkeys(\"/b\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  \" second match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,3,0], getpos('.'))\n  \" third match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n  \" first match again\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  set nowrapscan\n  \" last match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n  \" clean up\n  set wrapscan&vim\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline7()\n  \" Test that pressing <c-g> in an empty command line\n  \" does not move the cursor\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  let @/ = 'b'\n  call setline(1, [' bbvimb', ''])\n  set incsearch\n  \" first match\n  norm! gg0\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<cr>\", 'tx')\n  call assert_equal([0,1,3,0], getpos('.'))\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<c-t>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n\n  \" using an offset uses the last search pattern\n  call cursor(1, 1)\n  call setline(1, ['1 bbvimb', ' 2 bbvimb'])\n  let @/ = 'b'\n  call feedkeys(\"//e\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('1 bbvimb', getline('.'))\n  call assert_equal(4, col('.'))\n\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline8()\n  \" Highlighting is cleared in all windows\n  \" since hls applies to all windows\n  CheckOption incsearch\n  CheckFeature terminal\n  CheckNotGui\n  if has(\"win32\")\n    throw \"Skipped: Bug with sending <ESC> to terminal window not fixed yet\"\n  endif\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n  \" Prepare buffer text\n  let lines = ['abb vim vim vi', 'vimvivim']\n  call writefile(lines, 'Xsearch.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile', 'Xsearch.txt'], {'term_rows': 3})\n\n  call WaitForAssert({-> assert_equal(lines, [term_getline(buf, 1), term_getline(buf, 2)])})\n\n  call term_sendkeys(buf, \":set incsearch hlsearch\\<cr>\")\n  call term_sendkeys(buf, \":14vsp\\<cr>\")\n  call term_sendkeys(buf, \"/vim\\<cr>\")\n  call term_sendkeys(buf, \"/b\\<esc>\")\n  call term_sendkeys(buf, \"gg0\")\n  call TermWait(buf, 250)\n  let screen_line = term_scrape(buf, 1)\n  let [a0,a1,a2,a3] = [screen_line[3].attr, screen_line[4].attr,\n        \\ screen_line[18].attr, screen_line[19].attr]\n  call assert_notequal(a0, a1)\n  call assert_notequal(a0, a3)\n  call assert_notequal(a1, a2)\n  call assert_equal(a0, a2)\n  call assert_equal(a1, a3)\n  \" clean up\n  call delete('Xsearch.txt')\n\n  bwipe!\nendfunc\n\n\" Tests for regexp with various magic settings\nfunc Run_search_regexp_magic_opt()\n  put ='1 a aa abb abbccc'\n  exe 'normal! /a*b\\{2}c\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 2, 17, 0], getpos('.'))\n\n  put ='2 d dd dee deefff'\n  exe 'normal! /\\Md\\*e\\{2}f\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 3, 17, 0], getpos('.'))\n\n  set nomagic\n  put ='3 g gg ghh ghhiii'\n  exe 'normal! /g\\*h\\{2}i\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 4, 17, 0], getpos('.'))\n\n  put ='4 j jj jkk jkklll'\n  exe 'normal! /\\mj*k\\{2}l\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 5, 17, 0], getpos('.'))\n\n  put ='5 m mm mnn mnnooo'\n  exe 'normal! /\\vm*n{2}o+/e' . \"\\<CR>\"\n  call assert_equal([0, 6, 17, 0], getpos('.'))\n\n  put ='6 x ^aa$ x'\n  exe 'normal! /\\V^aa$' . \"\\<CR>\"\n  call assert_equal([0, 7, 5, 0], getpos('.'))\n\n  set magic\n  put ='7 (a)(b) abbaa'\n  exe 'normal! /\\v(a)(b)\\2\\1\\1/e' . \"\\<CR>\"\n  call assert_equal([0, 8, 14, 0], getpos('.'))\n\n  put ='8 axx [ab]xx'\n  exe 'normal! /\\V[ab]\\(\\[xy]\\)\\1' . \"\\<CR>\"\n  call assert_equal([0, 9, 7, 0], getpos('.'))\n\n  %d\nendfunc\n\nfunc Test_search_regexp()\n  enew!\n\n  set regexpengine=1\n  call Run_search_regexp_magic_opt()\n  set regexpengine=2\n  call Run_search_regexp_magic_opt()\n  set regexpengine&\n\n  set undolevels=100\n  put ='9 foobar'\n  put =''\n  exe \"normal! a\\<C-G>u\\<Esc>\"\n  normal G\n  exe 'normal! dv?bar?' . \"\\<CR>\"\n  call assert_equal('9 foo', getline('.'))\n  call assert_equal([0, 2, 5, 0], getpos('.'))\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal('9 foobar', getline('.'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  call assert_equal(3, line('$'))\n\n  set undolevels&\n  enew!\nendfunc\n\nfunc Test_search_cmdline_incsearch_highlight()\n  CheckOption incsearch\n\n  set incsearch hlsearch\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['aaa  1 the first', '  2 the second', '  3 the third'])\n\n  1\n  call feedkeys(\"/second\\<cr>\", 'tx')\n  call assert_equal('second', @/)\n  call assert_equal('  2 the second', getline('.'))\n\n  \" Canceling search won't change @/\n  1\n  let @/ = 'last pattern'\n  call feedkeys(\"/third\\<C-c>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/third\\<Esc>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/3\\<bs>\\<bs>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/third\\<c-g>\\<c-t>\\<Esc>\", 'tx')\n  call assert_equal('last pattern', @/)\n\n  \" clean up\n  set noincsearch nohlsearch\n  bw!\nendfunc\n\nfunc Test_search_cmdline_incsearch_highlight_attr()\n  CheckOption incsearch\n  CheckFeature terminal\n  CheckNotGui\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n\n  \" Prepare buffer text\n  let lines = ['abb vim vim vi', 'vimvivim']\n  call writefile(lines, 'Xsearch.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile', 'Xsearch.txt'], {'term_rows': 3})\n\n  call WaitForAssert({-> assert_equal(lines, [term_getline(buf, 1), term_getline(buf, 2)])})\n  \" wait for vim to complete initialization\n  call TermWait(buf)\n\n  \" Get attr of normal(a0), incsearch(a1), hlsearch(a2) highlight\n  call term_sendkeys(buf, \":set incsearch hlsearch\\<cr>\")\n  call term_sendkeys(buf, '/b')\n  call TermWait(buf, 100)\n  let screen_line1 = term_scrape(buf, 1)\n  call assert_true(len(screen_line1) > 2)\n  \" a0: attr_normal\n  let a0 = screen_line1[0].attr\n  \" a1: attr_incsearch\n  let a1 = screen_line1[1].attr\n  \" a2: attr_hlsearch\n  let a2 = screen_line1[2].attr\n  call assert_notequal(a0, a1)\n  call assert_notequal(a0, a2)\n  call assert_notequal(a1, a2)\n  call term_sendkeys(buf, \"\\<cr>gg0\")\n\n  \" Test incremental highlight search\n  call term_sendkeys(buf, \"/vim\")\n  call TermWait(buf, 100)\n  \" Buffer:\n  \" abb vim vim vi\n  \" vimvivim\n  \" Search: /vim\n  let attr_line1 = [a0,a0,a0,a0,a1,a1,a1,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test <C-g>\n  call term_sendkeys(buf, \"\\<C-g>\\<C-g>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a1,a1,a1,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test <C-t>\n  call term_sendkeys(buf, \"\\<C-t>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a1,a1,a1,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Type Enter and a1(incsearch highlight) should become a2(hlsearch highlight)\n  call term_sendkeys(buf, \"\\<cr>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test nohlsearch. a2(hlsearch highlight) should become a0(normal highlight)\n  call term_sendkeys(buf, \":1\\<cr>\")\n  call term_sendkeys(buf, \":set nohlsearch\\<cr>\")\n  call term_sendkeys(buf, \"/vim\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a1,a1,a1,a0,a0,a0,a0,a0,a0,a0]\n  let attr_line2 = [a0,a0,a0,a0,a0,a0,a0,a0]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n  call delete('Xsearch.txt')\n\n  call delete('Xsearch.txt')\n  bwipe!\nendfunc\n\nfunc Test_incsearch_cmdline_modifier()\n  CheckOption incsearch\n\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['foo'])\n  set incsearch\n  \" Test that error E14 does not occur in parsing command modifier.\n  call feedkeys(\"V:tab\", 'tx')\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_incsearch_scrolling()\n  CheckRunVimInTerminal\n  call assert_equal(0, &scrolloff)\n  call writefile([\n\t\\ 'let dots = repeat(\".\", 120)',\n\t\\ 'set incsearch cmdheight=2 scrolloff=0',\n\t\\ 'call setline(1, [dots, dots, dots, \"\", \"target\", dots, dots])',\n\t\\ 'normal gg',\n\t\\ 'redraw',\n\t\\ ], 'Xscript')\n  let buf = RunVimInTerminal('-S Xscript', {'rows': 9, 'cols': 70})\n  \" Need to send one key at a time to force a redraw\n  call term_sendkeys(buf, '/')\n  sleep 100m\n  call term_sendkeys(buf, 't')\n  sleep 100m\n  call term_sendkeys(buf, 'a')\n  sleep 100m\n  call term_sendkeys(buf, 'r')\n  sleep 100m\n  call term_sendkeys(buf, 'g')\n  call VerifyScreenDump(buf, 'Test_incsearch_scrolling_01', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xscript')\nendfunc\n\nfunc Test_incsearch_search_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 8)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ '3',\n\t\\ ], 'Xis_search_script')\n  let buf = RunVimInTerminal('-S Xis_search_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  call term_sendkeys(buf, '/fo')\n  call VerifyScreenDump(buf, 'Test_incsearch_search_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n  sleep 100m\n\n  call term_sendkeys(buf, '/\\v')\n  call VerifyScreenDump(buf, 'Test_incsearch_search_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_search_script')\nendfunc\n\nfunc Test_hlsearch_dump()\n  CheckOption hlsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set hlsearch cursorline',\n        \\ 'call setline(1, [\"xxx\", \"xxx\", \"xxx\"])',\n\t\\ '/.*',\n\t\\ '2',\n\t\\ ], 'Xhlsearch_script')\n  let buf = RunVimInTerminal('-S Xhlsearch_script', {'rows': 6, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_hlsearch_1', {})\n\n  call term_sendkeys(buf, \"/\\\\_.*\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_hlsearch_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlsearch_script')\nendfunc\n\nfunc Test_hlsearch_and_visual()\n  CheckOption hlsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set hlsearch',\n        \\ 'call setline(1, repeat([\"xxx yyy zzz\"], 3))',\n        \\ 'hi Search cterm=bold',\n\t\\ '/yyy',\n\t\\ 'call cursor(1, 6)',\n\t\\ ], 'Xhlvisual_script')\n  let buf = RunVimInTerminal('-S Xhlvisual_script', {'rows': 6, 'cols': 40})\n  call term_sendkeys(buf, \"vjj\")\n  call VerifyScreenDump(buf, 'Test_hlsearch_visual_1', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlvisual_script')\nendfunc\n\nfunc Test_hlsearch_block_visual_match()\n  CheckScreendump\n\n  let lines =<< trim END\n    set hlsearch\n    call setline(1, ['aa', 'bbbb', 'cccccc'])\n  END\n  call writefile(lines, 'Xhlsearch_block')\n  let buf = RunVimInTerminal('-S Xhlsearch_block', {'rows': 9, 'cols': 60})\n\n  call term_sendkeys(buf, \"G\\<C-V>$kk\\<Esc>\")\n  sleep 100m\n  call term_sendkeys(buf, \"/\\\\%V\\<CR>\")\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_hlsearch_block_visual_match', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlsearch_block')\nendfunc\n\nfunc Test_incsearch_substitute()\n  CheckOption incsearch\n\n  call test_override(\"char_avail\", 1)\n  new\n  set incsearch\n  for n in range(1, 10)\n    call setline(n, 'foo ' . n)\n  endfor\n  4\n  call feedkeys(\":.,.+2s/foo\\<BS>o\\<BS>o/xxx\\<cr>\", 'tx')\n  call assert_equal('foo 3', getline(3))\n  call assert_equal('xxx 4', getline(4))\n  call assert_equal('xxx 5', getline(5))\n  call assert_equal('xxx 6', getline(6))\n  call assert_equal('foo 7', getline(7))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_incsearch_substitute_long_line()\n  new\n  call test_override(\"char_avail\", 1)\n  set incsearch\n\n  call repeat('x', 100000)->setline(1)\n  call feedkeys(':s/\\%c', 'xt')\n  redraw\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  call Incsearch_cleanup()\n  bwipe!\nendfunc\n\n\" Similar to Test_incsearch_substitute() but with a screendump halfway.\nfunc Test_incsearch_substitute_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 10)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ 'call setline(11, \"bar 11\")',\n\t\\ '3',\n\t\\ ], 'Xis_subst_script')\n  let buf = RunVimInTerminal('-S Xis_subst_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  \" Select three lines at the cursor with typed pattern.\n  call term_sendkeys(buf, ':.,.+2s/')\n  sleep 100m\n  call term_sendkeys(buf, 'f')\n  sleep 100m\n  call term_sendkeys(buf, 'o')\n  sleep 100m\n  call term_sendkeys(buf, 'o')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Select three lines at the cursor using previous pattern.\n  call term_sendkeys(buf, \"/foo\\<CR>\")\n  sleep 100m\n  call term_sendkeys(buf, ':.,.+2s//')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_02', {})\n\n  \" Deleting last slash should remove the match.\n  call term_sendkeys(buf, \"\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_03', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Reverse range is accepted\n  call term_sendkeys(buf, ':5,2s/foo')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_04', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" White space after the command is skipped\n  call term_sendkeys(buf, ':2,3sub  /fo')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_05', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Command modifiers are skipped\n  call term_sendkeys(buf, ':above below browse botr confirm keepmar keepalt keeppat keepjum filter xxx hide lockm leftabove noau noswap rightbel sandbox silent silent! $tab top unsil vert verbose 4,5s/fo.')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_06', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Cursorline highlighting at match\n  call term_sendkeys(buf, \":set cursorline\\<CR>\")\n  call term_sendkeys(buf, 'G9G')\n  call term_sendkeys(buf, ':9,11s/bar')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_07', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Cursorline highlighting at cursor when no match\n  call term_sendkeys(buf, ':9,10s/bar')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_08', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Only \\v handled as empty pattern, does not move cursor\n  call term_sendkeys(buf, '3G4G')\n  call term_sendkeys(buf, \":nohlsearch\\<CR>\")\n  call term_sendkeys(buf, ':6,7s/\\v')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_09', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, \":set nocursorline\\<CR>\")\n\n  \" All matches are highlighted for 'hlsearch' after the incsearch canceled\n  call term_sendkeys(buf, \"1G*\")\n  call term_sendkeys(buf, \":2,5s/foo\")\n  sleep 100m\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_10', {})\n\n  call term_sendkeys(buf, \":split\\<CR>\")\n  call term_sendkeys(buf, \":let @/ = 'xyz'\\<CR>\")\n  call term_sendkeys(buf, \":%s/.\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_11', {})\n  call term_sendkeys(buf, \"\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_12', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_13', {})\n  call term_sendkeys(buf, \":%bwipe!\\<CR>\")\n  call term_sendkeys(buf, \":only!\\<CR>\")\n\n  \"  get :'<,'>s command in history\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"aasdfasdf\\<Esc>\")\n  call term_sendkeys(buf, \"V:s/a/b/g\\<CR>\")\n  \" Using '<,'> does not give E20\n  call term_sendkeys(buf, \":new\\<CR>\")\n  call term_sendkeys(buf, \"aasdfasdf\\<Esc>\")\n  call term_sendkeys(buf, \":\\<Up>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_14', {})\n  call term_sendkeys(buf, \"<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_script')\nendfunc\n\nfunc Test_incsearch_highlighting()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch',\n\t\\ 'call setline(1, \"hello/there\")',\n\t\\ ], 'Xis_subst_hl_script')\n  let buf = RunVimInTerminal('-S Xis_subst_hl_script', {'rows': 4, 'cols': 20})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 300m\n\n  \" Using a different search delimiter should still highlight matches\n  \" that contain a '/'.\n  call term_sendkeys(buf, \":%s;ello/the\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_15', {})\n  call term_sendkeys(buf, \"<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_hl_script')\nendfunc\n\nfunc Test_incsearch_with_change()\n  CheckFeature timers\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"one\", \"two ------ X\", \"three\"])',\n\t\\ 'call timer_start(200, { _ -> setline(2, \"x\")})',\n\t\\ ], 'Xis_change_script')\n  let buf = RunVimInTerminal('-S Xis_change_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 300m\n\n  \" Highlight X, it will be deleted by the timer callback.\n  call term_sendkeys(buf, ':%s/X')\n  call VerifyScreenDump(buf, 'Test_incsearch_change_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_change_script')\nendfunc\n\n\" Similar to Test_incsearch_substitute_dump() for :sort\nfunc Test_incsearch_sort_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"another one 2\", \"that one 3\", \"the one 1\"])',\n\t\\ ], 'Xis_sort_script')\n  let buf = RunVimInTerminal('-S Xis_sort_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  call term_sendkeys(buf, ':sort ni u /on')\n  call VerifyScreenDump(buf, 'Test_incsearch_sort_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':sort! /on')\n  call VerifyScreenDump(buf, 'Test_incsearch_sort_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_sort_script')\nendfunc\n\n\" Similar to Test_incsearch_substitute_dump() for :vimgrep famiry\nfunc Test_incsearch_vimgrep_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"another one 2\", \"that one 3\", \"the one 1\"])',\n\t\\ ], 'Xis_vimgrep_script')\n  let buf = RunVimInTerminal('-S Xis_vimgrep_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  call term_sendkeys(buf, ':vimgrep on')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':vimg /on/ *.txt')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':vimgrepadd \"\\<on')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_03', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':lv \"tha')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_04', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':lvimgrepa \"the\" **/*.txt')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_05', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_vimgrep_script')\nendfunc\n\nfunc Test_keep_last_search_pattern()\n  CheckOption incsearch\n\n  new\n  call setline(1, ['foo', 'foo', 'foo'])\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  let @/ = 'bar'\n  call feedkeys(\":/foo/s//\\<Esc>\", 'ntx')\n  call assert_equal('bar', @/)\n\n  \" no error message if pattern not found\n  call feedkeys(\":/xyz/s//\\<Esc>\", 'ntx')\n  call assert_equal('bar', @/)\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_word_under_cursor_after_match()\n  CheckOption incsearch\n\n  new\n  call setline(1, 'foo bar')\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  try\n    call feedkeys(\"/foo\\<C-R>\\<C-W>\\<CR>\", 'ntx')\n  catch /E486:/\n  endtry\n  call assert_equal('foobar', @/)\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_subst_word_under_cursor()\n  CheckOption incsearch\n\n  new\n  call setline(1, ['int SomeLongName;', 'for (xxx = 1; xxx < len; ++xxx)'])\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  call feedkeys(\"/LongName\\<CR>\", 'ntx')\n  call feedkeys(\":%s/xxx/\\<C-R>\\<C-W>/g\\<CR>\", 'ntx')\n  call assert_equal('for (SomeLongName = 1; SomeLongName < len; ++SomeLongName)', getline(2))\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_search_undefined_behaviour()\n  CheckFeature terminal\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n  \" did cause an undefined left shift\n  let g:buf = term_start([GetVimProg(), '--clean', '-e', '-s', '-c', 'call search(getline(\".\"))', 'samples/test000'], {'term_rows': 3})\n  call assert_equal([''], getline(1, '$'))\n  call term_sendkeys(g:buf, \":qa!\\<cr>\")\n  bwipe!\nendfunc\n\nfunc Test_search_undefined_behaviour2()\n  call search(\"\\%UC0000000\")\nendfunc\n\n\" Test for search('multi-byte char', 'bce')\nfunc Test_search_multibyte()\n  let save_enc = &encoding\n  set encoding=utf8\n  enew!\n  call append('$', '\uff21')\n  call cursor(2, 1)\n  call assert_equal(2, search('\uff21', 'bce', line('.')))\n  enew!\n  let &encoding = save_enc\nendfunc\n\n\" This was causing E874.  Also causes an invalid read?\nfunc Test_look_behind()\n  new\n  call setline(1, '0\\|\\&\\n\\@<=')\n  call search(getline(\".\"))\n  bwipe!\nendfunc\n\nfunc Test_search_visual_area_linewise()\n  new\n  call setline(1, ['aa', 'bb', 'cc'])\n  exe \"normal 2GV\\<Esc>\"\n  for engine in [1, 2]\n    exe 'set regexpengine=' .. engine\n    exe \"normal gg/\\\\%'<\\<CR>>\"\n    call assert_equal([0, 2, 1, 0, 1], getcurpos(), 'engine ' .. engine)\n    exe \"normal gg/\\\\%'>\\<CR>\"\n    call assert_equal([0, 2, 2, 0, 2], getcurpos(), 'engine ' .. engine)\n  endfor\n\n  bwipe!\n  set regexpengine&\nendfunc\n\nfunc Test_search_sentence()\n  new\n  \" this used to cause a crash\n  /\\%'(\n  /\n  bwipe\nendfunc\n\n\" Test that there is no crash when there is a last search pattern but no last\n\" substitute pattern.\nfunc Test_no_last_substitute_pat()\n  \" Use viminfo to set the last search pattern to a string and make the last\n  \" substitute pattern the most recent used and make it empty (NULL).\n  call writefile(['~MSle0/bar', '~MSle0~&'], 'Xviminfo')\n  rviminfo! Xviminfo\n  call assert_fails('normal n', 'E35:')\n\n  call delete('Xviminfo')\nendfunc\n\nfunc Test_search_Ctrl_L_combining()\n  \" Make sure, that Ctrl-L works correctly with combining characters.\n  \" It uses an artificial example of an 'a' with 4 combining chars:\n    \" 'a' U+0061 Dec:97 LATIN SMALL LETTER A &#x61; /\\%u61\\Z \"\\u0061\"\n    \" ' \u0300' U+0300 Dec:768 COMBINING GRAVE ACCENT &#x300; /\\%u300\\Z \"\\u0300\"\n    \" ' \u0301' U+0301 Dec:769 COMBINING ACUTE ACCENT &#x301; /\\%u301\\Z \"\\u0301\"\n    \" ' \u0307' U+0307 Dec:775 COMBINING DOT ABOVE &#x307; /\\%u307\\Z \"\\u0307\"\n    \" ' \u0323' U+0323 Dec:803 COMBINING DOT BELOW &#x323; /\\%u323 \"\\u0323\"\n  \" Those should also appear on the commandline\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  let bufcontent = ['', 'Mia\u0300\u0301\u0307\u0323m']\n  call append('$', bufcontent)\n  call feedkeys(\"/Mi\\<c-l>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(5, line('.'))\n  call assert_equal(bufcontent[1], @/)\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_large_hex_chars1()\n  \" This used to cause a crash, the character becomes an NFA state.\n  try\n    /\\%Ufffffc23\n  catch\n    call assert_match('E678:', v:exception)\n  endtry\n  try\n    set re=1\n    /\\%Ufffffc23\n  catch\n    call assert_match('E678:', v:exception)\n  endtry\n  set re&\nendfunc\n\nfunc Test_large_hex_chars2()\n  \" This used to cause a crash, the character becomes an NFA state.\n  try\n    /[\\Ufffffc1f]\n  catch\n    call assert_match('E486:', v:exception)\n  endtry\n  try\n    set re=1\n    /[\\Ufffffc1f]\n  catch\n    call assert_match('E486:', v:exception)\n  endtry\n  set re&\nendfunc\n\nfunc Test_one_error_msg()\n  \" This was also giving an internal error\n  call assert_fails('call search(\" \\\\((\\\\v[[=P=]]){185}+             \")', 'E871:')\nendfunc\n\nfunc Test_incsearch_add_char_under_cursor()\n  CheckOption incsearch\n\n  set incsearch\n  new\n  call setline(1, ['find match', 'anything'])\n  1\n  call test_override('char_avail', 1)\n  call feedkeys(\"fc/m\\<C-L>\\<C-L>\\<C-L>\\<C-L>\\<C-L>\\<CR>\", 'tx')\n  call assert_equal('match', @/)\n  call test_override('char_avail', 0)\n\n  set incsearch&\n  bwipe!\nendfunc\n\n\" Test for the search() function with match at the cursor position\nfunc Test_search_match_at_curpos()\n  new\n  call append(0, ['foobar', '', 'one two', ''])\n\n  normal gg\n\n  eval 'foobar'->search('c')\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  normal j\n  call search('^$', 'c')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call search('^$', 'bc')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  exe \"normal /two\\<CR>\"\n  call search('.', 'c')\n  call assert_equal([3, 5], [line('.'), col('.')])\n\n  close!\nendfunc\n\n\" Test for error cases with the search() function\nfunc Test_search_errors()\n  call assert_fails(\"call search('pat', [])\", 'E730:')\n  call assert_fails(\"call search('pat', 'b', {})\", 'E728:')\n  call assert_fails(\"call search('pat', 'b', 1, [])\", 'E745:')\n  call assert_fails(\"call search('pat', 'ns')\", 'E475:')\n  call assert_fails(\"call search('pat', 'mr')\", 'E475:')\n\n  new\n  call setline(1, ['foo', 'bar'])\n  call assert_fails('call feedkeys(\"/foo/;/bar/;\\<CR>\", \"tx\")', 'E386:')\n  bwipe!\nendfunc\n\nfunc Test_search_display_pattern()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n\n  call cursor(1, 1)\n  let @/ = 'foo'\n  let pat = @/->escape('()*?'. '\\s\\+')\n  let g:a = execute(':unsilent :norm! n')\n  call assert_match(pat, g:a)\n\n  \" right-left\n  if exists(\"+rightleft\")\n    set rl\n    call cursor(1, 1)\n    let @/ = 'foo'\n    let pat = 'oof/\\s\\+'\n    let g:a = execute(':unsilent :norm! n')\n    call assert_match(pat, g:a)\n    set norl\n  endif\nendfunc\n\nfunc Test_searchdecl()\n  let lines =<< trim END\n     int global;\n\n     func()\n     {\n       int global;\n       if (cond) {\n\t int local;\n       }\n       int local;\n       // comment\n     }\n  END\n  new\n  call setline(1, lines)\n  10\n  call assert_equal(0, searchdecl('local', 0, 0))\n  call assert_equal(7, getcurpos()[1])\n\n  10\n  call assert_equal(0, 'local'->searchdecl(0, 1))\n  call assert_equal(9, getcurpos()[1])\n\n  10\n  call assert_equal(0, searchdecl('global'))\n  call assert_equal(5, getcurpos()[1])\n\n  10\n  call assert_equal(0, searchdecl('global', 1))\n  call assert_equal(1, getcurpos()[1])\n\n  bwipe!\nendfunc\n\nfunc Test_search_special()\n  \" this was causing illegal memory access and an endless loop\n  set t_PE=\n  exe \"norm /\\x80PS\"\nendfunc\n\n\" Test for command failures when the last search pattern is not set.\n\" Need to run this in a new vim instance where last search pattern is not set.\nfunc Test_search_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails(\"normal i\\<C-R>/\\e\", 'E35:')\n    call assert_fails(\"exe '/'\", 'E35:')\n    call assert_fails(\"exe '?'\", 'E35:')\n    call assert_fails(\"/\", 'E35:')\n    call assert_fails(\"?\", 'E35:')\n    call assert_fails(\"normal n\", 'E35:')\n    call assert_fails(\"normal N\", 'E35:')\n    call assert_fails(\"normal gn\", 'E35:')\n    call assert_fails(\"normal gN\", 'E35:')\n    call assert_fails(\"normal cgn\", 'E35:')\n    call assert_fails(\"normal cgN\", 'E35:')\n    let p = []\n    let p = @/\n    call assert_equal('', p)\n    call assert_fails(\"normal :\\<C-R>/\", 'E35:')\n    call assert_fails(\"//p\", 'E35:')\n    call assert_fails(\";//p\", 'E35:')\n    call assert_fails(\"??p\", 'E35:')\n    call assert_fails(\";??p\", 'E35:')\n    call assert_fails('g//p', ['E35:', 'E476:'])\n    call assert_fails('v//p', ['E35:', 'E476:'])\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for using tilde (~) atom in search. This should use the last used\n\" substitute pattern\nfunc Test_search_tilde_pat()\n  let lines =<< trim [SCRIPT]\n    set regexpengine=1\n    call assert_fails('exe \"normal /~\\<CR>\"', 'E33:')\n    call assert_fails('exe \"normal ?~\\<CR>\"', 'E33:')\n    set regexpengine=2\n    call assert_fails('exe \"normal /~\\<CR>\"', ['E33:', 'E383:'])\n    call assert_fails('exe \"normal ?~\\<CR>\"', ['E33:', 'E383:'])\n    set regexpengine&\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for searching a pattern that is not present with 'nowrapscan'\nfunc Test_search_pat_not_found()\n  new\n  set nowrapscan\n  let @/ = '1abcxyz2'\n  call assert_fails('normal n', 'E385:')\n  call assert_fails('normal N', 'E384:')\n  set wrapscan&\n  close\nendfunc\n\n\" Test for v:searchforward variable\nfunc Test_searchforward_var()\n  new\n  call setline(1, ['foo', '', 'foo'])\n  call cursor(2, 1)\n  let @/ = 'foo'\n  let v:searchforward = 0\n  normal N\n  call assert_equal(3, line('.'))\n  call cursor(2, 1)\n  let v:searchforward = 1\n  normal N\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Test for invalid regular expressions\nfunc Test_invalid_regexp()\n  set regexpengine=1\n  call assert_fails(\"call search(repeat('\\\\(.\\\\)', 10))\", 'E51:')\n  call assert_fails(\"call search('\\\\%(')\", 'E53:')\n  call assert_fails(\"call search('\\\\(')\", 'E54:')\n  call assert_fails(\"call search('\\\\)')\", 'E55:')\n  call assert_fails(\"call search('x\\\\@#')\", 'E59:')\n  call assert_fails('call search(''\\v%(%(%(%(%(%(%(%(%(%(%(a){1}){1}){1}){1}){1}){1}){1}){1}){1}){1}){1}'')', 'E60:')\n  call assert_fails(\"call search('a\\\\+*')\", 'E61:')\n  call assert_fails(\"call search('\\\\_m')\", 'E63:')\n  call assert_fails(\"call search('\\\\+')\", 'E64:')\n  call assert_fails(\"call search('\\\\1')\", 'E65:')\n  call assert_fails(\"call search('\\\\z\\\\(\\\\)')\", 'E66:')\n  call assert_fails(\"call search('\\\\z2')\", 'E67:')\n  call assert_fails(\"call search('\\\\zx')\", 'E68:')\n  call assert_fails(\"call search('\\\\%[ab')\", 'E69:')\n  call assert_fails(\"call search('\\\\%[]')\", 'E70:')\n  call assert_fails(\"call search('\\\\%a')\", 'E71:')\n  call assert_fails(\"call search('ab\\\\%[\\\\(cd\\\\)]')\", 'E369:')\n  call assert_fails(\"call search('ab\\\\%[\\\\%(cd\\\\)]')\", 'E369:')\n  set regexpengine=2\n  call assert_fails(\"call search('\\\\_')\", 'E865:')\n  call assert_fails(\"call search('\\\\+')\", 'E866:')\n  call assert_fails(\"call search('\\\\zx')\", 'E867:')\n  call assert_fails(\"call search('\\\\%a')\", 'E867:')\n  call assert_fails(\"call search('x\\\\@#')\", 'E869:')\n  call assert_fails(\"call search(repeat('\\\\(.\\\\)', 10))\", 'E872:')\n  call assert_fails(\"call search('\\\\_m')\", 'E877:')\n  call assert_fails(\"call search('\\\\%(')\", 'E53:')\n  call assert_fails(\"call search('\\\\(')\", 'E54:')\n  call assert_fails(\"call search('\\\\)')\", 'E55:')\n  call assert_fails(\"call search('\\\\z\\\\(\\\\)')\", 'E66:')\n  call assert_fails(\"call search('\\\\%[ab')\", 'E69:')\n  call assert_fails(\"call search('\\\\%[]')\", 'E70:')\n  call assert_fails(\"call search('\\\\%9999999999999999999999999999v')\", 'E951:')\n  set regexpengine&\n  call assert_fails(\"call search('\\\\%#=3ab')\", 'E864:')\nendfunc\n\n\" Test for searching a very complex pattern in a string. Should switch the\n\" regexp engine from NFA to the old engine.\nfunc Test_regexp_switch_engine()\n  let l = readfile('samples/re.freeze.txt')\n  let v = substitute(l[4], '..\\@<!', '', '')\n  call assert_equal(l[4], v)\nendfunc\n\n\" Test for the \\%V atom to search within visually selected text\nfunc Test_search_in_visual_area()\n  new\n  call setline(1, ['foo bar1', 'foo bar2', 'foo bar3', 'foo bar4'])\n  exe \"normal 2GVjo/\\\\%Vbar\\<CR>\\<Esc>\"\n  call assert_equal([2, 5], [line('.'), col('.')])\n  exe \"normal 2GVj$?\\\\%Vbar\\<CR>\\<Esc>\"\n  call assert_equal([3, 5], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for searching with 'smartcase' and 'ignorecase'\nfunc Test_search_smartcase()\n  new\n  call setline(1, ['', 'Hello'])\n  set noignorecase nosmartcase\n  call assert_fails('exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"', 'E486:')\n\n  set ignorecase nosmartcase\n  exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call cursor(1, 1)\n  set ignorecase smartcase\n  call assert_fails('exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"', 'E486:')\n\n  exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)o\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  \" Test for using special atoms with 'smartcase'\n  call setline(1, ['', '    Hello\\ '])\n  call cursor(1, 1)\n  call feedkeys('/\\_.\\%(\\uello\\)\\' .. \"\\<CR>\", 'xt')\n  call assert_equal([2, 4], [line('.'), col('.')])\n\n  set ignorecase& smartcase&\n  close!\nendfun\n\n\" Test 'smartcase' with utf-8.\nfunc Test_search_smartcase_utf8()\n  new\n  let save_enc = &encoding\n  set encoding=utf8 ignorecase smartcase\n\n  call setline(1, 'Caf\u00e9 caf\u00c9')\n  1s/caf\u00e9/x/g\n  call assert_equal('x x', getline(1))\n\n  call setline(1, 'Caf\u00e9 caf\u00c9')\n  1s/caf\u00c9/x/g\n  call assert_equal('Caf\u00e9 x', getline(1))\n\n  set ignorecase& smartcase&\n  let &encoding = save_enc\n  close!\nendfunc\n\n\" Test searching past the end of a file\nfunc Test_search_past_eof()\n  new\n  call setline(1, ['Line'])\n  exe \"normal /\\\\n\\\\zs\\<CR>\"\n  call assert_equal([1, 4], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for various search offsets\nfunc Test_search_offset()\n  \" With /e, for a match in the first column of a line, the cursor should be\n  \" placed at the end of the previous line.\n  new\n  call setline(1, ['one two', 'three four'])\n  call search('two\\_.', 'e')\n  call assert_equal([1, 7], [line('.'), col('.')])\n\n  \" with cursor at the beginning of the file, use /s+1\n  call cursor(1, 1)\n  exe \"normal /two/s+1\\<CR>\"\n  call assert_equal([1, 6], [line('.'), col('.')])\n\n  \" with cursor at the end of the file, use /e-1\n  call cursor(2, 10)\n  exe \"normal ?three?e-1\\<CR>\"\n  call assert_equal([2, 4], [line('.'), col('.')])\n\n  \" line offset - after the last line\n  call cursor(1, 1)\n  exe \"normal /three/+1\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  \" line offset - before the first line\n  call cursor(2, 1)\n  exe \"normal ?one?-1\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" character offset - before the first character in the file\n  call cursor(2, 1)\n  exe \"normal ?one?s-1\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n  call cursor(2, 1)\n  exe \"normal ?one?e-3\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" character offset - after the last character in the file\n  call cursor(1, 1)\n  exe \"normal /four/s+4\\<CR>\"\n  call assert_equal([2, 10], [line('.'), col('.')])\n  call cursor(1, 1)\n  exe \"normal /four/e+1\\<CR>\"\n  call assert_equal([2, 10], [line('.'), col('.')])\n\n  close!\nendfunc\n\n\" Test for searching for matching parenthesis using %\nfunc Test_search_match_paren()\n  new\n  call setline(1, \"abc(def')'ghi'('jk'\\\\t'lm)no\")\n  \" searching for a matching parenthesis should skip single quoted characters\n  call cursor(1, 4)\n  normal %\n  call assert_equal([1, 25], [line('.'), col('.')])\n  normal %\n  call assert_equal([1, 4], [line('.'), col('.')])\n  call cursor(1, 5)\n  normal ])\n  call assert_equal([1, 25], [line('.'), col('.')])\n  call cursor(1, 24)\n  normal [(\n  call assert_equal([1, 4], [line('.'), col('.')])\n\n  \" matching parenthesis in 'virtualedit' mode with cursor after the eol\n  call setline(1, 'abc(defgh)')\n  set virtualedit=all\n  normal 20|%\n  call assert_equal(4, col('.'))\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for searching a pattern and stopping before a specified line\nfunc Test_search_stopline()\n  new\n  call setline(1, ['', '', '', 'vim'])\n  call assert_equal(0, search('vim', 'n', 3))\n  call assert_equal(4, search('vim', 'n', 4))\n  call setline(1, ['vim', '', '', ''])\n  call cursor(4, 1)\n  call assert_equal(0, search('vim', 'bn', 2))\n  call assert_equal(1, search('vim', 'bn', 1))\n  close!\nendfunc\n\nfunc Test_incsearch_highlighting_newline()\n  CheckRunVimInTerminal\n  CheckOption incsearch\n  CheckScreendump\n  new\n  call test_override(\"char_avail\", 1)\n\n  let commands =<< trim [CODE]\n    set incsearch nohls\n    call setline(1, ['test', 'xxx'])\n  [CODE]\n  call writefile(commands, 'Xincsearch_nl')\n  let buf = RunVimInTerminal('-S Xincsearch_nl', {'rows': 5, 'cols': 10})\n  call term_sendkeys(buf, '/test')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline1', {})\n  \" Need to send one key at a time to force a redraw\n  call term_sendkeys(buf, '\\n')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline2', {})\n  call term_sendkeys(buf, 'x')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline3', {})\n  call term_sendkeys(buf, 'x')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline4', {})\n  call term_sendkeys(buf, \"\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_newline5', {})\n  call StopVimInTerminal(buf)\n\n  \" clean up\n  call delete('Xincsearch_nl')\n  call test_override(\"char_avail\", 0)\n  bw\nendfunc\n\nfunc Test_incsearch_substitute_dump2()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 4)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ 'call setline(5, \"abc|def\")',\n\t\\ '3',\n\t\\ ], 'Xis_subst_script2')\n  let buf = RunVimInTerminal('-S Xis_subst_script2', {'rows': 9, 'cols': 70})\n\n  call term_sendkeys(buf, ':%s/\\vabc|')\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_incsearch_sub_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" The following should not be highlighted\n  call term_sendkeys(buf, ':1,5s/\\v|')\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_incsearch_sub_02', {})\n\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_script2')\nendfunc\n\nfunc Test_pattern_is_uppercase_smartcase()\n  new\n  let input=['abc', 'ABC', 'Abc', 'abC']\n  call setline(1, input)\n  call cursor(1,1)\n  \" default, matches firstline\n  %s/abc//g\n  call assert_equal(['', 'ABC', 'Abc', 'abC'],\n        \\ getline(1, '$'))\n\n  set smartcase ignorecase\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  \" with smartcase and incsearch set, matches everything\n  %s/abc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  \" with smartcase and incsearch set and found an uppercase letter,\n  \" match only that.\n  %s/abC//g\n  call assert_equal(['abc', 'ABC', 'Abc', ''],\n        \\ getline(1, '$'))\n\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\%V should not be detected as uppercase letter\n  %s/\\%Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\v%V should not be detected as uppercase letter\n  %s/\\v%Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\v%VabC should be detected as uppercase letter\n  %s/\\v%VabC//g\n  call assert_equal(['abc', 'ABC', 'Abc', ''],\n        \\ getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  \" \\Vabc should match everything\n  %s/\\Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input + ['_abc'])\n  \" _ matches normally\n  %s/\\v_.*//g\n  call assert_equal(['abc', 'ABC', 'Abc', 'abC', ''], getline(1, '$'))\n\n  set smartcase& ignorecase&\n  bw!\nendfunc\n\nfunc Test_no_last_search_pattern()\n  CheckOption incsearch\n\n  let @/ = \"\"\n  set incsearch\n  \" these were causing a crash\n  call feedkeys(\"//\\<C-G>\", 'xt')\n  call feedkeys(\"//\\<C-T>\", 'xt')\n  call feedkeys(\"??\\<C-G>\", 'xt')\n  call feedkeys(\"??\\<C-T>\", 'xt')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX)\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_stop(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_unlockvar\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_JUMPLIST\n# define ex_jumps\t\tex_ni\n# define ex_clearjumps\t\tex_ni\n# define ex_changes\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = NORMAL;\n    trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t\temsg(_(\"E501: At end-of-file\"));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    --RedrawingDisabled;\n    --no_wait_return;\n    update_screen(CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_endfor));\n\t    else\n\t\temsg(_(e_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw()\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(\"E605: Exception not caught: %s\"),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, options);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROT)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n#endif\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n#if (_MSC_VER == 1200)\n/*\n * Avoid optimisation bug in VC++ version 6.0\n */\n #pragma optimize( \"g\", off )\n#endif\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tmay_have_range;\n    int\t\tvim9script;\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n#ifdef FEAT_EVAL\n    vim9script = in_vim9script();\n#endif\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n#ifdef FEAT_EVAL\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n#endif\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n#endif\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    ea.cmd = cmd;\n#ifdef FEAT_EVAL\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else\n#endif\n\tif (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t    goto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\tif ((*ea.cmd == '|' || (exmode_active && ea.line1 != ea.line2))\n#ifdef FEAT_EVAL\n\t\t&& !vim9script\n#endif\n\t   )\n\t{\n\t    ea.cmdidx = CMD_print;\n\t    ea.argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\t    if ((errormsg = invalid_range(&ea)) == NULL)\n\t    {\n\t\tcorrect_range(&ea);\n\t\tex_print(&ea);\n\t    }\n\t}\n\telse if (ea.addr_count != 0)\n\t{\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// With '-' in 'cpoptions' a line number past the file is an\n\t\t// error, otherwise put it at the end of the file.\n\t\tif (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\t    ea.line2 = -1;\n\t\telse\n\t\t    ea.line2 = curbuf->b_ml.ml_line_count;\n\t    }\n\n\t    if (ea.line2 < 0)\n\t\terrormsg = _(e_invalid_range);\n\t    else\n\t    {\n\t\tif (ea.line2 == 0)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = ea.line2;\n\t\tbeginline(BL_SOL | BL_FIX);\n\t    }\n\t}\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(\"E492: Not an editor command\"));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(\"E981: Command not allowed in rvim\");\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n#endif\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    // no range allowed\n\t    errormsg = _(e_norange);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\t// no <!> allowed\n    {\n\terrormsg = _(e_nobang);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(\"E493: Backwards range given\");\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invarg);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(\"E494: Use w or w>>\");\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n')\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalidreg);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_zerocount);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    ea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_arg, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argreq);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if (ea.argt & EX_XFILE)\n    {\n\tif (expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\t    goto doend;\n    }\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\tea.errmsg = NULL;\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (getline_equal(ea.getline, ea.cookie, getsourceline)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif (sourcing)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n#if (_MSC_VER == 1200)\n #pragma optimize( \"\", on )\n#endif\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !isalpha((*pp)[i])\n\t\t\t   && (*pp)[i] != '_' && (!noparen || (*pp)[i] != '('))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *p;\n    int\t    starts_with_colon = FALSE;\n\n    CLEAR_POINTER(cmod);\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty line works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    eap->cmd = (char_u *)\"+\";\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (in_vim9script())\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = p; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (vim_strchr((char_u *)\".=\", *n) != NULL\n\t\t    || *s == '['\n\t\t    || (*n != NUL && n[1] == '='))\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t\t\t|| *p == NUL || ends_excmd(*p))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (in_vim9script() && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd);\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 1;\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose != 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    return FAIL;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\treturn FAIL;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    return FAIL;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    return OK;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff < IOSIZE - 7)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if (p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.' && (ASCII_ISALPHA(p[1])\n\t\t\t\t\t\t\t     || p[1] == '_'))))\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| eap->skip\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize using a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] == p[1] && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     * Exceptions:\n     * - The 'k' command can directly be followed by any character.\n     *   But it is not used in Vim9 script.\n     * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n     *\t    but :sre[wind] is another command, as are :scr[iptnames],\n     *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n     * - the \"d\" command can directly be followed by 'l' or 'p' flag.\n     */\n    p = eap->cmd;\n    if (!vim9 && *p == 'k')\n    {\n\teap->cmdidx = CMD_k;\n\t++p;\n    }\n    else if (!vim9\n\t    && p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\teap->cmdidx = CMD_substitute;\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL\n\t\t\t   && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// Not not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T  ea;\n    char_u   *name;\n    char_u   *p;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    name = argvars[0].vval.v_string;\n    if (name == NULL)\n\treturn;\n\n    while (*name != NUL && *name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\treturn;\n    if (in_vim9script())\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    return;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    for (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t    idx = (cmdidx_T)((int)idx + 1))\n\tif (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t    break;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_norange));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t\tn = getdigits(&cmd);\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t&& address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t    lnum += n;\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(_(\"INTERNAL: Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\"));\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(\"E319: Sorry, the command is not available in this version\");\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t\t errormsgp, &escaped);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n */\n    void\nseparate_nextcmd(exarg_T *eap)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if (eap->argt & (EX_CTRLV | EX_XFILE))\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tSTRMOVE(p - 1, p);\t// remove the '\\'\n\t\t--p;\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_arg, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\tcomment_char = '#';\n#endif\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n#endif\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(\"E173: %d more file to edit\",\n\t\t\t\"E173: %d more files to edit\", n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn;\n    }\n# endif\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn;\n\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n#endif\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (win == aucmd_win)\n    {\n\temsg(_(e_autocmd_close));\n\treturn;\n    }\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(buf, FALSE);\n\t    if (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\treturn;\n\t    need_hide = FALSE;\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invargval, eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    emsg(_(\"E784: Cannot close last tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\ttp = find_tabpage(tab_number);\n\t\tif (tp == NULL)\n\t\t{\n\t\t    beep_flush();\n\t\t    return;\n\t\t}\n\t\tif (tp != curtab)\n\t\t{\n\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t    return;\n\t\t}\n\t\telse if (!text_locked() && !curbuf_locked())\n\t\t    tabpage_close(eap->forceit);\n\t    }\n\t}\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    msg(_(\"Already only one tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\tgoto_tabpage(tab_number);\n\t\t// Repeat this up to a 1000 times, because autocommands may\n\t\t// mess up the lists.\n\t\tfor (done = 0; done < 1000; ++done)\n\t\t{\n\t\t    FOR_ALL_TABPAGES(tp)\n\t\t\tif (tp->tp_topframe != topframe)\n\t\t\t{\n\t\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t\t    // if we failed to close it quit\n\t\t\t    if (valid_tabpage(tp))\n\t\t\t\tdone = 1000;\n\t\t\t    // start over, \"tp\" is now invalid\n\t\t\t    break;\n\t\t\t}\n\t\t    if (first_tabpage->tp_next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n    int\t\th = tabline_height();\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    win_T   *wp;\n    int\t    wnr;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (!eap->skip)\n    {\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tif (eap->addr_count == 0)\n\t    win_close(curwin, FALSE);\t// don't free buffer\n\telse\n\t{\n\t    int\twinnr = 0;\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t    {\n\t\twinnr++;\n\t\tif (winnr == eap->line2)\n\t\t    break;\n\t    }\n\t    if (win == NULL)\n\t\twin = lastwin;\n\t    win_close(win, FALSE);\n\t}\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    static void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (!check_restricted())\n    {\n\tif (!eap->forceit)\n\t    autowrite_all();\n\tapply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n\twindgoto((int)Rows - 1, 0);\n\tout_char('\\n');\n\tout_flush();\n\tstoptermcap();\n\tout_flush();\t\t// needed for SUN to restore xterm buffer\n#ifdef FEAT_TITLE\n\tmch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n#endif\n\tui_suspend();\t\t// call machine specific function\n#ifdef FEAT_TITLE\n\tmaketitle();\n\tresettitle();\t\t// force updating the title\n#endif\n\tstarttermcap();\n\tscroll_start();\t\t// scroll screen before redrawing\n\tredraw_later_clear();\n\tshell_resized();\t// may have resized window\n\tapply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n    }\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_emptybuf));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = _(e_invalid_command);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\n    char_u\t*fname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n#ifdef FEAT_SEARCHPATH\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else\n# endif\n#endif\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\n# if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\ntheend:\n    vim_free(fname);\n# endif\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invarg2, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screenmode));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win((int)n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win((int)n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    int\t\tcount;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t\t\t\t      TRUE, curbuf->b_ffname);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t\t\t\t     FALSE, curbuf->b_ffname);\n\t}\n    }\n\n    if (fname != NULL)\n    {\n\teap->arg = fname;\n#endif\n\tdo_exedit(eap, NULL);\n#ifdef FEAT_SEARCHPATH\n\tvim_free(fname);\n    }\n#endif\n}\n\n/*\n * \":open\" simulation: for now just work like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tint\trd = RedrawingDisabled;\n\t\tint\tnwr = no_wait_return;\n\t\tint\tms = msg_scroll;\n#ifdef FEAT_GUI\n\t\tint\the = hold_gui_events;\n#endif\n\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tRedrawingDisabled = 0;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\thold_gui_events = 0;\n#endif\n\t\tmust_redraw = CLEAR;\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = rd;\n\t\tno_wait_return = nwr;\n\t\tmsg_scroll = ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit an new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"curbuf_lock\" is set.  Only \":edit\"\n\t// can bring us here, others are stopped earlier.\n\tif (*eap->arg != NUL && curbuf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n#ifdef FEAT_TITLE\n\tn = curwin->w_arg_idx_invalid;\n#endif\n\tcheck_arg_idx(curwin);\n#ifdef FEAT_TITLE\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n#endif\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n    else\n    {\n\tif (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\t    return;\n\n#ifdef FEAT_BROWSE\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    char_u *browseFile;\n\n\t    browseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t    if (browseFile != NULL)\n\t    {\n\t\ti = readfile(browseFile, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t\tvim_free(browseFile);\n\t    }\n\t    else\n\t\ti = OK;\n\t}\n\telse\n#endif\n\t     if (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n\tif (i != OK)\n\t{\n#if defined(FEAT_EVAL)\n\t    if (!aborting())\n#endif\n\t\tsemsg(_(e_notopen), eap->arg);\n\t}\n\telse\n\t{\n\t    if (empty && exmode_active)\n\t    {\n\t\t// Delete the empty line that remains.  Historically ex does\n\t\t// this but vi doesn't.\n\t\tif (eap->line2 == 0)\n\t\t    lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    lnum = 1;\n\t\tif (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t\t{\n\t\t    ml_delete(lnum);\n\t\t    if (curwin->w_cursor.lnum > 1\n\t\t\t\t\t     && curwin->w_cursor.lnum >= lnum)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t    deleted_lines_mark(lnum, 1L);\n\t\t}\n\t    }\n\t    redraw_curbuf_later(VALID);\n\t}\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    shorten_fnames(TRUE);\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*tofree;\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    int\t\tretval = FALSE;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(\"E186: No previous directory\"));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Free the previous directory\n    tofree = get_prevdir(scope);\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n    if (scope == CDSCOPE_WINDOW)\n\tcurwin->w_prevdir = pdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tcurtab->tp_prevdir = pdir;\n    else\n\tprev_dir = pdir;\n\n#if defined(UNIX) || defined(VMS)\n    // for UNIX \":cd\" means: go to home directory\n    if (*new_dir == NUL)\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n#endif\n    dir_differs = new_dir == NULL || pdir == NULL\n\t|| pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (new_dir == NULL || (dir_differs && vim_chdir(new_dir)))\n\temsg(_(e_failed));\n    else\n    {\n\tchar_u  *acmd_fname;\n\n\tpost_chdir(scope);\n\n\tif (dir_differs)\n\t{\n\t    if (scope == CDSCOPE_WINDOW)\n\t\tacmd_fname = (char_u *)\"window\";\n\t    else if (scope == CDSCOPE_TABPAGE)\n\t\tacmd_fname = (char_u *)\"tabpage\";\n\t    else\n\t\tacmd_fname = (char_u *)\"global\";\n\t    apply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE,\n\t\t\t\t\t\t\t\tcurbuf);\n\t}\n\tretval = TRUE;\n    }\n    vim_free(tofree);\n\n    return retval;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory\n    if (*new_dir == NUL)\n\tex_pwd(NULL);\n    else\n#endif\n    {\n\tcdscope_T\tscope = CDSCOPE_GLOBAL;\n\n\tif (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\t    scope = CDSCOPE_WINDOW;\n\telse if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\t    scope = CDSCOPE_TABPAGE;\n\n\tif (changedir_func(new_dir, eap->forceit, scope))\n\t{\n\t    // Echo the new current directory if the command was typed.\n\t    if (KeyTyped || p_verbose >= 5)\n\t\tex_pwd(eap);\n\t}\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(\"E187: Unknown\"));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto((int)n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invarg2), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n        cursor_sleep();\n    else\n        cursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n        cursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invarg2), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(\"E465: :winsize requires two number arguments\"));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invarg));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invarg));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(\"E188: Obtaining window position not implemented for this platform\"));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(\"E466: :winpos requires two number arguments\"));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n    }\n    else\n    {\n\tint\tsave_efr = exec_from_reg;\n\n\texec_from_reg = TRUE;\n\n\t/*\n\t * Execute from the typeahead buffer.\n\t * Continue until the stuff buffer is empty and all added characters\n\t * have been consumed.\n\t */\n\twhile (!stuff_empty() || typebuf.tb_len > prev_len)\n\t    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n\texec_from_reg = save_efr;\n    }\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invarg2), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(\"E930: Cannot use :redir inside execute()\"));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invarg2), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invarg2), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n#ifdef FEAT_TITLE\n    if (need_maketitle)\n\tmaketitle();\n#endif\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    update_screen(VIsual_active ? INVERTED : 0);\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(\"E739: Cannot create directory: %s\"), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_src_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(\"E189: \\\"%s\\\" exists (add ! to override)\"), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(\"E190: Cannot open \\\"%s\\\" for writing\"), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n\temsg(_(e_argreq));\n    else if (eap->arg[1] != NUL)\t// more than one character?\n\tsemsg(_(e_trailing_arg), eap->arg);\n    else\n    {\n\tpos = curwin->w_cursor;\t\t// save curwin->w_cursor\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_WHITE | BL_FIX);\n\tif (setmark(*eap->arg) == FAIL)\t// set mark\n\t    emsg(_(\"E191: Argument must be a letter or forward/backward quote\"));\n\tcurwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n    }\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_secure));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(\"E192: Recursive use of :normal too deep\"));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_arg, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_STACK + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped)\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(\"E809: #< is not available without the +eval feature\");\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(\"E194: No alternate file name to substitute for '#'\");\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n#endif\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(\"E495: no autocommand file name to substitute for \\\"<afile>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(\"E496: no autocommand buffer number to substitute for \\\"<abuf>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(\"E497: no autocommand match name to substitute for \\\"<amatch>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(spec_idx == SPEC_SFILE\n\t\t\t\t\t\t? ESTACK_SFILE : ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = spec_idx == SPEC_SFILE\n\t\t\t? _(\"E498: no :source file name to substitute for \\\"<sfile>\\\"\")\n\t\t\t: _(\"E489: no call stack to substitute for \\\"<stack>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(\"E842: no line number to use for \\\"<slnum>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(\"E961: no line number to use for \\\"<sflnum>\\\"\");\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_usingsid);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (valid != VALID_HEAD + VALID_PATH)\n\t    // xgettext:no-c-format\n\t    *errormsg = _(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\");\n\telse\n\t    *errormsg = _(\"E500: Evaluates to an empty string\");\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value((char_u *)\"selection\", 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value((char_u *)\"selectmode\", 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value((char_u *)\"mousemodel\", 0L, (char_u *)\"popup\", 0);\n\tset_option_value((char_u *)\"keymodel\", 0L,\n\t\t\t\t\t     (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value((char_u *)\"selection\", 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value((char_u *)\"mousemodel\", 0L, (char_u *)\"extend\", 0);\n\tset_option_value((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invarg2), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invarg2), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (!did_filetype)\n    {\n\tchar_u *arg = eap->arg;\n\n\tif (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\t    arg += 9;\n\n\tset_option_value((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n\tif (arg != eap->arg)\n\t    did_filetype = FALSE;\n    }\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n#endif\n", "\" Test for the search command\n\nsource shared.vim\nsource screendump.vim\nsource check.vim\n\nfunc Test_search_cmdline()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])\n  \" Test 1\n  \" CTRL-N / CTRL-P skips through the previous search history\n  set noincsearch\n  :1\n  call feedkeys(\"/foobar\\<cr>\", 'tx')\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('the', @/)\n  call feedkeys(\"/thes\\<C-P>\\<C-P>\\<cr>\", 'tx')\n  call assert_equal('foobar', @/)\n\n  \" Test 2\n  \" Ctrl-G goes from one match to the next\n  \" until the end of the buffer\n  set incsearch nowrapscan\n  :1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  :1\n  \" second match\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n  call assert_equal([0, 0, 0, 0], getpos('\"'))\n  :1\n  \" third match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 2).\"\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  :1\n  \" fourth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 3).\"\\<cr>\", 'tx')\n  call assert_equal('  5 there', getline('.'))\n  :1\n  \" fifth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 4).\"\\<cr>\", 'tx')\n  call assert_equal('  6 their', getline('.'))\n  :1\n  \" sixth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 5).\"\\<cr>\", 'tx')\n  call assert_equal('  7 the', getline('.'))\n  :1\n  \" seventh match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 6).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  :1\n  \" eighth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  :1\n  \" no further match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  call assert_equal([0, 0, 0, 0], getpos('\"'))\n\n  \" Test 3\n  \" Ctrl-G goes from one match to the next\n  \" and continues back at the top\n  set incsearch wrapscan\n  :1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  :1\n  \" second match\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n  :1\n  \" third match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 2).\"\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  :1\n  \" fourth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 3).\"\\<cr>\", 'tx')\n  call assert_equal('  5 there', getline('.'))\n  :1\n  \" fifth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 4).\"\\<cr>\", 'tx')\n  call assert_equal('  6 their', getline('.'))\n  :1\n  \" sixth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 5).\"\\<cr>\", 'tx')\n  call assert_equal('  7 the', getline('.'))\n  :1\n  \" seventh match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 6).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  :1\n  \" eighth match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  :1\n  \" back at first match\n  call feedkeys(\"/the\".repeat(\"\\<C-G>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n\n  \" Test 4\n  \" CTRL-T goes to the previous match\n  set incsearch nowrapscan\n  $\n  \" first match\n  call feedkeys(\"?the\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" first match\n  call feedkeys(\"?the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" second match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 1).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n\n  \" Test 5\n  \" CTRL-T goes to the previous match\n  set incsearch wrapscan\n  $\n  \" first match\n  call feedkeys(\"?the\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  $\n  \" first match at the top\n  call feedkeys(\"?the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" second match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 1).\"\\<cr>\", 'tx')\n  call assert_equal('  8 them', getline('.'))\n  $\n  \" last match\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 7).\"\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  $\n  \" back at the bottom of the buffer\n  call feedkeys(\"?the\".repeat(\"\\<C-T>\", 8).\"\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n\n  \" Test 6\n  \" CTRL-L adds to the search pattern\n  set incsearch wrapscan\n  1\n  \" first match\n  call feedkeys(\"/the\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to next match of 'thes'\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  1\n  \" wrap around\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" wrap around\n  set nowrapscan\n  call feedkeys(\"/the\\<c-l>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n\n  \" Test 7\n  \" <bs> remove from match, but stay at current match\n  set incsearch wrapscan\n  1\n  \" first match\n  call feedkeys(\"/thei\\<cr>\", 'tx')\n  call assert_equal('  4 their', getline('.'))\n  1\n  \" delete one char, add another\n  call feedkeys(\"/thei\\<bs>s\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" delete one char, add another,  go to previous match, add one char\n  call feedkeys(\"/thei\\<bs>s\\<bs>\\<C-T>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  9 these', getline('.'))\n  1\n  \" delete all chars, start from the beginning again\n  call feedkeys(\"/them\". repeat(\"\\<bs>\",4).'the\\>'.\"\\<cr>\", 'tx')\n  call assert_equal('  3 the', getline('.'))\n\n  \" clean up\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline2()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 these', '  3 the theother'])\n  \" Test 1\n  \" Ctrl-T goes correctly back and forth\n  set incsearch\n  1\n  \" first match\n  call feedkeys(\"/the\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to next match (on next line)\n  call feedkeys(\"/the\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to next match (still on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to next match (still on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 3)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline('.'))\n  1\n  \" go to previous match (on line 2)\n  call feedkeys(\"/the\\<C-G>\\<C-G>\\<C-G>\\<C-T>\\<C-T>\\<C-T>\\<cr>\", 'tx')\n  call assert_equal('  2 these', getline('.'))\n  1\n  \" go to previous match (on line 2)\n  call feedkeys(\"/the\\<C-G>\\<C-R>\\<C-W>\\<cr>\", 'tx')\n  call assert_equal('theother', @/)\n\n  \" Test 2: keep the view,\n  \" after deleting a character from the search cmd\n  call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])\n  resize 5\n  1\n  call feedkeys(\"/foo\\<bs>\\<cr>\", 'tx')\n  redraw\n  call assert_equal({'lnum': 10, 'leftcol': 0, 'col': 4, 'topfill': 0, 'topline': 6, 'coladd': 0, 'skipcol': 0, 'curswant': 4}, winsaveview())\n\n  \" remove all history entries\n  for i in range(11)\n      call histdel('/')\n  endfor\n\n  \" Test 3: reset the view,\n  \" after deleting all characters from the search cmd\n  norm! 1gg0\n  \" unfortunately, neither \"/foo\\<c-w>\\<cr>\", nor \"/foo\\<bs>\\<bs>\\<bs>\\<cr>\",\n  \" nor \"/foo\\<c-u>\\<cr>\" works to delete the commandline.\n  \" In that case Vim should return \"E35 no previous regular expression\",\n  \" but it looks like Vim still sees /foo and therefore the test fails.\n  \" Therefore, disabling this test\n  \"call assert_fails(feedkeys(\"/foo\\<c-w>\\<cr>\", 'tx'), 'E35:')\n  \"call assert_equal({'lnum': 1, 'leftcol': 0, 'col': 0, 'topfill': 0, 'topline': 1, 'coladd': 0, 'skipcol': 0, 'curswant': 0}, winsaveview())\n\n  \" clean up\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_use_sub_pat()\n  split\n  let @/ = ''\n  func X()\n    s/^/a/\n    /\n  endfunc\n  call X()\n  bwipe!\nendfunc\n\nfunc Test_searchpair()\n  new\n  call setline(1, ['other code', 'here [', ' [', ' \" cursor here', ' ]]'])\n\n  \" should not give an error for using \"42\"\n  call assert_equal(0, searchpair('a', 'b', 'c', '', 42))\n\n  4\n  call assert_equal(3, searchpair('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4\n  call assert_equal(2, searchpair('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4\n  call assert_equal(1, searchpair('\\[', '', ']', 'bWm'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4|norm ^\n  call assert_equal(5, searchpair('\\[', '', ']', 'Wn'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n  4\n  call assert_equal(2, searchpair('\\[', '', ']', 'bW',\n        \\                         'getline(\".\") =~ \"^\\\\s*\\[\"'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  set nomagic\n  4\n  call assert_equal(3, searchpair('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  set magic\n  4|norm ^\n  call assert_equal(0, searchpair('{', '', '}', 'bW'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n\n  %d\n  call setline(1, ['if 1', '  if 2', '  else', '  endif 2', 'endif 1'])\n\n  /\\<if 1\n  call assert_equal(5, searchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  /\\<if 2\n  call assert_equal(3, searchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 3, 3, 0], getpos('.'))\n\n  q!\nendfunc\n\nfunc Test_searchpairpos()\n  new\n  call setline(1, ['other code', 'here [', ' [', ' \" cursor here', ' ]]'])\n\n  4\n  call assert_equal([3, 2], searchpairpos('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4|norm ^\n  call assert_equal([5, 2], searchpairpos('\\[', '', ']', 'Wn'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bW',\n        \\                                 'getline(\".\") =~ \"^\\\\s*\\[\"'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  4\n  call assert_equal([2, 6], searchpairpos('\\[', '', ']', 'bWr'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  set nomagic\n  4\n  call assert_equal([3, 2], searchpairpos('\\[', '', ']', 'bW'))\n  call assert_equal([0, 3, 2, 0], getpos('.'))\n  set magic\n  4|norm ^\n  call assert_equal([0, 0], searchpairpos('{', '', '}', 'bW'))\n  call assert_equal([0, 4, 2, 0], getpos('.'))\n\n  %d\n  call setline(1, ['if 1', '  if 2', '  else', '  endif 2', 'endif 1'])\n  /\\<if 1\n  call assert_equal([5, 1], searchpairpos('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  /\\<if 2\n  call assert_equal([3, 3], searchpairpos('\\<if\\>', '\\<else\\>', '\\<endif\\>', 'W'))\n  call assert_equal([0, 3, 3, 0], getpos('.'))\n\n  q!\nendfunc\n\nfunc Test_searchpair_errors()\n  call assert_fails(\"call searchpair([0], 'middle', 'end', 'bW', 'skip', 99, 100)\", 'E730: Using a List as a String')\n  call assert_fails(\"call searchpair('start', {-> 0}, 'end', 'bW', 'skip', 99, 100)\", 'E729: Using a Funcref as a String')\n  call assert_fails(\"call searchpair('start', 'middle', {'one': 1}, 'bW', 'skip', 99, 100)\", 'E731: Using a Dictionary as a String')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'flags', 'skip', 99, 100)\", 'E475: Invalid argument: flags')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'bW', 'func', -99, 100)\", 'E475: Invalid argument: -99')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'bW', 'func', 99, -100)\", 'E475: Invalid argument: -100')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'e')\", 'E475: Invalid argument: e')\n  call assert_fails(\"call searchpair('start', 'middle', 'end', 'sn')\", 'E475: Invalid argument: sn')\nendfunc\n\nfunc Test_searchpairpos_errors()\n  call assert_fails(\"call searchpairpos([0], 'middle', 'end', 'bW', 'skip', 99, 100)\", 'E730: Using a List as a String')\n  call assert_fails(\"call searchpairpos('start', {-> 0}, 'end', 'bW', 'skip', 99, 100)\", 'E729: Using a Funcref as a String')\n  call assert_fails(\"call searchpairpos('start', 'middle', {'one': 1}, 'bW', 'skip', 99, 100)\", 'E731: Using a Dictionary as a String')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'flags', 'skip', 99, 100)\", 'E475: Invalid argument: flags')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'bW', 'func', -99, 100)\", 'E475: Invalid argument: -99')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'bW', 'func', 99, -100)\", 'E475: Invalid argument: -100')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'e')\", 'E475: Invalid argument: e')\n  call assert_fails(\"call searchpairpos('start', 'middle', 'end', 'sn')\", 'E475: Invalid argument: sn')\nendfunc\n\nfunc Test_searchpair_skip()\n    func Zero()\n      return 0\n    endfunc\n    func Partial(x)\n      return a:x\n    endfunc\n    new\n    call setline(1, ['{', 'foo', 'foo', 'foo', '}'])\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', ''))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', '0'))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', {-> 0}))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', function('Zero')))\n    3 | call assert_equal(1, searchpair('{', '', '}', 'bWn', function('Partial', [0])))\n    bw!\nendfunc\n\nfunc Test_searchpair_leak()\n  new\n  call setline(1, 'if one else another endif')\n\n  \" The error in the skip expression caused memory to leak.\n  call assert_fails(\"call searchpair('\\\\<if\\\\>', '\\\\<else\\\\>', '\\\\<endif\\\\>', '', '\\\"foo\\\" 2')\", 'E15:')\n\n  bwipe!\nendfunc\n\nfunc Test_searchc()\n  \" These commands used to cause memory overflow in searchc().\n  new\n  norm ixx\n  exe \"norm 0t\\u93cf\"\n  bw!\nendfunc\n\nfunc Cmdline3_prep()\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1', '  2 the~e', '  3 the theother'])\n  set incsearch\nendfunc\n\nfunc Incsearch_cleanup()\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline3()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  \" first match\n  call feedkeys(\"/the\\<c-l>\\<cr>\", 'tx')\n  call assert_equal('  2 the~e', getline('.'))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3s()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":%s/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%subs/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%substitute/the\\<c-l>/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxxe', getline('.'))\n  undo\n  call feedkeys(\":%smagic/the.e/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxx', getline('.'))\n  undo\n  call assert_fails(\":%snomagic/the.e/xxx\\<cr>\", 'E486:')\n  \"\n  call feedkeys(\":%snomagic/the\\\\.e/xxx\\<cr>\", 'tx')\n  call assert_equal('  2 xxx', getline('.'))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3g()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":g/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline(2))\n  undo\n  call feedkeys(\":global/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal('  3 the theother', getline(2))\n  undo\n  call feedkeys(\":g!/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n  undo\n  call feedkeys(\":global!/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline3v()\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  call feedkeys(\":v/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n  undo\n  call feedkeys(\":vglobal/the\\<c-l>/d\\<cr>\", 'tx')\n  call assert_equal(1, line('$'))\n  call assert_equal('  2 the~e', getline(1))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_search_cmdline4()\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['  1 the first', '  2 the second', '  3 the third'])\n  set incsearch\n  $\n  call feedkeys(\"?the\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  2 the second', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  2 the second', getline('.'))\n  \" clean up\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline5()\n  CheckOption incsearch\n\n  \" Do not call test_override(\"char_avail\", 1) so that <C-g> and <C-t> work\n  \" regardless char_avail.\n  new\n  call setline(1, ['  1 the first', '  2 the second', '  3 the third', ''])\n  set incsearch\n  1\n  call feedkeys(\"/the\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('  3 the third', getline('.'))\n  $\n  call feedkeys(\"?the\\<c-t>\\<c-t>\\<c-t>\\<cr>\", 'tx')\n  call assert_equal('  1 the first', getline('.'))\n  \" clean up\n  set noincsearch\n  bw!\nendfunc\n\nfunc Test_search_cmdline6()\n  \" Test that consecutive matches\n  \" are caught by <c-g>/<c-t>\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, [' bbvimb', ''])\n  set incsearch\n  \" first match\n  norm! gg0\n  call feedkeys(\"/b\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  \" second match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,3,0], getpos('.'))\n  \" third match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n  \" first match again\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  set nowrapscan\n  \" last match\n  norm! gg0\n  call feedkeys(\"/b\\<c-g>\\<c-g>\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n  \" clean up\n  set wrapscan&vim\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline7()\n  \" Test that pressing <c-g> in an empty command line\n  \" does not move the cursor\n  CheckOption incsearch\n\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  let @/ = 'b'\n  call setline(1, [' bbvimb', ''])\n  set incsearch\n  \" first match\n  norm! gg0\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<c-g>\\<cr>\", 'tx')\n  call assert_equal([0,1,2,0], getpos('.'))\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<cr>\", 'tx')\n  call assert_equal([0,1,3,0], getpos('.'))\n  \" moves to next match of previous search pattern, just like /<cr>\n  call feedkeys(\"/\\<c-t>\\<cr>\", 'tx')\n  call assert_equal([0,1,7,0], getpos('.'))\n\n  \" using an offset uses the last search pattern\n  call cursor(1, 1)\n  call setline(1, ['1 bbvimb', ' 2 bbvimb'])\n  let @/ = 'b'\n  call feedkeys(\"//e\\<c-g>\\<cr>\", 'tx')\n  call assert_equal('1 bbvimb', getline('.'))\n  call assert_equal(4, col('.'))\n\n  set noincsearch\n  call test_override(\"char_avail\", 0)\n  bw!\nendfunc\n\nfunc Test_search_cmdline8()\n  \" Highlighting is cleared in all windows\n  \" since hls applies to all windows\n  CheckOption incsearch\n  CheckFeature terminal\n  CheckNotGui\n  if has(\"win32\")\n    throw \"Skipped: Bug with sending <ESC> to terminal window not fixed yet\"\n  endif\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n  \" Prepare buffer text\n  let lines = ['abb vim vim vi', 'vimvivim']\n  call writefile(lines, 'Xsearch.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile', 'Xsearch.txt'], {'term_rows': 3})\n\n  call WaitForAssert({-> assert_equal(lines, [term_getline(buf, 1), term_getline(buf, 2)])})\n\n  call term_sendkeys(buf, \":set incsearch hlsearch\\<cr>\")\n  call term_sendkeys(buf, \":14vsp\\<cr>\")\n  call term_sendkeys(buf, \"/vim\\<cr>\")\n  call term_sendkeys(buf, \"/b\\<esc>\")\n  call term_sendkeys(buf, \"gg0\")\n  call TermWait(buf, 250)\n  let screen_line = term_scrape(buf, 1)\n  let [a0,a1,a2,a3] = [screen_line[3].attr, screen_line[4].attr,\n        \\ screen_line[18].attr, screen_line[19].attr]\n  call assert_notequal(a0, a1)\n  call assert_notequal(a0, a3)\n  call assert_notequal(a1, a2)\n  call assert_equal(a0, a2)\n  call assert_equal(a1, a3)\n  \" clean up\n  call delete('Xsearch.txt')\n\n  bwipe!\nendfunc\n\n\" Tests for regexp with various magic settings\nfunc Run_search_regexp_magic_opt()\n  put ='1 a aa abb abbccc'\n  exe 'normal! /a*b\\{2}c\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 2, 17, 0], getpos('.'))\n\n  put ='2 d dd dee deefff'\n  exe 'normal! /\\Md\\*e\\{2}f\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 3, 17, 0], getpos('.'))\n\n  set nomagic\n  put ='3 g gg ghh ghhiii'\n  exe 'normal! /g\\*h\\{2}i\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 4, 17, 0], getpos('.'))\n\n  put ='4 j jj jkk jkklll'\n  exe 'normal! /\\mj*k\\{2}l\\+/e' . \"\\<CR>\"\n  call assert_equal([0, 5, 17, 0], getpos('.'))\n\n  put ='5 m mm mnn mnnooo'\n  exe 'normal! /\\vm*n{2}o+/e' . \"\\<CR>\"\n  call assert_equal([0, 6, 17, 0], getpos('.'))\n\n  put ='6 x ^aa$ x'\n  exe 'normal! /\\V^aa$' . \"\\<CR>\"\n  call assert_equal([0, 7, 5, 0], getpos('.'))\n\n  set magic\n  put ='7 (a)(b) abbaa'\n  exe 'normal! /\\v(a)(b)\\2\\1\\1/e' . \"\\<CR>\"\n  call assert_equal([0, 8, 14, 0], getpos('.'))\n\n  put ='8 axx [ab]xx'\n  exe 'normal! /\\V[ab]\\(\\[xy]\\)\\1' . \"\\<CR>\"\n  call assert_equal([0, 9, 7, 0], getpos('.'))\n\n  %d\nendfunc\n\nfunc Test_search_regexp()\n  enew!\n\n  set regexpengine=1\n  call Run_search_regexp_magic_opt()\n  set regexpengine=2\n  call Run_search_regexp_magic_opt()\n  set regexpengine&\n\n  set undolevels=100\n  put ='9 foobar'\n  put =''\n  exe \"normal! a\\<C-G>u\\<Esc>\"\n  normal G\n  exe 'normal! dv?bar?' . \"\\<CR>\"\n  call assert_equal('9 foo', getline('.'))\n  call assert_equal([0, 2, 5, 0], getpos('.'))\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal('9 foobar', getline('.'))\n  call assert_equal([0, 2, 6, 0], getpos('.'))\n  call assert_equal(3, line('$'))\n\n  set undolevels&\n  enew!\nendfunc\n\nfunc Test_search_cmdline_incsearch_highlight()\n  CheckOption incsearch\n\n  set incsearch hlsearch\n  \" need to disable char_avail,\n  \" so that expansion of commandline works\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['aaa  1 the first', '  2 the second', '  3 the third'])\n\n  1\n  call feedkeys(\"/second\\<cr>\", 'tx')\n  call assert_equal('second', @/)\n  call assert_equal('  2 the second', getline('.'))\n\n  \" Canceling search won't change @/\n  1\n  let @/ = 'last pattern'\n  call feedkeys(\"/third\\<C-c>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/third\\<Esc>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/3\\<bs>\\<bs>\", 'tx')\n  call assert_equal('last pattern', @/)\n  call feedkeys(\"/third\\<c-g>\\<c-t>\\<Esc>\", 'tx')\n  call assert_equal('last pattern', @/)\n\n  \" clean up\n  set noincsearch nohlsearch\n  bw!\nendfunc\n\nfunc Test_search_cmdline_incsearch_highlight_attr()\n  CheckOption incsearch\n  CheckFeature terminal\n  CheckNotGui\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n\n  \" Prepare buffer text\n  let lines = ['abb vim vim vi', 'vimvivim']\n  call writefile(lines, 'Xsearch.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile', 'Xsearch.txt'], {'term_rows': 3})\n\n  call WaitForAssert({-> assert_equal(lines, [term_getline(buf, 1), term_getline(buf, 2)])})\n  \" wait for vim to complete initialization\n  call TermWait(buf)\n\n  \" Get attr of normal(a0), incsearch(a1), hlsearch(a2) highlight\n  call term_sendkeys(buf, \":set incsearch hlsearch\\<cr>\")\n  call term_sendkeys(buf, '/b')\n  call TermWait(buf, 100)\n  let screen_line1 = term_scrape(buf, 1)\n  call assert_true(len(screen_line1) > 2)\n  \" a0: attr_normal\n  let a0 = screen_line1[0].attr\n  \" a1: attr_incsearch\n  let a1 = screen_line1[1].attr\n  \" a2: attr_hlsearch\n  let a2 = screen_line1[2].attr\n  call assert_notequal(a0, a1)\n  call assert_notequal(a0, a2)\n  call assert_notequal(a1, a2)\n  call term_sendkeys(buf, \"\\<cr>gg0\")\n\n  \" Test incremental highlight search\n  call term_sendkeys(buf, \"/vim\")\n  call TermWait(buf, 100)\n  \" Buffer:\n  \" abb vim vim vi\n  \" vimvivim\n  \" Search: /vim\n  let attr_line1 = [a0,a0,a0,a0,a1,a1,a1,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test <C-g>\n  call term_sendkeys(buf, \"\\<C-g>\\<C-g>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a1,a1,a1,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test <C-t>\n  call term_sendkeys(buf, \"\\<C-t>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a1,a1,a1,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Type Enter and a1(incsearch highlight) should become a2(hlsearch highlight)\n  call term_sendkeys(buf, \"\\<cr>\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a2,a2,a2,a0,a2,a2,a2,a0,a0,a0]\n  let attr_line2 = [a2,a2,a2,a0,a0,a2,a2,a2]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n\n  \" Test nohlsearch. a2(hlsearch highlight) should become a0(normal highlight)\n  call term_sendkeys(buf, \":1\\<cr>\")\n  call term_sendkeys(buf, \":set nohlsearch\\<cr>\")\n  call term_sendkeys(buf, \"/vim\")\n  call TermWait(buf, 100)\n  let attr_line1 = [a0,a0,a0,a0,a1,a1,a1,a0,a0,a0,a0,a0,a0,a0]\n  let attr_line2 = [a0,a0,a0,a0,a0,a0,a0,a0]\n  call assert_equal(attr_line1, map(term_scrape(buf, 1)[:len(attr_line1)-1], 'v:val.attr'))\n  call assert_equal(attr_line2, map(term_scrape(buf, 2)[:len(attr_line2)-1], 'v:val.attr'))\n  call delete('Xsearch.txt')\n\n  call delete('Xsearch.txt')\n  bwipe!\nendfunc\n\nfunc Test_incsearch_cmdline_modifier()\n  CheckOption incsearch\n\n  call test_override(\"char_avail\", 1)\n  new\n  call setline(1, ['foo'])\n  set incsearch\n  \" Test that error E14 does not occur in parsing command modifier.\n  call feedkeys(\"V:tab\", 'tx')\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_incsearch_scrolling()\n  CheckRunVimInTerminal\n  call assert_equal(0, &scrolloff)\n  call writefile([\n\t\\ 'let dots = repeat(\".\", 120)',\n\t\\ 'set incsearch cmdheight=2 scrolloff=0',\n\t\\ 'call setline(1, [dots, dots, dots, \"\", \"target\", dots, dots])',\n\t\\ 'normal gg',\n\t\\ 'redraw',\n\t\\ ], 'Xscript')\n  let buf = RunVimInTerminal('-S Xscript', {'rows': 9, 'cols': 70})\n  \" Need to send one key at a time to force a redraw\n  call term_sendkeys(buf, '/')\n  sleep 100m\n  call term_sendkeys(buf, 't')\n  sleep 100m\n  call term_sendkeys(buf, 'a')\n  sleep 100m\n  call term_sendkeys(buf, 'r')\n  sleep 100m\n  call term_sendkeys(buf, 'g')\n  call VerifyScreenDump(buf, 'Test_incsearch_scrolling_01', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xscript')\nendfunc\n\nfunc Test_incsearch_search_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 8)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ '3',\n\t\\ ], 'Xis_search_script')\n  let buf = RunVimInTerminal('-S Xis_search_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  call term_sendkeys(buf, '/fo')\n  call VerifyScreenDump(buf, 'Test_incsearch_search_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n  sleep 100m\n\n  call term_sendkeys(buf, '/\\v')\n  call VerifyScreenDump(buf, 'Test_incsearch_search_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_search_script')\nendfunc\n\nfunc Test_hlsearch_dump()\n  CheckOption hlsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set hlsearch cursorline',\n        \\ 'call setline(1, [\"xxx\", \"xxx\", \"xxx\"])',\n\t\\ '/.*',\n\t\\ '2',\n\t\\ ], 'Xhlsearch_script')\n  let buf = RunVimInTerminal('-S Xhlsearch_script', {'rows': 6, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_hlsearch_1', {})\n\n  call term_sendkeys(buf, \"/\\\\_.*\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_hlsearch_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlsearch_script')\nendfunc\n\nfunc Test_hlsearch_and_visual()\n  CheckOption hlsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set hlsearch',\n        \\ 'call setline(1, repeat([\"xxx yyy zzz\"], 3))',\n        \\ 'hi Search cterm=bold',\n\t\\ '/yyy',\n\t\\ 'call cursor(1, 6)',\n\t\\ ], 'Xhlvisual_script')\n  let buf = RunVimInTerminal('-S Xhlvisual_script', {'rows': 6, 'cols': 40})\n  call term_sendkeys(buf, \"vjj\")\n  call VerifyScreenDump(buf, 'Test_hlsearch_visual_1', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlvisual_script')\nendfunc\n\nfunc Test_hlsearch_block_visual_match()\n  CheckScreendump\n\n  let lines =<< trim END\n    set hlsearch\n    call setline(1, ['aa', 'bbbb', 'cccccc'])\n  END\n  call writefile(lines, 'Xhlsearch_block')\n  let buf = RunVimInTerminal('-S Xhlsearch_block', {'rows': 9, 'cols': 60})\n\n  call term_sendkeys(buf, \"G\\<C-V>$kk\\<Esc>\")\n  sleep 100m\n  call term_sendkeys(buf, \"/\\\\%V\\<CR>\")\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_hlsearch_block_visual_match', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xhlsearch_block')\nendfunc\n\nfunc Test_incsearch_substitute()\n  CheckOption incsearch\n\n  call test_override(\"char_avail\", 1)\n  new\n  set incsearch\n  for n in range(1, 10)\n    call setline(n, 'foo ' . n)\n  endfor\n  4\n  call feedkeys(\":.,.+2s/foo\\<BS>o\\<BS>o/xxx\\<cr>\", 'tx')\n  call assert_equal('foo 3', getline(3))\n  call assert_equal('xxx 4', getline(4))\n  call assert_equal('xxx 5', getline(5))\n  call assert_equal('xxx 6', getline(6))\n  call assert_equal('foo 7', getline(7))\n\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_incsearch_substitute_long_line()\n  new\n  call test_override(\"char_avail\", 1)\n  set incsearch\n\n  call repeat('x', 100000)->setline(1)\n  call feedkeys(':s/\\%c', 'xt')\n  redraw\n  call feedkeys(\"\\<Esc>\", 'xt')\n\n  call Incsearch_cleanup()\n  bwipe!\nendfunc\n\n\" Similar to Test_incsearch_substitute() but with a screendump halfway.\nfunc Test_incsearch_substitute_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 10)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ 'call setline(11, \"bar 11\")',\n\t\\ '3',\n\t\\ ], 'Xis_subst_script')\n  let buf = RunVimInTerminal('-S Xis_subst_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  \" Select three lines at the cursor with typed pattern.\n  call term_sendkeys(buf, ':.,.+2s/')\n  sleep 100m\n  call term_sendkeys(buf, 'f')\n  sleep 100m\n  call term_sendkeys(buf, 'o')\n  sleep 100m\n  call term_sendkeys(buf, 'o')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Select three lines at the cursor using previous pattern.\n  call term_sendkeys(buf, \"/foo\\<CR>\")\n  sleep 100m\n  call term_sendkeys(buf, ':.,.+2s//')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_02', {})\n\n  \" Deleting last slash should remove the match.\n  call term_sendkeys(buf, \"\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_03', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Reverse range is accepted\n  call term_sendkeys(buf, ':5,2s/foo')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_04', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" White space after the command is skipped\n  call term_sendkeys(buf, ':2,3sub  /fo')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_05', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Command modifiers are skipped\n  call term_sendkeys(buf, ':above below browse botr confirm keepmar keepalt keeppat keepjum filter xxx hide lockm leftabove noau noswap rightbel sandbox silent silent! $tab top unsil vert verbose 4,5s/fo.')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_06', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Cursorline highlighting at match\n  call term_sendkeys(buf, \":set cursorline\\<CR>\")\n  call term_sendkeys(buf, 'G9G')\n  call term_sendkeys(buf, ':9,11s/bar')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_07', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Cursorline highlighting at cursor when no match\n  call term_sendkeys(buf, ':9,10s/bar')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_08', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Only \\v handled as empty pattern, does not move cursor\n  call term_sendkeys(buf, '3G4G')\n  call term_sendkeys(buf, \":nohlsearch\\<CR>\")\n  call term_sendkeys(buf, ':6,7s/\\v')\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_09', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, \":set nocursorline\\<CR>\")\n\n  \" All matches are highlighted for 'hlsearch' after the incsearch canceled\n  call term_sendkeys(buf, \"1G*\")\n  call term_sendkeys(buf, \":2,5s/foo\")\n  sleep 100m\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_10', {})\n\n  call term_sendkeys(buf, \":split\\<CR>\")\n  call term_sendkeys(buf, \":let @/ = 'xyz'\\<CR>\")\n  call term_sendkeys(buf, \":%s/.\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_11', {})\n  call term_sendkeys(buf, \"\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_12', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_13', {})\n  call term_sendkeys(buf, \":%bwipe!\\<CR>\")\n  call term_sendkeys(buf, \":only!\\<CR>\")\n\n  \"  get :'<,'>s command in history\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"aasdfasdf\\<Esc>\")\n  call term_sendkeys(buf, \"V:s/a/b/g\\<CR>\")\n  \" Using '<,'> does not give E20\n  call term_sendkeys(buf, \":new\\<CR>\")\n  call term_sendkeys(buf, \"aasdfasdf\\<Esc>\")\n  call term_sendkeys(buf, \":\\<Up>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_14', {})\n  call term_sendkeys(buf, \"<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_script')\nendfunc\n\nfunc Test_incsearch_highlighting()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch',\n\t\\ 'call setline(1, \"hello/there\")',\n\t\\ ], 'Xis_subst_hl_script')\n  let buf = RunVimInTerminal('-S Xis_subst_hl_script', {'rows': 4, 'cols': 20})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 300m\n\n  \" Using a different search delimiter should still highlight matches\n  \" that contain a '/'.\n  call term_sendkeys(buf, \":%s;ello/the\")\n  call VerifyScreenDump(buf, 'Test_incsearch_substitute_15', {})\n  call term_sendkeys(buf, \"<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_hl_script')\nendfunc\n\nfunc Test_incsearch_with_change()\n  CheckFeature timers\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"one\", \"two ------ X\", \"three\"])',\n\t\\ 'call timer_start(200, { _ -> setline(2, \"x\")})',\n\t\\ ], 'Xis_change_script')\n  let buf = RunVimInTerminal('-S Xis_change_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 300m\n\n  \" Highlight X, it will be deleted by the timer callback.\n  call term_sendkeys(buf, ':%s/X')\n  call VerifyScreenDump(buf, 'Test_incsearch_change_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_change_script')\nendfunc\n\n\" Similar to Test_incsearch_substitute_dump() for :sort\nfunc Test_incsearch_sort_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"another one 2\", \"that one 3\", \"the one 1\"])',\n\t\\ ], 'Xis_sort_script')\n  let buf = RunVimInTerminal('-S Xis_sort_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  call term_sendkeys(buf, ':sort ni u /on')\n  call VerifyScreenDump(buf, 'Test_incsearch_sort_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':sort! /on')\n  call VerifyScreenDump(buf, 'Test_incsearch_sort_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_sort_script')\nendfunc\n\n\" Similar to Test_incsearch_substitute_dump() for :vimgrep famiry\nfunc Test_incsearch_vimgrep_dump()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'call setline(1, [\"another one 2\", \"that one 3\", \"the one 1\"])',\n\t\\ ], 'Xis_vimgrep_script')\n  let buf = RunVimInTerminal('-S Xis_vimgrep_script', {'rows': 9, 'cols': 70})\n  \" Give Vim a chance to redraw to get rid of the spaces in line 2 caused by\n  \" the 'ambiwidth' check.\n  sleep 100m\n\n  \" Need to send one key at a time to force a redraw.\n  call term_sendkeys(buf, ':vimgrep on')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':vimg /on/ *.txt')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_02', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':vimgrepadd \"\\<on')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_03', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':lv \"tha')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_04', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call term_sendkeys(buf, ':lvimgrepa \"the\" **/*.txt')\n  call VerifyScreenDump(buf, 'Test_incsearch_vimgrep_05', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_vimgrep_script')\nendfunc\n\nfunc Test_keep_last_search_pattern()\n  CheckOption incsearch\n\n  new\n  call setline(1, ['foo', 'foo', 'foo'])\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  let @/ = 'bar'\n  call feedkeys(\":/foo/s//\\<Esc>\", 'ntx')\n  call assert_equal('bar', @/)\n\n  \" no error message if pattern not found\n  call feedkeys(\":/xyz/s//\\<Esc>\", 'ntx')\n  call assert_equal('bar', @/)\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_word_under_cursor_after_match()\n  CheckOption incsearch\n\n  new\n  call setline(1, 'foo bar')\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  try\n    call feedkeys(\"/foo\\<C-R>\\<C-W>\\<CR>\", 'ntx')\n  catch /E486:/\n  endtry\n  call assert_equal('foobar', @/)\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_subst_word_under_cursor()\n  CheckOption incsearch\n\n  new\n  call setline(1, ['int SomeLongName;', 'for (xxx = 1; xxx < len; ++xxx)'])\n  set incsearch\n  call test_override(\"char_avail\", 1)\n  call feedkeys(\"/LongName\\<CR>\", 'ntx')\n  call feedkeys(\":%s/xxx/\\<C-R>\\<C-W>/g\\<CR>\", 'ntx')\n  call assert_equal('for (SomeLongName = 1; SomeLongName < len; ++SomeLongName)', getline(2))\n\n  bwipe!\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\nfunc Test_search_undefined_behaviour()\n  CheckFeature terminal\n\n  let h = winheight(0)\n  if h < 3\n    return\n  endif\n  \" did cause an undefined left shift\n  let g:buf = term_start([GetVimProg(), '--clean', '-e', '-s', '-c', 'call search(getline(\".\"))', 'samples/test000'], {'term_rows': 3})\n  call assert_equal([''], getline(1, '$'))\n  call term_sendkeys(g:buf, \":qa!\\<cr>\")\n  bwipe!\nendfunc\n\nfunc Test_search_undefined_behaviour2()\n  call search(\"\\%UC0000000\")\nendfunc\n\n\" Test for search('multi-byte char', 'bce')\nfunc Test_search_multibyte()\n  let save_enc = &encoding\n  set encoding=utf8\n  enew!\n  call append('$', '\uff21')\n  call cursor(2, 1)\n  call assert_equal(2, search('\uff21', 'bce', line('.')))\n  enew!\n  let &encoding = save_enc\nendfunc\n\n\" This was causing E874.  Also causes an invalid read?\nfunc Test_look_behind()\n  new\n  call setline(1, '0\\|\\&\\n\\@<=')\n  call search(getline(\".\"))\n  bwipe!\nendfunc\n\nfunc Test_search_visual_area_linewise()\n  new\n  call setline(1, ['aa', 'bb', 'cc'])\n  exe \"normal 2GV\\<Esc>\"\n  for engine in [1, 2]\n    exe 'set regexpengine=' .. engine\n    exe \"normal gg/\\\\%'<\\<CR>>\"\n    call assert_equal([0, 2, 1, 0, 1], getcurpos(), 'engine ' .. engine)\n    exe \"normal gg/\\\\%'>\\<CR>\"\n    call assert_equal([0, 2, 2, 0, 2], getcurpos(), 'engine ' .. engine)\n  endfor\n\n  bwipe!\n  set regexpengine&\nendfunc\n\nfunc Test_search_sentence()\n  new\n  \" this used to cause a crash\n  /\\%'(\n  /\n  bwipe\nendfunc\n\n\" Test that there is no crash when there is a last search pattern but no last\n\" substitute pattern.\nfunc Test_no_last_substitute_pat()\n  \" Use viminfo to set the last search pattern to a string and make the last\n  \" substitute pattern the most recent used and make it empty (NULL).\n  call writefile(['~MSle0/bar', '~MSle0~&'], 'Xviminfo')\n  rviminfo! Xviminfo\n  call assert_fails('normal n', 'E35:')\n\n  call delete('Xviminfo')\nendfunc\n\nfunc Test_search_Ctrl_L_combining()\n  \" Make sure, that Ctrl-L works correctly with combining characters.\n  \" It uses an artificial example of an 'a' with 4 combining chars:\n    \" 'a' U+0061 Dec:97 LATIN SMALL LETTER A &#x61; /\\%u61\\Z \"\\u0061\"\n    \" ' \u0300' U+0300 Dec:768 COMBINING GRAVE ACCENT &#x300; /\\%u300\\Z \"\\u0300\"\n    \" ' \u0301' U+0301 Dec:769 COMBINING ACUTE ACCENT &#x301; /\\%u301\\Z \"\\u0301\"\n    \" ' \u0307' U+0307 Dec:775 COMBINING DOT ABOVE &#x307; /\\%u307\\Z \"\\u0307\"\n    \" ' \u0323' U+0323 Dec:803 COMBINING DOT BELOW &#x323; /\\%u323 \"\\u0323\"\n  \" Those should also appear on the commandline\n  CheckOption incsearch\n\n  call Cmdline3_prep()\n  1\n  let bufcontent = ['', 'Mia\u0300\u0301\u0307\u0323m']\n  call append('$', bufcontent)\n  call feedkeys(\"/Mi\\<c-l>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(5, line('.'))\n  call assert_equal(bufcontent[1], @/)\n  call Incsearch_cleanup()\nendfunc\n\nfunc Test_large_hex_chars1()\n  \" This used to cause a crash, the character becomes an NFA state.\n  try\n    /\\%Ufffffc23\n  catch\n    call assert_match('E678:', v:exception)\n  endtry\n  try\n    set re=1\n    /\\%Ufffffc23\n  catch\n    call assert_match('E678:', v:exception)\n  endtry\n  set re&\nendfunc\n\nfunc Test_large_hex_chars2()\n  \" This used to cause a crash, the character becomes an NFA state.\n  try\n    /[\\Ufffffc1f]\n  catch\n    call assert_match('E486:', v:exception)\n  endtry\n  try\n    set re=1\n    /[\\Ufffffc1f]\n  catch\n    call assert_match('E486:', v:exception)\n  endtry\n  set re&\nendfunc\n\nfunc Test_one_error_msg()\n  \" This was also giving an internal error\n  call assert_fails('call search(\" \\\\((\\\\v[[=P=]]){185}+             \")', 'E871:')\nendfunc\n\nfunc Test_incsearch_add_char_under_cursor()\n  CheckOption incsearch\n\n  set incsearch\n  new\n  call setline(1, ['find match', 'anything'])\n  1\n  call test_override('char_avail', 1)\n  call feedkeys(\"fc/m\\<C-L>\\<C-L>\\<C-L>\\<C-L>\\<C-L>\\<CR>\", 'tx')\n  call assert_equal('match', @/)\n  call test_override('char_avail', 0)\n\n  set incsearch&\n  bwipe!\nendfunc\n\n\" Test for the search() function with match at the cursor position\nfunc Test_search_match_at_curpos()\n  new\n  call append(0, ['foobar', '', 'one two', ''])\n\n  normal gg\n\n  eval 'foobar'->search('c')\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  normal j\n  call search('^$', 'c')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call search('^$', 'bc')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  exe \"normal /two\\<CR>\"\n  call search('.', 'c')\n  call assert_equal([3, 5], [line('.'), col('.')])\n\n  close!\nendfunc\n\n\" Test for error cases with the search() function\nfunc Test_search_errors()\n  call assert_fails(\"call search('pat', [])\", 'E730:')\n  call assert_fails(\"call search('pat', 'b', {})\", 'E728:')\n  call assert_fails(\"call search('pat', 'b', 1, [])\", 'E745:')\n  call assert_fails(\"call search('pat', 'ns')\", 'E475:')\n  call assert_fails(\"call search('pat', 'mr')\", 'E475:')\n\n  new\n  call setline(1, ['foo', 'bar'])\n  call assert_fails('call feedkeys(\"/foo/;/bar/;\\<CR>\", \"tx\")', 'E386:')\n  bwipe!\nendfunc\n\nfunc Test_search_display_pattern()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n\n  call cursor(1, 1)\n  let @/ = 'foo'\n  let pat = @/->escape('()*?'. '\\s\\+')\n  let g:a = execute(':unsilent :norm! n')\n  call assert_match(pat, g:a)\n\n  \" right-left\n  if exists(\"+rightleft\")\n    set rl\n    call cursor(1, 1)\n    let @/ = 'foo'\n    let pat = 'oof/\\s\\+'\n    let g:a = execute(':unsilent :norm! n')\n    call assert_match(pat, g:a)\n    set norl\n  endif\nendfunc\n\nfunc Test_searchdecl()\n  let lines =<< trim END\n     int global;\n\n     func()\n     {\n       int global;\n       if (cond) {\n\t int local;\n       }\n       int local;\n       // comment\n     }\n  END\n  new\n  call setline(1, lines)\n  10\n  call assert_equal(0, searchdecl('local', 0, 0))\n  call assert_equal(7, getcurpos()[1])\n\n  10\n  call assert_equal(0, 'local'->searchdecl(0, 1))\n  call assert_equal(9, getcurpos()[1])\n\n  10\n  call assert_equal(0, searchdecl('global'))\n  call assert_equal(5, getcurpos()[1])\n\n  10\n  call assert_equal(0, searchdecl('global', 1))\n  call assert_equal(1, getcurpos()[1])\n\n  bwipe!\nendfunc\n\nfunc Test_search_special()\n  \" this was causing illegal memory access and an endless loop\n  set t_PE=\n  exe \"norm /\\x80PS\"\nendfunc\n\n\" Test for command failures when the last search pattern is not set.\n\" Need to run this in a new vim instance where last search pattern is not set.\nfunc Test_search_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails(\"normal i\\<C-R>/\\e\", 'E35:')\n    call assert_fails(\"exe '/'\", 'E35:')\n    call assert_fails(\"exe '?'\", 'E35:')\n    call assert_fails(\"/\", 'E35:')\n    call assert_fails(\"?\", 'E35:')\n    call assert_fails(\"normal n\", 'E35:')\n    call assert_fails(\"normal N\", 'E35:')\n    call assert_fails(\"normal gn\", 'E35:')\n    call assert_fails(\"normal gN\", 'E35:')\n    call assert_fails(\"normal cgn\", 'E35:')\n    call assert_fails(\"normal cgN\", 'E35:')\n    let p = []\n    let p = @/\n    call assert_equal('', p)\n    call assert_fails(\"normal :\\<C-R>/\", 'E35:')\n    call assert_fails(\"//p\", 'E35:')\n    call assert_fails(\";//p\", 'E35:')\n    call assert_fails(\"??p\", 'E35:')\n    call assert_fails(\";??p\", 'E35:')\n    call assert_fails('g//p', ['E35:', 'E476:'])\n    call assert_fails('v//p', ['E35:', 'E476:'])\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for using tilde (~) atom in search. This should use the last used\n\" substitute pattern\nfunc Test_search_tilde_pat()\n  let lines =<< trim [SCRIPT]\n    set regexpengine=1\n    call assert_fails('exe \"normal /~\\<CR>\"', 'E33:')\n    call assert_fails('exe \"normal ?~\\<CR>\"', 'E33:')\n    set regexpengine=2\n    call assert_fails('exe \"normal /~\\<CR>\"', ['E33:', 'E383:'])\n    call assert_fails('exe \"normal ?~\\<CR>\"', ['E33:', 'E383:'])\n    set regexpengine&\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test for searching a pattern that is not present with 'nowrapscan'\nfunc Test_search_pat_not_found()\n  new\n  set nowrapscan\n  let @/ = '1abcxyz2'\n  call assert_fails('normal n', 'E385:')\n  call assert_fails('normal N', 'E384:')\n  set wrapscan&\n  close\nendfunc\n\n\" Test for v:searchforward variable\nfunc Test_searchforward_var()\n  new\n  call setline(1, ['foo', '', 'foo'])\n  call cursor(2, 1)\n  let @/ = 'foo'\n  let v:searchforward = 0\n  normal N\n  call assert_equal(3, line('.'))\n  call cursor(2, 1)\n  let v:searchforward = 1\n  normal N\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Test for invalid regular expressions\nfunc Test_invalid_regexp()\n  set regexpengine=1\n  call assert_fails(\"call search(repeat('\\\\(.\\\\)', 10))\", 'E51:')\n  call assert_fails(\"call search('\\\\%(')\", 'E53:')\n  call assert_fails(\"call search('\\\\(')\", 'E54:')\n  call assert_fails(\"call search('\\\\)')\", 'E55:')\n  call assert_fails(\"call search('x\\\\@#')\", 'E59:')\n  call assert_fails('call search(''\\v%(%(%(%(%(%(%(%(%(%(%(a){1}){1}){1}){1}){1}){1}){1}){1}){1}){1}){1}'')', 'E60:')\n  call assert_fails(\"call search('a\\\\+*')\", 'E61:')\n  call assert_fails(\"call search('\\\\_m')\", 'E63:')\n  call assert_fails(\"call search('\\\\+')\", 'E64:')\n  call assert_fails(\"call search('\\\\1')\", 'E65:')\n  call assert_fails(\"call search('\\\\z\\\\(\\\\)')\", 'E66:')\n  call assert_fails(\"call search('\\\\z2')\", 'E67:')\n  call assert_fails(\"call search('\\\\zx')\", 'E68:')\n  call assert_fails(\"call search('\\\\%[ab')\", 'E69:')\n  call assert_fails(\"call search('\\\\%[]')\", 'E70:')\n  call assert_fails(\"call search('\\\\%a')\", 'E71:')\n  call assert_fails(\"call search('ab\\\\%[\\\\(cd\\\\)]')\", 'E369:')\n  call assert_fails(\"call search('ab\\\\%[\\\\%(cd\\\\)]')\", 'E369:')\n  set regexpengine=2\n  call assert_fails(\"call search('\\\\_')\", 'E865:')\n  call assert_fails(\"call search('\\\\+')\", 'E866:')\n  call assert_fails(\"call search('\\\\zx')\", 'E867:')\n  call assert_fails(\"call search('\\\\%a')\", 'E867:')\n  call assert_fails(\"call search('x\\\\@#')\", 'E869:')\n  call assert_fails(\"call search(repeat('\\\\(.\\\\)', 10))\", 'E872:')\n  call assert_fails(\"call search('\\\\_m')\", 'E877:')\n  call assert_fails(\"call search('\\\\%(')\", 'E53:')\n  call assert_fails(\"call search('\\\\(')\", 'E54:')\n  call assert_fails(\"call search('\\\\)')\", 'E55:')\n  call assert_fails(\"call search('\\\\z\\\\(\\\\)')\", 'E66:')\n  call assert_fails(\"call search('\\\\%[ab')\", 'E69:')\n  call assert_fails(\"call search('\\\\%[]')\", 'E70:')\n  call assert_fails(\"call search('\\\\%9999999999999999999999999999v')\", 'E951:')\n  set regexpengine&\n  call assert_fails(\"call search('\\\\%#=3ab')\", 'E864:')\nendfunc\n\n\" Test for searching a very complex pattern in a string. Should switch the\n\" regexp engine from NFA to the old engine.\nfunc Test_regexp_switch_engine()\n  let l = readfile('samples/re.freeze.txt')\n  let v = substitute(l[4], '..\\@<!', '', '')\n  call assert_equal(l[4], v)\nendfunc\n\n\" Test for the \\%V atom to search within visually selected text\nfunc Test_search_in_visual_area()\n  new\n  call setline(1, ['foo bar1', 'foo bar2', 'foo bar3', 'foo bar4'])\n  exe \"normal 2GVjo/\\\\%Vbar\\<CR>\\<Esc>\"\n  call assert_equal([2, 5], [line('.'), col('.')])\n  exe \"normal 2GVj$?\\\\%Vbar\\<CR>\\<Esc>\"\n  call assert_equal([3, 5], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for searching with 'smartcase' and 'ignorecase'\nfunc Test_search_smartcase()\n  new\n  call setline(1, ['', 'Hello'])\n  set noignorecase nosmartcase\n  call assert_fails('exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"', 'E486:')\n\n  set ignorecase nosmartcase\n  exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call cursor(1, 1)\n  set ignorecase smartcase\n  call assert_fails('exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)O\\<CR>\"', 'E486:')\n\n  exe \"normal /\\\\a\\\\_.\\\\(.*\\\\)o\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  \" Test for using special atoms with 'smartcase'\n  call setline(1, ['', '    Hello\\ '])\n  call cursor(1, 1)\n  call feedkeys('/\\_.\\%(\\uello\\)\\' .. \"\\<CR>\", 'xt')\n  call assert_equal([2, 4], [line('.'), col('.')])\n\n  set ignorecase& smartcase&\n  close!\nendfun\n\n\" Test 'smartcase' with utf-8.\nfunc Test_search_smartcase_utf8()\n  new\n  let save_enc = &encoding\n  set encoding=utf8 ignorecase smartcase\n\n  call setline(1, 'Caf\u00e9 caf\u00c9')\n  1s/caf\u00e9/x/g\n  call assert_equal('x x', getline(1))\n\n  call setline(1, 'Caf\u00e9 caf\u00c9')\n  1s/caf\u00c9/x/g\n  call assert_equal('Caf\u00e9 x', getline(1))\n\n  set ignorecase& smartcase&\n  let &encoding = save_enc\n  close!\nendfunc\n\n\" Test searching past the end of a file\nfunc Test_search_past_eof()\n  new\n  call setline(1, ['Line'])\n  exe \"normal /\\\\n\\\\zs\\<CR>\"\n  call assert_equal([1, 4], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for various search offsets\nfunc Test_search_offset()\n  \" With /e, for a match in the first column of a line, the cursor should be\n  \" placed at the end of the previous line.\n  new\n  call setline(1, ['one two', 'three four'])\n  call search('two\\_.', 'e')\n  call assert_equal([1, 7], [line('.'), col('.')])\n\n  \" with cursor at the beginning of the file, use /s+1\n  call cursor(1, 1)\n  exe \"normal /two/s+1\\<CR>\"\n  call assert_equal([1, 6], [line('.'), col('.')])\n\n  \" with cursor at the end of the file, use /e-1\n  call cursor(2, 10)\n  exe \"normal ?three?e-1\\<CR>\"\n  call assert_equal([2, 4], [line('.'), col('.')])\n\n  \" line offset - after the last line\n  call cursor(1, 1)\n  exe \"normal /three/+1\\<CR>\"\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  \" line offset - before the first line\n  call cursor(2, 1)\n  exe \"normal ?one?-1\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" character offset - before the first character in the file\n  call cursor(2, 1)\n  exe \"normal ?one?s-1\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n  call cursor(2, 1)\n  exe \"normal ?one?e-3\\<CR>\"\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" character offset - after the last character in the file\n  call cursor(1, 1)\n  exe \"normal /four/s+4\\<CR>\"\n  call assert_equal([2, 10], [line('.'), col('.')])\n  call cursor(1, 1)\n  exe \"normal /four/e+1\\<CR>\"\n  call assert_equal([2, 10], [line('.'), col('.')])\n\n  close!\nendfunc\n\n\" Test for searching for matching parenthesis using %\nfunc Test_search_match_paren()\n  new\n  call setline(1, \"abc(def')'ghi'('jk'\\\\t'lm)no\")\n  \" searching for a matching parenthesis should skip single quoted characters\n  call cursor(1, 4)\n  normal %\n  call assert_equal([1, 25], [line('.'), col('.')])\n  normal %\n  call assert_equal([1, 4], [line('.'), col('.')])\n  call cursor(1, 5)\n  normal ])\n  call assert_equal([1, 25], [line('.'), col('.')])\n  call cursor(1, 24)\n  normal [(\n  call assert_equal([1, 4], [line('.'), col('.')])\n\n  \" matching parenthesis in 'virtualedit' mode with cursor after the eol\n  call setline(1, 'abc(defgh)')\n  set virtualedit=all\n  normal 20|%\n  call assert_equal(4, col('.'))\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for searching a pattern and stopping before a specified line\nfunc Test_search_stopline()\n  new\n  call setline(1, ['', '', '', 'vim'])\n  call assert_equal(0, search('vim', 'n', 3))\n  call assert_equal(4, search('vim', 'n', 4))\n  call setline(1, ['vim', '', '', ''])\n  call cursor(4, 1)\n  call assert_equal(0, search('vim', 'bn', 2))\n  call assert_equal(1, search('vim', 'bn', 1))\n  close!\nendfunc\n\nfunc Test_incsearch_highlighting_newline()\n  CheckRunVimInTerminal\n  CheckOption incsearch\n  CheckScreendump\n  new\n  call test_override(\"char_avail\", 1)\n\n  let commands =<< trim [CODE]\n    set incsearch nohls\n    call setline(1, ['test', 'xxx'])\n  [CODE]\n  call writefile(commands, 'Xincsearch_nl')\n  let buf = RunVimInTerminal('-S Xincsearch_nl', {'rows': 5, 'cols': 10})\n  call term_sendkeys(buf, '/test')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline1', {})\n  \" Need to send one key at a time to force a redraw\n  call term_sendkeys(buf, '\\n')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline2', {})\n  call term_sendkeys(buf, 'x')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline3', {})\n  call term_sendkeys(buf, 'x')\n  call VerifyScreenDump(buf, 'Test_incsearch_newline4', {})\n  call term_sendkeys(buf, \"\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_incsearch_newline5', {})\n  call StopVimInTerminal(buf)\n\n  \" clean up\n  call delete('Xincsearch_nl')\n  call test_override(\"char_avail\", 0)\n  bw\nendfunc\n\nfunc Test_incsearch_substitute_dump2()\n  CheckOption incsearch\n  CheckScreendump\n\n  call writefile([\n\t\\ 'set incsearch hlsearch scrolloff=0',\n\t\\ 'for n in range(1, 4)',\n\t\\ '  call setline(n, \"foo \" . n)',\n\t\\ 'endfor',\n\t\\ 'call setline(5, \"abc|def\")',\n\t\\ '3',\n\t\\ ], 'Xis_subst_script2')\n  let buf = RunVimInTerminal('-S Xis_subst_script2', {'rows': 9, 'cols': 70})\n\n  call term_sendkeys(buf, ':%s/\\vabc|')\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_incsearch_sub_01', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" The following should not be highlighted\n  call term_sendkeys(buf, ':1,5s/\\v|')\n  sleep 100m\n  call VerifyScreenDump(buf, 'Test_incsearch_sub_02', {})\n\n\n  call StopVimInTerminal(buf)\n  call delete('Xis_subst_script2')\nendfunc\n\nfunc Test_pattern_is_uppercase_smartcase()\n  new\n  let input=['abc', 'ABC', 'Abc', 'abC']\n  call setline(1, input)\n  call cursor(1,1)\n  \" default, matches firstline\n  %s/abc//g\n  call assert_equal(['', 'ABC', 'Abc', 'abC'],\n        \\ getline(1, '$'))\n\n  set smartcase ignorecase\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  \" with smartcase and incsearch set, matches everything\n  %s/abc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  \" with smartcase and incsearch set and found an uppercase letter,\n  \" match only that.\n  %s/abC//g\n  call assert_equal(['abc', 'ABC', 'Abc', ''],\n        \\ getline(1, '$'))\n\n  sil %d\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\%V should not be detected as uppercase letter\n  %s/\\%Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\v%V should not be detected as uppercase letter\n  %s/\\v%Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  exe \"norm! vG$\\<esc>\"\n  \" \\v%VabC should be detected as uppercase letter\n  %s/\\v%VabC//g\n  call assert_equal(['abc', 'ABC', 'Abc', ''],\n        \\ getline(1, '$'))\n\n  call setline(1, input)\n  call cursor(1,1)\n  \" \\Vabc should match everything\n  %s/\\Vabc//g\n  call assert_equal(['', '', '', ''], getline(1, '$'))\n\n  call setline(1, input + ['_abc'])\n  \" _ matches normally\n  %s/\\v_.*//g\n  call assert_equal(['abc', 'ABC', 'Abc', 'abC', ''], getline(1, '$'))\n\n  set smartcase& ignorecase&\n  bw!\nendfunc\n\nfunc Test_no_last_search_pattern()\n  CheckOption incsearch\n\n  let @/ = \"\"\n  set incsearch\n  \" these were causing a crash\n  call feedkeys(\"//\\<C-G>\", 'xt')\n  call feedkeys(\"//\\<C-T>\", 'xt')\n  call feedkeys(\"??\\<C-G>\", 'xt')\n  call feedkeys(\"??\\<C-T>\", 'xt')\nendfunc\n\nfunc Test_search_with_invalid_range()\n  new\n  let lines =<< trim END\n    /\\%.v\n    5/\n    c\n  END\n  call writefile(lines, 'Xrangesearch')\n  source Xrangesearch\n\n  bwipe!\n  call delete('Xrangesearch')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_docmd.c", "src/testdir/test_search.vim", "src/version.c"], "buggy_code_start_loc": [4232, 1991, 759], "buggy_code_end_loc": [4234, 1991, 759], "fixing_code_start_loc": [4232, 1992, 760], "fixing_code_end_loc": [4236, 2006, 762], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3875", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-15T14:15:07.807", "lastModified": "2022-08-26T20:19:38.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable a un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3489", "matchCriteriaId": "0A98C8BE-29E2-4A19-8375-A7CFEECBE09A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/35a319b77f897744eec1155b736e9372c9c5575f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5cdbc168-6ba1-4bc2-ba6c-28be12166a53", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7K4JJBIH3OQSZRVTWKCJCDLGMFGQ5DOH/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/S42L4Z4DTW4LHLQ4FJ33VEOXRCBE7WN4/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/35a319b77f897744eec1155b736e9372c9c5575f"}}