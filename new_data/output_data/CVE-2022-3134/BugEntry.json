{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: Tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: Block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: Invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: Cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: Pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: Pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: Pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: Pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: Line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: Line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\n#endif\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: Line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: Line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: Undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: Undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP) || defined(FEAT_EVAL)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_argument_must_be_positive_str[]\n\tINIT(= N_(\"E487: Argument must be positive: %s\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: Fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\n// E578 unused\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n// E614 unused\n// E615 unused\n// E616 unused\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: Missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: Missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): Write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): Write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: Invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: Invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: Invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: Invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: Invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: Invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: Invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: Invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: Invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: Invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: Invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: Invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: Invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: Invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: Invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: Invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: Invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using a Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_or_types_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' or 'types' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: Expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: Text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type_after_str[]\n\tINIT(= N_(\"E1008: Missing <type> after %s\"));\nEXTERN char e_missing_gt_after_type_str[]\n\tINIT(= N_(\"E1009: Missing > after type: %s\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n# ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n# endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_illegal_character_in_word[]\n\tINIT(= N_(\"E1280: Illegal character in word\"));\n#endif\nEXTERN char e_atom_engine_must_be_at_start_of_pattern[]\n\tINIT(= N_(\"E1281: Atom '\\\\%%#=%c' must be at the start of the pattern\"));\n#ifdef FEAT_EVAL\nEXTERN char e_bitshift_ops_must_be_number[]\n\tINIT(= N_(\"E1282: Bitshift operands must be numbers\"));\nEXTERN char e_bitshift_ops_must_be_postive[]\n\tINIT(= N_(\"E1283: Bitshift amount must be a positive number\"));\n#endif\n#if defined(FEAT_PROP_POPUP)\nEXTERN char e_argument_1_list_item_nr_dictionary_required[]\n\tINIT(= N_(\"E1284: Argument 1, list item %d: Dictionary required\"));\n#endif\n#ifdef FEAT_RELTIME\nEXTERN char e_could_not_clear_timeout_str[]\n\tINIT(= N_(\"E1285: Could not clear timeout: %s\"));\nEXTERN char e_could_not_set_timeout_str[]\n\tINIT(= N_(\"E1286: Could not set timeout: %s\"));\nEXTERN char e_could_not_set_handler_for_timeout_str[]\n\tINIT(= N_(\"E1287: Could not set handler for timeout: %s\"));\nEXTERN char e_could_not_reset_handler_for_timeout_str[]\n\tINIT(= N_(\"E1288: Could not reset handler for timeout: %s\"));\nEXTERN char e_could_not_check_for_pending_sigalrm_str[]\n\tINIT(= N_(\"E1289: Could not check for pending SIGALRM: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_substitute_nesting_too_deep[]\n\tINIT(= N_(\"E1290: substitute nesting too deep\"));\nEXTERN char e_invalid_argument_nr[]\n\tINIT(= N_(\"E1291: Invalid argument: %ld\"));\n#endif\n#ifdef FEAT_CMDWIN\nEXTERN char e_cmdline_window_already_open[]\n\tINIT(= N_(\"E1292: Command-line window is already open\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_negative_id_after_adding_textprop_with_text[]\n\tINIT(= N_(\"E1293: Cannot use a negative id after adding a textprop with text\"));\nEXTERN char e_can_only_use_text_align_when_column_is_zero[]\n\tINIT(= N_(\"E1294: Can only use text_align when column is zero\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_specify_both_type_and_types[]\n\tINIT(= N_(\"E1295: Cannot specify both 'type' and 'types'\"));\nEXTERN char e_can_only_use_left_padding_when_column_is_zero[]\n\tINIT(= N_(\"E1296: Can only use left padding when column is zero\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_null_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1297: Non-NULL Dictionary required for argument %d\"));\nEXTERN char e_non_null_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1298: Non-NULL List required for argument %d\"));\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle tags and the tag stack\n */\n\n#include \"vim.h\"\n\n/*\n * Structure to hold pointers to various items in a tag line.\n */\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n/*\n * Return values used when reading lines from a tags file.\n */\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n} tags_read_status_T;\n\n/*\n * States used during a tags search\n */\ntypedef enum\n{\n    TS_START,\t\t// at start of file\n    TS_LINEAR,\t\t// linear searching forward, till EOF\n    TS_BINARY,\t\t// binary searching\n    TS_SKIP_BACK,\t// skipping backwards\n    TS_STEP_FORWARD\t// stepping forwards\n} tagsearch_state_T;\t// Current search state\n\n/*\n * Binary search file offsets in a tags file\n */\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n} tagsearch_info_T;\n\n/*\n * Return values used when matching tags against a pattern.\n */\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n} tagmatch_status_T;\n\n/*\n * Arguments used for matching tags read from a tags file against a pattern.\n */\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n} findtags_match_args_T;\n\n/*\n * The matching tags are first stored in one of the hash tables.  In\n * which one depends on the priority of the match.\n * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.\n * At the end, all the matches from ga_match[] are concatenated, to make a list\n * sorted on priority.\n */\n#define MT_ST_CUR\t0\t\t// static match in current file\n#define MT_GL_CUR\t1\t\t// global match in current file\n#define MT_GL_OTH\t2\t\t// global match in other file\n#define MT_ST_OTH\t3\t\t// static match in other file\n#define MT_IC_OFF\t4\t\t// add for icase match\n#define MT_RE_OFF\t8\t\t// add for regexp match\n#define MT_MASK\t\t7\t\t// mask for printing priority\n#define MT_COUNT\t16\n\nstatic char\t*mt_names[MT_COUNT/2] =\n\t\t{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};\n\n#define NOTAGFILE\t99\t\t// return value for jumpto_tag\nstatic char_u\t*nofile_fname = NULL;\t// fname for NOTAGFILE error\n\nstatic void taglen_advance(int l);\n\nstatic int jumpto_tag(char_u *lbuf, int forceit, int keep_help);\n#ifdef FEAT_EMACS_TAGS\nstatic int parse_tag_line(char_u *lbuf, int is_etag, tagptrs_T *tagp);\n#else\nstatic int parse_tag_line(char_u *lbuf, tagptrs_T *tagp);\n#endif\nstatic int test_for_static(tagptrs_T *);\nstatic int parse_match(char_u *lbuf, tagptrs_T *tagp);\nstatic char_u *tag_full_fname(tagptrs_T *tagp);\nstatic char_u *expand_tag_fname(char_u *fname, char_u *tag_fname, int expand);\n#ifdef FEAT_EMACS_TAGS\nstatic int test_for_current(int, char_u *, char_u *, char_u *, char_u *);\n#else\nstatic int test_for_current(char_u *, char_u *, char_u *, char_u *);\n#endif\nstatic int find_extra(char_u **pp);\nstatic void print_tag_list(int new_tag, int use_tagstack, int num_matches, char_u **matches);\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\nstatic int add_llist_tags(char_u *tag, int num_matches, char_u **matches);\n#endif\nstatic void tagstack_clear_entry(taggy_T *item);\n\nstatic char_u\t*tagmatchname = NULL;\t// name of last used tag\n\n#if defined(FEAT_QUICKFIX)\n/*\n * Tag for preview window is remembered separately, to avoid messing up the\n * normal tagstack.\n */\nstatic taggy_T ptag_entry = {NULL, {{0, 0, 0}, 0}, 0, 0, NULL};\n#endif\n\n#ifdef FEAT_EVAL\nstatic int  tfu_in_use = FALSE;\t    // disallow recursive call of tagfunc\nstatic callback_T tfu_cb;\t    // 'tagfunc' callback function\n#endif\n\n// Used instead of NUL to separate tag fields in the growarrays.\n#define TAG_SEP 0x02\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Reads the 'tagfunc' option value and convert that to a callback value.\n * Invoked when the 'tagfunc' option is set. The option value can be a name of\n * a function (string), or function(<name>) or funcref(<name>) or a lambda.\n */\n    int\nset_tagfunc_option(void)\n{\n#ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n    free_callback(&curbuf->b_tfu_cb);\n\n    if (*curbuf->b_p_tfu == NUL)\n\treturn OK;\n\n    if (option_set_callback_func(curbuf->b_p_tfu, &tfu_cb) == FAIL)\n\treturn FAIL;\n\n    copy_callback(&curbuf->b_tfu_cb, &tfu_cb);\n#endif\n\n    return OK;\n}\n#endif\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tagfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n# endif\n}\n# endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'tagfunc' callback with 'copyID' so that it is not garbage\n * collected.\n */\n    int\nset_ref_in_tagfunc(int copyID UNUSED)\n{\n    int\tabort = FALSE;\n\n    abort = set_ref_in_callback(&tfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Copy the global 'tagfunc' callback function to the buffer-local 'tagfunc'\n * callback for 'buf'.\n */\n    void\nset_buflocal_tfu_callback(buf_T *buf UNUSED)\n{\n    free_callback(&buf->b_tfu_cb);\n    if (tfu_cb.cb_name != NULL && *tfu_cb.cb_name != NUL)\n\tcopy_callback(&buf->b_tfu_cb, &tfu_cb);\n}\n#endif\n\n/*\n * Jump to tag; handling of tag commands and tag stack\n *\n * *tag != NUL: \":tag {tag}\", jump to new tag, add to tag stack\n *\n * type == DT_TAG:\t\":tag [tag]\", jump to newer position or same tag again\n * type == DT_HELP:\tlike DT_TAG, but don't use regexp.\n * type == DT_POP:\t\":pop\" or CTRL-T, jump to old position\n * type == DT_NEXT:\tjump to next match of same tag\n * type == DT_PREV:\tjump to previous match of same tag\n * type == DT_FIRST:\tjump to first match of same tag\n * type == DT_LAST:\tjump to last match of same tag\n * type == DT_SELECT:\t\":tselect [tag]\", select tag from a list of all matches\n * type == DT_JUMP:\t\":tjump [tag]\", jump to tag or select tag from a list\n * type == DT_CSCOPE:\tuse cscope to find the tag\n * type == DT_LTAG:\tuse location list for displaying tag matches\n * type == DT_FREE:\tfree cached matches\n *\n * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise\n */\n    int\ndo_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * List all the matching tags.\n */\n    static void\nprint_tag_list(\n    int\t\tnew_tag,\n    int\t\tuse_tagstack,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*command_end;\n    tagptrs_T\ttagp;\n    int\t\ttaglen;\n    int\t\tattr;\n\n    /*\n     * Assume that the first match indicates how long the tags can\n     * be, and align the file names to that.\n     */\n    parse_match(matches[0], &tagp);\n    taglen = (int)(tagp.tagname_end - tagp.tagname + 2);\n    if (taglen < 18)\n\ttaglen = 18;\n    if (taglen > Columns - 25)\n\ttaglen = MAXCOL;\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\t// overwrite previous message\n    msg_start();\n    msg_puts_attr(_(\"  # pri kind tag\"), HL_ATTR(HLF_T));\n    msg_clr_eos();\n    taglen_advance(taglen);\n    msg_puts_attr(_(\"file\\n\"), HL_ATTR(HLF_T));\n\n    for (i = 0; i < num_matches && !got_int; ++i)\n    {\n\tparse_match(matches[i], &tagp);\n\tif (!new_tag && (\n#if defined(FEAT_QUICKFIX)\n\t\t    (g_do_tagpreview != 0\n\t\t     && i == ptag_entry.cur_match) ||\n#endif\n\t\t    (use_tagstack\n\t\t     && i == tagstack[tagstackidx].cur_match)))\n\t    *IObuff = '>';\n\telse\n\t    *IObuff = ' ';\n\tvim_snprintf((char *)IObuff + 1, IOSIZE - 1,\n\t\t\"%2d %s \", i + 1,\n\t\t\t       mt_names[matches[i][0] & MT_MASK]);\n\tmsg_puts((char *)IObuff);\n\tif (tagp.tagkind != NULL)\n\t    msg_outtrans_len(tagp.tagkind,\n\t\t\t  (int)(tagp.tagkind_end - tagp.tagkind));\n\tmsg_advance(13);\n\tmsg_outtrans_len_attr(tagp.tagname,\n\t\t\t   (int)(tagp.tagname_end - tagp.tagname),\n\t\t\t\t\t\t  HL_ATTR(HLF_T));\n\tmsg_putchar(' ');\n\ttaglen_advance(taglen);\n\n\t// Find out the actual file name. If it is long, truncate\n\t// it and put \"...\" in the middle\n\tp = tag_full_fname(&tagp);\n\tif (p != NULL)\n\t{\n\t    msg_outtrans_long_attr(p, HL_ATTR(HLF_D));\n\t    vim_free(p);\n\t}\n\tif (msg_col > 0)\n\t    msg_putchar('\\n');\n\tif (got_int)\n\t    break;\n\tmsg_advance(15);\n\n\t// print any extra fields\n\tcommand_end = tagp.command_end;\n\tif (command_end != NULL)\n\t{\n\t    p = command_end + 3;\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t    {\n\t\twhile (*p == TAB)\n\t\t    ++p;\n\n\t\t// skip \"file:\" without a value (static tag)\n\t\tif (STRNCMP(p, \"file:\", 5) == 0\n\t\t\t\t\t     && vim_isspace(p[5]))\n\t\t{\n\t\t    p += 5;\n\t\t    continue;\n\t\t}\n\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\tif (p == tagp.tagkind\n\t\t\t|| (p + 5 == tagp.tagkind\n\t\t\t\t&& STRNCMP(p, \"kind:\", 5) == 0))\n\t\t{\n\t\t    p = tagp.tagkind_end;\n\t\t    continue;\n\t\t}\n\t\t// print all other extra fields\n\t\tattr = HL_ATTR(HLF_CM);\n\t\twhile (*p && *p != '\\r' && *p != '\\n')\n\t\t{\n\t\t    if (msg_col + ptr2cells(p) >= Columns)\n\t\t    {\n\t\t\tmsg_putchar('\\n');\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t\tmsg_advance(15);\n\t\t    }\n\t\t    p = msg_outtrans_one(p, attr);\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tmsg_puts_attr(\" \", attr);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*p == ':')\n\t\t\tattr = 0;\n\t\t}\n\t    }\n\t    if (msg_col > 15)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    break;\n\t\tmsg_advance(15);\n\t    }\n\t}\n\telse\n\t{\n\t    for (p = tagp.command;\n\t\t\t      *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t;\n\t    command_end = p;\n\t}\n\n\t// Put the info (in several lines) at column 15.\n\t// Don't display \"/^\" and \"?^\".\n\tp = tagp.command;\n\tif (*p == '/' || *p == '?')\n\t{\n\t    ++p;\n\t    if (*p == '^')\n\t\t++p;\n\t}\n\t// Remove leading whitespace from pattern\n\twhile (p != command_end && vim_isspace(*p))\n\t    ++p;\n\n\twhile (p != command_end)\n\t{\n\t    if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)\n\t\tmsg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_advance(15);\n\n\t    // skip backslash used for escaping a command char or\n\t    // a backslash\n\t    if (*p == '\\\\' && (*(p + 1) == *tagp.command\n\t\t\t    || *(p + 1) == '\\\\'))\n\t\t++p;\n\n\t    if (*p == TAB)\n\t    {\n\t\tmsg_putchar(' ');\n\t\t++p;\n\t    }\n\t    else\n\t\tp = msg_outtrans_one(p, 0);\n\n\t    // don't display the \"$/;\\\"\" and \"$?;\\\"\"\n\t    if (p == command_end - 2 && *p == '$'\n\t\t\t\t     && *(p + 1) == *tagp.command)\n\t\tbreak;\n\t    // don't display matching '/' or '?'\n\t    if (p == command_end - 1 && *p == *tagp.command\n\t\t\t\t     && (*p == '/' || *p == '?'))\n\t\tbreak;\n\t}\n\tif (msg_col)\n\t    msg_putchar('\\n');\n\tui_breakcheck();\n    }\n    if (got_int)\n\tgot_int = FALSE;\t// only stop the listing\n}\n\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n/*\n * Add the matching tags to the location list for the current\n * window.\n */\n    static int\nadd_llist_tags(\n    char_u\t*tag,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    list_T\t*list;\n    char_u\ttag_name[128 + 1];\n    char_u\t*fname;\n    char_u\t*cmd;\n    int\t\ti;\n    char_u\t*p;\n    tagptrs_T\ttagp;\n\n    fname = alloc(MAXPATHL + 1);\n    cmd = alloc(CMDBUFFSIZE + 1);\n    list = list_alloc();\n    if (list == NULL || fname == NULL || cmd == NULL)\n    {\n\tvim_free(cmd);\n\tvim_free(fname);\n\tif (list != NULL)\n\t    list_free(list);\n\treturn FAIL;\n    }\n\n    for (i = 0; i < num_matches; ++i)\n    {\n\tint\t    len, cmd_len;\n\tlong    lnum;\n\tdict_T  *dict;\n\n\tparse_match(matches[i], &tagp);\n\n\t// Save the tag name\n\tlen = (int)(tagp.tagname_end - tagp.tagname);\n\tif (len > 128)\n\t    len = 128;\n\tvim_strncpy(tag_name, tagp.tagname, len);\n\ttag_name[len] = NUL;\n\n\t// Save the tag file name\n\tp = tag_full_fname(&tagp);\n\tif (p == NULL)\n\t    continue;\n\tvim_strncpy(fname, p, MAXPATHL);\n\tvim_free(p);\n\n\t// Get the line number or the search pattern used to locate\n\t// the tag.\n\tlnum = 0;\n\tif (isdigit(*tagp.command))\n\t    // Line number is used to locate the tag\n\t    lnum = atol((char *)tagp.command);\n\telse\n\t{\n\t    char_u *cmd_start, *cmd_end;\n\n\t    // Search pattern is used to locate the tag\n\n\t    // Locate the end of the command\n\t    cmd_start = tagp.command;\n\t    cmd_end = tagp.command_end;\n\t    if (cmd_end == NULL)\n\t    {\n\t\tfor (p = tagp.command;\n\t\t     *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t    ;\n\t\tcmd_end = p;\n\t    }\n\n\t    // Now, cmd_end points to the character after the\n\t    // command. Adjust it to point to the last\n\t    // character of the command.\n\t    cmd_end--;\n\n\t    // Skip the '/' and '?' characters at the\n\t    // beginning and end of the search pattern.\n\t    if (*cmd_start == '/' || *cmd_start == '?')\n\t\tcmd_start++;\n\n\t    if (*cmd_end == '/' || *cmd_end == '?')\n\t\tcmd_end--;\n\n\t    len = 0;\n\t    cmd[0] = NUL;\n\n\t    // If \"^\" is present in the tag search pattern, then\n\t    // copy it first.\n\t    if (*cmd_start == '^')\n\t    {\n\t\tSTRCPY(cmd, \"^\");\n\t\tcmd_start++;\n\t\tlen++;\n\t    }\n\n\t    // Precede the tag pattern with \\V to make it very\n\t    // nomagic.\n\t    STRCAT(cmd, \"\\\\V\");\n\t    len += 2;\n\n\t    cmd_len = (int)(cmd_end - cmd_start + 1);\n\t    if (cmd_len > (CMDBUFFSIZE - 5))\n\t\tcmd_len = CMDBUFFSIZE - 5;\n\t    STRNCAT(cmd, cmd_start, cmd_len);\n\t    len += cmd_len;\n\n\t    if (cmd[len - 1] == '$')\n\t    {\n\t\t// Replace '$' at the end of the search pattern\n\t\t// with '\\$'\n\t\tcmd[len - 1] = '\\\\';\n\t\tcmd[len] = '$';\n\t\tlen++;\n\t    }\n\n\t    cmd[len] = NUL;\n\t}\n\n\tif ((dict = dict_alloc()) == NULL)\n\t    continue;\n\tif (list_append_dict(list, dict) == FAIL)\n\t{\n\t    vim_free(dict);\n\t    continue;\n\t}\n\n\tdict_add_string(dict, \"text\", tag_name);\n\tdict_add_string(dict, \"filename\", fname);\n\tdict_add_number(dict, \"lnum\", lnum);\n\tif (lnum == 0)\n\t    dict_add_string(dict, \"pattern\", cmd);\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, \"ltag %s\", tag);\n    set_errorlist(curwin, list, ' ', IObuff, NULL);\n\n    list_free(list);\n    vim_free(fname);\n    vim_free(cmd);\n\n    return OK;\n}\n#endif\n\n/*\n * Free cached tags.\n */\n    void\ntag_freematch(void)\n{\n    VIM_CLEAR(tagmatchname);\n}\n\n    static void\ntaglen_advance(int l)\n{\n    if (l == MAXCOL)\n    {\n\tmsg_putchar('\\n');\n\tmsg_advance(24);\n    }\n    else\n\tmsg_advance(13 + l);\n}\n\n/*\n * Print the tag stack\n */\n    void\ndo_tags(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));\n    for (i = 0; i < tagstacklen; ++i)\n    {\n\tif (tagstack[i].tagname != NULL)\n\t{\n\t    name = fm_getname(&(tagstack[i].fmark), 30);\n\t    if (name == NULL)\t    // file name not available\n\t\tcontinue;\n\n\t    msg_putchar('\\n');\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%c%2d %2d %-15s %5ld  \",\n\t\ti == tagstackidx ? '>' : ' ',\n\t\ti + 1,\n\t\ttagstack[i].cur_match + 1,\n\t\ttagstack[i].tagname,\n\t\ttagstack[i].fmark.mark.lnum);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t}\n\tout_flush();\t\t    // show one line at a time\n    }\n    if (tagstackidx == tagstacklen)\t// idx at top of stack\n\tmsg_puts(\"\\n>\");\n}\n\n/*\n * Compare two strings, for length \"len\", ignoring case the ASCII way.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n */\n    static int\ntag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOUPPER_ASC(*s1) - (int)TOUPPER_ASC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t// this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t// strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t// strings match\n}\n\n/*\n * Structure to hold info about the tag pattern being used.\n */\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n} pat_T;\n\n/*\n * Extract info from the tag search pattern \"pats->pat\".\n */\n    static void\nprepare_pats(pat_T *pats, int has_re)\n{\n    pats->head = pats->pat;\n    pats->headlen = pats->len;\n    if (has_re)\n    {\n\t// When the pattern starts with '^' or \"\\\\<\", binary searching can be\n\t// used (much faster).\n\tif (pats->pat[0] == '^')\n\t    pats->head = pats->pat + 1;\n\telse if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')\n\t    pats->head = pats->pat + 2;\n\tif (pats->head == pats->pat)\n\t    pats->headlen = 0;\n\telse\n\t    for (pats->headlen = 0; pats->head[pats->headlen] != NUL;\n\t\t\t\t\t\t\t      ++pats->headlen)\n\t\tif (vim_strchr((char_u *)(magic_isset() ? \".[~*\\\\$\" : \"\\\\$\"),\n\t\t\t\t\t   pats->head[pats->headlen]) != NULL)\n\t\t    break;\n\tif (p_tl != 0 && pats->headlen > p_tl)\t// adjust for 'taglength'\n\t    pats->headlen = p_tl;\n    }\n\n    if (has_re)\n\tpats->regmatch.regprog = vim_regcomp(pats->pat,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n    else\n\tpats->regmatch.regprog = NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call the user-defined function to generate a list of tags used by\n * find_tags().\n *\n * Return OK if at least 1 tag has been successfully found,\n * NOTDONE if the function returns v:null, and FAIL otherwise.\n */\n    static int\nfind_tagfunc_tags(\n    char_u\t*pat,\t\t// pattern supplied to the user-defined function\n    garray_T\t*ga,\t\t// the tags will be placed here\n    int\t\t*match_count,\t// here the number of tags found will be placed\n    int\t\tflags,\t\t// flags from find_tags (TAG_*)\n    char_u\t*buf_ffname)\t// name of buffer for priority\n{\n    pos_T       save_pos;\n    list_T      *taglist;\n    listitem_T  *item;\n    int\t\tntags = 0;\n    int\t\tresult = FAIL;\n    typval_T\targs[4];\n    typval_T\trettv;\n    char_u      flagString[4];\n    dict_T\t*d;\n    taggy_T\t*tag = &curwin->w_tagstack[curwin->w_tagstackidx];\n\n    if (*curbuf->b_p_tfu == NUL || curbuf->b_tfu_cb.cb_name == NULL\n\t\t\t\t\t   || *curbuf->b_tfu_cb.cb_name == NUL)\n\treturn FAIL;\n\n    args[0].v_type = VAR_STRING;\n    args[0].vval.v_string = pat;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = flagString;\n\n    // create 'info' dict argument\n    if ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\treturn FAIL;\n    if (tag->user_data != NULL)\n\tdict_add_string(d, \"user_data\", tag->user_data);\n    if (buf_ffname != NULL)\n\tdict_add_string(d, \"buf_ffname\", buf_ffname);\n\n    ++d->dv_refcount;\n    args[2].v_type = VAR_DICT;\n    args[2].vval.v_dict = d;\n\n    args[3].v_type = VAR_UNKNOWN;\n\n    vim_snprintf((char *)flagString, sizeof(flagString),\n\t\t \"%s%s%s\",\n\t\t g_tag_at_cursor      ? \"c\": \"\",\n\t\t flags & TAG_INS_COMP ? \"i\": \"\",\n\t\t flags & TAG_REGEXP   ? \"r\": \"\");\n\n    save_pos = curwin->w_cursor;\n    result = call_callback(&curbuf->b_tfu_cb, 0, &rettv, 3, args);\n    curwin->w_cursor = save_pos;\t// restore the cursor position\n    --d->dv_refcount;\n\n    if (result == FAIL)\n\treturn FAIL;\n    if (rettv.v_type == VAR_SPECIAL && rettv.vval.v_number == VVAL_NULL)\n    {\n\tclear_tv(&rettv);\n\treturn NOTDONE;\n    }\n    if (rettv.v_type != VAR_LIST || !rettv.vval.v_list)\n    {\n\tclear_tv(&rettv);\n\temsg(_(e_invalid_return_value_from_tagfunc));\n\treturn FAIL;\n    }\n    taglist = rettv.vval.v_list;\n\n    FOR_ALL_LIST_ITEMS(taglist, item)\n    {\n\tchar_u\t\t*mfp;\n\tchar_u\t\t*res_name, *res_fname, *res_cmd, *res_kind;\n\tint\t\tlen;\n\tdict_iterator_T\titer;\n\tchar_u\t\t*dict_key;\n\ttypval_T\t*tv;\n\tint\t\thas_extra = 0;\n\tint\t\tname_only = flags & TAG_NAMES;\n\n\tif (item->li_tv.v_type != VAR_DICT)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n#ifdef FEAT_EMACS_TAGS\n\tlen = 3;\n#else\n\tlen = 2;\n#endif\n\tres_name = NULL;\n\tres_fname = NULL;\n\tres_cmd = NULL;\n\tres_kind = NULL;\n\n\tdict_iterate_start(&item->li_tv, &iter);\n\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t{\n\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\tcontinue;\n\n\t    len += (int)STRLEN(tv->vval.v_string) + 1;   // Space for \"\\tVALUE\"\n\t    if (!STRCMP(dict_key, \"name\"))\n\t    {\n\t\tres_name = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"filename\"))\n\t    {\n\t\tres_fname = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"cmd\"))\n\t    {\n\t\tres_cmd = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    has_extra = 1;\n\t    if (!STRCMP(dict_key, \"kind\"))\n\t    {\n\t\tres_kind = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    // Other elements will be stored as \"\\tKEY:VALUE\"\n\t    // Allocate space for the key and the colon\n\t    len += (int)STRLEN(dict_key) + 1;\n\t}\n\n\tif (has_extra)\n\t    len += 2;\t// need space for ;\"\n\n\tif (!res_name || !res_fname || !res_cmd)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n\tif (name_only)\n\t    mfp = vim_strsave(res_name);\n\telse\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\n\tif (mfp == NULL)\n\t    continue;\n\n\tif (!name_only)\n\t{\n\t    char_u *p = mfp;\n\n\t    *p++ = MT_GL_OTH + 1;   // mtt\n\t    *p++ = TAG_SEP;\t    // no tag file name\n#ifdef FEAT_EMACS_TAGS\n\t    *p++ = TAG_SEP;\n#endif\n\n\t    STRCPY(p, res_name);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_fname);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_cmd);\n\t    p += STRLEN(p);\n\n\t    if (has_extra)\n\t    {\n\t\tSTRCPY(p, \";\\\"\");\n\t\tp += STRLEN(p);\n\n\t\tif (res_kind)\n\t\t{\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, res_kind);\n\t\t    p += STRLEN(p);\n\t\t}\n\n\t\tdict_iterate_start(&item->li_tv, &iter);\n\t\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t\t{\n\t\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\t\tcontinue;\n\n\t\t    if (!STRCMP(dict_key, \"name\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"filename\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"cmd\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"kind\"))\n\t\t\tcontinue;\n\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, dict_key);\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, \":\");\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, tv->vval.v_string);\n\t\t    p += STRLEN(p);\n\t\t}\n\t    }\n\t}\n\n\t// Add all matches because tagfunc should do filtering.\n\tif (ga_grow(ga, 1) == OK)\n\t{\n\t    ((char_u **)(ga->ga_data))[ga->ga_len++] = mfp;\n\t    ++ntags;\n\t    result = OK;\n\t}\n\telse\n\t{\n\t    vim_free(mfp);\n\t    break;\n\t}\n    }\n\n    clear_tv(&rettv);\n\n    *match_count = ntags;\n    return result;\n}\n#endif\n\n/*\n * State information used during a tag search\n */\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help language priority\n    char_u\t*help_lang_find;\t// lang to be found\n    int\t\tis_txt;\t\t\t// flag of file extension\n#endif\n    int\t\tmatch_count;\t\t// number of matches found\n    garray_T\tga_match[MT_COUNT];\t// stores matches in sequence\n    hashtab_T\tht_match[MT_COUNT];\t// stores matches by key\n} findtags_state_T;\n\n/*\n * Initialize the state used by find_tags().\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    static int\nfindtags_state_init(\n    findtags_state_T\t*st,\n    char_u\t\t*pat,\n    int\t\t\tflags,\n    int\t\t\tmincount)\n{\n    int\t\tmtt;\n\n    st->tag_fname = alloc(MAXPATHL + 1);\n    st->fp = NULL;\n    st->orgpat = ALLOC_ONE(pat_T);\n    st->orgpat->pat = pat;\n    st->orgpat->len = (int)STRLEN(pat);\n    st->orgpat->regmatch.regprog = NULL;\n    st->flags = flags;\n    st->tag_file_sorted = NUL;\n    st->help_only = (flags & TAG_HELP);\n    st->get_searchpat = FALSE;\n#ifdef FEAT_MULTI_LANG\n    st->help_lang[0] = NUL;\n    st->help_pri = 0;\n    st->help_lang_find = NULL;\n    st->is_txt = FALSE;\n#endif\n    st->did_open = FALSE;\n    st->mincount = mincount;\n    st->lbuf_size = LSIZE;\n    st->lbuf = alloc(st->lbuf_size);\n#ifdef FEAT_EMACS_TAGS\n    st->ebuf = alloc(LSIZE);\n#endif\n    st->match_count = 0;\n    st->stop_searching = FALSE;\n\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tga_init2(&st->ga_match[mtt], sizeof(char_u *), 100);\n\thash_init(&st->ht_match[mtt]);\n    }\n\n    // check for out of memory situation\n    if (st->tag_fname == NULL\n\t    || st->lbuf == NULL\n#ifdef FEAT_EMACS_TAGS\n\t    || st->ebuf == NULL\n#endif\n       )\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the state used by find_tags()\n */\n    static void\nfindtags_state_free(findtags_state_T *st)\n{\n    vim_free(st->tag_fname);\n    vim_free(st->lbuf);\n    vim_regfree(st->orgpat->regmatch.regprog);\n    vim_free(st->orgpat);\n#ifdef FEAT_EMACS_TAGS\n    vim_free(st->ebuf);\n#endif\n}\n\n#ifdef FEAT_MULTI_LANG\n/*\n * Initialize the language and priority used for searching tags in a Vim help\n * file.\n * Returns TRUE to process the help file for tags and FALSE to skip the file.\n */\n    static int\nfindtags_in_help_init(findtags_state_T *st)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    // Keep 'en' as the language if the file extension is '.txt'\n    if (st->is_txt)\n\tSTRCPY(st->help_lang, \"en\");\n    else\n    {\n\t// Prefer help tags according to 'helplang'.  Put the two-letter\n\t// language name in help_lang[].\n\ti = (int)STRLEN(st->tag_fname);\n\tif (i > 3 && st->tag_fname[i - 3] == '-')\n\t    vim_strncpy(st->help_lang, st->tag_fname + i - 2, 2);\n\telse\n\t    STRCPY(st->help_lang, \"en\");\n    }\n    // When searching for a specific language skip tags files for other\n    // languages.\n    if (st->help_lang_find != NULL\n\t    && STRICMP(st->help_lang, st->help_lang_find) != 0)\n\treturn FALSE;\n\n    // For CTRL-] in a help file prefer a match with the same language.\n    if ((st->flags & TAG_KEEP_LANG)\n\t    && st->help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && curbuf->b_fname[i - 1] == 'x'\n\t    && curbuf->b_fname[i - 4] == '.'\n\t    && STRNICMP(curbuf->b_fname + i - 3, st->help_lang, 2) == 0)\n\tst->help_pri = 0;\n    else\n    {\n\t// search for the language in 'helplang'\n\tst->help_pri = 1;\n\tfor (s = p_hlg; *s != NUL; ++s)\n\t{\n\t    if (STRNICMP(s, st->help_lang, 2) == 0)\n\t\tbreak;\n\t    ++st->help_pri;\n\t    if ((s = vim_strchr(s, ',')) == NULL)\n\t\tbreak;\n\t}\n\tif (s == NULL || *s == NUL)\n\t{\n\t    // Language not in 'helplang': use last, prefer English, unless\n\t    // found already.\n\t    ++st->help_pri;\n\t    if (STRICMP(st->help_lang, \"en\") != 0)\n\t\t++st->help_pri;\n\t}\n    }\n\n    return TRUE;\n}\n#endif\n\n#ifdef FEAT_EVAL\n/*\n * Use the function set in 'tagfunc' (if configured and enabled) to get the\n * tags.\n * Return OK if at least 1 tag has been successfully found, NOTDONE if the\n * 'tagfunc' is not used or the 'tagfunc' returns v:null and FAIL otherwise.\n */\n    static int\nfindtags_apply_tfu(findtags_state_T *st, char_u *pat, char_u *buf_ffname)\n{\n    int\t\tuse_tfu = ((st->flags & TAG_NO_TAGFUNC) == 0);\n    int\t\tretval;\n\n    if (!use_tfu || tfu_in_use || *curbuf->b_p_tfu == NUL)\n\treturn NOTDONE;\n\n    tfu_in_use = TRUE;\n    retval = find_tagfunc_tags(pat, st->ga_match, &st->match_count,\n\t\t\t\t\t\tst->flags, buf_ffname);\n    tfu_in_use = FALSE;\n\n    return retval;\n}\n#endif\n\n#ifdef FEAT_EMACS_TAGS\n/*\n * Stack for included emacs-tags file.\n * It has a fixed size, to truncate cyclic includes. jw\n */\n# define INCSTACK_SIZE 42\nstatic struct\n{\n    FILE\t*fp;\n    char_u\t*etag_fname;\n} incstack[INCSTACK_SIZE];\nstatic int incstack_idx = 0;\t// index in incstack\n\n/*\n * Free the emacs include tags file stack.\n */\n    static void\nemacs_tags_incstack_free(void)\n{\n    while (incstack_idx)\n    {\n\t--incstack_idx;\n\tfclose(incstack[incstack_idx].fp);\n\tincstack[incstack_idx].fp = NULL;\n\tVIM_CLEAR(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Emacs tags line with CTRL-L: New file name on next line.\n * The file name is followed by a ','.  Remember etag file name in ebuf.\n * The FILE pointer to the tags file is stored in 'st->fp'.  If another tags\n * file is included, then the FILE pointer to the new tags file is stored in\n * 'st->fp'. The old file pointer is saved in incstack.\n */\n    static void\nemacs_tags_new_filename(findtags_state_T *st)\n{\n    char_u\t*p;\n    char_u\t*fullpath_ebuf;\n\n    if (vim_fgets(st->ebuf, LSIZE, st->fp))\n\treturn;\n\n    for (p = st->ebuf; *p && *p != ','; p++)\n\t;\n    *p = NUL;\n\n    // check for an included tags file.\n    // atoi(p+1) is the number of bytes before the next ^L unless it is an\n    // include statement. Skip the included tags file if it exceeds the\n    // maximum.\n    if (STRNCMP(p + 1, \"include\", 7) != 0 || incstack_idx >= INCSTACK_SIZE)\n\treturn;\n\n    // Save current \"fp\" and \"tag_fname\" in the stack.\n    incstack[incstack_idx].etag_fname = vim_strsave(st->tag_fname);\n    if (incstack[incstack_idx].etag_fname == NULL)\n\treturn;\n\n    incstack[incstack_idx].fp = st->fp;\n    st->fp = NULL;\n\n    // Figure out \"tag_fname\" and \"fp\" to use for\n    // included file.\n    fullpath_ebuf = expand_tag_fname(st->ebuf, st->tag_fname, FALSE);\n    if (fullpath_ebuf != NULL)\n    {\n\tst->fp = mch_fopen((char *)fullpath_ebuf, \"r\");\n\tif (st->fp != NULL)\n\t{\n\t    if (STRLEN(fullpath_ebuf) > LSIZE)\n\t\tsemsg(_(e_tag_file_path_truncated_for_str), st->ebuf);\n\t    vim_strncpy(st->tag_fname, fullpath_ebuf, MAXPATHL);\n\t    ++incstack_idx;\n\t    st->is_etag = FALSE; // we can include anything\n\t}\n\tvim_free(fullpath_ebuf);\n    }\n    if (st->fp == NULL)\n    {\n\t// Can't open the included file, skip it and\n\t// restore old value of \"fp\".\n\tst->fp = incstack[incstack_idx].fp;\n\tvim_free(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Reached the end of an emacs-style tags file. If this is an included tags\n * file, then pop it from the incstack and continue processing the parent tags\n * file. Otherwise, processed all the tags.\n * Returns TRUE if an included tags file is popped and processing should\n * continue with the parent tags file. Returns FALSE to stop processing tags.\n */\n    static int\nemacs_tags_file_eof(findtags_state_T *st)\n{\n    if (!incstack_idx)\t// reached end of file. stop processing.\n\treturn FALSE;\n\n    // reached the end of an included tags file. pop it.\n    --incstack_idx;\n    fclose(st->fp);\t// end of this file ...\n    st->fp = incstack[incstack_idx].fp;\n    STRCPY(st->tag_fname, incstack[incstack_idx].etag_fname);\n    vim_free(incstack[incstack_idx].etag_fname);\n    st->is_etag = TRUE;\t// (only etags can include)\n\n    return TRUE;\n}\n\n/*\n * Parse a line from an emacs-style tags file.\n * Returns OK if the line is parsed successfully, returns FAIL if the line is\n * not terminated by a newline.\n */\n    static int\nemacs_tags_parse_line(char_u *lbuf, tagptrs_T *tagp)\n{\n    char_u\t*p_7f;\n    char_u\t*p;\n\n    // There are two formats for an emacs tag line:\n    // 1:  struct EnvBase ^?EnvBase^A139,4627\n    // 2: #define\tARPB_WILD_WORLD ^?153,5194\n    p_7f = vim_strchr(lbuf, 0x7f);\n    if (p_7f == NULL)\n    {\netag_fail:\n\tif (vim_strchr(lbuf, '\\n') != NULL)\n\t    return FAIL;\n\n\t// Truncated line.  Ignore it.\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    msg(_(\"Ignoring long line in tags file\"));\n\t    verbose_leave();\n\t}\n\ttagp->command = lbuf;\n\ttagp->tagname = lbuf;\n\ttagp->tagname_end = lbuf;\n\treturn OK;\n    }\n\n    // Find ^A.  If not found the line number is after the 0x7f\n    p = vim_strchr(p_7f, Ctrl_A);\n    if (p == NULL)\n\tp = p_7f + 1;\n    else\n\t++p;\n\n    if (!VIM_ISDIGIT(*p))\t    // check for start of line number\n\tgoto etag_fail;\n    tagp->command = p;\n\n    if (p[-1] == Ctrl_A)\t    // first format: explicit tagname given\n    {\n\ttagp->tagname = p_7f + 1;\n\ttagp->tagname_end = p - 1;\n    }\n    else\t\t\t    // second format: isolate tagname\n    {\n\t// find end of tagname\n\tfor (p = p_7f - 1; !vim_iswordc(*p); --p)\n\t    if (p == lbuf)\n\t\tgoto etag_fail;\n\ttagp->tagname_end = p + 1;\n\twhile (p >= lbuf && vim_iswordc(*p))\n\t    --p;\n\ttagp->tagname = p + 1;\n    }\n\n    return OK;\n}\n#endif\n\n/*\n * Read the next line from a tags file.\n * Returns TAGS_READ_SUCCESS if a tags line is successfully read and should be\n * processed.\n * Returns TAGS_READ_EOF if the end of file is reached.\n * Returns TAGS_READ_IGNORE if the current line should be ignored (used when\n * reached end of a emacs included tags file)\n */\n    static tags_read_status_T\nfindtags_get_next_line(findtags_state_T *st, tagsearch_info_T *sinfo_p)\n{\n    int\t\teof;\n    off_T\toffset;\n\n    // For binary search: compute the next offset to use.\n    if (st->state == TS_BINARY)\n    {\n\toffset = sinfo_p->low_offset + ((sinfo_p->high_offset\n\t\t\t\t\t\t- sinfo_p->low_offset) / 2);\n\tif (offset == sinfo_p->curr_offset)\n\t    return TAGS_READ_EOF; // End the binary search without a match.\n\telse\n\t    sinfo_p->curr_offset = offset;\n    }\n\n    // Skipping back (after a match during binary search).\n    else if (st->state == TS_SKIP_BACK)\n    {\n\tsinfo_p->curr_offset -= st->lbuf_size * 2;\n\tif (sinfo_p->curr_offset < 0)\n\t{\n\t    sinfo_p->curr_offset = 0;\n\t    rewind(st->fp);\n\t    st->state = TS_STEP_FORWARD;\n\t}\n    }\n\n    // When jumping around in the file, first read a line to find the\n    // start of the next line.\n    if (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n    {\n\t// Adjust the search file offset to the correct position\n\tsinfo_p->curr_offset_used = sinfo_p->curr_offset;\n\tvim_ignored = vim_fseek(st->fp, sinfo_p->curr_offset, SEEK_SET);\n\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\tif (!eof && sinfo_p->curr_offset != 0)\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    if (sinfo_p->curr_offset == sinfo_p->high_offset)\n\t    {\n\t\t// oops, gone a bit too far; try from low offset\n\t\tvim_ignored = vim_fseek(st->fp, sinfo_p->low_offset, SEEK_SET);\n\t\tsinfo_p->curr_offset = sinfo_p->low_offset;\n\t    }\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\t// skip empty and blank lines\n\twhile (!eof && vim_isblankline(st->lbuf))\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\tif (eof)\n\t{\n\t    // Hit end of file.  Skip backwards.\n\t    st->state = TS_SKIP_BACK;\n\t    sinfo_p->match_offset = vim_ftell(st->fp);\n\t    sinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAGS_READ_IGNORE;\n\t}\n    }\n    // Not jumping around in the file: Read the next line.\n    else\n    {\n\t// skip empty and blank lines\n\tdo\n\t{\n#ifdef FEAT_CSCOPE\n\t    if (st->flags & TAG_CSCOPE)\n\t\teof = cs_fgets(st->lbuf, st->lbuf_size);\n\t    else\n#endif\n\t\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t} while (!eof && vim_isblankline(st->lbuf));\n\n\tif (eof)\n\t{\n#ifdef FEAT_EMACS_TAGS\n\t    if (emacs_tags_file_eof(st) == TRUE)\n\t\t// an included tags file. Continue processing the parent\n\t\t// tags file.\n\t\treturn TAGS_READ_IGNORE;\n#endif\n\t    return TAGS_READ_EOF;\n\t}\n    }\n\n    return TAGS_READ_SUCCESS;\n}\n\n/*\n * Parse a tags file header line in 'st->lbuf'.\n * Returns TRUE if the current line in st->lbuf is not a tags header line and\n * should be parsed as a regular tag line. Returns FALSE if the line is a\n * header line and the next header line should be read.\n */\n    static int\nfindtags_hdr_parse(findtags_state_T *st)\n{\n    char_u\t*p;\n\n    // Header lines in a tags file start with \"!_TAG_\"\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) != 0)\n\t// Non-header item before the header, e.g. \"!\" itself.\n\treturn TRUE;\n\n    // Process the header line.\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)\n\tst->tag_file_sorted = st->lbuf[18];\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0)\n    {\n\t// Prepare to convert every line from the specified encoding to\n\t// 'encoding'.\n\tfor (p = st->lbuf + 20; *p > ' ' && *p < 127; ++p)\n\t    ;\n\t*p = NUL;\n\tconvert_setup(&st->vimconv, st->lbuf + 20, p_enc);\n    }\n\n    // Read the next line.  Unrecognized flags are ignored.\n    return FALSE;\n}\n\n/*\n * Handler to initialize the state when starting to process a new tags file.\n * Called in the TS_START state when finding tags from a tags file.\n * Returns TRUE if the line read from the tags file should be parsed and\n * FALSE if the line should be ignored.\n */\n    static int\nfindtags_start_state_handler(\n    findtags_state_T\t*st,\n    int\t\t\t*sortic,\n    tagsearch_info_T\t*sinfo_p)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tnoic = (st->flags & TAG_NOIC);\n    off_T\tfilesize;\n\n    // The header ends when the line sorts below \"!_TAG_\".  When case is\n    // folded lower case letters sort before \"_\".\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) <= 0\n\t    || (st->lbuf[0] == '!' && ASCII_ISLOWER(st->lbuf[1])))\n\treturn findtags_hdr_parse(st);\n\n    // Headers ends.\n\n    // When there is no tag head, or ignoring case, need to do a\n    // linear search.\n    // When no \"!_TAG_\" is found, default to binary search.  If\n    // the tag file isn't sorted, the second loop will find it.\n    // When \"!_TAG_FILE_SORTED\" found: start binary search if\n    // flag set.\n    // For cscope, it's always linear.\n# ifdef FEAT_CSCOPE\n    if (st->linear || use_cscope)\n# else\n    if (st->linear)\n# endif\n\tst->state = TS_LINEAR;\n    else if (st->tag_file_sorted == NUL)\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '1')\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '2')\n    {\n\tst->state = TS_BINARY;\n\t*sortic = TRUE;\n\tst->orgpat->regmatch.rm_ic = (p_ic || !noic);\n    }\n    else\n\tst->state = TS_LINEAR;\n\n    if (st->state == TS_BINARY && st->orgpat->regmatch.rm_ic && !*sortic)\n    {\n\t// Binary search won't work for ignoring case, use linear\n\t// search.\n\tst->linear = TRUE;\n\tst->state = TS_LINEAR;\n    }\n\n    // When starting a binary search, get the size of the file and\n    // compute the first offset.\n    if (st->state == TS_BINARY)\n    {\n\tif (vim_fseek(st->fp, 0L, SEEK_END) != 0)\n\t    // can't seek, don't use binary search\n\t    st->state = TS_LINEAR;\n\telse\n\t{\n\t    // Get the tag file size (don't use mch_fstat(), it's\n\t    // not portable).  Don't use lseek(), it doesn't work\n\t    // properly on MacOS Catalina.\n\t    filesize = vim_ftell(st->fp);\n\t    vim_ignored = vim_fseek(st->fp, 0L, SEEK_SET);\n\n\t    // Calculate the first read offset in the file.  Start\n\t    // the search in the middle of the file.\n\t    sinfo_p->low_offset = 0;\n\t    sinfo_p->low_char = 0;\n\t    sinfo_p->high_offset = filesize;\n\t    sinfo_p->curr_offset = 0;\n\t    sinfo_p->high_char = 0xff;\n\t}\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Parse a tag line read from a tags file.\n * Returns OK if a tags line is successfully parsed.\n * Returns FAIL if a format error is encountered.\n */\n    static int\nfindtags_parse_line(\n    findtags_state_T\t\t*st,\n    tagptrs_T\t\t\t*tagpp,\n    findtags_match_args_T\t*margs,\n    tagsearch_info_T\t\t*sinfo_p)\n{\n    int\t\tstatus;\n    int\t\ti;\n    int\t\tcmplen;\n    int\t\ttagcmp;\n\n    // Figure out where the different strings are in this line.\n    // For \"normal\" tags: Do a quick check if the tag matches.\n    // This speeds up tag searching a lot!\n    if (st->orgpat->headlen\n#ifdef FEAT_EMACS_TAGS\n\t    && !st->is_etag\n#endif\n       )\n    {\n\tCLEAR_FIELD(*tagpp);\n\ttagpp->tagname = st->lbuf;\n\ttagpp->tagname_end = vim_strchr(st->lbuf, TAB);\n\tif (tagpp->tagname_end == NULL)\n\t    // Corrupted tag line.\n\t    return TAG_MATCH_FAIL;\n\n\t// Skip this line if the length of the tag is different and\n\t// there is no regexp, or the tag is too short.\n\tcmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tif (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\t    cmplen = p_tl;\n\tif ((st->flags & TAG_REGEXP) && st->orgpat->headlen < cmplen)\n\t    cmplen = st->orgpat->headlen;\n\telse if (st->state == TS_LINEAR && st->orgpat->headlen != cmplen)\n\t    return TAG_MATCH_NEXT;\n\n\tif (st->state == TS_BINARY)\n\t{\n\t    // Simplistic check for unsorted tags file.\n\t    i = (int)tagpp->tagname[0];\n\t    if (margs->sortic)\n\t\ti = (int)TOUPPER_ASC(tagpp->tagname[0]);\n\t    if (i < sinfo_p->low_char || i > sinfo_p->high_char)\n\t\tmargs->sort_error = TRUE;\n\n\t    // Compare the current tag with the searched tag.\n\t    if (margs->sortic)\n\t\ttagcmp = tag_strnicmp(tagpp->tagname, st->orgpat->head,\n\t\t\t\t\t\t\t(size_t)cmplen);\n\t    else\n\t\ttagcmp = STRNCMP(tagpp->tagname, st->orgpat->head, cmplen);\n\n\t    // A match with a shorter tag means to search forward.\n\t    // A match with a longer tag means to search backward.\n\t    if (tagcmp == 0)\n\t    {\n\t\tif (cmplen < st->orgpat->headlen)\n\t\t    tagcmp = -1;\n\t\telse if (cmplen > st->orgpat->headlen)\n\t\t    tagcmp = 1;\n\t    }\n\n\t    if (tagcmp == 0)\n\t    {\n\t\t// We've located the tag, now skip back and search\n\t\t// forward until the first matching tag is found.\n\t\tst->state = TS_SKIP_BACK;\n\t\tsinfo_p->match_offset = sinfo_p->curr_offset;\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\t    if (tagcmp < 0)\n\t    {\n\t\tsinfo_p->curr_offset = vim_ftell(st->fp);\n\t\tif (sinfo_p->curr_offset < sinfo_p->high_offset)\n\t\t{\n\t\t    sinfo_p->low_offset = sinfo_p->curr_offset;\n\t\t    if (margs->sortic)\n\t\t\tsinfo_p->low_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\t    else\n\t\t\tsinfo_p->low_char = tagpp->tagname[0];\n\t\t    return TAG_MATCH_NEXT;\n\t\t}\n\t    }\n\t    if (tagcmp > 0 && sinfo_p->curr_offset != sinfo_p->high_offset)\n\t    {\n\t\tsinfo_p->high_offset = sinfo_p->curr_offset;\n\t\tif (margs->sortic)\n\t\t    sinfo_p->high_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\telse\n\t\t    sinfo_p->high_char = tagpp->tagname[0];\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\n\t    // No match yet and are at the end of the binary search.\n\t    return TAG_MATCH_STOP;\n\t}\n\telse if (st->state == TS_SKIP_BACK)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\tst->state = TS_STEP_FORWARD;\n\t    else\n\t\t// Have to skip back more.  Restore the curr_offset\n\t\t// used, otherwise we get stuck at a long line.\n\t\tsinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAG_MATCH_NEXT;\n\t}\n\telse if (st->state == TS_STEP_FORWARD)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t    {\n\t\tif ((off_T)vim_ftell(st->fp) > sinfo_p->match_offset)\n\t\t    return TAG_MATCH_STOP;\t// past last match\n\t\telse\n\t\t    return TAG_MATCH_NEXT;\t// before first match\n\t    }\n\t}\n\telse\n\t    // skip this match if it can't match\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\treturn TAG_MATCH_NEXT;\n\n\t// Can be a matching tag, isolate the file name and command.\n\ttagpp->fname = tagpp->tagname_end + 1;\n\ttagpp->fname_end = vim_strchr(tagpp->fname, TAB);\n\tif (tagpp->fname_end == NULL)\n\t    status = FAIL;\n\telse\n\t{\n\t    tagpp->command = tagpp->fname_end + 1;\n\t    status = OK;\n\t}\n    }\n    else\n\tstatus = parse_tag_line(st->lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp);\n\n    if (status == FAIL)\n\treturn TAG_MATCH_FAIL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (st->is_etag)\n\ttagpp->fname = st->ebuf;\n#endif\n\n    return TAG_MATCH_SUCCESS;\n}\n\n/*\n * Initialize the structure used for tag matching.\n */\n    static void\nfindtags_matchargs_init(findtags_match_args_T *margs, int flags)\n{\n    margs->matchoff = 0;\t\t\t// match offset\n    margs->match_re = FALSE;\t\t\t// match with regexp\n    margs->match_no_ic = FALSE;\t\t\t// matches with case\n    margs->has_re = (flags & TAG_REGEXP);\t// regexp used\n    margs->sortic = FALSE;\t\t\t// tag file sorted in nocase\n    margs->sort_error = FALSE;\t\t\t// tags file not sorted\n}\n\n/*\n * Compares the tag name in 'tagpp->tagname' with a search pattern in\n * 'st->orgpat.head'.\n * Returns TAG_MATCH_SUCCESS if the tag matches, TAG_MATCH_FAIL if the tag\n * doesn't match, TAG_MATCH_NEXT to look for the next matching tag (used in a\n * binary search) and TAG_MATCH_STOP if all the tags are processed without a\n * match. Uses the values in 'margs' for doing the comparison.\n */\n    static tagmatch_status_T\nfindtags_match_tag(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T *margs)\n{\n    int\t\tmatch = FALSE;\n    int\t\tcmplen;\n\n    // First try matching with the pattern literally (also when it is\n    // a regexp).\n    cmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n    if (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\tcmplen = p_tl;\n    // if tag length does not match, don't try comparing\n    if (st->orgpat->len != cmplen)\n\tmatch = FALSE;\n    else\n    {\n\tif (st->orgpat->regmatch.rm_ic)\n\t{\n\t    match =\n\t\t(MB_STRNICMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t    if (match)\n\t\tmargs->match_no_ic =\n\t\t    (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t}\n\telse\n\t    match = (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n    }\n\n    // Has a regexp: Also find tags matching regexp.\n    margs->match_re = FALSE;\n    if (!match && st->orgpat->regmatch.regprog != NULL)\n    {\n\tint\tcc;\n\n\tcc = *tagpp->tagname_end;\n\t*tagpp->tagname_end = NUL;\n\tmatch = vim_regexec(&st->orgpat->regmatch, tagpp->tagname, (colnr_T)0);\n\tif (match)\n\t{\n\t    margs->matchoff = (int)(st->orgpat->regmatch.startp[0] -\n\t\t\t\t\t\t\ttagpp->tagname);\n\t    if (st->orgpat->regmatch.rm_ic)\n\t    {\n\t\tst->orgpat->regmatch.rm_ic = FALSE;\n\t\tmargs->match_no_ic = vim_regexec(&st->orgpat->regmatch,\n\t\t\ttagpp->tagname, (colnr_T)0);\n\t\tst->orgpat->regmatch.rm_ic = TRUE;\n\t    }\n\t}\n\t*tagpp->tagname_end = cc;\n\tmargs->match_re = TRUE;\n    }\n\n    return match ? TAG_MATCH_SUCCESS : TAG_MATCH_FAIL;\n}\n\n/*\n * Convert the encoding of a line read from a tags file in 'st->lbuf'.\n * Converting the pattern from 'enc' to the tags file encoding doesn't work,\n * because characters are not recognized. The converted line is saved in\n * st->lbuf.\n */\n    static void\nfindtags_string_convert(findtags_state_T *st)\n{\n    char_u\t*conv_line;\n    int\t\tlen;\n\n    conv_line = string_convert(&st->vimconv, st->lbuf, NULL);\n    if (conv_line == NULL)\n\treturn;\n\n    // Copy or swap lbuf and conv_line.\n    len = (int)STRLEN(conv_line) + 1;\n    if (len > st->lbuf_size)\n    {\n\tvim_free(st->lbuf);\n\tst->lbuf = conv_line;\n\tst->lbuf_size = len;\n    }\n    else\n    {\n\tSTRCPY(st->lbuf, conv_line);\n\tvim_free(conv_line);\n    }\n}\n\n/*\n * Add a matching tag found in a tags file to st->ht_match and st->ga_match.\n * Returns OK if successfully added the match and FAIL on memory allocation\n * failure.\n */\n    static int\nfindtags_add_match(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T   *margs,\n    char_u\t\t*buf_ffname,\n    hash_T\t\t*hash)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    int\t\tmtt;\n    int\t\tlen = 0;\n    int\t\tis_current;\t\t// file name matches\n    int\t\tis_static;\t\t// current tag line is static\n    char_u\t*mfp;\n    char_u\t*p;\n    char_u\t*s;\n\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n    {\n\t// Don't change the ordering, always use the same table.\n\tmtt = MT_GL_OTH;\n    }\n    else\n#endif\n    {\n\t// Decide in which array to store this match.\n\tis_current = test_for_current(\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp->fname, tagpp->fname_end, st->tag_fname, buf_ffname);\n#ifdef FEAT_EMACS_TAGS\n\tis_static = FALSE;\n\tif (!st->is_etag)\t// emacs tags are never static\n#endif\n\t    is_static = test_for_static(tagpp);\n\n\t// decide in which of the sixteen tables to store this\n\t// match\n\tif (is_static)\n\t{\n\t    if (is_current)\n\t\tmtt = MT_ST_CUR;\n\t    else\n\t\tmtt = MT_ST_OTH;\n\t}\n\telse\n\t{\n\t    if (is_current)\n\t\tmtt = MT_GL_CUR;\n\t    else\n\t\tmtt = MT_GL_OTH;\n\t}\n\tif (st->orgpat->regmatch.rm_ic && !margs->match_no_ic)\n\t    mtt += MT_IC_OFF;\n\tif (margs->match_re)\n\t    mtt += MT_RE_OFF;\n    }\n\n    // Add the found match in ht_match[mtt] and ga_match[mtt].\n    // Store the info we need later, which depends on the kind of\n    // tags we are dealing with.\n    if (st->help_only)\n    {\n#ifdef FEAT_MULTI_LANG\n# define ML_EXTRA 3\n#else\n# define ML_EXTRA 0\n#endif\n\t// Append the help-heuristic number after the tagname, for\n\t// sorting it later.  The heuristic is ignored for\n\t// detecting duplicates.\n\t// The format is {tagname}@{lang}NUL{heuristic}NUL\n\t*tagpp->tagname_end = NUL;\n\tlen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tmfp = alloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);\n\tif (mfp != NULL)\n\t{\n\t    int heuristic;\n\n\t    p = mfp;\n\t    STRCPY(p, tagpp->tagname);\n#ifdef FEAT_MULTI_LANG\n\t    p[len] = '@';\n\t    STRCPY(p + len + 1, st->help_lang);\n#endif\n\n\t    heuristic = help_heuristic(tagpp->tagname,\n\t\t\t\tmargs->match_re ? margs->matchoff : 0,\n\t\t\t\t!margs->match_no_ic);\n#ifdef FEAT_MULTI_LANG\n\t    heuristic += st->help_pri;\n#endif\n\t    sprintf((char *)p + len + 1 + ML_EXTRA, \"%06d\",\n\t\t    heuristic);\n\t}\n\t*tagpp->tagname_end = TAB;\n    }\n    else if (name_only)\n    {\n\tif (st->get_searchpat)\n\t{\n\t    char_u *temp_end = tagpp->command;\n\n\t    if (*temp_end == '/')\n\t\twhile (*temp_end && *temp_end != '\\r'\n\t\t\t&& *temp_end != '\\n'\n\t\t\t&& *temp_end != '$')\n\t\t    temp_end++;\n\n\t    if (tagpp->command + 2 < temp_end)\n\t    {\n\t\tlen = (int)(temp_end - tagpp->command - 2);\n\t\tmfp = alloc(len + 2);\n\t\tif (mfp != NULL)\n\t\t    vim_strncpy(mfp, tagpp->command + 2, len);\n\t    }\n\t    else\n\t\tmfp = NULL;\n\t    st->get_searchpat = FALSE;\n\t}\n\telse\n\t{\n\t    len = (int)(tagpp->tagname_end - tagpp->tagname);\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\t    if (mfp != NULL)\n\t\tvim_strncpy(mfp, tagpp->tagname, len);\n\n\t    // if wanted, re-read line to get long form too\n\t    if (State & MODE_INSERT)\n\t\tst->get_searchpat = p_sft;\n\t}\n    }\n    else\n    {\n\tsize_t tag_fname_len = STRLEN(st->tag_fname);\n#ifdef FEAT_EMACS_TAGS\n\tsize_t ebuf_len = 0;\n#endif\n\n\t// Save the tag in a buffer.\n\t// Use 0x02 to separate fields (Can't use NUL because the\n\t// hash key is terminated by NUL, or Ctrl_A because that is\n\t// part of some Emacs tag files -- see parse_tag_line).\n\t// Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>\n\t// other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>\n\t// without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>\n\t// Here <mtt> is the \"mtt\" value plus 1 to avoid NUL.\n\tlen = (int)tag_fname_len + (int)STRLEN(st->lbuf) + 3;\n#ifdef FEAT_EMACS_TAGS\n\tif (st->is_etag)\n\t{\n\t    ebuf_len = STRLEN(st->ebuf);\n\t    len += (int)ebuf_len + 1;\n\t}\n\telse\n\t    ++len;\n#endif\n\tmfp = alloc(sizeof(char_u) + len + 1);\n\tif (mfp != NULL)\n\t{\n\t    p = mfp;\n\t    p[0] = mtt + 1;\n\t    STRCPY(p + 1, st->tag_fname);\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Ignore differences in slashes, avoid adding\n\t    // both path/file and path\\file.\n\t    slash_adjust(p + 1);\n#endif\n\t    p[tag_fname_len + 1] = TAG_SEP;\n\t    s = p + 1 + tag_fname_len + 1;\n#ifdef FEAT_EMACS_TAGS\n\t    if (st->is_etag)\n\t    {\n\t\tSTRCPY(s, st->ebuf);\n\t\ts[ebuf_len] = TAG_SEP;\n\t\ts += ebuf_len + 1;\n\t    }\n\t    else\n\t\t*s++ = TAG_SEP;\n#endif\n\t    STRCPY(s, st->lbuf);\n\t}\n    }\n\n    if (mfp != NULL)\n    {\n\thashitem_T\t*hi;\n\n\t// Don't add identical matches.\n\t// Add all cscope tags, because they are all listed.\n\t// \"mfp\" is used as a hash key, there is a NUL byte to end\n\t// the part that matters for comparing, more bytes may\n\t// follow after it.  E.g. help tags store the priority\n\t// after the NUL.\n#ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    ++*hash;\n\telse\n#endif\n\t    *hash = hash_hash(mfp);\n\thi = hash_lookup(&st->ht_match[mtt], mfp, *hash);\n\tif (HASHITEM_EMPTY(hi))\n\t{\n\t    if (hash_add_item(&st->ht_match[mtt], hi, mfp, *hash) == FAIL\n\t\t    || ga_grow(&st->ga_match[mtt], 1) != OK)\n\t    {\n\t\t// Out of memory! Just forget about the rest.\n\t\tst->stop_searching = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    ((char_u **)(st->ga_match[mtt].ga_data))\n\t\t[st->ga_match[mtt].ga_len++] = mfp;\n\t    st->match_count++;\n\t}\n\telse\n\t    // duplicate tag, drop it\n\t    vim_free(mfp);\n    }\n\n    return OK;\n}\n\n/*\n * Read and get all the tags from file st->tag_fname.\n * Sets 'st->stop_searching' to TRUE to stop searching for additional tags.\n */\n    static void\nfindtags_get_all_tags(\n    findtags_state_T\t\t*st,\n    findtags_match_args_T\t*margs,\n    char_u\t\t\t*buf_ffname)\n{\n    tagptrs_T\t\ttagp;\n    tagsearch_info_T\tsearch_info;\n    int\t\t\tretval;\n#ifdef FEAT_CSCOPE\n    int\t\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    hash_T\t\thash = 0;\n\n    // This is only to avoid a compiler warning for using search_info\n    // uninitialised.\n    CLEAR_FIELD(search_info);\n\n    // Read and parse the lines in the file one by one\n    for (;;)\n    {\n\t// check for CTRL-C typed, more often when jumping around\n\tif (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n\t    line_breakcheck();\n\telse\n\t    fast_breakcheck();\n\tif ((st->flags & TAG_INS_COMP))\t// Double brackets for gcc\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\t// When mincount is TAG_MANY, stop when enough matches have been\n\t// found (for completion).\n\tif (st->mincount == TAG_MANY && st->match_count >= TAG_MANY)\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\tif (st->get_searchpat)\n\t    goto line_read_in;\n\n\tretval = findtags_get_next_line(st, &search_info);\n\tif (retval == TAGS_READ_IGNORE)\n\t    continue;\n\tif (retval == TAGS_READ_EOF)\n\t    break;\n\nline_read_in:\n\n\tif (st->vimconv.vc_type != CONV_NONE)\n\t    findtags_string_convert(st);\n\n#ifdef FEAT_EMACS_TAGS\n\t// Emacs tags line with CTRL-L: New file name on next line.\n\t// The file name is followed by a ','.\n\t// Remember etag file name in ebuf.\n\tif (*st->lbuf == Ctrl_L\n# ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n# endif\n\t   )\n\t{\n\t    st->is_etag = TRUE;\t\t// in case at the start\n\t    st->state = TS_LINEAR;\n\t    emacs_tags_new_filename(st);\n\t    continue;\n\t}\n#endif\n\n\t// When still at the start of the file, check for Emacs tags file\n\t// format, and for \"not sorted\" flag.\n\tif (st->state == TS_START)\n\t{\n\t    if (findtags_start_state_handler(st, &margs->sortic, &search_info) == FALSE)\n\t\tcontinue;\n\t}\n\n\t// When the line is too long the NUL will not be in the\n\t// last-but-one byte (see vim_fgets()).\n\t// Has been reported for Mozilla JS with extremely long names.\n\t// In that case we need to increase lbuf_size.\n\tif (st->lbuf[st->lbuf_size - 2] != NUL\n#ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n#endif\n\t   )\n\t{\n\t    st->lbuf_size *= 2;\n\t    vim_free(st->lbuf);\n\t    st->lbuf = alloc(st->lbuf_size);\n\t    if (st->lbuf == NULL)\n\t    {\n\t\tif (st->fp != NULL)\n\t\t    fclose(st->fp);\n\t\tst->fp = NULL;\n\t\tst->stop_searching = TRUE;\n\t\treturn;\n\t    }\n\n\t    if (st->state == TS_STEP_FORWARD || st->state == TS_LINEAR)\n\t\t// Seek to the same position to read the same line again\n\t\tvim_ignored = vim_fseek(st->fp, search_info.curr_offset,\n\t\t\t\t\t\t\t\t     SEEK_SET);\n\t    // this will try the same thing again, make sure the offset is\n\t    // different\n\t    search_info.curr_offset = 0;\n\t    continue;\n\t}\n\n\tretval = findtags_parse_line(st, &tagp, margs, &search_info);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\tif (retval == TAG_MATCH_FAIL)\n\t{\n\t    semsg(_(e_format_error_in_tags_file_str), st->tag_fname);\n#ifdef FEAT_CSCOPE\n\t    if (!use_cscope)\n#endif\n\t\tsemsg(_(\"Before byte %ld\"), (long)vim_ftell(st->fp));\n\t    st->stop_searching = TRUE;\n\t    return;\n\t}\n\n\tretval = findtags_match_tag(st, &tagp, margs);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\n\t// If a match is found, add it to ht_match[] and ga_match[].\n\tif (retval == TAG_MATCH_SUCCESS)\n\t{\n\t    if (findtags_add_match(st, &tagp, margs, buf_ffname, &hash)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\tbreak;\n\t}\n    } // forever\n}\n\n/*\n * Search for tags matching 'st->orgpat.pat' in the 'st->tag_fname' tags file.\n * Information needed to search for the tags is in the 'st' state structure.\n * The matching tags are returned in 'st'. If an error is encountered, then\n * 'st->stop_searching' is set to TRUE.\n */\n    static void\nfindtags_in_file(findtags_state_T *st, char_u *buf_ffname)\n{\n    findtags_match_args_T margs;\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n\n    st->vimconv.vc_type = CONV_NONE;\n    st->tag_file_sorted = NUL;\n    st->fp = NULL;\n    findtags_matchargs_init(&margs, st->flags);\n\n    // A file that doesn't exist is silently ignored.  Only when not a\n    // single file is found, an error message is given (further on).\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n\tst->fp = NULL;\t    // avoid GCC warning\n    else\n#endif\n    {\n#ifdef FEAT_MULTI_LANG\n\tif (curbuf->b_help)\n\t{\n\t    if (!findtags_in_help_init(st))\n\t\treturn;\n\t}\n#endif\n\n\tst->fp = mch_fopen((char *)st->tag_fname, \"r\");\n\tif (st->fp == NULL)\n\t    return;\n\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Searching tags file %s\"), st->tag_fname);\n\t    verbose_leave();\n\t}\n    }\n    st->did_open = TRUE;\t// remember that we found at least one file\n\n    st->state = TS_START;\t// we're at the start of the file\n#ifdef FEAT_EMACS_TAGS\n    st->is_etag = FALSE;\t// default is: not emacs style\n#endif\n\n    // Read and parse the lines in the file one by one\n    findtags_get_all_tags(st, &margs, buf_ffname);\n\n    if (st->fp != NULL)\n    {\n\tfclose(st->fp);\n\tst->fp = NULL;\n    }\n#ifdef FEAT_EMACS_TAGS\n    emacs_tags_incstack_free();\n#endif\n    if (st->vimconv.vc_type != CONV_NONE)\n\tconvert_setup(&st->vimconv, NULL, NULL);\n\n    if (margs.sort_error)\n\tsemsg(_(e_tags_file_not_sorted_str), st->tag_fname);\n\n    // Stop searching if sufficient tags have been found.\n    if (st->match_count >= st->mincount)\n\tst->stop_searching = TRUE;\n}\n\n/*\n * Copy the tags found by find_tags() to 'matchesp'.\n * Returns the number of matches copied.\n */\n    static int\nfindtags_copy_matches(findtags_state_T *st, char_u ***matchesp)\n{\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    char_u\t**matches;\n    int\t\tmtt;\n    int\t\ti;\n    char_u\t*mfp;\n    char_u\t*p;\n\n    if (st->match_count > 0)\n\tmatches = ALLOC_MULT(char_u *, st->match_count);\n    else\n\tmatches = NULL;\n    st->match_count = 0;\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tfor (i = 0; i < st->ga_match[mtt].ga_len; ++i)\n\t{\n\t    mfp = ((char_u **)(st->ga_match[mtt].ga_data))[i];\n\t    if (matches == NULL)\n\t\tvim_free(mfp);\n\t    else\n\t    {\n\t\tif (!name_only)\n\t\t{\n\t\t    // Change mtt back to zero-based.\n\t\t    *mfp = *mfp - 1;\n\n\t\t    // change the TAG_SEP back to NUL\n\t\t    for (p = mfp + 1; *p != NUL; ++p)\n\t\t\tif (*p == TAG_SEP)\n\t\t\t    *p = NUL;\n\t\t}\n\t\tmatches[st->match_count++] = mfp;\n\t    }\n\t}\n\n\tga_clear(&st->ga_match[mtt]);\n\thash_clear(&st->ht_match[mtt]);\n    }\n\n    *matchesp = matches;\n    return st->match_count;\n}\n\n/*\n * find_tags() - search for tags in tags files\n *\n * Return FAIL if search completely failed (*num_matches will be 0, *matchesp\n * will be NULL), OK otherwise.\n *\n * Priority depending on which type of tag is recognized:\n *  6.\tA static or global tag with a full matching tag for the current file.\n *  5.\tA global tag with a full matching tag for another file.\n *  4.\tA static tag with a full matching tag for another file.\n *  3.\tA static or global tag with an ignore-case matching tag for the\n *\tcurrent file.\n *  2.\tA global tag with an ignore-case matching tag for another file.\n *  1.\tA static tag with an ignore-case matching tag for another file.\n *\n * Tags in an emacs-style tags file are always global.\n *\n * flags:\n * TAG_HELP\t  only search for help tags\n * TAG_NAMES\t  only return name of tag\n * TAG_REGEXP\t  use \"pat\" as a regexp\n * TAG_NOIC\t  don't always ignore case\n * TAG_KEEP_LANG  keep language\n * TAG_CSCOPE\t  use cscope results for tags\n * TAG_NO_TAGFUNC do not call the 'tagfunc' function\n */\n    int\nfind_tags(\n    char_u\t*pat,\t\t\t// pattern to search for\n    int\t\t*num_matches,\t\t// return: number of matches found\n    char_u\t***matchesp,\t\t// return: array of matches found\n    int\t\tflags,\n    int\t\tmincount,\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    char_u\t*buf_ffname)\t\t// name of buffer for priority\n{\n    findtags_state_T\tst;\n    tagname_T\ttn;\t\t\t// info for get_tagfname()\n    int\t\tfirst_file;\t\t// trying first tag file\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\tround;\n\n    int\t\tsave_emsg_off;\n\n    int\t\thelp_save;\n#ifdef FEAT_MULTI_LANG\n    int\t\ti;\n    char_u\t*saved_pat = NULL;\t\t// copy of pat[]\n#endif\n\n    int\t\tfindall = (mincount == MAXCOL || mincount == TAG_MANY);\n\t\t\t\t\t\t// find all matching tags\n    int\t\thas_re = (flags & TAG_REGEXP);\t// regexp used\n    int\t\tnoic = (flags & TAG_NOIC);\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (flags & TAG_CSCOPE);\n#endif\n    int\t\tverbose = (flags & TAG_VERBOSE);\n    int\t\tsave_p_ic = p_ic;\n\n    /*\n     * Change the value of 'ignorecase' according to 'tagcase' for the\n     * duration of this function.\n     */\n    switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)\n    {\n\tcase TC_FOLLOWIC:\t\t break;\n\tcase TC_IGNORE:    p_ic = TRUE;  break;\n\tcase TC_MATCH:     p_ic = FALSE; break;\n\tcase TC_FOLLOWSCS: p_ic = ignorecase(pat); break;\n\tcase TC_SMART:     p_ic = ignorecase_opt(pat, TRUE, TRUE); break;\n    }\n\n    help_save = curbuf->b_help;\n\n    if (findtags_state_init(&st, pat, flags, mincount) == FAIL)\n\tgoto findtag_end;\n\n#ifdef FEAT_CSCOPE\n    STRCPY(st.tag_fname, \"from cscope\");\t// for error messages\n#endif\n\n    /*\n     * Initialize a few variables\n     */\n    if (st.help_only)\t\t\t\t// want tags from help file\n\tcurbuf->b_help = TRUE;\t\t\t// will be restored later\n#ifdef FEAT_CSCOPE\n    else if (use_cscope)\n    {\n\t// Make sure we don't mix help and cscope, confuses Coverity.\n\tst.help_only = FALSE;\n\tcurbuf->b_help = FALSE;\n    }\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    if (curbuf->b_help)\n    {\n\t// When \"@ab\" is specified use only the \"ab\" language, otherwise\n\t// search all languages.\n\tif (st.orgpat->len > 3 && pat[st.orgpat->len - 3] == '@'\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 2])\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 1]))\n\t{\n\t    saved_pat = vim_strnsave(pat, st.orgpat->len - 3);\n\t    if (saved_pat != NULL)\n\t    {\n\t\tst.help_lang_find = &pat[st.orgpat->len - 2];\n\t\tst.orgpat->pat = saved_pat;\n\t\tst.orgpat->len -= 3;\n\t    }\n\t}\n    }\n#endif\n    if (p_tl != 0 && st.orgpat->len > p_tl)\t// adjust for 'taglength'\n\tst.orgpat->len = p_tl;\n\n    save_emsg_off = emsg_off;\n    emsg_off = TRUE;  // don't want error for invalid RE here\n    prepare_pats(st.orgpat, has_re);\n    emsg_off = save_emsg_off;\n    if (has_re && st.orgpat->regmatch.regprog == NULL)\n\tgoto findtag_end;\n\n#ifdef FEAT_EVAL\n    retval = findtags_apply_tfu(&st, pat, buf_ffname);\n    if (retval != NOTDONE)\n\tgoto findtag_end;\n\n    // re-initialize the default return value\n    retval = FAIL;\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // Set a flag if the file extension is .txt\n    if ((flags & TAG_KEEP_LANG)\n\t    && st.help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && STRICMP(curbuf->b_fname + i - 4, \".txt\") == 0)\n\tst.is_txt = TRUE;\n#endif\n\n    /*\n     * When finding a specified number of matches, first try with matching\n     * case, so binary search can be used, and try ignore-case matches in a\n     * second loop.\n     * When finding all matches, 'tagbsearch' is off, or there is no fixed\n     * string to look for, ignore case right away to avoid going though the\n     * tags files twice.\n     * When the tag file is case-fold sorted, it is either one or the other.\n     * Only ignore case when TAG_NOIC not used or 'ignorecase' set.\n     */\n    st.orgpat->regmatch.rm_ic = ((p_ic || !noic)\n\t\t\t&& (findall || st.orgpat->headlen == 0 || !p_tbs));\n    for (round = 1; round <= 2; ++round)\n    {\n\tst.linear = (st.orgpat->headlen == 0 || !p_tbs || round == 2);\n\n      /*\n       * Try tag file names from tags option one by one.\n       */\n      for (first_file = TRUE;\n#ifdef FEAT_CSCOPE\n\t    use_cscope ||\n#endif\n\t\tget_tagfname(&tn, first_file, st.tag_fname) == OK;\n\t\t\t\t\t\t\t   first_file = FALSE)\n      {\n\t  findtags_in_file(&st, buf_ffname);\n\t  if (st.stop_searching\n#ifdef FEAT_CSCOPE\n\t\t  || use_cscope\n#endif\n\t     )\n\t  {\n\t      retval = OK;\n\t      break;\n\t  }\n      } // end of for-each-file loop\n\n#ifdef FEAT_CSCOPE\n\tif (!use_cscope)\n#endif\n\t    tagname_free(&tn);\n\n\t// stop searching when already did a linear search, or when TAG_NOIC\n\t// used, and 'ignorecase' not set or already did case-ignore search\n\tif (st.stop_searching || st.linear || (!p_ic && noic) ||\n\t\t\t\t\t\tst.orgpat->regmatch.rm_ic)\n\t    break;\n# ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    break;\n# endif\n\n\t// try another time while ignoring case\n\tst.orgpat->regmatch.rm_ic = TRUE;\n    }\n\n    if (!st.stop_searching)\n    {\n\tif (!st.did_open && verbose)\t// never opened any tags file\n\t    emsg(_(e_no_tags_file));\n\tretval = OK;\t\t// It's OK even when no tag found\n    }\n\nfindtag_end:\n    findtags_state_free(&st);\n\n    /*\n     * Move the matches from the ga_match[] arrays into one list of\n     * matches.  When retval == FAIL, free the matches.\n     */\n    if (retval == FAIL)\n\tst.match_count = 0;\n\n    *num_matches = findtags_copy_matches(&st, matchesp);\n\n    curbuf->b_help = help_save;\n#ifdef FEAT_MULTI_LANG\n    vim_free(saved_pat);\n#endif\n\n    p_ic = save_p_ic;\n\n    return retval;\n}\n\nstatic garray_T tag_fnames = GA_EMPTY;\n\n/*\n * Callback function for finding all \"tags\" and \"tags-??\" files in\n * 'runtimepath' doc directories.\n */\n    static void\nfound_tagfile_cb(char_u *fname, void *cookie UNUSED)\n{\n    if (ga_grow(&tag_fnames, 1) == OK)\n    {\n\tchar_u\t*tag_fname = vim_strsave(fname);\n\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(tag_fname);\n#endif\n\tsimplify_filename(tag_fname);\n\t((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] = tag_fname;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tag_stuff(void)\n{\n    ga_clear_strings(&tag_fnames);\n    if (curwin != NULL)\n\tdo_tag(NULL, DT_FREE, 0, 0, 0);\n    tag_freematch();\n\n# if defined(FEAT_QUICKFIX)\n    tagstack_clear_entry(&ptag_entry);\n# endif\n}\n#endif\n\n/*\n * Get the next name of a tag file from the tag file list.\n * For help files, use \"tags\" file only.\n *\n * Return FAIL if no more tag file names, OK otherwise.\n */\n    int\nget_tagfname(\n    tagname_T\t*tnp,\t// holds status info\n    int\t\tfirst,\t// TRUE when first file name is wanted\n    char_u\t*buf)\t// pointer to buffer of MAXPATHL chars\n{\n    char_u\t\t*fname = NULL;\n    char_u\t\t*r_ptr;\n    int\t\t\ti;\n\n    if (first)\n\tCLEAR_POINTER(tnp);\n\n    if (curbuf->b_help)\n    {\n\t/*\n\t * For help files it's done in a completely different way:\n\t * Find \"doc/tags\" and \"doc/tags-??\" in all directories in\n\t * 'runtimepath'.\n\t */\n\tif (first)\n\t{\n\t    ga_clear_strings(&tag_fnames);\n\t    ga_init2(&tag_fnames, sizeof(char_u *), 10);\n\t    do_in_runtimepath((char_u *)\n#ifdef FEAT_MULTI_LANG\n# ifdef VMS\n\t\t    // Functions decc$to_vms() and decc$translate_vms() crash\n\t\t    // on some VMS systems with wildcards \"??\".  Seems ECO\n\t\t    // patches do fix the problem in C RTL, but we can't use\n\t\t    // an #ifdef for that.\n\t\t    \"doc/tags doc/tags-*\"\n# else\n\t\t    \"doc/tags doc/tags-??\"\n# endif\n#else\n\t\t    \"doc/tags\"\n#endif\n\t\t\t\t\t   , DIP_ALL, found_tagfile_cb, NULL);\n\t}\n\n\tif (tnp->tn_hf_idx >= tag_fnames.ga_len)\n\t{\n\t    // Not found in 'runtimepath', use 'helpfile', if it exists and\n\t    // wasn't used yet, replacing \"help.txt\" with \"tags\".\n\t    if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)\n\t\treturn FAIL;\n\t    ++tnp->tn_hf_idx;\n\t    STRCPY(buf, p_hf);\n\t    STRCPY(gettail(buf), \"tags\");\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(buf);\n#endif\n\t    simplify_filename(buf);\n\n\t    for (i = 0; i < tag_fnames.ga_len; ++i)\n\t\tif (STRCMP(buf, ((char_u **)(tag_fnames.ga_data))[i]) == 0)\n\t\t    return FAIL; // avoid duplicate file names\n\t}\n\telse\n\t    vim_strncpy(buf, ((char_u **)(tag_fnames.ga_data))[\n\t\t\t\t\t     tnp->tn_hf_idx++], MAXPATHL - 1);\n\treturn OK;\n    }\n\n    if (first)\n    {\n\t// Init.  We make a copy of 'tags', because autocommands may change\n\t// the value without notifying us.\n\ttnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)\n\t\t\t\t\t\t ? curbuf->b_p_tags : p_tags);\n\tif (tnp->tn_tags == NULL)\n\t    return FAIL;\n\ttnp->tn_np = tnp->tn_tags;\n    }\n\n    /*\n     * Loop until we have found a file name that can be used.\n     * There are two states:\n     * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.\n     * tnp->tn_did_filefind_init == TRUE: find next file in this part.\n     */\n    for (;;)\n    {\n\tif (tnp->tn_did_filefind_init)\n\t{\n\t    fname = vim_findfile(tnp->tn_search_ctx);\n\t    if (fname != NULL)\n\t\tbreak;\n\n\t    tnp->tn_did_filefind_init = FALSE;\n\t}\n\telse\n\t{\n\t    char_u  *filename = NULL;\n\n\t    // Stop when used all parts of 'tags'.\n\t    if (*tnp->tn_np == NUL)\n\t    {\n\t\tvim_findfile_cleanup(tnp->tn_search_ctx);\n\t\ttnp->tn_search_ctx = NULL;\n\t\treturn FAIL;\n\t    }\n\n\t    /*\n\t     * Copy next file name into buf.\n\t     */\n\t    buf[0] = NUL;\n\t    (void)copy_option_part(&tnp->tn_np, buf, MAXPATHL - 1, \" ,\");\n\n\t    r_ptr = vim_findfile_stopdir(buf);\n\t    // move the filename one char forward and truncate the\n\t    // filepath with a NUL\n\t    filename = gettail(buf);\n\t    STRMOVE(filename + 1, filename);\n\t    *filename++ = NUL;\n\n\t    tnp->tn_search_ctx = vim_findfile_init(buf, filename,\n\t\t    r_ptr, 100,\n\t\t    FALSE,\t   // don't free visited list\n\t\t    FINDFILE_FILE, // we search for a file\n\t\t    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);\n\t    if (tnp->tn_search_ctx != NULL)\n\t\ttnp->tn_did_filefind_init = TRUE;\n\t}\n    }\n\n    STRCPY(buf, fname);\n    vim_free(fname);\n    return OK;\n}\n\n/*\n * Free the contents of a tagname_T that was filled by get_tagfname().\n */\n    void\ntagname_free(tagname_T *tnp)\n{\n    vim_free(tnp->tn_tags);\n    vim_findfile_cleanup(tnp->tn_search_ctx);\n    tnp->tn_search_ctx = NULL;\n    ga_clear_strings(&tag_fnames);\n}\n\n/*\n * Parse one line from the tags file. Find start/end of tag name, start/end of\n * file name and start of search pattern.\n *\n * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.\n *\n * Return FAIL if there is a format error in this line, OK otherwise.\n */\n    static int\nparse_tag_line(\n    char_u\t*lbuf,\t\t// line to be parsed\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag,\n#endif\n    tagptrs_T\t*tagp)\n{\n    char_u\t*p;\n\n#ifdef FEAT_EMACS_TAGS\n    if (is_etag)\n\t// emacs-style tag file\n\treturn emacs_tags_parse_line(lbuf, tagp);\n#endif\n\n    // Isolate the tagname, from lbuf up to the first white\n    tagp->tagname = lbuf;\n    p = vim_strchr(lbuf, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->tagname_end = p;\n\n    // Isolate file name, from first to second white space\n    if (*p != NUL)\n\t++p;\n    tagp->fname = p;\n    p = vim_strchr(p, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->fname_end = p;\n\n    // find start of search command, after second white space\n    if (*p != NUL)\n\t++p;\n    if (*p == NUL)\n\treturn FAIL;\n    tagp->command = p;\n\n    return OK;\n}\n\n/*\n * Check if tagname is a static tag\n *\n * Static tags produced by the older ctags program have the format:\n *\t'file:tag  file  /pattern'.\n * This is only recognized when both occurrence of 'file' are the same, to\n * avoid recognizing \"string::string\" or \":exit\".\n *\n * Static tags produced by the new ctags program have the format:\n *\t'tag  file  /pattern/;\"<Tab>file:'\t    \"\n *\n * Return TRUE if it is a static tag and adjust *tagname to the real tag.\n * Return FALSE if it is not a static tag.\n */\n    static int\ntest_for_static(tagptrs_T *tagp)\n{\n    char_u\t*p;\n\n    /*\n     * Check for new style static tag \":...<Tab>file:[<Tab>...]\"\n     */\n    p = tagp->command;\n    while ((p = vim_strchr(p, '\\t')) != NULL)\n    {\n\t++p;\n\tif (STRNCMP(p, \"file:\", 5) == 0)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Returns the length of a matching tag line.\n */\n    static size_t\nmatching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n\n    // does the same thing as parse_match()\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}\n\n/*\n * Parse a line from a matching tag.  Does not change the line itself.\n *\n * The line that we get looks like this:\n * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>\n * other tag: <mtt><tag_fname><NUL><NUL><lbuf>\n * without Emacs tags: <mtt><tag_fname><NUL><lbuf>\n *\n * Return OK or FAIL.\n */\n    static int\nparse_match(\n    char_u\t*lbuf,\t    // input: matching line\n    tagptrs_T\t*tagp)\t    // output: pointers into the line\n{\n    int\t\tretval;\n    char_u\t*p;\n    char_u\t*pc, *pt;\n\n    tagp->tag_fname = lbuf + 1;\n    lbuf += STRLEN(tagp->tag_fname) + 2;\n#ifdef FEAT_EMACS_TAGS\n    if (*lbuf)\n    {\n\ttagp->is_etag = TRUE;\n\ttagp->fname = lbuf;\n\tlbuf += STRLEN(lbuf);\n\ttagp->fname_end = lbuf++;\n    }\n    else\n    {\n\ttagp->is_etag = FALSE;\n\t++lbuf;\n    }\n#endif\n\n    // Find search pattern and the file name for non-etags.\n    retval = parse_tag_line(lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\t\ttagp->is_etag,\n#endif\n\t\t\ttagp);\n\n    tagp->tagkind = NULL;\n    tagp->user_data = NULL;\n    tagp->tagline = 0;\n    tagp->command_end = NULL;\n\n    if (retval == OK)\n    {\n\t// Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"\n\tp = tagp->command;\n\tif (find_extra(&p) == OK)\n\t{\n\t    if (p > tagp->command && p[-1] == '|')\n\t\ttagp->command_end = p - 1;  // drop trailing bar\n\t    else\n\t\ttagp->command_end = p;\n\t    p += 2;\t// skip \";\\\"\"\n\t    if (*p++ == TAB)\n\t\t// Accept ASCII alphabetic kind characters and any multi-byte\n\t\t// character.\n\t\twhile (ASCII_ISALPHA(*p) || mb_ptr2len(p) > 1)\n\t\t{\n\t\t    if (STRNCMP(p, \"kind:\", 5) == 0)\n\t\t\ttagp->tagkind = p + 5;\n\t\t    else if (STRNCMP(p, \"user_data:\", 10) == 0)\n\t\t\ttagp->user_data = p + 10;\n\t\t    else if (STRNCMP(p, \"line:\", 5) == 0)\n\t\t\ttagp->tagline = atoi((char *)p + 5);\n\t\t    if (tagp->tagkind != NULL && tagp->user_data != NULL)\n\t\t\tbreak;\n\t\t    pc = vim_strchr(p, ':');\n\t\t    pt = vim_strchr(p, '\\t');\n\t\t    if (pc == NULL || (pt != NULL && pc > pt))\n\t\t\ttagp->tagkind = p;\n\t\t    if (pt == NULL)\n\t\t\tbreak;\n\t\t    p = pt;\n\t\t    MB_PTR_ADV(p);\n\t\t}\n\t}\n\tif (tagp->tagkind != NULL)\n\t{\n\t    for (p = tagp->tagkind;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->tagkind_end = p;\n\t}\n\tif (tagp->user_data != NULL)\n\t{\n\t    for (p = tagp->user_data;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->user_data_end = p;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Find out the actual file name of a tag.  Concatenate the tags file name\n * with the matching tag file name.\n * Returns an allocated string or NULL (out of memory).\n */\n    static char_u *\ntag_full_fname(tagptrs_T *tagp)\n{\n    char_u\t*fullname;\n    int\t\tc;\n\n#ifdef FEAT_EMACS_TAGS\n    if (tagp->is_etag)\n\tc = 0;\t    // to shut up GCC\n    else\n#endif\n    {\n\tc = *tagp->fname_end;\n\t*tagp->fname_end = NUL;\n    }\n    fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, FALSE);\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp->is_etag)\n#endif\n\t*tagp->fname_end = c;\n\n    return fullname;\n}\n\n/*\n * Jump to a tag that has been found in one of the tag files\n *\n * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.\n */\n    static int\njumpto_tag(\n    char_u\t*lbuf_arg,\t// line from the tags file for this tag\n    int\t\tforceit,\t// :ta with !\n    int\t\tkeep_help)\t// keep help flag (FALSE for cscope)\n{\n    optmagic_T\tsave_magic_overruled;\n    int\t\tsave_p_ws, save_p_scs, save_p_ic;\n    linenr_T\tsave_lnum;\n    char_u\t*str;\n    char_u\t*pbuf;\t\t\t// search pattern buffer\n    char_u\t*pbuf_end;\n    char_u\t*tofree_fname = NULL;\n    char_u\t*fname;\n    tagptrs_T\ttagp;\n    int\t\tretval = FAIL;\n    int\t\tgetfile_result = GETFILE_UNUSED;\n    int\t\tsearch_options;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tsave_no_hlsearch;\n#endif\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n    char_u\t*full_fname = NULL;\n#ifdef FEAT_FOLDING\n    int\t\told_KeyTyped = KeyTyped;    // getting the file may reset it\n#endif\n    size_t\tlen;\n    char_u\t*lbuf;\n\n    // Make a copy of the line, it can become invalid when an autocommand calls\n    // back here recursively.\n    len = matching_line_len(lbuf_arg) + 1;\n    lbuf = alloc(len);\n    if (lbuf != NULL)\n\tmch_memmove(lbuf, lbuf_arg, len);\n\n    pbuf = alloc(LSIZE);\n\n    // parse the match line into the tagp structure\n    if (pbuf == NULL || lbuf == NULL || parse_match(lbuf, &tagp) == FAIL)\n    {\n\ttagp.fname_end = NULL;\n\tgoto erret;\n    }\n\n    // truncate the file name, so it can be used as a string\n    *tagp.fname_end = NUL;\n    fname = tagp.fname;\n\n    // copy the command to pbuf[], remove trailing CR/NL\n    str = tagp.command;\n    for (pbuf_end = pbuf; *str && *str != '\\n' && *str != '\\r'; )\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (tagp.is_etag && *str == ',')// stop at ',' after line number\n\t    break;\n#endif\n\t*pbuf_end++ = *str++;\n\tif (pbuf_end - pbuf + 1 >= LSIZE)\n\t    break;\n    }\n    *pbuf_end = NUL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp.is_etag)\n#endif\n    {\n\t/*\n\t * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here.\n\t */\n\tstr = pbuf;\n\tif (find_extra(&str) == OK)\n\t{\n\t    pbuf_end = str;\n\t    *pbuf_end = NUL;\n\t}\n    }\n\n    /*\n     * Expand file name, when needed (for environment variables).\n     * If 'tagrelative' option set, may change file name.\n     */\n    fname = expand_tag_fname(fname, tagp.tag_fname, TRUE);\n    if (fname == NULL)\n\tgoto erret;\n    tofree_fname = fname;\t// free() it later\n\n    /*\n     * Check if the file with the tag exists before abandoning the current\n     * file.  Also accept a file name for which there is a matching BufReadCmd\n     * autocommand event (e.g., http://sys/file).\n     */\n    if (mch_getperm(fname) < 0 && !has_autocmd(EVENT_BUFREADCMD, fname, NULL))\n    {\n\tretval = NOTAGFILE;\n\tvim_free(nofile_fname);\n\tnofile_fname = vim_strsave(fname);\n\tif (nofile_fname == NULL)\n\t    nofile_fname = empty_option;\n\tgoto erret;\n    }\n\n    ++RedrawingDisabled;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#if defined(FEAT_QUICKFIX)\n    if (g_do_tagpreview != 0)\n    {\n\tpostponed_split = 0;\t// don't split again below\n\tcurwin_save = curwin;\t// Save current window\n\n\t/*\n\t * If we are reusing a window, we may change dir when\n\t * entering it (autocommands) so turn the tag filename\n\t * into a fullpath\n\t */\n\tif (!curwin->w_p_pvw)\n\t{\n\t    full_fname = FullName_save(fname, FALSE);\n\t    fname = full_fname;\n\n\t    /*\n\t     * Make the preview window the current window.\n\t     * Open a preview window when needed.\n\t     */\n\t    prepare_tagpreview(TRUE, TRUE, FALSE);\n\t}\n    }\n\n    // If it was a CTRL-W CTRL-] command split window now.  For \":tab tag\"\n    // open a new tab page.\n    if (postponed_split && (swb_flags & (SWB_USEOPEN | SWB_USETAB)))\n    {\n\tbuf_T *existing_buf = buflist_findname_exp(fname);\n\n\tif (existing_buf != NULL)\n\t{\n\t    win_T *wp = NULL;\n\n\t    if (swb_flags & SWB_USEOPEN)\n\t\twp = buf_jump_open_win(existing_buf);\n\n\t    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t    // page containing \"existing_buf\" if one exists\n\t    if (wp == NULL && (swb_flags & SWB_USETAB))\n\t\twp = buf_jump_open_tab(existing_buf);\n\t    // We've switched to the buffer, the usual loading of the file must\n\t    // be skipped.\n\t    if (wp != NULL)\n\t\tgetfile_result = GETFILE_SAME_FILE;\n\t}\n    }\n    if (getfile_result == GETFILE_UNUSED\n\t\t\t\t  && (postponed_split || cmdmod.cmod_tab != 0))\n    {\n\tif (win_split(postponed_split > 0 ? postponed_split : 0,\n\t\t\t\t\t\tpostponed_split_flags) == FAIL)\n\t{\n\t    --RedrawingDisabled;\n\t    goto erret;\n\t}\n\tRESET_BINDING(curwin);\n    }\n#endif\n\n    if (keep_help)\n    {\n\t// A :ta from a help file will keep the b_help flag set.  For \":ptag\"\n\t// we need to use the flag from the window where we came from.\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    keep_help_flag = bt_help(curwin_save->w_buffer);\n\telse\n#endif\n\t    keep_help_flag = curbuf->b_help;\n    }\n\n    if (getfile_result == GETFILE_UNUSED)\n\t// Careful: getfile() may trigger autocommands and call jumpto_tag()\n\t// recursively.\n\tgetfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);\n    keep_help_flag = FALSE;\n\n    if (GETFILE_SUCCESS(getfile_result))\t// got to the right file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tpostponed_split = 0;\n\n\tsave_magic_overruled = magic_overruled;\n\tmagic_overruled = OPTION_MAGIC_OFF;\t// always execute with 'nomagic'\n#ifdef FEAT_SEARCH_EXTRA\n\t// Save value of no_hlsearch, jumping to a tag is not a real search\n\tsave_no_hlsearch = no_hlsearch;\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\t// getfile() may have cleared options, apply 'previewpopup' again.\n\tif (g_do_tagpreview != 0 && *p_pvp != NUL)\n\t    parse_previewpopup(curwin);\n#endif\n\n\t/*\n\t * If 'cpoptions' contains 't', store the search pattern for the \"n\"\n\t * command.  If 'cpoptions' does not contain 't', the search pattern\n\t * is not stored.\n\t */\n\tif (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)\n\t    search_options = 0;\n\telse\n\t    search_options = SEARCH_KEEP;\n\n\t/*\n\t * If the command is a search, try here.\n\t *\n\t * Reset 'smartcase' for the search, since the search pattern was not\n\t * typed by the user.\n\t * Only use do_search() when there is a full search command, without\n\t * anything following.\n\t */\n\tstr = pbuf;\n\tif (pbuf[0] == '/' || pbuf[0] == '?')\n\t    str = skip_regexp(pbuf + 1, pbuf[0], FALSE) + 1;\n\tif (str > pbuf_end - 1)\t// search command with nothing following\n\t{\n\t    save_p_ws = p_ws;\n\t    save_p_ic = p_ic;\n\t    save_p_scs = p_scs;\n\t    p_ws = TRUE;\t// need 'wrapscan' for backward searches\n\t    p_ic = FALSE;\t// don't ignore case now\n\t    p_scs = FALSE;\n\t    save_lnum = curwin->w_cursor.lnum;\n\t    if (tagp.tagline > 0)\n\t\t// start search before line from \"line:\" field\n\t\tcurwin->w_cursor.lnum = tagp.tagline - 1;\n\t    else\n\t\t// start search before first line\n\t\tcurwin->w_cursor.lnum = 0;\n\t    if (do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\tretval = OK;\n\t    else\n\t    {\n\t\tint\tfound = 1;\n\t\tint\tcc;\n\n\t\t/*\n\t\t * try again, ignore case now\n\t\t */\n\t\tp_ic = TRUE;\n\t\tif (!do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t{\n\t\t    /*\n\t\t     * Failed to find pattern, take a guess: \"^func  (\"\n\t\t     */\n\t\t    found = 2;\n\t\t    (void)test_for_static(&tagp);\n\t\t    cc = *tagp.tagname_end;\n\t\t    *tagp.tagname_end = NUL;\n\t\t    sprintf((char *)pbuf, \"^%s\\\\s\\\\*(\", tagp.tagname);\n\t\t    if (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t    {\n\t\t\t// Guess again: \"^char * \\<func  (\"\n\t\t\tsprintf((char *)pbuf, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",\n\t\t\t\t\t\t\t\ttagp.tagname);\n\t\t\tif (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t\t    found = 0;\n\t\t    }\n\t\t    *tagp.tagname_end = cc;\n\t\t}\n\t\tif (found == 0)\n\t\t{\n\t\t    emsg(_(e_canot_find_tag_pattern));\n\t\t    curwin->w_cursor.lnum = save_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Only give a message when really guessed, not when 'ic'\n\t\t     * is set and match found while ignoring case.\n\t\t     */\n\t\t    if (found == 2 || !save_p_ic)\n\t\t    {\n\t\t\tmsg(_(e_couldnt_find_tag_just_guessing));\n\t\t\tif (!msg_scrolled && msg_silent == 0)\n\t\t\t{\n\t\t\t    out_flush();\n\t\t\t    ui_delay(1010L, TRUE);\n\t\t\t}\n\t\t    }\n\t\t    retval = OK;\n\t\t}\n\t    }\n\t    p_ws = save_p_ws;\n\t    p_ic = save_p_ic;\n\t    p_scs = save_p_scs;\n\n\t    // A search command may have positioned the cursor beyond the end\n\t    // of the line.  May need to correct that here.\n\t    check_cursor();\n\t}\n\telse\n\t{\n\t    int\t\tsave_secure = secure;\n\n\t    // Setup the sandbox for executing the command from the tags file.\n\t    secure = 1;\n#ifdef HAVE_SANDBOX\n\t    ++sandbox;\n#endif\n\t    curwin->w_cursor.lnum = 1;\t\t// start command in line 1\n\t    do_cmdline_cmd(pbuf);\n\t    retval = OK;\n\n\t    // When the command has done something that is not allowed make\n\t    // sure the error message can be seen.\n\t    if (secure == 2)\n\t\twait_return(TRUE);\n\t    secure = save_secure;\n#ifdef HAVE_SANDBOX\n\t    --sandbox;\n#endif\n\t}\n\n\tmagic_overruled = save_magic_overruled;\n#ifdef FEAT_SEARCH_EXTRA\n\t// restore no_hlsearch when keeping the old search pattern\n\tif (search_options)\n\t    set_no_hlsearch(save_no_hlsearch);\n#endif\n\n\t// Return OK if jumped to another file (at least we found the file!).\n\tif (getfile_result == GETFILE_OPEN_OTHER)\n\t    retval = OK;\n\n\tif (retval == OK)\n\t{\n\t    /*\n\t     * For a help buffer: Put the cursor line at the top of the window,\n\t     * the help subject will be below it.\n\t     */\n\t    if (curbuf->b_help)\n\t\tset_topline(curwin, curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\tfoldOpenCursor();\n#endif\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t{\n\t    // Return cursor to where we were\n\t    validate_cursor();\n\t    redraw_later(UPD_VALID);\n\t    win_enter(curwin_save, TRUE);\n\t}\n#endif\n\n\t--RedrawingDisabled;\n    }\n    else\n    {\n\t--RedrawingDisabled;\n\tgot_int = FALSE;  // don't want entering window to fail\n\n\tif (postponed_split)\t\t// close the window\n\t{\n\t    win_close(curwin, FALSE);\n\t    postponed_split = 0;\n\t}\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n\telse if (WIN_IS_POPUP(curwin))\n\t{\n\t    win_T   *wp = curwin;\n\n\t    if (win_valid(curwin_save))\n\t\twin_enter(curwin_save, TRUE);\n\t    popup_close(wp->w_id, FALSE);\n\t}\n#endif\n    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n    if (WIN_IS_POPUP(curwin))\n\t// something went wrong, still in popup, but it can't have focus\n\twin_enter(firstwin, TRUE);\n#endif\n\nerret:\n#if defined(FEAT_QUICKFIX)\n    g_do_tagpreview = 0; // For next time\n#endif\n    vim_free(lbuf);\n    vim_free(pbuf);\n    vim_free(tofree_fname);\n    vim_free(full_fname);\n\n    return retval;\n}\n\n/*\n * If \"expand\" is TRUE, expand wildcards in fname.\n * If 'tagrelative' option set, change fname (name of file containing tag)\n * according to tag_fname (name of tag file containing fname).\n * Returns a pointer to allocated memory (or NULL when out of memory).\n */\n    static char_u *\nexpand_tag_fname(char_u *fname, char_u *tag_fname, int expand)\n{\n    char_u\t*p;\n    char_u\t*retval;\n    char_u\t*expanded_fname = NULL;\n    expand_T\txpc;\n\n    /*\n     * Expand file name (for environment variables) when needed.\n     */\n    if (expand && mch_has_wildcard(fname))\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\texpanded_fname = ExpandOne(&xpc, fname, NULL,\n\t\t\t    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n\tif (expanded_fname != NULL)\n\t    fname = expanded_fname;\n    }\n\n    if ((p_tr || curbuf->b_help)\n\t    && !vim_isAbsName(fname)\n\t    && (p = gettail(tag_fname)) != tag_fname)\n    {\n\tretval = alloc(MAXPATHL);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, tag_fname);\n\t    vim_strncpy(retval + (p - tag_fname), fname,\n\t\t\t\t\t      MAXPATHL - (p - tag_fname) - 1);\n\t    /*\n\t     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\".\n\t     */\n\t    simplify_filename(retval);\n\t}\n    }\n    else\n\tretval = vim_strsave(fname);\n\n    vim_free(expanded_fname);\n\n    return retval;\n}\n\n/*\n * Check if we have a tag for the buffer with name \"buf_ffname\".\n * This is a bit slow, because of the full path compare in fullpathcmp().\n * Return TRUE if tag for file \"fname\" if tag file \"tag_fname\" is for current\n * file.\n */\n    static int\ntest_for_current(\n#ifdef FEAT_EMACS_TAGS\n    int\t    is_etag,\n#endif\n    char_u  *fname,\n    char_u  *fname_end,\n    char_u  *tag_fname,\n    char_u  *buf_ffname)\n{\n    int\t    c;\n    int\t    retval = FALSE;\n    char_u  *fullname;\n\n    if (buf_ffname != NULL)\t// if the buffer has a name\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (is_etag)\n\t    c = 0;\t    // to shut up GCC\n\telse\n#endif\n\t{\n\t    c = *fname_end;\n\t    *fname_end = NUL;\n\t}\n\tfullname = expand_tag_fname(fname, tag_fname, TRUE);\n\tif (fullname != NULL)\n\t{\n\t    retval = (fullpathcmp(fullname, buf_ffname, TRUE, TRUE) & FPC_SAME);\n\t    vim_free(fullname);\n\t}\n#ifdef FEAT_EMACS_TAGS\n\tif (!is_etag)\n#endif\n\t    *fname_end = c;\n    }\n\n    return retval;\n}\n\n/*\n * Find the end of the tagaddress.\n * Return OK if \";\\\"\" is following, FAIL otherwise.\n */\n    static int\nfind_extra(char_u **pp)\n{\n    char_u\t*str = *pp;\n    char_u\tfirst_char = **pp;\n\n    // Repeat for addresses separated with ';'\n    for (;;)\n    {\n\tif (VIM_ISDIGIT(*str))\n\t    str = skipdigits(str + 1);\n\telse if (*str == '/' || *str == '?')\n\t{\n\t    str = skip_regexp(str + 1, *str, FALSE);\n\t    if (*str != first_char)\n\t\tstr = NULL;\n\t    else\n\t\t++str;\n\t}\n\telse\n\t{\n\t    // not a line number or search string, look for terminator.\n\t    str = (char_u *)strstr((char *)str, \"|;\\\"\");\n\t    if (str != NULL)\n\t    {\n\t\t++str;\n\t\tbreak;\n\t    }\n\n\t}\n\tif (str == NULL || *str != ';'\n\t\t  || !(VIM_ISDIGIT(str[1]) || str[1] == '/' || str[1] == '?'))\n\t    break;\n\t++str;\t// skip ';'\n\tfirst_char = *str;\n    }\n\n    if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0)\n    {\n\t*pp = str;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free a single entry in a tag stack\n */\n    static void\ntagstack_clear_entry(taggy_T *item)\n{\n    VIM_CLEAR(item->tagname);\n    VIM_CLEAR(item->user_data);\n}\n\n    int\nexpand_tags(\n    int\t\ttagnames,\t// expand tag names\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\ti;\n    int\t\textra_flag;\n    char_u\t*name_buf;\n    size_t\tname_buf_size = 100;\n    tagptrs_T\tt_p;\n    int\t\tret;\n\n    name_buf = alloc(name_buf_size);\n    if (name_buf == NULL)\n\treturn FAIL;\n\n    if (tagnames)\n\textra_flag = TAG_NAMES;\n    else\n\textra_flag = 0;\n    if (pat[0] == '/')\n\tret = find_tags(pat + 1, num_file, file,\n\t\tTAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    else\n\tret = find_tags(pat, num_file, file,\n\t      TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC | TAG_NOIC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    if (ret == OK && !tagnames)\n    {\n\t // Reorganize the tags for display and matching as strings of:\n\t // \"<tagname>\\0<kind>\\0<filename>\\0\"\n\t for (i = 0; i < *num_file; i++)\n\t {\n\t     size_t\tlen;\n\n\t     parse_match((*file)[i], &t_p);\n\t     len = t_p.tagname_end - t_p.tagname;\n\t     if (len > name_buf_size - 3)\n\t     {\n\t\t char_u *buf;\n\n\t\t name_buf_size = len + 3;\n\t\t buf = vim_realloc(name_buf, name_buf_size);\n\t\t if (buf == NULL)\n\t\t {\n\t\t     vim_free(name_buf);\n\t\t     return FAIL;\n\t\t }\n\t\t name_buf = buf;\n\t     }\n\n\t     mch_memmove(name_buf, t_p.tagname, len);\n\t     name_buf[len++] = 0;\n\t     name_buf[len++] = (t_p.tagkind != NULL && *t_p.tagkind)\n\t\t\t\t\t\t\t  ? *t_p.tagkind : 'f';\n\t     name_buf[len++] = 0;\n\t     mch_memmove((*file)[i] + len, t_p.fname,\n\t\t\t\t\t\t    t_p.fname_end - t_p.fname);\n\t     (*file)[i][len + (t_p.fname_end - t_p.fname)] = 0;\n\t     mch_memmove((*file)[i], name_buf, len);\n\t}\n    }\n\n    vim_free(name_buf);\n    return ret;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a tag field to the dictionary \"dict\".\n * Return OK or FAIL.\n */\n    static int\nadd_tag_field(\n    dict_T  *dict,\n    char    *field_name,\n    char_u  *start,\t\t// start of the value\n    char_u  *end)\t\t// after the value; can be NULL\n{\n    char_u\t*buf;\n    int\t\tlen = 0;\n    int\t\tretval;\n\n    // check that the field name doesn't exist yet\n    if (dict_has_key(dict, field_name))\n    {\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Duplicate field name: %s\"), field_name);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn FAIL;\n    if (start != NULL)\n    {\n\tif (end == NULL)\n\t{\n\t    end = start + STRLEN(start);\n\t    while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))\n\t\t--end;\n\t}\n\tlen = (int)(end - start);\n\tif (len > MAXPATHL - 1)\n\t    len = MAXPATHL - 1;\n\tvim_strncpy(buf, start, len);\n    }\n    buf[len] = NUL;\n    retval = dict_add_string(dict, field_name, buf);\n    vim_free(buf);\n    return retval;\n}\n\n/*\n * Add the tags matching the specified pattern \"pat\" to the list \"list\"\n * as a dictionary. Use \"buf_fname\" for priority, unless NULL.\n */\n    int\nget_tags(list_T *list, char_u *pat, char_u *buf_fname)\n{\n    int\t\tnum_matches, i, ret;\n    char_u\t**matches, *p;\n    char_u\t*full_fname;\n    dict_T\t*dict;\n    tagptrs_T\ttp;\n    long\tis_static;\n\n    ret = find_tags(pat, &num_matches, &matches,\n\t\t\t\tTAG_REGEXP | TAG_NOIC, (int)MAXCOL, buf_fname);\n    if (ret == OK && num_matches > 0)\n    {\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    if (parse_match(matches[i], &tp) == FAIL)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    is_static = test_for_static(&tp);\n\n\t    // Skip pseudo-tag lines.\n\t    if (STRNCMP(tp.tagname, \"!_TAG_\", 6) == 0)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    if ((dict = dict_alloc()) == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tvim_free(matches[i]);\n\t\tbreak;\n\t    }\n\t    if (list_append_dict(list, dict) == FAIL)\n\t\tret = FAIL;\n\n\t    full_fname = tag_full_fname(&tp);\n\t    if (add_tag_field(dict, \"name\", tp.tagname, tp.tagname_end) == FAIL\n\t\t    || add_tag_field(dict, \"filename\", full_fname,\n\t\t\t\t\t\t\t NULL) == FAIL\n\t\t    || add_tag_field(dict, \"cmd\", tp.command,\n\t\t\t\t\t\t       tp.command_end) == FAIL\n\t\t    || add_tag_field(dict, \"kind\", tp.tagkind,\n\t\t\t\t\t\t      tp.tagkind_end) == FAIL\n\t\t    || dict_add_number(dict, \"static\", is_static) == FAIL)\n\t\tret = FAIL;\n\n\t    vim_free(full_fname);\n\n\t    if (tp.command_end != NULL)\n\t    {\n\t\tfor (p = tp.command_end + 3;\n\t\t\t  *p != NUL && *p != '\\n' && *p != '\\r'; MB_PTR_ADV(p))\n\t\t{\n\t\t    if (p == tp.tagkind || (p + 5 == tp.tagkind\n\t\t\t\t\t      && STRNCMP(p, \"kind:\", 5) == 0))\n\t\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\t\tp = tp.tagkind_end - 1;\n\t\t    else if (STRNCMP(p, \"file:\", 5) == 0)\n\t\t\t// skip \"file:\" (static tag)\n\t\t\tp += 4;\n\t\t    else if (!VIM_ISWHITE(*p))\n\t\t    {\n\t\t\tchar_u\t*s, *n;\n\t\t\tint\tlen;\n\n\t\t\t// Add extra field as a dict entry.  Fields are\n\t\t\t// separated by Tabs.\n\t\t\tn = p;\n\t\t\twhile (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')\n\t\t\t    ++p;\n\t\t\tlen = (int)(p - n);\n\t\t\tif (*p == ':' && len > 0)\n\t\t\t{\n\t\t\t    s = ++p;\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\t    n[len] = NUL;\n\t\t\t    if (add_tag_field(dict, (char *)n, s, p) == FAIL)\n\t\t\t\tret = FAIL;\n\t\t\t    n[len] = ':';\n\t\t\t}\n\t\t\telse\n\t\t\t    // Skip field without colon.\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\tif (*p == NUL)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(matches[i]);\n\t}\n\tvim_free(matches);\n    }\n    return ret;\n}\n\n/*\n * Return information about 'tag' in dict 'retdict'.\n */\n    static void\nget_tag_details(taggy_T *tag, dict_T *retdict)\n{\n    list_T\t*pos;\n    fmark_T\t*fmark;\n\n    dict_add_string(retdict, \"tagname\", tag->tagname);\n    dict_add_number(retdict, \"matchnr\", tag->cur_match + 1);\n    dict_add_number(retdict, \"bufnr\", tag->cur_fnum);\n    if (tag->user_data)\n\tdict_add_string(retdict, \"user_data\", tag->user_data);\n\n    if ((pos = list_alloc_id(aid_tagstack_from)) == NULL)\n\treturn;\n    dict_add_list(retdict, \"from\", pos);\n\n    fmark = &tag->fmark;\n    list_append_number(pos,\n\t\t\t(varnumber_T)(fmark->fnum != -1 ? fmark->fnum : 0));\n    list_append_number(pos, (varnumber_T)fmark->mark.lnum);\n    list_append_number(pos, (varnumber_T)(fmark->mark.col == MAXCOL ?\n\t\t\t\t\tMAXCOL : fmark->mark.col + 1));\n    list_append_number(pos, (varnumber_T)fmark->mark.coladd);\n}\n\n/*\n * Return the tag stack entries of the specified window 'wp' in dictionary\n * 'retdict'.\n */\n    void\nget_tagstack(win_T *wp, dict_T *retdict)\n{\n    list_T\t*l;\n    int\t\ti;\n    dict_T\t*d;\n\n    dict_add_number(retdict, \"length\", wp->w_tagstacklen);\n    dict_add_number(retdict, \"curidx\", wp->w_tagstackidx + 1);\n    l = list_alloc_id(aid_tagstack_items);\n    if (l == NULL)\n\treturn;\n    dict_add_list(retdict, \"items\", l);\n\n    for (i = 0; i < wp->w_tagstacklen; i++)\n    {\n\tif ((d = dict_alloc_id(aid_tagstack_details)) == NULL)\n\t    return;\n\tlist_append_dict(l, d);\n\n\tget_tag_details(&wp->w_tagstack[i], d);\n    }\n}\n\n/*\n * Free all the entries in the tag stack of the specified window\n */\n    static void\ntagstack_clear(win_T *wp)\n{\n    int i;\n\n    // Free the current tag stack\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n\ttagstack_clear_entry(&wp->w_tagstack[i]);\n    wp->w_tagstacklen = 0;\n    wp->w_tagstackidx = 0;\n}\n\n/*\n * Remove the oldest entry from the tag stack and shift the rest of\n * the entries to free up the top of the stack.\n */\n    static void\ntagstack_shift(win_T *wp)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\ti;\n\n    tagstack_clear_entry(&tagstack[0]);\n    for (i = 1; i < wp->w_tagstacklen; ++i)\n\ttagstack[i - 1] = tagstack[i];\n    wp->w_tagstacklen--;\n}\n\n/*\n * Push a new item to the tag stack\n */\n    static void\ntagstack_push_item(\n\twin_T\t*wp,\n\tchar_u\t*tagname,\n\tint\tcur_fnum,\n\tint\tcur_match,\n\tpos_T\tmark,\n\tint\tfnum,\n\tchar_u  *user_data)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\tidx = wp->w_tagstacklen;\t// top of the stack\n\n    // if the tagstack is full: remove the oldest entry\n    if (idx >= TAGSTACKSIZE)\n    {\n\ttagstack_shift(wp);\n\tidx = TAGSTACKSIZE - 1;\n    }\n\n    wp->w_tagstacklen++;\n    tagstack[idx].tagname = tagname;\n    tagstack[idx].cur_fnum = cur_fnum;\n    tagstack[idx].cur_match = cur_match;\n    if (tagstack[idx].cur_match < 0)\n\ttagstack[idx].cur_match = 0;\n    tagstack[idx].fmark.mark = mark;\n    tagstack[idx].fmark.fnum = fnum;\n    tagstack[idx].user_data = user_data;\n}\n\n/*\n * Add a list of items to the tag stack in the specified window\n */\n    static void\ntagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n\n    // Add one entry at a time to the tag stack\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t// Skip non-dict items\n\titemdict = li->li_tv.vval.v_dict;\n\n\t// parse 'from' for the cursor position before the tag jump\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}\n\n/*\n * Set the current index in the tag stack. Valid values are between 0\n * and the stack length (inclusive).\n */\n    static void\ntagstack_set_curidx(win_T *wp, int curidx)\n{\n    wp->w_tagstackidx = curidx;\n    if (wp->w_tagstackidx < 0)\t\t\t// sanity check\n\twp->w_tagstackidx = 0;\n    if (wp->w_tagstackidx > wp->w_tagstacklen)\n\twp->w_tagstackidx = wp->w_tagstacklen;\n}\n\n/*\n * Set the tag stack entries of the specified window.\n * 'action' is set to one of:\n *\t'a' for append\n *\t'r' for replace\n *\t't' for truncate\n */\n    int\nset_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n\n#ifdef FEAT_EVAL\n    // not allowed to alter the tag stack entries from inside tagfunc\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n\n    if (action == 't')\t\t    // truncate the stack\n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\n\t// delete all the tag stack entries above the current entry\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t// replace the stack\n\t    tagstack_clear(wp);\n\n\ttagstack_push_items(wp, l);\n\t// set the current index after the last entry\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n\n    return OK;\n}\n#endif\n", "\" Test 'tagfunc'\n\nimport './vim9.vim' as v9\nsource check.vim\nsource screendump.vim\n\nfunc TagFunc(pat, flag, info)\n  let g:tagfunc_args = [a:pat, a:flag, a:info]\n  let tags = []\n  for num in range(1,10)\n    let tags += [{\n          \\ 'cmd': '2', 'name': 'nothing'.num, 'kind': 'm',\n          \\ 'filename': 'Xfile1', 'user_data': 'somedata'.num,\n          \\}]\n  endfor\n  return tags\nendfunc\n\nfunc Test_tagfunc()\n  set tagfunc=TagFunc\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n\n  call assert_equal({'cmd': '2', 'static': 0,\n        \\ 'name': 'nothing2', 'user_data': 'somedata2',\n        \\ 'kind': 'm', 'filename': 'Xfile1'}, taglist('.')[1])\n\n  call settagstack(win_getid(), {'items': []})\n\n  tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata1', gettagstack().items[0].user_data)\n  5tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n  pop\n  tag\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n\n  let g:tagfunc_args=[]\n  execute \"normal! \\<c-]>\"\n  call assert_equal('one', g:tagfunc_args[0])\n  call assert_equal('c', g:tagfunc_args[1])\n\n  let g:tagfunc_args=[]\n  execute \"tag /foo$\"\n  call assert_equal('foo$', g:tagfunc_args[0])\n  call assert_equal('r', g:tagfunc_args[1])\n\n  set cpt=t\n  let g:tagfunc_args=[]\n  execute \"normal! i\\<c-n>\\<c-y>\"\n  call assert_equal('\\<\\k\\k', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing1', getline('.')[0:7])\n\n  let g:tagfunc_args=[]\n  execute \"normal! ono\\<c-n>\\<c-n>\\<c-y>\"\n  call assert_equal('\\<no', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing2', getline('.')[0:7])\n\n  func BadTagFunc1(...)\n    return 0\n  endfunc\n  func BadTagFunc2(...)\n    return [1]\n  endfunc\n  func BadTagFunc3(...)\n    return [{'name': 'foo'}]\n  endfunc\n\n  for &tagfunc in ['BadTagFunc1', 'BadTagFunc2', 'BadTagFunc3']\n    try\n      tag nothing\n      call assert_false(1, 'tag command should have failed')\n    catch\n      call assert_exception('E987:')\n    endtry\n    exe 'delf' &tagfunc\n  endfor\n\n  func NullTagFunc(...)\n    return v:null\n  endfunc\n  set tags= tfu=NullTagFunc\n  call assert_fails('tag nothing', 'E433:')\n  delf NullTagFunc\n\n  bwipe!\n  set tags& tfu& cpt& \n  call delete('Xfile1')\nendfunc\n\n\" Test for modifying the tag stack from a tag function and jumping to a tag\n\" from a tag function\nfunc Test_tagfunc_settagstack()\n  func Mytagfunc1(pat, flags, info)\n    call settagstack(1, {'tagname' : 'mytag', 'from' : [0, 10, 1, 0]})\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc1\n  call writefile([''], 'Xtest')\n  call assert_fails('tag xyz', 'E986:')\n\n  func Mytagfunc2(pat, flags, info)\n    tag test_tag\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc2\n  call assert_fails('tag xyz', 'E986:')\n\n  call delete('Xtest')\n  set tagfunc&\n  delfunc Mytagfunc1\n  delfunc Mytagfunc2\nendfunc\n\n\" Script local tagfunc callback function\nfunc s:ScriptLocalTagFunc(pat, flags, info)\n  let g:ScriptLocalFuncArgs = [a:pat, a:flags, a:info]\n  return v:null\nendfunc\n\n\" Test for different ways of setting the 'tagfunc' option\nfunc Test_tagfunc_callback()\n  func TagFunc1(callnr, pat, flags, info)\n    let g:TagFunc1Args = [a:callnr, a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  func TagFunc2(pat, flags, info)\n    let g:TagFunc2Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &tagfunc = 'g:TagFunc2'\n    new\n    LET g:TagFunc2Args = []\n    call assert_fails('tag a10', 'E433:')\n    call assert_equal(['a10', '', {}], g:TagFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set tagfunc=function('g:TagFunc1',\\ [10])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a11', 'E433:')\n    call assert_equal([10, 'a11', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    VAR Fn = function('g:TagFunc1', [11])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([11, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = function('g:TagFunc1', [12])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([12, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set tagfunc=funcref('g:TagFunc1',\\ [13])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a13', 'E433:')\n    call assert_equal([13, 'a13', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [14])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([14, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [15])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([15, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b, c LMIDDLE g:TagFunc1(16, a, b, c) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set tagfunc=\" .. optval\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a17', 'E433:')\n    call assert_equal([16, 'a17', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a lambda expression\n    LET &tagfunc = LSTART a, b, c LMIDDLE g:TagFunc1(17, a, b, c) LEND\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([17, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(lambda expression)\n    LET &tagfunc = 'LSTART a, b, c LMIDDLE g:TagFunc1(18, a, b, c) LEND'\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([18, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(19, a, b, c) LEND\n    LET &tagfunc = Lambda\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([19, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(20, a, b, c) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([20, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b, c LMIDDLE strlen(a) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    call assert_fails(\"tag a20\", \"E987:\")\n    bw!\n\n    #\" Test for clearing the 'tagfunc' option\n    set tagfunc=''\n    set tagfunc&\n    call assert_fails(\"set tagfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set tagfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'tagfunc' to a non-existing function\n    LET &tagfunc = function('g:TagFunc2', [21])\n    LET g:TagFunc2Args = []\n    call assert_fails(\"set tagfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &tagfunc = function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"tag axb123\", 'E426:')\n    call assert_equal([], g:TagFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TagFunc3(pat, flags, info)\n    let g:TagFunc3Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  set tagfunc=s:TagFunc3\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a21', 'E433:')\n  call assert_equal(['a21', '', {}], g:TagFunc3Args)\n  bw!\n  let &tagfunc = 's:TagFunc3'\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a22', 'E433:')\n  call assert_equal(['a22', '', {}], g:TagFunc3Args)\n  bw!\n  delfunc s:TagFunc3\n\n  \" invalid return value\n  let &tagfunc = \"{a -> 'abc'}\"\n  call assert_fails(\"echo taglist('a')\", \"E987:\")\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set tagfunc=(a,\\ b,\\ c)\\ =>\\ g:TagFunc1(21,\\ a,\\ b,\\ c)\n  new\n  let g:TagFunc1Args = []\n  call assert_fails(\"tag a17\", \"E117:\")\n  call assert_equal([], g:TagFunc1Args)\n  bw!\n\n  \" Test for using a script local function\n  set tagfunc=<SID>ScriptLocalTagFunc\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a15', 'E433:')\n  call assert_equal(['a15', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a script local funcref variable\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= Fn\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a string(script local funcref variable)\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= string(Fn)\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" set 'tagfunc' to a partial with dict. This used to cause a crash.\n  func SetTagFunc()\n    let params = {'tagfn': function('g:DictTagFunc')}\n    let &tagfunc = params.tagfn\n  endfunc\n  func g:DictTagFunc(_) dict\n  endfunc\n  call SetTagFunc()\n  new\n  call SetTagFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set tagfunc=\n  wincmd w\n  set tagfunc=\n  :%bw!\n  delfunc g:DictTagFunc\n  delfunc SetTagFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tagFunc(callnr: number, pat: string, flags: string, info: dict<any>): any\n      g:Vim9tagFuncArgs = [callnr, pat, flags, info]\n      return null\n    enddef\n\n    # Test for using a def function with completefunc\n    set tagfunc=function('Vim9tagFunc',\\ [60])\n    new\n    g:Vim9tagFuncArgs = []\n    assert_fails('tag a10', 'E433:')\n    assert_equal([60, 'a10', '', {}], g:Vim9tagFuncArgs)\n\n    # Test for using a global function name\n    &tagfunc = g:TagFunc2\n    new\n    g:TagFunc2Args = []\n    assert_fails('tag a11', 'E433:')\n    assert_equal(['a11', '', {}], g:TagFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTagFunc(pat: string, flags: string, info: dict<any> ): any\n      g:LocalTagFuncArgs = [pat, flags, info]\n      return null\n    enddef\n    &tagfunc = LocalTagFunc\n    new\n    g:LocalTagFuncArgs = []\n    assert_fails('tag a12', 'E433:')\n    assert_equal(['a12', '', {}], g:LocalTagFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  delfunc TagFunc1\n  delfunc TagFunc2\n  set tagfunc&\n  %bw!\nendfunc\n\nfunc Test_tagfunc_wipes_buffer()\n  func g:Tag0unc0(t,f,o)\n   bwipe\n  endfunc\n  set tagfunc=g:Tag0unc0\n  new\n  cal assert_fails('tag 0', 'E987:')\n\n  delfunc g:Tag0unc0\n  set tagfunc=\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * Definition of error messages, sorted on error number.\n */\n\nEXTERN char e_interrupted[]\n\tINIT(= N_(\"Interrupted\"));\n\nEXTERN char e_backslash_should_be_followed_by[]\n\tINIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\n#ifdef FEAT_CMDWIN\nEXTERN char e_invalid_in_cmdline_window[]\n\tINIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\n#endif\nEXTERN char e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search[]\n\tINIT(= N_(\"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char e_file_exists[]\n\tINIT(= N_(\"E13: File exists (add ! to override)\"));\n// E14 unused\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_expression_str[]\n\tINIT(= N_(\"E15: Invalid expression: \\\"%s\\\"\"));\n#endif\nEXTERN char e_invalid_range[]\n\tINIT(= N_(\"E16: Invalid range\"));\n#if defined(UNIX) || defined(FEAT_SYN_HL) \\\n\t    || defined(FEAT_SPELL) || defined(FEAT_EVAL)\nEXTERN char e_str_is_directory[]\n\tINIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_unexpected_characters_in_let[]\n\tINIT(= N_(\"E18: Unexpected characters in :let\"));\nEXTERN char e_unexpected_characters_in_assignment[]\n\tINIT(= N_(\"E18: Unexpected characters in assignment\"));\n#endif\nEXTERN char e_mark_has_invalid_line_number[]\n\tINIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char e_mark_not_set[]\n\tINIT(= N_(\"E20: Mark not set\"));\nEXTERN char e_cannot_make_changes_modifiable_is_off[]\n\tINIT(= N_(\"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char e_scripts_nested_too_deep[]\n\tINIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char e_no_alternate_file[]\n\tINIT(= N_(\"E23: No alternate file\"));\nEXTERN char e_no_such_abbreviation[]\n\tINIT(= N_(\"E24: No such abbreviation\"));\n#if !defined(FEAT_GUI) || defined(VIMDLL)\nEXTERN char e_gui_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E25: GUI cannot be used: Not enabled at compile time\"));\n#endif\n#ifndef FEAT_RIGHTLEFT\nEXTERN char e_hebrew_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E26: Hebrew cannot be used: Not enabled at compile time\\n\"));\n#endif\nEXTERN char e_farsi_support_has_been_removed[]\n\tINIT(= N_(\"E27: Farsi support has been removed\\n\"));\n#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)\nEXTERN char e_no_such_highlight_group_name_str[]\n\tINIT(= N_(\"E28: No such highlight group name: %s\"));\n#endif\nEXTERN char e_no_inserted_text_yet[]\n\tINIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char e_no_previous_command_line[]\n\tINIT(= N_(\"E30: No previous command line\"));\nEXTERN char e_no_such_mapping[]\n\tINIT(= N_(\"E31: No such mapping\"));\nEXTERN char e_no_file_name[]\n\tINIT(= N_(\"E32: No file name\"));\nEXTERN char e_no_previous_substitute_regular_expression[]\n\tINIT(= N_(\"E33: No previous substitute regular expression\"));\nEXTERN char e_no_previous_command[]\n\tINIT(= N_(\"E34: No previous command\"));\nEXTERN char e_no_previous_regular_expression[]\n\tINIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char e_not_enough_room[]\n\tINIT(= N_(\"E36: Not enough room\"));\nEXTERN char e_no_write_since_last_change[]\n\tINIT(= N_(\"E37: No write since last change\"));\nEXTERN char e_no_write_since_last_change_add_bang_to_override[]\n\tINIT(= N_(\"E37: No write since last change (add ! to override)\"));\nEXTERN char e_null_argument[]\n\tINIT(= N_(\"E38: Null argument\"));\n#if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS) || defined(FEAT_EVAL)\nEXTERN char e_number_expected[]\n\tINIT(= N_(\"E39: Number expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_cant_open_errorfile_str[]\n\tINIT(= N_(\"E40: Can't open errorfile %s\"));\n#endif\nEXTERN char e_out_of_memory[]\n\tINIT(= N_(\"E41: Out of memory!\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_errors[]\n\tINIT(= N_(\"E42: No Errors\"));\n#endif\nEXTERN char e_damaged_match_string[]\n\tINIT(= N_(\"E43: Damaged match string\"));\nEXTERN char e_corrupted_regexp_program[]\n\tINIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char e_readonly_option_is_set_add_bang_to_override[]\n\tINIT(= N_(\"E45: 'readonly' option is set (add ! to override)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_change_readonly_variable[]\n\tINIT(= N_(\"E46: Cannot change read-only variable\"));\nEXTERN char e_cannot_change_readonly_variable_str[]\n\tINIT(= N_(\"E46: Cannot change read-only variable \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_error_while_reading_errorfile[]\n\tINIT(= N_(\"E47: Error while reading errorfile\"));\n#endif\n#ifdef HAVE_SANDBOX\nEXTERN char e_not_allowed_in_sandbox[]\n\tINIT(= N_(\"E48: Not allowed in sandbox\"));\n#endif\nEXTERN char e_invalid_scroll_size[]\n\tINIT(= N_(\"E49: Invalid scroll size\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_z[]\n\tINIT(= N_(\"E50: Too many \\\\z(\"));\n#endif\nEXTERN char e_too_many_str_open[]\n\tINIT(= N_(\"E51: Too many %s(\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_unmatched_z[]\n\tINIT(= N_(\"E52: Unmatched \\\\z(\"));\n#endif\nEXTERN char e_unmatched_str_percent_open[]\n\tINIT(= N_(\"E53: Unmatched %s%%(\"));\nEXTERN char e_unmatched_str_open[]\n\tINIT(= N_(\"E54: Unmatched %s(\"));\nEXTERN char e_unmatched_str_close[]\n\tINIT(= N_(\"E55: Unmatched %s)\"));\n// E56 unused\n// E57 unused\n// E58 unused\nEXTERN char e_invalid_character_after_str_at[]\n\tINIT(= N_(\"E59: Invalid character after %s@\"));\nEXTERN char e_too_many_complex_str_curly[]\n\tINIT(= N_(\"E60: Too many complex %s{...}s\"));\nEXTERN char e_nested_str[]\n\tINIT(= N_(\"E61: Nested %s*\"));\nEXTERN char e_nested_str_chr[]\n\tINIT(= N_(\"E62: Nested %s%c\"));\nEXTERN char e_invalid_use_of_underscore[]\n\tINIT(= N_(\"E63: Invalid use of \\\\_\"));\nEXTERN char e_str_chr_follows_nothing[]\n\tINIT(= N_(\"E64: %s%c follows nothing\"));\nEXTERN char e_illegal_back_reference[]\n\tINIT(= N_(\"E65: Illegal back reference\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_z_not_allowed_here[]\n\tINIT(= N_(\"E66: \\\\z( not allowed here\"));\nEXTERN char e_z1_z9_not_allowed_here[]\n\tINIT(= N_(\"E67: \\\\z1 - \\\\z9 not allowed here\"));\n#endif\nEXTERN char e_invalid_character_after_bsl_z[]\n\tINIT(= N_(\"E68: Invalid character after \\\\z\"));\nEXTERN char e_missing_sb_after_str[]\n\tINIT(= N_(\"E69: Missing ] after %s%%[\"));\nEXTERN char e_empty_str_brackets[]\n\tINIT(= N_(\"E70: Empty %s%%[]\"));\nEXTERN char e_invalid_character_after_str[]\n\tINIT(= N_(\"E71: Invalid character after %s%%\"));\nEXTERN char e_close_error_on_swap_file[]\n\tINIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char e_tag_stack_empty[]\n\tINIT(= N_(\"E73: Tag stack empty\"));\nEXTERN char e_command_too_complex[]\n\tINIT(= N_(\"E74: Command too complex\"));\nEXTERN char e_name_too_long[]\n\tINIT(= N_(\"E75: Name too long\"));\nEXTERN char e_too_many_brackets[]\n\tINIT(= N_(\"E76: Too many [\"));\nEXTERN char e_too_many_file_names[]\n\tINIT(= N_(\"E77: Too many file names\"));\nEXTERN char e_unknown_mark[]\n\tINIT(= N_(\"E78: Unknown mark\"));\nEXTERN char e_cannot_expand_wildcards[]\n\tINIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char e_error_while_writing[]\n\tINIT(= N_(\"E80: Error while writing\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_sid_not_in_script_context[]\n\tINIT(= N_(\"E81: Using <SID> not in a script context\"));\n#endif\nEXTERN char e_cannot_allocate_any_buffer_exiting[]\n\tINIT(= N_(\"E82: Cannot allocate any buffer, exiting...\"));\nEXTERN char e_cannot_allocate_buffer_using_other_one[]\n\tINIT(= N_(\"E83: Cannot allocate buffer, using other one...\"));\nEXTERN char e_no_modified_buffer_found[]\n\tINIT(= N_(\"E84: No modified buffer found\"));\nEXTERN char e_there_is_no_listed_buffer[]\n\tINIT(= N_(\"E85: There is no listed buffer\"));\nEXTERN char e_buffer_nr_does_not_exist[]\n\tINIT(= N_(\"E86: Buffer %ld does not exist\"));\nEXTERN char e_cannot_go_beyond_last_buffer[]\n\tINIT(= N_(\"E87: Cannot go beyond last buffer\"));\nEXTERN char e_cannot_go_before_first_buffer[]\n\tINIT(= N_(\"E88: Cannot go before first buffer\"));\nEXTERN char e_no_write_since_last_change_for_buffer_nr_add_bang_to_override[]\n\tINIT(= N_(\"E89: No write since last change for buffer %d (add ! to override)\"));\nEXTERN char e_cannot_unload_last_buffer[]\n\tINIT(= N_(\"E90: Cannot unload last buffer\"));\nEXTERN char e_shell_option_is_empty[]\n\tINIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char e_buffer_nr_not_found[]\n\tINIT(= N_(\"E92: Buffer %d not found\"));\nEXTERN char e_more_than_one_match_for_str[]\n\tINIT(= N_(\"E93: More than one match for %s\"));\nEXTERN char e_no_matching_buffer_for_str[]\n\tINIT(= N_(\"E94: No matching buffer for %s\"));\nEXTERN char e_buffer_with_this_name_already_exists[]\n\tINIT(= N_(\"E95: Buffer with this name already exists\"));\n#if defined(FEAT_DIFF)\nEXTERN char e_cannot_diff_more_than_nr_buffers[]\n\tINIT(= N_(\"E96: Cannot diff more than %d buffers\"));\nEXTERN char e_cannot_create_diffs[]\n\tINIT(= N_(\"E97: Cannot create diffs\"));\nEXTERN char e_cannot_read_diff_output[]\n\tINIT(= N_(\"E98: Cannot read diff output\"));\nEXTERN char e_current_buffer_is_not_in_diff_mode[]\n\tINIT(= N_(\"E99: Current buffer is not in diff mode\"));\nEXTERN char e_no_other_buffer_in_diff_mode[]\n\tINIT(= N_(\"E100: No other buffer in diff mode\"));\nEXTERN char e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use[]\n\tINIT(= N_(\"E101: More than two buffers in diff mode, don't know which one to use\"));\nEXTERN char e_cant_find_buffer_str[]\n\tINIT(= N_(\"E102: Can't find buffer \\\"%s\\\"\"));\nEXTERN char e_buffer_str_is_not_in_diff_mode[]\n\tINIT(= N_(\"E103: Buffer \\\"%s\\\" is not in diff mode\"));\n#endif\n#ifdef FEAT_DIGRAPHS\nEXTERN char e_escape_not_allowed_in_digraph[]\n\tINIT(= N_(\"E104: Escape not allowed in digraph\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_using_loadkeymap_not_in_sourced_file[]\n\tINIT(= N_(\"E105: Using :loadkeymap not in a sourced file\"));\n#endif\n// E106 unused\n#ifdef FEAT_EVAL\nEXTERN char e_missing_parenthesis_str[]\n\tINIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char e_no_such_variable_str[]\n\tINIT(= N_(\"E108: No such variable: \\\"%s\\\"\"));\nEXTERN char e_missing_colon_after_questionmark[]\n\tINIT(= N_(\"E109: Missing ':' after '?'\"));\nEXTERN char e_missing_closing_paren[]\n\tINIT(= N_(\"E110: Missing ')'\"));\nEXTERN char e_missing_closing_square_brace[]\n\tINIT(= N_(\"E111: Missing ']'\"));\nEXTERN char e_option_name_missing_str[]\n\tINIT(= N_(\"E112: Option name missing: %s\"));\nEXTERN char e_unknown_option_str[]\n\tINIT(= N_(\"E113: Unknown option: %s\"));\nEXTERN char e_missing_double_quote_str[]\n\tINIT(= N_(\"E114: Missing double quote: %s\"));\nEXTERN char e_missing_single_quote_str[]\n\tINIT(= N_(\"E115: Missing single quote: %s\"));\nEXTERN char e_invalid_arguments_for_function_str[]\n\tINIT(= N_(\"E116: Invalid arguments for function %s\"));\nEXTERN char e_unknown_function_str[]\n\tINIT(= N_(\"E117: Unknown function: %s\"));\nEXTERN char e_too_many_arguments_for_function_str[]\n\tINIT(= N_(\"E118: Too many arguments for function: %s\"));\nEXTERN char e_not_enough_arguments_for_function_str[]\n\tINIT(= N_(\"E119: Not enough arguments for function: %s\"));\nEXTERN char e_using_sid_not_in_script_context_str[]\n\tINIT(= N_(\"E120: Using <SID> not in a script context: %s\"));\nEXTERN char e_undefined_variable_str[]\n\tINIT(= N_(\"E121: Undefined variable: %s\"));\nEXTERN char e_undefined_variable_char_str[]\n\tINIT(= N_(\"E121: Undefined variable: %c:%s\"));\nEXTERN char e_function_str_already_exists_add_bang_to_replace[]\n\tINIT(= N_(\"E122: Function %s already exists, add ! to replace it\"));\nEXTERN char e_undefined_function_str[]\n\tINIT(= N_(\"E123: Undefined function: %s\"));\nEXTERN char e_missing_paren_str[]\n\tINIT(= N_(\"E124: Missing '(': %s\"));\nEXTERN char e_illegal_argument_str[]\n\tINIT(= N_(\"E125: Illegal argument: %s\"));\nEXTERN char e_missing_endfunction[]\n\tINIT(= N_(\"E126: Missing :endfunction\"));\nEXTERN char e_cannot_redefine_function_str_it_is_in_use[]\n\tINIT(= N_(\"E127: Cannot redefine function %s: It is in use\"));\nEXTERN char e_function_name_must_start_with_capital_or_s_str[]\n\tINIT(= N_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"));\nEXTERN char e_function_name_required[]\n\tINIT(= N_(\"E129: Function name required\"));\n// E130 unused\nEXTERN char e_cannot_delete_function_str_it_is_in_use[]\n\tINIT(= N_(\"E131: Cannot delete function %s: It is in use\"));\nEXTERN char e_function_call_depth_is_higher_than_macfuncdepth[]\n\tINIT(= N_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\nEXTERN char e_return_not_inside_function[]\n\tINIT(= N_(\"E133: :return not inside a function\"));\n#endif\nEXTERN char e_cannot_move_range_of_lines_into_itself[]\n\tINIT(= N_(\"E134: Cannot move a range of lines into itself\"));\nEXTERN char e_filter_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E135: *Filter* Autocommands must not change current buffer\"));\n#if defined(FEAT_VIMINFO)\nEXTERN char e_viminfo_too_many_errors_skipping_rest_of_file[]\n\tINIT(= N_(\"E136: viminfo: Too many errors, skipping rest of file\"));\nEXTERN char e_viminfo_file_is_not_writable_str[]\n\tINIT(= N_(\"E137: Viminfo file is not writable: %s\"));\nEXTERN char e_cant_write_viminfo_file_str[]\n\tINIT(= N_(\"E138: Can't write viminfo file %s!\"));\n#endif\nEXTERN char e_file_is_loaded_in_another_buffer[]\n\tINIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char e_use_bang_to_write_partial_buffer[]\n\tINIT(= N_(\"E140: Use ! to write partial buffer\"));\nEXTERN char e_no_file_name_for_buffer_nr[]\n\tINIT(= N_(\"E141: No file name for buffer %ld\"));\nEXTERN char e_file_not_written_writing_is_disabled_by_write_option[]\n\tINIT(= N_(\"E142: File not written: Writing is disabled by 'write' option\"));\nEXTERN char e_autocommands_unexpectedly_deleted_new_buffer_str[]\n\tINIT(= N_(\"E143: Autocommands unexpectedly deleted new buffer %s\"));\nEXTERN char e_non_numeric_argument_to_z[]\n\tINIT(= N_(\"E144: Non-numeric argument to :z\"));\nEXTERN char e_shell_commands_and_some_functionality_not_allowed_in_rvim[]\n\tINIT(= N_(\"E145: Shell commands and some functionality not allowed in rvim\"));\nEXTERN char e_regular_expressions_cant_be_delimited_by_letters[]\n\tINIT(= N_(\"E146: Regular expressions can't be delimited by letters\"));\nEXTERN char e_cannot_do_global_recursive_with_range[]\n\tINIT(= N_(\"E147: Cannot do :global recursive with a range\"));\nEXTERN char e_regular_expression_missing_from_global[]\n\tINIT(= N_(\"E148: Regular expression missing from :global\"));\nEXTERN char e_sorry_no_help_for_str[]\n\tINIT(= N_(\"E149: Sorry, no help for %s\"));\nEXTERN char e_not_a_directory_str[]\n\tINIT(= N_(\"E150: Not a directory: %s\"));\nEXTERN char e_no_match_str_1[]\n\tINIT(= N_(\"E151: No match: %s\"));\nEXTERN char e_cannot_open_str_for_writing_1[]\n\tINIT(= N_(\"E152: Cannot open %s for writing\"));\nEXTERN char e_unable_to_open_str_for_reading[]\n\tINIT(= N_(\"E153: Unable to open %s for reading\"));\nEXTERN char e_duplicate_tag_str_in_file_str_str[]\n\tINIT(= N_(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"));\n#ifdef FEAT_SIGNS\nEXTERN char e_unknown_sign_str[]\n\tINIT(= N_(\"E155: Unknown sign: %s\"));\nEXTERN char e_missing_sign_name[]\n\tINIT(= N_(\"E156: Missing sign name\"));\nEXTERN char e_invalid_sign_id_nr[]\n\tINIT(= N_(\"E157: Invalid sign ID: %d\"));\n#endif\n#if defined(FEAT_SIGNS) || defined(FEAT_EVAL)\nEXTERN char e_invalid_buffer_name_str[]\n\tINIT(= N_(\"E158: Invalid buffer name: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_missing_sign_number[]\n\tINIT(= N_(\"E159: Missing sign number\"));\nEXTERN char e_unknown_sign_command_str[]\n\tINIT(= N_(\"E160: Unknown sign command: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_breakpoint_not_found_str[]\n\tINIT(= N_(\"E161: Breakpoint not found: %s\"));\n#endif\nEXTERN char e_no_write_since_last_change_for_buffer_str[]\n\tINIT(= N_(\"E162: No write since last change for buffer \\\"%s\\\"\"));\nEXTERN char e_there_is_only_one_file_to_edit[]\n\tINIT(= N_(\"E163: There is only one file to edit\"));\nEXTERN char e_cannot_go_before_first_file[]\n\tINIT(= N_(\"E164: Cannot go before first file\"));\nEXTERN char e_cannot_go_beyond_last_file[]\n\tINIT(= N_(\"E165: Cannot go beyond last file\"));\nEXTERN char e_cant_open_linked_file_for_writing[]\n\tINIT(= N_(\"E166: Can't open linked file for writing\"));\nEXTERN char e_scriptencoding_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E167: :scriptencoding used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_finish_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E168: :finish used outside of a sourced file\"));\n#endif\nEXTERN char e_command_too_recursive[]\n\tINIT(= N_(\"E169: Command too recursive\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endwhile[]\n\tINIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char e_missing_endfor[]\n\tINIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char e_missing_endif[]\n\tINIT(= N_(\"E171: Missing :endif\"));\nEXTERN char e_missing_marker[]\n\tINIT(= N_(\"E172: Missing marker\"));\n#endif\nEXTERN char e_nr_more_file_to_edit[]\n\tINIT(= N_(\"E173: %d more file to edit\"));\nEXTERN char e_nr_more_files_to_edit[]\n\tINIT(= N_(\"E173: %d more files to edit\"));\nEXTERN char e_command_already_exists_add_bang_to_replace_it_str[]\n\tINIT(= N_(\"E174: Command already exists: add ! to replace it: %s\"));\nEXTERN char e_no_attribute_specified[]\n\tINIT(= N_(\"E175: No attribute specified\"));\nEXTERN char e_invalid_number_of_arguments[]\n\tINIT(= N_(\"E176: Invalid number of arguments\"));\nEXTERN char e_count_cannot_be_specified_twice[]\n\tINIT(= N_(\"E177: Count cannot be specified twice\"));\nEXTERN char e_invalid_default_value_for_count[]\n\tINIT(= N_(\"E178: Invalid default value for count\"));\nEXTERN char e_argument_required_for_str[]\n\tINIT(= N_(\"E179: Argument required for %s\"));\nEXTERN char e_invalid_complete_value_str[]\n\tINIT(= N_(\"E180: Invalid complete value: %s\"));\nEXTERN char e_invalid_address_type_value_str[]\n\tINIT(= N_(\"E180: Invalid address type value: %s\"));\nEXTERN char e_invalid_attribute_str[]\n\tINIT(= N_(\"E181: Invalid attribute: %s\"));\nEXTERN char e_invalid_command_name[]\n\tINIT(= N_(\"E182: Invalid command name\"));\nEXTERN char e_user_defined_commands_must_start_with_an_uppercase_letter[]\n\tINIT(= N_(\"E183: User defined commands must start with an uppercase letter\"));\nEXTERN char e_no_such_user_defined_command_str[]\n\tINIT(= N_(\"E184: No such user-defined command: %s\"));\nEXTERN char e_cannot_find_color_scheme_str[]\n\tINIT(= N_(\"E185: Cannot find color scheme '%s'\"));\nEXTERN char e_no_previous_directory[]\n\tINIT(= N_(\"E186: No previous directory\"));\nEXTERN char e_directory_unknown[]\n\tINIT(= N_(\"E187: Directory unknown\"));\nEXTERN char e_obtaining_window_position_not_implemented_for_this_platform[]\n\tINIT(= N_(\"E188: Obtaining window position not implemented for this platform\"));\nEXTERN char e_str_exists_add_bang_to_override[]\n\tINIT(= N_(\"E189: \\\"%s\\\" exists (add ! to override)\"));\nEXTERN char e_cannot_open_str_for_writing_2[]\n\tINIT(= N_(\"E190: Cannot open \\\"%s\\\" for writing\"));\nEXTERN char e_argument_must_be_letter_or_forward_backward_quote[]\n\tINIT(= N_(\"E191: Argument must be a letter or forward/backward quote\"));\nEXTERN char e_recursive_use_of_normal_too_deep[]\n\tINIT(= N_(\"E192: Recursive use of :normal too deep\"));\n#ifdef FEAT_EVAL\nEXTERN char e_str_not_inside_function[]\n\tINIT(= N_(\"E193: %s not inside a function\"));\n#endif\nEXTERN char e_no_alternate_file_name_to_substitute_for_hash[]\n\tINIT(= N_(\"E194: No alternate file name to substitute for '#'\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_cannot_open_viminfo_file_for_reading[]\n\tINIT(= N_(\"E195: Cannot open viminfo file for reading\"));\n#endif\n#ifndef FEAT_DIGRAPHS\nEXTERN char e_no_digraphs_version[]\n\tINIT(= N_(\"E196: No digraphs in this version\"));\n#endif\nEXTERN char e_cannot_set_language_to_str[]\n\tINIT(= N_(\"E197: Cannot set language to \\\"%s\\\"\"));\n// E198 unused\n#ifdef FEAT_CMDWIN\nEXTERN char e_active_window_or_buffer_deleted[]\n\tINIT(= N_(\"E199: Active window or buffer deleted\"));\n#endif\nEXTERN char e_readpre_autocommands_made_file_unreadable[]\n\tINIT(= N_(\"E200: *ReadPre autocommands made the file unreadable\"));\nEXTERN char e_readpre_autocommands_must_not_change_current_buffer[]\n\tINIT(= N_(\"E201: *ReadPre autocommands must not change current buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_conversion_mad_file_unreadable[]\n\tINIT(= N_(\"E202: Conversion made file unreadable!\"));\n#endif\nEXTERN char e_autocommands_deleted_or_unloaded_buffer_to_be_written[]\n\tINIT(= N_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\nEXTERN char e_autocommands_changed_number_of_lines_in_unexpected_way[]\n\tINIT(= N_(\"E204: Autocommand changed number of lines in unexpected way\"));\nEXTERN char e_patchmode_cant_save_original_file[]\n\tINIT(= N_(\"E205: Patchmode: can't save original file\"));\nEXTERN char e_patchmode_cant_touch_empty_original_file[]\n\tINIT(= N_(\"E206: Patchmode: can't touch empty original file\"));\nEXTERN char e_cant_delete_backup_file[]\n\tINIT(= N_(\"E207: Can't delete backup file\"));\nEXTERN char e_error_writing_to_str[]\n\tINIT(= N_(\"E208: Error writing to \\\"%s\\\"\"));\nEXTERN char e_error_closing_str[]\n\tINIT(= N_(\"E209: Error closing \\\"%s\\\"\"));\nEXTERN char e_error_reading_str[]\n\tINIT(= N_(\"E210: Error reading \\\"%s\\\"\"));\nEXTERN char e_file_str_no_longer_available[]\n\tINIT(= N_(\"E211: File \\\"%s\\\" no longer available\"));\nEXTERN char e_cant_open_file_for_writing[]\n\tINIT(= N_(\"E212: Can't open file for writing\"));\nEXTERN char e_cannot_convert_add_bang_to_write_without_conversion[]\n\tINIT(= N_(\"E213: Cannot convert (add ! to write without conversion)\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cant_find_temp_file_for_writing[]\n\tINIT(= N_(\"E214: Can't find temp file for writing\"));\n#endif\nEXTERN char e_illegal_character_after_star_str[]\n\tINIT(= N_(\"E215: Illegal character after *: %s\"));\nEXTERN char e_no_such_event_str[]\n\tINIT(= N_(\"E216: No such event: %s\"));\nEXTERN char e_no_such_group_or_event_str[]\n\tINIT(= N_(\"E216: No such group or event: %s\"));\nEXTERN char e_cant_execute_autocommands_for_all_events[]\n\tINIT(= N_(\"E217: Can't execute autocommands for ALL events\"));\nEXTERN char e_autocommand_nesting_too_deep[]\n\tINIT(= N_(\"E218: Autocommand nesting too deep\"));\nEXTERN char e_missing_open_curly[]\n\tINIT(= N_(\"E219: Missing {.\"));\nEXTERN char e_missing_close_curly[]\n\tINIT(= N_(\"E220: Missing }.\"));\n#ifdef FEAT_EVAL\nEXTERN char e_marker_cannot_start_with_lower_case_letter[]\n\tINIT(= N_(\"E221: Marker cannot start with lower case letter\"));\n#endif\nEXTERN char e_add_to_internal_buffer_that_was_already_read_from[]\n\tINIT(= N_(\"E222: Add to internal buffer that was already read from\"));\nEXTERN char e_recursive_mapping[]\n\tINIT(= N_(\"E223: Recursive mapping\"));\nEXTERN char e_global_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E224: Global abbreviation already exists for %s\"));\nEXTERN char e_global_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E225: Global mapping already exists for %s\"));\nEXTERN char e_abbreviation_already_exists_for_str[]\n\tINIT(= N_(\"E226: Abbreviation already exists for %s\"));\nEXTERN char e_mapping_already_exists_for_str[]\n\tINIT(= N_(\"E227: Mapping already exists for %s\"));\nEXTERN char e_makemap_illegal_mode[]\n\tINIT(= N_(\"E228: makemap: Illegal mode\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_the_GUI[]\n\tINIT(= N_(\"E229: Cannot start the GUI\"));\nEXTERN char e_cannot_read_from_str[]\n\tINIT(= N_(\"E230: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_guifontwide_invalid[]\n\tINIT(= N_(\"E231: 'guifontwide' invalid\"));\n#ifdef FEAT_BEVAL_GUI\nEXTERN char e_cannot_create_ballooneval_with_both_message_and_callback[]\n\tINIT(= N_(\"E232: Cannot create BalloonEval with both message and callback\"));\n#endif\n# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)\nEXTERN char e_cannot_open_display[]\n\tINIT(= N_(\"E233: Cannot open display\"));\n# endif\n# if defined(FEAT_XFONTSET)\nEXTERN char e_unknown_fontset_str[]\n\tINIT(= N_(\"E234: Unknown fontset: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\nEXTERN char e_unknown_font_str[]\n\tINIT(= N_(\"E235: Unknown font: %s\"));\n# endif\n# if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)\nEXTERN char e_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E236: Font \\\"%s\\\" is not fixed-width\"));\n# endif\n#endif\n#ifdef MSWIN\nEXTERN char e_printer_selection_failed[]\n\tINIT(= N_(\"E237: Printer selection failed\"));\nEXTERN char e_print_error_str[]\n\tINIT(= N_(\"E238: Print error: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_invalid_sign_text_str[]\n\tINIT(= N_(\"E239: Invalid sign text: %s\"));\n#endif\n#if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\nEXTERN char e_no_connection_to_x_server[]\n\tINIT(= N_(\"E240: No connection to the X server\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_str[]\n\tINIT(= N_(\"E241: Unable to send to %s\"));\n#endif\nEXTERN char e_cant_split_window_while_closing_another[]\n\tINIT(= N_(\"E242: Can't split a window while closing another\"));\n#if defined(FEAT_GUI_MSWIN) && !defined(FEAT_OLE)\nEXTERN char e_argument_not_supported_str_use_ole_version[]\n\tINIT(= N_(\"E243: Argument not supported: \\\"-%s\\\"; Use the OLE version.\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_illegal_str_name_str_in_font_name_str[]\n\tINIT(= N_(\"E244: Illegal %s name \\\"%s\\\" in font name \\\"%s\\\"\"));\nEXTERN char e_illegal_char_nr_in_font_name_str[]\n\tINIT(= N_(\"E245: Illegal char '%c' in font name \\\"%s\\\"\"));\n#endif\nEXTERN char e_filechangedshell_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E246: FileChangedShell autocommand deleted buffer\"));\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_no_registered_server_named_str[]\n\tINIT(= N_(\"E247: No registered server named \\\"%s\\\"\"));\nEXTERN char e_failed_to_send_command_to_destination_program[]\n\tINIT(= N_(\"E248: Failed to send command to the destination program\"));\n#endif\nEXTERN char e_window_layout_changed_unexpectedly[]\n\tINIT(= N_(\"E249: Window layout changed unexpectedly\"));\n#ifdef FEAT_XFONTSET\nEXTERN char e_fonts_for_the_following_charsets_are_missing_in_fontset[]\n\tINIT(= N_(\"E250: Fonts for the following charsets are missing in fontset %s:\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_vim_instance_registry_property_is_badly_formed_deleted[]\n\tINIT(= N_(\"E251: VIM instance registry property is badly formed.  Deleted!\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_fontsent_name_str_font_str_is_not_fixed_width[]\n\tINIT(= N_(\"E252: Fontset name: %s - Font '%s' is not fixed-width\"));\nEXTERN char e_fontset_name_str[]\n\tINIT(= N_(\"E253: Fontset name: %s\"));\n#endif\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_cannot_allocate_color_str[]\n\tINIT(= N_(\"E254: Cannot allocate color %s\"));\n#endif\n#if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)\nEXTERN char e_couldnt_read_in_sign_data[]\n\tINIT(= N_(\"E255: Couldn't read in sign data\"));\n#endif\n// E256 unused\n#ifdef FEAT_CSCOPE\nEXTERN char e_cstag_tag_not_founc[]\n\tINIT(= N_(\"E257: cstag: Tag not found\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_send_to_client[]\n\tINIT(= N_(\"E258: Unable to send to client\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_no_matches_found_for_cscope_query_str_of_str[]\n\tINIT(= N_(\"E259: No matches found for cscope query %s of %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_name_after_method[]\n\tINIT(= N_(\"E260: Missing name after ->\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_connection_str_not_founc[]\n\tINIT(= N_(\"E261: Cscope connection %s not found\"));\nEXTERN char e_error_reading_cscope_connection_nr[]\n\tINIT(= N_(\"E262: Error reading cscope connection %d\"));\n#endif\n#if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)\nEXTERN char e_sorry_this_command_is_disabled_python_library_could_not_be_found[]\n\tINIT(= N_(\"E263: Sorry, this command is disabled, the Python library could not be loaded.\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_python_error_initialising_io_object[]\n\tINIT(= N_(\"E264: Python: Error initialising I/O objects\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_dollar_must_be_an_instance_of_string[]\n\tINIT(= N_(\"E265: $_ must be an instance of String\"));\n#endif\n#ifdef DYNAMIC_RUBY\nEXTERN char e_sorry_this_command_is_disabled_the_ruby_library_could_not_be_loaded[]\n\tINIT(= N_(\"E266: Sorry, this command is disabled, the Ruby library could not be loaded.\"));\n#endif\n#ifdef FEAT_RUBY\nEXTERN char e_unexpected_return[]\n\tINIT(= N_(\"E267: Unexpected return\"));\nEXTERN char e_unexpected_next[]\n\tINIT(= N_(\"E268: Unexpected next\"));\nEXTERN char e_unexpected_break[]\n\tINIT(= N_(\"E269: Unexpected break\"));\nEXTERN char e_unexpected_redo[]\n\tINIT(= N_(\"E270: Unexpected redo\"));\nEXTERN char e_retry_outside_of_rescue_clause[]\n\tINIT(= N_(\"E271: Retry outside of rescue clause\"));\nEXTERN char e_unhandled_exception[]\n\tINIT(= N_(\"E272: Unhandled exception\"));\nEXTERN char e_unknown_longjmp_status_nr[]\n\tINIT(= N_(\"E273: Unknown longjmp status %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_before_parenthesis[]\n\tINIT(= N_(\"E274: No white space allowed before parenthesis\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_add_text_property_to_unloaded_buffer[]\n\tINIT(= N_(\"E275: Cannot add text property to unloaded buffer\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_function_as_method_str[]\n\tINIT(= N_(\"E276: Cannot use function as a method: %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_unable_to_read_server_reply[]\n\tINIT(= N_(\"E277: Unable to read a server reply\"));\n#endif\n// E278 unused\n#if defined(FEAT_TERMINAL) && !defined(UNIX) && !defined(MSWIN)\nEXTERN char e_sorry_plusplusshell_not_supported_on_this_system[]\n\tINIT(= N_(\"E279: Sorry, ++shell is not supported on this system\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_tcl_fatal_error_reflist_corrupt_please_report_this[]\n\tINIT(= N_(\"E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org\"));\n#endif\n// E281 unused\nEXTERN char e_cannot_read_from_str_2[]\n\tINIT(= N_(\"E282: Cannot read from \\\"%s\\\"\"));\nEXTERN char e_no_marks_matching_str[]\n\tINIT(= N_(\"E283: No marks matching \\\"%s\\\"\"));\n#ifdef FEAT_XIM\n# ifndef FEAT_GUI_GTK\nEXTERN char e_cannot_set_ic_values[]\n\tINIT(= N_(\"E284: Cannot set IC values\"));\n# endif\n# ifdef FEAT_GUI_X11\nEXTERN char e_failed_to_create_input_context[]\n\tINIT(= N_(\"E285: Failed to create input context\"));\nEXTERN char e_failed_to_open_input_method[]\n\tINIT(= N_(\"E286: Failed to open input method\"));\nEXTERN char e_warning_could_not_set_destroy_callback_to_im[]\n\tINIT(= N_(\"E287: Warning: Could not set destroy callback to IM\"));\nEXTERN char e_input_method_doesnt_support_any_style[]\n\tINIT(= N_(\"E288: Input method doesn't support any style\"));\nEXTERN char e_input_method_doesnt_support_my_preedit_type[]\n\tINIT(= N_(\"E289: Input method doesn't support my preedit type\"));\n# endif\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_list_or_number_required[]\n\tINIT(= N_(\"E290: List or number required\"));\n#endif\n// E291 unused\nEXTERN char e_invalid_count_for_del_bytes_nr[]\n\tINIT(= N_(\"E292: Invalid count for del_bytes(): %ld\"));\nEXTERN char e_block_was_not_locked[]\n\tINIT(= N_(\"E293: Block was not locked\"));\nEXTERN char e_seek_error_in_swap_file_read[]\n\tINIT(= N_(\"E294: Seek error in swap file read\"));\nEXTERN char e_read_error_in_swap_file[]\n\tINIT(= N_(\"E295: Read error in swap file\"));\nEXTERN char e_seek_error_in_swap_file_write[]\n\tINIT(= N_(\"E296: Seek error in swap file write\"));\nEXTERN char e_write_error_in_swap_file[]\n\tINIT(= N_(\"E297: Write error in swap file\"));\nEXTERN char e_didnt_get_block_nr_zero[]\n\tINIT(= N_(\"E298: Didn't get block nr 0?\"));\nEXTERN char e_didnt_get_block_nr_one[]\n\tINIT(= N_(\"E298: Didn't get block nr 1?\"));\nEXTERN char e_didnt_get_block_nr_two[]\n\tINIT(= N_(\"E298: Didn't get block nr 2?\"));\n#ifdef FEAT_PERL\nEXTERN char e_perl_evaluation_forbidden_in_sandbox_without_safe_module[]\n\tINIT(= N_(\"E299: Perl evaluation forbidden in sandbox without the Safe module\"));\n#endif\nEXTERN char e_swap_file_already_exists_symlink_attack[]\n\tINIT(= N_(\"E300: Swap file already exists (symlink attack?)\"));\nEXTERN char e_oops_lost_the_swap_file[]\n\tINIT(= N_(\"E301: Oops, lost the swap file!!!\"));\nEXTERN char e_could_not_rename_swap_file[]\n\tINIT(= N_(\"E302: Could not rename swap file\"));\nEXTERN char e_unable_to_open_swap_file_for_str_recovery_impossible[]\n\tINIT(= N_(\"E303: Unable to open swap file for \\\"%s\\\", recovery impossible\"));\nEXTERN char e_ml_upd_block0_didnt_get_block_zero[]\n\tINIT(= N_(\"E304: ml_upd_block0(): Didn't get block 0??\"));\nEXTERN char e_no_swap_file_found_for_str[]\n\tINIT(= N_(\"E305: No swap file found for %s\"));\nEXTERN char e_cannot_open_str[]\n\tINIT(= N_(\"E306: Cannot open %s\"));\nEXTERN char e_str_does_not_look_like_vim_swap_file[]\n\tINIT(= N_(\"E307: %s does not look like a Vim swap file\"));\nEXTERN char e_warning_original_file_may_have_been_changed[]\n\tINIT(= N_(\"E308: Warning: Original file may have been changed\"));\nEXTERN char e_unable_to_read_block_one_from_str[]\n\tINIT(= N_(\"E309: Unable to read block 1 from %s\"));\nEXTERN char e_block_one_id_wrong_str_not_swp_file[]\n\tINIT(= N_(\"E310: Block 1 ID wrong (%s not a .swp file?)\"));\nEXTERN char e_recovery_interrupted[]\n\tINIT(= N_(\"E311: Recovery Interrupted\"));\nEXTERN char e_errors_detected_while_recovering_look_for_lines_starting_with_questions[]\n\tINIT(= N_(\"E312: Errors detected while recovering; look for lines starting with ???\"));\nEXTERN char e_cannot_preserve_there_is_no_swap_file[]\n\tINIT(= N_(\"E313: Cannot preserve, there is no swap file\"));\nEXTERN char e_preserve_failed[]\n\tINIT(= N_(\"E314: Preserve failed\"));\nEXTERN char e_ml_get_invalid_lnum_nr[]\n\tINIT(= N_(\"E315: ml_get: Invalid lnum: %ld\"));\nEXTERN char e_ml_get_cannot_find_line_nr_in_buffer_nr_str[]\n\tINIT(= N_(\"E316: ml_get: Cannot find line %ld in buffer %d %s\"));\nEXTERN char e_pointer_block_id_wrong[]\n\tINIT(= N_(\"E317: Pointer block id wrong\"));\nEXTERN char e_pointer_block_id_wrong_two[]\n\tINIT(= N_(\"E317: Pointer block id wrong 2\"));\nEXTERN char e_pointer_block_id_wrong_three[]\n\tINIT(= N_(\"E317: Pointer block id wrong 3\"));\nEXTERN char e_pointer_block_id_wrong_four[]\n\tINIT(= N_(\"E317: Pointer block id wrong 4\"));\nEXTERN char e_updated_too_many_blocks[]\n\tINIT(= N_(\"E318: Updated too many blocks?\"));\nEXTERN char e_sorry_command_is_not_available_in_this_version[]\n\tINIT(= N_(\"E319: Sorry, the command is not available in this version\"));\nEXTERN char e_cannot_find_line_nr[]\n\tINIT(= N_(\"E320: Cannot find line %ld\"));\nEXTERN char e_could_not_reload_str[]\n\tINIT(= N_(\"E321: Could not reload \\\"%s\\\"\"));\nEXTERN char e_line_number_out_of_range_nr_past_the_end[]\n\tINIT(= N_(\"E322: Line number out of range: %ld past the end\"));\nEXTERN char e_line_count_wrong_in_block_nr[]\n\tINIT(= N_(\"E323: Line count wrong in block %ld\"));\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_cant_open_postscript_output_file[]\n\tINIT(= N_(\"E324: Can't open PostScript output file\"));\n#endif\nEXTERN char e_attention[]\n\tINIT(= N_(\"E325: ATTENTION\"));\nEXTERN char e_too_many_swap_files_found[]\n\tINIT(= N_(\"E326: Too many swap files found\"));\n#ifdef FEAT_MENU\nEXTERN char_u e_part_of_menu_item_path_is_not_sub_menu[]\n\tINIT(= N_(\"E327: Part of menu-item path is not sub-menu\"));\nEXTERN char e_menu_only_exists_in_another_mode[]\n\tINIT(= N_(\"E328: Menu only exists in another mode\"));\nEXTERN char_u e_no_menu_str[]\n\tINIT(= N_(\"E329: No menu \\\"%s\\\"\"));\nEXTERN char e_menu_path_must_not_lead_to_sub_menu[]\n\tINIT(= N_(\"E330: Menu path must not lead to a sub-menu\"));\nEXTERN char e_must_not_add_menu_items_directly_to_menu_bar[]\n\tINIT(= N_(\"E331: Must not add menu items directly to menu bar\"));\nEXTERN char e_separator_cannot_be_part_of_menu_path[]\n\tINIT(= N_(\"E332: Separator cannot be part of a menu path\"));\nEXTERN char e_menu_path_must_lead_to_menu_item[]\n\tINIT(= N_(\"E333: Menu path must lead to a menu item\"));\nEXTERN char e_menu_not_found_str[]\n\tINIT(= N_(\"E334: Menu not found: %s\"));\nEXTERN char e_menu_not_defined_for_str_mode[]\n\tINIT(= N_(\"E335: Menu not defined for %s mode\"));\nEXTERN char e_menu_path_must_lead_to_sub_menu[]\n\tINIT(= N_(\"E336: Menu path must lead to a sub-menu\"));\nEXTERN char e_menu_not_found_check_menu_names[]\n\tINIT(= N_(\"E337: Menu not found - check menu names\"));\n#endif\n#ifdef FEAT_BROWSE\nEXTERN char e_sorry_no_file_browser_in_console_mode[]\n\tINIT(= N_(\"E338: Sorry, no file browser in console mode\"));\n#endif\nEXTERN char e_pattern_too_long[]\n\tINIT(= N_(\"E339: Pattern too long\"));\n// E340 unused\nEXTERN char e_internal_error_lalloc_zero[]\n\tINIT(= N_(\"E341: Internal error: lalloc(0, )\"));\nEXTERN char e_out_of_memory_allocating_nr_bytes[]\n\tINIT(= N_(\"E342: Out of memory!  (allocating %lu bytes)\"));\nEXTERN char e_invalid_path_number_must_be_at_end_of_path_or_be_followed_by_str[]\n\tINIT(= N_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"));\nEXTERN char e_cant_find_directory_str_in_cdpath[]\n\tINIT(= N_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"));\nEXTERN char e_cant_find_file_str_in_path[]\n\tINIT(= N_(\"E345: Can't find file \\\"%s\\\" in path\"));\nEXTERN char e_no_more_directory_str_found_in_cdpath[]\n\tINIT(= N_(\"E346: No more directory \\\"%s\\\" found in cdpath\"));\nEXTERN char e_no_more_file_str_found_in_path[]\n\tINIT(= N_(\"E347: No more file \\\"%s\\\" found in path\"));\nEXTERN char e_no_string_under_cursor[]\n\tINIT(= N_(\"E348: No string under cursor\"));\nEXTERN char e_no_identifier_under_cursor[]\n\tINIT(= N_(\"E349: No identifier under cursor\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_cannot_create_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E350: Cannot create fold with current 'foldmethod'\"));\nEXTERN char e_cannot_delete_fold_with_current_foldmethod[]\n\tINIT(= N_(\"E351: Cannot delete fold with current 'foldmethod'\"));\nEXTERN char e_cannot_erase_folds_with_current_foldmethod[]\n\tINIT(= N_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n#endif\nEXTERN char e_nothing_in_register_str[]\n\tINIT(= N_(\"E353: Nothing in register %s\"));\nEXTERN char e_invalid_register_name_str[]\n\tINIT(= N_(\"E354: Invalid register name: '%s'\"));\nEXTERN char e_unknown_option_str_2[]\n\tINIT(= N_(\"E355: Unknown option: %s\"));\nEXTERN char e_get_varp_error[]\n\tINIT(= N_(\"E356: get_varp ERROR\"));\n#ifdef FEAT_LANGMAP\nEXTERN char e_langmap_matching_character_missing_for_str[]\n\tINIT(= N_(\"E357: 'langmap': Matching character missing for %s\"));\nEXTERN char e_langmap_extra_characters_after_semicolon_str[]\n\tINIT(= N_(\"E358: 'langmap': Extra characters after semicolon: %s\"));\n#endif\n#if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \\\n\t|| defined(UNIX) || defined(VMS)\nEXTERN char e_screen_mode_setting_not_supported[]\n\tINIT(= N_(\"E359: Screen mode setting not supported\"));\n#endif\n#ifdef AMIGA\nEXTERN char e_cannot_execute_shell_with_f_option[]\n\tINIT(= N_(\"E360: Cannot execute shell with -f option\"));\n#endif\n// E361 unused\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_using_boolean_value_as_float[]\n\tINIT(= N_(\"E362: Using a boolean value as a Float\"));\n#endif\nEXTERN char e_pattern_uses_more_memory_than_maxmempattern[]\n\tINIT(= N_(\"E363: Pattern uses more memory than 'maxmempattern'\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_library_call_failed_for_str[]\n\tINIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_failed_to_print_postscript_file[]\n\tINIT(= N_(\"E365: Failed to print PostScript file\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_not_allowed_to_enter_popup_window[]\n\tINIT(= N_(\"E366: Not allowed to enter a popup window\"));\n#endif\nEXTERN char e_no_such_group_str[]\n\tINIT(= N_(\"E367: No such group: \\\"%s\\\"\"));\n#ifdef FEAT_LIBCALL\nEXTERN char e_got_sig_str_in_libcall[]\n\tINIT(= N_(\"E368: Got SIG%s in libcall()\"));\n#endif\nEXTERN char e_invalid_item_in_str_brackets[]\n\tINIT(= N_(\"E369: Invalid item in %s%%[]\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_str_str[]\n\tINIT(= N_(\"E370: Could not load library %s: %s\"));\n#endif\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_command_not_found[]\n\tINIT(= N_(\"E371: Command not found\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_too_many_chr_in_format_string[]\n\tINIT(= N_(\"E372: Too many %%%c in format string\"));\nEXTERN char e_unexpected_chr_in_format_str[]\n\tINIT(= N_(\"E373: Unexpected %%%c in format string\"));\nEXTERN char e_missing_rsb_in_format_string[]\n\tINIT(= N_(\"E374: Missing ] in format string\"));\nEXTERN char e_unsupported_chr_in_format_string[]\n\tINIT(= N_(\"E375: Unsupported %%%c in format string\"));\nEXTERN char e_invalid_chr_in_format_string_prefix[]\n\tINIT(= N_(\"E376: Invalid %%%c in format string prefix\"));\nEXTERN char e_invalid_chr_in_format_string[]\n\tINIT(= N_(\"E377: Invalid %%%c in format string\"));\nEXTERN char e_errorformat_contains_no_pattern[]\n\tINIT(= N_(\"E378: 'errorformat' contains no pattern\"));\nEXTERN char e_missing_or_empty_directory_name[]\n\tINIT(= N_(\"E379: Missing or empty directory name\"));\nEXTERN char e_at_bottom_of_quickfix_stack[]\n\tINIT(= N_(\"E380: At bottom of quickfix stack\"));\nEXTERN char e_at_top_of_quickfix_stack[]\n\tINIT(= N_(\"E381: At top of quickfix stack\"));\n#endif\nEXTERN char e_cannot_write_buftype_option_is_set[]\n\tINIT(= N_(\"E382: Cannot write, 'buftype' option is set\"));\nEXTERN char e_invalid_search_string_str[]\n\tINIT(= N_(\"E383: Invalid search string: %s\"));\nEXTERN char e_search_hit_top_without_match_for_str[]\n\tINIT(= N_(\"E384: Search hit TOP without match for: %s\"));\nEXTERN char e_search_hit_bottom_without_match_for_str[]\n\tINIT(= N_(\"E385: Search hit BOTTOM without match for: %s\"));\nEXTERN char e_expected_question_or_slash_after_semicolon[]\n\tINIT(= N_(\"E386: Expected '?' or '/'  after ';'\"));\n#ifdef FEAT_FIND_ID\nEXTERN char e_match_is_on_current_line[]\n\tINIT(= N_(\"E387: Match is on current line\"));\nEXTERN char e_couldnt_find_definition[]\n\tINIT(= N_(\"E388: Couldn't find definition\"));\nEXTERN char e_couldnt_find_pattern[]\n\tINIT(= N_(\"E389: Couldn't find pattern\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_illegal_argument_str_2[]\n\tINIT(= N_(\"E390: Illegal argument: %s\"));\nEXTERN char e_no_such_syntax_cluster_1[]\n\tINIT(= N_(\"E391: No such syntax cluster: %s\"));\nEXTERN char e_no_such_syntax_cluster_2[]\n\tINIT(= N_(\"E392: No such syntax cluster: %s\"));\nEXTERN char e_groupthere_not_accepted_here[]\n\tINIT(= N_(\"E393: group[t]here not accepted here\"));\nEXTERN char e_didnt_find_region_item_for_str[]\n\tINIT(= N_(\"E394: Didn't find region item for %s\"));\nEXTERN char e_contains_argument_not_accepted_here[]\n\tINIT(= N_(\"E395: Contains argument not accepted here\"));\n// E396 unused\nEXTERN char e_filename_required[]\n\tINIT(= N_(\"E397: Filename required\"));\nEXTERN char e_missing_equal_str[]\n\tINIT(= N_(\"E398: Missing '=': %s\"));\nEXTERN char e_not_enough_arguments_syntax_region_str[]\n\tINIT(= N_(\"E399: Not enough arguments: syntax region %s\"));\nEXTERN char e_no_cluster_specified[]\n\tINIT(= N_(\"E400: No cluster specified\"));\nEXTERN char e_pattern_delimiter_not_found_str[]\n\tINIT(= N_(\"E401: Pattern delimiter not found: %s\"));\nEXTERN char e_garbage_after_pattern_str[]\n\tINIT(= N_(\"E402: Garbage after pattern: %s\"));\nEXTERN char e_syntax_sync_line_continuations_pattern_specified_twice[]\n\tINIT(= N_(\"E403: syntax sync: Line continuations pattern specified twice\"));\nEXTERN char e_illegal_arguments_str[]\n\tINIT(= N_(\"E404: Illegal arguments: %s\"));\nEXTERN char e_missing_equal_sign_str[]\n\tINIT(= N_(\"E405: Missing equal sign: %s\"));\nEXTERN char e_empty_argument_str[]\n\tINIT(= N_(\"E406: Empty argument: %s\"));\nEXTERN char e_str_not_allowed_here[]\n\tINIT(= N_(\"E407: %s not allowed here\"));\nEXTERN char e_str_must_be_first_in_contains_list[]\n\tINIT(= N_(\"E408: %s must be first in contains list\"));\nEXTERN char e_unknown_group_name_str[]\n\tINIT(= N_(\"E409: Unknown group name: %s\"));\nEXTERN char e_invalid_syntax_subcommand_str[]\n\tINIT(= N_(\"E410: Invalid :syntax subcommand: %s\"));\n#endif\nEXTERN char e_highlight_group_name_not_found_str[]\n\tINIT(= N_(\"E411: Highlight group not found: %s\"));\nEXTERN char e_not_enough_arguments_highlight_link_str[]\n\tINIT(= N_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_too_many_arguments_highlight_link_str[]\n\tINIT(= N_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"));\nEXTERN char e_group_has_settings_highlight_link_ignored[]\n\tINIT(= N_(\"E414: Group has settings, highlight link ignored\"));\nEXTERN char e_unexpected_equal_sign_str[]\n\tINIT(= N_(\"E415: Unexpected equal sign: %s\"));\nEXTERN char e_missing_equal_sign_str_2[]\n\tINIT(= N_(\"E416: Missing equal sign: %s\"));\nEXTERN char e_missing_argument_str[]\n\tINIT(= N_(\"E417: Missing argument: %s\"));\nEXTERN char e_illegal_value_str[]\n\tINIT(= N_(\"E418: Illegal value: %s\"));\nEXTERN char e_fg_color_unknown[]\n\tINIT(= N_(\"E419: FG color unknown\"));\nEXTERN char e_bg_color_unknown[]\n\tINIT(= N_(\"E420: BG color unknown\"));\nEXTERN char e_color_name_or_number_not_recognized[]\n\tINIT(= N_(\"E421: Color name or number not recognized: %s\"));\nEXTERN char e_terminal_code_too_long_str[]\n\tINIT(= N_(\"E422: Terminal code too long: %s\"));\nEXTERN char e_illegal_argument_str_3[]\n\tINIT(= N_(\"E423: Illegal argument: %s\"));\nEXTERN char e_too_many_different_highlighting_attributes_in_use[]\n\tINIT(= N_(\"E424: Too many different highlighting attributes in use\"));\nEXTERN char e_cannot_go_before_first_matching_tag[]\n\tINIT(= N_(\"E425: Cannot go before first matching tag\"));\nEXTERN char e_tag_not_found_str[]\n\tINIT(= N_(\"E426: Tag not found: %s\"));\nEXTERN char e_there_is_only_one_matching_tag[]\n\tINIT(= N_(\"E427: There is only one matching tag\"));\nEXTERN char e_cannot_go_beyond_last_matching_tag[]\n\tINIT(= N_(\"E428: Cannot go beyond last matching tag\"));\nEXTERN char e_file_str_does_not_exist[]\n\tINIT(= N_(\"E429: File \\\"%s\\\" does not exist\"));\n#ifdef FEAT_EMACS_TAGS\nEXTERN char e_tag_file_path_truncated_for_str[]\n\tINIT(= N_(\"E430: Tag file path truncated for %s\\n\"));\n#endif\nEXTERN char e_format_error_in_tags_file_str[]\n\tINIT(= N_(\"E431: Format error in tags file \\\"%s\\\"\"));\nEXTERN char e_tags_file_not_sorted_str[]\n\tINIT(= N_(\"E432: Tags file not sorted: %s\"));\nEXTERN char e_no_tags_file[]\n\tINIT(= N_(\"E433: No tags file\"));\nEXTERN char e_canot_find_tag_pattern[]\n\tINIT(= N_(\"E434: Can't find tag pattern\"));\nEXTERN char e_couldnt_find_tag_just_guessing[]\n\tINIT(= N_(\"E435: Couldn't find tag, just guessing!\"));\nEXTERN char e_no_str_entry_in_termcap[]\n\tINIT(= N_(\"E436: No \\\"%s\\\" entry in termcap\"));\nEXTERN char e_terminal_capability_cm_required[]\n\tINIT(= N_(\"E437: Terminal capability \\\"cm\\\" required\"));\nEXTERN char e_u_undo_line_numbers_wrong[]\n\tINIT(= N_(\"E438: u_undo: Line numbers wrong\"));\nEXTERN char e_undo_list_corrupt[]\n\tINIT(= N_(\"E439: Undo list corrupt\"));\nEXTERN char e_undo_line_missing[]\n\tINIT(= N_(\"E440: Undo line missing\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_there_is_no_preview_window[]\n\tINIT(= N_(\"E441: There is no preview window\"));\n#endif\nEXTERN char e_cant_split_topleft_and_botright_at_the_same_time[]\n\tINIT(= N_(\"E442: Can't split topleft and botright at the same time\"));\nEXTERN char e_cannot_rotate_when_another_window_is_split[]\n\tINIT(= N_(\"E443: Cannot rotate when another window is split\"));\nEXTERN char e_cannot_close_last_window[]\n\tINIT(= N_(\"E444: Cannot close last window\"));\nEXTERN char e_other_window_contains_changes[]\n\tINIT(= N_(\"E445: Other window contains changes\"));\nEXTERN char e_no_file_name_under_cursor[]\n\tINIT(= N_(\"E446: No file name under cursor\"));\nEXTERN char e_cant_find_file_str_in_path_2[]\n\tINIT(= N_(\"E447: Can't find file \\\"%s\\\" in path\"));\n#ifdef USING_LOAD_LIBRARY\nEXTERN char e_could_not_load_library_function_str[]\n\tINIT(= N_(\"E448: Could not load library function %s\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_expression_received[]\n\tINIT(= N_(\"E449: Invalid expression received\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_buffer_number_text_or_list_required[]\n\tINIT(= N_(\"E450: Buffer number, text or a list required\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_expected_right_curly_str[]\n\tINIT(= N_(\"E451: Expected }: %s\"));\nEXTERN char e_double_semicolon_in_list_of_variables[]\n\tINIT(= N_(\"E452: Double ; in list of variables\"));\n#endif\nEXTERN char e_ul_color_unknown[]\n\tINIT(= N_(\"E453: UL color unknown\"));\n#ifdef FEAT_EVAL\nEXTERN char e_function_list_was_modified[]\n\tINIT(= N_(\"E454: Function list was modified\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_error_writing_to_postscript_output_file[]\n\tINIT(= N_(\"E455: Error writing to PostScript output file\"));\nEXTERN char e_cant_open_file_str_2[]\n\tINIT(= N_(\"E456: Can't open file \\\"%s\\\"\"));\nEXTERN char e_cant_find_postscript_resource_file_str_ps[]\n\tINIT(= N_(\"E456: Can't find PostScript resource file \\\"%s.ps\\\"\"));\nEXTERN char e_cant_read_postscript_resource_file_str[]\n\tINIT(= N_(\"E457: Can't read PostScript resource file \\\"%s\\\"\"));\n#endif\n#ifdef FEAT_GUI_X11\nEXTERN char e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect[]\n\tINIT(= N_(\"E458: Cannot allocate colormap entry, some colors may be incorrect\"));\n#endif\n#if defined(UNIX) || defined(FEAT_SESSION)\nEXTERN char e_cannot_go_back_to_previous_directory[]\n\tINIT(= N_(\"E459: Cannot go back to previous directory\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_entries_missing_in_mapset_dict_argument[]\n\tINIT(= N_(\"E460: Entries missing in mapset() dict argument\"));\nEXTERN char e_illegal_variable_name_str[]\n\tINIT(= N_(\"E461: Illegal variable name: %s\"));\n#endif\nEXTERN char e_could_not_prepare_for_reloading_str[]\n\tINIT(= N_(\"E462: Could not prepare for reloading \\\"%s\\\"\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_region_is_guarded_cannot_modify[]\n\tINIT(= N_(\"E463: Region is guarded, cannot modify\"));\n#endif\nEXTERN char e_ambiguous_use_of_user_defined_command[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_ambiguous_use_of_user_defined_command_str[]\n\tINIT(= N_(\"E464: Ambiguous use of user-defined command: %s\"));\n#endif\nEXTERN char e_winsize_requires_two_number_arguments[]\n\tINIT(= N_(\"E465: :winsize requires two number arguments\"));\nEXTERN char e_winpos_requires_two_number_arguments[]\n\tINIT(= N_(\"E466: :winpos requires two number arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_custom_completion_requires_function_argument[]\n\tINIT(= N_(\"E467: Custom completion requires a function argument\"));\n#endif\nEXTERN char e_completion_argument_only_allowed_for_custom_completion[]\n\tINIT(= N_(\"E468: Completion argument only allowed for custom completion\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_invalid_cscopequickfix_flag_chr_for_chr[]\n\tINIT(= N_(\"E469: Invalid cscopequickfix flag %c for %c\"));\n#endif\nEXTERN char e_command_aborted[]\n\tINIT(= N_(\"E470: Command aborted\"));\nEXTERN char e_argument_required[]\n\tINIT(= N_(\"E471: Argument required\"));\nEXTERN char e_command_failed[]\n\tINIT(= N_(\"E472: Command failed\"));\nEXTERN char e_internal_error_in_regexp[]\n\tINIT(= N_(\"E473: Internal error in regexp\"));\nEXTERN char e_invalid_argument[]\n\tINIT(= N_(\"E474: Invalid argument\"));\nEXTERN char e_invalid_argument_str[]\n\tINIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char e_invalid_value_for_argument_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s\"));\n#if defined(FEAT_JOB_CHANNEL) || defined(FEAT_PROP_POPUP) || defined(FEAT_EVAL)\nEXTERN char e_invalid_value_for_argument_str_str[]\n\tINIT(= N_(\"E475: Invalid value for argument %s: %s\"));\n#endif\nEXTERN char e_invalid_command[]\n\tINIT(= N_(\"E476: Invalid command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_command_str[]\n\tINIT(= N_(\"E476: Invalid command: %s\"));\n#endif\nEXTERN char e_no_bang_allowed[]\n\tINIT(= N_(\"E477: No ! allowed\"));\nEXTERN char e_dont_panic[]\n\tINIT(= N_(\"E478: Don't panic!\"));\nEXTERN char e_no_match[]\n\tINIT(= N_(\"E479: No match\"));\nEXTERN char e_no_match_str_2[]\n\tINIT(= N_(\"E480: No match: %s\"));\nEXTERN char e_no_range_allowed[]\n\tINIT(= N_(\"E481: No range allowed\"));\nEXTERN char e_cant_create_file_str[]\n\tINIT(= N_(\"E482: Can't create file %s\"));\nEXTERN char e_cant_get_temp_file_name[]\n\tINIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char e_cant_open_file_str[]\n\tINIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char e_cant_read_file_str[]\n\tINIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char e_pattern_not_found[]\n\tINIT(= N_(\"E486: Pattern not found\"));\nEXTERN char e_pattern_not_found_str[]\n\tINIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char e_argument_must_be_positive[]\n\tINIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char e_argument_must_be_positive_str[]\n\tINIT(= N_(\"E487: Argument must be positive: %s\"));\nEXTERN char e_trailing_characters[]\n\tINIT(= N_(\"E488: Trailing characters\"));\nEXTERN char e_trailing_characters_str[]\n\tINIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char e_no_call_stack_to_substitute_for_stack[]\n\tINIT(= N_(\"E489: No call stack to substitute for \\\"<stack>\\\"\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_no_fold_found[]\n\tINIT(= N_(\"E490: No fold found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_json_decode_error_at_str[]\n\tINIT(= N_(\"E491: JSON decode error at '%s'\"));\n#endif\nEXTERN char e_not_an_editor_command[]\n\tINIT(= N_(\"E492: Not an editor command\"));\nEXTERN char e_backwards_range_given[]\n\tINIT(= N_(\"E493: Backwards range given\"));\nEXTERN char e_use_w_or_w_gt_gt[]\n\tINIT(= N_(\"E494: Use w or w>>\"));\nEXTERN char e_no_autocommand_file_name_to_substitute_for_afile[]\n\tINIT(= N_(\"E495: No autocommand file name to substitute for \\\"<afile>\\\"\"));\nEXTERN char e_no_autocommand_buffer_name_to_substitute_for_abuf[]\n\tINIT(= N_(\"E496: No autocommand buffer number to substitute for \\\"<abuf>\\\"\"));\nEXTERN char e_no_autocommand_match_name_to_substitute_for_amatch[]\n\tINIT(= N_(\"E497: No autocommand match name to substitute for \\\"<amatch>\\\"\"));\nEXTERN char e_no_source_file_name_to_substitute_for_sfile[]\n\tINIT(= N_(\"E498: No :source file name to substitute for \\\"<sfile>\\\"\"));\nEXTERN char e_empty_file_name_for_percent_or_hash_only_works_with_ph[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\"));\nEXTERN char e_evaluates_to_an_empty_string[]\n\tINIT(= N_(\"E500: Evaluates to an empty string\"));\nEXTERN char e_at_end_of_file[]\n\tINIT(= N_(\"E501: At end-of-file\"));\n\t// E502\nEXTERN char e_is_a_directory[]\n\tINIT(= N_(\"is a directory\"));\n\t// E503\nEXTERN char e_is_not_file_or_writable_device[]\n\tINIT(= N_(\"is not a file or writable device\"));\nEXTERN char e_str_is_not_file_or_writable_device[]\n\tINIT(= N_(\"E503: \\\"%s\\\" is not a file or writable device\"));\n\t// E504\nEXTERN char e_is_read_only_cannot_override_W_in_cpoptions[]\n\tINIT(= N_(\"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\"));\n\t// E505\nEXTERN char e_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"is read-only (add ! to override)\"));\nEXTERN char e_str_is_read_only_add_bang_to_override[]\n\tINIT(= N_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"));\nEXTERN char e_canot_write_to_backup_file_add_bang_to_override[]\n\tINIT(= N_(\"E506: Can't write to backup file (add ! to override)\"));\nEXTERN char e_close_error_for_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E507: Close error for backup file (add ! to write anyway)\"));\nEXTERN char e_cant_read_file_for_backup_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E508: Can't read file for backup (add ! to write anyway)\"));\nEXTERN char e_cannot_create_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E509: Cannot create backup file (add ! to override)\"));\nEXTERN char e_cant_make_backup_file_add_bang_to_write_anyway[]\n\tINIT(= N_(\"E510: Can't make backup file (add ! to write anyway)\"));\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_already_connected[]\n\tINIT(= N_(\"E511: NetBeans already connected\"));\n#endif\nEXTERN char e_close_failed[]\n\tINIT(= N_(\"E512: Close failed\"));\nEXTERN char e_write_error_conversion_failed_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_conversion_failed_in_line_nr_make_fenc_empty_to_override[]\n\tINIT(= N_(\"E513: Write error, conversion failed in line %ld (make 'fenc' empty to override)\"));\nEXTERN char e_write_error_file_system_full[]\n\tINIT(= N_(\"E514: Write error (file system full?)\"));\nEXTERN char e_no_buffers_were_unloaded[]\n\tINIT(= N_(\"E515: No buffers were unloaded\"));\nEXTERN char e_no_buffers_were_deleted[]\n\tINIT(= N_(\"E516: No buffers were deleted\"));\nEXTERN char e_no_buffers_were_wiped_out[]\n\tINIT(= N_(\"E517: No buffers were wiped out\"));\nEXTERN char e_unknown_option[]\n\tINIT(= N_(\"E518: Unknown option\"));\nEXTERN char e_option_not_supported[]\n\tINIT(= N_(\"E519: Option not supported\"));\nEXTERN char e_not_allowed_in_modeline[]\n\tINIT(= N_(\"E520: Not allowed in a modeline\"));\nEXTERN char e_number_required_after_equal[]\n\tINIT(= N_(\"E521: Number required after =\"));\nEXTERN char e_number_required_after_str_equal_str[]\n\tINIT(= N_(\"E521: Number required: &%s = '%s'\"));\nEXTERN char e_not_found_in_termcap[]\n\tINIT(= N_(\"E522: Not found in termcap\"));\nEXTERN char e_not_allowed_here[]\n\tINIT(= N_(\"E523: Not allowed here\"));\nEXTERN char e_missing_colon[]\n\tINIT(= N_(\"E524: Missing colon\"));\nEXTERN char e_zero_length_string[]\n\tINIT(= N_(\"E525: Zero length string\"));\n#ifdef FEAT_VIMINFO\nEXTERN char e_missing_number_after_angle_str_angle[]\n\tINIT(= N_(\"E526: Missing number after <%s>\"));\nEXTERN char e_missing_comma[]\n\tINIT(= N_(\"E527: Missing comma\"));\nEXTERN char e_must_specify_a_value[]\n\tINIT(= N_(\"E528: Must specify a ' value\"));\n#endif\nEXTERN char e_cannot_set_term_to_empty_string[]\n\tINIT(= N_(\"E529: Cannot set 'term' to empty string\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_change_term_in_GUI[]\n\tINIT(= N_(\"E530: Cannot change 'term' in the GUI\"));\nEXTERN char e_use_gui_to_start_GUI[]\n\tINIT(= N_(\"E531: Use \\\":gui\\\" to start the GUI\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_highlighting_color_name_too_long_in_defineAnnoType[]\n\tINIT(= N_(\"E532: Highlighting color name too long in defineAnnoType\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_cant_select_wide_font[]\n\tINIT(= N_(\"E533: Can't select wide font\"));\nEXTERN char e_invalid_wide_font[]\n\tINIT(= N_(\"E534: Invalid wide font\"));\n#endif\nEXTERN char e_illegal_character_after_chr[]\n\tINIT(= N_(\"E535: Illegal character after <%c>\"));\n#ifdef FEAT_FOLDING\nEXTERN char e_comma_required[]\n\tINIT(= N_(\"E536: Comma required\"));\nEXTERN char e_commentstring_must_be_empty_or_contain_str[]\n\tINIT(= N_(\"E537: 'commentstring' must be empty or contain %s\"));\n#endif\nEXTERN char e_pattern_found_in_every_line_str[]\n\tINIT(= N_(\"E538: Pattern found in every line: %s\"));\nEXTERN char e_illegal_character_str[]\n\tINIT(= N_(\"E539: Illegal character <%s>\"));\n#ifdef FEAT_STL_OPT\nEXTERN char e_unclosed_expression_sequence[]\n\tINIT(= N_(\"E540: Unclosed expression sequence\"));\n// E541 unused\nEXTERN char e_unbalanced_groups[]\n\tINIT(= N_(\"E542: Unbalanced groups\"));\n#endif\n#ifdef MSWIN\nEXTERN char e_not_valid_codepage[]\n\tINIT(= N_(\"E543: Not a valid codepage\"));\n#endif\n#ifdef FEAT_KEYMAP\nEXTERN char e_keymap_file_not_found[]\n\tINIT(= N_(\"E544: Keymap file not found\"));\n#endif\n#ifdef CURSOR_SHAPE\nEXTERN char e_missing_colon_2[]\n\tINIT(= N_(\"E545: Missing colon\"));\nEXTERN char e_illegal_mode[]\n\tINIT(= N_(\"E546: Illegal mode\"));\n#endif\n#ifdef FEAT_MOUSESHAPE\nEXTERN char e_illegal_mouseshape[]\n\tINIT(= N_(\"E547: Illegal mouseshape\"));\n#endif\nEXTERN char e_digit_expected[]\n\tINIT(= N_(\"E548: Digit expected\"));\nEXTERN char e_illegal_percentage[]\n\tINIT(= N_(\"E549: Illegal percentage\"));\n#ifdef FEAT_PRINTER\nEXTERN char e_missing_colon_3[]\n\tINIT(= N_(\"E550: Missing colon\"));\nEXTERN char e_illegal_component[]\n\tINIT(= N_(\"E551: Illegal component\"));\nEXTERN char e_digit_expected_2[]\n\tINIT(= N_(\"E552: Digit expected\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_more_items[]\n\tINIT(= N_(\"E553: No more items\"));\n#endif\nEXTERN char e_syntax_error_in_str_curlies[]\n\tINIT(= N_(\"E554: Syntax error in %s{...}\"));\nEXTERN char e_at_bottom_of_tag_stack[]\n\tINIT(= N_(\"E555: At bottom of tag stack\"));\nEXTERN char e_at_top_of_tag_stack[]\n\tINIT(= N_(\"E556: At top of tag stack\"));\nEXTERN char e_cannot_open_termcap_file[]\n\tINIT(= N_(\"E557: Cannot open termcap file\"));\nEXTERN char e_terminal_entry_not_found_in_terminfo[]\n\tINIT(= N_(\"E558: Terminal entry not found in terminfo\"));\n#if defined(HAVE_TGETENT) && !defined(TERMINFO)\nEXTERN char e_terminal_entry_not_found_in_termcap[]\n\tINIT(= N_(\"E559: Terminal entry not found in termcap\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_usage_cscope_str[]\n\tINIT(= N_(\"E560: Usage: cs[cope] %s\"));\nEXTERN char e_unknown_cscope_search_type[]\n\tINIT(= N_(\"E561: Unknown cscope search type\"));\nEXTERN char e_usage_cstag_ident[]\n\tINIT(= N_(\"E562: Usage: cstag <ident>\"));\nEXTERN char e_stat_str_error_nr[]\n\tINIT(= N_(\"E563: stat(%s) error: %d\"));\nEXTERN char e_str_is_not_directory_or_valid_cscope_database[]\n\tINIT(= N_(\"E564: %s is not a directory or a valid cscope database\"));\n#endif\nEXTERN char e_not_allowed_to_change_text_or_change_window[]\n\tINIT(= N_(\"E565: Not allowed to change text or change window\"));\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_create_cscope_pipes[]\n\tINIT(= N_(\"E566: Could not create cscope pipes\"));\nEXTERN char e_no_cscope_connections[]\n\tINIT(= N_(\"E567: No cscope connections\"));\nEXTERN char e_duplicate_cscope_database_not_added[]\n\tINIT(= N_(\"E568: Duplicate cscope database not added\"));\n// E569 unused\nEXTERN char e_fatal_error_in_cs_manage_matches[]\n\tINIT(= N_(\"E570: Fatal error in cs_manage_matches\"));\n#endif\n#ifdef DYNAMIC_TCL\nEXTERN char e_sorry_this_command_is_disabled_tcl_library_could_not_be_loaded[]\n\tINIT(= N_(\"E571: Sorry, this command is disabled: the Tcl library could not be loaded.\"));\n#endif\n#ifdef FEAT_TCL\nEXTERN char e_exit_code_nr[]\n\tINIT(= N_(\"E572: Exit code %d\"));\n#endif\n#ifdef FEAT_CLIENTSERVER\nEXTERN char e_invalid_server_id_used_str[]\n\tINIT(= N_(\"E573: Invalid server id used: %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_unknown_register_type_nr[]\n\tINIT(= N_(\"E574: Unknown register type %d\"));\n\t// E575\nEXTERN char e_illegal_starting_char[]\n\tINIT(= N_(\"Illegal starting char\"));\n\t// E576\nEXTERN char e_nonr_missing_gt[]\n\tINIT(= N_(\"Missing '>'\"));\n\t// E577\nEXTERN char e_illegal_register_name[]\n\tINIT(= N_(\"Illegal register name\"));\n#endif\n// E578 unused\n#ifdef FEAT_EVAL\nEXTERN char e_if_nesting_too_deep[]\n\tINIT(= N_(\"E579: :if nesting too deep\"));\nEXTERN char e_block_nesting_too_deep[]\n\tINIT(= N_(\"E579: Block nesting too deep\"));\nEXTERN char e_endif_without_if[]\n\tINIT(= N_(\"E580: :endif without :if\"));\nEXTERN char e_else_without_if[]\n\tINIT(= N_(\"E581: :else without :if\"));\nEXTERN char e_elseif_without_if[]\n\tINIT(= N_(\"E582: :elseif without :if\"));\nEXTERN char e_multiple_else[]\n\tINIT(= N_(\"E583: Multiple :else\"));\nEXTERN char e_elseif_after_else[]\n\tINIT(= N_(\"E584: :elseif after :else\"));\nEXTERN char e_while_for_nesting_too_deep[]\n\tINIT(= N_(\"E585: :while/:for nesting too deep\"));\nEXTERN char e_continue_without_while_or_for[]\n\tINIT(= N_(\"E586: :continue without :while or :for\"));\nEXTERN char e_break_without_while_or_for[]\n\tINIT(= N_(\"E587: :break without :while or :for\"));\nEXTERN char e_endwhile_without_while[]\n\tINIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char e_endfor_without_for[]\n\tINIT(= N_(\"E588: :endfor without :for\"));\n#endif\nEXTERN char e_backupext_and_patchmode_are_equal[]\n\tINIT(= N_(\"E589: 'backupext' and 'patchmode' are equal\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_preview_window_already_exists[]\n\tINIT(= N_(\"E590: A preview window already exists\"));\n#endif\nEXTERN char e_winheight_cannot_be_smaller_than_winminheight[]\n\tINIT(= N_(\"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char e_winwidth_cannot_be_smaller_than_winminwidth[]\n\tINIT(= N_(\"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char e_need_at_least_nr_lines[]\n\tINIT(= N_(\"E593: Need at least %d lines\"));\nEXTERN char e_need_at_least_nr_columns[]\n\tINIT(= N_(\"E594: Need at least %d columns\"));\n#ifdef FEAT_LINEBREAK\nEXTERN char e_showbreak_contains_unprintable_or_wide_character[]\n\tINIT(= N_(\"E595: 'showbreak' contains unprintable or wide character\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_invalid_fonts[]\n\tINIT(= N_(\"E596: Invalid font(s)\"));\n# ifdef FEAT_XFONTSET\nEXTERN char e_cant_select_fontset[]\n\tINIT(= N_(\"E597: Can't select fontset\"));\nEXTERN char e_invalid_fontset[]\n\tINIT(= N_(\"E598: Invalid fontset\"));\n# endif\n#endif\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\nEXTERN char e_value_of_imactivatekey_is_invalid[]\n\tINIT(= N_(\"E599: Value of 'imactivatekey' is invalid\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_missing_endtry[]\n\tINIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char e_try_nesting_too_deep[]\n\tINIT(= N_(\"E601: :try nesting too deep\"));\nEXTERN char e_endtry_without_try[]\n\tINIT(= N_(\"E602: :endtry without :try\"));\nEXTERN char e_catch_without_try[]\n\tINIT(= N_(\"E603: :catch without :try\"));\nEXTERN char e_catch_after_finally[]\n\tINIT(= N_(\"E604: :catch after :finally\"));\nEXTERN char e_exception_not_caught_str[]\n\tINIT(= N_(\"E605: Exception not caught: %s\"));\nEXTERN char e_finally_without_try[]\n\tINIT(= N_(\"E606: :finally without :try\"));\nEXTERN char e_multiple_finally[]\n\tINIT(= N_(\"E607: Multiple :finally\"));\nEXTERN char e_cannot_throw_exceptions_with_vim_prefix[]\n\tINIT(= N_(\"E608: Cannot :throw exceptions with 'Vim' prefix\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_cscope_error_str[]\n\tINIT(= N_(\"E609: Cscope error: %s\"));\n#endif\nEXTERN char e_no_argument_to_delete[]\n\tINIT(= N_(\"E610: No argument to delete\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_special_as_number[]\n\tINIT(= N_(\"E611: Using a Special as a Number\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_too_many_signs_defined[]\n\tINIT(= N_(\"E612: Too many signs defined\"));\n#endif\n#if defined(MSWIN) && defined(FEAT_PRINTER)\nEXTERN char e_unknown_printer_font_str[]\n\tINIT(= N_(\"E613: Unknown printer font: %s\"));\n#endif\n// E614 unused\n// E615 unused\n// E616 unused\n#ifdef FEAT_GUI_GTK\nEXTERN char e_cannot_be_changed_in_gtk_GUI[]\n\tINIT(= N_(\"E617: Cannot be changed in the GTK GUI\"));\n#endif\n#ifdef FEAT_POSTSCRIPT\nEXTERN char e_file_str_is_not_postscript_resource_file[]\n\tINIT(= N_(\"E618: File \\\"%s\\\" is not a PostScript resource file\"));\nEXTERN char e_file_str_is_not_supported_postscript_resource_file[]\n\tINIT(= N_(\"E619: File \\\"%s\\\" is not a supported PostScript resource file\"));\nEXTERN char e_unable_to_convert_to_print_encoding_str[]\n\tINIT(= N_(\"E620: Unable to convert to print encoding \\\"%s\\\"\"));\nEXTERN char e_str_resource_file_has_wrong_version[]\n\tINIT(= N_(\"E621: \\\"%s\\\" resource file has wrong version\"));\n#endif\n#ifdef FEAT_CSCOPE\nEXTERN char e_could_not_fork_for_cscope[]\n\tINIT(= N_(\"E622: Could not fork for cscope\"));\n# ifndef UNIX\nEXTERN char e_could_not_spawn_cscope_process[]\n\tINIT(= N_(\"E623: Could not spawn cscope process\"));\n# endif\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_cant_open_file_str_3[]\n\tINIT(= N_(\"E624: Can't open file \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_CSCOPE) && !defined(UNIX)\nEXTERN char e_cannot_open_cscope_database_str[]\n\tINIT(= N_(\"E625: Cannot open cscope database: %s\"));\nEXTERN char e_cannot_get_cscope_database_information[]\n\tINIT(= N_(\"E626: Cannot get cscope database information\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_missing_colon_str[]\n\tINIT(= \"E627: Missing colon: %s\");\nEXTERN char e_missing_bang_or_slash_in_str[]\n\tINIT(= \"E628: Missing ! or / in: %s\");\n#ifdef NBDEBUG\nEXTERN char e_bad_return_from_nb_do_cmd[]\n\tINIT(= \"E629: Bad return from nb_do_cmd\");\n#endif\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_str_write_while_not_connected[]\n\tINIT(= N_(\"E630: %s(): Write while not connected\"));\nEXTERN char e_str_write_failed[]\n\tINIT(= N_(\"E631: %s(): Write failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_invalid_buffer_identifier_in_getlength[]\n\tINIT(= \"E632: Invalid buffer identifier in getLength\");\nEXTERN char e_invalid_buffer_identifier_in_gettext[]\n\tINIT(= \"E633: Invalid buffer identifier in getText\");\nEXTERN char e_invalid_buffer_identifier_in_remove[]\n\tINIT(= \"E634: Invalid buffer identifier in remove\");\nEXTERN char e_invalid_buffer_identifier_in_insert[]\n\tINIT(= \"E635: Invalid buffer identifier in insert\");\nEXTERN char e_invalid_buffer_identifier_in_create[]\n\tINIT(= \"E636: Invalid buffer identifier in create\");\nEXTERN char e_invalid_buffer_identifier_in_startdocumentlisten[]\n\tINIT(= \"E637: Invalid buffer identifier in startDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_stopdocumentlisten[]\n\tINIT(= \"E638: Invalid buffer identifier in stopDocumentListen\");\nEXTERN char e_invalid_buffer_identifier_in_settitle[]\n\tINIT(= \"E639: Invalid buffer identifier in setTitle\");\nEXTERN char e_invalid_buffer_identifier_in_initdone[]\n\tINIT(= \"E640: Invalid buffer identifier in initDone\");\nEXTERN char e_invalid_buffer_identifier_in_setbuffernumber[]\n\tINIT(= \"E641: Invalid buffer identifier in setBufferNumber\");\nEXTERN char e_file_str_not_found_in_setbuffernumber[]\n\tINIT(= \"E642: File %s not found in setBufferNumber\");\nEXTERN char e_invalid_buffer_identifier_in_setfullname[]\n\tINIT(= \"E643: Invalid buffer identifier in setFullName\");\nEXTERN char e_invalid_buffer_identifier_in_editfile[]\n\tINIT(= \"E644: Invalid buffer identifier in editFile\");\nEXTERN char e_invalid_buffer_identifier_in_setvisible[]\n\tINIT(= \"E645: Invalid buffer identifier in setVisible\");\nEXTERN char e_invalid_buffer_identifier_in_setmodified[]\n\tINIT(= \"E646: Invalid buffer identifier in setModified\");\nEXTERN char e_invalid_buffer_identifier_in_setdot[]\n\tINIT(= \"E647: Invalid buffer identifier in setDot\");\nEXTERN char e_invalid_buffer_identifier_in_close[]\n\tINIT(= \"E648: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_close_2[]\n\tINIT(= \"E649: Invalid buffer identifier in close\");\nEXTERN char e_invalid_buffer_identifier_in_defineannotype[]\n\tINIT(= \"E650: Invalid buffer identifier in defineAnnoType\");\nEXTERN char e_invalid_buffer_identifier_in_addanno[]\n\tINIT(= \"E651: Invalid buffer identifier in addAnno\");\nEXTERN char e_invalid_buffer_identifier_in_getanno[]\n\tINIT(= \"E652: Invalid buffer identifier in getAnno\");\n#endif\n// E653 unused\nEXTERN char e_missing_delimiter_after_search_pattern_str[]\n\tINIT(= N_(\"E654: Missing delimiter after search pattern: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_too_many_symbolic_links_cycle[]\n\tINIT(= N_(\"E655: Too many symbolic links (cycle?)\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t// E656\nEXTERN char e_netbeans_disallows_writes_of_unmodified_buffers[]\n\tINIT(= N_(\"NetBeans disallows writes of unmodified buffers\"));\n\t// E657\nEXTERN char e_partial_writes_disallowed_for_netbeans_buffers[]\n\tINIT(= N_(\"Partial writes disallowed for NetBeans buffers\"));\nEXTERN char e_netbeans_connection_lost_for_buffer_nr[]\n\tINIT(= N_(\"E658: NetBeans connection lost for buffer %d\"));\n#endif\n#ifdef FEAT_PYTHON\nEXTERN char e_cannot_invoke_python_recursively[]\n\tINIT(= N_(\"E659: Cannot invoke Python recursively\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_cannot_open_netbeans_connection_info_file[]\n\tINIT(= \"E660: Cannot open NetBeans connection info file\");\n#endif\n#ifdef FEAT_MULTI_LANG\nEXTERN char e_sorry_no_str_help_for_str[]\n\tINIT(= N_(\"E661: Sorry, no '%s' help for %s\"));\n#endif\nEXTERN char e_at_start_of_changelist[]\n\tINIT(= N_(\"E662: At start of changelist\"));\nEXTERN char e_at_end_of_changelist[]\n\tINIT(= N_(\"E663: At end of changelist\"));\nEXTERN char e_changelist_is_empty[]\n\tINIT(= N_(\"E664: Changelist is empty\"));\n#ifdef FEAT_GUI\nEXTERN char e_cannot_start_gui_no_valid_font_found[]\n\tINIT(= N_(\"E665: Cannot start GUI, no valid font found\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_compiler_not_supported_str[]\n\tINIT(= N_(\"E666: Compiler not supported: %s\"));\n#endif\n#ifdef HAVE_FSYNC\nEXTERN char e_fsync_failed[]\n\tINIT(= N_(\"E667: Fsync failed\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_wrong_access_mode_for_netbeans_connection_info_file_str[]\n\tINIT(= N_(\"E668: Wrong access mode for NetBeans connection info file: \\\"%s\\\"\"));\n#endif\nEXTERN char e_unprintable_character_in_group_name[]\n\tINIT(= N_(\"E669: Unprintable character in group name\"));\nEXTERN char e_mix_of_help_file_encodings_within_language_str[]\n\tINIT(= N_(\"E670: Mix of help file encodings within a language: %s\"));\n#ifdef FEAT_GUI_MSWIN\nEXTERN char e_cannot_find_window_title_str[]\n\tINIT(= N_(\"E671: Cannot find window title \\\"%s\\\"\"));\nEXTERN char e_unable_to_open_window_inside_mdi_application[]\n\tINIT(= N_(\"E672: Unable to open window inside MDI application\"));\n#endif\n#if defined(FEAT_PRINTER) && defined(FEAT_POSTSCRIPT)\nEXTERN char e_incompatible_multi_byte_encoding_and_character_set[]\n\tINIT(= N_(\"E673: Incompatible multi-byte encoding and character set\"));\nEXTERN char e_printmbcharset_cannot_be_empty_with_multi_byte_encoding[]\n\tINIT(= N_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));\nEXTERN char e_no_default_font_specified_for_multi_byte_printing[]\n\tINIT(= N_(\"E675: No default font specified for multi-byte printing.\"));\n#endif\nEXTERN char e_no_matching_autocommands_for_acwrite_buffer[]\n\tINIT(= N_(\"E676: No matching autocommands for acwrite buffer\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_writing_temp_file[]\n\tINIT(= N_(\"E677: Error writing temp file\"));\n#endif\nEXTERN char e_invalid_character_after_str_2[]\n\tINIT(= N_(\"E678: Invalid character after %s%%[dxouU]\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_recursive_loop_loading_syncolor_vim[]\n\tINIT(= N_(\"E679: Recursive loop loading syncolor.vim\"));\n#endif\nEXTERN char e_buffer_nr_invalid_buffer_number[]\n\tINIT(= N_(\"E680: <buffer=%d>: invalid buffer number\"));\n#ifdef FEAT_QUICKFIX\nEXTERN char e_buffer_is_not_loaded[]\n\tINIT(= N_(\"E681: Buffer is not loaded\"));\nEXTERN char e_invalid_search_pattern_or_delimiter[]\n\tINIT(= N_(\"E682: Invalid search pattern or delimiter\"));\nEXTERN char e_file_name_missing_or_invalid_pattern[]\n\tINIT(= N_(\"E683: File name missing or invalid pattern\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_list_index_out_of_range_nr[]\n\tINIT(= N_(\"E684: List index out of range: %ld\"));\n#endif\nEXTERN char e_internal_error_str[]\n\tINIT(= N_(\"E685: Internal error: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list[]\n\tINIT(= N_(\"E686: Argument of %s must be a List\"));\nEXTERN char e_less_targets_than_list_items[]\n\tINIT(= N_(\"E687: Less targets than List items\"));\nEXTERN char e_more_targets_than_list_items[]\n\tINIT(= N_(\"E688: More targets than List items\"));\nEXTERN char e_can_only_index_list_dictionary_or_blob[]\n\tINIT(= N_(\"E689: Can only index a List, Dictionary or Blob\"));\nEXTERN char e_missing_in_after_for[]\n\tINIT(= N_(\"E690: Missing \\\"in\\\" after :for\"));\nEXTERN char e_can_only_compare_list_with_list[]\n\tINIT(= N_(\"E691: Can only compare List with List\"));\nEXTERN char e_invalid_operation_for_list[]\n\tINIT(= N_(\"E692: Invalid operation for List\"));\n// E693 unused\nEXTERN char e_invalid_operation_for_funcrefs[]\n\tINIT(= N_(\"E694: Invalid operation for Funcrefs\"));\nEXTERN char e_cannot_index_a_funcref[]\n\tINIT(= N_(\"E695: Cannot index a Funcref\"));\nEXTERN char e_missing_comma_in_list_str[]\n\tINIT(= N_(\"E696: Missing comma in List: %s\"));\nEXTERN char e_missing_end_of_list_rsb_str[]\n\tINIT(= N_(\"E697: Missing end of List ']': %s\"));\nEXTERN char e_variable_nested_too_deep_for_making_copy[]\n\tINIT(= N_(\"E698: Variable nested too deep for making a copy\"));\nEXTERN char e_too_many_arguments[]\n\tINIT(= N_(\"E699: Too many arguments\"));\nEXTERN char e_unknown_function_str_2[]\n\tINIT(= N_(\"E700: Unknown function: %s\"));\nEXTERN char e_invalid_type_for_len[]\n\tINIT(= N_(\"E701: Invalid type for len()\"));\nEXTERN char e_sort_compare_function_failed[]\n\tINIT(= N_(\"E702: Sort compare function failed\"));\nEXTERN char e_using_funcref_as_number[]\n\tINIT(= N_(\"E703: Using a Funcref as a Number\"));\nEXTERN char e_funcref_variable_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E704: Funcref variable name must start with a capital: %s\"));\nEXTERN char e_variable_name_conflicts_with_existing_function_str[]\n\tINIT(= N_(\"E705: Variable name conflicts with existing function: %s\"));\n// E706 unused\nEXTERN char e_function_name_conflicts_with_variable_str[]\n\tINIT(= N_(\"E707: Function name conflicts with variable: %s\"));\nEXTERN char e_slice_must_come_last[]\n\tINIT(= N_(\"E708: [:] must come last\"));\nEXTERN char e_slice_requires_list_or_blob_value[]\n\tINIT(= N_(\"E709: [:] requires a List or Blob value\"));\nEXTERN char e_list_value_has_more_items_than_targets[]\n\tINIT(= N_(\"E710: List value has more items than targets\"));\nEXTERN char e_list_value_does_not_have_enough_items[]\n\tINIT(= N_(\"E711: List value does not have enough items\"));\nEXTERN char e_argument_of_str_must_be_list_or_dictionary[]\n\tINIT(= N_(\"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char e_cannot_use_empty_key_for_dictionary[]\n\tINIT(= N_(\"E713: Cannot use empty key for Dictionary\"));\nEXTERN char e_list_required[]\n\tINIT(= N_(\"E714: List required\"));\nEXTERN char e_dictionary_required[]\n\tINIT(= N_(\"E715: Dictionary required\"));\nEXTERN char e_key_not_present_in_dictionary[]\n\tINIT(= N_(\"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_dictionary_entry_already_exists[]\n\tINIT(= N_(\"E717: Dictionary entry already exists\"));\nEXTERN char e_funcref_required[]\n\tINIT(= N_(\"E718: Funcref required\"));\nEXTERN char e_cannot_slice_dictionary[]\n\tINIT(= N_(\"E719: Cannot slice a Dictionary\"));\nEXTERN char e_missing_colon_in_dictionary[]\n\tINIT(= N_(\"E720: Missing colon in Dictionary: %s\"));\nEXTERN char e_duplicate_key_in_dicitonary[]\n\tINIT(= N_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"));\nEXTERN char e_missing_comma_in_dictionary[]\n\tINIT(= N_(\"E722: Missing comma in Dictionary: %s\"));\nEXTERN char e_missing_dict_end[]\n\tINIT(= N_(\"E723: Missing end of Dictionary '}': %s\"));\nEXTERN char e_variable_nested_too_deep_for_displaying[]\n\tINIT(= N_(\"E724: Variable nested too deep for displaying\"));\nEXTERN char e_calling_dict_function_without_dictionary_str[]\n\tINIT(= N_(\"E725: Calling dict function without Dictionary: %s\"));\nEXTERN char e_stride_is_zero[]\n\tINIT(= N_(\"E726: Stride is zero\"));\nEXTERN char e_start_past_end[]\n\tINIT(= N_(\"E727: Start past end\"));\nEXTERN char e_using_dictionary_as_number[]\n\tINIT(= N_(\"E728: Using a Dictionary as a Number\"));\nEXTERN char e_using_funcref_as_string[]\n\tINIT(= N_(\"E729: Using a Funcref as a String\"));\nEXTERN char e_using_list_as_string[]\n\tINIT(= N_(\"E730: Using a List as a String\"));\nEXTERN char e_using_dictionary_as_string[]\n\tINIT(= N_(\"E731: Using a Dictionary as a String\"));\nEXTERN char e_using_endfor_with_while[]\n\tINIT(= N_(\"E732: Using :endfor with :while\"));\nEXTERN char e_using_endwhile_with_for[]\n\tINIT(= N_(\"E733: Using :endwhile with :for\"));\nEXTERN char e_wrong_variable_type_for_str_equal[]\n\tINIT(= N_(\"E734: Wrong variable type for %s=\"));\nEXTERN char e_can_only_compare_dictionary_with_dictionary[]\n\tINIT(= N_(\"E735: Can only compare Dictionary with Dictionary\"));\nEXTERN char e_invalid_operation_for_dictionary[]\n\tINIT(= N_(\"E736: Invalid operation for Dictionary\"));\nEXTERN char e_key_already_exists_str[]\n\tINIT(= N_(\"E737: Key already exists: %s\"));\nEXTERN char e_cant_list_variables_for_str[]\n\tINIT(= N_(\"E738: Can't list variables for %s\"));\nEXTERN char e_cannot_create_directory_str[]\n\tINIT(= N_(\"E739: Cannot create directory: %s\"));\nEXTERN char e_too_many_arguments_for_function_str_2[]\n\tINIT(= N_(\"E740: Too many arguments for function %s\"));\nEXTERN char e_value_is_locked[]\n\tINIT(= N_(\"E741: Value is locked\"));\nEXTERN char e_value_is_locked_str[]\n\tINIT(= N_(\"E741: Value is locked: %s\"));\nEXTERN char e_cannot_change_value[]\n\tINIT(= N_(\"E742: Cannot change value\"));\nEXTERN char e_cannot_change_value_of_str[]\n\tINIT(= N_(\"E742: Cannot change value of %s\"));\nEXTERN char e_variable_nested_too_deep_for_unlock[]\n\tINIT(= N_(\"E743: Variable nested too deep for (un)lock\"));\n#endif\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char e_netbeans_does_not_allow_changes_in_read_only_files[]\n\tINIT(= N_(\"E744: NetBeans does not allow changes in read-only files\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_list_as_number[]\n\tINIT(= N_(\"E745: Using a List as a Number\"));\nEXTERN char e_function_name_does_not_match_script_file_name_str[]\n\tINIT(= N_(\"E746: Function name does not match script file name: %s\"));\n#endif\nEXTERN char e_cannot_change_directory_buffer_is_modified_add_bang_to_override[]\n\tINIT(= N_(\"E747: Cannot change directory, buffer is modified (add ! to override)\"));\nEXTERN char e_no_previously_used_register[]\n\tINIT(= N_(\"E748: No previously used register\"));\nEXTERN char e_empty_buffer[]\n\tINIT(= N_(\"E749: Empty buffer\"));\n#ifdef FEAT_PROFILE\nEXTERN char e_first_use_profile_start_fname[]\n\tINIT(= N_(\"E750: First use \\\":profile start {fname}\\\"\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_output_file_name_must_not_have_region_name[]\n\tINIT(= N_(\"E751: Output file name must not have region name\"));\nEXTERN char e_no_previous_spell_replacement[]\n\tINIT(= N_(\"E752: No previous spell replacement\"));\nEXTERN char e_not_found_str[]\n\tINIT(= N_(\"E753: Not found: %s\"));\nEXTERN char e_only_up_to_nr_regions_supported[]\n\tINIT(= N_(\"E754: Only up to %d regions supported\"));\nEXTERN char e_invalid_region_in_str[]\n\tINIT(= N_(\"E755: Invalid region in %s\"));\nEXTERN char e_spell_checking_is_not_possible[]\n\tINIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char e_this_does_not_look_like_spell_file[]\n\tINIT(= N_(\"E757: This does not look like a spell file\"));\nEXTERN char e_truncated_spell_file[]\n\tINIT(= N_(\"E758: Truncated spell file\"));\nEXTERN char e_format_error_in_spell_file[]\n\tINIT(= N_(\"E759: Format error in spell file\"));\nEXTERN char e_no_word_count_in_str[]\n\tINIT(= N_(\"E760: No word count in %s\"));\nEXTERN char e_format_error_in_affix_file_fol_low_or_upp[]\n\tINIT(= N_(\"E761: Format error in affix file FOL, LOW or UPP\"));\nEXTERN char e_character_in_fol_low_or_upp_is_out_of_range[]\n\tINIT(= N_(\"E762: Character in FOL, LOW or UPP is out of range\"));\nEXTERN char e_word_characters_differ_between_spell_files[]\n\tINIT(= N_(\"E763: Word characters differ between spell files\"));\n#endif\n#if defined(FEAT_SYN_HL) || defined(FEAT_COMPL_FUNC)\nEXTERN char e_option_str_is_not_set[]\n\tINIT(= N_(\"E764: Option '%s' is not set\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfile_does_not_have_nr_entries[]\n\tINIT(= N_(\"E765: 'spellfile' does not have %d entries\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_insufficient_arguments_for_printf[]\n\tINIT(= N_(\"E766: Insufficient arguments for printf()\"));\n#endif\nEXTERN char e_too_many_arguments_to_printf[]\n\tINIT(= N_(\"E767: Too many arguments for printf()\"));\nEXTERN char e_swap_file_exists_str_silent_overrides[]\n\tINIT(= N_(\"E768: Swap file exists: %s (:silent! overrides)\"));\nEXTERN char e_missing_rsb_after_str_lsb[]\n\tINIT(= N_(\"E769: Missing ] after %s[\"));\n#ifdef FEAT_SPELL\nEXTERN char e_unsupported_section_in_spell_file[]\n\tINIT(= N_(\"E770: Unsupported section in spell file\"));\nEXTERN char e_old_spell_file_needs_to_be_updated[]\n\tINIT(= N_(\"E771: Old spell file, needs to be updated\"));\nEXTERN char e_spell_file_is_for_newer_version_of_vim[]\n\tINIT(= N_(\"E772: Spell file is for newer version of Vim\"));\n#endif\nEXTERN char e_symlink_loop_for_str[]\n\tINIT(= N_(\"E773: Symlink loop for \\\"%s\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_operatorfunc_is_empty[]\n\tINIT(= N_(\"E774: 'operatorfunc' is empty\"));\n#else\nEXTERN char e_eval_feature_not_available[]\n\tINIT(= N_(\"E775: Eval feature not available\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_no_location_list[]\n\tINIT(= N_(\"E776: No location list\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_list_expected[]\n\tINIT(= N_(\"E777: String or List expected\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_this_does_not_look_like_sug_file_str[]\n\tINIT(= N_(\"E778: This does not look like a .sug file: %s\"));\nEXTERN char e_old_sug_file_needs_to_be_updated_str[]\n\tINIT(= N_(\"E779: Old .sug file, needs to be updated: %s\"));\nEXTERN char e_sug_file_is_for_newer_version_of_vim_str[]\n\tINIT(= N_(\"E780: .sug file is for newer version of Vim: %s\"));\nEXTERN char e_sug_file_doesnt_match_spl_file_str[]\n\tINIT(= N_(\"E781: .sug file doesn't match .spl file: %s\"));\nEXTERN char e_error_while_reading_sug_file_str[]\n\tINIT(= N_(\"E782: Error while reading .sug file: %s\"));\nEXTERN char e_duplicate_char_in_map_entry[]\n\tINIT(= N_(\"E783: Duplicate char in MAP entry\"));\n#endif\nEXTERN char e_cannot_close_last_tab_page[]\n\tINIT(= N_(\"E784: Cannot close last tab page\"));\n#ifdef FEAT_EVAL\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_can_only_be_used_in_insert_mode[]\n\tINIT(= N_(\"E785: complete() can only be used in Insert mode\"));\n# endif\nEXTERN char e_range_not_allowed[]\n\tINIT(= N_(\"E786: Range not allowed\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_buffer_changed_unexpectedly[]\n\tINIT(= N_(\"E787: Buffer changed unexpectedly\"));\n#endif\nEXTERN char e_not_allowed_to_edit_another_buffer_now[]\n\tINIT(= N_(\"E788: Not allowed to edit another buffer now\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_error_missing_rsb_str[]\n\tINIT(= N_(\"E789: Missing ']': %s\"));\n#endif\nEXTERN char e_undojoin_is_not_allowed_after_undo[]\n\tINIT(= N_(\"E790: undojoin is not allowed after undo\"));\n#ifdef FEAT_KEYMAP\nEXTERN char e_empty_keymap_entry[]\n\tINIT(= N_(\"E791: Empty keymap entry\"));\n#endif\n#ifdef FEAT_MENU\nEXTERN char e_empty_menu_name[]\n\tINIT(= N_(\"E792: Empty menu name\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_no_other_buffer_in_diff_mode_is_modifiable[]\n\tINIT(= N_(\"E793: No other buffer in diff mode is modifiable\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_set_variable_in_sandbox[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox\"));\nEXTERN char e_cannot_set_variable_in_sandbox_str[]\n\tINIT(= N_(\"E794: Cannot set variable in the sandbox: \\\"%s\\\"\"));\nEXTERN char e_cannot_delete_variable[]\n\tINIT(= N_(\"E795: Cannot delete variable\"));\nEXTERN char e_cannot_delete_variable_str[]\n\tINIT(= N_(\"E795: Cannot delete variable %s\"));\n\t// E796\n# ifdef MSWIN\nEXTERN char e_writing_to_device_disabled_with_opendevice_option[]\n\tINIT(= N_(\"writing to device disabled with 'opendevice' option\"));\n# endif\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_spellfilemising_autocommand_deleted_buffer[]\n\tINIT(= N_(\"E797: SpellFileMissing autocommand deleted buffer\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_is_reserved_for_match_nr[]\n\tINIT(= N_(\"E798: ID is reserved for \\\":match\\\": %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_1[]\n\tINIT(= N_(\"E799: Invalid ID: %d (must be greater than or equal to 1)\"));\n#endif\n#ifndef FEAT_ARABIC\nEXTERN char e_arabic_cannot_be_used_not_enabled_at_compile_time[]\n\tINIT(= N_(\"E800: Arabic cannot be used: Not enabled at compile time\\n\"));\n#endif\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN char e_id_already_taken_nr[]\n\tINIT(= N_(\"E801: ID already taken: %d\"));\nEXTERN char e_invalid_id_nr_must_be_greater_than_or_equal_to_one_2[]\n\tINIT(= N_(\"E802: Invalid ID: %d (must be greater than or equal to 1)\"));\nEXTERN char e_id_not_found_nr[]\n\tINIT(= N_(\"E803: ID not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_percent_with_float[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E804: Cannot use '%' with Float\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_float_as_number[]\n\tINIT(= N_(\"E805: Using a Float as a Number\"));\nEXTERN char e_using_float_as_string[]\n\tINIT(= N_(\"E806: Using a Float as a String\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_expected_float_argument_for_printf[]\n\tINIT(= N_(\"E807: Expected Float argument for printf()\"));\n#endif\n#if defined(FEAT_EVAL) && defined(FEAT_FLOAT)\nEXTERN char e_number_or_float_required[]\n\tINIT(= N_(\"E808: Number or Float required\"));\n#endif\n#ifndef FEAT_EVAL\nEXTERN char e_hashsmall_is_not_available_without_the_eval_feature[]\n\tINIT(= N_(\"E809: #< is not available without the +eval feature\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_or_write_temp_files[]\n\tINIT(= N_(\"E810: Cannot read or write temp files\"));\n#endif\nEXTERN char e_not_allowed_to_change_buffer_information_now[]\n\tINIT(= N_(\"E811: Not allowed to change buffer information now\"));\nEXTERN char e_autocommands_changed_buffer_or_buffer_name[]\n\tINIT(= N_(\"E812: Autocommands changed buffer or buffer name\"));\nEXTERN char e_cannot_close_autocmd_or_popup_window[]\n\tINIT(= N_(\"E813: Cannot close autocmd or popup window\"));\nEXTERN char e_cannot_close_window_only_autocmd_window_would_remain[]\n\tINIT(= N_(\"E814: Cannot close window, only autocmd window would remain\"));\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_libraries_could_not_be_loaded[]\n\tINIT(= N_(\"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded.\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_cannot_read_patch_output[]\n\tINIT(= N_(\"E816: Cannot read patch output\"));\n#endif\n#ifdef FEAT_CRYPT\nEXTERN char e_blowfish_big_little_endian_use_wrong[]\n\tINIT(= N_(\"E817: Blowfish big/little endian use wrong\"));\nEXTERN char e_sha256_test_failed[]\n\tINIT(= N_(\"E818: sha256 test failed\"));\nEXTERN char e_blowfish_test_failed[]\n\tINIT(= N_(\"E819: Blowfish test failed\"));\nEXTERN char e_sizeof_uint32_isnot_four[]\n\tINIT(= N_(\"E820: sizeof(uint32_t) != 4\"));\nEXTERN char e_file_is_encrypted_with_unknown_method[]\n\tINIT(= N_(\"E821: File is encrypted with unknown method\"));\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_cannot_open_undo_file_for_reading_str[]\n\tINIT(= N_(\"E822: Cannot open undo file for reading: %s\"));\nEXTERN char e_not_an_undo_file_str[]\n\tINIT(= N_(\"E823: Not an undo file: %s\"));\nEXTERN char e_incompatible_undo_file_str[]\n\tINIT(= N_(\"E824: Incompatible undo file: %s\"));\nEXTERN char e_corrupted_undo_file_str_str[]\n\tINIT(= N_(\"E825: Corrupted undo file (%s): %s\"));\n# ifdef FEAT_CRYPT\nEXTERN char e_undo_file_decryption_failed[]\n\tINIT(= N_(\"E826: Undo file decryption failed: %s\"));\n# else\nEXTERN char e_undo_file_is_encrypted_str[]\n\tINIT(= N_(\"E827: Undo file is encrypted: %s\"));\n# endif\nEXTERN char e_cannot_open_undo_file_for_writing_str[]\n\tINIT(= N_(\"E828: Cannot open undo file for writing: %s\"));\nEXTERN char e_write_error_in_undo_file_str[]\n\tINIT(= N_(\"E829: Write error in undo file: %s\"));\n#endif\nEXTERN char e_undo_number_nr_not_found[]\n\tINIT(= N_(\"E830: Undo number %ld not found\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_bf_key_init_called_with_empty_password[]\n\tINIT(= N_(\"E831: bf_key_init() called with empty password\"));\n# ifdef FEAT_PERSISTENT_UNDO\nEXTERN char e_non_encrypted_file_has_encrypted_undo_file[]\n\tINIT(= N_(\"E832: Non-encrypted file has encrypted undo file: %s\"));\n# endif\n#else\nEXTERN char e_str_is_encrypted_and_this_version_of_vim_does_not_support_encryption[]\n\tINIT(= N_(\"E833: %s is encrypted and this version of Vim does not support encryption\"));\n#endif\nEXTERN char e_conflicts_with_value_of_listchars[]\n\tINIT(= N_(\"E834: Conflicts with value of 'listchars'\"));\nEXTERN char e_conflicts_with_value_of_fillchars[]\n\tINIT(= N_(\"E835: Conflicts with value of 'fillchars'\"));\n#ifdef DYNAMIC_PYTHON\nEXTERN char e_this_vim_cannot_execute_python_after_using_py3[]\n\tINIT(= N_(\"E836: This Vim cannot execute :python after using :py3\"));\nEXTERN char e_this_vim_cannot_execute_py3_after_using_python[]\n\tINIT(= N_(\"E837: This Vim cannot execute :py3 after using :python\"));\n#endif\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI)\nEXTERN char e_netbeans_is_not_supported_with_this_GUI[]\n\tINIT(= N_(\"E838: NetBeans is not supported with this GUI\"));\n#endif\n// E839 unused\n# ifdef FEAT_COMPL_FUNC\nEXTERN char e_complete_function_deleted_text[]\n\tINIT(= N_(\"E840: Completion function deleted text\"));\n# endif\nEXTERN char e_reserved_name_cannot_be_used_for_user_defined_command[]\n\tINIT(= N_(\"E841: Reserved name, cannot be used for user defined command\"));\nEXTERN char e_no_line_number_to_use_for_slnum[]\n\tINIT(= N_(\"E842: No line number to use for \\\"<slnum>\\\"\"));\n#ifdef FEAT_CRYPT\nEXTERN char e_error_while_updating_swap_file_crypt[]\n\tINIT(= N_(\"E843: Error while updating swap file crypt\"));\n#endif\n#ifdef FEAT_CONCEAL\nEXTERN char e_invalid_cchar_value[]\n\tINIT(= N_(\"E844: Invalid cchar value\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_insufficient_memory_word_list_will_be_incomplete[]\n\tINIT(= N_(\"E845: Insufficient memory, word list will be incomplete\"));\n#endif\nEXTERN char e_key_code_not_set[]\n\tINIT(= N_(\"E846: Key code not set\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_too_many_syntax_includes[]\n\tINIT(= N_(\"E847: Too many syntax includes\"));\nEXTERN char e_too_many_syntax_clusters[]\n\tINIT(= N_(\"E848: Too many syntax clusters\"));\n#endif\nEXTERN char e_too_many_highlight_and_syntax_groups[]\n\tINIT(= N_(\"E849: Too many highlight and syntax groups\"));\n#ifndef FEAT_CLIPBOARD\nEXTERN char e_invalid_register_name[]\n\tINIT(= N_(\"E850: Invalid register name\"));\n#endif\n#ifdef FEAT_GUI\nEXTERN char e_failed_to_create_new_process_for_GUI[]\n\tINIT(= N_(\"E851: Failed to create a new process for the GUI\"));\nEXTERN char e_the_child_process_failed_to_start_GUI[]\n\tINIT(= N_(\"E852: The child process failed to start the GUI\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_argument_name_str[]\n\tINIT(= N_(\"E853: Duplicate argument name: %s\"));\n#endif\nEXTERN char e_path_too_long_for_completion[]\n\tINIT(= N_(\"E854: Path too long for completion\"));\nEXTERN char e_autocommands_caused_command_to_abort[]\n\tINIT(= N_(\"E855: Autocommands caused command to abort\"));\n#ifdef FEAT_EVAL\nEXTERN char e_assert_fails_second_arg[]\n\tINIT(= N_(\"E856: \\\"assert_fails()\\\" second argument must be a string or a list with one or two strings\"));\nEXTERN char e_dictionary_key_str_required[]\n\tINIT(= N_(\"E857: Dictionary key \\\"%s\\\" required\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_eval_did_not_return_valid_python_object[]\n\tINIT(= N_(\"E858: Eval did not return a valid python object\"));\nEXTERN char e_failed_to_convert_returned_python_object_to_vim_value[]\n\tINIT(= N_(\"E859: Failed to convert returned python object to a Vim value\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_need_id_and_type_or_types_with_both[]\n\tINIT(= N_(\"E860: Need 'id' and 'type' or 'types' with 'both'\"));\n# ifdef FEAT_TERMINAL\nEXTERN char e_cannot_open_second_popup_with_terminal[]\n\tINIT(= N_(\"E861: Cannot open a second popup with a terminal\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_g_here[]\n\tINIT(= N_(\"E862: Cannot use g: here\"));\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\nEXTERN char e_not_allowed_for_terminal_in_popup_window[]\n\tINIT(= N_(\"E863: Not allowed for a terminal in a popup window\"));\n#endif\nEXTERN char e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used\"));\nEXTERN char e_nfa_regexp_end_encountered_prematurely[]\n\tINIT(= N_(\"E865: (NFA) Regexp end encountered prematurely\"));\nEXTERN char e_nfa_regexp_misplaced_chr[]\n\tINIT(= N_(\"E866: (NFA regexp) Misplaced %c\"));\nEXTERN char e_nfa_regexp_unknown_operator_z_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\z%c'\"));\nEXTERN char e_nfa_regexp_unknown_operator_percent_chr[]\n\tINIT(= N_(\"E867: (NFA regexp) Unknown operator '\\\\%%%c'\"));\nEXTERN char e_error_building_nfa_with_equivalence_class[]\n\tINIT(= N_(\"E868: Error building NFA with equivalence class!\"));\nEXTERN char e_nfa_regexp_unknown_operator_at_chr[]\n\tINIT(= N_(\"E869: (NFA regexp) Unknown operator '\\\\@%c'\"));\nEXTERN char e_nfa_regexp_error_reading_repetition_limits[]\n\tINIT(= N_(\"E870: (NFA regexp) Error reading repetition limits\"));\nEXTERN char e_nfa_regexp_cant_have_multi_follow_multi[]\n\tINIT(= N_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\nEXTERN char e_nfa_regexp_too_many_parens[]\n\tINIT(= N_(\"E872: (NFA regexp) Too many '('\"));\nEXTERN char e_nfa_regexp_proper_termination_error[]\n\tINIT(= N_(\"E873: (NFA regexp) proper termination error\"));\nEXTERN char e_nfa_regexp_could_not_pop_stack[]\n\tINIT(= N_(\"E874: (NFA regexp) Could not pop the stack!\"));\nEXTERN char e_nfa_regexp_while_converting_from_postfix_to_nfa_too_many_stats_left_on_stack[]\n\tINIT(= N_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\nEXTERN char e_nfa_regexp_not_enough_space_to_store_whole_nfa[]\n\tINIT(= N_(\"E876: (NFA regexp) Not enough space to store the whole NFA\"));\nEXTERN char e_nfa_regexp_invalid_character_class_nr[]\n\tINIT(= N_(\"E877: (NFA regexp) Invalid character class: %d\"));\nEXTERN char e_nfa_regexp_could_not_allocate_memory_for_branch_traversal[]\n\tINIT(= N_(\"E878: (NFA regexp) Could not allocate memory for branch traversal!\"));\n#ifdef FEAT_SYN_HL\nEXTERN char e_nfa_regexp_too_many_z[]\n\tINIT(= N_(\"E879: (NFA regexp) Too many \\\\z(\"));\n#endif\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\nEXTERN char e_cant_handle_systemexit_of_python_exception_in_vim[]\n\tINIT(= N_(\"E880: Can't handle SystemExit of python exception in vim\"));\n#endif\nEXTERN char e_line_count_changed_unexpectedly[]\n\tINIT(= N_(\"E881: Line count changed unexpectedly\"));\n#ifdef FEAT_EVAL\nEXTERN char e_uniq_compare_function_failed[]\n\tINIT(= N_(\"E882: Uniq compare function failed\"));\nEXTERN char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]\n\tINIT(= N_(\"E883: Search pattern and expression register may not contain two or more lines\"));\nEXTERN char e_function_name_cannot_contain_colon_str[]\n\tINIT(= N_(\"E884: Function name cannot contain a colon: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_not_possible_to_change_sign_str[]\n\tINIT(= N_(\"E885: Not possible to change sign %s\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_cant_rename_viminfo_file_to_str[]\n\tINIT(= N_(\"E886: Can't rename viminfo file to %s!\"));\n#endif\nEXTERN char e_sorry_this_command_is_disabled_python_side_module_could_not_be_loaded[]\n\tINIT(= N_(\"E887: Sorry, this command is disabled, the Python's site module could not be loaded.\"));\nEXTERN char e_nfa_regexp_cannot_repeat_str[]\n\tINIT(= N_(\"E888: (NFA regexp) cannot repeat %s\"));\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_number_required[]\n\tINIT(= N_(\"E889: Number required\"));\n#endif\n#ifdef FEAT_SYN_HL\nEXTERN char e_trailing_char_after_rsb_str_str[]\n\tINIT(= N_(\"E890: Trailing char after ']': %s]%s\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_funcref_as_float[]\n\tINIT(= N_(\"E891: Using a Funcref as a Float\"));\nEXTERN char e_using_string_as_float[]\n\tINIT(= N_(\"E892: Using a String as a Float\"));\nEXTERN char e_using_list_as_float[]\n\tINIT(= N_(\"E893: Using a List as a Float\"));\nEXTERN char e_using_dictionary_as_float[]\n\tINIT(= N_(\"E894: Using a Dictionary as a Float\"));\n#endif\n#ifdef FEAT_MZSCHEME\nEXTERN char e_sorry_this_command_is_disabled_the_mzscheme_racket_base_module_could_not_be_loaded[]\n\tINIT(= N_(\"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_dictionary_or_blob[]\n\tINIT(= N_(\"E896: Argument of %s must be a List, Dictionary or Blob\"));\nEXTERN char e_list_or_blob_required[]\n\tINIT(= N_(\"E897: List or Blob required\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_socket_in_channel_connect[]\n\tINIT(= N_(\"E898: socket() in channel_connect()\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_or_blob[]\n\tINIT(= N_(\"E899: Argument of %s must be a List or Blob\"));\nEXTERN char e_maxdepth_must_be_non_negative_number[]\n\tINIT(= N_(\"E900: maxdepth must be non-negative number\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_getaddrinfo_in_channel_open_str[]\n\tINIT(= N_(\"E901: getaddrinfo() in channel_open(): %s\"));\n# ifndef FEAT_IPV6\nEXTERN char e_gethostbyname_in_channel_open[]\n\tINIT(= N_(\"E901: gethostbyname() in channel_open()\"));\n# endif\nEXTERN char e_cannot_connect_to_port[]\n\tINIT(= N_(\"E902: Cannot connect to port\"));\nEXTERN char e_received_command_with_non_string_argument[]\n\tINIT(= N_(\"E903: Received command with non-string argument\"));\nEXTERN char e_last_argument_for_expr_call_must_be_number[]\n\tINIT(= N_(\"E904: Last argument for expr/call must be a number\"));\nEXTERN char e_third_argument_for_call_must_be_list[]\n\tINIT(= N_(\"E904: Third argument for call must be a list\"));\nEXTERN char e_received_unknown_command_str[]\n\tINIT(= N_(\"E905: Received unknown command: %s\"));\nEXTERN char e_not_an_open_channel[]\n\tINIT(= N_(\"E906: Not an open channel\"));\n#endif\n#ifdef FEAT_FLOAT\nEXTERN char e_using_special_value_as_float[]\n\tINIT(= N_(\"E907: Using a special value as a Float\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_using_invalid_value_as_string_str[]\n\tINIT(= N_(\"E908: Using an invalid value as a String: %s\"));\nEXTERN char e_cannot_index_special_variable[]\n\tINIT(= N_(\"E909: Cannot index a special variable\"));\n#endif\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_using_job_as_number[]\n\tINIT(= N_(\"E910: Using a Job as a Number\"));\nEXTERN char e_using_job_as_float[]\n\tINIT(= N_(\"E911: Using a Job as a Float\"));\nEXTERN char e_cannot_use_evalexpr_sendexpr_with_raw_or_nl_channel[]\n\tINIT(= N_(\"E912: Cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel\"));\nEXTERN char e_using_channel_as_number[]\n\tINIT(= N_(\"E913: Using a Channel as a Number\"));\nEXTERN char e_using_channel_as_float[]\n\tINIT(= N_(\"E914: Using a Channel as a Float\"));\nEXTERN char e_in_io_buffer_requires_in_buf_or_in_name_to_be_set[]\n\tINIT(= N_(\"E915: in_io buffer requires in_buf or in_name to be set\"));\nEXTERN char e_not_valid_job[]\n\tINIT(= N_(\"E916: Not a valid job\"));\nEXTERN char e_cannot_use_callback_with_str[]\n\tINIT(= N_(\"E917: Cannot use a callback with %s()\"));\nEXTERN char e_buffer_must_be_loaded_str[]\n\tINIT(= N_(\"E918: Buffer must be loaded: %s\"));\n#endif\nEXTERN char e_directory_not_found_in_str_str[]\n\tINIT(= N_(\"E919: Directory not found in '%s': \\\"%s\\\"\"));\n#ifdef FEAT_JOB_CHANNEL\nEXTERN char e_io_file_requires_name_to_be_set[]\n\tINIT(= N_(\"E920: _io file requires _name to be set\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_callback_argument[]\n\tINIT(= N_(\"E921: Invalid callback argument\"));\nEXTERN char e_expected_dict[]\n\tINIT(= N_(\"E922: Expected a dict\"));\nEXTERN char e_second_argument_of_function_must_be_list_or_dict[]\n\tINIT(= N_(\"E923: Second argument of function() must be a list or a dict\"));\n#endif\n#ifdef FEAT_QUICKFIX\nEXTERN char e_current_window_was_closed[]\n\tINIT(= N_(\"E924: Current window was closed\"));\nEXTERN char e_current_quickfix_list_was_changed[]\n\tINIT(= N_(\"E925: Current quickfix list was changed\"));\nEXTERN char e_current_location_list_was_changed[]\n\tINIT(= N_(\"E926: Current location list was changed\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_QUICKFIX\nEXTERN char e_invalid_action_str_1[]\n\tINIT(= N_(\"E927: Invalid action: '%s'\"));\n# endif\nEXTERN char e_string_required[]\n\tINIT(= N_(\"E928: String required\"));\n#endif\n#ifdef FEAT_VIMINFO\nEXTERN char e_too_many_viminfo_temp_files_like_str[]\n\tINIT(= N_(\"E929: Too many viminfo temp files, like %s!\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_redir_inside_execute[]\n\tINIT(= N_(\"E930: Cannot use :redir inside execute()\"));\n#endif\nEXTERN char e_buffer_cannot_be_registered[]\n\tINIT(= N_(\"E931: Buffer cannot be registered\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_function_should_not_be_at_top_level[]\n\tINIT(= N_(\"E932: Closure function should not be at top level: %s\"));\nEXTERN char e_function_was_deleted_str[]\n\tINIT(= N_(\"E933: Function was deleted: %s\"));\n#endif\n#ifdef FEAT_SIGNS\nEXTERN char e_cannot_jump_to_buffer_that_does_not_have_name[]\n\tINIT(= N_(\"E934: Cannot jump to a buffer that does not have a name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_submatch_number_nr[]\n\tINIT(= N_(\"E935: Invalid submatch number: %d\"));\n#endif\nEXTERN char e_cannot_delete_current_group[]\n\tINIT(= N_(\"E936: Cannot delete the current group\"));\nEXTERN char e_attempt_to_delete_buffer_that_is_in_use_str[]\n\tINIT(= N_(\"E937: Attempt to delete a buffer that is in use: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_duplicate_key_in_json_str[]\n\tINIT(= N_(\"E938: Duplicate key in JSON: \\\"%s\\\"\"));\n#endif\nEXTERN char e_positive_count_required[]\n\tINIT(= N_(\"E939: Positive count required\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_lock_or_unlock_variable_str[]\n\tINIT(= N_(\"E940: Cannot lock or unlock variable %s\"));\n# ifdef FEAT_CLIENTSERVER\nEXTERN char e_already_started_server[]\n\tINIT(= N_(\"E941: Already started a server\"));\n# else\nEXTERN char e_clientserver_feature_not_available[]\n\tINIT(= N_(\"E942: +clientserver feature not available\"));\n# endif\n#endif\nEXTERN char e_command_table_needs_to_be_updated_run_make_cmdidxs[]\n\tINIT(= N_(\"E943: Command table needs to be updated, run 'make cmdidxs'\"));\nEXTERN char e_reverse_range_in_character_class[]\n\tINIT(= N_(\"E944: Reverse range in character class\"));\nEXTERN char e_range_too_large_in_character_class[]\n\tINIT(= N_(\"E945: Range too large in character class\"));\n#ifdef FEAT_TERMINAL\nEXTERN char e_cannot_make_terminal_with_running_job_modifiable[]\n\tINIT(= N_(\"E946: Cannot make a terminal with running job modifiable\"));\nEXTERN char e_job_still_running_in_buffer_str[]\n\tINIT(= N_(\"E947: Job still running in buffer \\\"%s\\\"\"));\nEXTERN char e_job_still_running[]\n\tINIT(= N_(\"E948: Job still running\"));\nEXTERN char e_job_still_running_add_bang_to_end_the_job[]\n\tINIT(= N_(\"E948: Job still running (add ! to end the job)\"));\n#endif\nEXTERN char e_file_changed_while_writing[]\n\tINIT(= N_(\"E949: File changed while writing\"));\nEXTERN char e_cannot_convert_between_str_and_str[]\n\tINIT(= N_(\"E950: Cannot convert between %s and %s\"));\nEXTERN char e_percent_value_too_large[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E951: \\\\% value too large\"));\n#if defined(FEAT_EVAL) && defined(FEAT_QUICKFIX)\nEXTERN char e_autocommand_caused_recursive_behavior[]\n\tINIT(= N_(\"E952: Autocommand caused recursive behavior\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_file_exists_str[]\n\tINIT(= N_(\"E953: File exists: %s\"));\n#endif\n#if defined(FEAT_TERMGUICOLORS) && defined(FEAT_VTP)\nEXTERN char e_24_bit_colors_are_not_supported_on_this_environment[]\n\tINIT(= N_(\"E954: 24-bit colors are not supported on this environment\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_not_terminal_buffer[]\n\tINIT(= N_(\"E955: Not a terminal buffer\"));\n#endif\nEXTERN char e_cannot_use_pattern_recursively[]\n\tINIT(= N_(\"E956: Cannot use pattern recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_window_number[]\n\tINIT(= N_(\"E957: Invalid window number\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_job_already_finished[]\n\tINIT(= N_(\"E958: Job already finished\"));\n#endif\n#ifdef FEAT_DIFF\nEXTERN char e_invalid_diff_format[]\n\tINIT(= N_(\"E959: Invalid diff format.\"));\nEXTERN char e_problem_creating_internal_diff[]\n\tINIT(= N_(\"E960: Problem creating the internal diff\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_line_number_to_use_for_sflnum[]\n\tINIT(= N_(\"E961: No line number to use for \\\"<sflnum>\\\"\"));\nEXTERN char e_invalid_action_str_2[]\n\tINIT(= N_(\"E962: Invalid action: '%s'\"));\nEXTERN char e_setting_str_to_value_with_wrong_type[]\n\tINIT(= N_(\"E963: Setting %s to value with wrong type\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char_u e_invalid_column_number_nr[]\n\tINIT(= N_(\"E964: Invalid column number: %ld\"));\nEXTERN char e_missing_property_type_name[]\n\tINIT(= N_(\"E965: Missing property type name\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char_u e_invalid_line_number_nr[]\n\tINIT(= N_(\"E966: Invalid line number: %ld\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_text_property_info_corrupted[]\n\tINIT(= N_(\"E967: Text property info corrupted\"));\nEXTERN char e_need_at_least_one_of_id_or_type[]\n\tINIT(= N_(\"E968: Need at least one of 'id' or 'type'\"));\nEXTERN char e_property_type_str_already_defined[]\n\tINIT(= N_(\"E969: Property type %s already defined\"));\nEXTERN char e_unknown_highlight_group_name_str[]\n\tINIT(= N_(\"E970: Unknown highlight group name: '%s'\"));\nEXTERN char e_type_not_exist[]\n\tINIT(= N_(\"E971: Property type %s does not exist\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_value_does_not_have_right_number_of_bytes[]\n\tINIT(= N_(\"E972: Blob value does not have the right number of bytes\"));\nEXTERN char e_blob_literal_should_have_an_even_number_of_hex_characters[]\n\tINIT(= N_(\"E973: Blob literal should have an even number of hex characters\"));\nEXTERN char e_using_blob_as_number[]\n\tINIT(= N_(\"E974: Using a Blob as a Number\"));\n# ifdef FEAT_FLOAT\nEXTERN char e_using_blob_as_float[]\n\tINIT(= N_(\"E975: Using a Blob as a Float\"));\n# endif\nEXTERN char e_using_blob_as_string[]\n\tINIT(= N_(\"E976: Using a Blob as a String\"));\nEXTERN char e_can_only_compare_blob_with_blob[]\n\tINIT(= N_(\"E977: Can only compare Blob with Blob\"));\nEXTERN char e_invalid_operation_for_blob[]\n\tINIT(= N_(\"E978: Invalid operation for Blob\"));\nEXTERN char e_blob_index_out_of_range_nr[]\n\tINIT(= N_(\"E979: Blob index out of range: %ld\"));\n# ifndef USE_INPUT_BUF\nEXTERN char e_lowlevel_input_not_supported[]\n\tINIT(= N_(\"E980: Lowlevel input not supported\"));\n# endif\n#endif\nEXTERN char e_command_not_allowed_in_rvim[]\n\tINIT(= N_(\"E981: Command not allowed in rvim\"));\n#if defined(FEAT_TERMINAL) && defined(MSWIN)\nEXTERN char e_conpty_is_not_available[]\n\tINIT(= N_(\"E982: ConPTY is not available\"));\n#endif\nEXTERN char e_duplicate_argument_str[]\n\tINIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char e_scriptversion_used_outside_of_sourced_file[]\n\tINIT(= N_(\"E984: :scriptversion used outside of a sourced file\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dot_equal_not_supported_with_script_version_two[]\n\tINIT(= N_(\"E985: .= is not supported with script version >= 2\"));\nEXTERN char e_cannot_modify_tag_stack_within_tagfunc[]\n\tINIT(= N_(\"E986: Cannot modify the tag stack within tagfunc\"));\nEXTERN char e_invalid_return_value_from_tagfunc[]\n\tINIT(= N_(\"E987: Invalid return value from tagfunc\"));\n#endif\n#ifdef GUI_MAY_SPAWN\nEXTERN char e_gui_cannot_be_used_cannot_execute_gvim_exe[]\n\tINIT(= N_(\"E988: GUI cannot be used. Cannot execute gvim.exe.\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_default_argument_follows_default_argument[]\n\tINIT(= N_(\"E989: Non-default argument follows default argument\"));\nEXTERN char e_missing_end_marker_str[]\n\tINIT(= N_(\"E990: Missing end marker '%s'\"));\nEXTERN char e_cannot_use_heredoc_here[]\n\tINIT(= N_(\"E991: Cannot use =<< here\"));\n#endif\nEXTERN char e_not_allowed_in_modeline_when_modelineexpr_is_off[]\n\tINIT(= N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\"));\n#ifdef FEAT_EVAL\nEXTERN char e_window_nr_is_not_popup_window[]\n\tINIT(= N_(\"E993: Window %d is not a popup window\"));\nEXTERN char e_not_allowed_in_popup_window[]\n\tINIT(= N_(\"E994: Not allowed in a popup window\"));\nEXTERN char e_cannot_modify_existing_variable[]\n\tINIT(= N_(\"E995: Cannot modify existing variable\"));\nEXTERN char e_cannot_lock_range[]\n\tINIT(= N_(\"E996: Cannot lock a range\"));\nEXTERN char e_cannot_lock_option[]\n\tINIT(= N_(\"E996: Cannot lock an option\"));\nEXTERN char e_cannot_lock_list_or_dict[]\n\tINIT(= N_(\"E996: Cannot lock a list or dict\"));\nEXTERN char e_cannot_lock_environment_variable[]\n\tINIT(= N_(\"E996: Cannot lock an environment variable\"));\nEXTERN char e_cannot_lock_register[]\n\tINIT(= N_(\"E996: Cannot lock a register\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_tabpage_not_found_nr[]\n\tINIT(= N_(\"E997: Tabpage not found: %d\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_reduce_of_an_empty_str_with_no_initial_value[]\n\tINIT(= N_(\"E998: Reduce of an empty %s with no initial value\"));\n#endif\nEXTERN char e_scriptversion_not_supported_nr[]\n\tINIT(= N_(\"E999: scriptversion not supported: %d\"));\n// E1000 unused\n#ifdef FEAT_EVAL\nEXTERN char e_variable_not_found_str[]\n\tINIT(= N_(\"E1001: Variable not found: %s\"));\nEXTERN char e_syntax_error_at_str[]\n\tINIT(= N_(\"E1002: Syntax error at %s\"));\nEXTERN char e_missing_return_value[]\n\tINIT(= N_(\"E1003: Missing return value\"));\nEXTERN char e_white_space_required_before_and_after_str_at_str[]\n\tINIT(= N_(\"E1004: White space required before and after '%s' at \\\"%s\\\"\"));\nEXTERN char e_too_many_argument_types[]\n\tINIT(= N_(\"E1005: Too many argument types\"));\nEXTERN char e_str_is_used_as_argument[]\n\tINIT(= N_(\"E1006: %s is used as an argument\"));\nEXTERN char e_mandatory_argument_after_optional_argument[]\n\tINIT(= N_(\"E1007: Mandatory argument after optional argument\"));\nEXTERN char e_missing_type_after_str[]\n\tINIT(= N_(\"E1008: Missing <type> after %s\"));\nEXTERN char e_missing_gt_after_type_str[]\n\tINIT(= N_(\"E1009: Missing > after type: %s\"));\nEXTERN char e_type_not_recognized_str[]\n\tINIT(= N_(\"E1010: Type not recognized: %s\"));\nEXTERN char e_name_too_long_str[]\n\tINIT(= N_(\"E1011: Name too long: %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s\"));\nEXTERN char e_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1012: Type mismatch; expected %s but got %s in %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_argument_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1013: Argument %d: type mismatch, expected %s but got %s in %s\"));\nEXTERN char e_invalid_key_str[]\n\tINIT(= N_(\"E1014: Invalid key: %s\"));\nEXTERN char e_name_expected_str[]\n\tINIT(= N_(\"E1015: Name expected: %s\"));\nEXTERN char e_cannot_declare_a_scope_variable[]\n\tINIT(= N_(\"E1016: Cannot declare a %s variable: %s\"));\nEXTERN char e_cannot_declare_an_environment_variable[]\n\tINIT(= N_(\"E1016: Cannot declare an environment variable: %s\"));\nEXTERN char e_variable_already_declared[]\n\tINIT(= N_(\"E1017: Variable already declared: %s\"));\nEXTERN char e_cannot_assign_to_constant[]\n\tINIT(= N_(\"E1018: Cannot assign to a constant: %s\"));\nEXTERN char e_can_only_concatenate_to_string[]\n\tINIT(= N_(\"E1019: Can only concatenate to string\"));\nEXTERN char e_cannot_use_operator_on_new_variable[]\n\tINIT(= N_(\"E1020: Cannot use an operator on a new variable: %s\"));\nEXTERN char e_const_requires_a_value[]\n\tINIT(= N_(\"E1021: Const requires a value\"));\nEXTERN char e_type_or_initialization_required[]\n\tINIT(= N_(\"E1022: Type or initialization required\"));\nEXTERN char e_using_number_as_bool_nr[]\n\tINIT(= N_(\"E1023: Using a Number as a Bool: %lld\"));\nEXTERN char e_using_number_as_string[]\n\tINIT(= N_(\"E1024: Using a Number as a String\"));\nEXTERN char e_using_rcurly_outside_if_block_scope[]\n\tINIT(= N_(\"E1025: Using } outside of a block scope\"));\n#endif\nEXTERN char e_missing_rcurly[]\n\tINIT(= N_(\"E1026: Missing }\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_statement[]\n\tINIT(= N_(\"E1027: Missing return statement\"));\nEXTERN char e_compiling_def_function_failed[]\n\tINIT(= N_(\"E1028: Compiling :def function failed\"));\nEXTERN char e_expected_str_but_got_str[]\n\tINIT(= N_(\"E1029: Expected %s but got %s\"));\nEXTERN char e_using_string_as_number_str[]\n\tINIT(= N_(\"E1030: Using a String as a Number: \\\"%s\\\"\"));\nEXTERN char e_cannot_use_void_value[]\n\tINIT(= N_(\"E1031: Cannot use void value\"));\nEXTERN char e_missing_catch_or_finally[]\n\tINIT(= N_(\"E1032: Missing :catch or :finally\"));\nEXTERN char e_catch_unreachable_after_catch_all[]\n\tINIT(= N_(\"E1033: Catch unreachable after catch-all\"));\nEXTERN char e_cannot_use_reserved_name[]\n\tINIT(= N_(\"E1034: Cannot use reserved name %s\"));\nEXTERN char e_percent_requires_number_arguments[]\n\t// xgettext:no-c-format\n\tINIT(= N_(\"E1035: % requires number arguments\"));\nEXTERN char e_char_requires_number_or_float_arguments[]\n\tINIT(= N_(\"E1036: %c requires number or float arguments\"));\nEXTERN char e_cannot_use_str_with_str[]\n\tINIT(= N_(\"E1037: Cannot use \\\"%s\\\" with %s\"));\nEXTERN char e_vim9script_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1038: \\\"vim9script\\\" can only be used in a script\"));\nEXTERN char e_vim9script_must_be_first_command_in_script[]\n\tINIT(= N_(\"E1039: \\\"vim9script\\\" must be the first command in a script\"));\n#endif\nEXTERN char e_cannot_use_scriptversion_after_vim9script[]\n\tINIT(= N_(\"E1040: Cannot use :scriptversion after :vim9script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_redefining_script_item_str[]\n\tINIT(= N_(\"E1041: Redefining script item: \\\"%s\\\"\"));\nEXTERN char e_export_can_only_be_used_in_vim9script[]\n\tINIT(= N_(\"E1042: Export can only be used in vim9script\"));\nEXTERN char e_invalid_command_after_export[]\n\tINIT(= N_(\"E1043: Invalid command after :export\"));\nEXTERN char e_export_with_invalid_argument[]\n\tINIT(= N_(\"E1044: Export with invalid argument\"));\n// E1045 not used\n// E1046 not used\nEXTERN char e_syntax_error_in_import_str[]\n\tINIT(= N_(\"E1047: Syntax error in import: %s\"));\nEXTERN char e_item_not_found_in_script_str[]\n\tINIT(= N_(\"E1048: Item not found in script: %s\"));\nEXTERN char e_item_not_exported_in_script_str[]\n\tINIT(= N_(\"E1049: Item not exported in script: %s\"));\nEXTERN char e_colon_required_before_range_str[]\n\tINIT(= N_(\"E1050: Colon required before a range: %s\"));\nEXTERN char e_wrong_argument_type_for_plus[]\n\tINIT(= N_(\"E1051: Wrong argument type for +\"));\nEXTERN char e_cannot_declare_an_option[]\n\tINIT(= N_(\"E1052: Cannot declare an option: %s\"));\nEXTERN char e_could_not_import_str[]\n\tINIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));\nEXTERN char e_variable_already_declared_in_script_str[]\n\tINIT(= N_(\"E1054: Variable already declared in the script: %s\"));\nEXTERN char e_missing_name_after_dots[]\n\tINIT(= N_(\"E1055: Missing name after ...\"));\nEXTERN char e_expected_type_str[]\n\tINIT(= N_(\"E1056: Expected a type: %s\"));\nEXTERN char e_missing_enddef[]\n\tINIT(= N_(\"E1057: Missing :enddef\"));\nEXTERN char e_function_nesting_too_deep[]\n\tINIT(= N_(\"E1058: Function nesting too deep\"));\nEXTERN char e_no_white_space_allowed_before_colon_str[]\n\tINIT(= N_(\"E1059: No white space allowed before colon: %s\"));\nEXTERN char e_expected_dot_after_name_str[]\n\tINIT(= N_(\"E1060: Expected dot after name: %s\"));\nEXTERN char e_cannot_find_function_str[]\n\tINIT(= N_(\"E1061: Cannot find function %s\"));\nEXTERN char e_cannot_index_number[]\n\tINIT(= N_(\"E1062: Cannot index a Number\"));\nEXTERN char e_type_mismatch_for_v_variable[]\n\tINIT(= N_(\"E1063: Type mismatch for v: variable\"));\n#endif\nEXTERN char e_yank_register_changed_while_using_it[]\n\tINIT(= N_(\"E1064: Yank register changed while using it\"));\nEXTERN char e_command_cannot_be_shortened_str[]\n\tINIT(= N_(\"E1065: Command cannot be shortened: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_a_register_str[]\n\tINIT(= N_(\"E1066: Cannot declare a register: %s\"));\nEXTERN char e_separator_mismatch_str[]\n\tINIT(= N_(\"E1067: Separator mismatch: %s\"));\nEXTERN char e_no_white_space_allowed_before_str_str[]\n\tINIT(= N_(\"E1068: No white space allowed before '%s': %s\"));\nEXTERN char e_white_space_required_after_str_str[]\n\tINIT(= N_(\"E1069: White space required after '%s': %s\"));\nEXTERN char e_invalid_string_for_import_str[]\n\tINIT(= N_(\"E1071: Invalid string for :import: %s\"));\nEXTERN char e_cannot_compare_str_with_str[]\n\tINIT(= N_(\"E1072: Cannot compare %s with %s\"));\nEXTERN char e_name_already_defined_str[]\n\tINIT(= N_(\"E1073: Name already defined: %s\"));\nEXTERN char e_no_white_space_allowed_after_dot[]\n\tINIT(= N_(\"E1074: No white space allowed after dot\"));\nEXTERN char e_namespace_not_supported_str[]\n\tINIT(= N_(\"E1075: Namespace not supported: %s\"));\n# ifndef FEAT_FLOAT\nEXTERN char e_this_vim_is_not_compiled_with_float_support[]\n\tINIT(= N_(\"E1076: This Vim is not compiled with float support\"));\n# endif\nEXTERN char e_missing_argument_type_for_str[]\n\tINIT(= N_(\"E1077: Missing argument type for %s\"));\n#endif\nEXTERN char e_invalid_command_nested_did_you_mean_plusplus_nested[]\n\tINIT(= N_(\"E1078: Invalid command \\\"nested\\\", did you mean \\\"++nested\\\"?\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_declare_variable_on_command_line[]\n\tINIT(= N_(\"E1079: Cannot declare a variable on the command line\"));\nEXTERN char e_invalid_assignment[]\n\tINIT(= N_(\"E1080: Invalid assignment\"));\nEXTERN char e_cannot_unlet_str[]\n\tINIT(= N_(\"E1081: Cannot unlet %s\"));\n#endif\nEXTERN char e_command_modifier_without_command[]\n\tINIT(= N_(\"E1082: Command modifier without command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_backtick[]\n\tINIT(= N_(\"E1083: Missing backtick\"));\nEXTERN char e_cannot_delete_vim9_script_function_str[]\n\tINIT(= N_(\"E1084: Cannot delete Vim9 script function %s\"));\nEXTERN char e_not_callable_type_str[]\n\tINIT(= N_(\"E1085: Not a callable type: %s\"));\n// E1086 unused\nEXTERN char e_cannot_use_index_when_declaring_variable[]\n\tINIT(= N_(\"E1087: Cannot use an index when declaring a variable\"));\nEXTERN char e_script_cannot_import_itself[]\n\tINIT(= N_(\"E1088: Script cannot import itself\"));\nEXTERN char e_unknown_variable_str[]\n\tINIT(= N_(\"E1089: Unknown variable: %s\"));\nEXTERN char e_cannot_assign_to_argument[]\n\tINIT(= N_(\"E1090: Cannot assign to argument %s\"));\nEXTERN char e_function_is_not_compiled_str[]\n\tINIT(= N_(\"E1091: Function is not compiled: %s\"));\nEXTERN char e_cannot_nest_redir[]\n\tINIT(= N_(\"E1092: Cannot nest :redir\"));\nEXTERN char e_expected_nr_items_but_got_nr[]\n\tINIT(= N_(\"E1093: Expected %d items but got %d\"));\nEXTERN char e_import_can_only_be_used_in_script[]\n\tINIT(= N_(\"E1094: Import can only be used in a script\"));\nEXTERN char e_unreachable_code_after_return[]\n\tINIT(= N_(\"E1095: Unreachable code after :return\"));\nEXTERN char e_returning_value_in_function_without_return_type[]\n\tINIT(= N_(\"E1096: Returning a value in a function without a return type\"));\nEXTERN char e_line_incomplete[]\n\tINIT(= N_(\"E1097: Line incomplete\"));\nEXTERN char e_string_list_or_blob_required[]\n\tINIT(= N_(\"E1098: String, List or Blob required\"));\nEXTERN char e_unknown_error_while_executing_str[]\n\tINIT(= N_(\"E1099: Unknown error while executing %s\"));\nEXTERN char e_command_not_supported_in_vim9_script_missing_var_str[]\n\tINIT(= N_(\"E1100: Command not supported in Vim9 script (missing :var?): %s\"));\nEXTERN char e_cannot_declare_script_variable_in_function_str[]\n\tINIT(= N_(\"E1101: Cannot declare a script variable in a function: %s\"));\nEXTERN char e_lambda_function_not_found_str[]\n\tINIT(= N_(\"E1102: Lambda function not found: %s\"));\nEXTERN char e_dictionary_not_set[]\n\tINIT(= N_(\"E1103: Dictionary not set\"));\nEXTERN char e_missing_gt[]\n\tINIT(= N_(\"E1104: Missing >\"));\nEXTERN char e_cannot_convert_str_to_string[]\n\tINIT(= N_(\"E1105: Cannot convert %s to string\"));\nEXTERN char e_one_argument_too_many[]\n\tINIT(= N_(\"E1106: One argument too many\"));\nEXTERN char e_nr_arguments_too_many[]\n\tINIT(= N_(\"E1106: %d arguments too many\"));\nEXTERN char e_string_list_dict_or_blob_required[]\n\tINIT(= N_(\"E1107: String, List, Dict or Blob required\"));\nEXTERN char e_item_not_found_str[]\n\tINIT(= N_(\"E1108: Item not found: %s\"));\nEXTERN char e_list_item_nr_is_not_list[]\n\tINIT(= N_(\"E1109: List item %d is not a List\"));\nEXTERN char e_list_item_nr_does_not_contain_3_numbers[]\n\tINIT(= N_(\"E1110: List item %d does not contain 3 numbers\"));\nEXTERN char e_list_item_nr_range_invalid[]\n\tINIT(= N_(\"E1111: List item %d range invalid\"));\nEXTERN char e_list_item_nr_cell_width_invalid[]\n\tINIT(= N_(\"E1112: List item %d cell width invalid\"));\nEXTERN char e_overlapping_ranges_for_nr[]\n\tINIT(= N_(\"E1113: Overlapping ranges for 0x%lx\"));\nEXTERN char e_only_values_of_0x100_and_higher_supported[]\n\tINIT(= N_(\"E1114: Only values of 0x100 and higher supported\"));\nEXTERN char e_assert_fails_fourth_argument[]\n\tINIT(= N_(\"E1115: \\\"assert_fails()\\\" fourth argument must be a number\"));\nEXTERN char e_assert_fails_fifth_argument[]\n\tINIT(= N_(\"E1116: \\\"assert_fails()\\\" fifth argument must be a string\"));\nEXTERN char e_cannot_use_bang_with_nested_def[]\n\tINIT(= N_(\"E1117: Cannot use ! with nested :def\"));\nEXTERN char e_cannot_change_locked_list[]\n\tINIT(= N_(\"E1118: Cannot change locked list\"));\nEXTERN char e_cannot_change_locked_list_item[]\n\tINIT(= N_(\"E1119: Cannot change locked list item\"));\nEXTERN char e_cannot_change_dict[]\n\tINIT(= N_(\"E1120: Cannot change dict\"));\nEXTERN char e_cannot_change_dict_item[]\n\tINIT(= N_(\"E1121: Cannot change dict item\"));\nEXTERN char e_variable_is_locked_str[]\n\tINIT(= N_(\"E1122: Variable is locked: %s\"));\nEXTERN char e_missing_comma_before_argument_str[]\n\tINIT(= N_(\"E1123: Missing comma before argument: %s\"));\nEXTERN char e_str_cannot_be_used_in_legacy_vim_script[]\n\tINIT(= N_(\"E1124: \\\"%s\\\" cannot be used in legacy Vim script\"));\nEXTERN char e_final_requires_a_value[]\n\tINIT(= N_(\"E1125: Final requires a value\"));\nEXTERN char e_cannot_use_let_in_vim9_script[]\n\tINIT(= N_(\"E1126: Cannot use :let in Vim9 script\"));\nEXTERN char e_missing_name_after_dot[]\n\tINIT(= N_(\"E1127: Missing name after dot\"));\nEXTERN char e_endblock_without_block[]\n\tINIT(= N_(\"E1128: } without {\"));\nEXTERN char e_throw_with_empty_string[]\n\tINIT(= N_(\"E1129: Throw with empty string\"));\nEXTERN char e_cannot_add_to_null_list[]\n\tINIT(= N_(\"E1130: Cannot add to null list\"));\nEXTERN char e_cannot_add_to_null_blob[]\n\tINIT(= N_(\"E1131: Cannot add to null blob\"));\nEXTERN char e_missing_function_argument[]\n\tINIT(= N_(\"E1132: Missing function argument\"));\nEXTERN char e_cannot_extend_null_dict[]\n\tINIT(= N_(\"E1133: Cannot extend a null dict\"));\nEXTERN char e_cannot_extend_null_list[]\n\tINIT(= N_(\"E1134: Cannot extend a null list\"));\nEXTERN char e_using_string_as_bool_str[]\n\tINIT(= N_(\"E1135: Using a String as a Bool: \\\"%s\\\"\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr_before_second_cmd[]\n\tINIT(= N_(\"E1136: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char e_cmd_maping_must_not_include_str_key[]\n\tINIT(= N_(\"E1137: <Cmd> mapping must not include %s key\"));\n#ifdef FEAT_EVAL\nEXTERN char e_using_bool_as_number[]\n\tINIT(= N_(\"E1138: Using a Bool as a Number\"));\nEXTERN char e_missing_matching_bracket_after_dict_key[]\n\tINIT(= N_(\"E1139: Missing matching bracket after dict key\"));\nEXTERN char e_for_argument_must_be_sequence_of_lists[]\n\tINIT(= N_(\"E1140: :for argument must be a sequence of lists\"));\nEXTERN char e_indexable_type_required[]\n\tINIT(= N_(\"E1141: Indexable type required\"));\nEXTERN char e_calling_test_garbagecollect_now_while_v_testing_is_not_set[]\n\tINIT(= N_(\"E1142: Calling test_garbagecollect_now() while v:testing is not set\"));\nEXTERN char e_empty_expression_str[]\n\tINIT(= N_(\"E1143: Empty expression: \\\"%s\\\"\"));\nEXTERN char e_command_str_not_followed_by_white_space_str[]\n\tINIT(= N_(\"E1144: Command \\\"%s\\\" is not followed by white space: %s\"));\nEXTERN char e_missing_heredoc_end_marker_str[]\n\tINIT(= N_(\"E1145: Missing heredoc end marker: %s\"));\nEXTERN char e_command_not_recognized_str[]\n\tINIT(= N_(\"E1146: Command not recognized: %s\"));\nEXTERN char e_list_not_set[]\n\tINIT(= N_(\"E1147: List not set\"));\nEXTERN char e_cannot_index_str[]\n\tINIT(= N_(\"E1148: Cannot index a %s\"));\nEXTERN char e_script_variable_invalid_after_reload_in_function_str[]\n\tINIT(= N_(\"E1149: Script variable is invalid after reload in function %s\"));\nEXTERN char e_script_variable_type_changed[]\n\tINIT(= N_(\"E1150: Script variable type changed\"));\nEXTERN char e_mismatched_endfunction[]\n\tINIT(= N_(\"E1151: Mismatched endfunction\"));\nEXTERN char e_mismatched_enddef[]\n\tINIT(= N_(\"E1152: Mismatched enddef\"));\nEXTERN char e_invalid_operation_for_str[]\n\tINIT(= N_(\"E1153: Invalid operation for %s\"));\nEXTERN char e_divide_by_zero[]\n\tINIT(= N_(\"E1154: Divide by zero\"));\n#endif\nEXTERN char e_cannot_define_autocommands_for_all_events[]\n\tINIT(= N_(\"E1155: Cannot define autocommands for ALL events\"));\nEXTERN char e_cannot_change_arglist_recursively[]\n\tINIT(= N_(\"E1156: Cannot change the argument list recursively\"));\n#ifdef FEAT_EVAL\nEXTERN char e_missing_return_type[]\n\tINIT(= N_(\"E1157: Missing return type\"));\nEXTERN char e_cannot_use_flatten_in_vim9_script[]\n\tINIT(= N_(\"E1158: Cannot use flatten() in Vim9 script, use flattennew()\"));\n#endif\nEXTERN char e_cannot_split_window_when_closing_buffer[]\n\tINIT(= N_(\"E1159: Cannot split a window when closing the buffer\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_default_for_variable_arguments[]\n\tINIT(= N_(\"E1160: Cannot use a default for variable arguments\"));\nEXTERN char e_cannot_json_encode_str[]\n\tINIT(= N_(\"E1161: Cannot json encode a %s\"));\nEXTERN char e_register_name_must_be_one_char_str[]\n\tINIT(= N_(\"E1162: Register name must be one character: %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s\"));\nEXTERN char e_variable_nr_type_mismatch_expected_str_but_got_str_in_str[]\n\tINIT(= N_(\"E1163: Variable %d: type mismatch, expected %s but got %s in %s\"));\n#endif\nEXTERN char e_vim9cmd_must_be_followed_by_command[]\n\tINIT(= N_(\"E1164: vim9cmd must be followed by a command\"));\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_range_with_assignment_str[]\n\tINIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));\nEXTERN char e_cannot_use_range_with_dictionary[]\n\tINIT(= N_(\"E1166: Cannot use a range with a dictionary\"));\nEXTERN char e_argument_name_shadows_existing_variable_str[]\n\tINIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));\nEXTERN char e_argument_already_declared_in_script_str[]\n\tINIT(= N_(\"E1168: Argument already declared in the script: %s\"));\nEXTERN char e_expression_too_recursive_str[]\n\tINIT(= N_(\"E1169: Expression too recursive: %s\"));\nEXTERN char e_cannot_use_hash_curly_to_start_comment[]\n\tINIT(= N_(\"E1170: Cannot use #{ to start a comment\"));\nEXTERN char e_missing_end_block[]\n\tINIT(= N_(\"E1171: Missing } after inline function\"));\nEXTERN char e_cannot_use_default_values_in_lambda[]\n\tINIT(= N_(\"E1172: Cannot use default values in a lambda\"));\nEXTERN char e_text_found_after_str_str[]\n\tINIT(= N_(\"E1173: Text found after %s: %s\"));\nEXTERN char e_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1174: String required for argument %d\"));\nEXTERN char e_non_empty_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1175: Non-empty string required for argument %d\"));\nEXTERN char e_misplaced_command_modifier[]\n\tINIT(= N_(\"E1176: Misplaced command modifier\"));\nEXTERN char e_for_loop_on_str_not_supported[]\n\tINIT(= N_(\"E1177: For loop on %s not supported\"));\nEXTERN char e_cannot_lock_unlock_local_variable[]\n\tINIT(= N_(\"E1178: Cannot lock or unlock a local variable\"));\n#endif\n#ifdef FEAT_TERMINAL\nEXTERN char e_failed_to_extract_pwd_from_str_check_your_shell_config[]\n\tINIT(= N_(\"E1179: Failed to extract PWD from %s, check your shell's config related to OSC 7\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_variable_arguments_type_must_be_list_str[]\n\tINIT(= N_(\"E1180: Variable arguments type must be a list: %s\"));\nEXTERN char e_cannot_use_underscore_here[]\n\tINIT(= N_(\"E1181: Cannot use an underscore here\"));\nEXTERN char e_cannot_define_dict_func_in_vim9_script_str[]\n\tINIT(= N_(\"E1182: Cannot define a dict function in Vim9 script: %s\"));\nEXTERN char e_cannot_use_range_with_assignment_operator_str[]\n\tINIT(= N_(\"E1183: Cannot use a range with an assignment operator: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_blob_not_set[]\n\tINIT(= N_(\"E1184: Blob not set\"));\nEXTERN char e_missing_redir_end[]\n\tINIT(= N_(\"E1185: Missing :redir END\"));\nEXTERN char e_expression_does_not_result_in_value_str[]\n\tINIT(= N_(\"E1186: Expression does not result in a value: %s\"));\n#endif\nEXTERN char e_failed_to_source_defaults[]\n\tINIT(= N_(\"E1187: Failed to source defaults.vim\"));\n#if defined(FEAT_TERMINAL) && defined(FEAT_CMDWIN)\nEXTERN char e_cannot_open_terminal_from_command_line_window[]\n\tINIT(= N_(\"E1188: Cannot open a terminal from the command line window\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_cannot_use_legacy_with_command_str[]\n\tINIT(= N_(\"E1189: Cannot use :legacy with this command: %s\"));\nEXTERN char e_one_argument_too_few[]\n\tINIT(= N_(\"E1190: One argument too few\"));\nEXTERN char e_nr_arguments_too_few[]\n\tINIT(= N_(\"E1190: %d arguments too few\"));\nEXTERN char e_call_to_function_that_failed_to_compile_str[]\n\tINIT(= N_(\"E1191: Call to function that failed to compile: %s\"));\nEXTERN char e_empty_function_name[]\n\tINIT(= N_(\"E1192: Empty function name\"));\n#endif\n// libsodium\n#ifdef FEAT_CRYPT\n# ifndef FEAT_SODIUM\nEXTERN char e_libsodium_not_built_in[]\n\tINIT(= N_(\"E1193: cryptmethod xchacha20 not built into this Vim\"));\n# else\n#  if 0\nEXTERN char e_libsodium_cannot_encrypt_header[]\n\tINIT(= N_(\"E1194: Cannot encrypt header, not enough space\"));\nEXTERN char e_libsodium_cannot_encrypt_buffer[]\n\tINIT(= N_(\"E1195: Cannot encrypt buffer, not enough space\"));\nEXTERN char e_libsodium_cannot_decrypt_header[]\n\tINIT(= N_(\"E1196: Cannot decrypt header, not enough space\"));\n#  endif\nEXTERN char e_libsodium_cannot_allocate_buffer[]\n\tINIT(= N_(\"E1197: Cannot allocate_buffer for encryption\"));\nEXTERN char e_libsodium_decryption_failed_header_incomplete[]\n\tINIT(= N_(\"E1198: Decryption failed: Header incomplete!\"));\n#  if 0\nEXTERN char e_libsodium_cannot_decrypt_buffer[]\n\tINIT(= N_(\"E1199: Cannot decrypt buffer, not enough space\"));\n#  endif\nEXTERN char e_libsodium_decryption_failed[]\n\tINIT(= N_(\"E1200: Decryption failed!\"));\nEXTERN char e_libsodium_decryption_failed_premature[]\n\tINIT(= N_(\"E1201: Decryption failed: pre-mature end of file!\"));\n# endif\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_no_white_space_allowed_after_str_str[]\n\tINIT(= N_(\"E1202: No white space allowed after '%s': %s\"));\nEXTERN char e_dot_can_only_be_used_on_dictionary_str[]\n\tINIT(= N_(\"E1203: Dot can only be used on a dictionary: %s\"));\n#endif\nEXTERN char e_regexp_number_after_dot_pos_search_chr[]\n\tINIT(= N_(\"E1204: No Number allowed after .: '\\\\%%%c'\"));\nEXTERN char e_no_white_space_allowed_between_option_and[]\n\tINIT(= N_(\"E1205: No white space allowed between option and\"));\n#ifdef FEAT_EVAL\nEXTERN char e_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1206: Dictionary required for argument %d\"));\nEXTERN char e_expression_without_effect_str[]\n\tINIT(= N_(\"E1207: Expression without an effect: %s\"));\n#endif\nEXTERN char e_complete_used_without_allowing_arguments[]\n\tINIT(= N_(\"E1208: -complete used without allowing arguments\"));\n#ifdef FEAT_EVAL\nEXTERN char e_invalid_value_for_line_number_str[]\n\tINIT(= N_(\"E1209: Invalid value for a line number: \\\"%s\\\"\"));\nEXTERN char e_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1210: Number required for argument %d\"));\nEXTERN char e_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1211: List required for argument %d\"));\nEXTERN char e_bool_required_for_argument_nr[]\n\tINIT(= N_(\"E1212: Bool required for argument %d\"));\nEXTERN char e_redefining_imported_item_str[]\n\tINIT(= N_(\"E1213: Redefining imported item \\\"%s\\\"\"));\n#endif\n#if defined(FEAT_DIGRAPHS) && defined(FEAT_EVAL)\nEXTERN char e_digraph_must_be_just_two_characters_str[]\n\tINIT(= N_(\"E1214: Digraph must be just two characters: %s\"));\nEXTERN char e_digraph_argument_must_be_one_character_str[]\n\tINIT(= N_(\"E1215: Digraph must be one character: %s\"));\nEXTERN char e_digraph_setlist_argument_must_be_list_of_lists_with_two_items[]\n\tINIT(= N_(\"E1216: digraph_setlist() argument must be a list of lists with two items\"));\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_chan_or_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1217: Channel or Job required for argument %d\"));\nEXTERN char e_job_required_for_argument_nr[]\n\tINIT(= N_(\"E1218: Job required for argument %d\"));\n# endif\nEXTERN char e_float_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1219: Float or Number required for argument %d\"));\nEXTERN char e_string_or_number_required_for_argument_nr[]\n\tINIT(= N_(\"E1220: String or Number required for argument %d\"));\n# ifdef FEAT_JOB_CHANNEL\nEXTERN char e_string_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1221: String or Blob required for argument %d\"));\n# endif\nEXTERN char e_string_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1222: String or List required for argument %d\"));\nEXTERN char e_string_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1223: String or Dictionary required for argument %d\"));\nEXTERN char e_string_number_or_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1224: String, Number or List required for argument %d\"));\nEXTERN char e_string_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1225: String, List or Dictionary required for argument %d\"));\nEXTERN char e_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1226: List or Blob required for argument %d\"));\nEXTERN char e_list_or_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1227: List or Dictionary required for argument %d\"));\nEXTERN char e_list_dict_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1228: List, Dictionary or Blob required for argument %d\"));\nEXTERN char e_expected_dictionary_for_using_key_str_but_got_str[]\n\tINIT(= N_(\"E1229: Expected dictionary for using key \\\"%s\\\", but got %s\"));\n#endif\n#ifdef FEAT_SODIUM\nEXTERN char e_encryption_sodium_mlock_failed[]\n\tINIT(= N_(\"E1230: Encryption: sodium_mlock() failed\"));\n#endif\nEXTERN char e_cannot_use_bar_to_separate_commands_here_str[]\n\tINIT(= N_(\"E1231: Cannot use a bar to separate commands here: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_exists_compiled_must_be_literal_string[]\n\tINIT(= N_(\"E1232: Argument of exists_compiled() must be a literal string\"));\nEXTERN char e_exists_compiled_can_only_be_used_in_def_function[]\n\tINIT(= N_(\"E1233: exists_compiled() can only be used in a :def function\"));\n#endif\nEXTERN char e_legacy_must_be_followed_by_command[]\n\tINIT(= N_(\"E1234: legacy must be followed by a command\"));\n#ifdef FEAT_EVAL\n// E1235 unused\nEXTERN char e_cannot_use_str_itself_it_is_imported[]\n\tINIT(= N_(\"E1236: Cannot use %s itself, it is imported\"));\n#endif\nEXTERN char e_no_such_user_defined_command_in_current_buffer_str[]\n\tINIT(= N_(\"E1237: No such user-defined command in current buffer: %s\"));\n#ifdef FEAT_EVAL\nEXTERN char e_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1238: Blob required for argument %d\"));\nEXTERN char e_invalid_value_for_blob_nr[]\n\tINIT(= N_(\"E1239: Invalid value for blob: %d\"));\n#endif\nEXTERN char e_resulting_text_too_long[]\n\tINIT(= N_(\"E1240: Resulting text too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_separator_not_supported_str[]\n\tINIT(= N_(\"E1241: Separator not supported: %s\"));\nEXTERN char e_no_white_space_allowed_before_separator_str[]\n\tINIT(= N_(\"E1242: No white space allowed before separator: %s\"));\n#endif\n#ifdef FEAT_GUI_GTK\nEXTERN char e_ascii_code_not_in_range[]\n\tINIT(= N_(\"E1243: ASCII code not in 32-127 range\"));\n#endif\n#ifdef FEAT_EVAL\n# if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\nEXTERN char e_bad_color_string_str[]\n\tINIT(= N_(\"E1244: Bad color string: %s\"));\n# endif\nEXTERN char e_cannot_expand_sfile_in_vim9_function[]\n\tINIT(= N_(\"E1245: Cannot expand <sfile> in a Vim9 function\"));\nEXTERN char e_cannot_find_variable_to_unlock_str[]\n\tINIT(= N_(\"E1246: Cannot find variable to (un)lock: %s\"));\n#endif\nEXTERN char e_line_number_out_of_range[]\n\tINIT(= N_(\"E1247: Line number out of range\"));\n#ifdef FEAT_EVAL\nEXTERN char e_closure_called_from_invalid_context[]\n\tINIT(= N_(\"E1248: Closure called from invalid context\"));\n#endif\nEXTERN char e_highlight_group_name_too_long[]\n\tINIT(= N_(\"E1249: Highlight group name too long\"));\n#ifdef FEAT_EVAL\nEXTERN char e_argument_of_str_must_be_list_string_dictionary_or_blob[]\n\tINIT(= N_(\"E1250: Argument of %s must be a List, String, Dictionary or Blob\"));\nEXTERN char e_list_dict_blob_or_string_required_for_argument_nr[]\n\tINIT(= N_(\"E1251: List, Dictionary, Blob or String required for argument %d\"));\nEXTERN char e_string_list_or_blob_required_for_argument_nr[]\n\tINIT(= N_(\"E1252: String, List or Blob required for argument %d\"));\nEXTERN char e_string_expected_for_argument_nr[]\n\tINIT(= N_(\"E1253: String expected for argument %d\"));\nEXTERN char e_cannot_use_script_variable_in_for_loop[]\n\tINIT(= N_(\"E1254: Cannot use script variable in for loop\"));\n#endif\nEXTERN char e_cmd_mapping_must_end_with_cr[]\n\tINIT(= N_(\"E1255: <Cmd> mapping must end with <CR>\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_argument_nr[]\n\tINIT(= N_(\"E1256: String or function required for argument %d\"));\nEXTERN char e_imported_script_must_use_as_or_end_in_dot_vim_str[]\n\tINIT(= N_(\"E1257: Imported script must use \\\"as\\\" or end in .vim: %s\"));\nEXTERN char e_no_dot_after_imported_name_str[]\n\tINIT(= N_(\"E1258: No '.' after imported name: %s\"));\nEXTERN char e_missing_name_after_imported_name_str[]\n\tINIT(= N_(\"E1259: Missing name after imported name: %s\"));\nEXTERN char e_cannot_unlet_imported_item_str[]\n\tINIT(= N_(\"E1260: Cannot unlet an imported item: %s\"));\nEXTERN char e_cannot_import_dot_vim_without_using_as[]\n\tINIT(= N_(\"E1261: Cannot import .vim without using \\\"as\\\"\"));\nEXTERN char e_cannot_import_same_script_twice_str[]\n\tINIT(= N_(\"E1262: Cannot import the same script twice: %s\"));\nEXTERN char e_cannot_use_name_with_hash_in_vim9_script_use_export_instead[]\n\tINIT(= N_(\"E1263: Cannot use name with # in Vim9 script, use export instead\"));\nEXTERN char e_autoload_import_cannot_use_absolute_or_relative_path[]\n\tINIT(= N_(\"E1264: Autoload import cannot use absolute or relative path: %s\"));\nEXTERN char e_cannot_use_partial_here[]\n\tINIT(= N_(\"E1265: Cannot use a partial here\"));\n#endif\n#if defined(FEAT_PYTHON3) && defined(MSWIN)\nEXTERN char e_critical_error_in_python3_initialization_check_your_installation[]\n\tINIT(= N_(\"E1266: Critical error in python3 initialization, check your python3 installation\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_function_name_must_start_with_capital_str[]\n\tINIT(= N_(\"E1267: Function name must start with a capital: %s\"));\nEXTERN char e_cannot_use_s_colon_in_vim9_script_str[]\n\tINIT(= N_(\"E1268: Cannot use s: in Vim9 script: %s\"));\nEXTERN char e_cannot_create_vim9_script_variable_in_function_str[]\n\tINIT(= N_(\"E1269: Cannot create a Vim9 script variable in a function: %s\"));\n#endif\nEXTERN char e_cannot_use_s_backslash_in_vim9_script[]\n\tINIT(= N_(\"E1270: Cannot use :s\\\\/sub/ in Vim9 script\"));\n#ifdef FEAT_EVAL\nEXTERN char e_compiling_closure_without_context_str[]\n\tINIT(= N_(\"E1271: Compiling closure without context: %s\"));\nEXTERN char e_using_type_not_in_script_context_str[]\n\tINIT(= N_(\"E1272: Using type not in a script context: %s\"));\n#endif\nEXTERN char e_nfa_regexp_missing_value_in_chr[]\n\tINIT(= N_(\"E1273: (NFA regexp) missing value in '\\\\%%%c'\"));\nEXTERN char e_no_script_file_name_to_substitute_for_script[]\n\tINIT(= N_(\"E1274: No script file name to substitute for \\\"<script>\\\"\"));\n#ifdef FEAT_EVAL\nEXTERN char e_string_or_function_required_for_arrow_parens_expr[]\n\tINIT(= N_(\"E1275: String or function required for ->(expr)\"));\nEXTERN char e_illegal_map_mode_string_str[]\n\tINIT(= N_(\"E1276: Illegal map mode string: '%s'\"));\n# if !defined(FEAT_JOB_CHANNEL)\nEXTERN char e_channel_job_feature_not_available[]\n\tINIT(= N_(\"E1277: Channel and job feature is not available\"));\n# endif\nEXTERN char e_stray_closing_curly_str[]\n\tINIT(= N_(\"E1278: Stray '}' without a matching '{': %s\"));\nEXTERN char e_missing_close_curly_str[]\n\tINIT(= N_(\"E1279: Missing '}': %s\"));\n#endif\n#ifdef FEAT_SPELL\nEXTERN char e_illegal_character_in_word[]\n\tINIT(= N_(\"E1280: Illegal character in word\"));\n#endif\nEXTERN char e_atom_engine_must_be_at_start_of_pattern[]\n\tINIT(= N_(\"E1281: Atom '\\\\%%#=%c' must be at the start of the pattern\"));\n#ifdef FEAT_EVAL\nEXTERN char e_bitshift_ops_must_be_number[]\n\tINIT(= N_(\"E1282: Bitshift operands must be numbers\"));\nEXTERN char e_bitshift_ops_must_be_postive[]\n\tINIT(= N_(\"E1283: Bitshift amount must be a positive number\"));\n#endif\n#if defined(FEAT_PROP_POPUP)\nEXTERN char e_argument_1_list_item_nr_dictionary_required[]\n\tINIT(= N_(\"E1284: Argument 1, list item %d: Dictionary required\"));\n#endif\n#ifdef FEAT_RELTIME\nEXTERN char e_could_not_clear_timeout_str[]\n\tINIT(= N_(\"E1285: Could not clear timeout: %s\"));\nEXTERN char e_could_not_set_timeout_str[]\n\tINIT(= N_(\"E1286: Could not set timeout: %s\"));\nEXTERN char e_could_not_set_handler_for_timeout_str[]\n\tINIT(= N_(\"E1287: Could not set handler for timeout: %s\"));\nEXTERN char e_could_not_reset_handler_for_timeout_str[]\n\tINIT(= N_(\"E1288: Could not reset handler for timeout: %s\"));\nEXTERN char e_could_not_check_for_pending_sigalrm_str[]\n\tINIT(= N_(\"E1289: Could not check for pending SIGALRM: %s\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_substitute_nesting_too_deep[]\n\tINIT(= N_(\"E1290: substitute nesting too deep\"));\nEXTERN char e_invalid_argument_nr[]\n\tINIT(= N_(\"E1291: Invalid argument: %ld\"));\n#endif\n#ifdef FEAT_CMDWIN\nEXTERN char e_cmdline_window_already_open[]\n\tINIT(= N_(\"E1292: Command-line window is already open\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_use_negative_id_after_adding_textprop_with_text[]\n\tINIT(= N_(\"E1293: Cannot use a negative id after adding a textprop with text\"));\nEXTERN char e_can_only_use_text_align_when_column_is_zero[]\n\tINIT(= N_(\"E1294: Can only use text_align when column is zero\"));\n#endif\n#ifdef FEAT_PROP_POPUP\nEXTERN char e_cannot_specify_both_type_and_types[]\n\tINIT(= N_(\"E1295: Cannot specify both 'type' and 'types'\"));\nEXTERN char e_can_only_use_left_padding_when_column_is_zero[]\n\tINIT(= N_(\"E1296: Can only use left padding when column is zero\"));\n#endif\n#ifdef FEAT_EVAL\nEXTERN char e_non_null_dict_required_for_argument_nr[]\n\tINIT(= N_(\"E1297: Non-NULL Dictionary required for argument %d\"));\nEXTERN char e_non_null_list_required_for_argument_nr[]\n\tINIT(= N_(\"E1298: Non-NULL List required for argument %d\"));\n#endif\nEXTERN char e_window_unexpectedly_close_while_searching_for_tags[]\n\tINIT(= N_(\"E1299: Window unexpectedly closed while searching for tags\"));\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle tags and the tag stack\n */\n\n#include \"vim.h\"\n\n/*\n * Structure to hold pointers to various items in a tag line.\n */\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n/*\n * Return values used when reading lines from a tags file.\n */\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n} tags_read_status_T;\n\n/*\n * States used during a tags search\n */\ntypedef enum\n{\n    TS_START,\t\t// at start of file\n    TS_LINEAR,\t\t// linear searching forward, till EOF\n    TS_BINARY,\t\t// binary searching\n    TS_SKIP_BACK,\t// skipping backwards\n    TS_STEP_FORWARD\t// stepping forwards\n} tagsearch_state_T;\t// Current search state\n\n/*\n * Binary search file offsets in a tags file\n */\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n} tagsearch_info_T;\n\n/*\n * Return values used when matching tags against a pattern.\n */\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n} tagmatch_status_T;\n\n/*\n * Arguments used for matching tags read from a tags file against a pattern.\n */\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n} findtags_match_args_T;\n\n/*\n * The matching tags are first stored in one of the hash tables.  In\n * which one depends on the priority of the match.\n * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.\n * At the end, all the matches from ga_match[] are concatenated, to make a list\n * sorted on priority.\n */\n#define MT_ST_CUR\t0\t\t// static match in current file\n#define MT_GL_CUR\t1\t\t// global match in current file\n#define MT_GL_OTH\t2\t\t// global match in other file\n#define MT_ST_OTH\t3\t\t// static match in other file\n#define MT_IC_OFF\t4\t\t// add for icase match\n#define MT_RE_OFF\t8\t\t// add for regexp match\n#define MT_MASK\t\t7\t\t// mask for printing priority\n#define MT_COUNT\t16\n\nstatic char\t*mt_names[MT_COUNT/2] =\n\t\t{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};\n\n#define NOTAGFILE\t99\t\t// return value for jumpto_tag\nstatic char_u\t*nofile_fname = NULL;\t// fname for NOTAGFILE error\n\nstatic void taglen_advance(int l);\n\nstatic int jumpto_tag(char_u *lbuf, int forceit, int keep_help);\n#ifdef FEAT_EMACS_TAGS\nstatic int parse_tag_line(char_u *lbuf, int is_etag, tagptrs_T *tagp);\n#else\nstatic int parse_tag_line(char_u *lbuf, tagptrs_T *tagp);\n#endif\nstatic int test_for_static(tagptrs_T *);\nstatic int parse_match(char_u *lbuf, tagptrs_T *tagp);\nstatic char_u *tag_full_fname(tagptrs_T *tagp);\nstatic char_u *expand_tag_fname(char_u *fname, char_u *tag_fname, int expand);\n#ifdef FEAT_EMACS_TAGS\nstatic int test_for_current(int, char_u *, char_u *, char_u *, char_u *);\n#else\nstatic int test_for_current(char_u *, char_u *, char_u *, char_u *);\n#endif\nstatic int find_extra(char_u **pp);\nstatic void print_tag_list(int new_tag, int use_tagstack, int num_matches, char_u **matches);\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\nstatic int add_llist_tags(char_u *tag, int num_matches, char_u **matches);\n#endif\nstatic void tagstack_clear_entry(taggy_T *item);\n\nstatic char_u\t*tagmatchname = NULL;\t// name of last used tag\n\n#if defined(FEAT_QUICKFIX)\n/*\n * Tag for preview window is remembered separately, to avoid messing up the\n * normal tagstack.\n */\nstatic taggy_T ptag_entry = {NULL, {{0, 0, 0}, 0}, 0, 0, NULL};\n#endif\n\n#ifdef FEAT_EVAL\nstatic int  tfu_in_use = FALSE;\t    // disallow recursive call of tagfunc\nstatic callback_T tfu_cb;\t    // 'tagfunc' callback function\n#endif\n\n// Used instead of NUL to separate tag fields in the growarrays.\n#define TAG_SEP 0x02\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Reads the 'tagfunc' option value and convert that to a callback value.\n * Invoked when the 'tagfunc' option is set. The option value can be a name of\n * a function (string), or function(<name>) or funcref(<name>) or a lambda.\n */\n    int\nset_tagfunc_option(void)\n{\n#ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n    free_callback(&curbuf->b_tfu_cb);\n\n    if (*curbuf->b_p_tfu == NUL)\n\treturn OK;\n\n    if (option_set_callback_func(curbuf->b_p_tfu, &tfu_cb) == FAIL)\n\treturn FAIL;\n\n    copy_callback(&curbuf->b_tfu_cb, &tfu_cb);\n#endif\n\n    return OK;\n}\n#endif\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tagfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n# endif\n}\n# endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'tagfunc' callback with 'copyID' so that it is not garbage\n * collected.\n */\n    int\nset_ref_in_tagfunc(int copyID UNUSED)\n{\n    int\tabort = FALSE;\n\n    abort = set_ref_in_callback(&tfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Copy the global 'tagfunc' callback function to the buffer-local 'tagfunc'\n * callback for 'buf'.\n */\n    void\nset_buflocal_tfu_callback(buf_T *buf UNUSED)\n{\n    free_callback(&buf->b_tfu_cb);\n    if (tfu_cb.cb_name != NULL && *tfu_cb.cb_name != NUL)\n\tcopy_callback(&buf->b_tfu_cb, &tfu_cb);\n}\n#endif\n\n/*\n * Jump to tag; handling of tag commands and tag stack\n *\n * *tag != NUL: \":tag {tag}\", jump to new tag, add to tag stack\n *\n * type == DT_TAG:\t\":tag [tag]\", jump to newer position or same tag again\n * type == DT_HELP:\tlike DT_TAG, but don't use regexp.\n * type == DT_POP:\t\":pop\" or CTRL-T, jump to old position\n * type == DT_NEXT:\tjump to next match of same tag\n * type == DT_PREV:\tjump to previous match of same tag\n * type == DT_FIRST:\tjump to first match of same tag\n * type == DT_LAST:\tjump to last match of same tag\n * type == DT_SELECT:\t\":tselect [tag]\", select tag from a list of all matches\n * type == DT_JUMP:\t\":tjump [tag]\", jump to tag or select tag from a list\n * type == DT_CSCOPE:\tuse cscope to find the tag\n * type == DT_LTAG:\tuse location list for displaying tag matches\n * type == DT_FREE:\tfree cached matches\n *\n * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise\n */\n    int\ndo_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // A tag function may do anything, which may cause various\n\t    // information to become invalid.  At least check for the tagstack\n\t    // to still be the same.\n\t    if (tagstack != curwin->w_tagstack)\n\t    {\n\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\t\tFreeWild(new_num_matches, new_matches);\n\t\tbreak;\n\t    }\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * List all the matching tags.\n */\n    static void\nprint_tag_list(\n    int\t\tnew_tag,\n    int\t\tuse_tagstack,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*command_end;\n    tagptrs_T\ttagp;\n    int\t\ttaglen;\n    int\t\tattr;\n\n    /*\n     * Assume that the first match indicates how long the tags can\n     * be, and align the file names to that.\n     */\n    parse_match(matches[0], &tagp);\n    taglen = (int)(tagp.tagname_end - tagp.tagname + 2);\n    if (taglen < 18)\n\ttaglen = 18;\n    if (taglen > Columns - 25)\n\ttaglen = MAXCOL;\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\t// overwrite previous message\n    msg_start();\n    msg_puts_attr(_(\"  # pri kind tag\"), HL_ATTR(HLF_T));\n    msg_clr_eos();\n    taglen_advance(taglen);\n    msg_puts_attr(_(\"file\\n\"), HL_ATTR(HLF_T));\n\n    for (i = 0; i < num_matches && !got_int; ++i)\n    {\n\tparse_match(matches[i], &tagp);\n\tif (!new_tag && (\n#if defined(FEAT_QUICKFIX)\n\t\t    (g_do_tagpreview != 0\n\t\t     && i == ptag_entry.cur_match) ||\n#endif\n\t\t    (use_tagstack\n\t\t     && i == tagstack[tagstackidx].cur_match)))\n\t    *IObuff = '>';\n\telse\n\t    *IObuff = ' ';\n\tvim_snprintf((char *)IObuff + 1, IOSIZE - 1,\n\t\t\"%2d %s \", i + 1,\n\t\t\t       mt_names[matches[i][0] & MT_MASK]);\n\tmsg_puts((char *)IObuff);\n\tif (tagp.tagkind != NULL)\n\t    msg_outtrans_len(tagp.tagkind,\n\t\t\t  (int)(tagp.tagkind_end - tagp.tagkind));\n\tmsg_advance(13);\n\tmsg_outtrans_len_attr(tagp.tagname,\n\t\t\t   (int)(tagp.tagname_end - tagp.tagname),\n\t\t\t\t\t\t  HL_ATTR(HLF_T));\n\tmsg_putchar(' ');\n\ttaglen_advance(taglen);\n\n\t// Find out the actual file name. If it is long, truncate\n\t// it and put \"...\" in the middle\n\tp = tag_full_fname(&tagp);\n\tif (p != NULL)\n\t{\n\t    msg_outtrans_long_attr(p, HL_ATTR(HLF_D));\n\t    vim_free(p);\n\t}\n\tif (msg_col > 0)\n\t    msg_putchar('\\n');\n\tif (got_int)\n\t    break;\n\tmsg_advance(15);\n\n\t// print any extra fields\n\tcommand_end = tagp.command_end;\n\tif (command_end != NULL)\n\t{\n\t    p = command_end + 3;\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t    {\n\t\twhile (*p == TAB)\n\t\t    ++p;\n\n\t\t// skip \"file:\" without a value (static tag)\n\t\tif (STRNCMP(p, \"file:\", 5) == 0\n\t\t\t\t\t     && vim_isspace(p[5]))\n\t\t{\n\t\t    p += 5;\n\t\t    continue;\n\t\t}\n\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\tif (p == tagp.tagkind\n\t\t\t|| (p + 5 == tagp.tagkind\n\t\t\t\t&& STRNCMP(p, \"kind:\", 5) == 0))\n\t\t{\n\t\t    p = tagp.tagkind_end;\n\t\t    continue;\n\t\t}\n\t\t// print all other extra fields\n\t\tattr = HL_ATTR(HLF_CM);\n\t\twhile (*p && *p != '\\r' && *p != '\\n')\n\t\t{\n\t\t    if (msg_col + ptr2cells(p) >= Columns)\n\t\t    {\n\t\t\tmsg_putchar('\\n');\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t\tmsg_advance(15);\n\t\t    }\n\t\t    p = msg_outtrans_one(p, attr);\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tmsg_puts_attr(\" \", attr);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*p == ':')\n\t\t\tattr = 0;\n\t\t}\n\t    }\n\t    if (msg_col > 15)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    break;\n\t\tmsg_advance(15);\n\t    }\n\t}\n\telse\n\t{\n\t    for (p = tagp.command;\n\t\t\t      *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t;\n\t    command_end = p;\n\t}\n\n\t// Put the info (in several lines) at column 15.\n\t// Don't display \"/^\" and \"?^\".\n\tp = tagp.command;\n\tif (*p == '/' || *p == '?')\n\t{\n\t    ++p;\n\t    if (*p == '^')\n\t\t++p;\n\t}\n\t// Remove leading whitespace from pattern\n\twhile (p != command_end && vim_isspace(*p))\n\t    ++p;\n\n\twhile (p != command_end)\n\t{\n\t    if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)\n\t\tmsg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_advance(15);\n\n\t    // skip backslash used for escaping a command char or\n\t    // a backslash\n\t    if (*p == '\\\\' && (*(p + 1) == *tagp.command\n\t\t\t    || *(p + 1) == '\\\\'))\n\t\t++p;\n\n\t    if (*p == TAB)\n\t    {\n\t\tmsg_putchar(' ');\n\t\t++p;\n\t    }\n\t    else\n\t\tp = msg_outtrans_one(p, 0);\n\n\t    // don't display the \"$/;\\\"\" and \"$?;\\\"\"\n\t    if (p == command_end - 2 && *p == '$'\n\t\t\t\t     && *(p + 1) == *tagp.command)\n\t\tbreak;\n\t    // don't display matching '/' or '?'\n\t    if (p == command_end - 1 && *p == *tagp.command\n\t\t\t\t     && (*p == '/' || *p == '?'))\n\t\tbreak;\n\t}\n\tif (msg_col)\n\t    msg_putchar('\\n');\n\tui_breakcheck();\n    }\n    if (got_int)\n\tgot_int = FALSE;\t// only stop the listing\n}\n\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n/*\n * Add the matching tags to the location list for the current\n * window.\n */\n    static int\nadd_llist_tags(\n    char_u\t*tag,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    list_T\t*list;\n    char_u\ttag_name[128 + 1];\n    char_u\t*fname;\n    char_u\t*cmd;\n    int\t\ti;\n    char_u\t*p;\n    tagptrs_T\ttagp;\n\n    fname = alloc(MAXPATHL + 1);\n    cmd = alloc(CMDBUFFSIZE + 1);\n    list = list_alloc();\n    if (list == NULL || fname == NULL || cmd == NULL)\n    {\n\tvim_free(cmd);\n\tvim_free(fname);\n\tif (list != NULL)\n\t    list_free(list);\n\treturn FAIL;\n    }\n\n    for (i = 0; i < num_matches; ++i)\n    {\n\tint\t    len, cmd_len;\n\tlong    lnum;\n\tdict_T  *dict;\n\n\tparse_match(matches[i], &tagp);\n\n\t// Save the tag name\n\tlen = (int)(tagp.tagname_end - tagp.tagname);\n\tif (len > 128)\n\t    len = 128;\n\tvim_strncpy(tag_name, tagp.tagname, len);\n\ttag_name[len] = NUL;\n\n\t// Save the tag file name\n\tp = tag_full_fname(&tagp);\n\tif (p == NULL)\n\t    continue;\n\tvim_strncpy(fname, p, MAXPATHL);\n\tvim_free(p);\n\n\t// Get the line number or the search pattern used to locate\n\t// the tag.\n\tlnum = 0;\n\tif (isdigit(*tagp.command))\n\t    // Line number is used to locate the tag\n\t    lnum = atol((char *)tagp.command);\n\telse\n\t{\n\t    char_u *cmd_start, *cmd_end;\n\n\t    // Search pattern is used to locate the tag\n\n\t    // Locate the end of the command\n\t    cmd_start = tagp.command;\n\t    cmd_end = tagp.command_end;\n\t    if (cmd_end == NULL)\n\t    {\n\t\tfor (p = tagp.command;\n\t\t     *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t    ;\n\t\tcmd_end = p;\n\t    }\n\n\t    // Now, cmd_end points to the character after the\n\t    // command. Adjust it to point to the last\n\t    // character of the command.\n\t    cmd_end--;\n\n\t    // Skip the '/' and '?' characters at the\n\t    // beginning and end of the search pattern.\n\t    if (*cmd_start == '/' || *cmd_start == '?')\n\t\tcmd_start++;\n\n\t    if (*cmd_end == '/' || *cmd_end == '?')\n\t\tcmd_end--;\n\n\t    len = 0;\n\t    cmd[0] = NUL;\n\n\t    // If \"^\" is present in the tag search pattern, then\n\t    // copy it first.\n\t    if (*cmd_start == '^')\n\t    {\n\t\tSTRCPY(cmd, \"^\");\n\t\tcmd_start++;\n\t\tlen++;\n\t    }\n\n\t    // Precede the tag pattern with \\V to make it very\n\t    // nomagic.\n\t    STRCAT(cmd, \"\\\\V\");\n\t    len += 2;\n\n\t    cmd_len = (int)(cmd_end - cmd_start + 1);\n\t    if (cmd_len > (CMDBUFFSIZE - 5))\n\t\tcmd_len = CMDBUFFSIZE - 5;\n\t    STRNCAT(cmd, cmd_start, cmd_len);\n\t    len += cmd_len;\n\n\t    if (cmd[len - 1] == '$')\n\t    {\n\t\t// Replace '$' at the end of the search pattern\n\t\t// with '\\$'\n\t\tcmd[len - 1] = '\\\\';\n\t\tcmd[len] = '$';\n\t\tlen++;\n\t    }\n\n\t    cmd[len] = NUL;\n\t}\n\n\tif ((dict = dict_alloc()) == NULL)\n\t    continue;\n\tif (list_append_dict(list, dict) == FAIL)\n\t{\n\t    vim_free(dict);\n\t    continue;\n\t}\n\n\tdict_add_string(dict, \"text\", tag_name);\n\tdict_add_string(dict, \"filename\", fname);\n\tdict_add_number(dict, \"lnum\", lnum);\n\tif (lnum == 0)\n\t    dict_add_string(dict, \"pattern\", cmd);\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, \"ltag %s\", tag);\n    set_errorlist(curwin, list, ' ', IObuff, NULL);\n\n    list_free(list);\n    vim_free(fname);\n    vim_free(cmd);\n\n    return OK;\n}\n#endif\n\n/*\n * Free cached tags.\n */\n    void\ntag_freematch(void)\n{\n    VIM_CLEAR(tagmatchname);\n}\n\n    static void\ntaglen_advance(int l)\n{\n    if (l == MAXCOL)\n    {\n\tmsg_putchar('\\n');\n\tmsg_advance(24);\n    }\n    else\n\tmsg_advance(13 + l);\n}\n\n/*\n * Print the tag stack\n */\n    void\ndo_tags(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));\n    for (i = 0; i < tagstacklen; ++i)\n    {\n\tif (tagstack[i].tagname != NULL)\n\t{\n\t    name = fm_getname(&(tagstack[i].fmark), 30);\n\t    if (name == NULL)\t    // file name not available\n\t\tcontinue;\n\n\t    msg_putchar('\\n');\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%c%2d %2d %-15s %5ld  \",\n\t\ti == tagstackidx ? '>' : ' ',\n\t\ti + 1,\n\t\ttagstack[i].cur_match + 1,\n\t\ttagstack[i].tagname,\n\t\ttagstack[i].fmark.mark.lnum);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t}\n\tout_flush();\t\t    // show one line at a time\n    }\n    if (tagstackidx == tagstacklen)\t// idx at top of stack\n\tmsg_puts(\"\\n>\");\n}\n\n/*\n * Compare two strings, for length \"len\", ignoring case the ASCII way.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n */\n    static int\ntag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOUPPER_ASC(*s1) - (int)TOUPPER_ASC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t// this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t// strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t// strings match\n}\n\n/*\n * Structure to hold info about the tag pattern being used.\n */\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n} pat_T;\n\n/*\n * Extract info from the tag search pattern \"pats->pat\".\n */\n    static void\nprepare_pats(pat_T *pats, int has_re)\n{\n    pats->head = pats->pat;\n    pats->headlen = pats->len;\n    if (has_re)\n    {\n\t// When the pattern starts with '^' or \"\\\\<\", binary searching can be\n\t// used (much faster).\n\tif (pats->pat[0] == '^')\n\t    pats->head = pats->pat + 1;\n\telse if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')\n\t    pats->head = pats->pat + 2;\n\tif (pats->head == pats->pat)\n\t    pats->headlen = 0;\n\telse\n\t    for (pats->headlen = 0; pats->head[pats->headlen] != NUL;\n\t\t\t\t\t\t\t      ++pats->headlen)\n\t\tif (vim_strchr((char_u *)(magic_isset() ? \".[~*\\\\$\" : \"\\\\$\"),\n\t\t\t\t\t   pats->head[pats->headlen]) != NULL)\n\t\t    break;\n\tif (p_tl != 0 && pats->headlen > p_tl)\t// adjust for 'taglength'\n\t    pats->headlen = p_tl;\n    }\n\n    if (has_re)\n\tpats->regmatch.regprog = vim_regcomp(pats->pat,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n    else\n\tpats->regmatch.regprog = NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call the user-defined function to generate a list of tags used by\n * find_tags().\n *\n * Return OK if at least 1 tag has been successfully found,\n * NOTDONE if the function returns v:null, and FAIL otherwise.\n */\n    static int\nfind_tagfunc_tags(\n    char_u\t*pat,\t\t// pattern supplied to the user-defined function\n    garray_T\t*ga,\t\t// the tags will be placed here\n    int\t\t*match_count,\t// here the number of tags found will be placed\n    int\t\tflags,\t\t// flags from find_tags (TAG_*)\n    char_u\t*buf_ffname)\t// name of buffer for priority\n{\n    pos_T       save_pos;\n    list_T      *taglist;\n    listitem_T  *item;\n    int\t\tntags = 0;\n    int\t\tresult = FAIL;\n    typval_T\targs[4];\n    typval_T\trettv;\n    char_u      flagString[4];\n    dict_T\t*d;\n    taggy_T\t*tag = &curwin->w_tagstack[curwin->w_tagstackidx];\n\n    if (*curbuf->b_p_tfu == NUL || curbuf->b_tfu_cb.cb_name == NULL\n\t\t\t\t\t   || *curbuf->b_tfu_cb.cb_name == NUL)\n\treturn FAIL;\n\n    args[0].v_type = VAR_STRING;\n    args[0].vval.v_string = pat;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = flagString;\n\n    // create 'info' dict argument\n    if ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\treturn FAIL;\n    if (tag->user_data != NULL)\n\tdict_add_string(d, \"user_data\", tag->user_data);\n    if (buf_ffname != NULL)\n\tdict_add_string(d, \"buf_ffname\", buf_ffname);\n\n    ++d->dv_refcount;\n    args[2].v_type = VAR_DICT;\n    args[2].vval.v_dict = d;\n\n    args[3].v_type = VAR_UNKNOWN;\n\n    vim_snprintf((char *)flagString, sizeof(flagString),\n\t\t \"%s%s%s\",\n\t\t g_tag_at_cursor      ? \"c\": \"\",\n\t\t flags & TAG_INS_COMP ? \"i\": \"\",\n\t\t flags & TAG_REGEXP   ? \"r\": \"\");\n\n    save_pos = curwin->w_cursor;\n    result = call_callback(&curbuf->b_tfu_cb, 0, &rettv, 3, args);\n    curwin->w_cursor = save_pos;\t// restore the cursor position\n    --d->dv_refcount;\n\n    if (result == FAIL)\n\treturn FAIL;\n    if (rettv.v_type == VAR_SPECIAL && rettv.vval.v_number == VVAL_NULL)\n    {\n\tclear_tv(&rettv);\n\treturn NOTDONE;\n    }\n    if (rettv.v_type != VAR_LIST || !rettv.vval.v_list)\n    {\n\tclear_tv(&rettv);\n\temsg(_(e_invalid_return_value_from_tagfunc));\n\treturn FAIL;\n    }\n    taglist = rettv.vval.v_list;\n\n    FOR_ALL_LIST_ITEMS(taglist, item)\n    {\n\tchar_u\t\t*mfp;\n\tchar_u\t\t*res_name, *res_fname, *res_cmd, *res_kind;\n\tint\t\tlen;\n\tdict_iterator_T\titer;\n\tchar_u\t\t*dict_key;\n\ttypval_T\t*tv;\n\tint\t\thas_extra = 0;\n\tint\t\tname_only = flags & TAG_NAMES;\n\n\tif (item->li_tv.v_type != VAR_DICT)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n#ifdef FEAT_EMACS_TAGS\n\tlen = 3;\n#else\n\tlen = 2;\n#endif\n\tres_name = NULL;\n\tres_fname = NULL;\n\tres_cmd = NULL;\n\tres_kind = NULL;\n\n\tdict_iterate_start(&item->li_tv, &iter);\n\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t{\n\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\tcontinue;\n\n\t    len += (int)STRLEN(tv->vval.v_string) + 1;   // Space for \"\\tVALUE\"\n\t    if (!STRCMP(dict_key, \"name\"))\n\t    {\n\t\tres_name = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"filename\"))\n\t    {\n\t\tres_fname = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"cmd\"))\n\t    {\n\t\tres_cmd = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    has_extra = 1;\n\t    if (!STRCMP(dict_key, \"kind\"))\n\t    {\n\t\tres_kind = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    // Other elements will be stored as \"\\tKEY:VALUE\"\n\t    // Allocate space for the key and the colon\n\t    len += (int)STRLEN(dict_key) + 1;\n\t}\n\n\tif (has_extra)\n\t    len += 2;\t// need space for ;\"\n\n\tif (!res_name || !res_fname || !res_cmd)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n\tif (name_only)\n\t    mfp = vim_strsave(res_name);\n\telse\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\n\tif (mfp == NULL)\n\t    continue;\n\n\tif (!name_only)\n\t{\n\t    char_u *p = mfp;\n\n\t    *p++ = MT_GL_OTH + 1;   // mtt\n\t    *p++ = TAG_SEP;\t    // no tag file name\n#ifdef FEAT_EMACS_TAGS\n\t    *p++ = TAG_SEP;\n#endif\n\n\t    STRCPY(p, res_name);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_fname);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_cmd);\n\t    p += STRLEN(p);\n\n\t    if (has_extra)\n\t    {\n\t\tSTRCPY(p, \";\\\"\");\n\t\tp += STRLEN(p);\n\n\t\tif (res_kind)\n\t\t{\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, res_kind);\n\t\t    p += STRLEN(p);\n\t\t}\n\n\t\tdict_iterate_start(&item->li_tv, &iter);\n\t\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t\t{\n\t\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\t\tcontinue;\n\n\t\t    if (!STRCMP(dict_key, \"name\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"filename\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"cmd\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"kind\"))\n\t\t\tcontinue;\n\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, dict_key);\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, \":\");\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, tv->vval.v_string);\n\t\t    p += STRLEN(p);\n\t\t}\n\t    }\n\t}\n\n\t// Add all matches because tagfunc should do filtering.\n\tif (ga_grow(ga, 1) == OK)\n\t{\n\t    ((char_u **)(ga->ga_data))[ga->ga_len++] = mfp;\n\t    ++ntags;\n\t    result = OK;\n\t}\n\telse\n\t{\n\t    vim_free(mfp);\n\t    break;\n\t}\n    }\n\n    clear_tv(&rettv);\n\n    *match_count = ntags;\n    return result;\n}\n#endif\n\n/*\n * State information used during a tag search\n */\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help language priority\n    char_u\t*help_lang_find;\t// lang to be found\n    int\t\tis_txt;\t\t\t// flag of file extension\n#endif\n    int\t\tmatch_count;\t\t// number of matches found\n    garray_T\tga_match[MT_COUNT];\t// stores matches in sequence\n    hashtab_T\tht_match[MT_COUNT];\t// stores matches by key\n} findtags_state_T;\n\n/*\n * Initialize the state used by find_tags().\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    static int\nfindtags_state_init(\n    findtags_state_T\t*st,\n    char_u\t\t*pat,\n    int\t\t\tflags,\n    int\t\t\tmincount)\n{\n    int\t\tmtt;\n\n    st->tag_fname = alloc(MAXPATHL + 1);\n    st->fp = NULL;\n    st->orgpat = ALLOC_ONE(pat_T);\n    st->orgpat->pat = pat;\n    st->orgpat->len = (int)STRLEN(pat);\n    st->orgpat->regmatch.regprog = NULL;\n    st->flags = flags;\n    st->tag_file_sorted = NUL;\n    st->help_only = (flags & TAG_HELP);\n    st->get_searchpat = FALSE;\n#ifdef FEAT_MULTI_LANG\n    st->help_lang[0] = NUL;\n    st->help_pri = 0;\n    st->help_lang_find = NULL;\n    st->is_txt = FALSE;\n#endif\n    st->did_open = FALSE;\n    st->mincount = mincount;\n    st->lbuf_size = LSIZE;\n    st->lbuf = alloc(st->lbuf_size);\n#ifdef FEAT_EMACS_TAGS\n    st->ebuf = alloc(LSIZE);\n#endif\n    st->match_count = 0;\n    st->stop_searching = FALSE;\n\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tga_init2(&st->ga_match[mtt], sizeof(char_u *), 100);\n\thash_init(&st->ht_match[mtt]);\n    }\n\n    // check for out of memory situation\n    if (st->tag_fname == NULL\n\t    || st->lbuf == NULL\n#ifdef FEAT_EMACS_TAGS\n\t    || st->ebuf == NULL\n#endif\n       )\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the state used by find_tags()\n */\n    static void\nfindtags_state_free(findtags_state_T *st)\n{\n    vim_free(st->tag_fname);\n    vim_free(st->lbuf);\n    vim_regfree(st->orgpat->regmatch.regprog);\n    vim_free(st->orgpat);\n#ifdef FEAT_EMACS_TAGS\n    vim_free(st->ebuf);\n#endif\n}\n\n#ifdef FEAT_MULTI_LANG\n/*\n * Initialize the language and priority used for searching tags in a Vim help\n * file.\n * Returns TRUE to process the help file for tags and FALSE to skip the file.\n */\n    static int\nfindtags_in_help_init(findtags_state_T *st)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    // Keep 'en' as the language if the file extension is '.txt'\n    if (st->is_txt)\n\tSTRCPY(st->help_lang, \"en\");\n    else\n    {\n\t// Prefer help tags according to 'helplang'.  Put the two-letter\n\t// language name in help_lang[].\n\ti = (int)STRLEN(st->tag_fname);\n\tif (i > 3 && st->tag_fname[i - 3] == '-')\n\t    vim_strncpy(st->help_lang, st->tag_fname + i - 2, 2);\n\telse\n\t    STRCPY(st->help_lang, \"en\");\n    }\n    // When searching for a specific language skip tags files for other\n    // languages.\n    if (st->help_lang_find != NULL\n\t    && STRICMP(st->help_lang, st->help_lang_find) != 0)\n\treturn FALSE;\n\n    // For CTRL-] in a help file prefer a match with the same language.\n    if ((st->flags & TAG_KEEP_LANG)\n\t    && st->help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && curbuf->b_fname[i - 1] == 'x'\n\t    && curbuf->b_fname[i - 4] == '.'\n\t    && STRNICMP(curbuf->b_fname + i - 3, st->help_lang, 2) == 0)\n\tst->help_pri = 0;\n    else\n    {\n\t// search for the language in 'helplang'\n\tst->help_pri = 1;\n\tfor (s = p_hlg; *s != NUL; ++s)\n\t{\n\t    if (STRNICMP(s, st->help_lang, 2) == 0)\n\t\tbreak;\n\t    ++st->help_pri;\n\t    if ((s = vim_strchr(s, ',')) == NULL)\n\t\tbreak;\n\t}\n\tif (s == NULL || *s == NUL)\n\t{\n\t    // Language not in 'helplang': use last, prefer English, unless\n\t    // found already.\n\t    ++st->help_pri;\n\t    if (STRICMP(st->help_lang, \"en\") != 0)\n\t\t++st->help_pri;\n\t}\n    }\n\n    return TRUE;\n}\n#endif\n\n#ifdef FEAT_EVAL\n/*\n * Use the function set in 'tagfunc' (if configured and enabled) to get the\n * tags.\n * Return OK if at least 1 tag has been successfully found, NOTDONE if the\n * 'tagfunc' is not used or the 'tagfunc' returns v:null and FAIL otherwise.\n */\n    static int\nfindtags_apply_tfu(findtags_state_T *st, char_u *pat, char_u *buf_ffname)\n{\n    int\t\tuse_tfu = ((st->flags & TAG_NO_TAGFUNC) == 0);\n    int\t\tretval;\n\n    if (!use_tfu || tfu_in_use || *curbuf->b_p_tfu == NUL)\n\treturn NOTDONE;\n\n    tfu_in_use = TRUE;\n    retval = find_tagfunc_tags(pat, st->ga_match, &st->match_count,\n\t\t\t\t\t\tst->flags, buf_ffname);\n    tfu_in_use = FALSE;\n\n    return retval;\n}\n#endif\n\n#ifdef FEAT_EMACS_TAGS\n/*\n * Stack for included emacs-tags file.\n * It has a fixed size, to truncate cyclic includes. jw\n */\n# define INCSTACK_SIZE 42\nstatic struct\n{\n    FILE\t*fp;\n    char_u\t*etag_fname;\n} incstack[INCSTACK_SIZE];\nstatic int incstack_idx = 0;\t// index in incstack\n\n/*\n * Free the emacs include tags file stack.\n */\n    static void\nemacs_tags_incstack_free(void)\n{\n    while (incstack_idx)\n    {\n\t--incstack_idx;\n\tfclose(incstack[incstack_idx].fp);\n\tincstack[incstack_idx].fp = NULL;\n\tVIM_CLEAR(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Emacs tags line with CTRL-L: New file name on next line.\n * The file name is followed by a ','.  Remember etag file name in ebuf.\n * The FILE pointer to the tags file is stored in 'st->fp'.  If another tags\n * file is included, then the FILE pointer to the new tags file is stored in\n * 'st->fp'. The old file pointer is saved in incstack.\n */\n    static void\nemacs_tags_new_filename(findtags_state_T *st)\n{\n    char_u\t*p;\n    char_u\t*fullpath_ebuf;\n\n    if (vim_fgets(st->ebuf, LSIZE, st->fp))\n\treturn;\n\n    for (p = st->ebuf; *p && *p != ','; p++)\n\t;\n    *p = NUL;\n\n    // check for an included tags file.\n    // atoi(p+1) is the number of bytes before the next ^L unless it is an\n    // include statement. Skip the included tags file if it exceeds the\n    // maximum.\n    if (STRNCMP(p + 1, \"include\", 7) != 0 || incstack_idx >= INCSTACK_SIZE)\n\treturn;\n\n    // Save current \"fp\" and \"tag_fname\" in the stack.\n    incstack[incstack_idx].etag_fname = vim_strsave(st->tag_fname);\n    if (incstack[incstack_idx].etag_fname == NULL)\n\treturn;\n\n    incstack[incstack_idx].fp = st->fp;\n    st->fp = NULL;\n\n    // Figure out \"tag_fname\" and \"fp\" to use for\n    // included file.\n    fullpath_ebuf = expand_tag_fname(st->ebuf, st->tag_fname, FALSE);\n    if (fullpath_ebuf != NULL)\n    {\n\tst->fp = mch_fopen((char *)fullpath_ebuf, \"r\");\n\tif (st->fp != NULL)\n\t{\n\t    if (STRLEN(fullpath_ebuf) > LSIZE)\n\t\tsemsg(_(e_tag_file_path_truncated_for_str), st->ebuf);\n\t    vim_strncpy(st->tag_fname, fullpath_ebuf, MAXPATHL);\n\t    ++incstack_idx;\n\t    st->is_etag = FALSE; // we can include anything\n\t}\n\tvim_free(fullpath_ebuf);\n    }\n    if (st->fp == NULL)\n    {\n\t// Can't open the included file, skip it and\n\t// restore old value of \"fp\".\n\tst->fp = incstack[incstack_idx].fp;\n\tvim_free(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Reached the end of an emacs-style tags file. If this is an included tags\n * file, then pop it from the incstack and continue processing the parent tags\n * file. Otherwise, processed all the tags.\n * Returns TRUE if an included tags file is popped and processing should\n * continue with the parent tags file. Returns FALSE to stop processing tags.\n */\n    static int\nemacs_tags_file_eof(findtags_state_T *st)\n{\n    if (!incstack_idx)\t// reached end of file. stop processing.\n\treturn FALSE;\n\n    // reached the end of an included tags file. pop it.\n    --incstack_idx;\n    fclose(st->fp);\t// end of this file ...\n    st->fp = incstack[incstack_idx].fp;\n    STRCPY(st->tag_fname, incstack[incstack_idx].etag_fname);\n    vim_free(incstack[incstack_idx].etag_fname);\n    st->is_etag = TRUE;\t// (only etags can include)\n\n    return TRUE;\n}\n\n/*\n * Parse a line from an emacs-style tags file.\n * Returns OK if the line is parsed successfully, returns FAIL if the line is\n * not terminated by a newline.\n */\n    static int\nemacs_tags_parse_line(char_u *lbuf, tagptrs_T *tagp)\n{\n    char_u\t*p_7f;\n    char_u\t*p;\n\n    // There are two formats for an emacs tag line:\n    // 1:  struct EnvBase ^?EnvBase^A139,4627\n    // 2: #define\tARPB_WILD_WORLD ^?153,5194\n    p_7f = vim_strchr(lbuf, 0x7f);\n    if (p_7f == NULL)\n    {\netag_fail:\n\tif (vim_strchr(lbuf, '\\n') != NULL)\n\t    return FAIL;\n\n\t// Truncated line.  Ignore it.\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    msg(_(\"Ignoring long line in tags file\"));\n\t    verbose_leave();\n\t}\n\ttagp->command = lbuf;\n\ttagp->tagname = lbuf;\n\ttagp->tagname_end = lbuf;\n\treturn OK;\n    }\n\n    // Find ^A.  If not found the line number is after the 0x7f\n    p = vim_strchr(p_7f, Ctrl_A);\n    if (p == NULL)\n\tp = p_7f + 1;\n    else\n\t++p;\n\n    if (!VIM_ISDIGIT(*p))\t    // check for start of line number\n\tgoto etag_fail;\n    tagp->command = p;\n\n    if (p[-1] == Ctrl_A)\t    // first format: explicit tagname given\n    {\n\ttagp->tagname = p_7f + 1;\n\ttagp->tagname_end = p - 1;\n    }\n    else\t\t\t    // second format: isolate tagname\n    {\n\t// find end of tagname\n\tfor (p = p_7f - 1; !vim_iswordc(*p); --p)\n\t    if (p == lbuf)\n\t\tgoto etag_fail;\n\ttagp->tagname_end = p + 1;\n\twhile (p >= lbuf && vim_iswordc(*p))\n\t    --p;\n\ttagp->tagname = p + 1;\n    }\n\n    return OK;\n}\n#endif\n\n/*\n * Read the next line from a tags file.\n * Returns TAGS_READ_SUCCESS if a tags line is successfully read and should be\n * processed.\n * Returns TAGS_READ_EOF if the end of file is reached.\n * Returns TAGS_READ_IGNORE if the current line should be ignored (used when\n * reached end of a emacs included tags file)\n */\n    static tags_read_status_T\nfindtags_get_next_line(findtags_state_T *st, tagsearch_info_T *sinfo_p)\n{\n    int\t\teof;\n    off_T\toffset;\n\n    // For binary search: compute the next offset to use.\n    if (st->state == TS_BINARY)\n    {\n\toffset = sinfo_p->low_offset + ((sinfo_p->high_offset\n\t\t\t\t\t\t- sinfo_p->low_offset) / 2);\n\tif (offset == sinfo_p->curr_offset)\n\t    return TAGS_READ_EOF; // End the binary search without a match.\n\telse\n\t    sinfo_p->curr_offset = offset;\n    }\n\n    // Skipping back (after a match during binary search).\n    else if (st->state == TS_SKIP_BACK)\n    {\n\tsinfo_p->curr_offset -= st->lbuf_size * 2;\n\tif (sinfo_p->curr_offset < 0)\n\t{\n\t    sinfo_p->curr_offset = 0;\n\t    rewind(st->fp);\n\t    st->state = TS_STEP_FORWARD;\n\t}\n    }\n\n    // When jumping around in the file, first read a line to find the\n    // start of the next line.\n    if (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n    {\n\t// Adjust the search file offset to the correct position\n\tsinfo_p->curr_offset_used = sinfo_p->curr_offset;\n\tvim_ignored = vim_fseek(st->fp, sinfo_p->curr_offset, SEEK_SET);\n\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\tif (!eof && sinfo_p->curr_offset != 0)\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    if (sinfo_p->curr_offset == sinfo_p->high_offset)\n\t    {\n\t\t// oops, gone a bit too far; try from low offset\n\t\tvim_ignored = vim_fseek(st->fp, sinfo_p->low_offset, SEEK_SET);\n\t\tsinfo_p->curr_offset = sinfo_p->low_offset;\n\t    }\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\t// skip empty and blank lines\n\twhile (!eof && vim_isblankline(st->lbuf))\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\tif (eof)\n\t{\n\t    // Hit end of file.  Skip backwards.\n\t    st->state = TS_SKIP_BACK;\n\t    sinfo_p->match_offset = vim_ftell(st->fp);\n\t    sinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAGS_READ_IGNORE;\n\t}\n    }\n    // Not jumping around in the file: Read the next line.\n    else\n    {\n\t// skip empty and blank lines\n\tdo\n\t{\n#ifdef FEAT_CSCOPE\n\t    if (st->flags & TAG_CSCOPE)\n\t\teof = cs_fgets(st->lbuf, st->lbuf_size);\n\t    else\n#endif\n\t\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t} while (!eof && vim_isblankline(st->lbuf));\n\n\tif (eof)\n\t{\n#ifdef FEAT_EMACS_TAGS\n\t    if (emacs_tags_file_eof(st) == TRUE)\n\t\t// an included tags file. Continue processing the parent\n\t\t// tags file.\n\t\treturn TAGS_READ_IGNORE;\n#endif\n\t    return TAGS_READ_EOF;\n\t}\n    }\n\n    return TAGS_READ_SUCCESS;\n}\n\n/*\n * Parse a tags file header line in 'st->lbuf'.\n * Returns TRUE if the current line in st->lbuf is not a tags header line and\n * should be parsed as a regular tag line. Returns FALSE if the line is a\n * header line and the next header line should be read.\n */\n    static int\nfindtags_hdr_parse(findtags_state_T *st)\n{\n    char_u\t*p;\n\n    // Header lines in a tags file start with \"!_TAG_\"\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) != 0)\n\t// Non-header item before the header, e.g. \"!\" itself.\n\treturn TRUE;\n\n    // Process the header line.\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)\n\tst->tag_file_sorted = st->lbuf[18];\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0)\n    {\n\t// Prepare to convert every line from the specified encoding to\n\t// 'encoding'.\n\tfor (p = st->lbuf + 20; *p > ' ' && *p < 127; ++p)\n\t    ;\n\t*p = NUL;\n\tconvert_setup(&st->vimconv, st->lbuf + 20, p_enc);\n    }\n\n    // Read the next line.  Unrecognized flags are ignored.\n    return FALSE;\n}\n\n/*\n * Handler to initialize the state when starting to process a new tags file.\n * Called in the TS_START state when finding tags from a tags file.\n * Returns TRUE if the line read from the tags file should be parsed and\n * FALSE if the line should be ignored.\n */\n    static int\nfindtags_start_state_handler(\n    findtags_state_T\t*st,\n    int\t\t\t*sortic,\n    tagsearch_info_T\t*sinfo_p)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tnoic = (st->flags & TAG_NOIC);\n    off_T\tfilesize;\n\n    // The header ends when the line sorts below \"!_TAG_\".  When case is\n    // folded lower case letters sort before \"_\".\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) <= 0\n\t    || (st->lbuf[0] == '!' && ASCII_ISLOWER(st->lbuf[1])))\n\treturn findtags_hdr_parse(st);\n\n    // Headers ends.\n\n    // When there is no tag head, or ignoring case, need to do a\n    // linear search.\n    // When no \"!_TAG_\" is found, default to binary search.  If\n    // the tag file isn't sorted, the second loop will find it.\n    // When \"!_TAG_FILE_SORTED\" found: start binary search if\n    // flag set.\n    // For cscope, it's always linear.\n# ifdef FEAT_CSCOPE\n    if (st->linear || use_cscope)\n# else\n    if (st->linear)\n# endif\n\tst->state = TS_LINEAR;\n    else if (st->tag_file_sorted == NUL)\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '1')\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '2')\n    {\n\tst->state = TS_BINARY;\n\t*sortic = TRUE;\n\tst->orgpat->regmatch.rm_ic = (p_ic || !noic);\n    }\n    else\n\tst->state = TS_LINEAR;\n\n    if (st->state == TS_BINARY && st->orgpat->regmatch.rm_ic && !*sortic)\n    {\n\t// Binary search won't work for ignoring case, use linear\n\t// search.\n\tst->linear = TRUE;\n\tst->state = TS_LINEAR;\n    }\n\n    // When starting a binary search, get the size of the file and\n    // compute the first offset.\n    if (st->state == TS_BINARY)\n    {\n\tif (vim_fseek(st->fp, 0L, SEEK_END) != 0)\n\t    // can't seek, don't use binary search\n\t    st->state = TS_LINEAR;\n\telse\n\t{\n\t    // Get the tag file size (don't use mch_fstat(), it's\n\t    // not portable).  Don't use lseek(), it doesn't work\n\t    // properly on MacOS Catalina.\n\t    filesize = vim_ftell(st->fp);\n\t    vim_ignored = vim_fseek(st->fp, 0L, SEEK_SET);\n\n\t    // Calculate the first read offset in the file.  Start\n\t    // the search in the middle of the file.\n\t    sinfo_p->low_offset = 0;\n\t    sinfo_p->low_char = 0;\n\t    sinfo_p->high_offset = filesize;\n\t    sinfo_p->curr_offset = 0;\n\t    sinfo_p->high_char = 0xff;\n\t}\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Parse a tag line read from a tags file.\n * Returns OK if a tags line is successfully parsed.\n * Returns FAIL if a format error is encountered.\n */\n    static int\nfindtags_parse_line(\n    findtags_state_T\t\t*st,\n    tagptrs_T\t\t\t*tagpp,\n    findtags_match_args_T\t*margs,\n    tagsearch_info_T\t\t*sinfo_p)\n{\n    int\t\tstatus;\n    int\t\ti;\n    int\t\tcmplen;\n    int\t\ttagcmp;\n\n    // Figure out where the different strings are in this line.\n    // For \"normal\" tags: Do a quick check if the tag matches.\n    // This speeds up tag searching a lot!\n    if (st->orgpat->headlen\n#ifdef FEAT_EMACS_TAGS\n\t    && !st->is_etag\n#endif\n       )\n    {\n\tCLEAR_FIELD(*tagpp);\n\ttagpp->tagname = st->lbuf;\n\ttagpp->tagname_end = vim_strchr(st->lbuf, TAB);\n\tif (tagpp->tagname_end == NULL)\n\t    // Corrupted tag line.\n\t    return TAG_MATCH_FAIL;\n\n\t// Skip this line if the length of the tag is different and\n\t// there is no regexp, or the tag is too short.\n\tcmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tif (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\t    cmplen = p_tl;\n\tif ((st->flags & TAG_REGEXP) && st->orgpat->headlen < cmplen)\n\t    cmplen = st->orgpat->headlen;\n\telse if (st->state == TS_LINEAR && st->orgpat->headlen != cmplen)\n\t    return TAG_MATCH_NEXT;\n\n\tif (st->state == TS_BINARY)\n\t{\n\t    // Simplistic check for unsorted tags file.\n\t    i = (int)tagpp->tagname[0];\n\t    if (margs->sortic)\n\t\ti = (int)TOUPPER_ASC(tagpp->tagname[0]);\n\t    if (i < sinfo_p->low_char || i > sinfo_p->high_char)\n\t\tmargs->sort_error = TRUE;\n\n\t    // Compare the current tag with the searched tag.\n\t    if (margs->sortic)\n\t\ttagcmp = tag_strnicmp(tagpp->tagname, st->orgpat->head,\n\t\t\t\t\t\t\t(size_t)cmplen);\n\t    else\n\t\ttagcmp = STRNCMP(tagpp->tagname, st->orgpat->head, cmplen);\n\n\t    // A match with a shorter tag means to search forward.\n\t    // A match with a longer tag means to search backward.\n\t    if (tagcmp == 0)\n\t    {\n\t\tif (cmplen < st->orgpat->headlen)\n\t\t    tagcmp = -1;\n\t\telse if (cmplen > st->orgpat->headlen)\n\t\t    tagcmp = 1;\n\t    }\n\n\t    if (tagcmp == 0)\n\t    {\n\t\t// We've located the tag, now skip back and search\n\t\t// forward until the first matching tag is found.\n\t\tst->state = TS_SKIP_BACK;\n\t\tsinfo_p->match_offset = sinfo_p->curr_offset;\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\t    if (tagcmp < 0)\n\t    {\n\t\tsinfo_p->curr_offset = vim_ftell(st->fp);\n\t\tif (sinfo_p->curr_offset < sinfo_p->high_offset)\n\t\t{\n\t\t    sinfo_p->low_offset = sinfo_p->curr_offset;\n\t\t    if (margs->sortic)\n\t\t\tsinfo_p->low_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\t    else\n\t\t\tsinfo_p->low_char = tagpp->tagname[0];\n\t\t    return TAG_MATCH_NEXT;\n\t\t}\n\t    }\n\t    if (tagcmp > 0 && sinfo_p->curr_offset != sinfo_p->high_offset)\n\t    {\n\t\tsinfo_p->high_offset = sinfo_p->curr_offset;\n\t\tif (margs->sortic)\n\t\t    sinfo_p->high_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\telse\n\t\t    sinfo_p->high_char = tagpp->tagname[0];\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\n\t    // No match yet and are at the end of the binary search.\n\t    return TAG_MATCH_STOP;\n\t}\n\telse if (st->state == TS_SKIP_BACK)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\tst->state = TS_STEP_FORWARD;\n\t    else\n\t\t// Have to skip back more.  Restore the curr_offset\n\t\t// used, otherwise we get stuck at a long line.\n\t\tsinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAG_MATCH_NEXT;\n\t}\n\telse if (st->state == TS_STEP_FORWARD)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t    {\n\t\tif ((off_T)vim_ftell(st->fp) > sinfo_p->match_offset)\n\t\t    return TAG_MATCH_STOP;\t// past last match\n\t\telse\n\t\t    return TAG_MATCH_NEXT;\t// before first match\n\t    }\n\t}\n\telse\n\t    // skip this match if it can't match\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\treturn TAG_MATCH_NEXT;\n\n\t// Can be a matching tag, isolate the file name and command.\n\ttagpp->fname = tagpp->tagname_end + 1;\n\ttagpp->fname_end = vim_strchr(tagpp->fname, TAB);\n\tif (tagpp->fname_end == NULL)\n\t    status = FAIL;\n\telse\n\t{\n\t    tagpp->command = tagpp->fname_end + 1;\n\t    status = OK;\n\t}\n    }\n    else\n\tstatus = parse_tag_line(st->lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp);\n\n    if (status == FAIL)\n\treturn TAG_MATCH_FAIL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (st->is_etag)\n\ttagpp->fname = st->ebuf;\n#endif\n\n    return TAG_MATCH_SUCCESS;\n}\n\n/*\n * Initialize the structure used for tag matching.\n */\n    static void\nfindtags_matchargs_init(findtags_match_args_T *margs, int flags)\n{\n    margs->matchoff = 0;\t\t\t// match offset\n    margs->match_re = FALSE;\t\t\t// match with regexp\n    margs->match_no_ic = FALSE;\t\t\t// matches with case\n    margs->has_re = (flags & TAG_REGEXP);\t// regexp used\n    margs->sortic = FALSE;\t\t\t// tag file sorted in nocase\n    margs->sort_error = FALSE;\t\t\t// tags file not sorted\n}\n\n/*\n * Compares the tag name in 'tagpp->tagname' with a search pattern in\n * 'st->orgpat.head'.\n * Returns TAG_MATCH_SUCCESS if the tag matches, TAG_MATCH_FAIL if the tag\n * doesn't match, TAG_MATCH_NEXT to look for the next matching tag (used in a\n * binary search) and TAG_MATCH_STOP if all the tags are processed without a\n * match. Uses the values in 'margs' for doing the comparison.\n */\n    static tagmatch_status_T\nfindtags_match_tag(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T *margs)\n{\n    int\t\tmatch = FALSE;\n    int\t\tcmplen;\n\n    // First try matching with the pattern literally (also when it is\n    // a regexp).\n    cmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n    if (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\tcmplen = p_tl;\n    // if tag length does not match, don't try comparing\n    if (st->orgpat->len != cmplen)\n\tmatch = FALSE;\n    else\n    {\n\tif (st->orgpat->regmatch.rm_ic)\n\t{\n\t    match =\n\t\t(MB_STRNICMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t    if (match)\n\t\tmargs->match_no_ic =\n\t\t    (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t}\n\telse\n\t    match = (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n    }\n\n    // Has a regexp: Also find tags matching regexp.\n    margs->match_re = FALSE;\n    if (!match && st->orgpat->regmatch.regprog != NULL)\n    {\n\tint\tcc;\n\n\tcc = *tagpp->tagname_end;\n\t*tagpp->tagname_end = NUL;\n\tmatch = vim_regexec(&st->orgpat->regmatch, tagpp->tagname, (colnr_T)0);\n\tif (match)\n\t{\n\t    margs->matchoff = (int)(st->orgpat->regmatch.startp[0] -\n\t\t\t\t\t\t\ttagpp->tagname);\n\t    if (st->orgpat->regmatch.rm_ic)\n\t    {\n\t\tst->orgpat->regmatch.rm_ic = FALSE;\n\t\tmargs->match_no_ic = vim_regexec(&st->orgpat->regmatch,\n\t\t\ttagpp->tagname, (colnr_T)0);\n\t\tst->orgpat->regmatch.rm_ic = TRUE;\n\t    }\n\t}\n\t*tagpp->tagname_end = cc;\n\tmargs->match_re = TRUE;\n    }\n\n    return match ? TAG_MATCH_SUCCESS : TAG_MATCH_FAIL;\n}\n\n/*\n * Convert the encoding of a line read from a tags file in 'st->lbuf'.\n * Converting the pattern from 'enc' to the tags file encoding doesn't work,\n * because characters are not recognized. The converted line is saved in\n * st->lbuf.\n */\n    static void\nfindtags_string_convert(findtags_state_T *st)\n{\n    char_u\t*conv_line;\n    int\t\tlen;\n\n    conv_line = string_convert(&st->vimconv, st->lbuf, NULL);\n    if (conv_line == NULL)\n\treturn;\n\n    // Copy or swap lbuf and conv_line.\n    len = (int)STRLEN(conv_line) + 1;\n    if (len > st->lbuf_size)\n    {\n\tvim_free(st->lbuf);\n\tst->lbuf = conv_line;\n\tst->lbuf_size = len;\n    }\n    else\n    {\n\tSTRCPY(st->lbuf, conv_line);\n\tvim_free(conv_line);\n    }\n}\n\n/*\n * Add a matching tag found in a tags file to st->ht_match and st->ga_match.\n * Returns OK if successfully added the match and FAIL on memory allocation\n * failure.\n */\n    static int\nfindtags_add_match(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T   *margs,\n    char_u\t\t*buf_ffname,\n    hash_T\t\t*hash)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    int\t\tmtt;\n    int\t\tlen = 0;\n    int\t\tis_current;\t\t// file name matches\n    int\t\tis_static;\t\t// current tag line is static\n    char_u\t*mfp;\n    char_u\t*p;\n    char_u\t*s;\n\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n    {\n\t// Don't change the ordering, always use the same table.\n\tmtt = MT_GL_OTH;\n    }\n    else\n#endif\n    {\n\t// Decide in which array to store this match.\n\tis_current = test_for_current(\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp->fname, tagpp->fname_end, st->tag_fname, buf_ffname);\n#ifdef FEAT_EMACS_TAGS\n\tis_static = FALSE;\n\tif (!st->is_etag)\t// emacs tags are never static\n#endif\n\t    is_static = test_for_static(tagpp);\n\n\t// decide in which of the sixteen tables to store this\n\t// match\n\tif (is_static)\n\t{\n\t    if (is_current)\n\t\tmtt = MT_ST_CUR;\n\t    else\n\t\tmtt = MT_ST_OTH;\n\t}\n\telse\n\t{\n\t    if (is_current)\n\t\tmtt = MT_GL_CUR;\n\t    else\n\t\tmtt = MT_GL_OTH;\n\t}\n\tif (st->orgpat->regmatch.rm_ic && !margs->match_no_ic)\n\t    mtt += MT_IC_OFF;\n\tif (margs->match_re)\n\t    mtt += MT_RE_OFF;\n    }\n\n    // Add the found match in ht_match[mtt] and ga_match[mtt].\n    // Store the info we need later, which depends on the kind of\n    // tags we are dealing with.\n    if (st->help_only)\n    {\n#ifdef FEAT_MULTI_LANG\n# define ML_EXTRA 3\n#else\n# define ML_EXTRA 0\n#endif\n\t// Append the help-heuristic number after the tagname, for\n\t// sorting it later.  The heuristic is ignored for\n\t// detecting duplicates.\n\t// The format is {tagname}@{lang}NUL{heuristic}NUL\n\t*tagpp->tagname_end = NUL;\n\tlen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tmfp = alloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);\n\tif (mfp != NULL)\n\t{\n\t    int heuristic;\n\n\t    p = mfp;\n\t    STRCPY(p, tagpp->tagname);\n#ifdef FEAT_MULTI_LANG\n\t    p[len] = '@';\n\t    STRCPY(p + len + 1, st->help_lang);\n#endif\n\n\t    heuristic = help_heuristic(tagpp->tagname,\n\t\t\t\tmargs->match_re ? margs->matchoff : 0,\n\t\t\t\t!margs->match_no_ic);\n#ifdef FEAT_MULTI_LANG\n\t    heuristic += st->help_pri;\n#endif\n\t    sprintf((char *)p + len + 1 + ML_EXTRA, \"%06d\",\n\t\t    heuristic);\n\t}\n\t*tagpp->tagname_end = TAB;\n    }\n    else if (name_only)\n    {\n\tif (st->get_searchpat)\n\t{\n\t    char_u *temp_end = tagpp->command;\n\n\t    if (*temp_end == '/')\n\t\twhile (*temp_end && *temp_end != '\\r'\n\t\t\t&& *temp_end != '\\n'\n\t\t\t&& *temp_end != '$')\n\t\t    temp_end++;\n\n\t    if (tagpp->command + 2 < temp_end)\n\t    {\n\t\tlen = (int)(temp_end - tagpp->command - 2);\n\t\tmfp = alloc(len + 2);\n\t\tif (mfp != NULL)\n\t\t    vim_strncpy(mfp, tagpp->command + 2, len);\n\t    }\n\t    else\n\t\tmfp = NULL;\n\t    st->get_searchpat = FALSE;\n\t}\n\telse\n\t{\n\t    len = (int)(tagpp->tagname_end - tagpp->tagname);\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\t    if (mfp != NULL)\n\t\tvim_strncpy(mfp, tagpp->tagname, len);\n\n\t    // if wanted, re-read line to get long form too\n\t    if (State & MODE_INSERT)\n\t\tst->get_searchpat = p_sft;\n\t}\n    }\n    else\n    {\n\tsize_t tag_fname_len = STRLEN(st->tag_fname);\n#ifdef FEAT_EMACS_TAGS\n\tsize_t ebuf_len = 0;\n#endif\n\n\t// Save the tag in a buffer.\n\t// Use 0x02 to separate fields (Can't use NUL because the\n\t// hash key is terminated by NUL, or Ctrl_A because that is\n\t// part of some Emacs tag files -- see parse_tag_line).\n\t// Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>\n\t// other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>\n\t// without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>\n\t// Here <mtt> is the \"mtt\" value plus 1 to avoid NUL.\n\tlen = (int)tag_fname_len + (int)STRLEN(st->lbuf) + 3;\n#ifdef FEAT_EMACS_TAGS\n\tif (st->is_etag)\n\t{\n\t    ebuf_len = STRLEN(st->ebuf);\n\t    len += (int)ebuf_len + 1;\n\t}\n\telse\n\t    ++len;\n#endif\n\tmfp = alloc(sizeof(char_u) + len + 1);\n\tif (mfp != NULL)\n\t{\n\t    p = mfp;\n\t    p[0] = mtt + 1;\n\t    STRCPY(p + 1, st->tag_fname);\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Ignore differences in slashes, avoid adding\n\t    // both path/file and path\\file.\n\t    slash_adjust(p + 1);\n#endif\n\t    p[tag_fname_len + 1] = TAG_SEP;\n\t    s = p + 1 + tag_fname_len + 1;\n#ifdef FEAT_EMACS_TAGS\n\t    if (st->is_etag)\n\t    {\n\t\tSTRCPY(s, st->ebuf);\n\t\ts[ebuf_len] = TAG_SEP;\n\t\ts += ebuf_len + 1;\n\t    }\n\t    else\n\t\t*s++ = TAG_SEP;\n#endif\n\t    STRCPY(s, st->lbuf);\n\t}\n    }\n\n    if (mfp != NULL)\n    {\n\thashitem_T\t*hi;\n\n\t// Don't add identical matches.\n\t// Add all cscope tags, because they are all listed.\n\t// \"mfp\" is used as a hash key, there is a NUL byte to end\n\t// the part that matters for comparing, more bytes may\n\t// follow after it.  E.g. help tags store the priority\n\t// after the NUL.\n#ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    ++*hash;\n\telse\n#endif\n\t    *hash = hash_hash(mfp);\n\thi = hash_lookup(&st->ht_match[mtt], mfp, *hash);\n\tif (HASHITEM_EMPTY(hi))\n\t{\n\t    if (hash_add_item(&st->ht_match[mtt], hi, mfp, *hash) == FAIL\n\t\t    || ga_grow(&st->ga_match[mtt], 1) != OK)\n\t    {\n\t\t// Out of memory! Just forget about the rest.\n\t\tst->stop_searching = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    ((char_u **)(st->ga_match[mtt].ga_data))\n\t\t[st->ga_match[mtt].ga_len++] = mfp;\n\t    st->match_count++;\n\t}\n\telse\n\t    // duplicate tag, drop it\n\t    vim_free(mfp);\n    }\n\n    return OK;\n}\n\n/*\n * Read and get all the tags from file st->tag_fname.\n * Sets 'st->stop_searching' to TRUE to stop searching for additional tags.\n */\n    static void\nfindtags_get_all_tags(\n    findtags_state_T\t\t*st,\n    findtags_match_args_T\t*margs,\n    char_u\t\t\t*buf_ffname)\n{\n    tagptrs_T\t\ttagp;\n    tagsearch_info_T\tsearch_info;\n    int\t\t\tretval;\n#ifdef FEAT_CSCOPE\n    int\t\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    hash_T\t\thash = 0;\n\n    // This is only to avoid a compiler warning for using search_info\n    // uninitialised.\n    CLEAR_FIELD(search_info);\n\n    // Read and parse the lines in the file one by one\n    for (;;)\n    {\n\t// check for CTRL-C typed, more often when jumping around\n\tif (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n\t    line_breakcheck();\n\telse\n\t    fast_breakcheck();\n\tif ((st->flags & TAG_INS_COMP))\t// Double brackets for gcc\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\t// When mincount is TAG_MANY, stop when enough matches have been\n\t// found (for completion).\n\tif (st->mincount == TAG_MANY && st->match_count >= TAG_MANY)\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\tif (st->get_searchpat)\n\t    goto line_read_in;\n\n\tretval = findtags_get_next_line(st, &search_info);\n\tif (retval == TAGS_READ_IGNORE)\n\t    continue;\n\tif (retval == TAGS_READ_EOF)\n\t    break;\n\nline_read_in:\n\n\tif (st->vimconv.vc_type != CONV_NONE)\n\t    findtags_string_convert(st);\n\n#ifdef FEAT_EMACS_TAGS\n\t// Emacs tags line with CTRL-L: New file name on next line.\n\t// The file name is followed by a ','.\n\t// Remember etag file name in ebuf.\n\tif (*st->lbuf == Ctrl_L\n# ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n# endif\n\t   )\n\t{\n\t    st->is_etag = TRUE;\t\t// in case at the start\n\t    st->state = TS_LINEAR;\n\t    emacs_tags_new_filename(st);\n\t    continue;\n\t}\n#endif\n\n\t// When still at the start of the file, check for Emacs tags file\n\t// format, and for \"not sorted\" flag.\n\tif (st->state == TS_START)\n\t{\n\t    if (findtags_start_state_handler(st, &margs->sortic, &search_info) == FALSE)\n\t\tcontinue;\n\t}\n\n\t// When the line is too long the NUL will not be in the\n\t// last-but-one byte (see vim_fgets()).\n\t// Has been reported for Mozilla JS with extremely long names.\n\t// In that case we need to increase lbuf_size.\n\tif (st->lbuf[st->lbuf_size - 2] != NUL\n#ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n#endif\n\t   )\n\t{\n\t    st->lbuf_size *= 2;\n\t    vim_free(st->lbuf);\n\t    st->lbuf = alloc(st->lbuf_size);\n\t    if (st->lbuf == NULL)\n\t    {\n\t\tif (st->fp != NULL)\n\t\t    fclose(st->fp);\n\t\tst->fp = NULL;\n\t\tst->stop_searching = TRUE;\n\t\treturn;\n\t    }\n\n\t    if (st->state == TS_STEP_FORWARD || st->state == TS_LINEAR)\n\t\t// Seek to the same position to read the same line again\n\t\tvim_ignored = vim_fseek(st->fp, search_info.curr_offset,\n\t\t\t\t\t\t\t\t     SEEK_SET);\n\t    // this will try the same thing again, make sure the offset is\n\t    // different\n\t    search_info.curr_offset = 0;\n\t    continue;\n\t}\n\n\tretval = findtags_parse_line(st, &tagp, margs, &search_info);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\tif (retval == TAG_MATCH_FAIL)\n\t{\n\t    semsg(_(e_format_error_in_tags_file_str), st->tag_fname);\n#ifdef FEAT_CSCOPE\n\t    if (!use_cscope)\n#endif\n\t\tsemsg(_(\"Before byte %ld\"), (long)vim_ftell(st->fp));\n\t    st->stop_searching = TRUE;\n\t    return;\n\t}\n\n\tretval = findtags_match_tag(st, &tagp, margs);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\n\t// If a match is found, add it to ht_match[] and ga_match[].\n\tif (retval == TAG_MATCH_SUCCESS)\n\t{\n\t    if (findtags_add_match(st, &tagp, margs, buf_ffname, &hash)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\tbreak;\n\t}\n    } // forever\n}\n\n/*\n * Search for tags matching 'st->orgpat.pat' in the 'st->tag_fname' tags file.\n * Information needed to search for the tags is in the 'st' state structure.\n * The matching tags are returned in 'st'. If an error is encountered, then\n * 'st->stop_searching' is set to TRUE.\n */\n    static void\nfindtags_in_file(findtags_state_T *st, char_u *buf_ffname)\n{\n    findtags_match_args_T margs;\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n\n    st->vimconv.vc_type = CONV_NONE;\n    st->tag_file_sorted = NUL;\n    st->fp = NULL;\n    findtags_matchargs_init(&margs, st->flags);\n\n    // A file that doesn't exist is silently ignored.  Only when not a\n    // single file is found, an error message is given (further on).\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n\tst->fp = NULL;\t    // avoid GCC warning\n    else\n#endif\n    {\n#ifdef FEAT_MULTI_LANG\n\tif (curbuf->b_help)\n\t{\n\t    if (!findtags_in_help_init(st))\n\t\treturn;\n\t}\n#endif\n\n\tst->fp = mch_fopen((char *)st->tag_fname, \"r\");\n\tif (st->fp == NULL)\n\t    return;\n\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Searching tags file %s\"), st->tag_fname);\n\t    verbose_leave();\n\t}\n    }\n    st->did_open = TRUE;\t// remember that we found at least one file\n\n    st->state = TS_START;\t// we're at the start of the file\n#ifdef FEAT_EMACS_TAGS\n    st->is_etag = FALSE;\t// default is: not emacs style\n#endif\n\n    // Read and parse the lines in the file one by one\n    findtags_get_all_tags(st, &margs, buf_ffname);\n\n    if (st->fp != NULL)\n    {\n\tfclose(st->fp);\n\tst->fp = NULL;\n    }\n#ifdef FEAT_EMACS_TAGS\n    emacs_tags_incstack_free();\n#endif\n    if (st->vimconv.vc_type != CONV_NONE)\n\tconvert_setup(&st->vimconv, NULL, NULL);\n\n    if (margs.sort_error)\n\tsemsg(_(e_tags_file_not_sorted_str), st->tag_fname);\n\n    // Stop searching if sufficient tags have been found.\n    if (st->match_count >= st->mincount)\n\tst->stop_searching = TRUE;\n}\n\n/*\n * Copy the tags found by find_tags() to 'matchesp'.\n * Returns the number of matches copied.\n */\n    static int\nfindtags_copy_matches(findtags_state_T *st, char_u ***matchesp)\n{\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    char_u\t**matches;\n    int\t\tmtt;\n    int\t\ti;\n    char_u\t*mfp;\n    char_u\t*p;\n\n    if (st->match_count > 0)\n\tmatches = ALLOC_MULT(char_u *, st->match_count);\n    else\n\tmatches = NULL;\n    st->match_count = 0;\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tfor (i = 0; i < st->ga_match[mtt].ga_len; ++i)\n\t{\n\t    mfp = ((char_u **)(st->ga_match[mtt].ga_data))[i];\n\t    if (matches == NULL)\n\t\tvim_free(mfp);\n\t    else\n\t    {\n\t\tif (!name_only)\n\t\t{\n\t\t    // Change mtt back to zero-based.\n\t\t    *mfp = *mfp - 1;\n\n\t\t    // change the TAG_SEP back to NUL\n\t\t    for (p = mfp + 1; *p != NUL; ++p)\n\t\t\tif (*p == TAG_SEP)\n\t\t\t    *p = NUL;\n\t\t}\n\t\tmatches[st->match_count++] = mfp;\n\t    }\n\t}\n\n\tga_clear(&st->ga_match[mtt]);\n\thash_clear(&st->ht_match[mtt]);\n    }\n\n    *matchesp = matches;\n    return st->match_count;\n}\n\n/*\n * find_tags() - search for tags in tags files\n *\n * Return FAIL if search completely failed (*num_matches will be 0, *matchesp\n * will be NULL), OK otherwise.\n *\n * Priority depending on which type of tag is recognized:\n *  6.\tA static or global tag with a full matching tag for the current file.\n *  5.\tA global tag with a full matching tag for another file.\n *  4.\tA static tag with a full matching tag for another file.\n *  3.\tA static or global tag with an ignore-case matching tag for the\n *\tcurrent file.\n *  2.\tA global tag with an ignore-case matching tag for another file.\n *  1.\tA static tag with an ignore-case matching tag for another file.\n *\n * Tags in an emacs-style tags file are always global.\n *\n * flags:\n * TAG_HELP\t  only search for help tags\n * TAG_NAMES\t  only return name of tag\n * TAG_REGEXP\t  use \"pat\" as a regexp\n * TAG_NOIC\t  don't always ignore case\n * TAG_KEEP_LANG  keep language\n * TAG_CSCOPE\t  use cscope results for tags\n * TAG_NO_TAGFUNC do not call the 'tagfunc' function\n */\n    int\nfind_tags(\n    char_u\t*pat,\t\t\t// pattern to search for\n    int\t\t*num_matches,\t\t// return: number of matches found\n    char_u\t***matchesp,\t\t// return: array of matches found\n    int\t\tflags,\n    int\t\tmincount,\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    char_u\t*buf_ffname)\t\t// name of buffer for priority\n{\n    findtags_state_T\tst;\n    tagname_T\ttn;\t\t\t// info for get_tagfname()\n    int\t\tfirst_file;\t\t// trying first tag file\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\tround;\n\n    int\t\tsave_emsg_off;\n\n    int\t\thelp_save;\n#ifdef FEAT_MULTI_LANG\n    int\t\ti;\n    char_u\t*saved_pat = NULL;\t\t// copy of pat[]\n#endif\n\n    int\t\tfindall = (mincount == MAXCOL || mincount == TAG_MANY);\n\t\t\t\t\t\t// find all matching tags\n    int\t\thas_re = (flags & TAG_REGEXP);\t// regexp used\n    int\t\tnoic = (flags & TAG_NOIC);\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (flags & TAG_CSCOPE);\n#endif\n    int\t\tverbose = (flags & TAG_VERBOSE);\n    int\t\tsave_p_ic = p_ic;\n\n    /*\n     * Change the value of 'ignorecase' according to 'tagcase' for the\n     * duration of this function.\n     */\n    switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)\n    {\n\tcase TC_FOLLOWIC:\t\t break;\n\tcase TC_IGNORE:    p_ic = TRUE;  break;\n\tcase TC_MATCH:     p_ic = FALSE; break;\n\tcase TC_FOLLOWSCS: p_ic = ignorecase(pat); break;\n\tcase TC_SMART:     p_ic = ignorecase_opt(pat, TRUE, TRUE); break;\n    }\n\n    help_save = curbuf->b_help;\n\n    if (findtags_state_init(&st, pat, flags, mincount) == FAIL)\n\tgoto findtag_end;\n\n#ifdef FEAT_CSCOPE\n    STRCPY(st.tag_fname, \"from cscope\");\t// for error messages\n#endif\n\n    /*\n     * Initialize a few variables\n     */\n    if (st.help_only)\t\t\t\t// want tags from help file\n\tcurbuf->b_help = TRUE;\t\t\t// will be restored later\n#ifdef FEAT_CSCOPE\n    else if (use_cscope)\n    {\n\t// Make sure we don't mix help and cscope, confuses Coverity.\n\tst.help_only = FALSE;\n\tcurbuf->b_help = FALSE;\n    }\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    if (curbuf->b_help)\n    {\n\t// When \"@ab\" is specified use only the \"ab\" language, otherwise\n\t// search all languages.\n\tif (st.orgpat->len > 3 && pat[st.orgpat->len - 3] == '@'\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 2])\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 1]))\n\t{\n\t    saved_pat = vim_strnsave(pat, st.orgpat->len - 3);\n\t    if (saved_pat != NULL)\n\t    {\n\t\tst.help_lang_find = &pat[st.orgpat->len - 2];\n\t\tst.orgpat->pat = saved_pat;\n\t\tst.orgpat->len -= 3;\n\t    }\n\t}\n    }\n#endif\n    if (p_tl != 0 && st.orgpat->len > p_tl)\t// adjust for 'taglength'\n\tst.orgpat->len = p_tl;\n\n    save_emsg_off = emsg_off;\n    emsg_off = TRUE;  // don't want error for invalid RE here\n    prepare_pats(st.orgpat, has_re);\n    emsg_off = save_emsg_off;\n    if (has_re && st.orgpat->regmatch.regprog == NULL)\n\tgoto findtag_end;\n\n#ifdef FEAT_EVAL\n    retval = findtags_apply_tfu(&st, pat, buf_ffname);\n    if (retval != NOTDONE)\n\tgoto findtag_end;\n\n    // re-initialize the default return value\n    retval = FAIL;\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // Set a flag if the file extension is .txt\n    if ((flags & TAG_KEEP_LANG)\n\t    && st.help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && STRICMP(curbuf->b_fname + i - 4, \".txt\") == 0)\n\tst.is_txt = TRUE;\n#endif\n\n    /*\n     * When finding a specified number of matches, first try with matching\n     * case, so binary search can be used, and try ignore-case matches in a\n     * second loop.\n     * When finding all matches, 'tagbsearch' is off, or there is no fixed\n     * string to look for, ignore case right away to avoid going though the\n     * tags files twice.\n     * When the tag file is case-fold sorted, it is either one or the other.\n     * Only ignore case when TAG_NOIC not used or 'ignorecase' set.\n     */\n    st.orgpat->regmatch.rm_ic = ((p_ic || !noic)\n\t\t\t&& (findall || st.orgpat->headlen == 0 || !p_tbs));\n    for (round = 1; round <= 2; ++round)\n    {\n\tst.linear = (st.orgpat->headlen == 0 || !p_tbs || round == 2);\n\n      /*\n       * Try tag file names from tags option one by one.\n       */\n      for (first_file = TRUE;\n#ifdef FEAT_CSCOPE\n\t    use_cscope ||\n#endif\n\t\tget_tagfname(&tn, first_file, st.tag_fname) == OK;\n\t\t\t\t\t\t\t   first_file = FALSE)\n      {\n\t  findtags_in_file(&st, buf_ffname);\n\t  if (st.stop_searching\n#ifdef FEAT_CSCOPE\n\t\t  || use_cscope\n#endif\n\t     )\n\t  {\n\t      retval = OK;\n\t      break;\n\t  }\n      } // end of for-each-file loop\n\n#ifdef FEAT_CSCOPE\n\tif (!use_cscope)\n#endif\n\t    tagname_free(&tn);\n\n\t// stop searching when already did a linear search, or when TAG_NOIC\n\t// used, and 'ignorecase' not set or already did case-ignore search\n\tif (st.stop_searching || st.linear || (!p_ic && noic) ||\n\t\t\t\t\t\tst.orgpat->regmatch.rm_ic)\n\t    break;\n# ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    break;\n# endif\n\n\t// try another time while ignoring case\n\tst.orgpat->regmatch.rm_ic = TRUE;\n    }\n\n    if (!st.stop_searching)\n    {\n\tif (!st.did_open && verbose)\t// never opened any tags file\n\t    emsg(_(e_no_tags_file));\n\tretval = OK;\t\t// It's OK even when no tag found\n    }\n\nfindtag_end:\n    findtags_state_free(&st);\n\n    /*\n     * Move the matches from the ga_match[] arrays into one list of\n     * matches.  When retval == FAIL, free the matches.\n     */\n    if (retval == FAIL)\n\tst.match_count = 0;\n\n    *num_matches = findtags_copy_matches(&st, matchesp);\n\n    curbuf->b_help = help_save;\n#ifdef FEAT_MULTI_LANG\n    vim_free(saved_pat);\n#endif\n\n    p_ic = save_p_ic;\n\n    return retval;\n}\n\nstatic garray_T tag_fnames = GA_EMPTY;\n\n/*\n * Callback function for finding all \"tags\" and \"tags-??\" files in\n * 'runtimepath' doc directories.\n */\n    static void\nfound_tagfile_cb(char_u *fname, void *cookie UNUSED)\n{\n    if (ga_grow(&tag_fnames, 1) == OK)\n    {\n\tchar_u\t*tag_fname = vim_strsave(fname);\n\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(tag_fname);\n#endif\n\tsimplify_filename(tag_fname);\n\t((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] = tag_fname;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tag_stuff(void)\n{\n    ga_clear_strings(&tag_fnames);\n    if (curwin != NULL)\n\tdo_tag(NULL, DT_FREE, 0, 0, 0);\n    tag_freematch();\n\n# if defined(FEAT_QUICKFIX)\n    tagstack_clear_entry(&ptag_entry);\n# endif\n}\n#endif\n\n/*\n * Get the next name of a tag file from the tag file list.\n * For help files, use \"tags\" file only.\n *\n * Return FAIL if no more tag file names, OK otherwise.\n */\n    int\nget_tagfname(\n    tagname_T\t*tnp,\t// holds status info\n    int\t\tfirst,\t// TRUE when first file name is wanted\n    char_u\t*buf)\t// pointer to buffer of MAXPATHL chars\n{\n    char_u\t\t*fname = NULL;\n    char_u\t\t*r_ptr;\n    int\t\t\ti;\n\n    if (first)\n\tCLEAR_POINTER(tnp);\n\n    if (curbuf->b_help)\n    {\n\t/*\n\t * For help files it's done in a completely different way:\n\t * Find \"doc/tags\" and \"doc/tags-??\" in all directories in\n\t * 'runtimepath'.\n\t */\n\tif (first)\n\t{\n\t    ga_clear_strings(&tag_fnames);\n\t    ga_init2(&tag_fnames, sizeof(char_u *), 10);\n\t    do_in_runtimepath((char_u *)\n#ifdef FEAT_MULTI_LANG\n# ifdef VMS\n\t\t    // Functions decc$to_vms() and decc$translate_vms() crash\n\t\t    // on some VMS systems with wildcards \"??\".  Seems ECO\n\t\t    // patches do fix the problem in C RTL, but we can't use\n\t\t    // an #ifdef for that.\n\t\t    \"doc/tags doc/tags-*\"\n# else\n\t\t    \"doc/tags doc/tags-??\"\n# endif\n#else\n\t\t    \"doc/tags\"\n#endif\n\t\t\t\t\t   , DIP_ALL, found_tagfile_cb, NULL);\n\t}\n\n\tif (tnp->tn_hf_idx >= tag_fnames.ga_len)\n\t{\n\t    // Not found in 'runtimepath', use 'helpfile', if it exists and\n\t    // wasn't used yet, replacing \"help.txt\" with \"tags\".\n\t    if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)\n\t\treturn FAIL;\n\t    ++tnp->tn_hf_idx;\n\t    STRCPY(buf, p_hf);\n\t    STRCPY(gettail(buf), \"tags\");\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(buf);\n#endif\n\t    simplify_filename(buf);\n\n\t    for (i = 0; i < tag_fnames.ga_len; ++i)\n\t\tif (STRCMP(buf, ((char_u **)(tag_fnames.ga_data))[i]) == 0)\n\t\t    return FAIL; // avoid duplicate file names\n\t}\n\telse\n\t    vim_strncpy(buf, ((char_u **)(tag_fnames.ga_data))[\n\t\t\t\t\t     tnp->tn_hf_idx++], MAXPATHL - 1);\n\treturn OK;\n    }\n\n    if (first)\n    {\n\t// Init.  We make a copy of 'tags', because autocommands may change\n\t// the value without notifying us.\n\ttnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)\n\t\t\t\t\t\t ? curbuf->b_p_tags : p_tags);\n\tif (tnp->tn_tags == NULL)\n\t    return FAIL;\n\ttnp->tn_np = tnp->tn_tags;\n    }\n\n    /*\n     * Loop until we have found a file name that can be used.\n     * There are two states:\n     * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.\n     * tnp->tn_did_filefind_init == TRUE: find next file in this part.\n     */\n    for (;;)\n    {\n\tif (tnp->tn_did_filefind_init)\n\t{\n\t    fname = vim_findfile(tnp->tn_search_ctx);\n\t    if (fname != NULL)\n\t\tbreak;\n\n\t    tnp->tn_did_filefind_init = FALSE;\n\t}\n\telse\n\t{\n\t    char_u  *filename = NULL;\n\n\t    // Stop when used all parts of 'tags'.\n\t    if (*tnp->tn_np == NUL)\n\t    {\n\t\tvim_findfile_cleanup(tnp->tn_search_ctx);\n\t\ttnp->tn_search_ctx = NULL;\n\t\treturn FAIL;\n\t    }\n\n\t    /*\n\t     * Copy next file name into buf.\n\t     */\n\t    buf[0] = NUL;\n\t    (void)copy_option_part(&tnp->tn_np, buf, MAXPATHL - 1, \" ,\");\n\n\t    r_ptr = vim_findfile_stopdir(buf);\n\t    // move the filename one char forward and truncate the\n\t    // filepath with a NUL\n\t    filename = gettail(buf);\n\t    STRMOVE(filename + 1, filename);\n\t    *filename++ = NUL;\n\n\t    tnp->tn_search_ctx = vim_findfile_init(buf, filename,\n\t\t    r_ptr, 100,\n\t\t    FALSE,\t   // don't free visited list\n\t\t    FINDFILE_FILE, // we search for a file\n\t\t    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);\n\t    if (tnp->tn_search_ctx != NULL)\n\t\ttnp->tn_did_filefind_init = TRUE;\n\t}\n    }\n\n    STRCPY(buf, fname);\n    vim_free(fname);\n    return OK;\n}\n\n/*\n * Free the contents of a tagname_T that was filled by get_tagfname().\n */\n    void\ntagname_free(tagname_T *tnp)\n{\n    vim_free(tnp->tn_tags);\n    vim_findfile_cleanup(tnp->tn_search_ctx);\n    tnp->tn_search_ctx = NULL;\n    ga_clear_strings(&tag_fnames);\n}\n\n/*\n * Parse one line from the tags file. Find start/end of tag name, start/end of\n * file name and start of search pattern.\n *\n * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.\n *\n * Return FAIL if there is a format error in this line, OK otherwise.\n */\n    static int\nparse_tag_line(\n    char_u\t*lbuf,\t\t// line to be parsed\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag,\n#endif\n    tagptrs_T\t*tagp)\n{\n    char_u\t*p;\n\n#ifdef FEAT_EMACS_TAGS\n    if (is_etag)\n\t// emacs-style tag file\n\treturn emacs_tags_parse_line(lbuf, tagp);\n#endif\n\n    // Isolate the tagname, from lbuf up to the first white\n    tagp->tagname = lbuf;\n    p = vim_strchr(lbuf, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->tagname_end = p;\n\n    // Isolate file name, from first to second white space\n    if (*p != NUL)\n\t++p;\n    tagp->fname = p;\n    p = vim_strchr(p, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->fname_end = p;\n\n    // find start of search command, after second white space\n    if (*p != NUL)\n\t++p;\n    if (*p == NUL)\n\treturn FAIL;\n    tagp->command = p;\n\n    return OK;\n}\n\n/*\n * Check if tagname is a static tag\n *\n * Static tags produced by the older ctags program have the format:\n *\t'file:tag  file  /pattern'.\n * This is only recognized when both occurrence of 'file' are the same, to\n * avoid recognizing \"string::string\" or \":exit\".\n *\n * Static tags produced by the new ctags program have the format:\n *\t'tag  file  /pattern/;\"<Tab>file:'\t    \"\n *\n * Return TRUE if it is a static tag and adjust *tagname to the real tag.\n * Return FALSE if it is not a static tag.\n */\n    static int\ntest_for_static(tagptrs_T *tagp)\n{\n    char_u\t*p;\n\n    /*\n     * Check for new style static tag \":...<Tab>file:[<Tab>...]\"\n     */\n    p = tagp->command;\n    while ((p = vim_strchr(p, '\\t')) != NULL)\n    {\n\t++p;\n\tif (STRNCMP(p, \"file:\", 5) == 0)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Returns the length of a matching tag line.\n */\n    static size_t\nmatching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n\n    // does the same thing as parse_match()\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}\n\n/*\n * Parse a line from a matching tag.  Does not change the line itself.\n *\n * The line that we get looks like this:\n * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>\n * other tag: <mtt><tag_fname><NUL><NUL><lbuf>\n * without Emacs tags: <mtt><tag_fname><NUL><lbuf>\n *\n * Return OK or FAIL.\n */\n    static int\nparse_match(\n    char_u\t*lbuf,\t    // input: matching line\n    tagptrs_T\t*tagp)\t    // output: pointers into the line\n{\n    int\t\tretval;\n    char_u\t*p;\n    char_u\t*pc, *pt;\n\n    tagp->tag_fname = lbuf + 1;\n    lbuf += STRLEN(tagp->tag_fname) + 2;\n#ifdef FEAT_EMACS_TAGS\n    if (*lbuf)\n    {\n\ttagp->is_etag = TRUE;\n\ttagp->fname = lbuf;\n\tlbuf += STRLEN(lbuf);\n\ttagp->fname_end = lbuf++;\n    }\n    else\n    {\n\ttagp->is_etag = FALSE;\n\t++lbuf;\n    }\n#endif\n\n    // Find search pattern and the file name for non-etags.\n    retval = parse_tag_line(lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\t\ttagp->is_etag,\n#endif\n\t\t\ttagp);\n\n    tagp->tagkind = NULL;\n    tagp->user_data = NULL;\n    tagp->tagline = 0;\n    tagp->command_end = NULL;\n\n    if (retval == OK)\n    {\n\t// Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"\n\tp = tagp->command;\n\tif (find_extra(&p) == OK)\n\t{\n\t    if (p > tagp->command && p[-1] == '|')\n\t\ttagp->command_end = p - 1;  // drop trailing bar\n\t    else\n\t\ttagp->command_end = p;\n\t    p += 2;\t// skip \";\\\"\"\n\t    if (*p++ == TAB)\n\t\t// Accept ASCII alphabetic kind characters and any multi-byte\n\t\t// character.\n\t\twhile (ASCII_ISALPHA(*p) || mb_ptr2len(p) > 1)\n\t\t{\n\t\t    if (STRNCMP(p, \"kind:\", 5) == 0)\n\t\t\ttagp->tagkind = p + 5;\n\t\t    else if (STRNCMP(p, \"user_data:\", 10) == 0)\n\t\t\ttagp->user_data = p + 10;\n\t\t    else if (STRNCMP(p, \"line:\", 5) == 0)\n\t\t\ttagp->tagline = atoi((char *)p + 5);\n\t\t    if (tagp->tagkind != NULL && tagp->user_data != NULL)\n\t\t\tbreak;\n\t\t    pc = vim_strchr(p, ':');\n\t\t    pt = vim_strchr(p, '\\t');\n\t\t    if (pc == NULL || (pt != NULL && pc > pt))\n\t\t\ttagp->tagkind = p;\n\t\t    if (pt == NULL)\n\t\t\tbreak;\n\t\t    p = pt;\n\t\t    MB_PTR_ADV(p);\n\t\t}\n\t}\n\tif (tagp->tagkind != NULL)\n\t{\n\t    for (p = tagp->tagkind;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->tagkind_end = p;\n\t}\n\tif (tagp->user_data != NULL)\n\t{\n\t    for (p = tagp->user_data;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->user_data_end = p;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Find out the actual file name of a tag.  Concatenate the tags file name\n * with the matching tag file name.\n * Returns an allocated string or NULL (out of memory).\n */\n    static char_u *\ntag_full_fname(tagptrs_T *tagp)\n{\n    char_u\t*fullname;\n    int\t\tc;\n\n#ifdef FEAT_EMACS_TAGS\n    if (tagp->is_etag)\n\tc = 0;\t    // to shut up GCC\n    else\n#endif\n    {\n\tc = *tagp->fname_end;\n\t*tagp->fname_end = NUL;\n    }\n    fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, FALSE);\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp->is_etag)\n#endif\n\t*tagp->fname_end = c;\n\n    return fullname;\n}\n\n/*\n * Jump to a tag that has been found in one of the tag files\n *\n * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.\n */\n    static int\njumpto_tag(\n    char_u\t*lbuf_arg,\t// line from the tags file for this tag\n    int\t\tforceit,\t// :ta with !\n    int\t\tkeep_help)\t// keep help flag (FALSE for cscope)\n{\n    optmagic_T\tsave_magic_overruled;\n    int\t\tsave_p_ws, save_p_scs, save_p_ic;\n    linenr_T\tsave_lnum;\n    char_u\t*str;\n    char_u\t*pbuf;\t\t\t// search pattern buffer\n    char_u\t*pbuf_end;\n    char_u\t*tofree_fname = NULL;\n    char_u\t*fname;\n    tagptrs_T\ttagp;\n    int\t\tretval = FAIL;\n    int\t\tgetfile_result = GETFILE_UNUSED;\n    int\t\tsearch_options;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tsave_no_hlsearch;\n#endif\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n    char_u\t*full_fname = NULL;\n#ifdef FEAT_FOLDING\n    int\t\told_KeyTyped = KeyTyped;    // getting the file may reset it\n#endif\n    size_t\tlen;\n    char_u\t*lbuf;\n\n    // Make a copy of the line, it can become invalid when an autocommand calls\n    // back here recursively.\n    len = matching_line_len(lbuf_arg) + 1;\n    lbuf = alloc(len);\n    if (lbuf != NULL)\n\tmch_memmove(lbuf, lbuf_arg, len);\n\n    pbuf = alloc(LSIZE);\n\n    // parse the match line into the tagp structure\n    if (pbuf == NULL || lbuf == NULL || parse_match(lbuf, &tagp) == FAIL)\n    {\n\ttagp.fname_end = NULL;\n\tgoto erret;\n    }\n\n    // truncate the file name, so it can be used as a string\n    *tagp.fname_end = NUL;\n    fname = tagp.fname;\n\n    // copy the command to pbuf[], remove trailing CR/NL\n    str = tagp.command;\n    for (pbuf_end = pbuf; *str && *str != '\\n' && *str != '\\r'; )\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (tagp.is_etag && *str == ',')// stop at ',' after line number\n\t    break;\n#endif\n\t*pbuf_end++ = *str++;\n\tif (pbuf_end - pbuf + 1 >= LSIZE)\n\t    break;\n    }\n    *pbuf_end = NUL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp.is_etag)\n#endif\n    {\n\t/*\n\t * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here.\n\t */\n\tstr = pbuf;\n\tif (find_extra(&str) == OK)\n\t{\n\t    pbuf_end = str;\n\t    *pbuf_end = NUL;\n\t}\n    }\n\n    /*\n     * Expand file name, when needed (for environment variables).\n     * If 'tagrelative' option set, may change file name.\n     */\n    fname = expand_tag_fname(fname, tagp.tag_fname, TRUE);\n    if (fname == NULL)\n\tgoto erret;\n    tofree_fname = fname;\t// free() it later\n\n    /*\n     * Check if the file with the tag exists before abandoning the current\n     * file.  Also accept a file name for which there is a matching BufReadCmd\n     * autocommand event (e.g., http://sys/file).\n     */\n    if (mch_getperm(fname) < 0 && !has_autocmd(EVENT_BUFREADCMD, fname, NULL))\n    {\n\tretval = NOTAGFILE;\n\tvim_free(nofile_fname);\n\tnofile_fname = vim_strsave(fname);\n\tif (nofile_fname == NULL)\n\t    nofile_fname = empty_option;\n\tgoto erret;\n    }\n\n    ++RedrawingDisabled;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#if defined(FEAT_QUICKFIX)\n    if (g_do_tagpreview != 0)\n    {\n\tpostponed_split = 0;\t// don't split again below\n\tcurwin_save = curwin;\t// Save current window\n\n\t/*\n\t * If we are reusing a window, we may change dir when\n\t * entering it (autocommands) so turn the tag filename\n\t * into a fullpath\n\t */\n\tif (!curwin->w_p_pvw)\n\t{\n\t    full_fname = FullName_save(fname, FALSE);\n\t    fname = full_fname;\n\n\t    /*\n\t     * Make the preview window the current window.\n\t     * Open a preview window when needed.\n\t     */\n\t    prepare_tagpreview(TRUE, TRUE, FALSE);\n\t}\n    }\n\n    // If it was a CTRL-W CTRL-] command split window now.  For \":tab tag\"\n    // open a new tab page.\n    if (postponed_split && (swb_flags & (SWB_USEOPEN | SWB_USETAB)))\n    {\n\tbuf_T *existing_buf = buflist_findname_exp(fname);\n\n\tif (existing_buf != NULL)\n\t{\n\t    win_T *wp = NULL;\n\n\t    if (swb_flags & SWB_USEOPEN)\n\t\twp = buf_jump_open_win(existing_buf);\n\n\t    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t    // page containing \"existing_buf\" if one exists\n\t    if (wp == NULL && (swb_flags & SWB_USETAB))\n\t\twp = buf_jump_open_tab(existing_buf);\n\t    // We've switched to the buffer, the usual loading of the file must\n\t    // be skipped.\n\t    if (wp != NULL)\n\t\tgetfile_result = GETFILE_SAME_FILE;\n\t}\n    }\n    if (getfile_result == GETFILE_UNUSED\n\t\t\t\t  && (postponed_split || cmdmod.cmod_tab != 0))\n    {\n\tif (win_split(postponed_split > 0 ? postponed_split : 0,\n\t\t\t\t\t\tpostponed_split_flags) == FAIL)\n\t{\n\t    --RedrawingDisabled;\n\t    goto erret;\n\t}\n\tRESET_BINDING(curwin);\n    }\n#endif\n\n    if (keep_help)\n    {\n\t// A :ta from a help file will keep the b_help flag set.  For \":ptag\"\n\t// we need to use the flag from the window where we came from.\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    keep_help_flag = bt_help(curwin_save->w_buffer);\n\telse\n#endif\n\t    keep_help_flag = curbuf->b_help;\n    }\n\n    if (getfile_result == GETFILE_UNUSED)\n\t// Careful: getfile() may trigger autocommands and call jumpto_tag()\n\t// recursively.\n\tgetfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);\n    keep_help_flag = FALSE;\n\n    if (GETFILE_SUCCESS(getfile_result))\t// got to the right file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tpostponed_split = 0;\n\n\tsave_magic_overruled = magic_overruled;\n\tmagic_overruled = OPTION_MAGIC_OFF;\t// always execute with 'nomagic'\n#ifdef FEAT_SEARCH_EXTRA\n\t// Save value of no_hlsearch, jumping to a tag is not a real search\n\tsave_no_hlsearch = no_hlsearch;\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\t// getfile() may have cleared options, apply 'previewpopup' again.\n\tif (g_do_tagpreview != 0 && *p_pvp != NUL)\n\t    parse_previewpopup(curwin);\n#endif\n\n\t/*\n\t * If 'cpoptions' contains 't', store the search pattern for the \"n\"\n\t * command.  If 'cpoptions' does not contain 't', the search pattern\n\t * is not stored.\n\t */\n\tif (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)\n\t    search_options = 0;\n\telse\n\t    search_options = SEARCH_KEEP;\n\n\t/*\n\t * If the command is a search, try here.\n\t *\n\t * Reset 'smartcase' for the search, since the search pattern was not\n\t * typed by the user.\n\t * Only use do_search() when there is a full search command, without\n\t * anything following.\n\t */\n\tstr = pbuf;\n\tif (pbuf[0] == '/' || pbuf[0] == '?')\n\t    str = skip_regexp(pbuf + 1, pbuf[0], FALSE) + 1;\n\tif (str > pbuf_end - 1)\t// search command with nothing following\n\t{\n\t    save_p_ws = p_ws;\n\t    save_p_ic = p_ic;\n\t    save_p_scs = p_scs;\n\t    p_ws = TRUE;\t// need 'wrapscan' for backward searches\n\t    p_ic = FALSE;\t// don't ignore case now\n\t    p_scs = FALSE;\n\t    save_lnum = curwin->w_cursor.lnum;\n\t    if (tagp.tagline > 0)\n\t\t// start search before line from \"line:\" field\n\t\tcurwin->w_cursor.lnum = tagp.tagline - 1;\n\t    else\n\t\t// start search before first line\n\t\tcurwin->w_cursor.lnum = 0;\n\t    if (do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\tretval = OK;\n\t    else\n\t    {\n\t\tint\tfound = 1;\n\t\tint\tcc;\n\n\t\t/*\n\t\t * try again, ignore case now\n\t\t */\n\t\tp_ic = TRUE;\n\t\tif (!do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t{\n\t\t    /*\n\t\t     * Failed to find pattern, take a guess: \"^func  (\"\n\t\t     */\n\t\t    found = 2;\n\t\t    (void)test_for_static(&tagp);\n\t\t    cc = *tagp.tagname_end;\n\t\t    *tagp.tagname_end = NUL;\n\t\t    sprintf((char *)pbuf, \"^%s\\\\s\\\\*(\", tagp.tagname);\n\t\t    if (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t    {\n\t\t\t// Guess again: \"^char * \\<func  (\"\n\t\t\tsprintf((char *)pbuf, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",\n\t\t\t\t\t\t\t\ttagp.tagname);\n\t\t\tif (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t\t    found = 0;\n\t\t    }\n\t\t    *tagp.tagname_end = cc;\n\t\t}\n\t\tif (found == 0)\n\t\t{\n\t\t    emsg(_(e_canot_find_tag_pattern));\n\t\t    curwin->w_cursor.lnum = save_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Only give a message when really guessed, not when 'ic'\n\t\t     * is set and match found while ignoring case.\n\t\t     */\n\t\t    if (found == 2 || !save_p_ic)\n\t\t    {\n\t\t\tmsg(_(e_couldnt_find_tag_just_guessing));\n\t\t\tif (!msg_scrolled && msg_silent == 0)\n\t\t\t{\n\t\t\t    out_flush();\n\t\t\t    ui_delay(1010L, TRUE);\n\t\t\t}\n\t\t    }\n\t\t    retval = OK;\n\t\t}\n\t    }\n\t    p_ws = save_p_ws;\n\t    p_ic = save_p_ic;\n\t    p_scs = save_p_scs;\n\n\t    // A search command may have positioned the cursor beyond the end\n\t    // of the line.  May need to correct that here.\n\t    check_cursor();\n\t}\n\telse\n\t{\n\t    int\t\tsave_secure = secure;\n\n\t    // Setup the sandbox for executing the command from the tags file.\n\t    secure = 1;\n#ifdef HAVE_SANDBOX\n\t    ++sandbox;\n#endif\n\t    curwin->w_cursor.lnum = 1;\t\t// start command in line 1\n\t    do_cmdline_cmd(pbuf);\n\t    retval = OK;\n\n\t    // When the command has done something that is not allowed make\n\t    // sure the error message can be seen.\n\t    if (secure == 2)\n\t\twait_return(TRUE);\n\t    secure = save_secure;\n#ifdef HAVE_SANDBOX\n\t    --sandbox;\n#endif\n\t}\n\n\tmagic_overruled = save_magic_overruled;\n#ifdef FEAT_SEARCH_EXTRA\n\t// restore no_hlsearch when keeping the old search pattern\n\tif (search_options)\n\t    set_no_hlsearch(save_no_hlsearch);\n#endif\n\n\t// Return OK if jumped to another file (at least we found the file!).\n\tif (getfile_result == GETFILE_OPEN_OTHER)\n\t    retval = OK;\n\n\tif (retval == OK)\n\t{\n\t    /*\n\t     * For a help buffer: Put the cursor line at the top of the window,\n\t     * the help subject will be below it.\n\t     */\n\t    if (curbuf->b_help)\n\t\tset_topline(curwin, curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\tfoldOpenCursor();\n#endif\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t{\n\t    // Return cursor to where we were\n\t    validate_cursor();\n\t    redraw_later(UPD_VALID);\n\t    win_enter(curwin_save, TRUE);\n\t}\n#endif\n\n\t--RedrawingDisabled;\n    }\n    else\n    {\n\t--RedrawingDisabled;\n\tgot_int = FALSE;  // don't want entering window to fail\n\n\tif (postponed_split)\t\t// close the window\n\t{\n\t    win_close(curwin, FALSE);\n\t    postponed_split = 0;\n\t}\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n\telse if (WIN_IS_POPUP(curwin))\n\t{\n\t    win_T   *wp = curwin;\n\n\t    if (win_valid(curwin_save))\n\t\twin_enter(curwin_save, TRUE);\n\t    popup_close(wp->w_id, FALSE);\n\t}\n#endif\n    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n    if (WIN_IS_POPUP(curwin))\n\t// something went wrong, still in popup, but it can't have focus\n\twin_enter(firstwin, TRUE);\n#endif\n\nerret:\n#if defined(FEAT_QUICKFIX)\n    g_do_tagpreview = 0; // For next time\n#endif\n    vim_free(lbuf);\n    vim_free(pbuf);\n    vim_free(tofree_fname);\n    vim_free(full_fname);\n\n    return retval;\n}\n\n/*\n * If \"expand\" is TRUE, expand wildcards in fname.\n * If 'tagrelative' option set, change fname (name of file containing tag)\n * according to tag_fname (name of tag file containing fname).\n * Returns a pointer to allocated memory (or NULL when out of memory).\n */\n    static char_u *\nexpand_tag_fname(char_u *fname, char_u *tag_fname, int expand)\n{\n    char_u\t*p;\n    char_u\t*retval;\n    char_u\t*expanded_fname = NULL;\n    expand_T\txpc;\n\n    /*\n     * Expand file name (for environment variables) when needed.\n     */\n    if (expand && mch_has_wildcard(fname))\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\texpanded_fname = ExpandOne(&xpc, fname, NULL,\n\t\t\t    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n\tif (expanded_fname != NULL)\n\t    fname = expanded_fname;\n    }\n\n    if ((p_tr || curbuf->b_help)\n\t    && !vim_isAbsName(fname)\n\t    && (p = gettail(tag_fname)) != tag_fname)\n    {\n\tretval = alloc(MAXPATHL);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, tag_fname);\n\t    vim_strncpy(retval + (p - tag_fname), fname,\n\t\t\t\t\t      MAXPATHL - (p - tag_fname) - 1);\n\t    /*\n\t     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\".\n\t     */\n\t    simplify_filename(retval);\n\t}\n    }\n    else\n\tretval = vim_strsave(fname);\n\n    vim_free(expanded_fname);\n\n    return retval;\n}\n\n/*\n * Check if we have a tag for the buffer with name \"buf_ffname\".\n * This is a bit slow, because of the full path compare in fullpathcmp().\n * Return TRUE if tag for file \"fname\" if tag file \"tag_fname\" is for current\n * file.\n */\n    static int\ntest_for_current(\n#ifdef FEAT_EMACS_TAGS\n    int\t    is_etag,\n#endif\n    char_u  *fname,\n    char_u  *fname_end,\n    char_u  *tag_fname,\n    char_u  *buf_ffname)\n{\n    int\t    c;\n    int\t    retval = FALSE;\n    char_u  *fullname;\n\n    if (buf_ffname != NULL)\t// if the buffer has a name\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (is_etag)\n\t    c = 0;\t    // to shut up GCC\n\telse\n#endif\n\t{\n\t    c = *fname_end;\n\t    *fname_end = NUL;\n\t}\n\tfullname = expand_tag_fname(fname, tag_fname, TRUE);\n\tif (fullname != NULL)\n\t{\n\t    retval = (fullpathcmp(fullname, buf_ffname, TRUE, TRUE) & FPC_SAME);\n\t    vim_free(fullname);\n\t}\n#ifdef FEAT_EMACS_TAGS\n\tif (!is_etag)\n#endif\n\t    *fname_end = c;\n    }\n\n    return retval;\n}\n\n/*\n * Find the end of the tagaddress.\n * Return OK if \";\\\"\" is following, FAIL otherwise.\n */\n    static int\nfind_extra(char_u **pp)\n{\n    char_u\t*str = *pp;\n    char_u\tfirst_char = **pp;\n\n    // Repeat for addresses separated with ';'\n    for (;;)\n    {\n\tif (VIM_ISDIGIT(*str))\n\t    str = skipdigits(str + 1);\n\telse if (*str == '/' || *str == '?')\n\t{\n\t    str = skip_regexp(str + 1, *str, FALSE);\n\t    if (*str != first_char)\n\t\tstr = NULL;\n\t    else\n\t\t++str;\n\t}\n\telse\n\t{\n\t    // not a line number or search string, look for terminator.\n\t    str = (char_u *)strstr((char *)str, \"|;\\\"\");\n\t    if (str != NULL)\n\t    {\n\t\t++str;\n\t\tbreak;\n\t    }\n\n\t}\n\tif (str == NULL || *str != ';'\n\t\t  || !(VIM_ISDIGIT(str[1]) || str[1] == '/' || str[1] == '?'))\n\t    break;\n\t++str;\t// skip ';'\n\tfirst_char = *str;\n    }\n\n    if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0)\n    {\n\t*pp = str;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free a single entry in a tag stack\n */\n    static void\ntagstack_clear_entry(taggy_T *item)\n{\n    VIM_CLEAR(item->tagname);\n    VIM_CLEAR(item->user_data);\n}\n\n    int\nexpand_tags(\n    int\t\ttagnames,\t// expand tag names\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\ti;\n    int\t\textra_flag;\n    char_u\t*name_buf;\n    size_t\tname_buf_size = 100;\n    tagptrs_T\tt_p;\n    int\t\tret;\n\n    name_buf = alloc(name_buf_size);\n    if (name_buf == NULL)\n\treturn FAIL;\n\n    if (tagnames)\n\textra_flag = TAG_NAMES;\n    else\n\textra_flag = 0;\n    if (pat[0] == '/')\n\tret = find_tags(pat + 1, num_file, file,\n\t\tTAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    else\n\tret = find_tags(pat, num_file, file,\n\t      TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC | TAG_NOIC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    if (ret == OK && !tagnames)\n    {\n\t // Reorganize the tags for display and matching as strings of:\n\t // \"<tagname>\\0<kind>\\0<filename>\\0\"\n\t for (i = 0; i < *num_file; i++)\n\t {\n\t     size_t\tlen;\n\n\t     parse_match((*file)[i], &t_p);\n\t     len = t_p.tagname_end - t_p.tagname;\n\t     if (len > name_buf_size - 3)\n\t     {\n\t\t char_u *buf;\n\n\t\t name_buf_size = len + 3;\n\t\t buf = vim_realloc(name_buf, name_buf_size);\n\t\t if (buf == NULL)\n\t\t {\n\t\t     vim_free(name_buf);\n\t\t     return FAIL;\n\t\t }\n\t\t name_buf = buf;\n\t     }\n\n\t     mch_memmove(name_buf, t_p.tagname, len);\n\t     name_buf[len++] = 0;\n\t     name_buf[len++] = (t_p.tagkind != NULL && *t_p.tagkind)\n\t\t\t\t\t\t\t  ? *t_p.tagkind : 'f';\n\t     name_buf[len++] = 0;\n\t     mch_memmove((*file)[i] + len, t_p.fname,\n\t\t\t\t\t\t    t_p.fname_end - t_p.fname);\n\t     (*file)[i][len + (t_p.fname_end - t_p.fname)] = 0;\n\t     mch_memmove((*file)[i], name_buf, len);\n\t}\n    }\n\n    vim_free(name_buf);\n    return ret;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a tag field to the dictionary \"dict\".\n * Return OK or FAIL.\n */\n    static int\nadd_tag_field(\n    dict_T  *dict,\n    char    *field_name,\n    char_u  *start,\t\t// start of the value\n    char_u  *end)\t\t// after the value; can be NULL\n{\n    char_u\t*buf;\n    int\t\tlen = 0;\n    int\t\tretval;\n\n    // check that the field name doesn't exist yet\n    if (dict_has_key(dict, field_name))\n    {\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Duplicate field name: %s\"), field_name);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn FAIL;\n    if (start != NULL)\n    {\n\tif (end == NULL)\n\t{\n\t    end = start + STRLEN(start);\n\t    while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))\n\t\t--end;\n\t}\n\tlen = (int)(end - start);\n\tif (len > MAXPATHL - 1)\n\t    len = MAXPATHL - 1;\n\tvim_strncpy(buf, start, len);\n    }\n    buf[len] = NUL;\n    retval = dict_add_string(dict, field_name, buf);\n    vim_free(buf);\n    return retval;\n}\n\n/*\n * Add the tags matching the specified pattern \"pat\" to the list \"list\"\n * as a dictionary. Use \"buf_fname\" for priority, unless NULL.\n */\n    int\nget_tags(list_T *list, char_u *pat, char_u *buf_fname)\n{\n    int\t\tnum_matches, i, ret;\n    char_u\t**matches, *p;\n    char_u\t*full_fname;\n    dict_T\t*dict;\n    tagptrs_T\ttp;\n    long\tis_static;\n\n    ret = find_tags(pat, &num_matches, &matches,\n\t\t\t\tTAG_REGEXP | TAG_NOIC, (int)MAXCOL, buf_fname);\n    if (ret == OK && num_matches > 0)\n    {\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    if (parse_match(matches[i], &tp) == FAIL)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    is_static = test_for_static(&tp);\n\n\t    // Skip pseudo-tag lines.\n\t    if (STRNCMP(tp.tagname, \"!_TAG_\", 6) == 0)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    if ((dict = dict_alloc()) == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tvim_free(matches[i]);\n\t\tbreak;\n\t    }\n\t    if (list_append_dict(list, dict) == FAIL)\n\t\tret = FAIL;\n\n\t    full_fname = tag_full_fname(&tp);\n\t    if (add_tag_field(dict, \"name\", tp.tagname, tp.tagname_end) == FAIL\n\t\t    || add_tag_field(dict, \"filename\", full_fname,\n\t\t\t\t\t\t\t NULL) == FAIL\n\t\t    || add_tag_field(dict, \"cmd\", tp.command,\n\t\t\t\t\t\t       tp.command_end) == FAIL\n\t\t    || add_tag_field(dict, \"kind\", tp.tagkind,\n\t\t\t\t\t\t      tp.tagkind_end) == FAIL\n\t\t    || dict_add_number(dict, \"static\", is_static) == FAIL)\n\t\tret = FAIL;\n\n\t    vim_free(full_fname);\n\n\t    if (tp.command_end != NULL)\n\t    {\n\t\tfor (p = tp.command_end + 3;\n\t\t\t  *p != NUL && *p != '\\n' && *p != '\\r'; MB_PTR_ADV(p))\n\t\t{\n\t\t    if (p == tp.tagkind || (p + 5 == tp.tagkind\n\t\t\t\t\t      && STRNCMP(p, \"kind:\", 5) == 0))\n\t\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\t\tp = tp.tagkind_end - 1;\n\t\t    else if (STRNCMP(p, \"file:\", 5) == 0)\n\t\t\t// skip \"file:\" (static tag)\n\t\t\tp += 4;\n\t\t    else if (!VIM_ISWHITE(*p))\n\t\t    {\n\t\t\tchar_u\t*s, *n;\n\t\t\tint\tlen;\n\n\t\t\t// Add extra field as a dict entry.  Fields are\n\t\t\t// separated by Tabs.\n\t\t\tn = p;\n\t\t\twhile (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')\n\t\t\t    ++p;\n\t\t\tlen = (int)(p - n);\n\t\t\tif (*p == ':' && len > 0)\n\t\t\t{\n\t\t\t    s = ++p;\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\t    n[len] = NUL;\n\t\t\t    if (add_tag_field(dict, (char *)n, s, p) == FAIL)\n\t\t\t\tret = FAIL;\n\t\t\t    n[len] = ':';\n\t\t\t}\n\t\t\telse\n\t\t\t    // Skip field without colon.\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\tif (*p == NUL)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(matches[i]);\n\t}\n\tvim_free(matches);\n    }\n    return ret;\n}\n\n/*\n * Return information about 'tag' in dict 'retdict'.\n */\n    static void\nget_tag_details(taggy_T *tag, dict_T *retdict)\n{\n    list_T\t*pos;\n    fmark_T\t*fmark;\n\n    dict_add_string(retdict, \"tagname\", tag->tagname);\n    dict_add_number(retdict, \"matchnr\", tag->cur_match + 1);\n    dict_add_number(retdict, \"bufnr\", tag->cur_fnum);\n    if (tag->user_data)\n\tdict_add_string(retdict, \"user_data\", tag->user_data);\n\n    if ((pos = list_alloc_id(aid_tagstack_from)) == NULL)\n\treturn;\n    dict_add_list(retdict, \"from\", pos);\n\n    fmark = &tag->fmark;\n    list_append_number(pos,\n\t\t\t(varnumber_T)(fmark->fnum != -1 ? fmark->fnum : 0));\n    list_append_number(pos, (varnumber_T)fmark->mark.lnum);\n    list_append_number(pos, (varnumber_T)(fmark->mark.col == MAXCOL ?\n\t\t\t\t\tMAXCOL : fmark->mark.col + 1));\n    list_append_number(pos, (varnumber_T)fmark->mark.coladd);\n}\n\n/*\n * Return the tag stack entries of the specified window 'wp' in dictionary\n * 'retdict'.\n */\n    void\nget_tagstack(win_T *wp, dict_T *retdict)\n{\n    list_T\t*l;\n    int\t\ti;\n    dict_T\t*d;\n\n    dict_add_number(retdict, \"length\", wp->w_tagstacklen);\n    dict_add_number(retdict, \"curidx\", wp->w_tagstackidx + 1);\n    l = list_alloc_id(aid_tagstack_items);\n    if (l == NULL)\n\treturn;\n    dict_add_list(retdict, \"items\", l);\n\n    for (i = 0; i < wp->w_tagstacklen; i++)\n    {\n\tif ((d = dict_alloc_id(aid_tagstack_details)) == NULL)\n\t    return;\n\tlist_append_dict(l, d);\n\n\tget_tag_details(&wp->w_tagstack[i], d);\n    }\n}\n\n/*\n * Free all the entries in the tag stack of the specified window\n */\n    static void\ntagstack_clear(win_T *wp)\n{\n    int i;\n\n    // Free the current tag stack\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n\ttagstack_clear_entry(&wp->w_tagstack[i]);\n    wp->w_tagstacklen = 0;\n    wp->w_tagstackidx = 0;\n}\n\n/*\n * Remove the oldest entry from the tag stack and shift the rest of\n * the entries to free up the top of the stack.\n */\n    static void\ntagstack_shift(win_T *wp)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\ti;\n\n    tagstack_clear_entry(&tagstack[0]);\n    for (i = 1; i < wp->w_tagstacklen; ++i)\n\ttagstack[i - 1] = tagstack[i];\n    wp->w_tagstacklen--;\n}\n\n/*\n * Push a new item to the tag stack\n */\n    static void\ntagstack_push_item(\n\twin_T\t*wp,\n\tchar_u\t*tagname,\n\tint\tcur_fnum,\n\tint\tcur_match,\n\tpos_T\tmark,\n\tint\tfnum,\n\tchar_u  *user_data)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\tidx = wp->w_tagstacklen;\t// top of the stack\n\n    // if the tagstack is full: remove the oldest entry\n    if (idx >= TAGSTACKSIZE)\n    {\n\ttagstack_shift(wp);\n\tidx = TAGSTACKSIZE - 1;\n    }\n\n    wp->w_tagstacklen++;\n    tagstack[idx].tagname = tagname;\n    tagstack[idx].cur_fnum = cur_fnum;\n    tagstack[idx].cur_match = cur_match;\n    if (tagstack[idx].cur_match < 0)\n\ttagstack[idx].cur_match = 0;\n    tagstack[idx].fmark.mark = mark;\n    tagstack[idx].fmark.fnum = fnum;\n    tagstack[idx].user_data = user_data;\n}\n\n/*\n * Add a list of items to the tag stack in the specified window\n */\n    static void\ntagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n\n    // Add one entry at a time to the tag stack\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t// Skip non-dict items\n\titemdict = li->li_tv.vval.v_dict;\n\n\t// parse 'from' for the cursor position before the tag jump\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}\n\n/*\n * Set the current index in the tag stack. Valid values are between 0\n * and the stack length (inclusive).\n */\n    static void\ntagstack_set_curidx(win_T *wp, int curidx)\n{\n    wp->w_tagstackidx = curidx;\n    if (wp->w_tagstackidx < 0)\t\t\t// sanity check\n\twp->w_tagstackidx = 0;\n    if (wp->w_tagstackidx > wp->w_tagstacklen)\n\twp->w_tagstackidx = wp->w_tagstacklen;\n}\n\n/*\n * Set the tag stack entries of the specified window.\n * 'action' is set to one of:\n *\t'a' for append\n *\t'r' for replace\n *\t't' for truncate\n */\n    int\nset_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n\n#ifdef FEAT_EVAL\n    // not allowed to alter the tag stack entries from inside tagfunc\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n\n    if (action == 't')\t\t    // truncate the stack\n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\n\t// delete all the tag stack entries above the current entry\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t// replace the stack\n\t    tagstack_clear(wp);\n\n\ttagstack_push_items(wp, l);\n\t// set the current index after the last entry\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n\n    return OK;\n}\n#endif\n", "\" Test 'tagfunc'\n\nimport './vim9.vim' as v9\nsource check.vim\nsource screendump.vim\n\nfunc TagFunc(pat, flag, info)\n  let g:tagfunc_args = [a:pat, a:flag, a:info]\n  let tags = []\n  for num in range(1,10)\n    let tags += [{\n          \\ 'cmd': '2', 'name': 'nothing'.num, 'kind': 'm',\n          \\ 'filename': 'Xfile1', 'user_data': 'somedata'.num,\n          \\}]\n  endfor\n  return tags\nendfunc\n\nfunc Test_tagfunc()\n  set tagfunc=TagFunc\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n\n  call assert_equal({'cmd': '2', 'static': 0,\n        \\ 'name': 'nothing2', 'user_data': 'somedata2',\n        \\ 'kind': 'm', 'filename': 'Xfile1'}, taglist('.')[1])\n\n  call settagstack(win_getid(), {'items': []})\n\n  tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata1', gettagstack().items[0].user_data)\n  5tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n  pop\n  tag\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n\n  let g:tagfunc_args=[]\n  execute \"normal! \\<c-]>\"\n  call assert_equal('one', g:tagfunc_args[0])\n  call assert_equal('c', g:tagfunc_args[1])\n\n  let g:tagfunc_args=[]\n  execute \"tag /foo$\"\n  call assert_equal('foo$', g:tagfunc_args[0])\n  call assert_equal('r', g:tagfunc_args[1])\n\n  set cpt=t\n  let g:tagfunc_args=[]\n  execute \"normal! i\\<c-n>\\<c-y>\"\n  call assert_equal('\\<\\k\\k', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing1', getline('.')[0:7])\n\n  let g:tagfunc_args=[]\n  execute \"normal! ono\\<c-n>\\<c-n>\\<c-y>\"\n  call assert_equal('\\<no', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing2', getline('.')[0:7])\n\n  func BadTagFunc1(...)\n    return 0\n  endfunc\n  func BadTagFunc2(...)\n    return [1]\n  endfunc\n  func BadTagFunc3(...)\n    return [{'name': 'foo'}]\n  endfunc\n\n  for &tagfunc in ['BadTagFunc1', 'BadTagFunc2', 'BadTagFunc3']\n    try\n      tag nothing\n      call assert_false(1, 'tag command should have failed')\n    catch\n      call assert_exception('E987:')\n    endtry\n    exe 'delf' &tagfunc\n  endfor\n\n  func NullTagFunc(...)\n    return v:null\n  endfunc\n  set tags= tfu=NullTagFunc\n  call assert_fails('tag nothing', 'E433:')\n  delf NullTagFunc\n\n  bwipe!\n  set tags& tfu& cpt& \n  call delete('Xfile1')\nendfunc\n\n\" Test for modifying the tag stack from a tag function and jumping to a tag\n\" from a tag function\nfunc Test_tagfunc_settagstack()\n  func Mytagfunc1(pat, flags, info)\n    call settagstack(1, {'tagname' : 'mytag', 'from' : [0, 10, 1, 0]})\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc1\n  call writefile([''], 'Xtest')\n  call assert_fails('tag xyz', 'E986:')\n\n  func Mytagfunc2(pat, flags, info)\n    tag test_tag\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc2\n  call assert_fails('tag xyz', 'E986:')\n\n  call delete('Xtest')\n  set tagfunc&\n  delfunc Mytagfunc1\n  delfunc Mytagfunc2\nendfunc\n\n\" Script local tagfunc callback function\nfunc s:ScriptLocalTagFunc(pat, flags, info)\n  let g:ScriptLocalFuncArgs = [a:pat, a:flags, a:info]\n  return v:null\nendfunc\n\n\" Test for different ways of setting the 'tagfunc' option\nfunc Test_tagfunc_callback()\n  func TagFunc1(callnr, pat, flags, info)\n    let g:TagFunc1Args = [a:callnr, a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  func TagFunc2(pat, flags, info)\n    let g:TagFunc2Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &tagfunc = 'g:TagFunc2'\n    new\n    LET g:TagFunc2Args = []\n    call assert_fails('tag a10', 'E433:')\n    call assert_equal(['a10', '', {}], g:TagFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set tagfunc=function('g:TagFunc1',\\ [10])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a11', 'E433:')\n    call assert_equal([10, 'a11', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    VAR Fn = function('g:TagFunc1', [11])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([11, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = function('g:TagFunc1', [12])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([12, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set tagfunc=funcref('g:TagFunc1',\\ [13])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a13', 'E433:')\n    call assert_equal([13, 'a13', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [14])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([14, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [15])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([15, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b, c LMIDDLE g:TagFunc1(16, a, b, c) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set tagfunc=\" .. optval\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a17', 'E433:')\n    call assert_equal([16, 'a17', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a lambda expression\n    LET &tagfunc = LSTART a, b, c LMIDDLE g:TagFunc1(17, a, b, c) LEND\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([17, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(lambda expression)\n    LET &tagfunc = 'LSTART a, b, c LMIDDLE g:TagFunc1(18, a, b, c) LEND'\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([18, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(19, a, b, c) LEND\n    LET &tagfunc = Lambda\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([19, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(20, a, b, c) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([20, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b, c LMIDDLE strlen(a) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    call assert_fails(\"tag a20\", \"E987:\")\n    bw!\n\n    #\" Test for clearing the 'tagfunc' option\n    set tagfunc=''\n    set tagfunc&\n    call assert_fails(\"set tagfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set tagfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'tagfunc' to a non-existing function\n    LET &tagfunc = function('g:TagFunc2', [21])\n    LET g:TagFunc2Args = []\n    call assert_fails(\"set tagfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &tagfunc = function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"tag axb123\", 'E426:')\n    call assert_equal([], g:TagFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TagFunc3(pat, flags, info)\n    let g:TagFunc3Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  set tagfunc=s:TagFunc3\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a21', 'E433:')\n  call assert_equal(['a21', '', {}], g:TagFunc3Args)\n  bw!\n  let &tagfunc = 's:TagFunc3'\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a22', 'E433:')\n  call assert_equal(['a22', '', {}], g:TagFunc3Args)\n  bw!\n  delfunc s:TagFunc3\n\n  \" invalid return value\n  let &tagfunc = \"{a -> 'abc'}\"\n  call assert_fails(\"echo taglist('a')\", \"E987:\")\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set tagfunc=(a,\\ b,\\ c)\\ =>\\ g:TagFunc1(21,\\ a,\\ b,\\ c)\n  new\n  let g:TagFunc1Args = []\n  call assert_fails(\"tag a17\", \"E117:\")\n  call assert_equal([], g:TagFunc1Args)\n  bw!\n\n  \" Test for using a script local function\n  set tagfunc=<SID>ScriptLocalTagFunc\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a15', 'E433:')\n  call assert_equal(['a15', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a script local funcref variable\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= Fn\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a string(script local funcref variable)\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= string(Fn)\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" set 'tagfunc' to a partial with dict. This used to cause a crash.\n  func SetTagFunc()\n    let params = {'tagfn': function('g:DictTagFunc')}\n    let &tagfunc = params.tagfn\n  endfunc\n  func g:DictTagFunc(_) dict\n  endfunc\n  call SetTagFunc()\n  new\n  call SetTagFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set tagfunc=\n  wincmd w\n  set tagfunc=\n  :%bw!\n  delfunc g:DictTagFunc\n  delfunc SetTagFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tagFunc(callnr: number, pat: string, flags: string, info: dict<any>): any\n      g:Vim9tagFuncArgs = [callnr, pat, flags, info]\n      return null\n    enddef\n\n    # Test for using a def function with completefunc\n    set tagfunc=function('Vim9tagFunc',\\ [60])\n    new\n    g:Vim9tagFuncArgs = []\n    assert_fails('tag a10', 'E433:')\n    assert_equal([60, 'a10', '', {}], g:Vim9tagFuncArgs)\n\n    # Test for using a global function name\n    &tagfunc = g:TagFunc2\n    new\n    g:TagFunc2Args = []\n    assert_fails('tag a11', 'E433:')\n    assert_equal(['a11', '', {}], g:TagFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTagFunc(pat: string, flags: string, info: dict<any> ): any\n      g:LocalTagFuncArgs = [pat, flags, info]\n      return null\n    enddef\n    &tagfunc = LocalTagFunc\n    new\n    g:LocalTagFuncArgs = []\n    assert_fails('tag a12', 'E433:')\n    assert_equal(['a12', '', {}], g:LocalTagFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  delfunc TagFunc1\n  delfunc TagFunc2\n  set tagfunc&\n  %bw!\nendfunc\n\nfunc Test_tagfunc_wipes_buffer()\n  func g:Tag0unc0(t,f,o)\n   bwipe\n  endfunc\n  set tagfunc=g:Tag0unc0\n  new\n  cal assert_fails('tag 0', 'E987:')\n\n  delfunc g:Tag0unc0\n  set tagfunc=\nendfunc\n\nfunc Test_tagfunc_closes_window()\n  split any\n  func MytagfuncClose(pat, flags, info)\n    close\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=MytagfuncClose\n  call assert_fails('tag xyz', 'E1299:')\n\n  set tagfunc=\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/errors.h", "src/tag.c", "src/testdir/test_tagfunc.vim", "src/version.c"], "buggy_code_start_loc": [3326, 691, 403, 705], "buggy_code_end_loc": [3326, 691, 403, 705], "fixing_code_start_loc": [3327, 692, 404, 706], "fixing_code_end_loc": [3329, 702, 417, 708], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0389.", "other": {"cve": {"id": "CVE-2022-3134", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-06T20:15:09.150", "lastModified": "2023-05-03T12:16:13.427", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0389."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0389"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0389", "matchCriteriaId": "3C956E50-9AD6-4E43-A2AF-B44093751477"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/ccfde4d028e891a41e3548323c3d47b06fb0b83e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6ec79e49-c7ab-4cd6-a517-e7934c2eb9dc", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/ccfde4d028e891a41e3548323c3d47b06fb0b83e"}}