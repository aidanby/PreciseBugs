{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst async = require('async')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst userSchema = require('../models/user')\nconst permissions = require('../permissions')\nconst emitter = require('../emitter')\nconst xss = require('xss')\n\nconst accountsController = {}\n\naccountsController.content = {}\n\nfunction handleError (res, err) {\n  if (err) {\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\naccountsController.signup = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowUserRegistration:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'Create Account'\n        content.layout = false\n        content.data = {}\n\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_signup', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\naccountsController.get = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Accounts'\n  content.nav = 'accounts'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  return res.render('accounts', content)\n}\n\naccountsController.getCustomers = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Customers'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-customers'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'customers'\n\n  return res.render('accounts', content)\n}\n\naccountsController.getAgents = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Agents'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-agents'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'agents'\n\n  return res.render('accounts', content)\n}\n\naccountsController.getAdmins = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Admins'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-admins'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'admins'\n\n  return res.render('accounts', content)\n}\n\naccountsController.importPage = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:import')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Accounts - Import'\n  content.nav = 'accounts'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  res.render('accounts_import', content)\n}\n\naccountsController.profile = function (req, res) {\n  const user = req.user\n  const backUrl = req.header('Referer') || '/'\n  if (_.isUndefined(user)) {\n    req.flash('message', 'Permission Denied.')\n    winston.warn('Undefined User - /Profile')\n    return res.redirect(backUrl)\n  }\n\n  const content = {}\n  content.title = 'Profile'\n  content.nav = 'profile'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.host = req.hostname\n  content.data.account = {}\n\n  async.parallel(\n    {\n      account: function (callback) {\n        userSchema.findOne({ _id: req.user._id }, '+accessToken +tOTPKey', function (err, obj) {\n          callback(err, obj)\n        })\n      }\n    },\n    function (err, result) {\n      if (err) {\n        winston.warn(err)\n        return res.redirect(backUrl)\n      }\n\n      content.data.account = result.account\n\n      res.render('subviews/profile', content)\n    }\n  )\n}\n\naccountsController.bindLdap = function (req, res) {\n  const ldap = require('../ldap')\n  const postData = req.body\n  if (_.isUndefined(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data.' })\n\n  const server = postData['ldap-server']\n  const dn = postData['ldap-bind-dn']\n  const password = postData['ldap-password']\n  const searchBase = postData['ldap-search-base']\n  const filter = postData['ldap-filter']\n\n  ldap.bind('ldap://' + server, dn, password, function (err) {\n    if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n    ldap.search(searchBase, filter, function (err, results) {\n      if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n      if (_.isUndefined(results)) return res.status(400).json({ success: false, error: 'Undefined Results' })\n\n      const entries = results.entries\n      let foundUsers = null\n      ldap.unbind(function (err) {\n        if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n        let mappedUsernames = _.map(entries, 'sAMAccountName')\n\n        userSchema.find({ username: mappedUsernames }, function (err, users) {\n          if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n          foundUsers = users\n\n          mappedUsernames = _.map(foundUsers, 'username')\n\n          _.each(mappedUsernames, function (mappedUsername) {\n            const u = _.find(entries, function (f) {\n              return f.sAMAccountName.toLowerCase() === mappedUsername.toLowerCase()\n            })\n\n            if (u) {\n              let clonedUser = _.find(foundUsers, function (g) {\n                return g.username.toLowerCase() === u.sAMAccountName.toLowerCase()\n              })\n              if (clonedUser) {\n                clonedUser = _.clone(clonedUser)\n                clonedUser.fullname = u.displayName\n                clonedUser.email = u.mail\n                clonedUser.title = u.title\n              }\n            }\n\n            _.remove(entries, function (k) {\n              return k.sAMAccountName.toLowerCase() === mappedUsername.toLowerCase()\n            })\n          })\n\n          _.remove(entries, function (e) {\n            return _.isUndefined(e.mail)\n          })\n\n          return res.json({\n            success: true,\n            addedUsers: entries,\n            updatedUsers: foundUsers\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction processUsers (addedUserArray, updatedUserArray, item, callback) {\n  userSchema.getUserByUsername(item.username, function (err, user) {\n    if (err) return callback(err)\n\n    if (user) {\n      updatedUserArray.push(item)\n    } else {\n      addedUserArray.push(item)\n    }\n\n    return callback()\n  })\n}\n\naccountsController.uploadCSV = function (req, res) {\n  const csv = require('fast-csv')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1\n    }\n  })\n\n  const object = {}\n\n  const parser = csv.parse()\n\n  busboy.on('file', function (name, file, info) {\n    object.csv = []\n\n    file\n      .on('readable', function () {\n        let data\n        while ((data = file.read()) !== null) {\n          parser.write(data)\n        }\n      })\n      .on('end', function () {\n        parser.end()\n      })\n  })\n\n  busboy.on('error', function (err) {\n    res.status(400).json({ success: false, error: err })\n  })\n\n  parser\n    .on('data', function (row) {\n      object.csv.push(row)\n    })\n    .on('end', function () {\n      if (object.csv.length < 1) {\n        return res.json({ success: false, error: 'Invalid CSV. No title Row.' })\n      }\n\n      const titleRow = object.csv[0]\n      const usernameIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'username'\n      })\n      const fullnameIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'name'\n      })\n      const emailIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'email'\n      })\n      const titleIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'title'\n      })\n      const roleIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'role'\n      })\n\n      object.csv.splice(0, 1)\n\n      // Left with just the data for the import; Lets map that to an array of usable objects.\n      object.csv = _.map(object.csv, function (item) {\n        return _.assign(\n          { username: item[usernameIdx] },\n          { fullname: item[fullnameIdx] },\n          { email: item[emailIdx] },\n          { title: item[titleIdx] },\n          { role: item[roleIdx] }\n        )\n      })\n\n      const addedUsers = []\n      const updatedUsers = []\n\n      async.each(\n        object.csv,\n        function (item, next) {\n          return processUsers(addedUsers, updatedUsers, item, next)\n        },\n        function (err) {\n          if (err) {\n            winston.warn(err.message)\n            return res.json({ success: false, error: err })\n          }\n\n          return res.json({\n            success: true,\n            contents: object.csv,\n            addedUsers: addedUsers,\n            updatedUsers: updatedUsers\n          })\n        }\n      )\n    })\n\n  req.pipe(busboy)\n}\n\naccountsController.uploadJSON = function (req, res) {\n  const Busboy = require('busboy')\n  const busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1\n    }\n  })\n\n  const addedUsers = []\n\n  const updatedUsers = []\n\n  const object = {}\n  let error\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    if (mimetype.indexOf('application/json') === -1) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n    let buffer = ''\n    file.on('data', function (data) {\n      buffer += data\n    })\n\n    file\n      .on('end', function () {\n        object.json = JSON.parse(buffer)\n        const accounts = object.json.accounts\n        if (_.isUndefined(accounts)) {\n          return res.status(400).json({\n            success: false,\n            error: 'No accounts defined in JSON file.'\n          })\n        }\n\n        async.eachSeries(\n          accounts,\n          function (item, next) {\n            return processUsers(addedUsers, updatedUsers, item, next)\n          },\n          function (err) {\n            if (err) {\n              return res.status(400).json({ success: false, error: err })\n            }\n\n            return res.json({\n              success: true,\n              contents: object.json,\n              addedUsers: addedUsers,\n              updatedUsers: updatedUsers\n            })\n          }\n        )\n      })\n      .setEncoding('utf8')\n  })\n\n  busboy.on('error', function (err) {\n    return res.status(400).json({ success: false, error: err })\n  })\n\n  busboy.on('finish', function () {\n    if (error) {\n      return res.status(error.status).json({ success: false, error: error })\n    }\n  })\n\n  req.pipe(busboy)\n}\n\naccountsController.uploadImage = function (req, res) {\n  const fs = require('fs')\n  const path = require('path')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 1024 * 1024 * 3 // 3mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === '_id') object._id = val\n    if (fieldname === 'username') object.username = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    const ext = path.extname(filename)\n    if (mimetype.indexOf('image/') === -1 || ext === '.svg') {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/users')\n    if (!fs.existsSync(savePath)) fs.mkdirSync(savePath)\n\n    object.filePath = path.join(savePath, 'aProfile_' + object.username + path.extname(filename))\n    object.filename = 'aProfile_' + object.username + path.extname(filename)\n    object.mimetype = mimetype\n\n    file.on('limit', function () {\n      error = {\n        status: 400,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      // if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath);\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.once('finish', function () {\n    if (error) {\n      winston.warn(error)\n      return res.status(error.status).send(error.message)\n    }\n\n    if (\n      _.isUndefined(object._id) ||\n      _.isUndefined(object.username) ||\n      _.isUndefined(object.filePath) ||\n      _.isUndefined(object.filename)\n    ) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(400).send('File Failed to Save to Disk')\n    if (path.extname(object.filename) === '.jpg' || path.extname(object.filename) === '.jpeg') {\n      require('../helpers/utils').stripExifData(object.filePath)\n    }\n\n    userSchema.getUser(object._id, function (err, user) {\n      if (err) return handleError(res, err)\n\n      user.image = object.filename\n\n      user.save(function (err) {\n        if (err) return handleError(res, err)\n\n        emitter.emit('trudesk:profileImageUpdate', {\n          userid: user._id,\n          img: user.image\n        })\n\n        return res.status(200).send('/uploads/users/' + object.filename)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nmodule.exports = accountsController\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    2/18/19 5:59 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar packagejson = require('../../../../package')\n\nmodule.exports = function (middleware, router, controllers) {\n  // ShortenVars\n  var apiv1 = middleware.api\n  var isAdmin = middleware.isAdmin\n  var isAgent = middleware.isAgent\n  var isAgentOrAdmin = middleware.isAgentOrAdmin\n  var canUser = middleware.canUser\n  var apiCtrl = controllers.api.v1\n\n  // Common\n  router.get('/api', controllers.api.index)\n  router.get('/api/v1/version', function (req, res) {\n    return res.json({ version: packagejson.version })\n  })\n  router.post('/api/v1/login', apiCtrl.common.login)\n  router.get('/api/v1/login', apiv1, apiCtrl.common.getLoggedInUser)\n  router.get('/api/v1/logout', apiv1, apiCtrl.common.logout)\n\n  // Roles\n  router.get('/api/v1/roles', apiv1, apiCtrl.roles.get)\n  router.post('/api/v1/roles', apiv1, isAdmin, apiCtrl.roles.create)\n  router.put('/api/v1/roles/:id', apiv1, isAdmin, apiCtrl.roles.update)\n  router.delete('/api/v1/roles/:id', apiv1, isAdmin, apiCtrl.roles.delete)\n\n  // Tickets\n  router.get('/api/v1/tickets', apiv1, canUser('tickets:view'), apiCtrl.tickets.get)\n  router.get('/api/v1/tickets/group/:id', apiv1, isAdmin, canUser('tickets:view'), apiCtrl.tickets.getByGroup)\n  router.get('/api/v1/tickets/search', apiv1, canUser('tickets:view'), apiCtrl.tickets.search)\n  router.post('/api/v1/tickets/create', apiv1, canUser('tickets:create'), apiCtrl.tickets.create)\n  router.get('/api/v1/tickets/type/:id', apiv1, apiCtrl.tickets.getType)\n  router.post('/api/v1/tickets/type/:id/removepriority', apiv1, isAdmin, apiCtrl.tickets.typeRemovePriority)\n  router.post('/api/v1/tickets/type/:id/addpriority', apiv1, isAdmin, apiCtrl.tickets.typeAddPriority)\n  router.get('/api/v1/tickets/types', apiv1, apiCtrl.tickets.getTypes)\n  router.post('/api/v1/tickets/types/create', apiv1, isAdmin, apiCtrl.tickets.createType)\n  router.put('/api/v1/tickets/types/:id', apiv1, isAdmin, apiCtrl.tickets.updateType)\n  router.delete('/api/v1/tickets/types/:id', apiv1, isAdmin, apiCtrl.tickets.deleteType)\n  router.post('/api/v1/tickets/priority/create', apiv1, isAdmin, apiCtrl.tickets.createPriority)\n  router.post('/api/v1/tickets/priority/:id/delete', apiv1, isAdmin, apiCtrl.tickets.deletePriority)\n  router.get('/api/v1/tickets/priorities', apiv1, apiCtrl.tickets.getPriorities)\n  router.put('/api/v1/tickets/priority/:id', apiv1, isAdmin, apiCtrl.tickets.updatePriority)\n\n  router.get('/api/v1/tickets/overdue', apiv1, canUser('tickets:view'), apiCtrl.tickets.getOverdue)\n  router.post('/api/v1/tickets/addcomment', apiv1, canUser('comments:create'), apiCtrl.tickets.postComment)\n  router.post('/api/v1/tickets/addnote', apiv1, canUser('tickets:notes'), apiCtrl.tickets.postInternalNote)\n  router.get('/api/v1/tickets/tags', apiv1, apiCtrl.tickets.getTags)\n  router.get('/api/v1/tickets/count/tags', apiv1, apiCtrl.tickets.getTagCount)\n  router.get('/api/v1/tickets/count/tags/:timespan', apiv1, apiCtrl.tickets.getTagCount)\n  router.get('/api/v1/tickets/count/days', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/count/days/:timespan', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/count/topgroups', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get('/api/v1/tickets/count/topgroups/:top', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get('/api/v1/tickets/count/topgroups/:timespan/:top', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get(\n    '/api/v1/tickets/count/group/:id',\n    apiv1,\n    isAgentOrAdmin,\n    canUser('tickets:view'),\n    apiCtrl.tickets.getCountByGroup\n  )\n  router.get('/api/v1/tickets/stats', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/stats/group/:group', apiv1, apiCtrl.tickets.getTicketStatsForGroup)\n  router.get('/api/v1/tickets/stats/user/:user', apiv1, apiCtrl.tickets.getTicketStatsForUser)\n  router.get('/api/v1/tickets/stats/:timespan', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/deleted', apiv1, isAdmin, apiCtrl.tickets.getDeletedTickets)\n  router.post('/api/v1/tickets/deleted/restore', apiv1, isAdmin, apiCtrl.tickets.restoreDeleted)\n  router.get('/api/v1/tickets/:uid', apiv1, canUser('tickets:view'), apiCtrl.tickets.single)\n  router.put('/api/v1/tickets/:id', apiv1, canUser('tickets:update'), apiCtrl.tickets.update)\n  router.delete('/api/v1/tickets/:id', apiv1, canUser('tickets:delete'), apiCtrl.tickets.delete)\n  router.put('/api/v1/tickets/:id/subscribe', apiv1, apiCtrl.tickets.subscribe)\n  router.delete(\n    '/api/v1/tickets/:tid/attachments/remove/:aid',\n    canUser('tickets:update'),\n    apiv1,\n    apiCtrl.tickets.removeAttachment\n  )\n\n  // Tags\n  router.get('/api/v1/count/tags', middleware.api, function (req, res) {\n    var tagSchema = require('../models/tag')\n    tagSchema.countDocuments({}, function (err, count) {\n      if (err) return res.status(500).json({ success: false, error: err })\n\n      return res.json({ success: true, count: count })\n    })\n  })\n\n  router.post('/api/v1/tags/create', apiv1, apiCtrl.tags.createTag)\n  router.get('/api/v1/tags/limit', apiv1, apiCtrl.tags.getTagsWithLimit)\n  router.put('/api/v1/tags/:id', apiv1, isAgentOrAdmin, apiCtrl.tags.updateTag)\n  router.delete('/api/v1/tags/:id', apiv1, isAgentOrAdmin, apiCtrl.tags.deleteTag)\n\n  // Public Tickets\n  var checkCaptcha = middleware.checkCaptcha\n  var checkOrigin = middleware.checkOrigin\n\n  router.post('/api/v1/public/users/checkemail', checkCaptcha, checkOrigin, apiCtrl.users.checkEmail)\n  router.post('/api/v1/public/tickets/create', checkCaptcha, checkOrigin, apiCtrl.tickets.createPublicTicket)\n  router.post('/api/v1/public/account/create', checkCaptcha, checkOrigin, apiCtrl.users.createPublicAccount)\n\n  // Groups\n  router.get('/api/v1/groups', apiv1, apiCtrl.groups.get)\n  router.get('/api/v1/groups/all', apiv1, canUser('groups:view'), apiCtrl.groups.getAll)\n  router.post('/api/v1/groups/create', apiv1, canUser('groups:create'), apiCtrl.groups.create)\n  router.get('/api/v1/groups/:id', apiv1, apiCtrl.groups.getSingleGroup)\n  router.put('/api/v1/groups/:id', apiv1, canUser('groups:update'), apiCtrl.groups.updateGroup)\n  router.delete('/api/v1/groups/:id', apiv1, canUser('groups:delete'), apiCtrl.groups.deleteGroup)\n\n  // Users\n  router.get('/api/v1/users', apiv1, canUser('accounts:view'), apiCtrl.users.getWithLimit)\n  router.post('/api/v1/users/create', apiv1, canUser('accounts:create'), apiCtrl.users.create)\n  router.get('/api/v1/users/notifications', apiv1, apiCtrl.users.getNotifications)\n  router.get('/api/v1/users/notificationCount', apiv1, apiCtrl.users.notificationCount)\n  router.get('/api/v1/users/getassignees', apiv1, isAgentOrAdmin, apiCtrl.users.getAssingees)\n  router.get('/api/v1/users/:username', apiv1, canUser('accounts:view'), apiCtrl.users.single)\n  router.put('/api/v1/users/:username', apiv1, canUser('accounts:update'), apiCtrl.users.update)\n  router.get('/api/v1/users/:username/groups', apiv1, apiCtrl.users.getGroups)\n  router.post('/api/v1/users/:username/uploadprofilepic', apiv1, apiCtrl.users.uploadProfilePic)\n  router.put('/api/v1/users/:username/updatepreferences', apiv1, apiCtrl.users.updatePreferences)\n  router.get('/api/v1/users/:username/enable', apiv1, canUser('accounts:update'), apiCtrl.users.enableUser)\n  router.delete('/api/v1/users/:username', apiv1, canUser('accounts:delete'), apiCtrl.users.deleteUser)\n  router.post('/api/v1/users/:id/generateapikey', apiv1, apiCtrl.users.generateApiKey)\n  router.post('/api/v1/users/:id/removeapikey', apiv1, apiCtrl.users.removeApiKey)\n  router.post('/api/v1/users/:id/generatel2auth', apiv1, middleware.csrfCheck, apiCtrl.users.generateL2Auth)\n  router.post('/api/v1/users/:id/removel2auth', apiv1, middleware.csrfCheck, apiCtrl.users.removeL2Auth)\n\n  // Messages\n  router.get('/api/v1/messages', apiv1, apiCtrl.messages.get)\n  router.post('/api/v1/messages/conversation/start', apiv1, apiCtrl.messages.startConversation)\n  router.get('/api/v1/messages/conversation/:id', apiv1, apiCtrl.messages.getMessagesForConversation)\n  router.delete('/api/v1/messages/conversation/:id', apiv1, apiCtrl.messages.deleteConversation)\n  router.get('/api/v1/messages/conversations', apiv1, apiCtrl.messages.getConversations)\n  router.get('/api/v1/messages/conversations/recent', apiv1, apiCtrl.messages.getRecentConversations)\n  router.post('/api/v1/messages/send', apiv1, apiCtrl.messages.send)\n\n  // Notices\n  router.post('/api/v1/notices/create', apiv1, canUser('notices:create'), apiCtrl.notices.create)\n  router.get('/api/v1/notices/clearactive', apiv1, canUser('notices:deactivate'), apiCtrl.notices.clearActive)\n  router.put('/api/v1/notices/:id', apiv1, canUser('notices:update'), apiCtrl.notices.updateNotice)\n  router.delete('/api/v1/notices/:id', apiv1, canUser('notices:delete'), apiCtrl.notices.deleteNotice)\n\n  // Reports Generator\n  var reportsGenCtrl = apiCtrl.reports.generate\n  var genBaseUrl = '/api/v1/reports/generate/'\n  router.post(genBaseUrl + 'tickets_by_group', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByGroup)\n  router.post(genBaseUrl + 'tickets_by_status', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByStatus)\n  router.post(genBaseUrl + 'tickets_by_priority', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByPriority)\n  router.post(genBaseUrl + 'tickets_by_tags', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByTags)\n  router.post(genBaseUrl + 'tickets_by_type', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByType)\n  router.post(genBaseUrl + 'tickets_by_user', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByUser)\n  router.post(genBaseUrl + 'tickets_by_assignee', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByAssignee)\n  router.post(genBaseUrl + 'tickets_by_team', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByTeam)\n\n  // Settings\n  router.get('/api/v1/settings', apiv1, apiCtrl.settings.getSettings)\n  router.put('/api/v1/settings', apiv1, isAdmin, apiCtrl.settings.updateSetting)\n  router.post('/api/v1/settings/testmailer', apiv1, isAdmin, apiCtrl.settings.testMailer)\n  router.put('/api/v1/settings/mailer/template/:id', apiv1, isAdmin, apiCtrl.settings.updateTemplateSubject)\n  router.get('/api/v1/settings/buildsass', apiv1, isAdmin, apiCtrl.settings.buildsass)\n  router.put('/api/v1/settings/updateroleorder', isAdmin, apiv1, apiCtrl.settings.updateRoleOrder)\n\n  // Backups\n  router.get('/api/v1/backups', apiv1, isAdmin, controllers.backuprestore.getBackups)\n  router.post('/api/v1/backup', apiv1, isAdmin, controllers.backuprestore.runBackup)\n  router.delete('/api/v1/backup/:backup', apiv1, isAdmin, controllers.backuprestore.deleteBackup)\n  router.post('/api/v1/backup/restore', apiv1, isAdmin, controllers.backuprestore.restoreBackup)\n  router.post('/api/v1/backup/upload', apiv1, isAdmin, controllers.backuprestore.uploadBackup)\n  router.get('/api/v1/backup/hastools', apiv1, isAdmin, controllers.backuprestore.hasBackupTools)\n\n  // Editor\n\n  router.get('/api/v1/editor/load/:id', apiv1, isAdmin, controllers.editor.load)\n  router.post('/api/v1/editor/save', apiv1, isAdmin, controllers.editor.save)\n  router.get('/api/v1/editor/assets', apiv1, isAdmin, controllers.editor.getAssets)\n  router.post('/api/v1/editor/assets/remove', apiv1, isAdmin, controllers.editor.removeAsset)\n  router.post('/api/v1/editor/assets/upload', apiv1, isAdmin, controllers.editor.assetsUpload)\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst async = require('async')\nconst _ = require('lodash')\nconst winston = require('winston')\nconst permissions = require('../../../permissions')\nconst emitter = require('../../../emitter')\nconst UserSchema = require('../../../models/user')\nconst groupSchema = require('../../../models/group')\nconst notificationSchema = require('../../../models/notification')\n\nconst apiUsers = {}\n\n/**\n * @api {get} /api/v1/users Gets users with query string\n * @apiName getUsers\n * @apiDescription Gets users with query string\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {number} count Count of users in array\n * @apiSuccess {array} users Users returned (populated)\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.getWithLimit = function (req, res) {\n  let limit = 10\n  if (!_.isUndefined(req.query.limit)) {\n    limit = parseInt(req.query.limit)\n  }\n  const page = parseInt(req.query.page)\n  const search = req.query.search\n\n  const obj = {\n    limit: limit,\n    page: page,\n    search: search\n  }\n\n  async.waterfall(\n    [\n      function (callback) {\n        UserSchema.getUserWithObject(obj, function (err, results) {\n          callback(err, results)\n        })\n      },\n      function (users, callback) {\n        const result = []\n\n        async.waterfall(\n          [\n            function (cc) {\n              groupSchema.getAllGroups(function (err, grps) {\n                if (err) return cc(err)\n                return cc(null, grps)\n              })\n            },\n            function (grps, cc) {\n              async.eachSeries(\n                users,\n                function (u, c) {\n                  const user = u.toObject()\n\n                  const groups = _.filter(grps, function (g) {\n                    return _.some(g.members, function (m) {\n                      return m._id.toString() === user._id.toString()\n                    })\n                  })\n\n                  user.groups = _.map(groups, function (group) {\n                    return { name: group.name, _id: group._id }\n                  })\n\n                  result.push(stripUserFields(user))\n                  return c()\n                },\n                function (err) {\n                  if (err) return callback(err)\n                  return cc(null, result)\n                }\n              )\n            }\n          ],\n          function (err, results) {\n            if (err) return callback(err)\n            return callback(null, results)\n          }\n        )\n      }\n    ],\n    function (err, rr) {\n      if (err) return res.status(400).json({ error: 'Error: ' + err.message })\n\n      return res.json({ success: true, count: _.size(rr), users: rr })\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/users/create Create Account\n * @apiName createAccount\n * @apiDescription Creates an account with the given post data.\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"aUsername\":    \"user.name\",\n *      \"aPass\":        \"password\",\n *      \"aPassConfirm\": \"password\",\n *      \"aFullname\":    \"fullname\",\n *      \"aEmail\":       \"email@email.com\",\n *      \"aRole\":        {RoleId},\n *      \"aTitle\":       \"User Title\",\n *      \"aGrps\":        [{GroupId}]\n * }\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} account Saved Account Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.create = function (req, res) {\n  const response = {}\n  response.success = true\n\n  const postData = req.body\n\n  if (_.isUndefined(postData) || !_.isObject(postData)) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  const propCheck = ['aUsername', 'aPass', 'aPassConfirm', 'aFullname', 'aEmail', 'aRole']\n\n  if (\n    !_.every(propCheck, function (x) {\n      return x in postData\n    })\n  ) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  if (_.isUndefined(postData.aGrps) || _.isNull(postData.aGrps) || !_.isArray(postData.aGrps)) {\n    return res.status(400).json({ success: false, error: 'Invalid Group Array' })\n  }\n\n  if (postData.aPass !== postData.aPassConfirm)\n    return res.status(400).json({ success: false, error: 'Invalid Password Match' })\n\n  const Chance = require('chance')\n  const chance = new Chance()\n\n  const account = new UserSchema({\n    username: postData.aUsername,\n    password: postData.aPass,\n    fullname: postData.aFullname,\n    email: postData.aEmail,\n    accessToken: chance.hash(),\n    role: postData.aRole\n  })\n\n  if (postData.aTitle) {\n    account.title = postData.aTitle\n  }\n\n  account.save(function (err, a) {\n    if (err) {\n      response.success = false\n      response.error = err\n      winston.debug(response)\n      return res.status(400).json(response)\n    }\n\n    a.populate('role', function (err, populatedAccount) {\n      if (err) return res.status(500).json({ success: false, error: err })\n\n      response.account = populatedAccount.toObject()\n      delete response.account.password\n\n      const groups = []\n\n      async.each(\n        postData.aGrps,\n        function (id, done) {\n          if (_.isUndefined(id)) return done(null)\n          groupSchema.getGroupById(id, function (err, grp) {\n            if (err) return done(err)\n            if (!grp) return done('Invalid Group (' + id + ') - Group not found. Check Group ID')\n\n            grp.addMember(a._id, function (err, success) {\n              if (err) return done(err)\n\n              grp.save(function (err) {\n                if (err) return done(err)\n                groups.push(grp)\n                done(null, success)\n              })\n            })\n          })\n        },\n        function (err) {\n          if (err) return res.status(400).json({ success: false, error: err })\n          response.account.groups = groups\n          return res.json(response)\n        }\n      )\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/public/account/create Create Public Account\n * @apiName createPublicAccount\n * @apiDescription Creates an account with the given post data.\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"aFullname\":    \"user name\",\n *      \"aEmail\":       \"email@email.com\"\"\n *      \"aPassword\":    \"password\",\n * }\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} account Saved Account Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.createPublicAccount = function (req, res) {\n  const SettingSchema = require('../../../models/setting')\n\n  const response = {}\n  response.success = true\n  const postData = req.body\n  if (!_.isObject(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  let user, group\n\n  async.waterfall(\n    [\n      function (next) {\n        SettingSchema.getSetting('allowUserRegistration:enable', function (err, allowUserRegistration) {\n          if (err) return next(err)\n          if (!allowUserRegistration) {\n            winston.warn('Public account creation was attempted while disabled!')\n            return next({ message: 'Public account creation is disabled.' })\n          }\n\n          return next()\n        })\n      },\n      function (next) {\n        SettingSchema.getSetting('role:user:default', function (err, roleDefault) {\n          if (err) return next(err)\n          if (!roleDefault) {\n            winston.error('No Default User Role Set. (Settings > Permissions > Default User Role)')\n            return next({ message: 'No Default Role Set. Please contact administrator.' })\n          }\n\n          return next(null, roleDefault)\n        })\n      },\n      function (roleDefault, next) {\n        const UserSchema = require('../../../models/user')\n        user = new UserSchema({\n          username: postData.user.email,\n          password: postData.user.password,\n          fullname: postData.user.fullname,\n          email: postData.user.email,\n          role: roleDefault.value\n        })\n\n        user.save(function (err, savedUser) {\n          if (err) return next(err)\n\n          return next(null, savedUser)\n        })\n      },\n      function (savedUser, next) {\n        const GroupSchema = require('../../../models/group')\n        group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, savedGroup) {\n          if (err) return next(err)\n\n          return next(null, { user: savedUser, group: savedGroup })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) winston.debug(err)\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      delete result.user.password\n      result.user.password = undefined\n\n      return res.json({\n        success: true,\n        userData: { user: result.user, group: result.group }\n      })\n    }\n  )\n}\n\n/**\n * @api {put} /api/v1/users/:username Update User\n * @apiName updateUser\n * @apiDescription Updates a single user.\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiParamExample {json} Request:\n * {\n        aId:            {{_id}},\n        aUsername:      {{username}},\n        aFullname:      {{fullname}},\n        aTitle:         {{title}},\n        aPass:          {{password}},\n        aPassconfirm:   {{password_confirm}},\n        aEmail:         {{email}},\n        aRole:          {{role.id}},\n        aGrps:          [{{group._id}}]\n * }\n *\n * @apiSuccess {object} user Saved User Object [Stripped]\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.update = function (req, res) {\n  const username = req.params.username\n  if (_.isNull(username) || _.isUndefined(username))\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  const data = req.body\n  // saveGroups - Profile saving where groups are not sent\n  const saveGroups = !_.isUndefined(data.saveGroups) ? data.saveGroups : true\n  let passwordUpdated = false\n\n  const obj = {\n    fullname: data.aFullname,\n    title: data.aTitle,\n    password: data.aPass,\n    passconfirm: data.aPassConfirm,\n    email: data.aEmail,\n    role: data.aRole,\n    groups: data.aGrps\n  }\n\n  if (_.isNull(obj.groups) || _.isUndefined(obj.groups)) {\n    obj.groups = []\n  } else if (!_.isArray(obj.groups)) {\n    obj.groups = [obj.groups]\n  }\n\n  async.series(\n    {\n      user: function (done) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return done(err)\n          if (!user) return done('Invalid User Object')\n\n          obj._id = user._id\n\n          if (\n            !_.isUndefined(obj.password) &&\n            !_.isEmpty(obj.password) &&\n            !_.isUndefined(obj.passconfirm) &&\n            !_.isEmpty(obj.passconfirm)\n          ) {\n            if (obj.password === obj.passconfirm) {\n              user.password = obj.password\n              passwordUpdated = true\n            }\n          }\n\n          if (!_.isUndefined(obj.fullname) && obj.fullname.length > 0) user.fullname = obj.fullname\n          if (!_.isUndefined(obj.email) && obj.email.length > 0) user.email = obj.email\n          if (!_.isUndefined(obj.title) && obj.title.length > 0) user.title = obj.title\n          if (!_.isUndefined(obj.role) && obj.role.length > 0) user.role = obj.role\n\n          user.save(function (err, nUser) {\n            if (err) return done(err)\n\n            nUser.populate('role', function (err, populatedUser) {\n              if (err) return done(err)\n              const resUser = stripUserFields(populatedUser)\n\n              return done(null, resUser)\n            })\n          })\n        })\n      },\n      groups: function (done) {\n        if (!saveGroups) {\n          groupSchema.getAllGroupsOfUser(obj._id, done)\n        } else {\n          const userGroups = []\n          groupSchema.getAllGroups(function (err, groups) {\n            if (err) return done(err)\n            async.each(\n              groups,\n              function (grp, callback) {\n                if (_.includes(obj.groups, grp._id.toString())) {\n                  if (grp.isMember(obj._id)) {\n                    userGroups.push(grp)\n                    return callback()\n                  }\n                  grp.addMember(obj._id, function (err, result) {\n                    if (err) return callback(err)\n\n                    if (result) {\n                      grp.save(function (err) {\n                        if (err) return callback(err)\n                        userGroups.push(grp)\n                        return callback()\n                      })\n                    } else {\n                      return callback()\n                    }\n                  })\n                } else {\n                  // Remove Member from group\n                  grp.removeMember(obj._id, function (err, result) {\n                    if (err) return callback(err)\n                    if (result) {\n                      grp.save(function (err) {\n                        if (err) return callback(err)\n\n                        return callback()\n                      })\n                    } else {\n                      return callback()\n                    }\n                  })\n                }\n              },\n              function (err) {\n                if (err) return done(err)\n\n                return done(null, userGroups)\n              }\n            )\n          })\n        }\n      }\n    },\n    async function (err, results) {\n      if (err) {\n        winston.debug(err)\n        return res.status(400).json({ success: false, error: err })\n      }\n\n      const user = results.user.toJSON()\n      user.groups = results.groups.map(function (g) {\n        return { _id: g._id, name: g.name }\n      })\n\n      if (passwordUpdated) {\n        const Session = require('../../../models/session')\n        await Session.destroy(user._id)\n      }\n\n      return res.json({ success: true, user: user })\n    }\n  )\n}\n\n/**\n * @api {put} /api/v1/users/:username/updatepreferences Updates User Preferences\n * @apiName updatePreferences\n * @apiDescription Updates a single user preference.\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\" -H \"accesstoken: {accesstoken}\" -X PUT -d \"{\\\"preference\\\":\\\"{preference_name}\\\",\\\"value\\\":{value}}\" -l http://localhost/api/v1/users/{username}/updatepreferences\n *\n * @apiParamExample {json} Request:\n * {\n *      \"preference\": \"preference_name\",\n *      \"value\": \"preference_value\"\n * }\n *\n * @apiSuccess {object} user Saved User Object [Stripped]\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.updatePreferences = function (req, res) {\n  const username = req.params.username\n  if (typeof username === 'undefined') {\n    return res.status(400).json({ success: false, error: 'Invalid Request' })\n  }\n\n  const data = req.body\n  const preference = data.preference\n  const value = data.value\n\n  UserSchema.getUserByUsername(username, function (err, user) {\n    if (err) {\n      winston.warn('[API:USERS:UpdatePreferences] Error= ' + err)\n      return res.status(400).json({ success: false, error: err })\n    }\n\n    if (_.isNull(user.preferences)) {\n      user.preferences = {}\n    }\n\n    user.preferences[preference] = value\n\n    user.save(function (err, u) {\n      if (err) {\n        winston.warn('[API:USERS:UpdatePreferences] Error= ' + err)\n        return res.status(400).json({ success: false, error: err })\n      }\n\n      const resUser = stripUserFields(u)\n\n      return res.json({ success: true, user: resUser })\n    })\n  })\n}\n\n/**\n * @api {delete} /api/v1/users/:username Delete / Disable User\n * @apiName deleteUser\n * @apiDescription Disables or Deletes the giving user via username\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username\n *\n * @apiSuccess {boolean}     success    Was the user successfully Deleted or disabled.\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.deleteUser = function (req, res) {\n  const username = req.params.username\n\n  if (_.isUndefined(username) || _.isNull(username)) return res.status(400).json({ error: 'Invalid Request' })\n\n  async.waterfall(\n    [\n      function (cb) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return cb(err)\n\n          if (_.isNull(user)) {\n            return cb({ message: 'Invalid User' })\n          }\n\n          if (user.username.toLowerCase() === req.user.username) {\n            return cb({ message: 'Cannot remove yourself!' })\n          }\n\n          if (!permissions.canThis(req.user.role, 'accounts:delete')) return cb({ message: 'Access Denied' })\n\n          // TODO: FIX THIS FOR HIERARCHY!!\n          // if (req.user.role.toLowerCase() === 'support' || req.user.role.toLowerCase() === 'user') {\n          //     if (user.role.toLowerCase() === 'mod' || user.role.toLowerCase() === 'admin')\n          //         return cb({message: 'Insufficient permissions'});\n          //\n          // }\n\n          return cb(null, user)\n        })\n      },\n      function (user, cb) {\n        const ticketSchema = require('../../../models/ticket')\n        ticketSchema.find({ owner: user._id }, function (err, tickets) {\n          if (err) return cb(err)\n\n          const hasTickets = _.size(tickets) > 0\n          return cb(null, hasTickets, user)\n        })\n      },\n      function (hasTickets, user, cb) {\n        const conversationSchema = require('../../../models/chat/conversation')\n        conversationSchema.getConversationsWithLimit(user._id, 10, function (err, conversations) {\n          if (err) return cb(err)\n\n          const hasConversations = _.size(conversations) > 0\n          return cb(null, hasTickets, hasConversations, user)\n        })\n      },\n      function (hasTickets, hasConversations, user, cb) {\n        const ticketSchema = require('../../../models/ticket')\n        ticketSchema.find({ assignee: user._id }, function (err, tickets) {\n          if (err) return cb(err)\n\n          const isAssignee = _.size(tickets) > 0\n          return cb(null, hasTickets, hasConversations, isAssignee, user)\n        })\n      },\n      function (hasTickets, hasConversations, isAssignee, user, cb) {\n        if (hasTickets || hasConversations || isAssignee) {\n          // Disable if the user has tickets or conversations\n          user.softDelete(function (err) {\n            if (err) return cb(err)\n\n            // Force logout if Logged in\n            return cb(null, true)\n          })\n        } else {\n          user.remove(function (err) {\n            if (err) return cb(err)\n\n            return cb(null, false)\n          })\n        }\n      }\n    ],\n    function (err, disabled) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, disabled: disabled })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/users/:username/enable Enable User\n * @apiName enableUser\n * @apiDescription Enable the giving user via username\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username/enable\n *\n * @apiSuccess {boolean}     success    Was the user successfully enabled.\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.enableUser = function (req, res) {\n  const username = req.params.username\n  if (_.isUndefined(username)) return res.status(400).json({ error: 'Invalid Request' })\n\n  UserSchema.getUserByUsername(username, function (err, user) {\n    if (err) {\n      winston.debug(err)\n      return res.status(400).json({ error: err.message })\n    }\n\n    if (_.isUndefined(user) || _.isNull(user)) return res.status(400).json({ error: 'Invalid Request' })\n\n    if (!permissions.canThis(req.user.role, 'accounts:delete'))\n      return res.status(401).json({ error: 'Invalid Permissions' })\n\n    user.deleted = false\n\n    user.save(function (err) {\n      if (err) return res.status(400).json({ error: err.message })\n\n      res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {get} /api/v1/users/:username Get User\n * @apiName getUser\n * @apiDescription Gets the user via the given username\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username\n *\n * @apiSuccess {object}     _id                 The MongoDB ID\n * @apiSuccess {string}     username            Username of the User\n * @apiSuccess {string}     fullname            Fullname of the User\n * @apiSuccess {string}     email               Email Address of the User\n * @apiSuccess {string}     role                Assigned Permission Role of the user\n * @apiSuccess {string}     title               Title of the User\n * @apiSuccess {string}     image               Image filename for the user's profile picture\n * @apiSuccess {array}      iOSDeviceTokens     iOS Device Tokens for push notifications\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.single = function (req, res) {\n  const username = req.params.username\n  if (_.isUndefined(username)) return res.status(400).json({ error: 'Invalid Request.' })\n\n  const response = {\n    success: true,\n    groups: []\n  }\n\n  async.waterfall(\n    [\n      function (done) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return done(err)\n\n          if (_.isUndefined(user) || _.isNull(user)) return done('Invalid Request')\n\n          user = stripUserFields(user)\n          response.user = user\n\n          done(null, user)\n        })\n      },\n      function (user, done) {\n        groupSchema.getAllGroupsOfUserNoPopulate(user._id, function (err, grps) {\n          if (err) return done(err)\n\n          response.groups = _.map(grps, function (o) {\n            return o._id\n          })\n\n          done(null, response.groups)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return res.status(400).json({ error: err })\n\n      res.json(response)\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/users/notificationCount Get Notification Count\n * @apiName getNotificationCount\n * @apiDescription Gets the current notification count for the currently logged in user.\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/notificationCount\n *\n * @apiSuccess {string}     count   The Notification Count\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.notificationCount = function (req, res) {\n  notificationSchema.getUnreadCount(req.user._id, function (err, count) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    return res.json({ success: true, count: count.toString() })\n  })\n}\n\napiUsers.getNotifications = function (req, res) {\n  notificationSchema.findAllForUser(req.user._id, function (err, notifications) {\n    if (err) return res.status(500).json({ success: false, error: err.message })\n\n    return res.json({ success: true, notifications: notifications })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/generateapikey Generate API Key\n * @apiName generateApiKey\n * @apiDescription Generates an API key for the given user id\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/generateapikey\n *\n * @apiSuccess {string}     token   Generated API Key\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.generateApiKey = function (req, res) {\n  const id = req.params.id\n  if (_.isUndefined(id) || _.isNull(id)) return res.status(400).json({ error: 'Invalid Request' })\n  if (!req.user.role.isAdmin && req.user._id.toString() !== id)\n    return res.status(401).json({ success: false, error: 'Unauthorized' })\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err || !user) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    // if (user.accessToken) return res.status(400).json({ success: false, error: 'User already has generated token' })\n\n    user.addAccessToken(function (err, token) {\n      if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n      res.json({ token: token })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/removeapikey Removes API Key\n * @apiName removeApiKey\n * @apiDescription Removes API key for the given user id\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/removeapikey\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.removeApiKey = function (req, res) {\n  const id = req.params.id\n  if (_.isUndefined(id) || _.isNull(id)) return res.status(400).json({ error: 'Invalid Request' })\n\n  if (!req.user.isAdmin && req.user._id.toString() !== id) return res.status(401).json({ success: 'Unauthorized' })\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ error: 'Invalid Request', fullError: err })\n\n    user.removeAccessToken(function (err) {\n      if (err) return res.status(400).json({ error: 'Invalid Request', fullError: err })\n\n      return res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/generatel2auth Generate Layer Two Auth\n * @apiName generateL2Auth\n * @apiDescription Generate a new layer two auth for the given user id\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/generatel2auth\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.generateL2Auth = function (req, res) {\n  const id = req.params.id\n  if (id.toString() !== req.user._id.toString()) {\n    return res.status(400).json({ success: false, error: 'Invalid Account Owner!' })\n  }\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    user.generateL2Auth(function (err, generatedKey) {\n      if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n      req.session.l2auth = 'totp'\n      return res.json({ success: true, generatedKey: generatedKey })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/removel2auth Removes Layer Two Auth\n * @apiName removeL2Auth\n * @apiDescription Removes Layer Two Auth for the given user id\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/removel2auth\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.removeL2Auth = function (req, res) {\n  const id = req.params.id\n  if (id.toString() !== req.user._id.toString()) {\n    return res.status(400).json({ success: false, error: 'Invalid Account Owner!' })\n  }\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    user.removeL2Auth(function (err) {\n      if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n      req.session.l2auth = null\n      return res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/checkemail\n * @apiName checkEmail\n * @apiDescription Returns a true if email exists\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/checkemail\n *\n * @apiSuccess {boolean}     success   Successful?\n * @apiSuccess {boolean}     emailexist Does Email Exist?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\n\napiUsers.checkEmail = function (req, res) {\n  const email = req.body.email\n\n  if (_.isUndefined(email) || _.isNull(email)) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  UserSchema.getUserByEmail(email, function (err, users) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (!_.isNull(users)) {\n      return res.json({ success: true, exist: true })\n    }\n\n    return res.json({ success: true, exist: false })\n  })\n}\n\n/**\n * @api {get} /api/v1/users/getassignees Get Assignees\n * @apiName getassignees\n * @apiDescription Returns a list of assignable users\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/getassignees\n *\n * @apiSuccess {boolean}     success   Successful?\n * @apiSuccess {array}       users     Array of Assignees\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.getAssingees = function (req, res) {\n  UserSchema.getAssigneeUsers(function (err, users) {\n    if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n    const strippedUsers = []\n\n    async.each(\n      users,\n      function (user, cb) {\n        user = stripUserFields(user)\n        strippedUsers.push(user)\n\n        cb()\n      },\n      function () {\n        return res.json({ success: true, users: strippedUsers })\n      }\n    )\n  })\n}\n\napiUsers.getGroups = function (req, res) {\n  if (req.user.role.isAdmin || req.user.role.isAgent) {\n    const departmentSchema = require('../../../models/department')\n    departmentSchema.getDepartmentGroupsOfUser(req.user._id, function (err, groups) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      const mappedGroups = groups.map(function (g) {\n        return g._id\n      })\n\n      return res.json({ success: true, groups: mappedGroups })\n    })\n  } else {\n    if (req.user.username !== req.params.username)\n      return res.status(400).json({ success: false, error: 'Invalid API Call' })\n\n    groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, function (err, groups) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      const mappedGroups = groups.map(function (g) {\n        return g._id\n      })\n\n      return res.json({ success: true, groups: mappedGroups })\n    })\n  }\n}\n\napiUsers.uploadProfilePic = function (req, res) {\n  const fs = require('fs')\n  const path = require('path')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 1024 * 1024 * 3\n    }\n  })\n\n  const object = {}\n  let error\n\n  if (_.isUndefined(req.params.username)) return res.status(400).json({ error: 'Invalid Username' })\n  object.username = req.params.username\n\n  busboy.on('file', function (name, file, info) {\n    const mimetype = info.mimeType\n\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 400,\n        message: 'Invalid file type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../../../public/uploads/users')\n    if (!fs.existsSync(savePath)) fs.mkdirSync(savePath)\n\n    object.filePath = path.join(savePath, 'aProfile_' + object.username + '.jpg')\n    object.filename = 'aProfile_' + object.username + '.jpg'\n    object.mimetype = mimetype\n\n    file.on('limit', function () {\n      error = {\n        status: 400,\n        message: 'File too large'\n      }\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.username) || _.isUndefined(object.filePath) || _.isUndefined(object.filename)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    if (!fs.existsSync(object.filePath)) return res.status(400).send('File failed to save to disk')\n\n    UserSchema.getUserByUsername(object.username, function (err, user) {\n      if (err) return res.status(400).send(err.message)\n\n      user.image = object.filename\n\n      user.save(function (err) {\n        if (err) return res.status(500).send(err.message)\n\n        emitter.emit('trudesk:profileImageUpdate', {\n          userid: user._id,\n          img: user.image\n        })\n\n        return res.json({ success: true, user: stripUserFields(user) })\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction stripUserFields (user) {\n  user.password = undefined\n  user.accessToken = undefined\n  user.__v = undefined\n  user.tOTPKey = undefined\n  user.iOSDeviceTokens = undefined\n\n  return user\n}\n\nmodule.exports = apiUsers\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst async = require('async')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst userSchema = require('../models/user')\nconst permissions = require('../permissions')\nconst emitter = require('../emitter')\nconst xss = require('xss')\nconst path = require('path')\n\nconst accountsController = {}\n\naccountsController.content = {}\n\nfunction handleError (res, err) {\n  if (err) {\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\naccountsController.signup = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowUserRegistration:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'Create Account'\n        content.layout = false\n        content.data = {}\n\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_signup', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\naccountsController.get = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Accounts'\n  content.nav = 'accounts'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  return res.render('accounts', content)\n}\n\naccountsController.getCustomers = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Customers'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-customers'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'customers'\n\n  return res.render('accounts', content)\n}\n\naccountsController.getAgents = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Agents'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-agents'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'agents'\n\n  return res.render('accounts', content)\n}\n\naccountsController.getAdmins = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:view')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Admins'\n  content.nav = 'accounts'\n  content.subnav = 'accounts-admins'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.view = 'admins'\n\n  return res.render('accounts', content)\n}\n\naccountsController.importPage = function (req, res) {\n  const user = req.user\n  if (_.isUndefined(user) || !permissions.canThis(user.role, 'accounts:import')) {\n    return res.redirect('/')\n  }\n\n  const content = {}\n  content.title = 'Accounts - Import'\n  content.nav = 'accounts'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  res.render('accounts_import', content)\n}\n\naccountsController.profile = function (req, res) {\n  const user = req.user\n  const backUrl = req.header('Referer') || '/'\n  if (_.isUndefined(user)) {\n    req.flash('message', 'Permission Denied.')\n    winston.warn('Undefined User - /Profile')\n    return res.redirect(backUrl)\n  }\n\n  const content = {}\n  content.title = 'Profile'\n  content.nav = 'profile'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.host = req.hostname\n  content.data.account = {}\n\n  async.parallel(\n    {\n      account: function (callback) {\n        userSchema.findOne({ _id: req.user._id }, '+accessToken +tOTPKey', function (err, obj) {\n          callback(err, obj)\n        })\n      }\n    },\n    function (err, result) {\n      if (err) {\n        winston.warn(err)\n        return res.redirect(backUrl)\n      }\n\n      content.data.account = result.account\n\n      res.render('subviews/profile', content)\n    }\n  )\n}\n\naccountsController.bindLdap = function (req, res) {\n  const ldap = require('../ldap')\n  const postData = req.body\n  if (_.isUndefined(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data.' })\n\n  const server = postData['ldap-server']\n  const dn = postData['ldap-bind-dn']\n  const password = postData['ldap-password']\n  const searchBase = postData['ldap-search-base']\n  const filter = postData['ldap-filter']\n\n  ldap.bind('ldap://' + server, dn, password, function (err) {\n    if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n    ldap.search(searchBase, filter, function (err, results) {\n      if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n      if (_.isUndefined(results)) return res.status(400).json({ success: false, error: 'Undefined Results' })\n\n      const entries = results.entries\n      let foundUsers = null\n      ldap.unbind(function (err) {\n        if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n        let mappedUsernames = _.map(entries, 'sAMAccountName')\n\n        userSchema.find({ username: mappedUsernames }, function (err, users) {\n          if (err && !res.headersSent) return res.status(400).json({ success: false, error: err })\n\n          foundUsers = users\n\n          mappedUsernames = _.map(foundUsers, 'username')\n\n          _.each(mappedUsernames, function (mappedUsername) {\n            const u = _.find(entries, function (f) {\n              return f.sAMAccountName.toLowerCase() === mappedUsername.toLowerCase()\n            })\n\n            if (u) {\n              let clonedUser = _.find(foundUsers, function (g) {\n                return g.username.toLowerCase() === u.sAMAccountName.toLowerCase()\n              })\n              if (clonedUser) {\n                clonedUser = _.clone(clonedUser)\n                clonedUser.fullname = u.displayName\n                clonedUser.email = u.mail\n                clonedUser.title = u.title\n              }\n            }\n\n            _.remove(entries, function (k) {\n              return k.sAMAccountName.toLowerCase() === mappedUsername.toLowerCase()\n            })\n          })\n\n          _.remove(entries, function (e) {\n            return _.isUndefined(e.mail)\n          })\n\n          return res.json({\n            success: true,\n            addedUsers: entries,\n            updatedUsers: foundUsers\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction processUsers (addedUserArray, updatedUserArray, item, callback) {\n  userSchema.getUserByUsername(item.username, function (err, user) {\n    if (err) return callback(err)\n\n    if (user) {\n      updatedUserArray.push(item)\n    } else {\n      addedUserArray.push(item)\n    }\n\n    return callback()\n  })\n}\n\naccountsController.uploadCSV = function (req, res) {\n  const csv = require('fast-csv')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1\n    }\n  })\n\n  const object = {}\n\n  const parser = csv.parse()\n\n  busboy.on('file', function (name, file, info) {\n    object.csv = []\n\n    file\n      .on('readable', function () {\n        let data\n        while ((data = file.read()) !== null) {\n          parser.write(data)\n        }\n      })\n      .on('end', function () {\n        parser.end()\n      })\n  })\n\n  busboy.on('error', function (err) {\n    res.status(400).json({ success: false, error: err })\n  })\n\n  parser\n    .on('data', function (row) {\n      object.csv.push(row)\n    })\n    .on('end', function () {\n      if (object.csv.length < 1) {\n        return res.json({ success: false, error: 'Invalid CSV. No title Row.' })\n      }\n\n      const titleRow = object.csv[0]\n      const usernameIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'username'\n      })\n      const fullnameIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'name'\n      })\n      const emailIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'email'\n      })\n      const titleIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'title'\n      })\n      const roleIdx = _.findIndex(titleRow, function (i) {\n        return i.toLowerCase() === 'role'\n      })\n\n      object.csv.splice(0, 1)\n\n      // Left with just the data for the import; Lets map that to an array of usable objects.\n      object.csv = _.map(object.csv, function (item) {\n        return _.assign(\n          { username: item[usernameIdx] },\n          { fullname: item[fullnameIdx] },\n          { email: item[emailIdx] },\n          { title: item[titleIdx] },\n          { role: item[roleIdx] }\n        )\n      })\n\n      const addedUsers = []\n      const updatedUsers = []\n\n      async.each(\n        object.csv,\n        function (item, next) {\n          return processUsers(addedUsers, updatedUsers, item, next)\n        },\n        function (err) {\n          if (err) {\n            winston.warn(err.message)\n            return res.json({ success: false, error: err })\n          }\n\n          return res.json({\n            success: true,\n            contents: object.csv,\n            addedUsers: addedUsers,\n            updatedUsers: updatedUsers\n          })\n        }\n      )\n    })\n\n  req.pipe(busboy)\n}\n\naccountsController.uploadJSON = function (req, res) {\n  const Busboy = require('busboy')\n  const busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1\n    }\n  })\n\n  const addedUsers = []\n\n  const updatedUsers = []\n\n  const object = {}\n  let error\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    if (mimetype.indexOf('application/json') === -1) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n    let buffer = ''\n    file.on('data', function (data) {\n      buffer += data\n    })\n\n    file\n      .on('end', function () {\n        object.json = JSON.parse(buffer)\n        const accounts = object.json.accounts\n        if (_.isUndefined(accounts)) {\n          return res.status(400).json({\n            success: false,\n            error: 'No accounts defined in JSON file.'\n          })\n        }\n\n        async.eachSeries(\n          accounts,\n          function (item, next) {\n            return processUsers(addedUsers, updatedUsers, item, next)\n          },\n          function (err) {\n            if (err) {\n              return res.status(400).json({ success: false, error: err })\n            }\n\n            return res.json({\n              success: true,\n              contents: object.json,\n              addedUsers: addedUsers,\n              updatedUsers: updatedUsers\n            })\n          }\n        )\n      })\n      .setEncoding('utf8')\n  })\n\n  busboy.on('error', function (err) {\n    return res.status(400).json({ success: false, error: err })\n  })\n\n  busboy.on('finish', function () {\n    if (error) {\n      return res.status(error.status).json({ success: false, error: error })\n    }\n  })\n\n  req.pipe(busboy)\n}\n\naccountsController.uploadImage = function (req, res) {\n  const fs = require('fs')\n  const path = require('path')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 1024 * 1024 * 3 // 3mb limit\n    }\n  })\n\n  const allowedExts = ['.png', '.jpg', '.jpeg', '.gif']\n\n  const object = {}\n  let error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === '_id') object._id = val\n    if (fieldname === 'username') object.username = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    const ext = path.extname(filename)\n\n    if (!allowedExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/users')\n    if (!fs.existsSync(savePath)) fs.mkdirSync(savePath)\n\n    object.filename = 'aProfile_' + object.username + path.extname(filename)\n    object.filename = object.filename.replace('/', '').replace('..', '')\n    object.filePath = path.join(savePath, object.filename)\n    object.mimetype = mimetype\n\n    file.on('limit', function () {\n      error = {\n        status: 400,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      // if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath);\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.once('finish', function () {\n    if (error) {\n      winston.warn(error)\n      return res.status(error.status).send(error.message)\n    }\n\n    if (\n      _.isUndefined(object._id) ||\n      _.isUndefined(object.username) ||\n      _.isUndefined(object.filePath) ||\n      _.isUndefined(object.filename)\n    ) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(400).send('File Failed to Save to Disk')\n    if (path.extname(object.filename) === '.jpg' || path.extname(object.filename) === '.jpeg') {\n      require('../helpers/utils').stripExifData(object.filePath)\n    }\n\n    userSchema.getUser(object._id, function (err, user) {\n      if (err) return handleError(res, err)\n\n      user.image = object.filename\n\n      user.save(function (err) {\n        if (err) return handleError(res, err)\n\n        emitter.emit('trudesk:profileImageUpdate', {\n          userid: user._id,\n          img: user.image\n        })\n\n        return res.status(200).send('/uploads/users/' + object.filename)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nmodule.exports = accountsController\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    2/18/19 5:59 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar packagejson = require('../../../../package')\n\nmodule.exports = function (middleware, router, controllers) {\n  // ShortenVars\n  var apiv1 = middleware.api\n  var isAdmin = middleware.isAdmin\n  var isAgent = middleware.isAgent\n  var isAgentOrAdmin = middleware.isAgentOrAdmin\n  var canUser = middleware.canUser\n  var apiCtrl = controllers.api.v1\n\n  // Common\n  router.get('/api', controllers.api.index)\n  router.get('/api/v1/version', function (req, res) {\n    return res.json({ version: packagejson.version })\n  })\n  router.post('/api/v1/login', apiCtrl.common.login)\n  router.get('/api/v1/login', apiv1, apiCtrl.common.getLoggedInUser)\n  router.get('/api/v1/logout', apiv1, apiCtrl.common.logout)\n\n  // Roles\n  router.get('/api/v1/roles', apiv1, apiCtrl.roles.get)\n  router.post('/api/v1/roles', apiv1, isAdmin, apiCtrl.roles.create)\n  router.put('/api/v1/roles/:id', apiv1, isAdmin, apiCtrl.roles.update)\n  router.delete('/api/v1/roles/:id', apiv1, isAdmin, apiCtrl.roles.delete)\n\n  // Tickets\n  router.get('/api/v1/tickets', apiv1, canUser('tickets:view'), apiCtrl.tickets.get)\n  router.get('/api/v1/tickets/group/:id', apiv1, isAdmin, canUser('tickets:view'), apiCtrl.tickets.getByGroup)\n  router.get('/api/v1/tickets/search', apiv1, canUser('tickets:view'), apiCtrl.tickets.search)\n  router.post('/api/v1/tickets/create', apiv1, canUser('tickets:create'), apiCtrl.tickets.create)\n  router.get('/api/v1/tickets/type/:id', apiv1, apiCtrl.tickets.getType)\n  router.post('/api/v1/tickets/type/:id/removepriority', apiv1, isAdmin, apiCtrl.tickets.typeRemovePriority)\n  router.post('/api/v1/tickets/type/:id/addpriority', apiv1, isAdmin, apiCtrl.tickets.typeAddPriority)\n  router.get('/api/v1/tickets/types', apiv1, apiCtrl.tickets.getTypes)\n  router.post('/api/v1/tickets/types/create', apiv1, isAdmin, apiCtrl.tickets.createType)\n  router.put('/api/v1/tickets/types/:id', apiv1, isAdmin, apiCtrl.tickets.updateType)\n  router.delete('/api/v1/tickets/types/:id', apiv1, isAdmin, apiCtrl.tickets.deleteType)\n  router.post('/api/v1/tickets/priority/create', apiv1, isAdmin, apiCtrl.tickets.createPriority)\n  router.post('/api/v1/tickets/priority/:id/delete', apiv1, isAdmin, apiCtrl.tickets.deletePriority)\n  router.get('/api/v1/tickets/priorities', apiv1, apiCtrl.tickets.getPriorities)\n  router.put('/api/v1/tickets/priority/:id', apiv1, isAdmin, apiCtrl.tickets.updatePriority)\n\n  router.get('/api/v1/tickets/overdue', apiv1, canUser('tickets:view'), apiCtrl.tickets.getOverdue)\n  router.post('/api/v1/tickets/addcomment', apiv1, canUser('comments:create'), apiCtrl.tickets.postComment)\n  router.post('/api/v1/tickets/addnote', apiv1, canUser('tickets:notes'), apiCtrl.tickets.postInternalNote)\n  router.get('/api/v1/tickets/tags', apiv1, apiCtrl.tickets.getTags)\n  router.get('/api/v1/tickets/count/tags', apiv1, apiCtrl.tickets.getTagCount)\n  router.get('/api/v1/tickets/count/tags/:timespan', apiv1, apiCtrl.tickets.getTagCount)\n  router.get('/api/v1/tickets/count/days', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/count/days/:timespan', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/count/topgroups', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get('/api/v1/tickets/count/topgroups/:top', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get('/api/v1/tickets/count/topgroups/:timespan/:top', apiv1, apiCtrl.tickets.getTopTicketGroups)\n  router.get(\n    '/api/v1/tickets/count/group/:id',\n    apiv1,\n    isAgentOrAdmin,\n    canUser('tickets:view'),\n    apiCtrl.tickets.getCountByGroup\n  )\n  router.get('/api/v1/tickets/stats', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/stats/group/:group', apiv1, apiCtrl.tickets.getTicketStatsForGroup)\n  router.get('/api/v1/tickets/stats/user/:user', apiv1, apiCtrl.tickets.getTicketStatsForUser)\n  router.get('/api/v1/tickets/stats/:timespan', apiv1, apiCtrl.tickets.getTicketStats)\n  router.get('/api/v1/tickets/deleted', apiv1, isAdmin, apiCtrl.tickets.getDeletedTickets)\n  router.post('/api/v1/tickets/deleted/restore', apiv1, isAdmin, apiCtrl.tickets.restoreDeleted)\n  router.get('/api/v1/tickets/:uid', apiv1, canUser('tickets:view'), apiCtrl.tickets.single)\n  router.put('/api/v1/tickets/:id', apiv1, canUser('tickets:update'), apiCtrl.tickets.update)\n  router.delete('/api/v1/tickets/:id', apiv1, canUser('tickets:delete'), apiCtrl.tickets.delete)\n  router.put('/api/v1/tickets/:id/subscribe', apiv1, apiCtrl.tickets.subscribe)\n  router.delete(\n    '/api/v1/tickets/:tid/attachments/remove/:aid',\n    canUser('tickets:update'),\n    apiv1,\n    apiCtrl.tickets.removeAttachment\n  )\n\n  // Tags\n  router.get('/api/v1/count/tags', middleware.api, function (req, res) {\n    var tagSchema = require('../models/tag')\n    tagSchema.countDocuments({}, function (err, count) {\n      if (err) return res.status(500).json({ success: false, error: err })\n\n      return res.json({ success: true, count: count })\n    })\n  })\n\n  router.post('/api/v1/tags/create', apiv1, apiCtrl.tags.createTag)\n  router.get('/api/v1/tags/limit', apiv1, apiCtrl.tags.getTagsWithLimit)\n  router.put('/api/v1/tags/:id', apiv1, isAgentOrAdmin, apiCtrl.tags.updateTag)\n  router.delete('/api/v1/tags/:id', apiv1, isAgentOrAdmin, apiCtrl.tags.deleteTag)\n\n  // Public Tickets\n  var checkCaptcha = middleware.checkCaptcha\n  var checkOrigin = middleware.checkOrigin\n\n  router.post('/api/v1/public/users/checkemail', checkCaptcha, checkOrigin, apiCtrl.users.checkEmail)\n  router.post('/api/v1/public/tickets/create', checkCaptcha, checkOrigin, apiCtrl.tickets.createPublicTicket)\n  router.post('/api/v1/public/account/create', checkCaptcha, checkOrigin, apiCtrl.users.createPublicAccount)\n\n  // Groups\n  router.get('/api/v1/groups', apiv1, apiCtrl.groups.get)\n  router.get('/api/v1/groups/all', apiv1, canUser('groups:view'), apiCtrl.groups.getAll)\n  router.post('/api/v1/groups/create', apiv1, canUser('groups:create'), apiCtrl.groups.create)\n  router.get('/api/v1/groups/:id', apiv1, apiCtrl.groups.getSingleGroup)\n  router.put('/api/v1/groups/:id', apiv1, canUser('groups:update'), apiCtrl.groups.updateGroup)\n  router.delete('/api/v1/groups/:id', apiv1, canUser('groups:delete'), apiCtrl.groups.deleteGroup)\n\n  // Users\n  router.get('/api/v1/users', apiv1, canUser('accounts:view'), apiCtrl.users.getWithLimit)\n  router.post('/api/v1/users/create', apiv1, canUser('accounts:create'), apiCtrl.users.create)\n  router.get('/api/v1/users/notifications', apiv1, apiCtrl.users.getNotifications)\n  router.get('/api/v1/users/notificationCount', apiv1, apiCtrl.users.notificationCount)\n  router.get('/api/v1/users/getassignees', apiv1, isAgentOrAdmin, apiCtrl.users.getAssingees)\n  router.get('/api/v1/users/:username', apiv1, canUser('accounts:view'), apiCtrl.users.single)\n  router.put('/api/v1/users/:username', apiv1, canUser('accounts:update'), apiCtrl.users.update)\n  router.get('/api/v1/users/:username/groups', apiv1, apiCtrl.users.getGroups)\n  router.put('/api/v1/users/:username/updatepreferences', apiv1, apiCtrl.users.updatePreferences)\n  router.get('/api/v1/users/:username/enable', apiv1, canUser('accounts:update'), apiCtrl.users.enableUser)\n  router.delete('/api/v1/users/:username', apiv1, canUser('accounts:delete'), apiCtrl.users.deleteUser)\n  router.post('/api/v1/users/:id/generateapikey', apiv1, apiCtrl.users.generateApiKey)\n  router.post('/api/v1/users/:id/removeapikey', apiv1, apiCtrl.users.removeApiKey)\n  router.post('/api/v1/users/:id/generatel2auth', apiv1, middleware.csrfCheck, apiCtrl.users.generateL2Auth)\n  router.post('/api/v1/users/:id/removel2auth', apiv1, middleware.csrfCheck, apiCtrl.users.removeL2Auth)\n\n  // Messages\n  router.get('/api/v1/messages', apiv1, apiCtrl.messages.get)\n  router.post('/api/v1/messages/conversation/start', apiv1, apiCtrl.messages.startConversation)\n  router.get('/api/v1/messages/conversation/:id', apiv1, apiCtrl.messages.getMessagesForConversation)\n  router.delete('/api/v1/messages/conversation/:id', apiv1, apiCtrl.messages.deleteConversation)\n  router.get('/api/v1/messages/conversations', apiv1, apiCtrl.messages.getConversations)\n  router.get('/api/v1/messages/conversations/recent', apiv1, apiCtrl.messages.getRecentConversations)\n  router.post('/api/v1/messages/send', apiv1, apiCtrl.messages.send)\n\n  // Notices\n  router.post('/api/v1/notices/create', apiv1, canUser('notices:create'), apiCtrl.notices.create)\n  router.get('/api/v1/notices/clearactive', apiv1, canUser('notices:deactivate'), apiCtrl.notices.clearActive)\n  router.put('/api/v1/notices/:id', apiv1, canUser('notices:update'), apiCtrl.notices.updateNotice)\n  router.delete('/api/v1/notices/:id', apiv1, canUser('notices:delete'), apiCtrl.notices.deleteNotice)\n\n  // Reports Generator\n  var reportsGenCtrl = apiCtrl.reports.generate\n  var genBaseUrl = '/api/v1/reports/generate/'\n  router.post(genBaseUrl + 'tickets_by_group', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByGroup)\n  router.post(genBaseUrl + 'tickets_by_status', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByStatus)\n  router.post(genBaseUrl + 'tickets_by_priority', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByPriority)\n  router.post(genBaseUrl + 'tickets_by_tags', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByTags)\n  router.post(genBaseUrl + 'tickets_by_type', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByType)\n  router.post(genBaseUrl + 'tickets_by_user', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByUser)\n  router.post(genBaseUrl + 'tickets_by_assignee', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByAssignee)\n  router.post(genBaseUrl + 'tickets_by_team', apiv1, canUser('reports:create'), reportsGenCtrl.ticketsByTeam)\n\n  // Settings\n  router.get('/api/v1/settings', apiv1, apiCtrl.settings.getSettings)\n  router.put('/api/v1/settings', apiv1, isAdmin, apiCtrl.settings.updateSetting)\n  router.post('/api/v1/settings/testmailer', apiv1, isAdmin, apiCtrl.settings.testMailer)\n  router.put('/api/v1/settings/mailer/template/:id', apiv1, isAdmin, apiCtrl.settings.updateTemplateSubject)\n  router.get('/api/v1/settings/buildsass', apiv1, isAdmin, apiCtrl.settings.buildsass)\n  router.put('/api/v1/settings/updateroleorder', isAdmin, apiv1, apiCtrl.settings.updateRoleOrder)\n\n  // Backups\n  router.get('/api/v1/backups', apiv1, isAdmin, controllers.backuprestore.getBackups)\n  router.post('/api/v1/backup', apiv1, isAdmin, controllers.backuprestore.runBackup)\n  router.delete('/api/v1/backup/:backup', apiv1, isAdmin, controllers.backuprestore.deleteBackup)\n  router.post('/api/v1/backup/restore', apiv1, isAdmin, controllers.backuprestore.restoreBackup)\n  router.post('/api/v1/backup/upload', apiv1, isAdmin, controllers.backuprestore.uploadBackup)\n  router.get('/api/v1/backup/hastools', apiv1, isAdmin, controllers.backuprestore.hasBackupTools)\n\n  // Editor\n\n  router.get('/api/v1/editor/load/:id', apiv1, isAdmin, controllers.editor.load)\n  router.post('/api/v1/editor/save', apiv1, isAdmin, controllers.editor.save)\n  router.get('/api/v1/editor/assets', apiv1, isAdmin, controllers.editor.getAssets)\n  router.post('/api/v1/editor/assets/remove', apiv1, isAdmin, controllers.editor.removeAsset)\n  router.post('/api/v1/editor/assets/upload', apiv1, isAdmin, controllers.editor.assetsUpload)\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst async = require('async')\nconst _ = require('lodash')\nconst winston = require('winston')\nconst permissions = require('../../../permissions')\nconst emitter = require('../../../emitter')\nconst UserSchema = require('../../../models/user')\nconst groupSchema = require('../../../models/group')\nconst notificationSchema = require('../../../models/notification')\n\nconst apiUsers = {}\n\n/**\n * @api {get} /api/v1/users Gets users with query string\n * @apiName getUsers\n * @apiDescription Gets users with query string\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {number} count Count of users in array\n * @apiSuccess {array} users Users returned (populated)\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.getWithLimit = function (req, res) {\n  let limit = 10\n  if (!_.isUndefined(req.query.limit)) {\n    limit = parseInt(req.query.limit)\n  }\n  const page = parseInt(req.query.page)\n  const search = req.query.search\n\n  const obj = {\n    limit: limit,\n    page: page,\n    search: search\n  }\n\n  async.waterfall(\n    [\n      function (callback) {\n        UserSchema.getUserWithObject(obj, function (err, results) {\n          callback(err, results)\n        })\n      },\n      function (users, callback) {\n        const result = []\n\n        async.waterfall(\n          [\n            function (cc) {\n              groupSchema.getAllGroups(function (err, grps) {\n                if (err) return cc(err)\n                return cc(null, grps)\n              })\n            },\n            function (grps, cc) {\n              async.eachSeries(\n                users,\n                function (u, c) {\n                  const user = u.toObject()\n\n                  const groups = _.filter(grps, function (g) {\n                    return _.some(g.members, function (m) {\n                      return m._id.toString() === user._id.toString()\n                    })\n                  })\n\n                  user.groups = _.map(groups, function (group) {\n                    return { name: group.name, _id: group._id }\n                  })\n\n                  result.push(stripUserFields(user))\n                  return c()\n                },\n                function (err) {\n                  if (err) return callback(err)\n                  return cc(null, result)\n                }\n              )\n            }\n          ],\n          function (err, results) {\n            if (err) return callback(err)\n            return callback(null, results)\n          }\n        )\n      }\n    ],\n    function (err, rr) {\n      if (err) return res.status(400).json({ error: 'Error: ' + err.message })\n\n      return res.json({ success: true, count: _.size(rr), users: rr })\n    }\n  )\n}\n\n/**\n * @api {post} /api/v1/users/create Create Account\n * @apiName createAccount\n * @apiDescription Creates an account with the given post data.\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"aUsername\":    \"user.name\",\n *      \"aPass\":        \"password\",\n *      \"aPassConfirm\": \"password\",\n *      \"aFullname\":    \"fullname\",\n *      \"aEmail\":       \"email@email.com\",\n *      \"aRole\":        {RoleId},\n *      \"aTitle\":       \"User Title\",\n *      \"aGrps\":        [{GroupId}]\n * }\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} account Saved Account Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.create = function (req, res) {\n  const response = {}\n  response.success = true\n\n  const postData = req.body\n\n  if (_.isUndefined(postData) || !_.isObject(postData)) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  const propCheck = ['aUsername', 'aPass', 'aPassConfirm', 'aFullname', 'aEmail', 'aRole']\n\n  if (\n    !_.every(propCheck, function (x) {\n      return x in postData\n    })\n  ) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  if (_.isUndefined(postData.aGrps) || _.isNull(postData.aGrps) || !_.isArray(postData.aGrps)) {\n    return res.status(400).json({ success: false, error: 'Invalid Group Array' })\n  }\n\n  if (postData.aPass !== postData.aPassConfirm)\n    return res.status(400).json({ success: false, error: 'Invalid Password Match' })\n\n  const Chance = require('chance')\n  const chance = new Chance()\n\n  const account = new UserSchema({\n    username: postData.aUsername,\n    password: postData.aPass,\n    fullname: postData.aFullname,\n    email: postData.aEmail,\n    accessToken: chance.hash(),\n    role: postData.aRole\n  })\n\n  if (postData.aTitle) {\n    account.title = postData.aTitle\n  }\n\n  account.save(function (err, a) {\n    if (err) {\n      response.success = false\n      response.error = err\n      winston.debug(response)\n      return res.status(400).json(response)\n    }\n\n    a.populate('role', function (err, populatedAccount) {\n      if (err) return res.status(500).json({ success: false, error: err })\n\n      response.account = populatedAccount.toObject()\n      delete response.account.password\n\n      const groups = []\n\n      async.each(\n        postData.aGrps,\n        function (id, done) {\n          if (_.isUndefined(id)) return done(null)\n          groupSchema.getGroupById(id, function (err, grp) {\n            if (err) return done(err)\n            if (!grp) return done('Invalid Group (' + id + ') - Group not found. Check Group ID')\n\n            grp.addMember(a._id, function (err, success) {\n              if (err) return done(err)\n\n              grp.save(function (err) {\n                if (err) return done(err)\n                groups.push(grp)\n                done(null, success)\n              })\n            })\n          })\n        },\n        function (err) {\n          if (err) return res.status(400).json({ success: false, error: err })\n          response.account.groups = groups\n          return res.json(response)\n        }\n      )\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/public/account/create Create Public Account\n * @apiName createPublicAccount\n * @apiDescription Creates an account with the given post data.\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n *\n * @apiParamExample {json} Request-Example:\n * {\n *      \"aFullname\":    \"user name\",\n *      \"aEmail\":       \"email@email.com\"\"\n *      \"aPassword\":    \"password\",\n * }\n *\n * @apiSuccess {boolean} success If the Request was a success\n * @apiSuccess {object} error Error, if occurred\n * @apiSuccess {object} account Saved Account Object\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.createPublicAccount = function (req, res) {\n  const SettingSchema = require('../../../models/setting')\n\n  const response = {}\n  response.success = true\n  const postData = req.body\n  if (!_.isObject(postData)) return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  let user, group\n\n  async.waterfall(\n    [\n      function (next) {\n        SettingSchema.getSetting('allowUserRegistration:enable', function (err, allowUserRegistration) {\n          if (err) return next(err)\n          if (!allowUserRegistration) {\n            winston.warn('Public account creation was attempted while disabled!')\n            return next({ message: 'Public account creation is disabled.' })\n          }\n\n          return next()\n        })\n      },\n      function (next) {\n        SettingSchema.getSetting('role:user:default', function (err, roleDefault) {\n          if (err) return next(err)\n          if (!roleDefault) {\n            winston.error('No Default User Role Set. (Settings > Permissions > Default User Role)')\n            return next({ message: 'No Default Role Set. Please contact administrator.' })\n          }\n\n          return next(null, roleDefault)\n        })\n      },\n      function (roleDefault, next) {\n        const UserSchema = require('../../../models/user')\n        user = new UserSchema({\n          username: postData.user.email,\n          password: postData.user.password,\n          fullname: postData.user.fullname,\n          email: postData.user.email,\n          role: roleDefault.value\n        })\n\n        user.save(function (err, savedUser) {\n          if (err) return next(err)\n\n          return next(null, savedUser)\n        })\n      },\n      function (savedUser, next) {\n        const GroupSchema = require('../../../models/group')\n        group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, savedGroup) {\n          if (err) return next(err)\n\n          return next(null, { user: savedUser, group: savedGroup })\n        })\n      }\n    ],\n    function (err, result) {\n      if (err) winston.debug(err)\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      delete result.user.password\n      result.user.password = undefined\n\n      return res.json({\n        success: true,\n        userData: { user: result.user, group: result.group }\n      })\n    }\n  )\n}\n\n/**\n * @api {put} /api/v1/users/:username Update User\n * @apiName updateUser\n * @apiDescription Updates a single user.\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiParamExample {json} Request:\n * {\n        aId:            {{_id}},\n        aUsername:      {{username}},\n        aFullname:      {{fullname}},\n        aTitle:         {{title}},\n        aPass:          {{password}},\n        aPassconfirm:   {{password_confirm}},\n        aEmail:         {{email}},\n        aRole:          {{role.id}},\n        aGrps:          [{{group._id}}]\n * }\n *\n * @apiSuccess {object} user Saved User Object [Stripped]\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.update = function (req, res) {\n  const username = req.params.username\n  if (_.isNull(username) || _.isUndefined(username))\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n\n  const data = req.body\n  // saveGroups - Profile saving where groups are not sent\n  const saveGroups = !_.isUndefined(data.saveGroups) ? data.saveGroups : true\n  let passwordUpdated = false\n\n  const obj = {\n    fullname: data.aFullname,\n    title: data.aTitle,\n    password: data.aPass,\n    passconfirm: data.aPassConfirm,\n    email: data.aEmail,\n    role: data.aRole,\n    groups: data.aGrps\n  }\n\n  if (_.isNull(obj.groups) || _.isUndefined(obj.groups)) {\n    obj.groups = []\n  } else if (!_.isArray(obj.groups)) {\n    obj.groups = [obj.groups]\n  }\n\n  async.series(\n    {\n      user: function (done) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return done(err)\n          if (!user) return done('Invalid User Object')\n\n          obj._id = user._id\n\n          if (\n            !_.isUndefined(obj.password) &&\n            !_.isEmpty(obj.password) &&\n            !_.isUndefined(obj.passconfirm) &&\n            !_.isEmpty(obj.passconfirm)\n          ) {\n            if (obj.password === obj.passconfirm) {\n              user.password = obj.password\n              passwordUpdated = true\n            }\n          }\n\n          if (!_.isUndefined(obj.fullname) && obj.fullname.length > 0) user.fullname = obj.fullname\n          if (!_.isUndefined(obj.email) && obj.email.length > 0) user.email = obj.email\n          if (!_.isUndefined(obj.title) && obj.title.length > 0) user.title = obj.title\n          if (!_.isUndefined(obj.role) && obj.role.length > 0) user.role = obj.role\n\n          user.save(function (err, nUser) {\n            if (err) return done(err)\n\n            nUser.populate('role', function (err, populatedUser) {\n              if (err) return done(err)\n              const resUser = stripUserFields(populatedUser)\n\n              return done(null, resUser)\n            })\n          })\n        })\n      },\n      groups: function (done) {\n        if (!saveGroups) {\n          groupSchema.getAllGroupsOfUser(obj._id, done)\n        } else {\n          const userGroups = []\n          groupSchema.getAllGroups(function (err, groups) {\n            if (err) return done(err)\n            async.each(\n              groups,\n              function (grp, callback) {\n                if (_.includes(obj.groups, grp._id.toString())) {\n                  if (grp.isMember(obj._id)) {\n                    userGroups.push(grp)\n                    return callback()\n                  }\n                  grp.addMember(obj._id, function (err, result) {\n                    if (err) return callback(err)\n\n                    if (result) {\n                      grp.save(function (err) {\n                        if (err) return callback(err)\n                        userGroups.push(grp)\n                        return callback()\n                      })\n                    } else {\n                      return callback()\n                    }\n                  })\n                } else {\n                  // Remove Member from group\n                  grp.removeMember(obj._id, function (err, result) {\n                    if (err) return callback(err)\n                    if (result) {\n                      grp.save(function (err) {\n                        if (err) return callback(err)\n\n                        return callback()\n                      })\n                    } else {\n                      return callback()\n                    }\n                  })\n                }\n              },\n              function (err) {\n                if (err) return done(err)\n\n                return done(null, userGroups)\n              }\n            )\n          })\n        }\n      }\n    },\n    async function (err, results) {\n      if (err) {\n        winston.debug(err)\n        return res.status(400).json({ success: false, error: err })\n      }\n\n      const user = results.user.toJSON()\n      user.groups = results.groups.map(function (g) {\n        return { _id: g._id, name: g.name }\n      })\n\n      if (passwordUpdated) {\n        const Session = require('../../../models/session')\n        await Session.destroy(user._id)\n      }\n\n      return res.json({ success: true, user: user })\n    }\n  )\n}\n\n/**\n * @api {put} /api/v1/users/:username/updatepreferences Updates User Preferences\n * @apiName updatePreferences\n * @apiDescription Updates a single user preference.\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"Content-Type: application/json\" -H \"accesstoken: {accesstoken}\" -X PUT -d \"{\\\"preference\\\":\\\"{preference_name}\\\",\\\"value\\\":{value}}\" -l http://localhost/api/v1/users/{username}/updatepreferences\n *\n * @apiParamExample {json} Request:\n * {\n *      \"preference\": \"preference_name\",\n *      \"value\": \"preference_value\"\n * }\n *\n * @apiSuccess {object} user Saved User Object [Stripped]\n *\n * @apiError InvalidPostData The data was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Post Data\"\n }\n */\napiUsers.updatePreferences = function (req, res) {\n  const username = req.params.username\n  if (typeof username === 'undefined') {\n    return res.status(400).json({ success: false, error: 'Invalid Request' })\n  }\n\n  const data = req.body\n  const preference = data.preference\n  const value = data.value\n\n  UserSchema.getUserByUsername(username, function (err, user) {\n    if (err) {\n      winston.warn('[API:USERS:UpdatePreferences] Error= ' + err)\n      return res.status(400).json({ success: false, error: err })\n    }\n\n    if (_.isNull(user.preferences)) {\n      user.preferences = {}\n    }\n\n    user.preferences[preference] = value\n\n    user.save(function (err, u) {\n      if (err) {\n        winston.warn('[API:USERS:UpdatePreferences] Error= ' + err)\n        return res.status(400).json({ success: false, error: err })\n      }\n\n      const resUser = stripUserFields(u)\n\n      return res.json({ success: true, user: resUser })\n    })\n  })\n}\n\n/**\n * @api {delete} /api/v1/users/:username Delete / Disable User\n * @apiName deleteUser\n * @apiDescription Disables or Deletes the giving user via username\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username\n *\n * @apiSuccess {boolean}     success    Was the user successfully Deleted or disabled.\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.deleteUser = function (req, res) {\n  const username = req.params.username\n\n  if (_.isUndefined(username) || _.isNull(username)) return res.status(400).json({ error: 'Invalid Request' })\n\n  async.waterfall(\n    [\n      function (cb) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return cb(err)\n\n          if (_.isNull(user)) {\n            return cb({ message: 'Invalid User' })\n          }\n\n          if (user.username.toLowerCase() === req.user.username) {\n            return cb({ message: 'Cannot remove yourself!' })\n          }\n\n          if (!permissions.canThis(req.user.role, 'accounts:delete')) return cb({ message: 'Access Denied' })\n\n          // TODO: FIX THIS FOR HIERARCHY!!\n          // if (req.user.role.toLowerCase() === 'support' || req.user.role.toLowerCase() === 'user') {\n          //     if (user.role.toLowerCase() === 'mod' || user.role.toLowerCase() === 'admin')\n          //         return cb({message: 'Insufficient permissions'});\n          //\n          // }\n\n          return cb(null, user)\n        })\n      },\n      function (user, cb) {\n        const ticketSchema = require('../../../models/ticket')\n        ticketSchema.find({ owner: user._id }, function (err, tickets) {\n          if (err) return cb(err)\n\n          const hasTickets = _.size(tickets) > 0\n          return cb(null, hasTickets, user)\n        })\n      },\n      function (hasTickets, user, cb) {\n        const conversationSchema = require('../../../models/chat/conversation')\n        conversationSchema.getConversationsWithLimit(user._id, 10, function (err, conversations) {\n          if (err) return cb(err)\n\n          const hasConversations = _.size(conversations) > 0\n          return cb(null, hasTickets, hasConversations, user)\n        })\n      },\n      function (hasTickets, hasConversations, user, cb) {\n        const ticketSchema = require('../../../models/ticket')\n        ticketSchema.find({ assignee: user._id }, function (err, tickets) {\n          if (err) return cb(err)\n\n          const isAssignee = _.size(tickets) > 0\n          return cb(null, hasTickets, hasConversations, isAssignee, user)\n        })\n      },\n      function (hasTickets, hasConversations, isAssignee, user, cb) {\n        if (hasTickets || hasConversations || isAssignee) {\n          // Disable if the user has tickets or conversations\n          user.softDelete(function (err) {\n            if (err) return cb(err)\n\n            // Force logout if Logged in\n            return cb(null, true)\n          })\n        } else {\n          user.remove(function (err) {\n            if (err) return cb(err)\n\n            return cb(null, false)\n          })\n        }\n      }\n    ],\n    function (err, disabled) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      return res.json({ success: true, disabled: disabled })\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/users/:username/enable Enable User\n * @apiName enableUser\n * @apiDescription Enable the giving user via username\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -X DELETE -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username/enable\n *\n * @apiSuccess {boolean}     success    Was the user successfully enabled.\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.enableUser = function (req, res) {\n  const username = req.params.username\n  if (_.isUndefined(username)) return res.status(400).json({ error: 'Invalid Request' })\n\n  UserSchema.getUserByUsername(username, function (err, user) {\n    if (err) {\n      winston.debug(err)\n      return res.status(400).json({ error: err.message })\n    }\n\n    if (_.isUndefined(user) || _.isNull(user)) return res.status(400).json({ error: 'Invalid Request' })\n\n    if (!permissions.canThis(req.user.role, 'accounts:delete'))\n      return res.status(401).json({ error: 'Invalid Permissions' })\n\n    user.deleted = false\n\n    user.save(function (err) {\n      if (err) return res.status(400).json({ error: err.message })\n\n      res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {get} /api/v1/users/:username Get User\n * @apiName getUser\n * @apiDescription Gets the user via the given username\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:username\n *\n * @apiSuccess {object}     _id                 The MongoDB ID\n * @apiSuccess {string}     username            Username of the User\n * @apiSuccess {string}     fullname            Fullname of the User\n * @apiSuccess {string}     email               Email Address of the User\n * @apiSuccess {string}     role                Assigned Permission Role of the user\n * @apiSuccess {string}     title               Title of the User\n * @apiSuccess {string}     image               Image filename for the user's profile picture\n * @apiSuccess {array}      iOSDeviceTokens     iOS Device Tokens for push notifications\n *\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.single = function (req, res) {\n  const username = req.params.username\n  if (_.isUndefined(username)) return res.status(400).json({ error: 'Invalid Request.' })\n\n  const response = {\n    success: true,\n    groups: []\n  }\n\n  async.waterfall(\n    [\n      function (done) {\n        UserSchema.getUserByUsername(username, function (err, user) {\n          if (err) return done(err)\n\n          if (_.isUndefined(user) || _.isNull(user)) return done('Invalid Request')\n\n          user = stripUserFields(user)\n          response.user = user\n\n          done(null, user)\n        })\n      },\n      function (user, done) {\n        groupSchema.getAllGroupsOfUserNoPopulate(user._id, function (err, grps) {\n          if (err) return done(err)\n\n          response.groups = _.map(grps, function (o) {\n            return o._id\n          })\n\n          done(null, response.groups)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return res.status(400).json({ error: err })\n\n      res.json(response)\n    }\n  )\n}\n\n/**\n * @api {get} /api/v1/users/notificationCount Get Notification Count\n * @apiName getNotificationCount\n * @apiDescription Gets the current notification count for the currently logged in user.\n * @apiVersion 0.1.0\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/notificationCount\n *\n * @apiSuccess {string}     count   The Notification Count\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.notificationCount = function (req, res) {\n  notificationSchema.getUnreadCount(req.user._id, function (err, count) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    return res.json({ success: true, count: count.toString() })\n  })\n}\n\napiUsers.getNotifications = function (req, res) {\n  notificationSchema.findAllForUser(req.user._id, function (err, notifications) {\n    if (err) return res.status(500).json({ success: false, error: err.message })\n\n    return res.json({ success: true, notifications: notifications })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/generateapikey Generate API Key\n * @apiName generateApiKey\n * @apiDescription Generates an API key for the given user id\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/generateapikey\n *\n * @apiSuccess {string}     token   Generated API Key\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.generateApiKey = function (req, res) {\n  const id = req.params.id\n  if (_.isUndefined(id) || _.isNull(id)) return res.status(400).json({ error: 'Invalid Request' })\n  if (!req.user.role.isAdmin && req.user._id.toString() !== id)\n    return res.status(401).json({ success: false, error: 'Unauthorized' })\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err || !user) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    // if (user.accessToken) return res.status(400).json({ success: false, error: 'User already has generated token' })\n\n    user.addAccessToken(function (err, token) {\n      if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n      res.json({ token: token })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/removeapikey Removes API Key\n * @apiName removeApiKey\n * @apiDescription Removes API key for the given user id\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/removeapikey\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.removeApiKey = function (req, res) {\n  const id = req.params.id\n  if (_.isUndefined(id) || _.isNull(id)) return res.status(400).json({ error: 'Invalid Request' })\n\n  if (!req.user.isAdmin && req.user._id.toString() !== id) return res.status(401).json({ success: 'Unauthorized' })\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ error: 'Invalid Request', fullError: err })\n\n    user.removeAccessToken(function (err) {\n      if (err) return res.status(400).json({ error: 'Invalid Request', fullError: err })\n\n      return res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/generatel2auth Generate Layer Two Auth\n * @apiName generateL2Auth\n * @apiDescription Generate a new layer two auth for the given user id\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/generatel2auth\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.generateL2Auth = function (req, res) {\n  const id = req.params.id\n  if (id.toString() !== req.user._id.toString()) {\n    return res.status(400).json({ success: false, error: 'Invalid Account Owner!' })\n  }\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    user.generateL2Auth(function (err, generatedKey) {\n      if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n      req.session.l2auth = 'totp'\n      return res.json({ success: true, generatedKey: generatedKey })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/:id/removel2auth Removes Layer Two Auth\n * @apiName removeL2Auth\n * @apiDescription Removes Layer Two Auth for the given user id\n * @apiVersion 0.1.8\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/:id/removel2auth\n *\n * @apiSuccess {boolean}     success   Successful?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.removeL2Auth = function (req, res) {\n  const id = req.params.id\n  if (id.toString() !== req.user._id.toString()) {\n    return res.status(400).json({ success: false, error: 'Invalid Account Owner!' })\n  }\n\n  UserSchema.getUser(id, function (err, user) {\n    if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n    user.removeL2Auth(function (err) {\n      if (err) return res.status(400).json({ success: false, error: 'Invalid Request' })\n\n      req.session.l2auth = null\n      return res.json({ success: true })\n    })\n  })\n}\n\n/**\n * @api {post} /api/v1/users/checkemail\n * @apiName checkEmail\n * @apiDescription Returns a true if email exists\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/checkemail\n *\n * @apiSuccess {boolean}     success   Successful?\n * @apiSuccess {boolean}     emailexist Does Email Exist?\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\n\napiUsers.checkEmail = function (req, res) {\n  const email = req.body.email\n\n  if (_.isUndefined(email) || _.isNull(email)) {\n    return res.status(400).json({ success: false, error: 'Invalid Post Data' })\n  }\n\n  UserSchema.getUserByEmail(email, function (err, users) {\n    if (err) return res.status(400).json({ success: false, error: err.message })\n\n    if (!_.isNull(users)) {\n      return res.json({ success: true, exist: true })\n    }\n\n    return res.json({ success: true, exist: false })\n  })\n}\n\n/**\n * @api {get} /api/v1/users/getassignees Get Assignees\n * @apiName getassignees\n * @apiDescription Returns a list of assignable users\n * @apiVersion 0.1.7\n * @apiGroup User\n * @apiHeader {string} accesstoken The access token for the logged in user\n * @apiExample Example usage:\n * curl -H \"accesstoken: {accesstoken}\" -l http://localhost/api/v1/users/getassignees\n *\n * @apiSuccess {boolean}     success   Successful?\n * @apiSuccess {array}       users     Array of Assignees\n *\n * @apiError InvalidRequest The request was invalid\n * @apiErrorExample\n *      HTTP/1.1 400 Bad Request\n {\n     \"error\": \"Invalid Request\"\n }\n */\napiUsers.getAssingees = function (req, res) {\n  UserSchema.getAssigneeUsers(function (err, users) {\n    if (err) return res.status(400).json({ error: 'Invalid Request' })\n\n    const strippedUsers = []\n\n    async.each(\n      users,\n      function (user, cb) {\n        user = stripUserFields(user)\n        strippedUsers.push(user)\n\n        cb()\n      },\n      function () {\n        return res.json({ success: true, users: strippedUsers })\n      }\n    )\n  })\n}\n\napiUsers.getGroups = function (req, res) {\n  if (req.user.role.isAdmin || req.user.role.isAgent) {\n    const departmentSchema = require('../../../models/department')\n    departmentSchema.getDepartmentGroupsOfUser(req.user._id, function (err, groups) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      const mappedGroups = groups.map(function (g) {\n        return g._id\n      })\n\n      return res.json({ success: true, groups: mappedGroups })\n    })\n  } else {\n    if (req.user.username !== req.params.username)\n      return res.status(400).json({ success: false, error: 'Invalid API Call' })\n\n    groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, function (err, groups) {\n      if (err) return res.status(400).json({ success: false, error: err.message })\n\n      const mappedGroups = groups.map(function (g) {\n        return g._id\n      })\n\n      return res.json({ success: true, groups: mappedGroups })\n    })\n  }\n}\n\nfunction stripUserFields (user) {\n  user.password = undefined\n  user.accessToken = undefined\n  user.__v = undefined\n  user.tOTPKey = undefined\n  user.iOSDeviceTokens = undefined\n\n  return user\n}\n\nmodule.exports = apiUsers\n"], "filenames": ["src/controllers/accounts.js", "src/controllers/api/v1/routes.js", "src/controllers/api/v1/users.js"], "buggy_code_start_loc": [21, 133, 1083], "buggy_code_end_loc": [490, 134, 1162], "fixing_code_start_loc": [22, 132, 1082], "fixing_code_end_loc": [496, 132, 1082], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository polonel/trudesk prior to 1.2.2.", "other": {"cve": {"id": "CVE-2022-1752", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-21T03:15:51.087", "lastModified": "2022-05-26T16:07:43.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository polonel/trudesk prior to 1.2.2."}, {"lang": "es", "value": "Una Subida sin Restricciones de Archivos de Tipo Peligroso en el repositorio GitHub polonel/trudesk versiones anteriores a 1.2.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "129D9FED-E43F-47B1-8FB3-012D00E93181"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/d107f12e71c0fe1e7ac0fdc7463f59c4965a42cd", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/66e9bfa9-598f-49ab-a472-752911df3f2d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/d107f12e71c0fe1e7ac0fdc7463f59c4965a42cd"}}