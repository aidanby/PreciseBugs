{"buggy_code": ["#include \"Note.hpp\"\n#include \"prf.h\"\n#include \"crypto/sha256.h\"\n\n#include \"random.h\"\n#include \"version.h\"\n#include \"streams.h\"\n\n#include \"zcash/util.h\"\n#include \"librustzcash.h\"\n\nusing namespace libzcash;\n\nSproutNote::SproutNote() {\n    a_pk = random_uint256();\n    rho = random_uint256();\n    r = random_uint256();\n}\n\nuint256 SproutNote::cm() const {\n    unsigned char discriminant = 0xb0;\n\n    CSHA256 hasher;\n    hasher.Write(&discriminant, 1);\n    hasher.Write(a_pk.begin(), 32);\n\n    auto value_vec = convertIntToVectorLE(value_);\n\n    hasher.Write(&value_vec[0], value_vec.size());\n    hasher.Write(rho.begin(), 32);\n    hasher.Write(r.begin(), 32);\n\n    uint256 result;\n    hasher.Finalize(result.begin());\n\n    return result;\n}\n\nuint256 SproutNote::nullifier(const SproutSpendingKey& a_sk) const {\n    return PRF_nf(a_sk, rho);\n}\n\n// Construct and populate Sapling note for a given payment address and value.\nSaplingNote::SaplingNote(const SaplingPaymentAddress& address, const uint64_t value) : BaseNote(value) {\n    d = address.d;\n    pk_d = address.pk_d;\n    librustzcash_sapling_generate_r(r.begin());\n}\n\n// Call librustzcash to compute the commitment\nboost::optional<uint256> SaplingNote::cm() const {\n    uint256 result;\n    if (!librustzcash_sapling_compute_cm(\n            d.data(),\n            pk_d.begin(),\n            value(),\n            r.begin(),\n            result.begin()\n        ))\n    {\n        return boost::none;\n    }\n\n    return result;\n}\n\n// Call librustzcash to compute the nullifier\nboost::optional<uint256> SaplingNote::nullifier(const SaplingFullViewingKey& vk, const uint64_t position) const\n{\n    auto ak = vk.ak;\n    auto nk = vk.nk;\n\n    uint256 result;\n    if (!librustzcash_sapling_compute_nf(\n            d.data(),\n            pk_d.begin(),\n            value(),\n            r.begin(),\n            ak.begin(),\n            nk.begin(),\n            position,\n            result.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    return result;\n}\n\nSproutNotePlaintext::SproutNotePlaintext(\n    const SproutNote& note,\n    std::array<unsigned char, ZC_MEMO_SIZE> memo) : BaseNotePlaintext(note, memo)\n{\n    rho = note.rho;\n    r = note.r;\n}\n\nSproutNote SproutNotePlaintext::note(const SproutPaymentAddress& addr) const\n{\n    return SproutNote(addr.a_pk, value_, rho, r);\n}\n\nSproutNotePlaintext SproutNotePlaintext::decrypt(const ZCNoteDecryption& decryptor,\n                                     const ZCNoteDecryption::Ciphertext& ciphertext,\n                                     const uint256& ephemeralKey,\n                                     const uint256& h_sig,\n                                     unsigned char nonce\n                                    )\n{\n    auto plaintext = decryptor.decrypt(ciphertext, ephemeralKey, h_sig, nonce);\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << plaintext;\n\n    SproutNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    return ret;\n}\n\nZCNoteEncryption::Ciphertext SproutNotePlaintext::encrypt(ZCNoteEncryption& encryptor,\n                                                    const uint256& pk_enc\n                                                   ) const\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n\n    ZCNoteEncryption::Plaintext pt;\n\n    assert(pt.size() == ss.size());\n\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    return encryptor.encrypt(pk_enc, pt);\n}\n\n\n\n// Construct and populate SaplingNotePlaintext for a given note and memo.\nSaplingNotePlaintext::SaplingNotePlaintext(\n    const SaplingNote& note,\n    std::array<unsigned char, ZC_MEMO_SIZE> memo) : BaseNotePlaintext(note, memo)\n{\n    d = note.d;\n    rcm = note.r;\n}\n\n\nboost::optional<SaplingNote> SaplingNotePlaintext::note(const SaplingIncomingViewingKey& ivk) const\n{\n    auto addr = ivk.address(d);\n    if (addr) {\n        return SaplingNote(d, addr.get().pk_d, value_, rcm);\n    } else {\n        return boost::none;\n    }\n}\n\nboost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    return ret;\n}\n\nboost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}\n\nboost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &epk,\n    const uint256 &esk,\n    const uint256 &pk_d,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, epk, esk, pk_d);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    assert(ss.size() == 0);\n\n    return ret;\n}\n\nboost::optional<SaplingNotePlaintextEncryptionResult> SaplingNotePlaintext::encrypt(const uint256& pk_d) const\n{\n    // Get the encryptor\n    auto sne = SaplingNoteEncryption::FromDiversifier(d);\n    if (!sne) {\n        return boost::none;\n    }\n    auto enc = sne.get();\n\n    // Create the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n    SaplingEncPlaintext pt;\n    assert(pt.size() == ss.size());\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    // Encrypt the plaintext\n    auto encciphertext = enc.encrypt_to_recipient(pk_d, pt);\n    if (!encciphertext) {\n        return boost::none;\n    }\n    return SaplingNotePlaintextEncryptionResult(encciphertext.get(), enc);\n}\n\n\nSaplingOutCiphertext SaplingOutgoingPlaintext::encrypt(\n        const uint256& ovk,\n        const uint256& cv,\n        const uint256& cm,\n        SaplingNoteEncryption& enc\n    ) const\n{\n    // Create the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n    SaplingOutPlaintext pt;\n    assert(pt.size() == ss.size());\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    return enc.encrypt_to_ourselves(ovk, cv, cm, pt);\n}\n"], "fixing_code": ["#include \"Note.hpp\"\n#include \"prf.h\"\n#include \"crypto/sha256.h\"\n\n#include \"random.h\"\n#include \"version.h\"\n#include \"streams.h\"\n\n#include \"zcash/util.h\"\n#include \"librustzcash.h\"\n\nusing namespace libzcash;\n\nSproutNote::SproutNote() {\n    a_pk = random_uint256();\n    rho = random_uint256();\n    r = random_uint256();\n}\n\nuint256 SproutNote::cm() const {\n    unsigned char discriminant = 0xb0;\n\n    CSHA256 hasher;\n    hasher.Write(&discriminant, 1);\n    hasher.Write(a_pk.begin(), 32);\n\n    auto value_vec = convertIntToVectorLE(value_);\n\n    hasher.Write(&value_vec[0], value_vec.size());\n    hasher.Write(rho.begin(), 32);\n    hasher.Write(r.begin(), 32);\n\n    uint256 result;\n    hasher.Finalize(result.begin());\n\n    return result;\n}\n\nuint256 SproutNote::nullifier(const SproutSpendingKey& a_sk) const {\n    return PRF_nf(a_sk, rho);\n}\n\n// Construct and populate Sapling note for a given payment address and value.\nSaplingNote::SaplingNote(const SaplingPaymentAddress& address, const uint64_t value) : BaseNote(value) {\n    d = address.d;\n    pk_d = address.pk_d;\n    librustzcash_sapling_generate_r(r.begin());\n}\n\n// Call librustzcash to compute the commitment\nboost::optional<uint256> SaplingNote::cm() const {\n    uint256 result;\n    if (!librustzcash_sapling_compute_cm(\n            d.data(),\n            pk_d.begin(),\n            value(),\n            r.begin(),\n            result.begin()\n        ))\n    {\n        return boost::none;\n    }\n\n    return result;\n}\n\n// Call librustzcash to compute the nullifier\nboost::optional<uint256> SaplingNote::nullifier(const SaplingFullViewingKey& vk, const uint64_t position) const\n{\n    auto ak = vk.ak;\n    auto nk = vk.nk;\n\n    uint256 result;\n    if (!librustzcash_sapling_compute_nf(\n            d.data(),\n            pk_d.begin(),\n            value(),\n            r.begin(),\n            ak.begin(),\n            nk.begin(),\n            position,\n            result.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    return result;\n}\n\nSproutNotePlaintext::SproutNotePlaintext(\n    const SproutNote& note,\n    std::array<unsigned char, ZC_MEMO_SIZE> memo) : BaseNotePlaintext(note, memo)\n{\n    rho = note.rho;\n    r = note.r;\n}\n\nSproutNote SproutNotePlaintext::note(const SproutPaymentAddress& addr) const\n{\n    return SproutNote(addr.a_pk, value_, rho, r);\n}\n\nSproutNotePlaintext SproutNotePlaintext::decrypt(const ZCNoteDecryption& decryptor,\n                                     const ZCNoteDecryption::Ciphertext& ciphertext,\n                                     const uint256& ephemeralKey,\n                                     const uint256& h_sig,\n                                     unsigned char nonce\n                                    )\n{\n    auto plaintext = decryptor.decrypt(ciphertext, ephemeralKey, h_sig, nonce);\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << plaintext;\n\n    SproutNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    return ret;\n}\n\nZCNoteEncryption::Ciphertext SproutNotePlaintext::encrypt(ZCNoteEncryption& encryptor,\n                                                    const uint256& pk_enc\n                                                   ) const\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n\n    ZCNoteEncryption::Plaintext pt;\n\n    assert(pt.size() == ss.size());\n\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    return encryptor.encrypt(pk_enc, pt);\n}\n\n\n\n// Construct and populate SaplingNotePlaintext for a given note and memo.\nSaplingNotePlaintext::SaplingNotePlaintext(\n    const SaplingNote& note,\n    std::array<unsigned char, ZC_MEMO_SIZE> memo) : BaseNotePlaintext(note, memo)\n{\n    d = note.d;\n    rcm = note.r;\n}\n\n\nboost::optional<SaplingNote> SaplingNotePlaintext::note(const SaplingIncomingViewingKey& ivk) const\n{\n    auto addr = ivk.address(d);\n    if (addr) {\n        return SaplingNote(d, addr.get().pk_d, value_, rcm);\n    } else {\n        return boost::none;\n    }\n}\n\nboost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n\n        SaplingOutgoingPlaintext ret;\n        ss >> ret;\n\n        assert(ss.size() == 0);\n\n        return ret;\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n}\n\nboost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}\n\nboost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &epk,\n    const uint256 &esk,\n    const uint256 &pk_d,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, epk, esk, pk_d);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}\n\nboost::optional<SaplingNotePlaintextEncryptionResult> SaplingNotePlaintext::encrypt(const uint256& pk_d) const\n{\n    // Get the encryptor\n    auto sne = SaplingNoteEncryption::FromDiversifier(d);\n    if (!sne) {\n        return boost::none;\n    }\n    auto enc = sne.get();\n\n    // Create the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n    SaplingEncPlaintext pt;\n    assert(pt.size() == ss.size());\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    // Encrypt the plaintext\n    auto encciphertext = enc.encrypt_to_recipient(pk_d, pt);\n    if (!encciphertext) {\n        return boost::none;\n    }\n    return SaplingNotePlaintextEncryptionResult(encciphertext.get(), enc);\n}\n\n\nSaplingOutCiphertext SaplingOutgoingPlaintext::encrypt(\n        const uint256& ovk,\n        const uint256& cv,\n        const uint256& cm,\n        SaplingNoteEncryption& enc\n    ) const\n{\n    // Create the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << (*this);\n    SaplingOutPlaintext pt;\n    assert(pt.size() == ss.size());\n    memcpy(&pt[0], &ss[0], pt.size());\n\n    return enc.encrypt_to_ourselves(ovk, cv, cm, pt);\n}\n"], "filenames": ["src/zcash/Note.cpp"], "buggy_code_start_loc": [176], "buggy_code_end_loc": [270], "fixing_code_start_loc": [176], "fixing_code_end_loc": [283], "type": "CWE-755", "message": "Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party.", "other": {"cve": {"id": "CVE-2019-16930", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-28T22:15:09.857", "lastModified": "2019-10-04T15:58:14.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party."}, {"lang": "es", "value": "Zcashd en Zcash versiones anteriores a 2.0.7-3, permite la detecci\u00f3n de la direcci\u00f3n IP de un nodo completo que posee una direcci\u00f3n blindada, relacionada con el manejo inapropiado de excepciones durante la deserializaci\u00f3n de textos planos de notas. Esto afecta a cualquiera que haya revelado su zaddr a un tercero."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:z.cash:zcash:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.7-3", "matchCriteriaId": "76AA1C9E-53CD-4B1A-B951-82F725553840"}]}]}], "references": [{"url": "http://duke.leto.net/2019/10/01/zcash-metadata-leakage-cve-2019-16930.html", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/zcash/zcash/commit/c1fbf8ab5d73cff5e1f45236995857c75ba4128d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zcash/zcash/releases/tag/v2.0.7-3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://z.cash/support/security/announcements/security-announcement-2019-09-24/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zcash/zcash/commit/c1fbf8ab5d73cff5e1f45236995857c75ba4128d"}}