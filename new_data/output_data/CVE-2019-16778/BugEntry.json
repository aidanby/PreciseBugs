{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#define EIGEN_USE_THREADS\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/common_runtime/gpu/gpu_event_mgr.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#if GOOGLE_CUDA\n#include \"tensorflow/core/kernels/cuda_solvers.h\"\n#include \"tensorflow/core/platform/cuda.h\"\n\nusing stream_executor::cuda::ScopedActivateExecutorContext;\n#elif TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/cuda_solvers.h\"\n#include \"tensorflow/core/platform/rocm.h\"\nusing stream_executor::rocm::ScopedActivateExecutorContext;\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\n// Static routines not in the templated class to reduce code size\nstatic void SegmentReductionValidationHelper(OpKernelContext* context,\n                                             const Tensor& input,\n                                             const Tensor& segment_ids) {\n  OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n              errors::InvalidArgument(\"segment_ids should be a vector.\"));\n  const int64 num_indices = segment_ids.NumElements();\n  OP_REQUIRES(context, num_indices == input.dim_size(0),\n              errors::InvalidArgument(\n                  \"segment_ids should be the same size as dimension 0 of\"\n                  \" input.\"));\n}\n\nstatic bool SegmentReductionDoValidation(OpKernelContext* c,\n                                         const Tensor& input,\n                                         const Tensor& segment_ids) {\n  SegmentReductionValidationHelper(c, input, segment_ids);\n  return c->status().ok();\n}\n\n// This operator handles reducing segments along the first dimension.\n// See core/ops/math_ops.cc for more details.\ntemplate <typename Device, class T, class Index, typename Reducer,\n          int default_value>\nclass SegmentReductionOp : public OpKernel {\n public:\n  explicit SegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    if (!SegmentReductionDoValidation(context, input, segment_ids)) {\n      return;\n    }\n\n    const int64 num_indices = segment_ids.NumElements();\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64 num_col = input_flat.dimension(1);\n\n    const auto segment_vec = segment_ids.vec<Index>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const Index output_rows =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) return;\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n#if !defined(EIGEN_HAS_INDEX_LIST)\n    Eigen::DSizes<Eigen::DenseIndex, 1> dims_to_reduce;\n    dims_to_reduce[0] = 0;\n#else\n    Eigen::IndexList<Eigen::type2index<0> > dims_to_reduce;\n#endif\n    Index start = 0, end = 1;\n\n    Index uninitialized_index = 0;  // Index from which the output is not set.\n    Index out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    // TODO(agarwal): if this loop becomes a bottleneck, consider sharding it\n    // across threads.\n    Eigen::DSizes<Eigen::DenseIndex, 1> out_slice_shape(num_col);\n    while (end <= num_indices) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      Index next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      // Process segment [start, end)\n      const T* in_slice_ptr = &input_flat(start, 0);\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 1, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          OutT;\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(T(default_value));\n      }\n\n      T* out_slice_ptr = &output_flat(out_index, 0);\n      OutT out_slice(out_slice_ptr, out_slice_shape);\n      // We don't use out_slice.device(context->eigen_device<Device>)\n      // because these pieces of work are likely to be very small and\n      // the context switching overhead dwarfs any benefit we get from\n      // using another thread to do this work.\n      if (start == end - 1) {\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, out_slice_shape);\n        out_slice = in_slice;\n      } else {\n        Eigen::DSizes<Eigen::DenseIndex, 2> in_slice_shape(end - start,\n                                                           num_col);\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, in_slice_shape);\n\n        out_slice = in_slice.reduce(dims_to_reduce, Reducer());\n      }\n      if (end >= num_indices) break;\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n//  SegmentSumGPUOp is a segment sum operator implemented for GPU only.\n//  TODO: This implementation of SegmentSumGPUOp is sometimes slower than\n//  its unsorted counterpart (mostly when problem size is small).\n//  This is due to the following two main reasons and a cost-effective way\n//  to resolve these problems is desirable.\n//  1. Sorted segment sum requires a memory transfer from device to host in\n//     order to know the size of the output dimension whereas unsorted segment\n//     sum receives the size of the output dimension as an input parameter.\n//  2. Sorted segment sum is essentially a tiled version of unsorted segment\n//     sum and therefore such optimization comes at an inherent cost. However\n//     such cost may not be justified when the problem size is small. When to\n//     use the tiled version or the untiled version depends on many factors\n//     including data alignments, ratio of calculation to memory traffic and\n//     obviously, the problem sizes.\ntemplate <class T, class Index>\nclass SegmentSumGPUOp : public AsyncOpKernel {\n public:\n  explicit SegmentSumGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_ASYNC(\n        context, TensorShapeUtils::IsVector(segment_ids.shape()),\n        errors::InvalidArgument(\"segment_ids should be a vector.\"), done);\n\n    const int64 num_indices = segment_ids.NumElements();\n    OP_REQUIRES_ASYNC(\n        context, num_indices == input.dim_size(0),\n        errors::InvalidArgument(\n            \"segment_ids should be the same size as dimension 0 of\"\n            \" input.\"),\n        done);\n\n    if (num_indices == 0) {\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, 0);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n      done();\n      return;\n    }\n\n    se::DeviceMemoryBase output_rows_device(\n        const_cast<Tensor&>(segment_ids).template flat<Index>().data() +\n        (num_indices - 1));\n    ScratchSpace<Index> output_rows_host(context, 1, /* on_host */ true);\n\n    auto stream = context->op_device_context()->stream();\n    OP_REQUIRES_ASYNC(\n        context,\n        stream\n            ->ThenMemcpy(output_rows_host.mutable_data(), output_rows_device,\n                         sizeof(Index))\n            .ok(),\n        errors::Internal(\n            \"SegmentSumGPUOp: failed to copy output_rows from device\"),\n        done);\n\n    functor::SegmentSumFunctor<T, Index> functor_;\n    auto create_and_check_output = [context, output_rows_host, &input,\n                                    &segment_ids, &functor_, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      Index output_rows = *output_rows_host.data();\n      output_rows++;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, output_rows);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      auto output_flat = output->flat_outer_dims<T>();\n      auto data_ptr = input.template flat<T>().data();\n      auto segment_flat = segment_ids.flat<Index>();\n      functor_(context, context->eigen_device<GPUDevice>(), output_rows,\n               segment_ids.shape(), segment_flat, input.NumElements(), data_ptr,\n               output_flat);\n\n      done();\n    };\n\n    context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n        stream, create_and_check_output);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER_CPU_KERNEL_SEGMENT(name, functor, type, index_type, \\\n                                    default_value)                   \\\n  REGISTER_KERNEL_BUILDER(                                           \\\n      Name(name)                                                     \\\n          .Device(DEVICE_CPU)                                        \\\n          .TypeConstraint<type>(\"T\")                                 \\\n          .TypeConstraint<index_type>(\"Tindices\"),                   \\\n      SegmentReductionOp<CPUDevice, type, index_type, functor, default_value>)\n\n#define REGISTER_REAL_CPU_KERNELS(type, index_type)                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentSum\", Eigen::internal::SumReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentMean\", Eigen::internal::MeanReducer<type>, type, index_type, 0); \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentProd\", Eigen::internal::ProdReducer<type>, type, index_type, 1); \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentMin\", Eigen::internal::MinReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentMax\", Eigen::internal::MaxReducer<type>, \\\n                              type, index_type, 0)\n\n#define REGISTER_COMPLEX_CPU_KERNELS(type, index_type)                         \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentSum\", Eigen::internal::SumReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentMean\", Eigen::internal::MeanReducer<type>, type, index_type, 0); \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentProd\", Eigen::internal::ProdReducer<type>, type, index_type, 1);\n\n#define REGISTER_REAL_CPU_KERNELS_ALL(type) \\\n  REGISTER_REAL_CPU_KERNELS(type, int32);   \\\n  REGISTER_REAL_CPU_KERNELS(type, int64)\n\n#define REGISTER_COMPLEX_CPU_KERNELS_ALL(type) \\\n  REGISTER_COMPLEX_CPU_KERNELS(type, int32);   \\\n  REGISTER_COMPLEX_CPU_KERNELS(type, int64)\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex128);\n#undef REGISTER_CPU_KERNEL_SEGMENT\n#undef REGISTER_REAL_CPU_KERNELS\n#undef REGISTER_COMPLEX_CPU_KERNELS\n#undef REGISTER_REAL_CPU_KERNELS_ALL\n#undef REGISTER_COMPLEX_CPU_KERNELS_ALL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_SORTED_KERNELS(type, index_type)                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"SegmentSum\")                           \\\n                              .Device(DEVICE_GPU)                      \\\n                              .TypeConstraint<type>(\"T\")               \\\n                              .TypeConstraint<index_type>(\"Tindices\"), \\\n                          SegmentSumGPUOp<type, index_type>)\n\n#define REGISTER_GPU_SORTED_KERNELS_ALL(type) \\\n  REGISTER_GPU_SORTED_KERNELS(type, int32);   \\\n  REGISTER_GPU_SORTED_KERNELS(type, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_SORTED_KERNELS_ALL);\n#undef REGISTER_GPU_SORTED_KERNELS\n#undef REGISTER_GPU_SORTED_KERNELS_ALL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Unsorted segment reduction ops.\n\nnamespace functor {\n\n// The ReductionFunctor implementation for CPU.\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }\n};\n\ntemplate <typename T>\nusing MatrixChip = Eigen::TensorChippingOp<0l, typename TTypes<T, 2>::Matrix>;\n\ntemplate <typename T>\nusing constMatrixChip =\n    Eigen::TensorChippingOp<0l, const typename TTypes<T, 2>::ConstMatrix>;\n\n// reduction functors\ntemplate <typename T>\nstruct SumOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output += data;\n  }\n};\n\ntemplate <typename T>\nstruct MaxOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMax(output);\n  }\n};\n\ntemplate <typename T>\nstruct MinOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMin(output);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output *= data;\n  }\n};\n}  // namespace functor\n\n// Static check routines not in the templated class to reduce code size\nstatic void UnsortedSegmentReductionValidation(OpKernel* op_kernel,\n                                               OpKernelContext* context,\n                                               const Tensor& data,\n                                               const Tensor& segment_ids,\n                                               const Tensor& num_segments) {\n  OP_REQUIRES(\n      context, op_kernel->IsLegacyScalar(num_segments.shape()),\n      errors::InvalidArgument(\"num_segments should be a scalar, not shape \",\n                              num_segments.shape().DebugString()));\n  OP_REQUIRES(\n      context, TensorShapeUtils::StartsWith(data.shape(), segment_ids.shape()),\n      errors::InvalidArgument(\"data.shape = \", data.shape().DebugString(),\n                              \" does not start with segment_ids.shape = \",\n                              segment_ids.shape().DebugString()));\n}\n\nstatic bool UnsortedSegmentReductionDoValidation(OpKernel* op_kernel,\n                                                 OpKernelContext* context,\n                                                 const Tensor& data,\n                                                 const Tensor& segment_ids,\n                                                 const Tensor& num_segments) {\n  UnsortedSegmentReductionValidation(op_kernel, context, data, segment_ids,\n                                     num_segments);\n  return context->status().ok();\n}\n\n// The UnsortedSegmentReduction OpKernel. The DeviceReductionFunctor\n// is the device specific implementation of the reduction. These device\n// specific implementations are templated themselves with the corresponding\n// initial value functors and reduction functors.\ntemplate <typename T, typename Index, typename DeviceReductionFunctor>\nclass UnsortedSegmentReductionOp : public OpKernel {\n public:\n  explicit UnsortedSegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context), reduction_functor_(DeviceReductionFunctor()) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }\n\n protected:\n  DeviceReductionFunctor reduction_functor_;\n};\n\n#define REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(                           \\\n    name, type, index_type, initial_value_functor, reduction_functor)  \\\n  REGISTER_KERNEL_BUILDER(                                             \\\n      Name(name)                                                       \\\n          .Device(DEVICE_CPU)                                          \\\n          .TypeConstraint<type>(\"T\")                                   \\\n          .TypeConstraint<index_type>(\"Tindices\"),                     \\\n      UnsortedSegmentReductionOp<                                      \\\n          type, index_type,                                            \\\n          functor::UnsortedSegmentFunctor<CPUDevice, type, index_type, \\\n                                          initial_value_functor,       \\\n                                          reduction_functor> >)\n\n#define REGISTER_REAL_CPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type,  \\\n                                      functor::Zero<type>,                     \\\n                                      functor::SumOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMax\", type, index_type,  \\\n                                      functor::Lowest<type>,                   \\\n                                      functor::MaxOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMin\", type, index_type,  \\\n                                      functor::Highest<type>,                  \\\n                                      functor::MinOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOp<type>);\n\n#define REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, index_type)                \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type,  \\\n                                      functor::Zero<type>,                     \\\n                                      functor::SumOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOp<type>)\n\n#define REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_REAL_CPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_REAL_CPU_UNSORTED_KERNELS(type, int64)\n\n#define REGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, int64)\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(complex128);\n\n#undef REGISTER_REAL_CPU_UNSORTED_KERNELS\n#undef REGISTER_CPU_KERNEL_UNSORTEDSEGMENT\n#undef REGISTER_COMPLEX_CPU_UNSORTED_KERNELS\n#undef REGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL\n#undef REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(                                 \\\n    name, type, index_type, initial_value_functor, reduction_kernel_functor) \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(name)                                                             \\\n          .Device(DEVICE_GPU)                                                \\\n          .HostMemory(\"num_segments\")                                        \\\n          .TypeConstraint<type>(\"T\")                                         \\\n          .TypeConstraint<index_type>(\"Tindices\"),                           \\\n      UnsortedSegmentReductionOp<                                            \\\n          type, index_type,                                                  \\\n          functor::UnsortedSegmentFunctor<GPUDevice, type, index_type,       \\\n                                          initial_value_functor,             \\\n                                          reduction_kernel_functor> >)\n\n// sum is the only op that supports all input types currently\n#define REGISTER_REAL_GPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMax\", type, index_type,  \\\n                                      functor::Lowest<type>,                   \\\n                                      functor::MaxOpGpu<type>);                \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMin\", type, index_type,  \\\n                                      functor::Highest<type>,                  \\\n                                      functor::MinOpGpu<type>);                \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOpGpu<type>);\n\n#define REGISTER_SUM_GPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type, \\\n                                      functor::Zero<type>,                    \\\n                                      functor::SumOpGpu<type>);\n\n#define REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_REAL_GPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_REAL_GPU_UNSORTED_KERNELS(type, int64);\n\n#define REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_SUM_GPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_SUM_GPU_UNSORTED_KERNELS(type, int64);\n\n\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_int32(REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_int32(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\n// TODO(rocm): support atomicAdd for complex numbers on ROCm\n#if GOOGLE_CUDA\nTF_CALL_complex64(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_complex128(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\n#endif\n\n#undef REGISTER_GPU_KERNEL_UNSORTEDSEGMENT\n#undef REGISTER_REAL_GPU_UNSORTED_KERNELS\n#undef REGISTER_SUM_GPU_UNSORTED_KERNELS\n#undef REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL\n#undef REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Sparse segment reduction ops.\n\n// Same as SegmentReductionOp but takes as input a \"sparse\" tensor, represented\n// by two dense tensors, one containing the data, and the other containing\n// indices into the data.\ntemplate <typename Device, class T>\nclass SparseSegmentReductionOpBase : public OpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : OpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    Index output_rows = -1;\n    if (has_num_segments_) {\n      const Tensor& num_segments = context->input(3);\n\n      OP_REQUIRES(\n          context, num_segments.shape().dims() == 0,\n          errors::InvalidArgument(\"num_segments should be a scalar, not shape \",\n                                  num_segments.shape().DebugString()));\n      output_rows = internal::SubtleMustCopy(num_segments.scalar<int32>()());\n      OP_REQUIRES(context, output_rows >= 0,\n                  errors::InvalidArgument(\"segment ids must be >= 0\"));\n    }\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n\n    const int64 num_indices = indices.NumElements();\n    OP_REQUIRES(context, num_indices == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64 num_col = input_flat.dimension(1);\n    const auto indices_vec = indices.vec<Index>();\n    typedef int32 OutputRow;\n    const auto segment_vec = segment_ids.vec<OutputRow>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const OutputRow last_segment_id_plus_one =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    if (has_num_segments_) {\n      OP_REQUIRES(\n          context, output_rows >= last_segment_id_plus_one,\n          errors::InvalidArgument(\"segment ids must be < num_segments\"));\n    } else {\n      output_rows = last_segment_id_plus_one;\n    }\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) {\n      if (output_rows > 0) {\n        output->flat_outer_dims<T>().setConstant(default_value_);\n      }\n      return;\n    }\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n    int64 start = 0, end = 1;\n    // Index from which the output is not initialized.\n    OutputRow uninitialized_index = 0;\n    OutputRow out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    while (true) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      OutputRow next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(default_value_);\n      }\n\n      auto out = output_flat.template chip<0>(out_index);\n      const int bad_offset =\n          Reduce(input_flat, indices_vec, start, end - start, out);\n      OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"));\n\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n      if (end > num_indices) break;\n    }\n\n    // Fill the gap at the end with the default value.\n    if (uninitialized_index < output_rows) {\n      Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n          output_rows - uninitialized_index, num_col);\n      Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n      gap_slice.setConstant(default_value_);\n    }\n  }\n\n private:\n  typedef int32 Index;\n\n  int64 Reduce(const typename TTypes<T>::ConstMatrix& input_flat,\n               const typename TTypes<Index>::ConstVec& indices_vec, int64 start,\n               int64 num,\n               Eigen::TensorChippingOp<0, typename TTypes<T>::Matrix> out) {\n#define INDEX(n, i)                               \\\n  const auto index##n = indices_vec(start + (i)); \\\n  if (!FastBoundsCheck(index##n, input_flat.dimension(0))) return (i);\n\n#define L(n) input_flat.template chip<0>(index##n)\n\n    if (num == 1) {\n      INDEX(0, 0);\n      out = L(0);\n    } else {\n      int64 r = num % 8;\n      T m(1);\n      if (is_mean_ && (num < 10)) {\n        m = T(num);\n      }\n      if (is_sqrtn_ && (num < 10)) {\n        m = T(sqrt(num));\n      }\n      switch (r) {\n        case 2: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          out = (L(0) + L(1)) / m;\n          break;\n        }\n        case 3: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          out = (L(0) + L(1) + L(2)) / m;\n          break;\n        }\n        case 4: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          out = (L(0) + L(1) + L(2) + L(3)) / m;\n          break;\n        }\n        case 5: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4)) / m;\n          break;\n        }\n        case 6: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) / m;\n          break;\n        }\n        case 7: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) / m;\n          break;\n        }\n        case 0: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) / m;\n          r = 8;\n          break;\n        }\n        case 1: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          INDEX(8, 8);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) /\n                m;\n          r = 9;\n          break;\n        }\n      }\n      for (; r < num; r += 8) {\n        INDEX(0, r);\n        INDEX(1, r + 1);\n        INDEX(2, r + 2);\n        INDEX(3, r + 3);\n        INDEX(4, r + 4);\n        INDEX(5, r + 5);\n        INDEX(6, r + 6);\n        INDEX(7, r + 7);\n        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);\n      }\n      if (is_mean_ && num >= 10) {\n        out = out / static_cast<T>(num);\n      }\n      if (is_sqrtn_ && num >= 10) {\n        out = out / static_cast<T>(sqrt(num));\n      }\n    }\n\n    return -1;\n#undef L\n#undef INDEX\n  }\n\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionMeanOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionMeanWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionMeanWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSqrtNOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSqrtNWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSumOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSumWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSumWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSum\")                       \\\n                              .Device(DEVICE_CPU)                        \\\n                              .TypeConstraint<type>(\"T\")                 \\\n                              .TypeConstraint<int32>(\"Tidx\"),            \\\n                          SparseSegmentReductionSumOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseSegmentSumWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                            \\\n          .TypeConstraint<type>(\"T\")                                     \\\n          .TypeConstraint<int32>(\"Tidx\"),                                \\\n      SparseSegmentReductionSumWithNumSegmentsOp<CPUDevice, type>);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_SPARSE_KERNELS);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentMean\")                       \\\n                              .Device(DEVICE_CPU)                         \\\n                              .TypeConstraint<type>(\"T\")                  \\\n                              .TypeConstraint<int32>(\"Tidx\"),             \\\n                          SparseSegmentReductionMeanOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                                \\\n      Name(\"SparseSegmentMeanWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                             \\\n          .TypeConstraint<type>(\"T\")                                      \\\n          .TypeConstraint<int32>(\"Tidx\"),                                 \\\n      SparseSegmentReductionMeanWithNumSegmentsOp<CPUDevice, type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSqrtN\")                       \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<type>(\"T\")                   \\\n                              .TypeConstraint<int32>(\"Tidx\"),              \\\n                          SparseSegmentReductionSqrtNOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"SparseSegmentSqrtNWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<type>(\"T\")                                       \\\n          .TypeConstraint<int32>(\"Tidx\"),                                  \\\n      SparseSegmentReductionSqrtNWithNumSegmentsOp<CPUDevice, type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\ntemplate <class T>\nclass SparseSegmentGradOpBase : public OpKernel {\n public:\n  explicit SparseSegmentGradOpBase(OpKernelConstruction* context, bool is_sqrtn)\n      : OpKernel(context), is_sqrtn_(is_sqrtn) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n    const Tensor& output_dim0 = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n    OP_REQUIRES(context, IsLegacyScalar(output_dim0.shape()),\n                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));\n\n    const int64 N = indices.NumElements();\n    OP_REQUIRES(context, N == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n    typedef int32 SegmentId;\n    const SegmentId M =\n        internal::SubtleMustCopy(output_dim0.scalar<SegmentId>()());\n\n    auto input_flat = input.flat_outer_dims<T>();\n    typedef int32 Index;\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, M);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (M == 0 || N == 0) return;\n\n    // Note that similar to SparseSegmentMean, we assume that segment_vec is\n    // already sorted and has non-negative values.\n    const SegmentId num_segments = input.dim_size(0);\n    const SegmentId last_segment_id_plus_one =\n        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;\n    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"));\n\n    // Compute scaling factors for input.\n    std::vector<double> scaling(num_segments, 0.0);\n    for (int64 i = 0; i < N; ++i) {\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n      scaling[idx] += 1;\n    }\n    for (size_t i = 0; i < scaling.size(); ++i) {\n      if (is_sqrtn_) {\n        scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));\n      } else {\n        scaling[i] = 1.0 / std::max(scaling[i], 1.0);\n      }\n    }\n\n    auto output_flat = output->flat_outer_dims<T>();\n    output_flat.setZero();\n    std::vector<bool> is_modified(M, false);\n\n    for (int64 i = 0; i < N; ++i) {\n      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));\n      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),\n                  errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\"));\n\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n\n      const T scale = static_cast<T>(scaling[idx]);\n      if (is_modified[output_idx]) {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx) * scale;\n        }\n      } else {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx) * scale;\n        }\n      }\n      is_modified[output_idx] = true;\n    }\n  }\n\n private:\n  const bool is_sqrtn_;\n};\n\ntemplate <class T>\nclass SparseSegmentMeanGradOp : public SparseSegmentGradOpBase<T> {\n public:\n  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<T>(context, false /*is_sqrtn*/) {}\n};\n\ntemplate <class T>\nclass SparseSegmentSqrtNGradOp : public SparseSegmentGradOpBase<T> {\n public:\n  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<T>(context, true /*is_sqrtn*/) {}\n};\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentMeanGrad\")       \\\n                              .Device(DEVICE_CPU)             \\\n                              .TypeConstraint<type>(\"T\")      \\\n                              .TypeConstraint<int32>(\"Tidx\"), \\\n                          SparseSegmentMeanGradOp<type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSqrtNGrad\")      \\\n                              .Device(DEVICE_CPU)             \\\n                              .TypeConstraint<type>(\"T\")      \\\n                              .TypeConstraint<int32>(\"Tidx\"), \\\n                          SparseSegmentSqrtNGradOp<type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n#define TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n\n// This file requires the following include because it uses GpuAtomicMax:\n// #include \"tensorflow/core/util/gpu_kernel_helper.h\"\n\n// Unfortunately we can't add the #include, since it breaks compilation for\n// non-GPU targets. This only breaks in clang, because it's more strict for\n// template code and GpuAtomicMax is used in template context.\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n\nnamespace tensorflow {\n\nclass OpKernelContext;\n\nnamespace functor {\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n// Functor for SegmentSumGPUOp.\n// output_rows: the number of output segments (unique segment ids in\n//                'segment_ids').\n// segment_ids_shape: shape of 'segment_ids' tensor.\n// segment_ids: unsorted map from input to output segment ids at which to\n//                perform segment sum operation.\n// data_size: size of input data tensor.\n// data: input data tensor.\n// output: output reshaped to {output_rows, output.size/output_rows}\ntemplate <typename T, typename Index>\nstruct SegmentSumFunctor {\n  void operator()(OpKernelContext* ctx, const GPUDevice& d,\n                  const Index output_rows, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#endif\n\ntemplate <typename Device, typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor {\n  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n// reduction functors for the gpu\ntemplate <typename T>\nstruct SumOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicAdd(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMul(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MaxOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMax(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MinOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMin(dest, value);\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// initial value functors\ntemplate <typename T>\nstruct Zero {\n  EIGEN_STRONG_INLINE T operator()() const { return T(0); }\n};\n\ntemplate <typename T>\nstruct One {\n  EIGEN_STRONG_INLINE T operator()() const { return T(1); }\n};\n\ntemplate <typename T>\nstruct Lowest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::lowest();\n  }\n};\n\ntemplate <typename T>\nstruct Highest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::highest();\n  }\n};\n\n}  // namespace functor\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define EIGEN_USE_GPU\n\n// We need to include gpu_kernel_helper.h before segment_reduction_ops.h\n// See comment in segment_reduction_ops.h for more details.\n// clang-format off\n#include \"tensorflow/core/util/gpu_kernel_helper.h\"\n// clang-format on\n\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/util/gpu_device_functions.h\"\n\nnamespace tensorflow {\n\nusing GPUDevice = Eigen::GpuDevice;\n\n// SortedSegmentSumFunctor kernel reduces input data just as\n// UnsortedSegmentSumCustomKernel does except that input data\n// is partitioned along the outer reduction dimension. This is\n// because consecutive rows (elements in a row share the same\n// outer dimension index) in the flattened 2D input data likely\n// belong to the same segment in sorted segment sum operation.\n// Therefore such partitioning strategy has two advantages over\n// the UnsortedSegmentSumFunctor kernel:\n// 1. Each thread reduces across multiple rows before writing\n// answers to the global memory, we can therefore\n// write reduction results to global memory less often.\n// 2. We may know that the current thread is the only contributor\n// to an output element because of the increasing nature of segment\n// ids. In such cases, we do not need to use atomic operations\n// to write results to global memory.\n// In the flattened view of input data (with only outer and inner\n// dimension), every thread processes a strip of input data of\n// size OuterDimTileSize x 1. This strip runs across multiple\n// rows of input data and all reduction elements share one inner\n// dimension index.\ntemplate <typename T, typename Index, int OuterDimTileSize>\n__global__ void SortedSegmentSumCustomKernel(const Index input_outer_dim_size,\n                                             const Index inner_dim_size,\n                                             const Index output_outer_dim_size,\n                                             const Index* segment_ids,\n                                             const T* input, T* output,\n                                             const Index total_stripe_count) {\n  for (int stripe_index : GpuGridRangeX(total_stripe_count)) {\n    const Index segment_offset = stripe_index % inner_dim_size;\n    const Index input_outer_dim_index_base =\n        stripe_index / inner_dim_size * Index(OuterDimTileSize);\n\n    T sum = T(0);\n    Index first_segment_id = segment_ids[input_outer_dim_index_base];\n    Index last_output_segment_id = output_outer_dim_size;\n\n    const Index actual_stripe_height =\n        min(Index(OuterDimTileSize),\n            input_outer_dim_size - input_outer_dim_index_base);\n    for (Index j = 0; j < actual_stripe_height; j++) {\n      Index current_output_segment_id =\n          segment_ids[input_outer_dim_index_base + j];\n      // Decide whether to write result to global memory.\n      // Result is only written to global memory if we move\n      // to another segment. Otherwise we can keep accumulating\n      // locally.\n      if (current_output_segment_id > last_output_segment_id) {\n        const Index output_index =\n            last_output_segment_id * inner_dim_size + segment_offset;\n        // decide whether to write result to global memory using atomic\n        // operations\n        if (last_output_segment_id == first_segment_id) {\n          GpuAtomicAdd(output + output_index, sum);\n        } else {\n          *(output + output_index) = sum;\n        }\n        sum = T(0);\n      }\n      sum += ldg(input + (input_outer_dim_index_base + j) * inner_dim_size +\n                 segment_offset);\n      last_output_segment_id = current_output_segment_id;\n    }\n    // For the last result in a strip, always write using atomic operations\n    // due to possible race conditions with threads computing\n    // the following strip.\n    const Index output_index =\n        last_output_segment_id * inner_dim_size + segment_offset;\n    GpuAtomicAdd(output + output_index, sum);\n  }\n}\n\n// UnsortedSegmentSumKernel processes 'input_total_size' elements.\n// Each element is mapped from input to output by a combination of its\n// 'segment_ids' mapping and 'inner_dim_size'.\ntemplate <typename T, typename Index, typename KernelReductionFunctor>\n__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}\n\nnamespace functor {\n\ntemplate <typename T, typename Index>\nvoid SegmentSumFunctor<T, Index>::operator()(\n    OpKernelContext* ctx, const GPUDevice& d, const Index output_rows,\n    const TensorShape& segment_ids_shape,\n    typename TTypes<Index>::ConstFlat segment_ids, const Index data_size,\n    const T* data, typename TTypes<T, 2>::Tensor output) {\n  if (output.size() == 0) {\n    return;\n  }\n  // Set 'output' to zeros.\n  GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n  TF_CHECK_OK(GpuLaunchKernel(SetZero<T>, config.block_count,\n                              config.thread_per_block, 0, d.stream(),\n                              output.size(), output.data()));\n  if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n    return;\n  }\n\n  // Launch kernel to compute sorted segment sum.\n  // Notes:\n  // *) 'input_total_size' is the total number of elements to process.\n  // *) 'segment_ids.shape' is a prefix of data's shape.\n  // *) 'input_outer_dim_size' is the total number of segments to process.\n  const Index input_total_size = data_size;\n  const Index input_outer_dim_size = segment_ids.dimension(0);\n  const Index input_inner_dim_size = input_total_size / input_outer_dim_size;\n\n  const int OuterDimTileSize = 8;\n\n  const Index input_outer_dim_num_stripe =\n      Eigen::divup(input_outer_dim_size, Index(OuterDimTileSize));\n\n  const Index total_stripe_count =\n      input_inner_dim_size * input_outer_dim_num_stripe;\n\n  config = GetGpuLaunchConfig(total_stripe_count, d);\n  TF_CHECK_OK(GpuLaunchKernel(\n      SortedSegmentSumCustomKernel<T, Index, OuterDimTileSize>,\n      config.block_count, config.thread_per_block, 0, d.stream(),\n      input_outer_dim_size, input_inner_dim_size, output_rows,\n      segment_ids.data(), data, output.data(), total_stripe_count));\n}\n\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<GPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    // Set 'output' to initial value.\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    // Launch kernel to compute unsorted segment reduction.\n    // Notes:\n    // *) 'data_size' is the total number of elements to process.\n    // *) 'segment_ids.shape' is a prefix of data's shape.\n    // *) 'input_outer_dim_size' is the total number of segments to process.\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }\n};\n\n#define DEFINE_SORTED_GPU_SPECS_INDEX(T, Index) \\\n  template struct SegmentSumFunctor<T, Index>\n\n#define DEFINE_SORTED_GPU_SPECS(T)         \\\n  DEFINE_SORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_SORTED_GPU_SPECS_INDEX(T, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_SORTED_GPU_SPECS);\n\n#define DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, Index)                         \\\n  template struct UnsortedSegmentFunctor<                                      \\\n      GPUDevice, T, Index, functor::Lowest<T>, functor::MaxOpGpu<T>>;          \\\n  template struct UnsortedSegmentFunctor<                                      \\\n      GPUDevice, T, Index, functor::Highest<T>, functor::MinOpGpu<T>>;         \\\n  template struct UnsortedSegmentFunctor<GPUDevice, T, Index, functor::One<T>, \\\n                                         functor::ProdOpGpu<T>>;\n\n// sum is the only op that supports all input types currently\n#define DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, Index) \\\n  template struct UnsortedSegmentFunctor<             \\\n      GPUDevice, T, Index, functor::Zero<T>, functor::SumOpGpu<T>>;\n\n#define DEFINE_REAL_GPU_SPECS(T)                  \\\n  DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, int64);\n\n#define DEFINE_SUM_GPU_SPECS(T)                  \\\n  DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_REAL_GPU_SPECS);\nTF_CALL_int32(DEFINE_REAL_GPU_SPECS);\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_SUM_GPU_SPECS);\nTF_CALL_int32(DEFINE_SUM_GPU_SPECS);\n\n// TODO(rocm): support atomicAdd for complex numbers on ROCm\n#if GOOGLE_CUDA\nTF_CALL_complex64(DEFINE_SUM_GPU_SPECS);\nTF_CALL_complex128(DEFINE_SUM_GPU_SPECS);\n#endif\n\n#undef DEFINE_SORTED_GPU_SPECS_INDEX\n#undef DEFINE_SORTED_GPU_SPECS\n#undef DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX\n#undef DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX\n#undef DEFINE_REAL_GPU_SPECS\n#undef DEFINE_SUM_GPU_SPECS\n\n}  // namespace functor\n}  // namespace tensorflow\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#define EIGEN_USE_THREADS\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/common_runtime/gpu/gpu_event_mgr.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#if GOOGLE_CUDA\n#include \"tensorflow/core/kernels/cuda_solvers.h\"\n#include \"tensorflow/core/platform/cuda.h\"\n\nusing stream_executor::cuda::ScopedActivateExecutorContext;\n#elif TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/cuda_solvers.h\"\n#include \"tensorflow/core/platform/rocm.h\"\nusing stream_executor::rocm::ScopedActivateExecutorContext;\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\n// Static routines not in the templated class to reduce code size\nstatic void SegmentReductionValidationHelper(OpKernelContext* context,\n                                             const Tensor& input,\n                                             const Tensor& segment_ids) {\n  OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n              errors::InvalidArgument(\"segment_ids should be a vector.\"));\n  const int64 num_indices = segment_ids.NumElements();\n  OP_REQUIRES(context, num_indices == input.dim_size(0),\n              errors::InvalidArgument(\n                  \"segment_ids should be the same size as dimension 0 of\"\n                  \" input.\"));\n}\n\nstatic bool SegmentReductionDoValidation(OpKernelContext* c,\n                                         const Tensor& input,\n                                         const Tensor& segment_ids) {\n  SegmentReductionValidationHelper(c, input, segment_ids);\n  return c->status().ok();\n}\n\n// This operator handles reducing segments along the first dimension.\n// See core/ops/math_ops.cc for more details.\ntemplate <typename Device, class T, class Index, typename Reducer,\n          int default_value>\nclass SegmentReductionOp : public OpKernel {\n public:\n  explicit SegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    if (!SegmentReductionDoValidation(context, input, segment_ids)) {\n      return;\n    }\n\n    const int64 num_indices = segment_ids.NumElements();\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64 num_col = input_flat.dimension(1);\n\n    const auto segment_vec = segment_ids.vec<Index>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const Index output_rows =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) return;\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n#if !defined(EIGEN_HAS_INDEX_LIST)\n    Eigen::DSizes<Eigen::DenseIndex, 1> dims_to_reduce;\n    dims_to_reduce[0] = 0;\n#else\n    Eigen::IndexList<Eigen::type2index<0> > dims_to_reduce;\n#endif\n    Index start = 0, end = 1;\n\n    Index uninitialized_index = 0;  // Index from which the output is not set.\n    Index out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    // TODO(agarwal): if this loop becomes a bottleneck, consider sharding it\n    // across threads.\n    Eigen::DSizes<Eigen::DenseIndex, 1> out_slice_shape(num_col);\n    while (end <= num_indices) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      Index next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      // Process segment [start, end)\n      const T* in_slice_ptr = &input_flat(start, 0);\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 1, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          OutT;\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(T(default_value));\n      }\n\n      T* out_slice_ptr = &output_flat(out_index, 0);\n      OutT out_slice(out_slice_ptr, out_slice_shape);\n      // We don't use out_slice.device(context->eigen_device<Device>)\n      // because these pieces of work are likely to be very small and\n      // the context switching overhead dwarfs any benefit we get from\n      // using another thread to do this work.\n      if (start == end - 1) {\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, out_slice_shape);\n        out_slice = in_slice;\n      } else {\n        Eigen::DSizes<Eigen::DenseIndex, 2> in_slice_shape(end - start,\n                                                           num_col);\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, in_slice_shape);\n\n        out_slice = in_slice.reduce(dims_to_reduce, Reducer());\n      }\n      if (end >= num_indices) break;\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n//  SegmentSumGPUOp is a segment sum operator implemented for GPU only.\n//  TODO: This implementation of SegmentSumGPUOp is sometimes slower than\n//  its unsorted counterpart (mostly when problem size is small).\n//  This is due to the following two main reasons and a cost-effective way\n//  to resolve these problems is desirable.\n//  1. Sorted segment sum requires a memory transfer from device to host in\n//     order to know the size of the output dimension whereas unsorted segment\n//     sum receives the size of the output dimension as an input parameter.\n//  2. Sorted segment sum is essentially a tiled version of unsorted segment\n//     sum and therefore such optimization comes at an inherent cost. However\n//     such cost may not be justified when the problem size is small. When to\n//     use the tiled version or the untiled version depends on many factors\n//     including data alignments, ratio of calculation to memory traffic and\n//     obviously, the problem sizes.\ntemplate <class T, class Index>\nclass SegmentSumGPUOp : public AsyncOpKernel {\n public:\n  explicit SegmentSumGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_ASYNC(\n        context, TensorShapeUtils::IsVector(segment_ids.shape()),\n        errors::InvalidArgument(\"segment_ids should be a vector.\"), done);\n\n    const int64 num_indices = segment_ids.NumElements();\n    OP_REQUIRES_ASYNC(\n        context, num_indices == input.dim_size(0),\n        errors::InvalidArgument(\n            \"segment_ids should be the same size as dimension 0 of\"\n            \" input.\"),\n        done);\n\n    if (num_indices == 0) {\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, 0);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n      done();\n      return;\n    }\n\n    se::DeviceMemoryBase output_rows_device(\n        const_cast<Tensor&>(segment_ids).template flat<Index>().data() +\n        (num_indices - 1));\n    ScratchSpace<Index> output_rows_host(context, 1, /* on_host */ true);\n\n    auto stream = context->op_device_context()->stream();\n    OP_REQUIRES_ASYNC(\n        context,\n        stream\n            ->ThenMemcpy(output_rows_host.mutable_data(), output_rows_device,\n                         sizeof(Index))\n            .ok(),\n        errors::Internal(\n            \"SegmentSumGPUOp: failed to copy output_rows from device\"),\n        done);\n\n    functor::SegmentSumFunctor<T, Index> functor_;\n    auto create_and_check_output = [context, output_rows_host, &input,\n                                    &segment_ids, &functor_, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      Index output_rows = *output_rows_host.data();\n      output_rows++;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, output_rows);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      auto output_flat = output->flat_outer_dims<T>();\n      auto data_ptr = input.template flat<T>().data();\n      auto segment_flat = segment_ids.flat<Index>();\n      functor_(context, context->eigen_device<GPUDevice>(), output_rows,\n               segment_ids.shape(), segment_flat, input.NumElements(), data_ptr,\n               output_flat);\n\n      done();\n    };\n\n    context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n        stream, create_and_check_output);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER_CPU_KERNEL_SEGMENT(name, functor, type, index_type, \\\n                                    default_value)                   \\\n  REGISTER_KERNEL_BUILDER(                                           \\\n      Name(name)                                                     \\\n          .Device(DEVICE_CPU)                                        \\\n          .TypeConstraint<type>(\"T\")                                 \\\n          .TypeConstraint<index_type>(\"Tindices\"),                   \\\n      SegmentReductionOp<CPUDevice, type, index_type, functor, default_value>)\n\n#define REGISTER_REAL_CPU_KERNELS(type, index_type)                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentSum\", Eigen::internal::SumReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentMean\", Eigen::internal::MeanReducer<type>, type, index_type, 0); \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentProd\", Eigen::internal::ProdReducer<type>, type, index_type, 1); \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentMin\", Eigen::internal::MinReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentMax\", Eigen::internal::MaxReducer<type>, \\\n                              type, index_type, 0)\n\n#define REGISTER_COMPLEX_CPU_KERNELS(type, index_type)                         \\\n  REGISTER_CPU_KERNEL_SEGMENT(\"SegmentSum\", Eigen::internal::SumReducer<type>, \\\n                              type, index_type, 0);                            \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentMean\", Eigen::internal::MeanReducer<type>, type, index_type, 0); \\\n  REGISTER_CPU_KERNEL_SEGMENT(                                                 \\\n      \"SegmentProd\", Eigen::internal::ProdReducer<type>, type, index_type, 1);\n\n#define REGISTER_REAL_CPU_KERNELS_ALL(type) \\\n  REGISTER_REAL_CPU_KERNELS(type, int32);   \\\n  REGISTER_REAL_CPU_KERNELS(type, int64)\n\n#define REGISTER_COMPLEX_CPU_KERNELS_ALL(type) \\\n  REGISTER_COMPLEX_CPU_KERNELS(type, int32);   \\\n  REGISTER_COMPLEX_CPU_KERNELS(type, int64)\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex128);\n#undef REGISTER_CPU_KERNEL_SEGMENT\n#undef REGISTER_REAL_CPU_KERNELS\n#undef REGISTER_COMPLEX_CPU_KERNELS\n#undef REGISTER_REAL_CPU_KERNELS_ALL\n#undef REGISTER_COMPLEX_CPU_KERNELS_ALL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_SORTED_KERNELS(type, index_type)                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"SegmentSum\")                           \\\n                              .Device(DEVICE_GPU)                      \\\n                              .TypeConstraint<type>(\"T\")               \\\n                              .TypeConstraint<index_type>(\"Tindices\"), \\\n                          SegmentSumGPUOp<type, index_type>)\n\n#define REGISTER_GPU_SORTED_KERNELS_ALL(type) \\\n  REGISTER_GPU_SORTED_KERNELS(type, int32);   \\\n  REGISTER_GPU_SORTED_KERNELS(type, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_SORTED_KERNELS_ALL);\n#undef REGISTER_GPU_SORTED_KERNELS\n#undef REGISTER_GPU_SORTED_KERNELS_ALL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Unsorted segment reduction ops.\n\nnamespace functor {\n\n// The ReductionFunctor implementation for CPU.\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  typename TTypes<T, 2>::ConstTensor data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data.size() == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    const int64 num_segments = output.dimension(0);\n    ReductionF reduction;\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data.template chip<0>(i), output.template chip<0>(j));\n    }\n  }\n};\n\ntemplate <typename T>\nusing MatrixChip = Eigen::TensorChippingOp<0l, typename TTypes<T, 2>::Matrix>;\n\ntemplate <typename T>\nusing constMatrixChip =\n    Eigen::TensorChippingOp<0l, const typename TTypes<T, 2>::ConstMatrix>;\n\n// reduction functors\ntemplate <typename T>\nstruct SumOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output += data;\n  }\n};\n\ntemplate <typename T>\nstruct MaxOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMax(output);\n  }\n};\n\ntemplate <typename T>\nstruct MinOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMin(output);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output *= data;\n  }\n};\n}  // namespace functor\n\n// Static check routines not in the templated class to reduce code size\nstatic void UnsortedSegmentReductionValidation(OpKernel* op_kernel,\n                                               OpKernelContext* context,\n                                               const Tensor& data,\n                                               const Tensor& segment_ids,\n                                               const Tensor& num_segments) {\n  OP_REQUIRES(\n      context, op_kernel->IsLegacyScalar(num_segments.shape()),\n      errors::InvalidArgument(\"num_segments should be a scalar, not shape \",\n                              num_segments.shape().DebugString()));\n  OP_REQUIRES(\n      context, TensorShapeUtils::StartsWith(data.shape(), segment_ids.shape()),\n      errors::InvalidArgument(\"data.shape = \", data.shape().DebugString(),\n                              \" does not start with segment_ids.shape = \",\n                              segment_ids.shape().DebugString()));\n}\n\nstatic bool UnsortedSegmentReductionDoValidation(OpKernel* op_kernel,\n                                                 OpKernelContext* context,\n                                                 const Tensor& data,\n                                                 const Tensor& segment_ids,\n                                                 const Tensor& num_segments) {\n  UnsortedSegmentReductionValidation(op_kernel, context, data, segment_ids,\n                                     num_segments);\n  return context->status().ok();\n}\n\n// The UnsortedSegmentReduction OpKernel. The DeviceReductionFunctor\n// is the device specific implementation of the reduction. These device\n// specific implementations are templated themselves with the corresponding\n// initial value functors and reduction functors.\ntemplate <typename T, typename Index, typename DeviceReductionFunctor>\nclass UnsortedSegmentReductionOp : public OpKernel {\n public:\n  explicit UnsortedSegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context), reduction_functor_(DeviceReductionFunctor()) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n                       output_flat);\n  }\n\n protected:\n  DeviceReductionFunctor reduction_functor_;\n};\n\n#define REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(                           \\\n    name, type, index_type, initial_value_functor, reduction_functor)  \\\n  REGISTER_KERNEL_BUILDER(                                             \\\n      Name(name)                                                       \\\n          .Device(DEVICE_CPU)                                          \\\n          .TypeConstraint<type>(\"T\")                                   \\\n          .TypeConstraint<index_type>(\"Tindices\"),                     \\\n      UnsortedSegmentReductionOp<                                      \\\n          type, index_type,                                            \\\n          functor::UnsortedSegmentFunctor<CPUDevice, type, index_type, \\\n                                          initial_value_functor,       \\\n                                          reduction_functor> >)\n\n#define REGISTER_REAL_CPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type,  \\\n                                      functor::Zero<type>,                     \\\n                                      functor::SumOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMax\", type, index_type,  \\\n                                      functor::Lowest<type>,                   \\\n                                      functor::MaxOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMin\", type, index_type,  \\\n                                      functor::Highest<type>,                  \\\n                                      functor::MinOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOp<type>);\n\n#define REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, index_type)                \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type,  \\\n                                      functor::Zero<type>,                     \\\n                                      functor::SumOp<type>);                   \\\n  REGISTER_CPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOp<type>)\n\n#define REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_REAL_CPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_REAL_CPU_UNSORTED_KERNELS(type, int64)\n\n#define REGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_COMPLEX_CPU_UNSORTED_KERNELS(type, int64)\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL(complex128);\n\n#undef REGISTER_REAL_CPU_UNSORTED_KERNELS\n#undef REGISTER_CPU_KERNEL_UNSORTEDSEGMENT\n#undef REGISTER_COMPLEX_CPU_UNSORTED_KERNELS\n#undef REGISTER_COMPLEX_CPU_UNSORTED_KERNELS_ALL\n#undef REGISTER_REAL_CPU_UNSORTED_KERNELS_ALL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(                                 \\\n    name, type, index_type, initial_value_functor, reduction_kernel_functor) \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(name)                                                             \\\n          .Device(DEVICE_GPU)                                                \\\n          .HostMemory(\"num_segments\")                                        \\\n          .TypeConstraint<type>(\"T\")                                         \\\n          .TypeConstraint<index_type>(\"Tindices\"),                           \\\n      UnsortedSegmentReductionOp<                                            \\\n          type, index_type,                                                  \\\n          functor::UnsortedSegmentFunctor<GPUDevice, type, index_type,       \\\n                                          initial_value_functor,             \\\n                                          reduction_kernel_functor> >)\n\n// sum is the only op that supports all input types currently\n#define REGISTER_REAL_GPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMax\", type, index_type,  \\\n                                      functor::Lowest<type>,                   \\\n                                      functor::MaxOpGpu<type>);                \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentMin\", type, index_type,  \\\n                                      functor::Highest<type>,                  \\\n                                      functor::MinOpGpu<type>);                \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentProd\", type, index_type, \\\n                                      functor::One<type>,                      \\\n                                      functor::ProdOpGpu<type>);\n\n#define REGISTER_SUM_GPU_UNSORTED_KERNELS(type, index_type)                   \\\n  REGISTER_GPU_KERNEL_UNSORTEDSEGMENT(\"UnsortedSegmentSum\", type, index_type, \\\n                                      functor::Zero<type>,                    \\\n                                      functor::SumOpGpu<type>);\n\n#define REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_REAL_GPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_REAL_GPU_UNSORTED_KERNELS(type, int64);\n\n#define REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL(type) \\\n  REGISTER_SUM_GPU_UNSORTED_KERNELS(type, int32);   \\\n  REGISTER_SUM_GPU_UNSORTED_KERNELS(type, int64);\n\n\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_int32(REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_int32(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\n// TODO(rocm): support atomicAdd for complex numbers on ROCm\n#if GOOGLE_CUDA\nTF_CALL_complex64(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\nTF_CALL_complex128(REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL);\n#endif\n\n#undef REGISTER_GPU_KERNEL_UNSORTEDSEGMENT\n#undef REGISTER_REAL_GPU_UNSORTED_KERNELS\n#undef REGISTER_SUM_GPU_UNSORTED_KERNELS\n#undef REGISTER_REAL_GPU_UNSORTED_KERNELS_ALL\n#undef REGISTER_SUM_GPU_UNSORTED_KERNELS_ALL\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Sparse segment reduction ops.\n\n// Same as SegmentReductionOp but takes as input a \"sparse\" tensor, represented\n// by two dense tensors, one containing the data, and the other containing\n// indices into the data.\ntemplate <typename Device, class T>\nclass SparseSegmentReductionOpBase : public OpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : OpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    Index output_rows = -1;\n    if (has_num_segments_) {\n      const Tensor& num_segments = context->input(3);\n\n      OP_REQUIRES(\n          context, num_segments.shape().dims() == 0,\n          errors::InvalidArgument(\"num_segments should be a scalar, not shape \",\n                                  num_segments.shape().DebugString()));\n      output_rows = internal::SubtleMustCopy(num_segments.scalar<int32>()());\n      OP_REQUIRES(context, output_rows >= 0,\n                  errors::InvalidArgument(\"segment ids must be >= 0\"));\n    }\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n\n    const int64 num_indices = indices.NumElements();\n    OP_REQUIRES(context, num_indices == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64 num_col = input_flat.dimension(1);\n    const auto indices_vec = indices.vec<Index>();\n    typedef int32 OutputRow;\n    const auto segment_vec = segment_ids.vec<OutputRow>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const OutputRow last_segment_id_plus_one =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    if (has_num_segments_) {\n      OP_REQUIRES(\n          context, output_rows >= last_segment_id_plus_one,\n          errors::InvalidArgument(\"segment ids must be < num_segments\"));\n    } else {\n      output_rows = last_segment_id_plus_one;\n    }\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) {\n      if (output_rows > 0) {\n        output->flat_outer_dims<T>().setConstant(default_value_);\n      }\n      return;\n    }\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n    int64 start = 0, end = 1;\n    // Index from which the output is not initialized.\n    OutputRow uninitialized_index = 0;\n    OutputRow out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    while (true) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      OutputRow next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(default_value_);\n      }\n\n      auto out = output_flat.template chip<0>(out_index);\n      const int bad_offset =\n          Reduce(input_flat, indices_vec, start, end - start, out);\n      OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"));\n\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n      if (end > num_indices) break;\n    }\n\n    // Fill the gap at the end with the default value.\n    if (uninitialized_index < output_rows) {\n      Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n          output_rows - uninitialized_index, num_col);\n      Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n      gap_slice.setConstant(default_value_);\n    }\n  }\n\n private:\n  typedef int32 Index;\n\n  int64 Reduce(const typename TTypes<T>::ConstMatrix& input_flat,\n               const typename TTypes<Index>::ConstVec& indices_vec, int64 start,\n               int64 num,\n               Eigen::TensorChippingOp<0, typename TTypes<T>::Matrix> out) {\n#define INDEX(n, i)                               \\\n  const auto index##n = indices_vec(start + (i)); \\\n  if (!FastBoundsCheck(index##n, input_flat.dimension(0))) return (i);\n\n#define L(n) input_flat.template chip<0>(index##n)\n\n    if (num == 1) {\n      INDEX(0, 0);\n      out = L(0);\n    } else {\n      int64 r = num % 8;\n      T m(1);\n      if (is_mean_ && (num < 10)) {\n        m = T(num);\n      }\n      if (is_sqrtn_ && (num < 10)) {\n        m = T(sqrt(num));\n      }\n      switch (r) {\n        case 2: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          out = (L(0) + L(1)) / m;\n          break;\n        }\n        case 3: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          out = (L(0) + L(1) + L(2)) / m;\n          break;\n        }\n        case 4: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          out = (L(0) + L(1) + L(2) + L(3)) / m;\n          break;\n        }\n        case 5: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4)) / m;\n          break;\n        }\n        case 6: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) / m;\n          break;\n        }\n        case 7: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) / m;\n          break;\n        }\n        case 0: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) / m;\n          r = 8;\n          break;\n        }\n        case 1: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          INDEX(8, 8);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) /\n                m;\n          r = 9;\n          break;\n        }\n      }\n      for (; r < num; r += 8) {\n        INDEX(0, r);\n        INDEX(1, r + 1);\n        INDEX(2, r + 2);\n        INDEX(3, r + 3);\n        INDEX(4, r + 4);\n        INDEX(5, r + 5);\n        INDEX(6, r + 6);\n        INDEX(7, r + 7);\n        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);\n      }\n      if (is_mean_ && num >= 10) {\n        out = out / static_cast<T>(num);\n      }\n      if (is_sqrtn_ && num >= 10) {\n        out = out / static_cast<T>(sqrt(num));\n      }\n    }\n\n    return -1;\n#undef L\n#undef INDEX\n  }\n\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionMeanOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionMeanWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionMeanWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSqrtNOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSqrtNWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSumOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T>\nclass SparseSegmentReductionSumWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T> {\n public:\n  explicit SparseSegmentReductionSumWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSum\")                       \\\n                              .Device(DEVICE_CPU)                        \\\n                              .TypeConstraint<type>(\"T\")                 \\\n                              .TypeConstraint<int32>(\"Tidx\"),            \\\n                          SparseSegmentReductionSumOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseSegmentSumWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                            \\\n          .TypeConstraint<type>(\"T\")                                     \\\n          .TypeConstraint<int32>(\"Tidx\"),                                \\\n      SparseSegmentReductionSumWithNumSegmentsOp<CPUDevice, type>);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_SPARSE_KERNELS);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentMean\")                       \\\n                              .Device(DEVICE_CPU)                         \\\n                              .TypeConstraint<type>(\"T\")                  \\\n                              .TypeConstraint<int32>(\"Tidx\"),             \\\n                          SparseSegmentReductionMeanOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                                \\\n      Name(\"SparseSegmentMeanWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                             \\\n          .TypeConstraint<type>(\"T\")                                      \\\n          .TypeConstraint<int32>(\"Tidx\"),                                 \\\n      SparseSegmentReductionMeanWithNumSegmentsOp<CPUDevice, type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSqrtN\")                       \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<type>(\"T\")                   \\\n                              .TypeConstraint<int32>(\"Tidx\"),              \\\n                          SparseSegmentReductionSqrtNOp<CPUDevice, type>); \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"SparseSegmentSqrtNWithNumSegments\")                            \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<type>(\"T\")                                       \\\n          .TypeConstraint<int32>(\"Tidx\"),                                  \\\n      SparseSegmentReductionSqrtNWithNumSegmentsOp<CPUDevice, type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\ntemplate <class T>\nclass SparseSegmentGradOpBase : public OpKernel {\n public:\n  explicit SparseSegmentGradOpBase(OpKernelConstruction* context, bool is_sqrtn)\n      : OpKernel(context), is_sqrtn_(is_sqrtn) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n    const Tensor& output_dim0 = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n    OP_REQUIRES(context, IsLegacyScalar(output_dim0.shape()),\n                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));\n\n    const int64 N = indices.NumElements();\n    OP_REQUIRES(context, N == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n    typedef int32 SegmentId;\n    const SegmentId M =\n        internal::SubtleMustCopy(output_dim0.scalar<SegmentId>()());\n\n    auto input_flat = input.flat_outer_dims<T>();\n    typedef int32 Index;\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, M);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (M == 0 || N == 0) return;\n\n    // Note that similar to SparseSegmentMean, we assume that segment_vec is\n    // already sorted and has non-negative values.\n    const SegmentId num_segments = input.dim_size(0);\n    const SegmentId last_segment_id_plus_one =\n        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;\n    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"));\n\n    // Compute scaling factors for input.\n    std::vector<double> scaling(num_segments, 0.0);\n    for (int64 i = 0; i < N; ++i) {\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n      scaling[idx] += 1;\n    }\n    for (size_t i = 0; i < scaling.size(); ++i) {\n      if (is_sqrtn_) {\n        scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));\n      } else {\n        scaling[i] = 1.0 / std::max(scaling[i], 1.0);\n      }\n    }\n\n    auto output_flat = output->flat_outer_dims<T>();\n    output_flat.setZero();\n    std::vector<bool> is_modified(M, false);\n\n    for (int64 i = 0; i < N; ++i) {\n      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));\n      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),\n                  errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\"));\n\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n\n      const T scale = static_cast<T>(scaling[idx]);\n      if (is_modified[output_idx]) {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx) * scale;\n        }\n      } else {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx) * scale;\n        }\n      }\n      is_modified[output_idx] = true;\n    }\n  }\n\n private:\n  const bool is_sqrtn_;\n};\n\ntemplate <class T>\nclass SparseSegmentMeanGradOp : public SparseSegmentGradOpBase<T> {\n public:\n  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<T>(context, false /*is_sqrtn*/) {}\n};\n\ntemplate <class T>\nclass SparseSegmentSqrtNGradOp : public SparseSegmentGradOpBase<T> {\n public:\n  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<T>(context, true /*is_sqrtn*/) {}\n};\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentMeanGrad\")       \\\n                              .Device(DEVICE_CPU)             \\\n                              .TypeConstraint<type>(\"T\")      \\\n                              .TypeConstraint<int32>(\"Tidx\"), \\\n                          SparseSegmentMeanGradOp<type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n\n#define REGISTER_CPU_SPARSE_KERNELS(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseSegmentSqrtNGrad\")      \\\n                              .Device(DEVICE_CPU)             \\\n                              .TypeConstraint<type>(\"T\")      \\\n                              .TypeConstraint<int32>(\"Tidx\"), \\\n                          SparseSegmentSqrtNGradOp<type>);\nREGISTER_CPU_SPARSE_KERNELS(float);\nREGISTER_CPU_SPARSE_KERNELS(double);\n#undef REGISTER_CPU_SPARSE_KERNELS\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n#define TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n\n// This file requires the following include because it uses GpuAtomicMax:\n// #include \"tensorflow/core/util/gpu_kernel_helper.h\"\n\n// Unfortunately we can't add the #include, since it breaks compilation for\n// non-GPU targets. This only breaks in clang, because it's more strict for\n// template code and GpuAtomicMax is used in template context.\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n\nnamespace tensorflow {\n\nclass OpKernelContext;\n\nnamespace functor {\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n// Functor for SegmentSumGPUOp.\n// output_rows: the number of output segments (unique segment ids in\n//                'segment_ids').\n// segment_ids_shape: shape of 'segment_ids' tensor.\n// segment_ids: unsorted map from input to output segment ids at which to\n//                perform segment sum operation.\n// data_size: size of input data tensor.\n// data: input data tensor.\n// output: output reshaped to {output_rows, output.size/output_rows}\ntemplate <typename T, typename Index>\nstruct SegmentSumFunctor {\n  void operator()(OpKernelContext* ctx, const GPUDevice& d,\n                  const Index output_rows, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#endif\n\ntemplate <typename Device, typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor {\n  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  typename TTypes<T, 2>::ConstTensor data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n// reduction functors for the gpu\ntemplate <typename T>\nstruct SumOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicAdd(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMul(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MaxOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMax(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MinOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMin(dest, value);\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// initial value functors\ntemplate <typename T>\nstruct Zero {\n  EIGEN_STRONG_INLINE T operator()() const { return T(0); }\n};\n\ntemplate <typename T>\nstruct One {\n  EIGEN_STRONG_INLINE T operator()() const { return T(1); }\n};\n\ntemplate <typename T>\nstruct Lowest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::lowest();\n  }\n};\n\ntemplate <typename T>\nstruct Highest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::highest();\n  }\n};\n\n}  // namespace functor\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define EIGEN_USE_GPU\n\n// We need to include gpu_kernel_helper.h before segment_reduction_ops.h\n// See comment in segment_reduction_ops.h for more details.\n// clang-format off\n#include \"tensorflow/core/util/gpu_kernel_helper.h\"\n// clang-format on\n\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/util/gpu_device_functions.h\"\n\nnamespace tensorflow {\n\nusing GPUDevice = Eigen::GpuDevice;\n\n// SortedSegmentSumFunctor kernel reduces input data just as\n// UnsortedSegmentSumCustomKernel does except that input data\n// is partitioned along the outer reduction dimension. This is\n// because consecutive rows (elements in a row share the same\n// outer dimension index) in the flattened 2D input data likely\n// belong to the same segment in sorted segment sum operation.\n// Therefore such partitioning strategy has two advantages over\n// the UnsortedSegmentSumFunctor kernel:\n// 1. Each thread reduces across multiple rows before writing\n// answers to the global memory, we can therefore\n// write reduction results to global memory less often.\n// 2. We may know that the current thread is the only contributor\n// to an output element because of the increasing nature of segment\n// ids. In such cases, we do not need to use atomic operations\n// to write results to global memory.\n// In the flattened view of input data (with only outer and inner\n// dimension), every thread processes a strip of input data of\n// size OuterDimTileSize x 1. This strip runs across multiple\n// rows of input data and all reduction elements share one inner\n// dimension index.\ntemplate <typename T, typename Index, int OuterDimTileSize>\n__global__ void SortedSegmentSumCustomKernel(const Index input_outer_dim_size,\n                                             const Index inner_dim_size,\n                                             const Index output_outer_dim_size,\n                                             const Index* segment_ids,\n                                             const T* input, T* output,\n                                             const Index total_stripe_count) {\n  for (int stripe_index : GpuGridRangeX(total_stripe_count)) {\n    const Index segment_offset = stripe_index % inner_dim_size;\n    const Index input_outer_dim_index_base =\n        stripe_index / inner_dim_size * Index(OuterDimTileSize);\n\n    T sum = T(0);\n    Index first_segment_id = segment_ids[input_outer_dim_index_base];\n    Index last_output_segment_id = output_outer_dim_size;\n\n    const Index actual_stripe_height =\n        min(Index(OuterDimTileSize),\n            input_outer_dim_size - input_outer_dim_index_base);\n    for (Index j = 0; j < actual_stripe_height; j++) {\n      Index current_output_segment_id =\n          segment_ids[input_outer_dim_index_base + j];\n      // Decide whether to write result to global memory.\n      // Result is only written to global memory if we move\n      // to another segment. Otherwise we can keep accumulating\n      // locally.\n      if (current_output_segment_id > last_output_segment_id) {\n        const Index output_index =\n            last_output_segment_id * inner_dim_size + segment_offset;\n        // decide whether to write result to global memory using atomic\n        // operations\n        if (last_output_segment_id == first_segment_id) {\n          GpuAtomicAdd(output + output_index, sum);\n        } else {\n          *(output + output_index) = sum;\n        }\n        sum = T(0);\n      }\n      sum += ldg(input + (input_outer_dim_index_base + j) * inner_dim_size +\n                 segment_offset);\n      last_output_segment_id = current_output_segment_id;\n    }\n    // For the last result in a strip, always write using atomic operations\n    // due to possible race conditions with threads computing\n    // the following strip.\n    const Index output_index =\n        last_output_segment_id * inner_dim_size + segment_offset;\n    GpuAtomicAdd(output + output_index, sum);\n  }\n}\n\n// UnsortedSegmentSumKernel processes 'input_total_size' elements.\n// Each element is mapped from input to output by a combination of its\n// 'segment_ids' mapping and 'inner_dim_size'.\ntemplate <typename T, typename Index, typename KernelReductionFunctor>\n__global__ void UnsortedSegmentCustomKernel(const int64 input_outer_dim_size,\n                                            const int64 inner_dim_size,\n                                            const int64 output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const int64 input_total_size = input_outer_dim_size * inner_dim_size;\n  for (int64 input_index : GpuGridRangeX(input_total_size)) {\n    const int64 input_segment_index = input_index / inner_dim_size;\n    const int64 segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 ||\n        output_segment_index >= output_outer_dim_size) {\n      continue;\n    }\n    const int64 output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}\n\nnamespace functor {\n\ntemplate <typename T, typename Index>\nvoid SegmentSumFunctor<T, Index>::operator()(\n    OpKernelContext* ctx, const GPUDevice& d, const Index output_rows,\n    const TensorShape& segment_ids_shape,\n    typename TTypes<Index>::ConstFlat segment_ids, const Index data_size,\n    const T* data, typename TTypes<T, 2>::Tensor output) {\n  if (output.size() == 0) {\n    return;\n  }\n  // Set 'output' to zeros.\n  GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n  TF_CHECK_OK(GpuLaunchKernel(SetZero<T>, config.block_count,\n                              config.thread_per_block, 0, d.stream(),\n                              output.size(), output.data()));\n  if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n    return;\n  }\n\n  // Launch kernel to compute sorted segment sum.\n  // Notes:\n  // *) 'input_total_size' is the total number of elements to process.\n  // *) 'segment_ids.shape' is a prefix of data's shape.\n  // *) 'input_outer_dim_size' is the total number of segments to process.\n  const Index input_total_size = data_size;\n  const Index input_outer_dim_size = segment_ids.dimension(0);\n  const Index input_inner_dim_size = input_total_size / input_outer_dim_size;\n\n  const int OuterDimTileSize = 8;\n\n  const Index input_outer_dim_num_stripe =\n      Eigen::divup(input_outer_dim_size, Index(OuterDimTileSize));\n\n  const Index total_stripe_count =\n      input_inner_dim_size * input_outer_dim_num_stripe;\n\n  config = GetGpuLaunchConfig(total_stripe_count, d);\n  TF_CHECK_OK(GpuLaunchKernel(\n      SortedSegmentSumCustomKernel<T, Index, OuterDimTileSize>,\n      config.block_count, config.thread_per_block, 0, d.stream(),\n      input_outer_dim_size, input_inner_dim_size, output_rows,\n      segment_ids.data(), data, output.data(), total_stripe_count));\n}\n\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<GPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  typename TTypes<T, 2>::ConstTensor data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    // Set 'output' to initial value.\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    const int64 data_size = data.size();\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    // Launch kernel to compute unsorted segment reduction.\n    // Notes:\n    // *) 'data_size' is the total number of elements to process.\n    // *) 'segment_ids.shape' is a prefix of data's shape.\n    // *) 'input_outer_dim_size' is the total number of segments to process.\n    const int64 input_outer_dim_size = segment_ids.dimension(0);\n    const int64 input_inner_dim_size = data.dimension(1);\n    const int64 output_outer_dim_size = output.dimension(0);\n    config = GetGpuLaunchConfig(data_size, d);\n\n    TF_CHECK_OK(GpuLaunchKernel(\n        UnsortedSegmentCustomKernel<T, Index, ReductionF>, config.block_count,\n        config.thread_per_block, 0, d.stream(), input_outer_dim_size,\n        input_inner_dim_size, output_outer_dim_size, segment_ids.data(),\n        data.data(), output.data()));\n  }\n};\n\n#define DEFINE_SORTED_GPU_SPECS_INDEX(T, Index) \\\n  template struct SegmentSumFunctor<T, Index>\n\n#define DEFINE_SORTED_GPU_SPECS(T)         \\\n  DEFINE_SORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_SORTED_GPU_SPECS_INDEX(T, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_SORTED_GPU_SPECS);\n\n#define DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, Index)                         \\\n  template struct UnsortedSegmentFunctor<                                      \\\n      GPUDevice, T, Index, functor::Lowest<T>, functor::MaxOpGpu<T>>;          \\\n  template struct UnsortedSegmentFunctor<                                      \\\n      GPUDevice, T, Index, functor::Highest<T>, functor::MinOpGpu<T>>;         \\\n  template struct UnsortedSegmentFunctor<GPUDevice, T, Index, functor::One<T>, \\\n                                         functor::ProdOpGpu<T>>;\n\n// sum is the only op that supports all input types currently\n#define DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, Index) \\\n  template struct UnsortedSegmentFunctor<             \\\n      GPUDevice, T, Index, functor::Zero<T>, functor::SumOpGpu<T>>;\n\n#define DEFINE_REAL_GPU_SPECS(T)                  \\\n  DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX(T, int64);\n\n#define DEFINE_SUM_GPU_SPECS(T)                  \\\n  DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, int32); \\\n  DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX(T, int64);\n\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_REAL_GPU_SPECS);\nTF_CALL_int32(DEFINE_REAL_GPU_SPECS);\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_SUM_GPU_SPECS);\nTF_CALL_int32(DEFINE_SUM_GPU_SPECS);\n\n// TODO(rocm): support atomicAdd for complex numbers on ROCm\n#if GOOGLE_CUDA\nTF_CALL_complex64(DEFINE_SUM_GPU_SPECS);\nTF_CALL_complex128(DEFINE_SUM_GPU_SPECS);\n#endif\n\n#undef DEFINE_SORTED_GPU_SPECS_INDEX\n#undef DEFINE_SORTED_GPU_SPECS\n#undef DEFINE_REAL_UNSORTED_GPU_SPECS_INDEX\n#undef DEFINE_SUM_UNSORTED_GPU_SPECS_INDEX\n#undef DEFINE_REAL_GPU_SPECS\n#undef DEFINE_SUM_GPU_SPECS\n\n}  // namespace functor\n}  // namespace tensorflow\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n"], "filenames": ["tensorflow/core/kernels/segment_reduction_ops.cc", "tensorflow/core/kernels/segment_reduction_ops.h", "tensorflow/core/kernels/segment_reduction_ops_gpu.cu.cc"], "buggy_code_start_loc": [379, 62, 109], "buggy_code_end_loc": [505, 66, 208], "fixing_code_start_loc": [379, 62, 109], "fixing_code_end_loc": [504, 65, 209], "type": "CWE-681", "message": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.", "other": {"cve": {"id": "CVE-2019-16778", "sourceIdentifier": "security-advisories@github.com", "published": "2019-12-16T21:15:11.403", "lastModified": "2021-10-29T15:03:06.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0."}, {"lang": "es", "value": "En TensorFlow versiones anteriores a 1.15, un desbordamiento de b\u00fafer de la pila puede ser producido en la funci\u00f3n UnsortedSegmentSum cuando el argumento de la plantilla Index es int32. En este caso, los campos data_size y num_segments son truncados de int64 hasta int32 y pueden producir n\u00fameros negativos, resultando en el acceso a la memoria de la pila fuera de los l\u00edmites. Es poco probable que sea explotable y se detect\u00f3 y repar\u00f3 internamente en TensorFlow versiones 1.15 y 2.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-681"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.15.0", "matchCriteriaId": "4E5F862F-CC11-42FE-ABC5-AA63A003E6FF"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2019-002.md", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-844w-j86r-4x2j", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892"}}