{"buggy_code": ["#include \"crypto.h\"\n\n#include <tier0/vprof.h>\n#include <tier0/dbg.h>\n\n#include \"tier0/memdbgoff.h\"\n#include <sodium.h>\n#include \"tier0/memdbgon.h\"\n\n#ifdef STEAMNETWORKINGSOCKETS_CRYPTO_LIBSODIUM\n\nSymmetricCryptContextBase::SymmetricCryptContextBase()\n    : m_ctx(nullptr), m_cbIV(0), m_cbTag(0)\n{\n}\n\nvoid SymmetricCryptContextBase::Wipe()\n{\n    sodium_free(m_ctx);\n\n    m_ctx = nullptr;\n    m_cbIV = 0;\n    m_cbTag = 0;\n}\n\nbool AES_GCM_CipherContext::InitCipher( const void *pKey, size_t cbKey, size_t cbIV, size_t cbTag, bool bEncrypt )\n{\n    // Libsodium requires AES and CLMUL instructions for AES-GCM, available in\n    // Intel \"Westmere\" and up. 90.41% of Steam users have this as of the\n    // November 2019 survey.\n    // Libsodium recommends ChaCha20-Poly1305 in software if you've not got AES support\n    // in hardware.\n    AssertMsg( crypto_aead_aes256gcm_is_available() == 1, \"No hardware AES support on this CPU.\" );\n    AssertMsg( cbKey == crypto_aead_aes256gcm_KEYBYTES, \"AES key sizes other than 256 are unsupported.\" );\n    AssertMsg( cbIV == crypto_aead_aes256gcm_NPUBBYTES, \"Nonce size is unsupported\" );\n\n    if(m_ctx == nullptr)\n    {\n        m_ctx = sodium_malloc( sizeof(crypto_aead_aes256gcm_state) );\n    }\n\n    crypto_aead_aes256gcm_beforenm( static_cast<crypto_aead_aes256gcm_state*>( m_ctx ), static_cast<const unsigned char*>( pKey ) );\n\n    return true;\n}\n\nbool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n\n    return true;\n}\n\nbool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}\n\nvoid CCrypto::Init()\n{\n    // sodium_init is safe to call multiple times from multiple threads\n    // so no need to do anything clever here.\n    if(sodium_init() < 0)\n    {\n        AssertMsg( false, \"libsodium didn't init\" );\n    }\n}\n\nvoid CCrypto::GenerateRandomBlock( void *pubDest, int cubDest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateRandomBlock\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssertFatal( cubDest >= 0 );\n\n    randombytes_buf( pubDest, cubDest );\n}\n\nvoid CCrypto::GenerateSHA256Digest( const void *pData, size_t cbData, SHA256Digest_t *pOutputDigest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateSHA256Digest\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssert( pData );\n    Assert( pOutputDigest );\n\n    crypto_hash_sha256( *pOutputDigest, static_cast<const unsigned char*>(pData), cbData );\n}\n\nvoid CCrypto::GenerateHMAC256( const uint8 *pubData, uint32 cubData, const uint8 *pubKey, uint32 cubKey, SHA256Digest_t *pOutputDigest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateHMAC256\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssert( pubData );\n\tAssert( cubData > 0 );\n\tAssert( pubKey );\n\tAssert( cubKey > 0 );\n\tAssert( pOutputDigest );\n\n    Assert( sizeof(*pOutputDigest) == crypto_auth_hmacsha256_BYTES );\n    Assert( cubKey == crypto_auth_hmacsha256_KEYBYTES );\n\n    crypto_auth_hmacsha256( *pOutputDigest, pubData, cubData, pubKey );\n}\n\n#endif\n"], "fixing_code": ["#include \"crypto.h\"\n\n#include <tier0/vprof.h>\n#include <tier0/dbg.h>\n\n#include \"tier0/memdbgoff.h\"\n#include <sodium.h>\n#include \"tier0/memdbgon.h\"\n\n#ifdef STEAMNETWORKINGSOCKETS_CRYPTO_LIBSODIUM\n\nSymmetricCryptContextBase::SymmetricCryptContextBase()\n    : m_ctx(nullptr), m_cbIV(0), m_cbTag(0)\n{\n}\n\nvoid SymmetricCryptContextBase::Wipe()\n{\n    sodium_free(m_ctx);\n\n    m_ctx = nullptr;\n    m_cbIV = 0;\n    m_cbTag = 0;\n}\n\nbool AES_GCM_CipherContext::InitCipher( const void *pKey, size_t cbKey, size_t cbIV, size_t cbTag, bool bEncrypt )\n{\n    // Libsodium requires AES and CLMUL instructions for AES-GCM, available in\n    // Intel \"Westmere\" and up. 90.41% of Steam users have this as of the\n    // November 2019 survey.\n    // Libsodium recommends ChaCha20-Poly1305 in software if you've not got AES support\n    // in hardware.\n    AssertMsg( crypto_aead_aes256gcm_is_available() == 1, \"No hardware AES support on this CPU.\" );\n    AssertMsg( cbKey == crypto_aead_aes256gcm_KEYBYTES, \"AES key sizes other than 256 are unsupported.\" );\n    AssertMsg( cbIV == crypto_aead_aes256gcm_NPUBBYTES, \"Nonce size is unsupported\" );\n\n    if(m_ctx == nullptr)\n    {\n        m_ctx = sodium_malloc( sizeof(crypto_aead_aes256gcm_state) );\n    }\n\n    crypto_aead_aes256gcm_beforenm( static_cast<crypto_aead_aes256gcm_state*>( m_ctx ), static_cast<const unsigned char*>( pKey ) );\n\n    return true;\n}\n\nbool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n\n\t// Make sure caller's buffer is big enough to hold the result.\n\tif ( cbPlaintextData + crypto_aead_aes256gcm_ABYTES > *pcbEncryptedDataAndTag )\n\t{\n\t\t*pcbEncryptedDataAndTag = 0;\n\t\treturn false;\n\t}\n\n    unsigned long long cbEncryptedDataAndTag_longlong;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &cbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = cbEncryptedDataAndTag_longlong;\n\n    return true;\n}\n\nbool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n\t// Make sure caller's buffer is big enough to hold the result\n\tif ( cbEncryptedDataAndTag > *pcbPlaintextData + crypto_aead_aes256gcm_ABYTES )\n\t{\n\t\t*pcbPlaintextData = 0;\n\t\treturn false;\n\t}\n\n    unsigned long long cbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &cbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = cbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}\n\nvoid CCrypto::Init()\n{\n    // sodium_init is safe to call multiple times from multiple threads\n    // so no need to do anything clever here.\n    if(sodium_init() < 0)\n    {\n        AssertMsg( false, \"libsodium didn't init\" );\n    }\n}\n\nvoid CCrypto::GenerateRandomBlock( void *pubDest, int cubDest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateRandomBlock\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssertFatal( cubDest >= 0 );\n\n    randombytes_buf( pubDest, cubDest );\n}\n\nvoid CCrypto::GenerateSHA256Digest( const void *pData, size_t cbData, SHA256Digest_t *pOutputDigest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateSHA256Digest\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssert( pData );\n    Assert( pOutputDigest );\n\n    crypto_hash_sha256( *pOutputDigest, static_cast<const unsigned char*>(pData), cbData );\n}\n\nvoid CCrypto::GenerateHMAC256( const uint8 *pubData, uint32 cubData, const uint8 *pubKey, uint32 cubKey, SHA256Digest_t *pOutputDigest )\n{\n    VPROF_BUDGET( \"CCrypto::GenerateHMAC256\", VPROF_BUDGETGROUP_ENCRYPTION );\n\tAssert( pubData );\n\tAssert( cubData > 0 );\n\tAssert( pubKey );\n\tAssert( cubKey > 0 );\n\tAssert( pOutputDigest );\n\n    Assert( sizeof(*pOutputDigest) == crypto_auth_hmacsha256_BYTES );\n    Assert( cubKey == crypto_auth_hmacsha256_KEYBYTES );\n\n    crypto_auth_hmacsha256( *pOutputDigest, pubData, cubData, pubKey );\n}\n\n#endif\n"], "filenames": ["src/common/crypto_libsodium.cpp"], "buggy_code_start_loc": [53], "buggy_code_end_loc": [86], "fixing_code_start_loc": [52], "fixing_code_end_loc": [99], "type": "CWE-787", "message": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles long encrypted messages in function AES_GCM_DecryptContext::Decrypt() when compiled using libsodium, leading to a Stack-Based Buffer Overflow and resulting in a memory corruption and possibly even a remote code execution.", "other": {"cve": {"id": "CVE-2020-6018", "sourceIdentifier": "cve@checkpoint.com", "published": "2020-12-02T01:15:12.967", "lastModified": "2022-04-12T16:19:58.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles long encrypted messages in function AES_GCM_DecryptContext::Decrypt() when compiled using libsodium, leading to a Stack-Based Buffer Overflow and resulting in a memory corruption and possibly even a remote code execution."}, {"lang": "es", "value": "Game Networking Sockets de Valve anterior a versi\u00f3n v1.2.0 manejan incorrectamente los mensajes cifrados largos en la funci\u00f3n AES_GCM_DecryptContext::Decrypt() cuando se compilan usando libsodium, lo que conlleva a un Desbordamiento de B\u00fafer en la Regi\u00f3n Stack de la Memoria y resultando en una corrupci\u00f3n de la memoria y incluso posiblemente una ejecuci\u00f3n de c\u00f3digo remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:valvesoftware:game_networking_sockets:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "8CB71176-D705-4517-81B9-97A557278890"}]}]}], "references": [{"url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/bea84e2844b647532a9b7fbc3a6a8989d66e49e3", "source": "cve@checkpoint.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/2020/game-on-finding-vulnerabilities-in-valves-steam-sockets/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/bea84e2844b647532a9b7fbc3a6a8989d66e49e3"}}