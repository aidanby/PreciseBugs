{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/math64.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n// Max allocation size for user controls.\nstatic int max_user_ctl_alloc_size = 8 * 1024 * 1024;\nmodule_param_named(max_user_ctl_alloc_size, max_user_ctl_alloc_size, int, 0444);\nMODULE_PARM_DESC(max_user_ctl_alloc_size, \"Max allocation size for user controls\");\n\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic DECLARE_RWSEM(snd_ctl_layer_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\nstatic struct snd_ctl_layer_ops *snd_ctl_layer;\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint i, err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tfor (i = 0; i < SND_CTL_SUBDEV_ITEMS; i++)\n\t\tctl->preferred_subdevice[i] = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_fasync_free(ctl->fasync);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\n/**\n * snd_ctl_notify - Send notification to user-space for a control change\n * @card: the card to send notification\n * @mask: the event mask, SNDRV_CTL_EVENT_*\n * @id: the ctl element id to send notification\n *\n * This function adds an event record with the given id and mask, appends\n * to the list and wakes up the user-space for notification.  This can be\n * called in the atomic context.\n */\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tif (card->shutdown)\n\t\treturn;\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock(&ctl->read_lock);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock(&ctl->read_lock);\n\t\tsnd_kill_fasync(ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n}\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_notify_one - Send notification to user-space for a control change\n * @card: the card to send notification\n * @mask: the event mask, SNDRV_CTL_EVENT_*\n * @kctl: the pointer with the control instance\n * @ioff: the additional offset to the control index\n *\n * This function calls snd_ctl_notify() and does additional jobs\n * like LED state changes.\n */\nvoid snd_ctl_notify_one(struct snd_card *card, unsigned int mask,\n\t\t\tstruct snd_kcontrol *kctl, unsigned int ioff)\n{\n\tstruct snd_ctl_elem_id id = kctl->id;\n\tstruct snd_ctl_layer_ops *lops;\n\n\tid.index += ioff;\n\tid.numid += ioff;\n\tsnd_ctl_notify(card, mask, &id);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->lnotify(card, mask, kctl, ioff);\n\tup_read(&snd_ctl_layer_rwsem);\n}\nEXPORT_SYMBOL(snd_ctl_notify_one);\n\n/**\n * snd_ctl_new - create a new control instance with some elements\n * @kctl: the pointer to store new control instance\n * @count: the number of elements in this control\n * @access: the default access flags for elements in this control\n * @file: given when locking these elements\n *\n * Allocates a memory object for a new control instance. The instance has\n * elements as many as the given number (@count). Each element has given\n * access permissions (@access). Each element is locked when @file is given.\n *\n * Return: 0 on success, error code on failure\n */\nstatic int snd_ctl_new(struct snd_kcontrol **kctl, unsigned int count,\n\t\t       unsigned int access, struct snd_ctl_file *file)\n{\n\tunsigned int idx;\n\n\tif (count == 0 || count > MAX_CONTROL_COUNT)\n\t\treturn -EINVAL;\n\n\t*kctl = kzalloc(struct_size(*kctl, vd, count), GFP_KERNEL);\n\tif (!*kctl)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\t(*kctl)->vd[idx].access = access;\n\t\t(*kctl)->vd[idx].owner = file;\n\t}\n\t(*kctl)->count = count;\n\n\treturn 0;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given\n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int count;\n\tunsigned int access;\n\tint err;\n\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\n\tcount = ncontrol->count;\n\tif (count == 0)\n\t\tcount = 1;\n\n\taccess = ncontrol->access;\n\tif (access == 0)\n\t\taccess = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\taccess &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_INACTIVE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK |\n\t\t   SNDRV_CTL_ELEM_ACCESS_LED_MASK |\n\t\t   SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK);\n\n\terr = snd_ctl_new(&kctl, count, access, NULL);\n\tif (err < 0)\n\t\treturn NULL;\n\n\t/* The 'numid' member is decided when calling snd_ctl_add(). */\n\tkctl->id.iface = ncontrol->iface;\n\tkctl->id.device = ncontrol->device;\n\tkctl->id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrscpy(kctl->id.name, ncontrol->name, sizeof(kctl->id.name));\n\t\tif (strcmp(ncontrol->name, kctl->id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl->id.name);\n\t}\n\tkctl->id.index = ncontrol->index;\n\n\tkctl->info = ncontrol->info;\n\tkctl->get = ncontrol->get;\n\tkctl->put = ncontrol->put;\n\tkctl->tlv.p = ncontrol->tlv.p;\n\n\tkctl->private_value = ncontrol->private_value;\n\tkctl->private_data = private_data;\n\n\treturn kctl;\n}\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\t/* Make sure that the ids assigned to the control do not wrap around */\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* check whether the given id is contained in the given kctl */\nstatic bool elem_id_matches(const struct snd_kcontrol *kctl,\n\t\t\t    const struct snd_ctl_elem_id *id)\n{\n\treturn kctl->id.iface == id->iface &&\n\t\tkctl->id.device == id->device &&\n\t\tkctl->id.subdevice == id->subdevice &&\n\t\t!strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)) &&\n\t\tkctl->id.index <= id->index &&\n\t\tkctl->id.index + kctl->count > id->index;\n}\n\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n/* Compute a hash key for the corresponding ctl id\n * It's for the name lookup, hence the numid is excluded.\n * The hash key is bound in LONG_MAX to be used for Xarray key.\n */\n#define MULTIPLIER\t37\nstatic unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}\n\n/* add hash entries to numid and ctl xarray tables */\nstatic void add_hash_entries(struct snd_card *card,\n\t\t\t     struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id = kcontrol->id;\n\tint i;\n\n\txa_store_range(&card->ctl_numids, kcontrol->id.numid,\n\t\t       kcontrol->id.numid + kcontrol->count - 1,\n\t\t       kcontrol, GFP_KERNEL);\n\n\tfor (i = 0; i < kcontrol->count; i++) {\n\t\tid.index = kcontrol->id.index + i;\n\t\tif (xa_insert(&card->ctl_hash, get_ctl_id_hash(&id),\n\t\t\t      kcontrol, GFP_KERNEL)) {\n\t\t\t/* skip hash for this entry, noting we had collision */\n\t\t\tcard->ctl_hash_collision = true;\n\t\t\tdev_dbg(card->dev, \"ctl_hash collision %d:%s:%d\\n\",\n\t\t\t\tid.iface, id.name, id.index);\n\t\t}\n\t}\n}\n\n/* remove hash entries that have been added */\nstatic void remove_hash_entries(struct snd_card *card,\n\t\t\t\tstruct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id = kcontrol->id;\n\tstruct snd_kcontrol *matched;\n\tunsigned long h;\n\tint i;\n\n\tfor (i = 0; i < kcontrol->count; i++) {\n\t\txa_erase(&card->ctl_numids, id.numid);\n\t\th = get_ctl_id_hash(&id);\n\t\tmatched = xa_load(&card->ctl_hash, h);\n\t\tif (matched && (matched == kcontrol ||\n\t\t\t\telem_id_matches(matched, &id)))\n\t\t\txa_erase(&card->ctl_hash, h);\n\t\tid.index++;\n\t\tid.numid++;\n\t}\n}\n#else /* CONFIG_SND_CTL_FAST_LOOKUP */\nstatic inline void add_hash_entries(struct snd_card *card,\n\t\t\t\t    struct snd_kcontrol *kcontrol)\n{\n}\nstatic inline void remove_hash_entries(struct snd_card *card,\n\t\t\t\t       struct snd_kcontrol *kcontrol)\n{\n}\n#endif /* CONFIG_SND_CTL_FAST_LOOKUP */\n\nenum snd_ctl_add_mode {\n\tCTL_ADD_EXCLUSIVE, CTL_REPLACE, CTL_ADD_ON_REPLACE,\n};\n\n/* add/replace a new kcontrol object; call with card->controls_rwsem locked */\nstatic int __snd_ctl_add_replace(struct snd_card *card,\n\t\t\t\t struct snd_kcontrol *kcontrol,\n\t\t\t\t enum snd_ctl_add_mode mode)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint err;\n\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\treturn -EINVAL;\n\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (mode == CTL_REPLACE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (mode == CTL_ADD_EXCLUSIVE) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\tid.iface, id.device, id.subdevice, id.name,\n\t\t\t\tid.index);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\terr = snd_ctl_remove(card, old);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\n\tadd_hash_entries(card, kcontrol);\n\n\tfor (idx = 0; idx < kcontrol->count; idx++)\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_ADD, kcontrol, idx);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_add_replace(struct snd_card *card,\n\t\t\t       struct snd_kcontrol *kcontrol,\n\t\t\t       enum snd_ctl_add_mode mode)\n{\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\n\tdown_write(&card->controls_rwsem);\n\terr = __snd_ctl_add_replace(card, kcontrol, mode);\n\tup_write(&card->controls_rwsem);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\treturn snd_ctl_add_replace(card, kcontrol, CTL_ADD_EXCLUSIVE);\n}\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\treturn snd_ctl_add_replace(card, kcontrol,\n\t\t\t\t   add_on_replace ? CTL_ADD_ON_REPLACE : CTL_REPLACE);\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\nstatic int __snd_ctl_remove(struct snd_card *card,\n\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t    bool remove_hash)\n{\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\n\tif (remove_hash)\n\t\tremove_hash_entries(card, kcontrol);\n\n\tcard->controls_count -= kcontrol->count;\n\tfor (idx = 0; idx < kcontrol->count; idx++)\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_REMOVE, kcontrol, idx);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\treturn __snd_ctl_remove(card, kcontrol, true);\n}\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n * The given ID data is filled with full information.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tsnd_ctl_build_ioff(id, kctl, index_offset);\n\tdowngrade_write(&card->controls_rwsem);\n\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_INFO, kctl, index_offset);\n\tup_read(&card->controls_rwsem);\n\treturn 1;\n\n unlock:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tremove_hash_entries(card, kctl);\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tadd_hash_entries(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_rename - rename the control on the card\n * @card: the card instance\n * @kctl: the control to rename\n * @name: the new name\n *\n * Renames the specified control on the card to the new name.\n *\n * Make sure to take the control write lock - down_write(&card->controls_rwsem).\n */\nvoid snd_ctl_rename(struct snd_card *card, struct snd_kcontrol *kctl,\n\t\t    const char *name)\n{\n\tremove_hash_entries(card, kctl);\n\n\tif (strscpy(kctl->id.name, name, sizeof(kctl->id.name)) < 0)\n\t\tpr_warn(\"ALSA: Renamed control new name '%s' truncated to '%s'\\n\",\n\t\t\tname, kctl->id.name);\n\n\tadd_hash_entries(card, kctl);\n}\nEXPORT_SYMBOL(snd_ctl_rename);\n\n#ifndef CONFIG_SND_CTL_FAST_LOOKUP\nstatic struct snd_kcontrol *\nsnd_ctl_find_numid_slow(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n#endif /* !CONFIG_SND_CTL_FAST_LOOKUP */\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\treturn xa_load(&card->ctl_numids, numid);\n#else\n\treturn snd_ctl_find_numid_slow(card, numid);\n#endif\n}\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\tkctl = xa_load(&card->ctl_hash, get_ctl_id_hash(id));\n\tif (kctl && elem_id_matches(kctl, id))\n\t\treturn kctl;\n\tif (!card->ctl_hash_collision)\n\t\treturn NULL; /* we can rely on only hash table */\n#endif\n\t/* no matching in hash table - try all as the last resort */\n\tlist_for_each_entry(kctl, &card->controls, list)\n\t\tif (elem_id_matches(kctl, id))\n\t\t\treturn kctl;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrscpy(info->id, card->id, sizeof(info->id));\n\tstrscpy(info->driver, card->driver, sizeof(info->driver));\n\tstrscpy(info->name, card->shortname, sizeof(info->name));\n\tstrscpy(info->longname, card->longname, sizeof(info->longname));\n\tstrscpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrscpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list *list)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id id;\n\tunsigned int offset, space, jidx;\n\tint err = 0;\n\n\toffset = list->offset;\n\tspace = list->space;\n\n\tdown_read(&card->controls_rwsem);\n\tlist->count = card->controls_count;\n\tlist->used = 0;\n\tif (space > 0) {\n\t\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\t\tif (offset >= kctl->count) {\n\t\t\t\toffset -= kctl->count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (jidx = offset; jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(&id, kctl, jidx);\n\t\t\t\tif (copy_to_user(list->pids + list->used, &id,\n\t\t\t\t\t\t sizeof(id))) {\n\t\t\t\t\terr = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlist->used++;\n\t\t\t\tif (!--space)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t}\n out:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic int snd_ctl_elem_list_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_list __user *_list)\n{\n\tstruct snd_ctl_elem_list list;\n\tint err;\n\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\terr = snd_ctl_elem_list(card, &list);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* Check whether the given kctl info is valid */\nstatic int snd_ctl_check_elem_info(struct snd_card *card,\n\t\t\t\t   const struct snd_ctl_elem_info *info)\n{\n\tstatic const unsigned int max_value_counts[] = {\n\t\t[SNDRV_CTL_ELEM_TYPE_BOOLEAN]\t= 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_INTEGER]\t= 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_ENUMERATED] = 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_BYTES]\t= 512,\n\t\t[SNDRV_CTL_ELEM_TYPE_IEC958]\t= 1,\n\t\t[SNDRV_CTL_ELEM_TYPE_INTEGER64] = 64,\n\t};\n\n\tif (info->type < SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\n\t    info->type > SNDRV_CTL_ELEM_TYPE_INTEGER64) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: invalid type %d\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index, info->type);\n\t\treturn -EINVAL;\n\t}\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED &&\n\t    info->value.enumerated.items == 0) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: zero enum items\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index);\n\t\treturn -EINVAL;\n\t}\n\tif (info->count > max_value_counts[info->type]) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: invalid count %d\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index, info->count);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* The capacity of struct snd_ctl_elem_value.value.*/\nstatic const unsigned int value_sizes[] = {\n\t[SNDRV_CTL_ELEM_TYPE_BOOLEAN]\t= sizeof(long),\n\t[SNDRV_CTL_ELEM_TYPE_INTEGER]\t= sizeof(long),\n\t[SNDRV_CTL_ELEM_TYPE_ENUMERATED] = sizeof(unsigned int),\n\t[SNDRV_CTL_ELEM_TYPE_BYTES]\t= sizeof(unsigned char),\n\t[SNDRV_CTL_ELEM_TYPE_IEC958]\t= sizeof(struct snd_aes_iec958),\n\t[SNDRV_CTL_ELEM_TYPE_INTEGER64] = sizeof(long long),\n};\n\n/* fill the remaining snd_ctl_elem_value data with the given pattern */\nstatic void fill_remaining_elem_value(struct snd_ctl_elem_value *control,\n\t\t\t\t      struct snd_ctl_elem_info *info,\n\t\t\t\t      u32 pattern)\n{\n\tsize_t offset = value_sizes[info->type] * info->count;\n\n\toffset = DIV_ROUND_UP(offset, sizeof(u32));\n\tmemset32((u32 *)control->value.bytes.data + offset, pattern,\n\t\t sizeof(control->value) / sizeof(u32) - offset);\n}\n\n/* check whether the given integer ctl value is valid */\nstatic int sanity_check_int_value(struct snd_card *card,\n\t\t\t\t  const struct snd_ctl_elem_value *control,\n\t\t\t\t  const struct snd_ctl_elem_info *info,\n\t\t\t\t  int i, bool print_error)\n{\n\tlong long lval, lmin, lmax, lstep;\n\tu64 rem;\n\n\tswitch (info->type) {\n\tdefault:\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\t\tlval = control->value.integer.value[i];\n\t\tlmin = 0;\n\t\tlmax = 1;\n\t\tlstep = 0;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tlval = control->value.integer.value[i];\n\t\tlmin = info->value.integer.min;\n\t\tlmax = info->value.integer.max;\n\t\tlstep = info->value.integer.step;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tlval = control->value.integer64.value[i];\n\t\tlmin = info->value.integer64.min;\n\t\tlmax = info->value.integer64.max;\n\t\tlstep = info->value.integer64.step;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tlval = control->value.enumerated.item[i];\n\t\tlmin = 0;\n\t\tlmax = info->value.enumerated.items - 1;\n\t\tlstep = 0;\n\t\tbreak;\n\t}\n\n\tif (lval < lmin || lval > lmax) {\n\t\tif (print_error)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: value out of range %lld (%lld/%lld) at count %i\\n\",\n\t\t\t\tcontrol->id.iface, control->id.device,\n\t\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\t\tcontrol->id.index, lval, lmin, lmax, i);\n\t\treturn -EINVAL;\n\t}\n\tif (lstep) {\n\t\tdiv64_u64_rem(lval, lstep, &rem);\n\t\tif (rem) {\n\t\t\tif (print_error)\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"control %i:%i:%i:%s:%i: unaligned value %lld (step %lld) at count %i\\n\",\n\t\t\t\t\tcontrol->id.iface, control->id.device,\n\t\t\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\t\t\tcontrol->id.index, lval, lstep, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* check whether the all input values are valid for the given elem value */\nstatic int sanity_check_input_values(struct snd_card *card,\n\t\t\t\t     const struct snd_ctl_elem_value *control,\n\t\t\t\t     const struct snd_ctl_elem_info *info,\n\t\t\t\t     bool print_error)\n{\n\tint i, ret;\n\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tfor (i = 0; i < info->count; i++) {\n\t\t\tret = sanity_check_int_value(card, control, info, i,\n\t\t\t\t\t\t     print_error);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* perform sanity checks to the given snd_ctl_elem_value object */\nstatic int sanity_check_elem_value(struct snd_card *card,\n\t\t\t\t   const struct snd_ctl_elem_value *control,\n\t\t\t\t   const struct snd_ctl_elem_info *info,\n\t\t\t\t   u32 pattern)\n{\n\tsize_t offset;\n\tint ret;\n\tu32 *p;\n\n\tret = sanity_check_input_values(card, control, info, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* check whether the remaining area kept untouched */\n\toffset = value_sizes[info->type] * info->count;\n\toffset = DIV_ROUND_UP(offset, sizeof(u32));\n\tp = (u32 *)control->value.bytes.data + offset;\n\tfor (; offset < sizeof(control->value) / sizeof(u32); offset++, p++) {\n\t\tif (*p != pattern) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t*p = 0; /* clear the checked area */\n\t}\n\n\treturn ret;\n}\n\nstatic int __snd_ctl_elem_info(struct snd_card *card,\n\t\t\t       struct snd_kcontrol *kctl,\n\t\t\t       struct snd_ctl_elem_info *info,\n\t\t\t       struct snd_ctl_file *ctl)\n{\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = snd_power_ref_and_wait(card);\n\tif (!result)\n\t\tresult = kctl->info(kctl, info);\n\tsnd_power_unref(card);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t\tif (!snd_ctl_skip_validation(info) &&\n\t\t    snd_ctl_check_elem_info(card, info) < 0)\n\t\t\tresult = -EINVAL;\n\t}\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL)\n\t\tresult = -ENOENT;\n\telse\n\t\tresult = __snd_ctl_elem_info(card, kctl, info, ctl);\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tresult = snd_ctl_elem_info(ctl, &info);\n\tif (result < 0)\n\t\treturn result;\n\t/* drop internal access flags */\n\tinfo.access &= ~(SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK|\n\t\t\t SNDRV_CTL_ELEM_ACCESS_LED_MASK);\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t/* info is needed only for validation */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) || kctl->put == NULL ||\n\t    (file && vd->owner && vd->owner != file)) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -EPERM;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\tresult = snd_power_ref_and_wait(card);\n\t/* validate input values */\n\tif (IS_ENABLED(CONFIG_SND_CTL_INPUT_VALIDATION) && !result) {\n\t\tstruct snd_ctl_elem_info info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.id = control->id;\n\t\tresult = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\t\tif (!result)\n\t\t\tresult = sanity_check_input_values(card, control, &info,\n\t\t\t\t\t\t\t   false);\n\t}\n\tif (!result)\n\t\tresult = kctl->put(kctl, control);\n\tsnd_power_unref(card);\n\tif (result < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn result;\n\t}\n\n\tif (result > 0) {\n\t\tdowngrade_write(&card->controls_rwsem);\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_VALUE, kctl, index_offset);\n\t\tup_read(&card->controls_rwsem);\n\t} else {\n\t\tup_write(&card->controls_rwsem);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tresult = snd_ctl_elem_write(card, file, control);\n\tif (result < 0)\n\t\tgoto error;\n\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tstruct snd_card *card;\n\tchar *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\n// check whether the addition (in bytes) of user ctl element may overflow the limit.\nstatic bool check_user_elem_overflow(struct snd_card *card, ssize_t add)\n{\n\treturn (ssize_t)card->user_ctl_alloc_size + add > max_user_ctl_alloc_size;\n}\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int offset;\n\n\toffset = snd_ctl_get_ioff(kcontrol, &uinfo->id);\n\t*uinfo = ue->info;\n\tsnd_ctl_build_ioff(&uinfo->id, kcontrol, offset);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\tunsigned int offset;\n\n\titem = uinfo->value.enumerated.item;\n\n\toffset = snd_ctl_get_ioff(kcontrol, &uinfo->id);\n\t*uinfo = ue->info;\n\tsnd_ctl_build_ioff(&uinfo->id, kcontrol, offset);\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int size = ue->elem_data_size;\n\tchar *src = ue->elem_data +\n\t\t\tsnd_ctl_get_ioff(kcontrol, &ucontrol->id) * size;\n\n\tmemcpy(&ucontrol->value, src, size);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int size = ue->elem_data_size;\n\tchar *dst = ue->elem_data +\n\t\t\tsnd_ctl_get_ioff(kcontrol, &ucontrol->id) * size;\n\n\tchange = memcmp(&ucontrol->value, dst, size) != 0;\n\tif (change)\n\t\tmemcpy(dst, &ucontrol->value, size);\n\treturn change;\n}\n\n/* called in controls_rwsem write lock */\nstatic int replace_user_tlv(struct snd_kcontrol *kctl, unsigned int __user *buf,\n\t\t\t    unsigned int size)\n{\n\tstruct user_element *ue = kctl->private_data;\n\tunsigned int *container;\n\tunsigned int mask = 0;\n\tint i;\n\tint change;\n\n\tif (size > 1024 * 128)\t/* sane value */\n\t\treturn -EINVAL;\n\n\t// does the TLV size change cause overflow?\n\tif (check_user_elem_overflow(ue->card, (ssize_t)(size - ue->tlv_data_size)))\n\t\treturn -ENOMEM;\n\n\tcontainer = vmemdup_user(buf, size);\n\tif (IS_ERR(container))\n\t\treturn PTR_ERR(container);\n\n\tchange = ue->tlv_data_size != size;\n\tif (!change)\n\t\tchange = memcmp(ue->tlv_data, container, size) != 0;\n\tif (!change) {\n\t\tkvfree(container);\n\t\treturn 0;\n\t}\n\n\tif (ue->tlv_data == NULL) {\n\t\t/* Now TLV data is available. */\n\t\tfor (i = 0; i < kctl->count; ++i)\n\t\t\tkctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tmask = SNDRV_CTL_EVENT_MASK_INFO;\n\t} else {\n\t\tue->card->user_ctl_alloc_size -= ue->tlv_data_size;\n\t\tue->tlv_data_size = 0;\n\t\tkvfree(ue->tlv_data);\n\t}\n\n\tue->tlv_data = container;\n\tue->tlv_data_size = size;\n\t// decremented at private_free.\n\tue->card->user_ctl_alloc_size += size;\n\n\tmask |= SNDRV_CTL_EVENT_MASK_TLV;\n\tfor (i = 0; i < kctl->count; ++i)\n\t\tsnd_ctl_notify_one(ue->card, mask, kctl, i);\n\n\treturn change;\n}\n\nstatic int read_user_tlv(struct snd_kcontrol *kctl, unsigned int __user *buf,\n\t\t\t unsigned int size)\n{\n\tstruct user_element *ue = kctl->private_data;\n\n\tif (ue->tlv_data_size == 0 || ue->tlv_data == NULL)\n\t\treturn -ENXIO;\n\n\tif (size < ue->tlv_data_size)\n\t\treturn -ENOSPC;\n\n\tif (copy_to_user(buf, ue->tlv_data, ue->tlv_data_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kctl, int op_flag,\n\t\t\t\t unsigned int size, unsigned int __user *buf)\n{\n\tif (op_flag == SNDRV_CTL_TLV_OP_WRITE)\n\t\treturn replace_user_tlv(kctl, buf, size);\n\telse\n\t\treturn read_user_tlv(kctl, buf, size);\n}\n\n/* called in controls_rwsem write lock */\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tif (buf_len > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tif (check_user_elem_overflow(ue->card, buf_len))\n\t\treturn -ENOMEM;\n\tnames = vmemdup_user((const void __user *)user_ptrval, buf_len);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkvfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\t// increment the allocation size; decremented again at private_free.\n\tue->card->user_ctl_alloc_size += ue->info.value.enumerated.names_length;\n\n\treturn 0;\n}\n\nstatic size_t compute_user_elem_size(size_t size, unsigned int count)\n{\n\treturn sizeof(struct user_element) + size * count;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t// decrement the allocation size.\n\tue->card->user_ctl_alloc_size -= compute_user_elem_size(ue->elem_data_size, kcontrol->count);\n\tue->card->user_ctl_alloc_size -= ue->tlv_data_size;\n\tif (ue->priv_data)\n\t\tue->card->user_ctl_alloc_size -= ue->info.value.enumerated.names_length;\n\n\tkvfree(ue->tlv_data);\n\tkvfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int count;\n\tunsigned int access;\n\tlong private_size;\n\tsize_t alloc_size;\n\tstruct user_element *ue;\n\tunsigned int offset;\n\tint err;\n\n\tif (!*info->id.name)\n\t\treturn -EINVAL;\n\tif (strnlen(info->id.name, sizeof(info->id.name)) >= sizeof(info->id.name))\n\t\treturn -EINVAL;\n\n\t/* Delete a control to replace them if needed. */\n\tif (replace) {\n\t\tinfo->id.numid = 0;\n\t\terr = snd_ctl_remove_user_ctl(file, &info->id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Check the number of elements for this userspace control. */\n\tcount = info->owner;\n\tif (count == 0)\n\t\tcount = 1;\n\n\t/* Arrange access permissions if needed. */\n\taccess = info->access;\n\tif (access == 0)\n\t\taccess = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\taccess &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_INACTIVE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_WRITE);\n\n\t/* In initial state, nothing is available as TLV container. */\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\n\t/*\n\t * Check information and calculate the size of data specific to\n\t * this userspace control.\n\t */\n\t/* pass NULL to card for suppressing error messages */\n\terr = snd_ctl_check_elem_info(NULL, info);\n\tif (err < 0)\n\t\treturn err;\n\t/* user-space control doesn't allow zero-size data */\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\tprivate_size = value_sizes[info->type] * info->count;\n\talloc_size = compute_user_elem_size(private_size, count);\n\n\tdown_write(&card->controls_rwsem);\n\tif (check_user_elem_overflow(card, alloc_size)) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Keep memory object for this userspace control. After passing this\n\t * code block, the instance should be freed by snd_ctl_free_one().\n\t *\n\t * Note that these elements in this control are locked.\n\t */\n\terr = snd_ctl_new(&kctl, count, access, file);\n\tif (err < 0)\n\t\tgoto unlock;\n\tmemcpy(&kctl->id, &info->id, sizeof(kctl->id));\n\tue = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!ue) {\n\t\tkfree(kctl);\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tkctl->private_data = ue;\n\tkctl->private_free = snd_ctl_elem_user_free;\n\n\t// increment the allocated size; decremented again at private_free.\n\tcard->user_ctl_alloc_size += alloc_size;\n\n\t/* Set private data for this userspace control. */\n\tue->card = card;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tsnd_ctl_free_one(kctl);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Set callback functions. */\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl->info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl->info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl->get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl->put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n\t\tkctl->tlv.c = snd_ctl_elem_user_tlv;\n\n\t/* This function manage to free the instance on failure. */\n\terr = __snd_ctl_add_replace(card, kctl, CTL_ADD_EXCLUSIVE);\n\tif (err < 0) {\n\t\tsnd_ctl_free_one(kctl);\n\t\tgoto unlock;\n\t}\n\toffset = snd_ctl_get_ioff(kctl, &info->id);\n\tsnd_ctl_build_ioff(&info->id, kctl, offset);\n\t/*\n\t * Here we cannot fill any field for the number of elements added by\n\t * this operation because there're no specific fields. The usage of\n\t * 'owner' field for this purpose may cause any bugs to userspace\n\t * applications because the field originally means PID of a process\n\t * which locks the element.\n\t */\n unlock:\n\tup_write(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tint err;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\terr = snd_ctl_elem_add(file, &info, replace);\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(_info, &info, sizeof(info))) {\n\t\tsnd_ctl_remove_user_ctl(file, &info.id);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int call_tlv_handler(struct snd_ctl_file *file, int op_flag,\n\t\t\t    struct snd_kcontrol *kctl,\n\t\t\t    struct snd_ctl_elem_id *id,\n\t\t\t    unsigned int __user *buf, unsigned int size)\n{\n\tstatic const struct {\n\t\tint op;\n\t\tint perm;\n\t} pairs[] = {\n\t\t{SNDRV_CTL_TLV_OP_READ,  SNDRV_CTL_ELEM_ACCESS_TLV_READ},\n\t\t{SNDRV_CTL_TLV_OP_WRITE, SNDRV_CTL_ELEM_ACCESS_TLV_WRITE},\n\t\t{SNDRV_CTL_TLV_OP_CMD,   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND},\n\t};\n\tstruct snd_kcontrol_volatile *vd = &kctl->vd[snd_ctl_get_ioff(kctl, id)];\n\tint i, ret;\n\n\t/* Check support of the request for this element. */\n\tfor (i = 0; i < ARRAY_SIZE(pairs); ++i) {\n\t\tif (op_flag == pairs[i].op && (vd->access & pairs[i].perm))\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(pairs))\n\t\treturn -ENXIO;\n\n\tif (kctl->tlv.c == NULL)\n\t\treturn -ENXIO;\n\n\t/* Write and command operations are not allowed for locked element. */\n\tif (op_flag != SNDRV_CTL_TLV_OP_READ &&\n\t    vd->owner != NULL && vd->owner != file)\n\t\treturn -EPERM;\n\n\tret = snd_power_ref_and_wait(file->card);\n\tif (!ret)\n\t\tret = kctl->tlv.c(kctl, op_flag, size, buf);\n\tsnd_power_unref(file->card);\n\treturn ret;\n}\n\nstatic int read_tlv_buf(struct snd_kcontrol *kctl, struct snd_ctl_elem_id *id,\n\t\t\tunsigned int __user *buf, unsigned int size)\n{\n\tstruct snd_kcontrol_volatile *vd = &kctl->vd[snd_ctl_get_ioff(kctl, id)];\n\tunsigned int len;\n\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ))\n\t\treturn -ENXIO;\n\n\tif (kctl->tlv.p == NULL)\n\t\treturn -ENXIO;\n\n\tlen = sizeof(unsigned int) * 2 + kctl->tlv.p[1];\n\tif (size < len)\n\t\treturn -ENOMEM;\n\n\tif (copy_to_user(buf, kctl->tlv.p, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_tlv __user *buf,\n                             int op_flag)\n{\n\tstruct snd_ctl_tlv header;\n\tunsigned int __user *container;\n\tunsigned int container_size;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol_volatile *vd;\n\n\tif (copy_from_user(&header, buf, sizeof(header)))\n\t\treturn -EFAULT;\n\n\t/* In design of control core, numerical ID starts at 1. */\n\tif (header.numid == 0)\n\t\treturn -EINVAL;\n\n\t/* At least, container should include type and length fields.  */\n\tif (header.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tcontainer_size = header.length;\n\tcontainer = buf->tlv;\n\n\tkctl = snd_ctl_find_numid(file->card, header.numid);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\t/* Calculate index of the element in this set. */\n\tid = kctl->id;\n\tsnd_ctl_build_ioff(&id, kctl, header.numid - id.numid);\n\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\treturn call_tlv_handler(file, op_flag, kctl, &id, container,\n\t\t\t\t\tcontainer_size);\n\t} else {\n\t\tif (op_flag == SNDRV_CTL_TLV_OP_READ) {\n\t\t\treturn read_tlv_buf(kctl, &id, container,\n\t\t\t\t\t    container_size);\n\t\t}\n\t}\n\n\t/* Not supported. */\n\treturn -ENXIO;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\tdown_read(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_READ);\n\t\tup_read(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\tdown_write(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_WRITE);\n\t\tup_write(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\tdown_write(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_CMD);\n\t\tup_write(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_entry_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic __poll_t snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\t__poll_t mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\n/**\n * snd_ctl_register_ioctl - register the device-specific control-ioctls\n * @fcn: ioctl callback function\n *\n * called from each device manager like pcm.c, hwdep.c, etc.\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\n/**\n * snd_ctl_register_ioctl_compat - register the device-specific 32bit compat\n * control-ioctls\n * @fcn: ioctl callback function\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\n/**\n * snd_ctl_unregister_ioctl - de-register the device-specific control-ioctls\n * @fcn: ioctl callback function to unregister\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\n/**\n * snd_ctl_unregister_ioctl_compat - de-register the device-specific compat\n * 32bit control-ioctls\n * @fcn: ioctl callback function to unregister\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn snd_fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/* return the preferred subdevice number if already assigned;\n * otherwise return -1\n */\nint snd_ctl_get_preferred_subdevice(struct snd_card *card, int type)\n{\n\tstruct snd_ctl_file *kctl;\n\tint subdevice = -1;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_for_each_entry(kctl, &card->ctl_files, list) {\n\t\tif (kctl->pid == task_pid(current)) {\n\t\t\tsubdevice = kctl->preferred_subdevice[type];\n\t\t\tif (subdevice != -1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\treturn subdevice;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_get_preferred_subdevice);\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n * control layers (audio LED etc.)\n */\n\n/**\n * snd_ctl_request_layer - request to use the layer\n * @module_name: Name of the kernel module (NULL == build-in)\n *\n * Return: zero if successful, or an error code when the module cannot be loaded\n */\nint snd_ctl_request_layer(const char *module_name)\n{\n\tstruct snd_ctl_layer_ops *lops;\n\n\tif (module_name == NULL)\n\t\treturn 0;\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tif (strcmp(lops->module_name, module_name) == 0)\n\t\t\tbreak;\n\tup_read(&snd_ctl_layer_rwsem);\n\tif (lops)\n\t\treturn 0;\n\treturn request_module(module_name);\n}\nEXPORT_SYMBOL_GPL(snd_ctl_request_layer);\n\n/**\n * snd_ctl_register_layer - register new control layer\n * @lops: operation structure\n *\n * The new layer can track all control elements and do additional\n * operations on top (like audio LED handling).\n */\nvoid snd_ctl_register_layer(struct snd_ctl_layer_ops *lops)\n{\n\tstruct snd_card *card;\n\tint card_number;\n\n\tdown_write(&snd_ctl_layer_rwsem);\n\tlops->next = snd_ctl_layer;\n\tsnd_ctl_layer = lops;\n\tup_write(&snd_ctl_layer_rwsem);\n\tfor (card_number = 0; card_number < SNDRV_CARDS; card_number++) {\n\t\tcard = snd_card_ref(card_number);\n\t\tif (card) {\n\t\t\tdown_read(&card->controls_rwsem);\n\t\t\tlops->lregister(card);\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_card_unref(card);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_ctl_register_layer);\n\n/**\n * snd_ctl_disconnect_layer - disconnect control layer\n * @lops: operation structure\n *\n * It is expected that the information about tracked cards\n * is freed before this call (the disconnect callback is\n * not called here).\n */\nvoid snd_ctl_disconnect_layer(struct snd_ctl_layer_ops *lops)\n{\n\tstruct snd_ctl_layer_ops *lops2, *prev_lops2;\n\n\tdown_write(&snd_ctl_layer_rwsem);\n\tfor (lops2 = snd_ctl_layer, prev_lops2 = NULL; lops2; lops2 = lops2->next) {\n\t\tif (lops2 == lops) {\n\t\t\tif (!prev_lops2)\n\t\t\t\tsnd_ctl_layer = lops->next;\n\t\t\telse\n\t\t\t\tprev_lops2->next = lops->next;\n\t\t\tbreak;\n\t\t}\n\t\tprev_lops2 = lops2;\n\t}\n\tup_write(&snd_ctl_layer_rwsem);\n}\nEXPORT_SYMBOL_GPL(snd_ctl_disconnect_layer);\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_layer_ops *lops;\n\tint err;\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t  &snd_ctl_f_ops, card, &card->ctl_dev);\n\tif (err < 0)\n\t\treturn err;\n\tdown_read(&card->controls_rwsem);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->lregister(card);\n\tup_read(&snd_ctl_layer_rwsem);\n\tup_read(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_ctl_layer_ops *lops;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tsnd_kill_fasync(ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\n\tdown_read(&card->controls_rwsem);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->ldisconnect(card);\n\tup_read(&snd_ctl_layer_rwsem);\n\tup_read(&card->controls_rwsem);\n\n\treturn snd_unregister_device(&card->ctl_dev);\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\t__snd_ctl_remove(card, control, false);\n\t}\n\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\txa_destroy(&card->ctl_numids);\n\txa_destroy(&card->ctl_hash);\n#endif\n\tup_write(&card->controls_rwsem);\n\tput_device(&card->ctl_dev);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(card->number < 0 || card->number >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tsnd_device_initialize(&card->ctl_dev, card);\n\tdev_set_name(&card->ctl_dev, \"controlC%d\", card->number);\n\n\terr = snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n\tif (err < 0)\n\t\tput_device(&card->ctl_dev);\n\treturn err;\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\n\n/**\n * snd_ctl_boolean_mono_info - Helper function for a standard boolean info\n * callback with a mono channel\n * @kcontrol: the kcontrol instance\n * @uinfo: info to store\n *\n * This is a function that can be used as info callback for a standard\n * boolean control with a single mono channel.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\n/**\n * snd_ctl_boolean_stereo_info - Helper function for a standard boolean info\n * callback with stereo two channels\n * @kcontrol: the kcontrol instance\n * @uinfo: info to store\n *\n * This is a function that can be used as info callback for a standard\n * boolean control with stereo two channels.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (!items)\n\t\treturn 0;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tWARN(strlen(names[info->value.enumerated.item]) >= sizeof(info->value.enumerated.name),\n\t     \"ALSA: too long item name '%s'\\n\",\n\t     names[info->value.enumerated.item]);\n\tstrscpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/math64.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n// Max allocation size for user controls.\nstatic int max_user_ctl_alloc_size = 8 * 1024 * 1024;\nmodule_param_named(max_user_ctl_alloc_size, max_user_ctl_alloc_size, int, 0444);\nMODULE_PARM_DESC(max_user_ctl_alloc_size, \"Max allocation size for user controls\");\n\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic DECLARE_RWSEM(snd_ctl_layer_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\nstatic struct snd_ctl_layer_ops *snd_ctl_layer;\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint i, err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tfor (i = 0; i < SND_CTL_SUBDEV_ITEMS; i++)\n\t\tctl->preferred_subdevice[i] = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_fasync_free(ctl->fasync);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\n/**\n * snd_ctl_notify - Send notification to user-space for a control change\n * @card: the card to send notification\n * @mask: the event mask, SNDRV_CTL_EVENT_*\n * @id: the ctl element id to send notification\n *\n * This function adds an event record with the given id and mask, appends\n * to the list and wakes up the user-space for notification.  This can be\n * called in the atomic context.\n */\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tif (card->shutdown)\n\t\treturn;\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock(&ctl->read_lock);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock(&ctl->read_lock);\n\t\tsnd_kill_fasync(ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n}\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_notify_one - Send notification to user-space for a control change\n * @card: the card to send notification\n * @mask: the event mask, SNDRV_CTL_EVENT_*\n * @kctl: the pointer with the control instance\n * @ioff: the additional offset to the control index\n *\n * This function calls snd_ctl_notify() and does additional jobs\n * like LED state changes.\n */\nvoid snd_ctl_notify_one(struct snd_card *card, unsigned int mask,\n\t\t\tstruct snd_kcontrol *kctl, unsigned int ioff)\n{\n\tstruct snd_ctl_elem_id id = kctl->id;\n\tstruct snd_ctl_layer_ops *lops;\n\n\tid.index += ioff;\n\tid.numid += ioff;\n\tsnd_ctl_notify(card, mask, &id);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->lnotify(card, mask, kctl, ioff);\n\tup_read(&snd_ctl_layer_rwsem);\n}\nEXPORT_SYMBOL(snd_ctl_notify_one);\n\n/**\n * snd_ctl_new - create a new control instance with some elements\n * @kctl: the pointer to store new control instance\n * @count: the number of elements in this control\n * @access: the default access flags for elements in this control\n * @file: given when locking these elements\n *\n * Allocates a memory object for a new control instance. The instance has\n * elements as many as the given number (@count). Each element has given\n * access permissions (@access). Each element is locked when @file is given.\n *\n * Return: 0 on success, error code on failure\n */\nstatic int snd_ctl_new(struct snd_kcontrol **kctl, unsigned int count,\n\t\t       unsigned int access, struct snd_ctl_file *file)\n{\n\tunsigned int idx;\n\n\tif (count == 0 || count > MAX_CONTROL_COUNT)\n\t\treturn -EINVAL;\n\n\t*kctl = kzalloc(struct_size(*kctl, vd, count), GFP_KERNEL);\n\tif (!*kctl)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\t(*kctl)->vd[idx].access = access;\n\t\t(*kctl)->vd[idx].owner = file;\n\t}\n\t(*kctl)->count = count;\n\n\treturn 0;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given\n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int count;\n\tunsigned int access;\n\tint err;\n\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\n\tcount = ncontrol->count;\n\tif (count == 0)\n\t\tcount = 1;\n\n\taccess = ncontrol->access;\n\tif (access == 0)\n\t\taccess = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\taccess &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_INACTIVE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK |\n\t\t   SNDRV_CTL_ELEM_ACCESS_LED_MASK |\n\t\t   SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK);\n\n\terr = snd_ctl_new(&kctl, count, access, NULL);\n\tif (err < 0)\n\t\treturn NULL;\n\n\t/* The 'numid' member is decided when calling snd_ctl_add(). */\n\tkctl->id.iface = ncontrol->iface;\n\tkctl->id.device = ncontrol->device;\n\tkctl->id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrscpy(kctl->id.name, ncontrol->name, sizeof(kctl->id.name));\n\t\tif (strcmp(ncontrol->name, kctl->id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl->id.name);\n\t}\n\tkctl->id.index = ncontrol->index;\n\n\tkctl->info = ncontrol->info;\n\tkctl->get = ncontrol->get;\n\tkctl->put = ncontrol->put;\n\tkctl->tlv.p = ncontrol->tlv.p;\n\n\tkctl->private_value = ncontrol->private_value;\n\tkctl->private_data = private_data;\n\n\treturn kctl;\n}\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\t/* Make sure that the ids assigned to the control do not wrap around */\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* check whether the given id is contained in the given kctl */\nstatic bool elem_id_matches(const struct snd_kcontrol *kctl,\n\t\t\t    const struct snd_ctl_elem_id *id)\n{\n\treturn kctl->id.iface == id->iface &&\n\t\tkctl->id.device == id->device &&\n\t\tkctl->id.subdevice == id->subdevice &&\n\t\t!strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)) &&\n\t\tkctl->id.index <= id->index &&\n\t\tkctl->id.index + kctl->count > id->index;\n}\n\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n/* Compute a hash key for the corresponding ctl id\n * It's for the name lookup, hence the numid is excluded.\n * The hash key is bound in LONG_MAX to be used for Xarray key.\n */\n#define MULTIPLIER\t37\nstatic unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}\n\n/* add hash entries to numid and ctl xarray tables */\nstatic void add_hash_entries(struct snd_card *card,\n\t\t\t     struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id = kcontrol->id;\n\tint i;\n\n\txa_store_range(&card->ctl_numids, kcontrol->id.numid,\n\t\t       kcontrol->id.numid + kcontrol->count - 1,\n\t\t       kcontrol, GFP_KERNEL);\n\n\tfor (i = 0; i < kcontrol->count; i++) {\n\t\tid.index = kcontrol->id.index + i;\n\t\tif (xa_insert(&card->ctl_hash, get_ctl_id_hash(&id),\n\t\t\t      kcontrol, GFP_KERNEL)) {\n\t\t\t/* skip hash for this entry, noting we had collision */\n\t\t\tcard->ctl_hash_collision = true;\n\t\t\tdev_dbg(card->dev, \"ctl_hash collision %d:%s:%d\\n\",\n\t\t\t\tid.iface, id.name, id.index);\n\t\t}\n\t}\n}\n\n/* remove hash entries that have been added */\nstatic void remove_hash_entries(struct snd_card *card,\n\t\t\t\tstruct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id = kcontrol->id;\n\tstruct snd_kcontrol *matched;\n\tunsigned long h;\n\tint i;\n\n\tfor (i = 0; i < kcontrol->count; i++) {\n\t\txa_erase(&card->ctl_numids, id.numid);\n\t\th = get_ctl_id_hash(&id);\n\t\tmatched = xa_load(&card->ctl_hash, h);\n\t\tif (matched && (matched == kcontrol ||\n\t\t\t\telem_id_matches(matched, &id)))\n\t\t\txa_erase(&card->ctl_hash, h);\n\t\tid.index++;\n\t\tid.numid++;\n\t}\n}\n#else /* CONFIG_SND_CTL_FAST_LOOKUP */\nstatic inline void add_hash_entries(struct snd_card *card,\n\t\t\t\t    struct snd_kcontrol *kcontrol)\n{\n}\nstatic inline void remove_hash_entries(struct snd_card *card,\n\t\t\t\t       struct snd_kcontrol *kcontrol)\n{\n}\n#endif /* CONFIG_SND_CTL_FAST_LOOKUP */\n\nenum snd_ctl_add_mode {\n\tCTL_ADD_EXCLUSIVE, CTL_REPLACE, CTL_ADD_ON_REPLACE,\n};\n\n/* add/replace a new kcontrol object; call with card->controls_rwsem locked */\nstatic int __snd_ctl_add_replace(struct snd_card *card,\n\t\t\t\t struct snd_kcontrol *kcontrol,\n\t\t\t\t enum snd_ctl_add_mode mode)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint err;\n\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\treturn -EINVAL;\n\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (mode == CTL_REPLACE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (mode == CTL_ADD_EXCLUSIVE) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\tid.iface, id.device, id.subdevice, id.name,\n\t\t\t\tid.index);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\terr = snd_ctl_remove(card, old);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\n\tadd_hash_entries(card, kcontrol);\n\n\tfor (idx = 0; idx < kcontrol->count; idx++)\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_ADD, kcontrol, idx);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_add_replace(struct snd_card *card,\n\t\t\t       struct snd_kcontrol *kcontrol,\n\t\t\t       enum snd_ctl_add_mode mode)\n{\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\n\tdown_write(&card->controls_rwsem);\n\terr = __snd_ctl_add_replace(card, kcontrol, mode);\n\tup_write(&card->controls_rwsem);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\treturn snd_ctl_add_replace(card, kcontrol, CTL_ADD_EXCLUSIVE);\n}\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\treturn snd_ctl_add_replace(card, kcontrol,\n\t\t\t\t   add_on_replace ? CTL_ADD_ON_REPLACE : CTL_REPLACE);\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\nstatic int __snd_ctl_remove(struct snd_card *card,\n\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t    bool remove_hash)\n{\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\n\tif (remove_hash)\n\t\tremove_hash_entries(card, kcontrol);\n\n\tcard->controls_count -= kcontrol->count;\n\tfor (idx = 0; idx < kcontrol->count; idx++)\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_REMOVE, kcontrol, idx);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\treturn __snd_ctl_remove(card, kcontrol, true);\n}\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n * The given ID data is filled with full information.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tsnd_ctl_build_ioff(id, kctl, index_offset);\n\tdowngrade_write(&card->controls_rwsem);\n\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_INFO, kctl, index_offset);\n\tup_read(&card->controls_rwsem);\n\treturn 1;\n\n unlock:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tremove_hash_entries(card, kctl);\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tadd_hash_entries(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_rename - rename the control on the card\n * @card: the card instance\n * @kctl: the control to rename\n * @name: the new name\n *\n * Renames the specified control on the card to the new name.\n *\n * Make sure to take the control write lock - down_write(&card->controls_rwsem).\n */\nvoid snd_ctl_rename(struct snd_card *card, struct snd_kcontrol *kctl,\n\t\t    const char *name)\n{\n\tremove_hash_entries(card, kctl);\n\n\tif (strscpy(kctl->id.name, name, sizeof(kctl->id.name)) < 0)\n\t\tpr_warn(\"ALSA: Renamed control new name '%s' truncated to '%s'\\n\",\n\t\t\tname, kctl->id.name);\n\n\tadd_hash_entries(card, kctl);\n}\nEXPORT_SYMBOL(snd_ctl_rename);\n\n#ifndef CONFIG_SND_CTL_FAST_LOOKUP\nstatic struct snd_kcontrol *\nsnd_ctl_find_numid_slow(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n#endif /* !CONFIG_SND_CTL_FAST_LOOKUP */\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\treturn xa_load(&card->ctl_numids, numid);\n#else\n\treturn snd_ctl_find_numid_slow(card, numid);\n#endif\n}\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\tkctl = xa_load(&card->ctl_hash, get_ctl_id_hash(id));\n\tif (kctl && elem_id_matches(kctl, id))\n\t\treturn kctl;\n\tif (!card->ctl_hash_collision)\n\t\treturn NULL; /* we can rely on only hash table */\n#endif\n\t/* no matching in hash table - try all as the last resort */\n\tlist_for_each_entry(kctl, &card->controls, list)\n\t\tif (elem_id_matches(kctl, id))\n\t\t\treturn kctl;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrscpy(info->id, card->id, sizeof(info->id));\n\tstrscpy(info->driver, card->driver, sizeof(info->driver));\n\tstrscpy(info->name, card->shortname, sizeof(info->name));\n\tstrscpy(info->longname, card->longname, sizeof(info->longname));\n\tstrscpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrscpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list *list)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id id;\n\tunsigned int offset, space, jidx;\n\tint err = 0;\n\n\toffset = list->offset;\n\tspace = list->space;\n\n\tdown_read(&card->controls_rwsem);\n\tlist->count = card->controls_count;\n\tlist->used = 0;\n\tif (space > 0) {\n\t\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\t\tif (offset >= kctl->count) {\n\t\t\t\toffset -= kctl->count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (jidx = offset; jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(&id, kctl, jidx);\n\t\t\t\tif (copy_to_user(list->pids + list->used, &id,\n\t\t\t\t\t\t sizeof(id))) {\n\t\t\t\t\terr = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlist->used++;\n\t\t\t\tif (!--space)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t}\n out:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic int snd_ctl_elem_list_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_list __user *_list)\n{\n\tstruct snd_ctl_elem_list list;\n\tint err;\n\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\terr = snd_ctl_elem_list(card, &list);\n\tif (err)\n\t\treturn err;\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* Check whether the given kctl info is valid */\nstatic int snd_ctl_check_elem_info(struct snd_card *card,\n\t\t\t\t   const struct snd_ctl_elem_info *info)\n{\n\tstatic const unsigned int max_value_counts[] = {\n\t\t[SNDRV_CTL_ELEM_TYPE_BOOLEAN]\t= 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_INTEGER]\t= 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_ENUMERATED] = 128,\n\t\t[SNDRV_CTL_ELEM_TYPE_BYTES]\t= 512,\n\t\t[SNDRV_CTL_ELEM_TYPE_IEC958]\t= 1,\n\t\t[SNDRV_CTL_ELEM_TYPE_INTEGER64] = 64,\n\t};\n\n\tif (info->type < SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\n\t    info->type > SNDRV_CTL_ELEM_TYPE_INTEGER64) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: invalid type %d\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index, info->type);\n\t\treturn -EINVAL;\n\t}\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED &&\n\t    info->value.enumerated.items == 0) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: zero enum items\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index);\n\t\treturn -EINVAL;\n\t}\n\tif (info->count > max_value_counts[info->type]) {\n\t\tif (card)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: invalid count %d\\n\",\n\t\t\t\tinfo->id.iface, info->id.device,\n\t\t\t\tinfo->id.subdevice, info->id.name,\n\t\t\t\tinfo->id.index, info->count);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* The capacity of struct snd_ctl_elem_value.value.*/\nstatic const unsigned int value_sizes[] = {\n\t[SNDRV_CTL_ELEM_TYPE_BOOLEAN]\t= sizeof(long),\n\t[SNDRV_CTL_ELEM_TYPE_INTEGER]\t= sizeof(long),\n\t[SNDRV_CTL_ELEM_TYPE_ENUMERATED] = sizeof(unsigned int),\n\t[SNDRV_CTL_ELEM_TYPE_BYTES]\t= sizeof(unsigned char),\n\t[SNDRV_CTL_ELEM_TYPE_IEC958]\t= sizeof(struct snd_aes_iec958),\n\t[SNDRV_CTL_ELEM_TYPE_INTEGER64] = sizeof(long long),\n};\n\n/* fill the remaining snd_ctl_elem_value data with the given pattern */\nstatic void fill_remaining_elem_value(struct snd_ctl_elem_value *control,\n\t\t\t\t      struct snd_ctl_elem_info *info,\n\t\t\t\t      u32 pattern)\n{\n\tsize_t offset = value_sizes[info->type] * info->count;\n\n\toffset = DIV_ROUND_UP(offset, sizeof(u32));\n\tmemset32((u32 *)control->value.bytes.data + offset, pattern,\n\t\t sizeof(control->value) / sizeof(u32) - offset);\n}\n\n/* check whether the given integer ctl value is valid */\nstatic int sanity_check_int_value(struct snd_card *card,\n\t\t\t\t  const struct snd_ctl_elem_value *control,\n\t\t\t\t  const struct snd_ctl_elem_info *info,\n\t\t\t\t  int i, bool print_error)\n{\n\tlong long lval, lmin, lmax, lstep;\n\tu64 rem;\n\n\tswitch (info->type) {\n\tdefault:\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\t\tlval = control->value.integer.value[i];\n\t\tlmin = 0;\n\t\tlmax = 1;\n\t\tlstep = 0;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tlval = control->value.integer.value[i];\n\t\tlmin = info->value.integer.min;\n\t\tlmax = info->value.integer.max;\n\t\tlstep = info->value.integer.step;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tlval = control->value.integer64.value[i];\n\t\tlmin = info->value.integer64.min;\n\t\tlmax = info->value.integer64.max;\n\t\tlstep = info->value.integer64.step;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tlval = control->value.enumerated.item[i];\n\t\tlmin = 0;\n\t\tlmax = info->value.enumerated.items - 1;\n\t\tlstep = 0;\n\t\tbreak;\n\t}\n\n\tif (lval < lmin || lval > lmax) {\n\t\tif (print_error)\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"control %i:%i:%i:%s:%i: value out of range %lld (%lld/%lld) at count %i\\n\",\n\t\t\t\tcontrol->id.iface, control->id.device,\n\t\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\t\tcontrol->id.index, lval, lmin, lmax, i);\n\t\treturn -EINVAL;\n\t}\n\tif (lstep) {\n\t\tdiv64_u64_rem(lval, lstep, &rem);\n\t\tif (rem) {\n\t\t\tif (print_error)\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"control %i:%i:%i:%s:%i: unaligned value %lld (step %lld) at count %i\\n\",\n\t\t\t\t\tcontrol->id.iface, control->id.device,\n\t\t\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\t\t\tcontrol->id.index, lval, lstep, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* check whether the all input values are valid for the given elem value */\nstatic int sanity_check_input_values(struct snd_card *card,\n\t\t\t\t     const struct snd_ctl_elem_value *control,\n\t\t\t\t     const struct snd_ctl_elem_info *info,\n\t\t\t\t     bool print_error)\n{\n\tint i, ret;\n\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tfor (i = 0; i < info->count; i++) {\n\t\t\tret = sanity_check_int_value(card, control, info, i,\n\t\t\t\t\t\t     print_error);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* perform sanity checks to the given snd_ctl_elem_value object */\nstatic int sanity_check_elem_value(struct snd_card *card,\n\t\t\t\t   const struct snd_ctl_elem_value *control,\n\t\t\t\t   const struct snd_ctl_elem_info *info,\n\t\t\t\t   u32 pattern)\n{\n\tsize_t offset;\n\tint ret;\n\tu32 *p;\n\n\tret = sanity_check_input_values(card, control, info, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* check whether the remaining area kept untouched */\n\toffset = value_sizes[info->type] * info->count;\n\toffset = DIV_ROUND_UP(offset, sizeof(u32));\n\tp = (u32 *)control->value.bytes.data + offset;\n\tfor (; offset < sizeof(control->value) / sizeof(u32); offset++, p++) {\n\t\tif (*p != pattern) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t*p = 0; /* clear the checked area */\n\t}\n\n\treturn ret;\n}\n\nstatic int __snd_ctl_elem_info(struct snd_card *card,\n\t\t\t       struct snd_kcontrol *kctl,\n\t\t\t       struct snd_ctl_elem_info *info,\n\t\t\t       struct snd_ctl_file *ctl)\n{\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = snd_power_ref_and_wait(card);\n\tif (!result)\n\t\tresult = kctl->info(kctl, info);\n\tsnd_power_unref(card);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t\tif (!snd_ctl_skip_validation(info) &&\n\t\t    snd_ctl_check_elem_info(card, info) < 0)\n\t\t\tresult = -EINVAL;\n\t}\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL)\n\t\tresult = -ENOENT;\n\telse\n\t\tresult = __snd_ctl_elem_info(card, kctl, info, ctl);\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tresult = snd_ctl_elem_info(ctl, &info);\n\tif (result < 0)\n\t\treturn result;\n\t/* drop internal access flags */\n\tinfo.access &= ~(SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK|\n\t\t\t SNDRV_CTL_ELEM_ACCESS_LED_MASK);\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t/* info is needed only for validation */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\nunlock:\n\tup_read(&card->controls_rwsem);\n\treturn ret;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tresult = snd_ctl_elem_read(card, control);\n\tif (result < 0)\n\t\tgoto error;\n\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) || kctl->put == NULL ||\n\t    (file && vd->owner && vd->owner != file)) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -EPERM;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\tresult = snd_power_ref_and_wait(card);\n\t/* validate input values */\n\tif (IS_ENABLED(CONFIG_SND_CTL_INPUT_VALIDATION) && !result) {\n\t\tstruct snd_ctl_elem_info info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.id = control->id;\n\t\tresult = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\t\tif (!result)\n\t\t\tresult = sanity_check_input_values(card, control, &info,\n\t\t\t\t\t\t\t   false);\n\t}\n\tif (!result)\n\t\tresult = kctl->put(kctl, control);\n\tsnd_power_unref(card);\n\tif (result < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn result;\n\t}\n\n\tif (result > 0) {\n\t\tdowngrade_write(&card->controls_rwsem);\n\t\tsnd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_VALUE, kctl, index_offset);\n\t\tup_read(&card->controls_rwsem);\n\t} else {\n\t\tup_write(&card->controls_rwsem);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tresult = snd_ctl_elem_write(card, file, control);\n\tif (result < 0)\n\t\tgoto error;\n\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tstruct snd_card *card;\n\tchar *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\n// check whether the addition (in bytes) of user ctl element may overflow the limit.\nstatic bool check_user_elem_overflow(struct snd_card *card, ssize_t add)\n{\n\treturn (ssize_t)card->user_ctl_alloc_size + add > max_user_ctl_alloc_size;\n}\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int offset;\n\n\toffset = snd_ctl_get_ioff(kcontrol, &uinfo->id);\n\t*uinfo = ue->info;\n\tsnd_ctl_build_ioff(&uinfo->id, kcontrol, offset);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\tunsigned int offset;\n\n\titem = uinfo->value.enumerated.item;\n\n\toffset = snd_ctl_get_ioff(kcontrol, &uinfo->id);\n\t*uinfo = ue->info;\n\tsnd_ctl_build_ioff(&uinfo->id, kcontrol, offset);\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int size = ue->elem_data_size;\n\tchar *src = ue->elem_data +\n\t\t\tsnd_ctl_get_ioff(kcontrol, &ucontrol->id) * size;\n\n\tmemcpy(&ucontrol->value, src, size);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tunsigned int size = ue->elem_data_size;\n\tchar *dst = ue->elem_data +\n\t\t\tsnd_ctl_get_ioff(kcontrol, &ucontrol->id) * size;\n\n\tchange = memcmp(&ucontrol->value, dst, size) != 0;\n\tif (change)\n\t\tmemcpy(dst, &ucontrol->value, size);\n\treturn change;\n}\n\n/* called in controls_rwsem write lock */\nstatic int replace_user_tlv(struct snd_kcontrol *kctl, unsigned int __user *buf,\n\t\t\t    unsigned int size)\n{\n\tstruct user_element *ue = kctl->private_data;\n\tunsigned int *container;\n\tunsigned int mask = 0;\n\tint i;\n\tint change;\n\n\tif (size > 1024 * 128)\t/* sane value */\n\t\treturn -EINVAL;\n\n\t// does the TLV size change cause overflow?\n\tif (check_user_elem_overflow(ue->card, (ssize_t)(size - ue->tlv_data_size)))\n\t\treturn -ENOMEM;\n\n\tcontainer = vmemdup_user(buf, size);\n\tif (IS_ERR(container))\n\t\treturn PTR_ERR(container);\n\n\tchange = ue->tlv_data_size != size;\n\tif (!change)\n\t\tchange = memcmp(ue->tlv_data, container, size) != 0;\n\tif (!change) {\n\t\tkvfree(container);\n\t\treturn 0;\n\t}\n\n\tif (ue->tlv_data == NULL) {\n\t\t/* Now TLV data is available. */\n\t\tfor (i = 0; i < kctl->count; ++i)\n\t\t\tkctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tmask = SNDRV_CTL_EVENT_MASK_INFO;\n\t} else {\n\t\tue->card->user_ctl_alloc_size -= ue->tlv_data_size;\n\t\tue->tlv_data_size = 0;\n\t\tkvfree(ue->tlv_data);\n\t}\n\n\tue->tlv_data = container;\n\tue->tlv_data_size = size;\n\t// decremented at private_free.\n\tue->card->user_ctl_alloc_size += size;\n\n\tmask |= SNDRV_CTL_EVENT_MASK_TLV;\n\tfor (i = 0; i < kctl->count; ++i)\n\t\tsnd_ctl_notify_one(ue->card, mask, kctl, i);\n\n\treturn change;\n}\n\nstatic int read_user_tlv(struct snd_kcontrol *kctl, unsigned int __user *buf,\n\t\t\t unsigned int size)\n{\n\tstruct user_element *ue = kctl->private_data;\n\n\tif (ue->tlv_data_size == 0 || ue->tlv_data == NULL)\n\t\treturn -ENXIO;\n\n\tif (size < ue->tlv_data_size)\n\t\treturn -ENOSPC;\n\n\tif (copy_to_user(buf, ue->tlv_data, ue->tlv_data_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kctl, int op_flag,\n\t\t\t\t unsigned int size, unsigned int __user *buf)\n{\n\tif (op_flag == SNDRV_CTL_TLV_OP_WRITE)\n\t\treturn replace_user_tlv(kctl, buf, size);\n\telse\n\t\treturn read_user_tlv(kctl, buf, size);\n}\n\n/* called in controls_rwsem write lock */\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tif (buf_len > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tif (check_user_elem_overflow(ue->card, buf_len))\n\t\treturn -ENOMEM;\n\tnames = vmemdup_user((const void __user *)user_ptrval, buf_len);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkvfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\t// increment the allocation size; decremented again at private_free.\n\tue->card->user_ctl_alloc_size += ue->info.value.enumerated.names_length;\n\n\treturn 0;\n}\n\nstatic size_t compute_user_elem_size(size_t size, unsigned int count)\n{\n\treturn sizeof(struct user_element) + size * count;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t// decrement the allocation size.\n\tue->card->user_ctl_alloc_size -= compute_user_elem_size(ue->elem_data_size, kcontrol->count);\n\tue->card->user_ctl_alloc_size -= ue->tlv_data_size;\n\tif (ue->priv_data)\n\t\tue->card->user_ctl_alloc_size -= ue->info.value.enumerated.names_length;\n\n\tkvfree(ue->tlv_data);\n\tkvfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int count;\n\tunsigned int access;\n\tlong private_size;\n\tsize_t alloc_size;\n\tstruct user_element *ue;\n\tunsigned int offset;\n\tint err;\n\n\tif (!*info->id.name)\n\t\treturn -EINVAL;\n\tif (strnlen(info->id.name, sizeof(info->id.name)) >= sizeof(info->id.name))\n\t\treturn -EINVAL;\n\n\t/* Delete a control to replace them if needed. */\n\tif (replace) {\n\t\tinfo->id.numid = 0;\n\t\terr = snd_ctl_remove_user_ctl(file, &info->id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Check the number of elements for this userspace control. */\n\tcount = info->owner;\n\tif (count == 0)\n\t\tcount = 1;\n\n\t/* Arrange access permissions if needed. */\n\taccess = info->access;\n\tif (access == 0)\n\t\taccess = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\taccess &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_INACTIVE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_WRITE);\n\n\t/* In initial state, nothing is available as TLV container. */\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\n\t/*\n\t * Check information and calculate the size of data specific to\n\t * this userspace control.\n\t */\n\t/* pass NULL to card for suppressing error messages */\n\terr = snd_ctl_check_elem_info(NULL, info);\n\tif (err < 0)\n\t\treturn err;\n\t/* user-space control doesn't allow zero-size data */\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\tprivate_size = value_sizes[info->type] * info->count;\n\talloc_size = compute_user_elem_size(private_size, count);\n\n\tdown_write(&card->controls_rwsem);\n\tif (check_user_elem_overflow(card, alloc_size)) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Keep memory object for this userspace control. After passing this\n\t * code block, the instance should be freed by snd_ctl_free_one().\n\t *\n\t * Note that these elements in this control are locked.\n\t */\n\terr = snd_ctl_new(&kctl, count, access, file);\n\tif (err < 0)\n\t\tgoto unlock;\n\tmemcpy(&kctl->id, &info->id, sizeof(kctl->id));\n\tue = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!ue) {\n\t\tkfree(kctl);\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tkctl->private_data = ue;\n\tkctl->private_free = snd_ctl_elem_user_free;\n\n\t// increment the allocated size; decremented again at private_free.\n\tcard->user_ctl_alloc_size += alloc_size;\n\n\t/* Set private data for this userspace control. */\n\tue->card = card;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tsnd_ctl_free_one(kctl);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Set callback functions. */\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl->info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl->info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl->get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl->put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n\t\tkctl->tlv.c = snd_ctl_elem_user_tlv;\n\n\t/* This function manage to free the instance on failure. */\n\terr = __snd_ctl_add_replace(card, kctl, CTL_ADD_EXCLUSIVE);\n\tif (err < 0) {\n\t\tsnd_ctl_free_one(kctl);\n\t\tgoto unlock;\n\t}\n\toffset = snd_ctl_get_ioff(kctl, &info->id);\n\tsnd_ctl_build_ioff(&info->id, kctl, offset);\n\t/*\n\t * Here we cannot fill any field for the number of elements added by\n\t * this operation because there're no specific fields. The usage of\n\t * 'owner' field for this purpose may cause any bugs to userspace\n\t * applications because the field originally means PID of a process\n\t * which locks the element.\n\t */\n unlock:\n\tup_write(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tint err;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\terr = snd_ctl_elem_add(file, &info, replace);\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(_info, &info, sizeof(info))) {\n\t\tsnd_ctl_remove_user_ctl(file, &info.id);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int call_tlv_handler(struct snd_ctl_file *file, int op_flag,\n\t\t\t    struct snd_kcontrol *kctl,\n\t\t\t    struct snd_ctl_elem_id *id,\n\t\t\t    unsigned int __user *buf, unsigned int size)\n{\n\tstatic const struct {\n\t\tint op;\n\t\tint perm;\n\t} pairs[] = {\n\t\t{SNDRV_CTL_TLV_OP_READ,  SNDRV_CTL_ELEM_ACCESS_TLV_READ},\n\t\t{SNDRV_CTL_TLV_OP_WRITE, SNDRV_CTL_ELEM_ACCESS_TLV_WRITE},\n\t\t{SNDRV_CTL_TLV_OP_CMD,   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND},\n\t};\n\tstruct snd_kcontrol_volatile *vd = &kctl->vd[snd_ctl_get_ioff(kctl, id)];\n\tint i, ret;\n\n\t/* Check support of the request for this element. */\n\tfor (i = 0; i < ARRAY_SIZE(pairs); ++i) {\n\t\tif (op_flag == pairs[i].op && (vd->access & pairs[i].perm))\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(pairs))\n\t\treturn -ENXIO;\n\n\tif (kctl->tlv.c == NULL)\n\t\treturn -ENXIO;\n\n\t/* Write and command operations are not allowed for locked element. */\n\tif (op_flag != SNDRV_CTL_TLV_OP_READ &&\n\t    vd->owner != NULL && vd->owner != file)\n\t\treturn -EPERM;\n\n\tret = snd_power_ref_and_wait(file->card);\n\tif (!ret)\n\t\tret = kctl->tlv.c(kctl, op_flag, size, buf);\n\tsnd_power_unref(file->card);\n\treturn ret;\n}\n\nstatic int read_tlv_buf(struct snd_kcontrol *kctl, struct snd_ctl_elem_id *id,\n\t\t\tunsigned int __user *buf, unsigned int size)\n{\n\tstruct snd_kcontrol_volatile *vd = &kctl->vd[snd_ctl_get_ioff(kctl, id)];\n\tunsigned int len;\n\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ))\n\t\treturn -ENXIO;\n\n\tif (kctl->tlv.p == NULL)\n\t\treturn -ENXIO;\n\n\tlen = sizeof(unsigned int) * 2 + kctl->tlv.p[1];\n\tif (size < len)\n\t\treturn -ENOMEM;\n\n\tif (copy_to_user(buf, kctl->tlv.p, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_tlv __user *buf,\n                             int op_flag)\n{\n\tstruct snd_ctl_tlv header;\n\tunsigned int __user *container;\n\tunsigned int container_size;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol_volatile *vd;\n\n\tif (copy_from_user(&header, buf, sizeof(header)))\n\t\treturn -EFAULT;\n\n\t/* In design of control core, numerical ID starts at 1. */\n\tif (header.numid == 0)\n\t\treturn -EINVAL;\n\n\t/* At least, container should include type and length fields.  */\n\tif (header.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tcontainer_size = header.length;\n\tcontainer = buf->tlv;\n\n\tkctl = snd_ctl_find_numid(file->card, header.numid);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\t/* Calculate index of the element in this set. */\n\tid = kctl->id;\n\tsnd_ctl_build_ioff(&id, kctl, header.numid - id.numid);\n\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\treturn call_tlv_handler(file, op_flag, kctl, &id, container,\n\t\t\t\t\tcontainer_size);\n\t} else {\n\t\tif (op_flag == SNDRV_CTL_TLV_OP_READ) {\n\t\t\treturn read_tlv_buf(kctl, &id, container,\n\t\t\t\t\t    container_size);\n\t\t}\n\t}\n\n\t/* Not supported. */\n\treturn -ENXIO;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\tdown_read(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_READ);\n\t\tup_read(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\tdown_write(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_WRITE);\n\t\tup_write(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\tdown_write(&ctl->card->controls_rwsem);\n\t\terr = snd_ctl_tlv_ioctl(ctl, argp, SNDRV_CTL_TLV_OP_CMD);\n\t\tup_write(&ctl->card->controls_rwsem);\n\t\treturn err;\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_entry_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic __poll_t snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\t__poll_t mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\n/**\n * snd_ctl_register_ioctl - register the device-specific control-ioctls\n * @fcn: ioctl callback function\n *\n * called from each device manager like pcm.c, hwdep.c, etc.\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\n/**\n * snd_ctl_register_ioctl_compat - register the device-specific 32bit compat\n * control-ioctls\n * @fcn: ioctl callback function\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\n/**\n * snd_ctl_unregister_ioctl - de-register the device-specific control-ioctls\n * @fcn: ioctl callback function to unregister\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\n/**\n * snd_ctl_unregister_ioctl_compat - de-register the device-specific compat\n * 32bit control-ioctls\n * @fcn: ioctl callback function to unregister\n *\n * Return: zero if successful, or a negative error code\n */\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn snd_fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/* return the preferred subdevice number if already assigned;\n * otherwise return -1\n */\nint snd_ctl_get_preferred_subdevice(struct snd_card *card, int type)\n{\n\tstruct snd_ctl_file *kctl;\n\tint subdevice = -1;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_for_each_entry(kctl, &card->ctl_files, list) {\n\t\tif (kctl->pid == task_pid(current)) {\n\t\t\tsubdevice = kctl->preferred_subdevice[type];\n\t\t\tif (subdevice != -1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\treturn subdevice;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_get_preferred_subdevice);\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n * control layers (audio LED etc.)\n */\n\n/**\n * snd_ctl_request_layer - request to use the layer\n * @module_name: Name of the kernel module (NULL == build-in)\n *\n * Return: zero if successful, or an error code when the module cannot be loaded\n */\nint snd_ctl_request_layer(const char *module_name)\n{\n\tstruct snd_ctl_layer_ops *lops;\n\n\tif (module_name == NULL)\n\t\treturn 0;\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tif (strcmp(lops->module_name, module_name) == 0)\n\t\t\tbreak;\n\tup_read(&snd_ctl_layer_rwsem);\n\tif (lops)\n\t\treturn 0;\n\treturn request_module(module_name);\n}\nEXPORT_SYMBOL_GPL(snd_ctl_request_layer);\n\n/**\n * snd_ctl_register_layer - register new control layer\n * @lops: operation structure\n *\n * The new layer can track all control elements and do additional\n * operations on top (like audio LED handling).\n */\nvoid snd_ctl_register_layer(struct snd_ctl_layer_ops *lops)\n{\n\tstruct snd_card *card;\n\tint card_number;\n\n\tdown_write(&snd_ctl_layer_rwsem);\n\tlops->next = snd_ctl_layer;\n\tsnd_ctl_layer = lops;\n\tup_write(&snd_ctl_layer_rwsem);\n\tfor (card_number = 0; card_number < SNDRV_CARDS; card_number++) {\n\t\tcard = snd_card_ref(card_number);\n\t\tif (card) {\n\t\t\tdown_read(&card->controls_rwsem);\n\t\t\tlops->lregister(card);\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_card_unref(card);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_ctl_register_layer);\n\n/**\n * snd_ctl_disconnect_layer - disconnect control layer\n * @lops: operation structure\n *\n * It is expected that the information about tracked cards\n * is freed before this call (the disconnect callback is\n * not called here).\n */\nvoid snd_ctl_disconnect_layer(struct snd_ctl_layer_ops *lops)\n{\n\tstruct snd_ctl_layer_ops *lops2, *prev_lops2;\n\n\tdown_write(&snd_ctl_layer_rwsem);\n\tfor (lops2 = snd_ctl_layer, prev_lops2 = NULL; lops2; lops2 = lops2->next) {\n\t\tif (lops2 == lops) {\n\t\t\tif (!prev_lops2)\n\t\t\t\tsnd_ctl_layer = lops->next;\n\t\t\telse\n\t\t\t\tprev_lops2->next = lops->next;\n\t\t\tbreak;\n\t\t}\n\t\tprev_lops2 = lops2;\n\t}\n\tup_write(&snd_ctl_layer_rwsem);\n}\nEXPORT_SYMBOL_GPL(snd_ctl_disconnect_layer);\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_layer_ops *lops;\n\tint err;\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t  &snd_ctl_f_ops, card, &card->ctl_dev);\n\tif (err < 0)\n\t\treturn err;\n\tdown_read(&card->controls_rwsem);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->lregister(card);\n\tup_read(&snd_ctl_layer_rwsem);\n\tup_read(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_ctl_layer_ops *lops;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tsnd_kill_fasync(ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\n\tdown_read(&card->controls_rwsem);\n\tdown_read(&snd_ctl_layer_rwsem);\n\tfor (lops = snd_ctl_layer; lops; lops = lops->next)\n\t\tlops->ldisconnect(card);\n\tup_read(&snd_ctl_layer_rwsem);\n\tup_read(&card->controls_rwsem);\n\n\treturn snd_unregister_device(&card->ctl_dev);\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\t__snd_ctl_remove(card, control, false);\n\t}\n\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\txa_destroy(&card->ctl_numids);\n\txa_destroy(&card->ctl_hash);\n#endif\n\tup_write(&card->controls_rwsem);\n\tput_device(&card->ctl_dev);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(card->number < 0 || card->number >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tsnd_device_initialize(&card->ctl_dev, card);\n\tdev_set_name(&card->ctl_dev, \"controlC%d\", card->number);\n\n\terr = snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n\tif (err < 0)\n\t\tput_device(&card->ctl_dev);\n\treturn err;\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\n\n/**\n * snd_ctl_boolean_mono_info - Helper function for a standard boolean info\n * callback with a mono channel\n * @kcontrol: the kcontrol instance\n * @uinfo: info to store\n *\n * This is a function that can be used as info callback for a standard\n * boolean control with a single mono channel.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\n/**\n * snd_ctl_boolean_stereo_info - Helper function for a standard boolean info\n * callback with stereo two channels\n * @kcontrol: the kcontrol instance\n * @uinfo: info to store\n *\n * This is a function that can be used as info callback for a standard\n * boolean control with stereo two channels.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero (always successful)\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (!items)\n\t\treturn 0;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tWARN(strlen(names[info->value.enumerated.item]) >= sizeof(info->value.enumerated.name),\n\t     \"ALSA: too long item name '%s'\\n\",\n\t     names[info->value.enumerated.item]);\n\tstrscpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n"], "filenames": ["sound/core/control.c"], "buggy_code_start_loc": [1205], "buggy_code_end_loc": [1259], "fixing_code_start_loc": [1206], "fixing_code_end_loc": [1264], "type": "CWE-416", "message": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e\n", "other": {"cve": {"id": "CVE-2023-0266", "sourceIdentifier": "cve-coordination@google.com", "published": "2023-01-30T14:15:10.500", "lastModified": "2023-05-03T14:15:16.877", "vulnStatus": "Modified", "cisaExploitAdd": "2023-03-30", "cisaActionDue": "2023-04-20", "cisaRequiredAction": "Apply updates per vendor instructions.", "cisaVulnerabilityName": "Linux Kernel Use-After-Free Vulnerability", "descriptions": [{"lang": "en", "value": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:C/C:L/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2", "matchCriteriaId": "108695B6-7133-4B6C-80AF-0F66880FE858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*", "matchCriteriaId": "FF501633-2F44-4913-A8EE-B021929F49F6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "2BDA597B-CAC1-4DF0-86F0-42E142C654E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "725C78C9-12CE-406F-ABE8-0813A01D66E8"}]}]}], "references": [{"url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git/tree/queue-5.10/alsa-pcm-move-rwsem-lock-inside-snd_ctl_elem_read-to-prevent-uaf.patch?id=72783cf35e6c55bca84c4bb7b776c58152856fd4", "source": "cve-coordination@google.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/56b88b50565cd8b946a2d00b0c83927b7ebb055e", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/becf9e5d553c2389d857a3c178ce80fdb34a02e1", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html", "source": "cve-coordination@google.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/56b88b50565cd8b946a2d00b0c83927b7ebb055e"}}