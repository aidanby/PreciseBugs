{"buggy_code": ["/*\n# probe.c: Code for probing protocols\n#\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n*/\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#ifdef ENABLE_REGEX\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#endif\n#include <ctype.h>\n#include \"probe.h\"\n#include \"log.h\"\n\n\n\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_openvpn_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tinc_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_xmpp_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_socks5_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_true(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto) { return 1; }\n\n/* Table of protocols that have a built-in probe\n */\nstatic struct protocol_probe_desc builtins[] = {\n    /* description  probe  */\n    { \"ssh\",        is_ssh_protocol},\n    { \"openvpn\",    is_openvpn_protocol },\n    { \"wireguard\",  is_wireguard_protocol },\n    { \"tinc\",       is_tinc_protocol },\n    { \"xmpp\",       is_xmpp_protocol },\n    { \"http\",       is_http_protocol },\n    { \"tls\",        is_tls_protocol },\n    { \"adb\",        is_adb_protocol },\n    { \"socks5\",     is_socks5_protocol },\n    { \"syslog\",     is_syslog_protocol },\n    { \"teamspeak\",  is_teamspeak_protocol },\n    { \"anyprot\",    is_true }\n};\n\n/* TODO I think this has to go */\nstruct protocol_probe_desc*  get_builtins(void) {\n    return builtins;\n}\n\nint get_num_builtins(void) {\n    return ARRAY_SIZE(builtins);\n}\n\n/* Returns the protocol to connect to in case of timeout; \n * if not found, return the first protocol specified \n */\nstruct sslhcfg_protocols_item* timeout_protocol(void) \n{\n    int i;\n    for (i = 0; i < cfg.protocols_len; i++) {\n        if (!strcmp(cfg.protocols[i].name, cfg.on_timeout)) return &cfg.protocols[i];\n    }\n    return &cfg.protocols[0];\n}\n\n\n/* From http://grapsus.net/blog/post/Hexadecimal-dump-in-C */\n#define HEXDUMP_COLS 16\nvoid hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}\n\n/* Is the buffer the beginning of an SSH connection? */\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 4)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"SSH-\", 4);\n}\n\n/* Is the buffer the beginning of an OpenVPN connection?\n *\n * Code inspired from OpenVPN port-share option; however, OpenVPN code is\n * wrong: users using pre-shared secrets have non-initialised key_id fields so\n * p[3] & 7 should not be looked at, and also the key_method can be specified\n * to 1 which changes the opcode to P_CONTROL_HARD_RESET_CLIENT_V1.\n * See:\n * http://www.fengnet.com/book/vpns%20illustrated%20tunnels%20%20vpnsand%20ipsec/ch08lev1sec5.html\n * and OpenVPN ssl.c, ssl.h and options.c\n */\n#define OVPN_OPCODE_MASK 0xF8\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V1  (0x01 << 3)\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V2  (0x07 << 3)\n#define OVPN_HMAC_128 16\n#define OVPN_HMAC_160 20\n#define OVPN_HARD_RESET_PACKET_ID_OFFSET(hmac_size) (9 + hmac_size)\nstatic int is_openvpn_protocol (const char*p,ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int packet_len;\n\n    if (proto->is_udp == 0)\n    {\n        if (len < 2)\n            return PROBE_AGAIN;\n\n        packet_len = ntohs(*(uint16_t*)p);\n        return packet_len == len - 2;\n    } else {\n        if (len < 1)\n            return PROBE_NEXT;\n\n        if ((p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V1 &&\n            (p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V2)\n            return PROBE_NEXT;\n\n        /* The detection pattern above may not be reliable enough.\n         * Check the packet id: OpenVPN sents five initial packets\n         * whereas the packet id is increased with every transmitted datagram.\n         */\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128))) <= 5u)\n            return PROBE_MATCH;\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160))) <= 5u)\n            return PROBE_MATCH;\n\n        return PROBE_NEXT;\n    }\n}\n\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (proto->is_udp == 0)\n        return PROBE_NEXT;\n\n    // Handshake Init: 148 bytes\n    if (len != 148)\n        return PROBE_NEXT;\n\n    // Handshake Init: p[0] = 0x01, p[1..3] = 0x000000 (reserved)\n    if (ntohl(*(uint32_t*)p) != 0x01000000)\n        return PROBE_NEXT;\n\n    return PROBE_MATCH;\n}\n\n/* Is the buffer the beginning of a tinc connections?\n * Protocol is documented here: http://www.tinc-vpn.org/documentation/tinc.pdf\n * First connection starts with \"0 \" in 1.0.15)\n * */\nstatic int is_tinc_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"0 \", 2);\n}\n\n/* Is the buffer the beginning of a jabber (XMPP) connections?\n * (Protocol is documented (http://tools.ietf.org/html/rfc6120) but for lazy\n * clients, just checking first frame containing \"jabber\" in xml entity)\n * */\nstatic int is_xmpp_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (memmem(p, len, \"jabber\", 6))\n        return PROBE_MATCH;\n\n    /* sometimes the word 'jabber' shows up late in the initial string,\n       sometimes after a newline. this makes sure we snarf the entire preamble\n       and detect it. (fixed for adium/pidgin) */\n    if (len < 50)\n        return PROBE_AGAIN;\n\n    return PROBE_NEXT;\n}\n\nstatic int probe_http_method(const char *p, int len, const char *opt)\n{\n    if (len < strlen(opt))\n        return PROBE_AGAIN;\n\n    return !strncmp(p, opt, strlen(opt));\n}\n\n/* Is the buffer the beginning of an HTTP connection?  */\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res;\n    /* If it's got HTTP in the request (HTTP/1.1) then it's HTTP */\n    if (memmem(p, len, \"HTTP\", 4))\n        return PROBE_MATCH;\n\n#define PROBE_HTTP_METHOD(opt) if ((res = probe_http_method(p, len, opt)) != PROBE_NEXT) return res\n\n    /* Otherwise it could be HTTP/1.0 without version: check if it's got an\n     * HTTP method (RFC2616 5.1.1) */\n    PROBE_HTTP_METHOD(\"OPTIONS\");\n    PROBE_HTTP_METHOD(\"GET\");\n    PROBE_HTTP_METHOD(\"HEAD\");\n    PROBE_HTTP_METHOD(\"POST\");\n    PROBE_HTTP_METHOD(\"PUT\");\n    PROBE_HTTP_METHOD(\"DELETE\");\n    PROBE_HTTP_METHOD(\"TRACE\");\n    PROBE_HTTP_METHOD(\"CONNECT\");\n\n#undef PROBE_HTTP_METHOD\n\n    return PROBE_NEXT;\n}\n\n/* Says if it's TLS, optionally with SNI and ALPN lists in proto->data */\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    switch (parse_tls_header(proto->data, p, len)) {\n    case TLS_MATCH: return PROBE_MATCH;\n    case TLS_NOMATCH: return PROBE_NEXT;\n    case TLS_ELENGTH: return PROBE_AGAIN;\n    default: return PROBE_NEXT;\n    }\n}\n\nstatic int probe_adb_cnxn_message(const char *p)\n{\n    /* The initial ADB host->device packet has a command type of CNXN, and a\n     * data payload starting with \"host:\".  Note that current versions of the\n     * client hardcode \"host::\" (with empty serialno and banner fields) but\n     * other clients may populate those fields.\n     */\n    return !memcmp(&p[0], \"CNXN\", 4) && !memcmp(&p[24], \"host:\", 5);\n}\n\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    /* amessage.data_length is not being checked, under the assumption that\n     * a packet >= 30 bytes will have \"something\" in the payload field.\n     *\n     * 24 bytes for the message header and 5 bytes for the \"host:\" tag.\n     *\n     * ADB protocol:\n     * https://android.googlesource.com/platform/system/adb/+/master/protocol.txt\n     */\n    static const unsigned int min_data_packet_size = 30;\n\n    if (len < min_data_packet_size)\n        return PROBE_AGAIN;\n\n    if (probe_adb_cnxn_message(&p[0]) == PROBE_MATCH)\n        return PROBE_MATCH;\n\n    /* In ADB v26.0.0 rc1-4321094, the initial host->device packet sends an\n     * empty message before sending the CNXN command type. This was an\n     * unintended side effect introduced in\n     * https://android-review.googlesource.com/c/342653, and will be reverted for\n     * a future release.\n     */\n    static const unsigned char empty_message[] = {\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff\n    };\n\n    if (len < min_data_packet_size + sizeof(empty_message))\n        return PROBE_AGAIN;\n\n    if (memcmp(&p[0], empty_message, sizeof(empty_message)))\n        return PROBE_NEXT;\n\n    return probe_adb_cnxn_message(&p[sizeof(empty_message)]);\n}\n\nstatic int is_socks5_protocol(const char *p_in, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    unsigned char* p = (unsigned char*)p_in;\n    int i;\n\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    /* First byte should be socks protocol version */\n    if (p[0] != 5)\n        return PROBE_NEXT;\n\n    /* Second byte should be number of supported \n     * authentication methods, assuming maximum of 10,\n     * as defined in https://www.iana.org/assignments/socks-methods/socks-methods.xhtml\n     */\n    char m_count = p[1];\n    if (m_count < 1 || m_count > 10)\n        return PROBE_NEXT;\n\n    if (len < 2 + m_count)\n        return PROBE_AGAIN;\n\n    /* Each authentication method number should be in range 0..9 \n     * (https://www.iana.org/assignments/socks-methods/socks-methods.xhtml)\n     */\n    for (i = 0; i < m_count; i++) {\n        if (p[2 + i] > 9)\n            return PROBE_NEXT;\n    }\n    return PROBE_MATCH;\n}\n\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res, i, j;\n\n    res = sscanf(p, \"<%d>\", &i);\n    if (res == 1) return 1;\n\n    res = sscanf(p, \"%d <%d>\", &i, &j);\n    if (res == 2) return 1;\n\n    return 0;\n}\n\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 8)\n        return PROBE_NEXT;\n\n    return !strncmp(p, \"TS3INIT1\", len);\n}\n\nstatic int regex_probe(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n#ifdef ENABLE_REGEX\n    pcre2_code**probe = (pcre2_code**)proto->data;\n    pcre2_match_data* matches;\n\n    matches = pcre2_match_data_create(1, NULL);\n\n    for (; *probe; probe++) {\n        int res = pcre2_match(*probe, (PCRE2_SPTR8)p, len, 0, 0, matches, NULL);\n        if (res >= 0) return 1;\n\n    }\n    return 0;\n#else\n    /* Should never happen as we check when loading config file */\n    print_message(msg_int_error, \"FATAL: regex probe called but not built in\\n\");\n    exit(5);\n#endif\n}\n\n/* Run all the probes on a buffer\n * buf, len: buffer to test on\n * proto_in, proto_len: array of protocols to try\n * proto_out: protocol that matched\n *\n * Returns\n *      PROBE_AGAIN if not enough data, and set *proto to NULL\n *      PROBE_MATCH if protocol is identified, in which case *proto is set to\n *      point to the appropriate protocol\n * */\nint probe_buffer(char* buf, int len,\n                 struct sslhcfg_protocols_item** proto_in,\n                 int proto_len,\n                 struct sslhcfg_protocols_item** proto_out\n                 )\n{\n    struct sslhcfg_protocols_item* p;\n    int i, res, again = 0;\n\n    print_message(msg_packets, \"hexdump of incoming packet:\\n\");\n    hexdump(msg_packets, buf, len);\n\n    *proto_out = NULL;\n    for (i = 0; i < proto_len; i++) {\n        char* probe_str[3] = {\"PROBE_NEXT\", \"PROBE_MATCH\", \"PROBE_AGAIN\"};\n        p = proto_in[i];\n\n        if (! p->probe) continue;\n\n        print_message(msg_probe_info, \"probing for %s\\n\", p->name);\n\n        /* Don't probe last protocol if it is anyprot (and store last protocol) */\n        if ((i == proto_len - 1) && (!strcmp(p->name, \"anyprot\")))\n            break;\n\n        if (p->minlength_is_present && (len < p->minlength )) {\n            print_message(msg_probe_info, \"input too short, %d bytes but need %d\\n\", \n                          len , p->minlength);\n            again++;\n            continue;\n        }\n\n        res = p->probe(buf, len, p);\n        print_message(msg_probe_info, \"probed for %s: %s\\n\", p->name, probe_str[res]);\n\n        if (res == PROBE_MATCH) {\n            *proto_out = p;\n            return PROBE_MATCH;\n        }\n        if (res == PROBE_AGAIN)\n            again++;\n    }\n    if (again)\n        return PROBE_AGAIN;\n\n    /* Everything failed: match the last one */\n\n    if (proto_len == 0) {\n        /* This should be caught by configuration sanity checks, but just in\n         * case, die gracefully rather than segfaulting */\n        print_message(msg_int_error, \"Received traffic on transport that has no target\\n\");\n        exit(0);\n    }\n    *proto_out = proto_in[proto_len-1];\n    return PROBE_MATCH;\n}\n\n/* Returns the probe for specified protocol:\n * parameter is the description in builtins[], or \"regex\" \n * */\nT_PROBE* get_probe(const char* description) {\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(builtins); i++) {\n        if (!strcmp(builtins[i].name, description)) {\n            return builtins[i].probe;\n        }\n    }\n\n    /* Special case of \"regex\" probe (we don't want to set it in builtins\n     * because builtins is also used to build the command-line options and\n     * regexp is not legal on the command line)*/\n    if (!strcmp(description, \"regex\"))\n        return regex_probe;\n\n    /* Special case of \"timeout\" is allowed as a probe name in the\n     * configuration file even though it's not really a probe */\n    if (!strcmp(description, \"timeout\"))\n        return is_true;\n\n    return NULL;\n}\n\n\n"], "fixing_code": ["/*\n# probe.c: Code for probing protocols\n#\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n*/\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#ifdef ENABLE_REGEX\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#endif\n#include <ctype.h>\n#include \"probe.h\"\n#include \"log.h\"\n\n\n\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_openvpn_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tinc_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_xmpp_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_socks5_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_true(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto) { return 1; }\n\n/* Table of protocols that have a built-in probe\n */\nstatic struct protocol_probe_desc builtins[] = {\n    /* description  probe  */\n    { \"ssh\",        is_ssh_protocol},\n    { \"openvpn\",    is_openvpn_protocol },\n    { \"wireguard\",  is_wireguard_protocol },\n    { \"tinc\",       is_tinc_protocol },\n    { \"xmpp\",       is_xmpp_protocol },\n    { \"http\",       is_http_protocol },\n    { \"tls\",        is_tls_protocol },\n    { \"adb\",        is_adb_protocol },\n    { \"socks5\",     is_socks5_protocol },\n    { \"syslog\",     is_syslog_protocol },\n    { \"teamspeak\",  is_teamspeak_protocol },\n    { \"anyprot\",    is_true }\n};\n\n/* TODO I think this has to go */\nstruct protocol_probe_desc*  get_builtins(void) {\n    return builtins;\n}\n\nint get_num_builtins(void) {\n    return ARRAY_SIZE(builtins);\n}\n\n/* Returns the protocol to connect to in case of timeout; \n * if not found, return the first protocol specified \n */\nstruct sslhcfg_protocols_item* timeout_protocol(void) \n{\n    int i;\n    for (i = 0; i < cfg.protocols_len; i++) {\n        if (!strcmp(cfg.protocols[i].name, cfg.on_timeout)) return &cfg.protocols[i];\n    }\n    return &cfg.protocols[0];\n}\n\n\n/* From http://grapsus.net/blog/post/Hexadecimal-dump-in-C */\n#define HEXDUMP_COLS 16\nvoid hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, \"%s\", str);\n            c = 0;\n        }\n    }\n}\n\n/* Is the buffer the beginning of an SSH connection? */\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 4)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"SSH-\", 4);\n}\n\n/* Is the buffer the beginning of an OpenVPN connection?\n *\n * Code inspired from OpenVPN port-share option; however, OpenVPN code is\n * wrong: users using pre-shared secrets have non-initialised key_id fields so\n * p[3] & 7 should not be looked at, and also the key_method can be specified\n * to 1 which changes the opcode to P_CONTROL_HARD_RESET_CLIENT_V1.\n * See:\n * http://www.fengnet.com/book/vpns%20illustrated%20tunnels%20%20vpnsand%20ipsec/ch08lev1sec5.html\n * and OpenVPN ssl.c, ssl.h and options.c\n */\n#define OVPN_OPCODE_MASK 0xF8\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V1  (0x01 << 3)\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V2  (0x07 << 3)\n#define OVPN_HMAC_128 16\n#define OVPN_HMAC_160 20\n#define OVPN_HARD_RESET_PACKET_ID_OFFSET(hmac_size) (9 + hmac_size)\nstatic int is_openvpn_protocol (const char*p,ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int packet_len;\n\n    if (proto->is_udp == 0)\n    {\n        if (len < 2)\n            return PROBE_AGAIN;\n\n        packet_len = ntohs(*(uint16_t*)p);\n        return packet_len == len - 2;\n    } else {\n        if (len < 1)\n            return PROBE_NEXT;\n\n        if ((p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V1 &&\n            (p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V2)\n            return PROBE_NEXT;\n\n        /* The detection pattern above may not be reliable enough.\n         * Check the packet id: OpenVPN sents five initial packets\n         * whereas the packet id is increased with every transmitted datagram.\n         */\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128))) <= 5u)\n            return PROBE_MATCH;\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160))) <= 5u)\n            return PROBE_MATCH;\n\n        return PROBE_NEXT;\n    }\n}\n\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (proto->is_udp == 0)\n        return PROBE_NEXT;\n\n    // Handshake Init: 148 bytes\n    if (len != 148)\n        return PROBE_NEXT;\n\n    // Handshake Init: p[0] = 0x01, p[1..3] = 0x000000 (reserved)\n    if (ntohl(*(uint32_t*)p) != 0x01000000)\n        return PROBE_NEXT;\n\n    return PROBE_MATCH;\n}\n\n/* Is the buffer the beginning of a tinc connections?\n * Protocol is documented here: http://www.tinc-vpn.org/documentation/tinc.pdf\n * First connection starts with \"0 \" in 1.0.15)\n * */\nstatic int is_tinc_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"0 \", 2);\n}\n\n/* Is the buffer the beginning of a jabber (XMPP) connections?\n * (Protocol is documented (http://tools.ietf.org/html/rfc6120) but for lazy\n * clients, just checking first frame containing \"jabber\" in xml entity)\n * */\nstatic int is_xmpp_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (memmem(p, len, \"jabber\", 6))\n        return PROBE_MATCH;\n\n    /* sometimes the word 'jabber' shows up late in the initial string,\n       sometimes after a newline. this makes sure we snarf the entire preamble\n       and detect it. (fixed for adium/pidgin) */\n    if (len < 50)\n        return PROBE_AGAIN;\n\n    return PROBE_NEXT;\n}\n\nstatic int probe_http_method(const char *p, int len, const char *opt)\n{\n    if (len < strlen(opt))\n        return PROBE_AGAIN;\n\n    return !strncmp(p, opt, strlen(opt));\n}\n\n/* Is the buffer the beginning of an HTTP connection?  */\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res;\n    /* If it's got HTTP in the request (HTTP/1.1) then it's HTTP */\n    if (memmem(p, len, \"HTTP\", 4))\n        return PROBE_MATCH;\n\n#define PROBE_HTTP_METHOD(opt) if ((res = probe_http_method(p, len, opt)) != PROBE_NEXT) return res\n\n    /* Otherwise it could be HTTP/1.0 without version: check if it's got an\n     * HTTP method (RFC2616 5.1.1) */\n    PROBE_HTTP_METHOD(\"OPTIONS\");\n    PROBE_HTTP_METHOD(\"GET\");\n    PROBE_HTTP_METHOD(\"HEAD\");\n    PROBE_HTTP_METHOD(\"POST\");\n    PROBE_HTTP_METHOD(\"PUT\");\n    PROBE_HTTP_METHOD(\"DELETE\");\n    PROBE_HTTP_METHOD(\"TRACE\");\n    PROBE_HTTP_METHOD(\"CONNECT\");\n\n#undef PROBE_HTTP_METHOD\n\n    return PROBE_NEXT;\n}\n\n/* Says if it's TLS, optionally with SNI and ALPN lists in proto->data */\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    switch (parse_tls_header(proto->data, p, len)) {\n    case TLS_MATCH: return PROBE_MATCH;\n    case TLS_NOMATCH: return PROBE_NEXT;\n    case TLS_ELENGTH: return PROBE_AGAIN;\n    default: return PROBE_NEXT;\n    }\n}\n\nstatic int probe_adb_cnxn_message(const char *p)\n{\n    /* The initial ADB host->device packet has a command type of CNXN, and a\n     * data payload starting with \"host:\".  Note that current versions of the\n     * client hardcode \"host::\" (with empty serialno and banner fields) but\n     * other clients may populate those fields.\n     */\n    return !memcmp(&p[0], \"CNXN\", 4) && !memcmp(&p[24], \"host:\", 5);\n}\n\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    /* amessage.data_length is not being checked, under the assumption that\n     * a packet >= 30 bytes will have \"something\" in the payload field.\n     *\n     * 24 bytes for the message header and 5 bytes for the \"host:\" tag.\n     *\n     * ADB protocol:\n     * https://android.googlesource.com/platform/system/adb/+/master/protocol.txt\n     */\n    static const unsigned int min_data_packet_size = 30;\n\n    if (len < min_data_packet_size)\n        return PROBE_AGAIN;\n\n    if (probe_adb_cnxn_message(&p[0]) == PROBE_MATCH)\n        return PROBE_MATCH;\n\n    /* In ADB v26.0.0 rc1-4321094, the initial host->device packet sends an\n     * empty message before sending the CNXN command type. This was an\n     * unintended side effect introduced in\n     * https://android-review.googlesource.com/c/342653, and will be reverted for\n     * a future release.\n     */\n    static const unsigned char empty_message[] = {\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff\n    };\n\n    if (len < min_data_packet_size + sizeof(empty_message))\n        return PROBE_AGAIN;\n\n    if (memcmp(&p[0], empty_message, sizeof(empty_message)))\n        return PROBE_NEXT;\n\n    return probe_adb_cnxn_message(&p[sizeof(empty_message)]);\n}\n\nstatic int is_socks5_protocol(const char *p_in, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    unsigned char* p = (unsigned char*)p_in;\n    int i;\n\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    /* First byte should be socks protocol version */\n    if (p[0] != 5)\n        return PROBE_NEXT;\n\n    /* Second byte should be number of supported \n     * authentication methods, assuming maximum of 10,\n     * as defined in https://www.iana.org/assignments/socks-methods/socks-methods.xhtml\n     */\n    char m_count = p[1];\n    if (m_count < 1 || m_count > 10)\n        return PROBE_NEXT;\n\n    if (len < 2 + m_count)\n        return PROBE_AGAIN;\n\n    /* Each authentication method number should be in range 0..9 \n     * (https://www.iana.org/assignments/socks-methods/socks-methods.xhtml)\n     */\n    for (i = 0; i < m_count; i++) {\n        if (p[2 + i] > 9)\n            return PROBE_NEXT;\n    }\n    return PROBE_MATCH;\n}\n\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res, i, j;\n\n    res = sscanf(p, \"<%d>\", &i);\n    if (res == 1) return 1;\n\n    res = sscanf(p, \"%d <%d>\", &i, &j);\n    if (res == 2) return 1;\n\n    return 0;\n}\n\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 8)\n        return PROBE_NEXT;\n\n    return !strncmp(p, \"TS3INIT1\", len);\n}\n\nstatic int regex_probe(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n#ifdef ENABLE_REGEX\n    pcre2_code**probe = (pcre2_code**)proto->data;\n    pcre2_match_data* matches;\n\n    matches = pcre2_match_data_create(1, NULL);\n\n    for (; *probe; probe++) {\n        int res = pcre2_match(*probe, (PCRE2_SPTR8)p, len, 0, 0, matches, NULL);\n        if (res >= 0) return 1;\n\n    }\n    return 0;\n#else\n    /* Should never happen as we check when loading config file */\n    print_message(msg_int_error, \"FATAL: regex probe called but not built in\\n\");\n    exit(5);\n#endif\n}\n\n/* Run all the probes on a buffer\n * buf, len: buffer to test on\n * proto_in, proto_len: array of protocols to try\n * proto_out: protocol that matched\n *\n * Returns\n *      PROBE_AGAIN if not enough data, and set *proto to NULL\n *      PROBE_MATCH if protocol is identified, in which case *proto is set to\n *      point to the appropriate protocol\n * */\nint probe_buffer(char* buf, int len,\n                 struct sslhcfg_protocols_item** proto_in,\n                 int proto_len,\n                 struct sslhcfg_protocols_item** proto_out\n                 )\n{\n    struct sslhcfg_protocols_item* p;\n    int i, res, again = 0;\n\n    print_message(msg_packets, \"hexdump of incoming packet:\\n\");\n    hexdump(msg_packets, buf, len);\n\n    *proto_out = NULL;\n    for (i = 0; i < proto_len; i++) {\n        char* probe_str[3] = {\"PROBE_NEXT\", \"PROBE_MATCH\", \"PROBE_AGAIN\"};\n        p = proto_in[i];\n\n        if (! p->probe) continue;\n\n        print_message(msg_probe_info, \"probing for %s\\n\", p->name);\n\n        /* Don't probe last protocol if it is anyprot (and store last protocol) */\n        if ((i == proto_len - 1) && (!strcmp(p->name, \"anyprot\")))\n            break;\n\n        if (p->minlength_is_present && (len < p->minlength )) {\n            print_message(msg_probe_info, \"input too short, %d bytes but need %d\\n\", \n                          len , p->minlength);\n            again++;\n            continue;\n        }\n\n        res = p->probe(buf, len, p);\n        print_message(msg_probe_info, \"probed for %s: %s\\n\", p->name, probe_str[res]);\n\n        if (res == PROBE_MATCH) {\n            *proto_out = p;\n            return PROBE_MATCH;\n        }\n        if (res == PROBE_AGAIN)\n            again++;\n    }\n    if (again)\n        return PROBE_AGAIN;\n\n    /* Everything failed: match the last one */\n\n    if (proto_len == 0) {\n        /* This should be caught by configuration sanity checks, but just in\n         * case, die gracefully rather than segfaulting */\n        print_message(msg_int_error, \"Received traffic on transport that has no target\\n\");\n        exit(0);\n    }\n    *proto_out = proto_in[proto_len-1];\n    return PROBE_MATCH;\n}\n\n/* Returns the probe for specified protocol:\n * parameter is the description in builtins[], or \"regex\" \n * */\nT_PROBE* get_probe(const char* description) {\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(builtins); i++) {\n        if (!strcmp(builtins[i].name, description)) {\n            return builtins[i].probe;\n        }\n    }\n\n    /* Special case of \"regex\" probe (we don't want to set it in builtins\n     * because builtins is also used to build the command-line options and\n     * regexp is not legal on the command line)*/\n    if (!strcmp(description, \"regex\"))\n        return regex_probe;\n\n    /* Special case of \"timeout\" is allowed as a probe name in the\n     * configuration file even though it's not really a probe */\n    if (!strcmp(description, \"timeout\"))\n        return is_true;\n\n    return NULL;\n}\n\n\n"], "filenames": ["probe.c"], "buggy_code_start_loc": [119], "buggy_code_end_loc": [120], "fixing_code_start_loc": [119], "fixing_code_end_loc": [120], "type": "CWE-134", "message": "A vulnerability, which was classified as critical, has been found in sslh. This issue affects the function hexdump of the file probe.c of the component Packet Dumping Handler. The manipulation of the argument msg_info leads to format string. The attack may be initiated remotely. The name of the patch is b19f8a6046b080e4c2e28354a58556bb26040c6f. It is recommended to apply a patch to fix this issue. The identifier VDB-216497 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4639", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-21T22:15:08.647", "lastModified": "2022-12-28T22:04:36.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, has been found in sslh. This issue affects the function hexdump of the file probe.c of the component Packet Dumping Handler. The manipulation of the argument msg_info leads to format string. The attack may be initiated remotely. The name of the patch is b19f8a6046b080e4c2e28354a58556bb26040c6f. It is recommended to apply a patch to fix this issue. The identifier VDB-216497 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sslh_project:sslh:2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "4D4C9C3C-CEAE-43A0-8FBE-3911804561FA"}]}]}], "references": [{"url": "https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/yrutschle/sslh/pull/353", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216497", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f"}}