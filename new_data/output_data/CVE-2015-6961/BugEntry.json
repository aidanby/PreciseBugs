{"buggy_code": [".*\n*.pyc\n*.pyo\n*~\n#*\n*.1\n*.bak\n*.bak2\n*.svn\n*.w2p\n*.class\n*.rej\n*.orig\nThumbs.db\n.DS_Store\nindex.yaml\nroutes.py\nlogging.conf\ngluon/tests/VERSION\ngluon/tests/sql.log\nhttpserver.log\nhttpserver.pid\nparameters*.py\n./deposit\n./benchmark\n./build\n./dist*\n./dummy_tests\n./optional_contrib\n./ssl\n./docs\n./logs\n./*.zip\n./gluon/*.1\n./gluon/*.txt\n./admin.w2p\n./examples.w2p\ncron.master\napplications/*\n!applications/welcome\n!applications/welcome/*\n!applications/examples\n!applications/examples/*\n!applications/admin\n!applications/admin/*\napplications/*/databases/*\napplications/*/sessions/*\napplications/*/errors/*\napplications/*/cache/*\napplications/*/uploads/*\napplications/*/*.py[oc]\napplications/*/static/temp\napplications/*/progress.log\napplications/examples/static/epydoc\napplications/examples/static/sphinx\napplications/admin/cron/cron.master\nHOWTO-web2py-devel\n*.sublime-project\n*.sublime-workspace\n.idea/*\n", "#!/bin/python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n| This file is part of the web2py Web Framework\n| Copyrighted by Massimo Di Pierro <mdipierro@cs.depaul.edu>\n| License: LGPLv3 (http://www.gnu.org/licenses/lgpl.html)\n\nAuth, Mail, PluginManager and various utilities\n------------------------------------------------\n\"\"\"\n\nimport base64\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport datetime\nimport thread\nimport logging\nimport sys\nimport glob\nimport os\nimport re\nimport time\nimport traceback\nimport smtplib\nimport urllib\nimport urllib2\nimport Cookie\nimport cStringIO\nimport ConfigParser\nimport email.utils\nimport random\nfrom email import MIMEBase, MIMEMultipart, MIMEText, Encoders, Header, message_from_string, Charset\n\nfrom gluon.contenttype import contenttype\nfrom gluon.storage import Storage, StorageList, Settings, Messages\nfrom gluon.utils import web2py_uuid\nfrom gluon.fileutils import read_file, check_credentials\nfrom gluon import *\nfrom gluon.contrib.autolinks import expand_one\nfrom gluon.contrib.markmin.markmin2html import \\\n    replace_at_urls, replace_autolinks, replace_components\nfrom pydal.objects import Row, Set, Query\n\nimport gluon.serializers as serializers\n\nTable = DAL.Table\nField = DAL.Field\n\ntry:\n    # try stdlib (Python 2.6)\n    import json as json_parser\nexcept ImportError:\n    try:\n        # try external module\n        import simplejson as json_parser\n    except:\n        # fallback to pure-Python module\n        import gluon.contrib.simplejson as json_parser\n\n__all__ = ['Mail', 'Auth', 'Recaptcha', 'Recaptcha2', 'Crud', 'Service', 'Wiki',\n           'PluginManager', 'fetch', 'geocode', 'reverse_geocode', 'prettydate']\n\n### mind there are two loggers here (logger and crud.settings.logger)!\nlogger = logging.getLogger(\"web2py\")\n\nDEFAULT = lambda: None\n\n\ndef getarg(position, default=None):\n    args = current.request.args\n    if position < 0 and len(args) >= -position:\n        return args[position]\n    elif position >= 0 and len(args) > position:\n        return args[position]\n    else:\n        return default\n\n\ndef callback(actions, form, tablename=None):\n    if actions:\n        if tablename and isinstance(actions, dict):\n            actions = actions.get(tablename, [])\n        if not isinstance(actions, (list, tuple)):\n            actions = [actions]\n        [action(form) for action in actions]\n\n\ndef validators(*a):\n    b = []\n    for item in a:\n        if isinstance(item, (list, tuple)):\n            b = b + list(item)\n        else:\n            b.append(item)\n    return b\n\n\ndef call_or_redirect(f, *args):\n    if callable(f):\n        redirect(f(*args))\n    else:\n        redirect(f)\n\n\ndef replace_id(url, form):\n    if url:\n        url = url.replace('[id]', str(form.vars.id))\n        if url[0] == '/' or url[:4] == 'http':\n            return url\n    return URL(url)\n\n\nclass Mail(object):\n    \"\"\"\n    Class for configuring and sending emails with alternative text / html\n    body, multiple attachments and encryption support\n\n    Works with SMTP and Google App Engine.\n\n    Args:\n        server: SMTP server address in address:port notation\n        sender: sender email address\n        login: sender login name and password in login:password notation\n            or None if no authentication is required\n        tls: enables/disables encryption (True by default)\n\n    In Google App Engine use ::\n\n        server='gae'\n\n    For sake of backward compatibility all fields are optional and default\n    to None, however, to be able to send emails at least server and sender\n    must be specified. They are available under following fields::\n\n        mail.settings.server\n        mail.settings.sender\n        mail.settings.login\n        mail.settings.timeout = 60 # seconds (default)\n\n    When server is 'logging', email is logged but not sent (debug mode)\n\n    Optionally you can use PGP encryption or X509::\n\n        mail.settings.cipher_type = None\n        mail.settings.gpg_home = None\n        mail.settings.sign = True\n        mail.settings.sign_passphrase = None\n        mail.settings.encrypt = True\n        mail.settings.x509_sign_keyfile = None\n        mail.settings.x509_sign_certfile = None\n        mail.settings.x509_sign_chainfile = None\n        mail.settings.x509_nocerts = False\n        mail.settings.x509_crypt_certfiles = None\n\n        cipher_type       : None\n                            gpg - need a python-pyme package and gpgme lib\n                            x509 - smime\n        gpg_home          : you can set a GNUPGHOME environment variable\n                            to specify home of gnupg\n        sign              : sign the message (True or False)\n        sign_passphrase   : passphrase for key signing\n        encrypt           : encrypt the message (True or False). It defaults\n                            to True\n                         ... x509 only ...\n        x509_sign_keyfile : the signers private key filename or\n                            string containing the key. (PEM format)\n        x509_sign_certfile: the signers certificate filename or\n                            string containing the cert. (PEM format)\n        x509_sign_chainfile: sets the optional all-in-one file where you\n                             can assemble the certificates of Certification\n                             Authorities (CA) which form the certificate\n                             chain of email certificate. It can be a\n                             string containing the certs to. (PEM format)\n        x509_nocerts      : if True then no attached certificate in mail\n        x509_crypt_certfiles: the certificates file or strings to encrypt\n                              the messages with can be a file name /\n                              string or a list of file names /\n                              strings (PEM format)\n\n    Examples:\n        Create Mail object with authentication data for remote server::\n\n            mail = Mail('example.com:25', 'me@example.com', 'me:password')\n\n    Notice for GAE users:\n        attachments have an automatic content_id='attachment-i' where i is progressive number\n        in this way the can be referenced from the HTML as <img src=\"cid:attachment-0\" /> etc.\n    \"\"\"\n\n    class Attachment(MIMEBase.MIMEBase):\n        \"\"\"\n        Email attachment\n\n        Args:\n            payload: path to file or file-like object with read() method\n            filename: name of the attachment stored in message; if set to\n                None, it will be fetched from payload path; file-like\n                object payload must have explicit filename specified\n            content_id: id of the attachment; automatically contained within\n                `<` and `>`\n            content_type: content type of the attachment; if set to None,\n                it will be fetched from filename using gluon.contenttype\n                module\n            encoding: encoding of all strings passed to this function (except\n                attachment body)\n\n        Content ID is used to identify attachments within the html body;\n        in example, attached image with content ID 'photo' may be used in\n        html message as a source of img tag `<img src=\"cid:photo\" />`.\n\n        Example::\n            Create attachment from text file::\n\n                attachment = Mail.Attachment('/path/to/file.txt')\n\n                Content-Type: text/plain\n                MIME-Version: 1.0\n                Content-Disposition: attachment; filename=\"file.txt\"\n                Content-Transfer-Encoding: base64\n\n                SOMEBASE64CONTENT=\n\n            Create attachment from image file with custom filename and cid::\n\n                attachment = Mail.Attachment('/path/to/file.png',\n                                                 filename='photo.png',\n                                                 content_id='photo')\n\n                Content-Type: image/png\n                MIME-Version: 1.0\n                Content-Disposition: attachment; filename=\"photo.png\"\n                Content-Id: <photo>\n                Content-Transfer-Encoding: base64\n\n                SOMEOTHERBASE64CONTENT=\n        \"\"\"\n\n        def __init__(\n            self,\n            payload,\n            filename=None,\n            content_id=None,\n            content_type=None,\n                encoding='utf-8'):\n            if isinstance(payload, str):\n                if filename is None:\n                    filename = os.path.basename(payload)\n                payload = read_file(payload, 'rb')\n            else:\n                if filename is None:\n                    raise Exception('Missing attachment name')\n                payload = payload.read()\n            filename = filename.encode(encoding)\n            if content_type is None:\n                content_type = contenttype(filename)\n            self.my_filename = filename\n            self.my_payload = payload\n            MIMEBase.MIMEBase.__init__(self, *content_type.split('/', 1))\n            self.set_payload(payload)\n            self['Content-Disposition'] = 'attachment; filename=\"%s\"' % filename\n            if not content_id is None:\n                self['Content-Id'] = '<%s>' % content_id.encode(encoding)\n            Encoders.encode_base64(self)\n\n    def __init__(self, server=None, sender=None, login=None, tls=True):\n\n        settings = self.settings = Settings()\n        settings.server = server\n        settings.sender = sender\n        settings.login = login\n        settings.tls = tls\n        settings.timeout = 60 # seconds\n        settings.hostname = None\n        settings.ssl = False\n        settings.cipher_type = None\n        settings.gpg_home = None\n        settings.sign = True\n        settings.sign_passphrase = None\n        settings.encrypt = True\n        settings.x509_sign_keyfile = None\n        settings.x509_sign_certfile = None\n        settings.x509_sign_chainfile = None\n        settings.x509_nocerts = False\n        settings.x509_crypt_certfiles = None\n        settings.debug = False\n        settings.lock_keys = True\n        self.result = {}\n        self.error = None\n\n    def send(self,\n             to,\n             subject='[no subject]',\n             message='[no message]',\n             attachments=None,\n             cc=None,\n             bcc=None,\n             reply_to=None,\n             sender=None,\n             encoding='utf-8',\n             raw=False,\n             headers={},\n             from_address=None,\n             cipher_type=None,\n             sign=None,\n             sign_passphrase=None,\n             encrypt=None,\n             x509_sign_keyfile=None,\n             x509_sign_chainfile=None,\n             x509_sign_certfile=None,\n             x509_crypt_certfiles=None,\n             x509_nocerts=None\n             ):\n        \"\"\"\n        Sends an email using data specified in constructor\n\n        Args:\n            to: list or tuple of receiver addresses; will also accept single\n                object\n            subject: subject of the email\n            message: email body text; depends on type of passed object:\n\n                - if 2-list or 2-tuple is passed: first element will be\n                  source of plain text while second of html text;\n                - otherwise: object will be the only source of plain text\n                  and html source will be set to None\n\n                If text or html source is:\n\n                - None: content part will be ignored,\n                - string: content part will be set to it,\n                - file-like object: content part will be fetched from it using\n                  it's read() method\n            attachments: list or tuple of Mail.Attachment objects; will also\n                accept single object\n            cc: list or tuple of carbon copy receiver addresses; will also\n                accept single object\n            bcc: list or tuple of blind carbon copy receiver addresses; will\n                also accept single object\n            reply_to: address to which reply should be composed\n            encoding: encoding of all strings passed to this method (including\n                message bodies)\n            headers: dictionary of headers to refine the headers just before\n                sending mail, e.g. `{'X-Mailer' : 'web2py mailer'}`\n            from_address: address to appear in the 'From:' header, this is not\n                the envelope sender. If not specified the sender will be used\n\n            cipher_type :\n                gpg - need a python-pyme package and gpgme lib\n                x509 - smime\n            gpg_home : you can set a GNUPGHOME environment variable\n                to specify home of gnupg\n            sign : sign the message (True or False)\n            sign_passphrase  : passphrase for key signing\n            encrypt : encrypt the message (True or False). It defaults to True.\n                         ... x509 only ...\n            x509_sign_keyfile : the signers private key filename or\n                string containing the key. (PEM format)\n            x509_sign_certfile: the signers certificate filename or\n                string containing the cert. (PEM format)\n            x509_sign_chainfile: sets the optional all-in-one file where you\n                can assemble the certificates of Certification\n                Authorities (CA) which form the certificate\n                chain of email certificate. It can be a\n                string containing the certs to. (PEM format)\n            x509_nocerts : if True then no attached certificate in mail\n            x509_crypt_certfiles: the certificates file or strings to encrypt\n                the messages with can be a file name / string or\n                a list of file names / strings (PEM format)\n        Examples:\n            Send plain text message to single address::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          'Plain text body of the message')\n\n            Send html message to single address::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          '<html>Plain text body of the message</html>')\n\n            Send text and html message to three addresses (two in cc)::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          ('Plain text body', '<html>html body</html>'),\n                          cc=['other1@example.com', 'other2@example.com'])\n\n            Send html only message with image attachment available from the\n            message by 'photo' content id::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          (None, '<html><img src=\"cid:photo\" /></html>'),\n                          Mail.Attachment('/path/to/photo.jpg'\n                                          content_id='photo'))\n\n            Send email with two attachments and no body text::\n\n                mail.send('you@example.com,\n                          'Message subject',\n                          None,\n                          [Mail.Attachment('/path/to/fist.file'),\n                           Mail.Attachment('/path/to/second.file')])\n\n        Returns:\n            True on success, False on failure.\n\n        Before return, method updates two object's fields:\n\n            - self.result: return value of smtplib.SMTP.sendmail() or GAE's\n              mail.send_mail() method\n            - self.error: Exception message or None if above was successful\n        \"\"\"\n\n        # We don't want to use base64 encoding for unicode mail\n        Charset.add_charset('utf-8', Charset.QP, Charset.QP, 'utf-8')\n\n        def encode_header(key):\n            if [c for c in key if 32 > ord(c) or ord(c) > 127]:\n                return Header.Header(key.encode('utf-8'), 'utf-8')\n            else:\n                return key\n\n        # encoded or raw text\n        def encoded_or_raw(text):\n            if raw:\n                text = encode_header(text)\n            return text\n\n        sender = sender or self.settings.sender\n\n        if not isinstance(self.settings.server, str):\n            raise Exception('Server address not specified')\n        if not isinstance(sender, str):\n            raise Exception('Sender address not specified')\n\n        if not raw and attachments:\n            # Use multipart/mixed if there is attachments\n            payload_in = MIMEMultipart.MIMEMultipart('mixed')\n        elif raw:\n            # no encoding configuration for raw messages\n            if not isinstance(message, basestring):\n                message = message.read()\n            if isinstance(message, unicode):\n                text = message.encode('utf-8')\n            elif not encoding == 'utf-8':\n                text = message.decode(encoding).encode('utf-8')\n            else:\n                text = message\n            # No charset passed to avoid transport encoding\n            # NOTE: some unicode encoded strings will produce\n            # unreadable mail contents.\n            payload_in = MIMEText.MIMEText(text)\n        if to:\n            if not isinstance(to, (list, tuple)):\n                to = [to]\n        else:\n            raise Exception('Target receiver address not specified')\n        if cc:\n            if not isinstance(cc, (list, tuple)):\n                cc = [cc]\n        if bcc:\n            if not isinstance(bcc, (list, tuple)):\n                bcc = [bcc]\n        if message is None:\n            text = html = None\n        elif isinstance(message, (list, tuple)):\n            text, html = message\n        elif message.strip().startswith('<html') and \\\n                message.strip().endswith('</html>'):\n            text = self.settings.server == 'gae' and message or None\n            html = message\n        else:\n            text = message\n            html = None\n\n        if (not text is None or not html is None) and (not raw):\n\n            if not text is None:\n                if not isinstance(text, basestring):\n                    text = text.read()\n                if isinstance(text, unicode):\n                    text = text.encode('utf-8')\n                elif not encoding == 'utf-8':\n                    text = text.decode(encoding).encode('utf-8')\n            if not html is None:\n                if not isinstance(html, basestring):\n                    html = html.read()\n                if isinstance(html, unicode):\n                    html = html.encode('utf-8')\n                elif not encoding == 'utf-8':\n                    html = html.decode(encoding).encode('utf-8')\n\n            # Construct mime part only if needed\n            if text is not None and html:\n                # We have text and html we need multipart/alternative\n                attachment = MIMEMultipart.MIMEMultipart('alternative')\n                attachment.attach(MIMEText.MIMEText(text, _charset='utf-8'))\n                attachment.attach(\n                    MIMEText.MIMEText(html, 'html', _charset='utf-8'))\n            elif text is not None:\n                attachment = MIMEText.MIMEText(text, _charset='utf-8')\n            elif html:\n                attachment = \\\n                    MIMEText.MIMEText(html, 'html', _charset='utf-8')\n\n            if attachments:\n                # If there is attachments put text and html into\n                # multipart/mixed\n                payload_in.attach(attachment)\n            else:\n                # No attachments no multipart/mixed\n                payload_in = attachment\n\n        if (attachments is None) or raw:\n            pass\n        elif isinstance(attachments, (list, tuple)):\n            for attachment in attachments:\n                payload_in.attach(attachment)\n        else:\n            payload_in.attach(attachments)\n\n        #######################################################\n        #                      CIPHER                         #\n        #######################################################\n        cipher_type = cipher_type or self.settings.cipher_type\n        sign = sign if sign != None else self.settings.sign\n        sign_passphrase = sign_passphrase or self.settings.sign_passphrase\n        encrypt = encrypt if encrypt != None else self.settings.encrypt\n        #######################################################\n        #                       GPGME                         #\n        #######################################################\n        if cipher_type == 'gpg':\n            if self.settings.gpg_home:\n                # Set GNUPGHOME environment variable to set home of gnupg\n                import os\n                os.environ['GNUPGHOME'] = self.settings.gpg_home\n            if not sign and not encrypt:\n                self.error = \"No sign and no encrypt is set but cipher type to gpg\"\n                return False\n\n            # need a python-pyme package and gpgme lib\n            from pyme import core, errors\n            from pyme.constants.sig import mode\n            ############################################\n            #                   sign                   #\n            ############################################\n            if sign:\n                import string\n                core.check_version(None)\n                pin = string.replace(payload_in.as_string(), '\\n', '\\r\\n')\n                plain = core.Data(pin)\n                sig = core.Data()\n                c = core.Context()\n                c.set_armor(1)\n                c.signers_clear()\n                # search for signing key for From:\n                for sigkey in c.op_keylist_all(sender, 1):\n                    if sigkey.can_sign:\n                        c.signers_add(sigkey)\n                if not c.signers_enum(0):\n                    self.error = 'No key for signing [%s]' % sender\n                    return False\n                c.set_passphrase_cb(lambda x, y, z: sign_passphrase)\n                try:\n                    # make a signature\n                    c.op_sign(plain, sig, mode.DETACH)\n                    sig.seek(0, 0)\n                    # make it part of the email\n                    payload = MIMEMultipart.MIMEMultipart('signed',\n                                                          boundary=None,\n                                                          _subparts=None,\n                                                          **dict(\n                                                          micalg=\"pgp-sha1\",\n                                                          protocol=\"application/pgp-signature\"))\n                    # insert the origin payload\n                    payload.attach(payload_in)\n                    # insert the detached signature\n                    p = MIMEBase.MIMEBase(\"application\", 'pgp-signature')\n                    p.set_payload(sig.read())\n                    payload.attach(p)\n                    # it's just a trick to handle the no encryption case\n                    payload_in = payload\n                except errors.GPGMEError, ex:\n                    self.error = \"GPG error: %s\" % ex.getstring()\n                    return False\n            ############################################\n            #                  encrypt                 #\n            ############################################\n            if encrypt:\n                core.check_version(None)\n                plain = core.Data(payload_in.as_string())\n                cipher = core.Data()\n                c = core.Context()\n                c.set_armor(1)\n                # collect the public keys for encryption\n                recipients = []\n                rec = to[:]\n                if cc:\n                    rec.extend(cc)\n                if bcc:\n                    rec.extend(bcc)\n                for addr in rec:\n                    c.op_keylist_start(addr, 0)\n                    r = c.op_keylist_next()\n                    if r is None:\n                        self.error = 'No key for [%s]' % addr\n                        return False\n                    recipients.append(r)\n                try:\n                    # make the encryption\n                    c.op_encrypt(recipients, 1, plain, cipher)\n                    cipher.seek(0, 0)\n                    # make it a part of the email\n                    payload = MIMEMultipart.MIMEMultipart('encrypted',\n                                                          boundary=None,\n                                                          _subparts=None,\n                                                          **dict(protocol=\"application/pgp-encrypted\"))\n                    p = MIMEBase.MIMEBase(\"application\", 'pgp-encrypted')\n                    p.set_payload(\"Version: 1\\r\\n\")\n                    payload.attach(p)\n                    p = MIMEBase.MIMEBase(\"application\", 'octet-stream')\n                    p.set_payload(cipher.read())\n                    payload.attach(p)\n                except errors.GPGMEError, ex:\n                    self.error = \"GPG error: %s\" % ex.getstring()\n                    return False\n        #######################################################\n        #                       X.509                         #\n        #######################################################\n        elif cipher_type == 'x509':\n            if not sign and not encrypt:\n                self.error = \"No sign and no encrypt is set but cipher type to x509\"\n                return False\n            import os\n            x509_sign_keyfile = x509_sign_keyfile or\\\n                                      self.settings.x509_sign_keyfile\n\n            x509_sign_chainfile = x509_sign_chainfile or\\\n                                      self.settings.x509_sign_chainfile\n\n            x509_sign_certfile = x509_sign_certfile or\\\n                                      self.settings.x509_sign_certfile or\\\n                                      x509_sign_keyfile or\\\n                                      self.settings.x509_sign_certfile\n\n            # crypt certfiles could be a string or a list\n            x509_crypt_certfiles = x509_crypt_certfiles or\\\n                                      self.settings.x509_crypt_certfiles\n\n            x509_nocerts = x509_nocerts or\\\n                                      self.settings.x509_nocerts\n\n            # need m2crypto\n            try:\n                from M2Crypto import BIO, SMIME, X509\n            except Exception, e:\n                self.error = \"Can't load M2Crypto module\"\n                return False\n            msg_bio = BIO.MemoryBuffer(payload_in.as_string())\n            s = SMIME.SMIME()\n\n            # SIGN\n            if sign:\n                # key for signing\n                try:\n                    keyfile_bio = BIO.openfile(x509_sign_keyfile)\\\n                        if os.path.isfile(x509_sign_keyfile)\\\n                        else BIO.MemoryBuffer(x509_sign_keyfile)\n                    sign_certfile_bio = BIO.openfile(x509_sign_certfile)\\\n                        if os.path.isfile(x509_sign_certfile)\\\n                        else BIO.MemoryBuffer(x509_sign_certfile)\n                    s.load_key_bio(keyfile_bio, sign_certfile_bio,\n                                   callback=lambda x: sign_passphrase)\n                    if x509_sign_chainfile:\n                        sk = X509.X509_Stack()\n                        chain = X509.load_cert(x509_sign_chainfile)\\\n                            if os.path.isfile(x509_sign_chainfile)\\\n                            else X509.load_cert_string(x509_sign_chainfile)\n                        sk.push(chain)\n                        s.set_x509_stack(sk)\n                except Exception, e:\n                    self.error = \"Something went wrong on certificate / private key loading: <%s>\" % str(e)\n                    return False\n                try:\n                    if x509_nocerts:\n                        flags = SMIME.PKCS7_NOCERTS\n                    else:\n                        flags = 0\n                    if not encrypt:\n                        flags += SMIME.PKCS7_DETACHED\n                    p7 = s.sign(msg_bio, flags=flags)\n                    msg_bio = BIO.MemoryBuffer(payload_in.as_string(\n                    ))  # Recreate coz sign() has consumed it.\n                except Exception, e:\n                    self.error = \"Something went wrong on signing: <%s> %s\" % (\n                        str(e), str(flags))\n                    return False\n\n            # ENCRYPT\n            if encrypt:\n                try:\n                    sk = X509.X509_Stack()\n                    if not isinstance(x509_crypt_certfiles, (list, tuple)):\n                        x509_crypt_certfiles = [x509_crypt_certfiles]\n\n                    # make an encryption cert's stack\n                    for crypt_certfile in x509_crypt_certfiles:\n                        certfile = X509.load_cert(crypt_certfile)\\\n                             if os.path.isfile(crypt_certfile)\\\n                             else X509.load_cert_string(crypt_certfile)\n                        sk.push(certfile)\n                    s.set_x509_stack(sk)\n\n                    s.set_cipher(SMIME.Cipher('des_ede3_cbc'))\n                    tmp_bio = BIO.MemoryBuffer()\n                    if sign:\n                        s.write(tmp_bio, p7)\n                    else:\n                        tmp_bio.write(payload_in.as_string())\n                    p7 = s.encrypt(tmp_bio)\n                except Exception, e:\n                    self.error = \"Something went wrong on encrypting: <%s>\" % str(e)\n                    return False\n\n            # Final stage in sign and encryption\n            out = BIO.MemoryBuffer()\n            if encrypt:\n                s.write(out, p7)\n            else:\n                if sign:\n                    s.write(out, p7, msg_bio, SMIME.PKCS7_DETACHED)\n                else:\n                    out.write('\\r\\n')\n                    out.write(payload_in.as_string())\n            out.close()\n            st = str(out.read())\n            payload = message_from_string(st)\n        else:\n            # no cryptography process as usual\n            payload = payload_in\n\n        if from_address:\n            payload['From'] = encoded_or_raw(from_address.decode(encoding))\n        else:\n            payload['From'] = encoded_or_raw(sender.decode(encoding))\n        origTo = to[:]\n        if to:\n            payload['To'] = encoded_or_raw(', '.join(to).decode(encoding))\n        if reply_to:\n            payload['Reply-To'] = encoded_or_raw(reply_to.decode(encoding))\n        if cc:\n            payload['Cc'] = encoded_or_raw(', '.join(cc).decode(encoding))\n            to.extend(cc)\n        if bcc:\n            to.extend(bcc)\n        payload['Subject'] = encoded_or_raw(subject.decode(encoding))\n        payload['Date'] = email.utils.formatdate()\n        for k, v in headers.iteritems():\n            payload[k] = encoded_or_raw(v.decode(encoding))\n        result = {}\n        try:\n            if self.settings.server == 'logging':\n                logger.warn('email not sent\\n%s\\nFrom: %s\\nTo: %s\\nSubject: %s\\n\\n%s\\n%s\\n' %\n                            ('-' * 40, sender,\n                                ', '.join(to), subject,\n                                text or html, '-' * 40))\n            elif self.settings.server == 'gae':\n                xcc = dict()\n                if cc:\n                    xcc['cc'] = cc\n                if bcc:\n                    xcc['bcc'] = bcc\n                if reply_to:\n                    xcc['reply_to'] = reply_to\n                from google.appengine.api import mail\n                attachments = attachments and [mail.Attachment(\n                        a.my_filename,\n                        a.my_payload,\n                        contebt_id='<attachment-%s>' % k\n                        ) for k,a in enumerate(attachments) if not raw]\n                if attachments:\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), html=html,\n                        attachments=attachments, **xcc)\n                elif html and (not raw):\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), html=html, **xcc)\n                else:\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), **xcc)\n            else:\n                smtp_args = self.settings.server.split(':')\n                kwargs = dict(timeout=self.settings.timeout)\n                if self.settings.ssl:\n                    server = smtplib.SMTP_SSL(*smtp_args, **kwargs)\n                else:\n                    server = smtplib.SMTP(*smtp_args, **kwargs)\n                if self.settings.tls and not self.settings.ssl:\n                    server.ehlo(self.settings.hostname)\n                    server.starttls()\n                    server.ehlo(self.settings.hostname)\n                if self.settings.login:\n                    server.login(*self.settings.login.split(':', 1))\n                result = server.sendmail(\n                    sender, to, payload.as_string())\n                server.quit()\n        except Exception, e:\n            logger.warn('Mail.send failure:%s' % e)\n            self.result = result\n            self.error = e\n            return False\n        self.result = result\n        self.error = None\n        return True\n\n\nclass Recaptcha(DIV):\n\n    \"\"\"\n    Examples:\n        Use as::\n\n            form = FORM(Recaptcha(public_key='...',private_key='...'))\n\n        or::\n\n            form = SQLFORM(...)\n            form.append(Recaptcha(public_key='...',private_key='...'))\n\n    \"\"\"\n\n    API_SSL_SERVER = 'https://www.google.com/recaptcha/api'\n    API_SERVER = 'http://www.google.com/recaptcha/api'\n    VERIFY_SERVER = 'http://www.google.com/recaptcha/api/verify'\n\n    def __init__(self,\n                 request=None,\n                 public_key='',\n                 private_key='',\n                 use_ssl=False,\n                 error=None,\n                 error_message='invalid',\n                 label='Verify:',\n                 options='',\n                 comment='',\n                 ajax=False\n    ):\n        request = request or current.request\n        self.request_vars = request and request.vars or current.request.vars\n        self.remote_addr = request.env.remote_addr\n        self.public_key = public_key\n        self.private_key = private_key\n        self.use_ssl = use_ssl\n        self.error = error\n        self.errors = Storage()\n        self.error_message = error_message\n        self.components = []\n        self.attributes = {}\n        self.label = label\n        self.options = options\n        self.comment = comment\n        self.ajax = ajax\n\n    def _validate(self):\n\n        # for local testing:\n\n        recaptcha_challenge_field = \\\n            self.request_vars.recaptcha_challenge_field\n        recaptcha_response_field = \\\n            self.request_vars.recaptcha_response_field\n        private_key = self.private_key\n        remoteip = self.remote_addr\n        if not (recaptcha_response_field and recaptcha_challenge_field\n                and len(recaptcha_response_field)\n                and len(recaptcha_challenge_field)):\n            self.errors['captcha'] = self.error_message\n            return False\n        params = urllib.urlencode({\n            'privatekey': private_key,\n            'remoteip': remoteip,\n            'challenge': recaptcha_challenge_field,\n            'response': recaptcha_response_field,\n        })\n        request = urllib2.Request(\n            url=self.VERIFY_SERVER,\n            data=params,\n            headers={'Content-type': 'application/x-www-form-urlencoded',\n                     'User-agent': 'reCAPTCHA Python'})\n        httpresp = urllib2.urlopen(request)\n        return_values = httpresp.read().splitlines()\n        httpresp.close()\n        return_code = return_values[0]\n        if return_code == 'true':\n            del self.request_vars.recaptcha_challenge_field\n            del self.request_vars.recaptcha_response_field\n            self.request_vars.captcha = ''\n            return True\n        else:\n            # In case we get an error code, store it so we can get an error message\n            # from the /api/challenge URL as described in the reCAPTCHA api docs.\n            self.error = return_values[1]\n            self.errors['captcha'] = self.error_message\n            return False\n\n    def xml(self):\n        public_key = self.public_key\n        use_ssl = self.use_ssl\n        error_param = ''\n        if self.error:\n            error_param = '&error=%s' % self.error\n        if use_ssl:\n            server = self.API_SSL_SERVER\n        else:\n            server = self.API_SERVER\n        if not self.ajax:\n            captcha = DIV(\n                SCRIPT(\"var RecaptchaOptions = {%s};\" % self.options),\n                SCRIPT(_type=\"text/javascript\",\n                       _src=\"%s/challenge?k=%s%s\" % (server, public_key, error_param)),\n                TAG.noscript(\n                    IFRAME(\n                        _src=\"%s/noscript?k=%s%s\" % (\n                            server, public_key, error_param),\n                        _height=\"300\", _width=\"500\", _frameborder=\"0\"), BR(),\n                    INPUT(\n                        _type='hidden', _name='recaptcha_response_field',\n                        _value='manual_challenge')), _id='recaptcha')\n\n        else: #use Google's ajax interface, needed for LOADed components\n\n            url_recaptcha_js = \"%s/js/recaptcha_ajax.js\" % server\n            RecaptchaOptions = \"var RecaptchaOptions = {%s}\" % self.options\n            script = \"\"\"%(options)s;\n            jQuery.getScript('%(url)s',function() {\n                Recaptcha.create('%(public_key)s',\n                    'recaptcha',jQuery.extend(RecaptchaOptions,{'callback':Recaptcha.focus_response_field}))\n                }) \"\"\" % ({'options': RecaptchaOptions, 'url': url_recaptcha_js, 'public_key': public_key})\n            captcha = DIV(\n                SCRIPT(\n                    script,\n                    _type=\"text/javascript\",\n                ),\n                TAG.noscript(\n                    IFRAME(\n                        _src=\"%s/noscript?k=%s%s\" % (\n                            server, public_key, error_param),\n                        _height=\"300\", _width=\"500\", _frameborder=\"0\"), BR(),\n                    INPUT(\n                        _type='hidden', _name='recaptcha_response_field',\n                        _value='manual_challenge')), _id='recaptcha')\n\n        if not self.errors.captcha:\n            return XML(captcha).xml()\n        else:\n            captcha.append(DIV(self.errors['captcha'], _class='error'))\n            return XML(captcha).xml()\n\n\nclass Recaptcha2(DIV):\n    \"\"\"\n    Experimental:\n    Creates a DIV holding the newer Recaptcha from Google (v2)\n\n    Args:\n        request : the request. If not passed, uses current request\n        public_key : the public key Google gave you\n        private_key : the private key Google gave you\n        error_message : the error message to show if verification fails\n        label : the label to use\n        options (dict) : takes these parameters\n\n            - hl\n            - theme\n            - type\n            - tabindex\n            - callback\n            - expired-callback\n\n            see https://developers.google.com/recaptcha/docs/display for docs about those\n\n        comment : the comment\n\n    Examples:\n        Use as::\n\n            form = FORM(Recaptcha2(public_key='...',private_key='...'))\n\n        or::\n\n            form = SQLFORM(...)\n            form.append(Recaptcha2(public_key='...',private_key='...'))\n\n        to protect the login page instead, use::\n\n            from gluon.tools import Recaptcha2\n            auth.settings.captcha = Recaptcha2(request, public_key='...',private_key='...')\n\n    \"\"\"\n\n    API_URI = 'https://www.google.com/recaptcha/api.js'\n    VERIFY_SERVER = 'https://www.google.com/recaptcha/api/siteverify'\n\n    def __init__(self,\n                 request=None,\n                 public_key='',\n                 private_key='',\n                 error_message='invalid',\n                 label='Verify:',\n                 options=None,\n                 comment='',\n                 ):\n        request = request or current.request\n        self.request_vars = request and request.vars or current.request.vars\n        self.remote_addr = request.env.remote_addr\n        self.public_key = public_key\n        self.private_key = private_key\n        self.errors = Storage()\n        self.error_message = error_message\n        self.components = []\n        self.attributes = {}\n        self.label = label\n        self.options = options or {}\n        self.comment = comment\n\n    def _validate(self):\n        recaptcha_response_field = self.request_vars.pop('g-recaptcha-response', None)\n        remoteip = self.remote_addr\n        if not recaptcha_response_field:\n            self.errors['captcha'] = self.error_message\n            return False\n        params = urllib.urlencode({\n            'secret': self.private_key,\n            'remoteip': remoteip,\n            'response': recaptcha_response_field,\n        })\n        request = urllib2.Request(\n            url=self.VERIFY_SERVER,\n            data=params,\n            headers={'Content-type': 'application/x-www-form-urlencoded',\n                     'User-agent': 'reCAPTCHA Python'})\n        httpresp = urllib2.urlopen(request)\n        content = httpresp.read()\n        httpresp.close()\n        try:\n            response_dict = json_parser.loads(content)\n        except:\n            self.errors['captcha'] = self.error_message\n            return False\n        if response_dict.get('success', False):\n            self.request_vars.captcha = ''\n            return True\n        else:\n            self.errors['captcha'] = self.error_message\n            return False\n\n    def xml(self):\n        api_uri = self.API_URI\n        hl = self.options.pop('hl', None)\n        if hl:\n            api_uri = self.API_URI + '?hl=%s' % hl\n        public_key = self.public_key\n        self.options['sitekey'] = public_key\n        captcha = DIV(\n            SCRIPT(_src=api_uri, _async='', _defer=''),\n            DIV(_class=\"g-recaptcha\", data=self.options),\n            TAG.noscript(XML(\"\"\"\n<div style=\"width: 302px; height: 352px;\">\n<div style=\"width: 302px; height: 352px; position: relative;\">\n  <div style=\"width: 302px; height: 352px; position: absolute;\">\n    <iframe src=\"https://www.google.com/recaptcha/api/fallback?k=%(public_key)s\"\n            frameborder=\"0\" scrolling=\"no\"\n            style=\"width: 302px; height:352px; border-style: none;\">\n    </iframe>\n  </div>\n  <div style=\"width: 250px; height: 80px; position: absolute; border-style: none;\n              bottom: 21px; left: 25px; margin: 0px; padding: 0px; right: 25px;\">\n    <textarea id=\"g-recaptcha-response\" name=\"g-recaptcha-response\"\n              class=\"g-recaptcha-response\"\n              style=\"width: 250px; height: 80px; border: 1px solid #c1c1c1;\n                     margin: 0px; padding: 0px; resize: none;\" value=\"\">\n    </textarea>\n  </div>\n</div>\n</div>\"\"\" % dict(public_key=public_key))\n            )\n        )\n        if not self.errors.captcha:\n            return XML(captcha).xml()\n        else:\n            captcha.append(DIV(self.errors['captcha'], _class='error'))\n            return XML(captcha).xml()\n\n\n# this should only be used for captcha and perhaps not even for that\ndef addrow(form, a, b, c, style, _id, position=-1):\n    if style == \"divs\":\n        form[0].insert(position, DIV(DIV(LABEL(a), _class='w2p_fl'),\n                                     DIV(b, _class='w2p_fw'),\n                                     DIV(c, _class='w2p_fc'),\n                                     _id=_id))\n    elif style == \"table2cols\":\n        form[0].insert(position, TR(TD(LABEL(a), _class='w2p_fl'),\n                                    TD(c, _class='w2p_fc')))\n        form[0].insert(position + 1, TR(TD(b, _class='w2p_fw'),\n                                        _colspan=2, _id=_id))\n    elif style == \"ul\":\n        form[0].insert(position, LI(DIV(LABEL(a), _class='w2p_fl'),\n                                    DIV(b, _class='w2p_fw'),\n                                    DIV(c, _class='w2p_fc'),\n                                    _id=_id))\n    elif style == \"bootstrap\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label'),\n                                     DIV(b, SPAN(c, _class='inline-help'),\n                                         _class='controls'),\n                                     _class='control-group', _id=_id))\n    elif style == \"bootstrap3_inline\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label col-sm-3'),\n                                     DIV(b, SPAN(c, _class='help-block'),\n                                         _class='col-sm-9'),\n                                     _class='form-group', _id=_id))\n    elif style == \"bootstrap3_stacked\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label'),\n                                     b, SPAN(c, _class='help-block'),\n                                     _class='form-group', _id=_id))\n    else:\n        form[0].insert(position, TR(TD(LABEL(a), _class='w2p_fl'),\n                                    TD(b, _class='w2p_fw'),\n                                    TD(c, _class='w2p_fc'), _id=_id))\n\n\nclass Auth(object):\n\n    default_settings = dict(\n        hideerror=False,\n        password_min_length=4,\n        cas_maps=None,\n        reset_password_requires_verification=False,\n        registration_requires_verification=False,\n        registration_requires_approval=False,\n        bulk_register_enabled=False,\n        login_after_registration=False,\n        login_after_password_change=True,\n        alternate_requires_registration=False,\n        create_user_groups=\"user_%(id)s\",\n        everybody_group_id=None,\n        manager_actions={},\n        auth_manager_role=None,\n        two_factor_authentication_group = None,\n        login_captcha=None,\n        register_captcha=None,\n        pre_registration_div=None,\n        retrieve_username_captcha=None,\n        retrieve_password_captcha=None,\n        captcha=None,\n        prevent_open_redirect_attacks=True,\n        prevent_password_reset_attacks=True,\n        expiration=3600,            # one hour\n        long_expiration=3600 * 30 * 24,  # one month\n        remember_me_form=True,\n        allow_basic_login=False,\n        allow_basic_login_only=False,\n        on_failed_authentication=lambda x: redirect(x),\n        formstyle=None,\n        label_separator=None,\n        logging_enabled = True,\n        allow_delete_accounts=False,\n        password_field='password',\n        table_user_name='auth_user',\n        table_group_name='auth_group',\n        table_membership_name='auth_membership',\n        table_permission_name='auth_permission',\n        table_event_name='auth_event',\n        table_cas_name='auth_cas',\n        table_token_name='auth_token',\n        table_user=None,\n        table_group=None,\n        table_membership=None,\n        table_permission=None,\n        table_event=None,\n        table_cas=None,\n        showid=False,\n        use_username=False,\n        login_email_validate=True,\n        login_userfield=None,\n        multi_login=False,\n        logout_onlogout=None,\n        register_fields=None,\n        register_verify_password=True,\n        profile_fields=None,\n        email_case_sensitive=True,\n        username_case_sensitive=True,\n        update_fields=['email'],\n        ondelete=\"CASCADE\",\n        client_side=True,\n        renew_session_onlogin=True,\n        renew_session_onlogout=True,\n        keep_session_onlogin=True,\n        keep_session_onlogout=False,\n        wiki=Settings(),\n    )\n        # ## these are messages that can be customized\n    default_messages = dict(\n        login_button='Log In',\n        register_button='Sign Up',\n        password_reset_button='Request reset password',\n        password_change_button='Change password',\n        profile_save_button='Apply changes',\n        submit_button='Submit',\n        verify_password='Verify Password',\n        delete_label='Check to delete',\n        function_disabled='Function disabled',\n        access_denied='Insufficient privileges',\n        registration_verifying='Registration needs verification',\n        registration_pending='Registration is pending approval',\n        email_taken='This email already has an account',\n        invalid_username='Invalid username',\n        username_taken='Username already taken',\n        login_disabled='Login disabled by administrator',\n        logged_in='Logged in',\n        email_sent='Email sent',\n        unable_to_send_email='Unable to send email',\n        email_verified='Email verified',\n        logged_out='Logged out',\n        registration_successful='Registration successful',\n        invalid_email='Invalid email',\n        unable_send_email='Unable to send email',\n        invalid_login='Invalid login',\n        invalid_user='Invalid user',\n        invalid_password='Invalid password',\n        is_empty=\"Cannot be empty\",\n        mismatched_password=\"Password fields don't match\",\n        verify_email='Welcome %(username)s! Click on the link %(link)s to verify your email',\n        verify_email_subject='Email verification',\n        username_sent='Your username was emailed to you',\n        new_password_sent='A new password was emailed to you',\n        password_changed='Password changed',\n        retrieve_username='Your username is: %(username)s',\n        retrieve_username_subject='Username retrieve',\n        retrieve_password='Your password is: %(password)s',\n        retrieve_password_subject='Password retrieve',\n        reset_password='Click on the link %(link)s to reset your password',\n        reset_password_subject='Password reset',\n        bulk_invite_subject='Invitation to join%(site)s',\n        bulk_invite_body='You have been invited to join %(site)s, click %(link)s to complete the process',\n        invalid_reset_password='Invalid reset password',\n        profile_updated='Profile updated',\n        new_password='New password',\n        old_password='Old password',\n        group_description='Group uniquely assigned to user %(id)s',\n        register_log='User %(id)s Registered',\n        login_log='User %(id)s Logged-in',\n        login_failed_log=None,\n        logout_log='User %(id)s Logged-out',\n        profile_log='User %(id)s Profile updated',\n        verify_email_log='User %(id)s Verification email sent',\n        retrieve_username_log='User %(id)s Username retrieved',\n        retrieve_password_log='User %(id)s Password retrieved',\n        reset_password_log='User %(id)s Password reset',\n        change_password_log='User %(id)s Password changed',\n        add_group_log='Group %(group_id)s created',\n        del_group_log='Group %(group_id)s deleted',\n        add_membership_log=None,\n        del_membership_log=None,\n        has_membership_log=None,\n        add_permission_log=None,\n        del_permission_log=None,\n        has_permission_log=None,\n        impersonate_log='User %(id)s is impersonating %(other_id)s',\n        label_first_name='First name',\n        label_last_name='Last name',\n        label_username='Username',\n        label_email='E-mail',\n        label_password='Password',\n        label_registration_key='Registration key',\n        label_reset_password_key='Reset Password key',\n        label_registration_id='Registration identifier',\n        label_role='Role',\n        label_description='Description',\n        label_user_id='User ID',\n        label_group_id='Group ID',\n        label_name='Name',\n        label_table_name='Object or table name',\n        label_record_id='Record ID',\n        label_time_stamp='Timestamp',\n        label_client_ip='Client IP',\n        label_origin='Origin',\n        label_remember_me=\"Remember me (for 30 days)\",\n        verify_password_comment='please input your password again',\n    )\n\n    \"\"\"\n    Class for authentication, authorization, role based access control.\n\n    Includes:\n\n    - registration and profile\n    - login and logout\n    - username and password retrieval\n    - event logging\n    - role creation and assignment\n    - user defined group/role based permission\n\n    Args:\n\n        environment: is there for legacy but unused (awful)\n        db: has to be the database where to create tables for authentication\n        mailer: `Mail(...)` or None (no mailer) or True (make a mailer)\n        hmac_key: can be a hmac_key or hmac_key=Auth.get_or_create_key()\n        controller: (where is the user action?)\n        cas_provider: (delegate authentication to the URL, CAS2)\n\n    Authentication Example::\n\n        from gluon.contrib.utils import *\n        mail=Mail()\n        mail.settings.server='smtp.gmail.com:587'\n        mail.settings.sender='you@somewhere.com'\n        mail.settings.login='username:password'\n        auth=Auth(db)\n        auth.settings.mailer=mail\n        # auth.settings....=...\n        auth.define_tables()\n        def authentication():\n            return dict(form=auth())\n\n    Exposes:\n\n    - `http://.../{application}/{controller}/authentication/login`\n    - `http://.../{application}/{controller}/authentication/logout`\n    - `http://.../{application}/{controller}/authentication/register`\n    - `http://.../{application}/{controller}/authentication/verify_email`\n    - `http://.../{application}/{controller}/authentication/retrieve_username`\n    - `http://.../{application}/{controller}/authentication/retrieve_password`\n    - `http://.../{application}/{controller}/authentication/reset_password`\n    - `http://.../{application}/{controller}/authentication/profile`\n    - `http://.../{application}/{controller}/authentication/change_password`\n\n    On registration a group with role=new_user.id is created\n    and user is given membership of this group.\n\n    You can create a group with::\n\n        group_id=auth.add_group('Manager', 'can access the manage action')\n        auth.add_permission(group_id, 'access to manage')\n\n    Here \"access to manage\" is just a user defined string.\n    You can give access to a user::\n\n        auth.add_membership(group_id, user_id)\n\n    If user id is omitted, the logged in user is assumed\n\n    Then you can decorate any action::\n\n        @auth.requires_permission('access to manage')\n        def manage():\n            return dict()\n\n    You can restrict a permission to a specific table::\n\n        auth.add_permission(group_id, 'edit', db.sometable)\n        @auth.requires_permission('edit', db.sometable)\n\n    Or to a specific record::\n\n        auth.add_permission(group_id, 'edit', db.sometable, 45)\n        @auth.requires_permission('edit', db.sometable, 45)\n\n    If authorization is not granted calls::\n\n        auth.settings.on_failed_authorization\n\n    Other options::\n\n        auth.settings.mailer=None\n        auth.settings.expiration=3600 # seconds\n\n        ...\n\n        ### these are messages that can be customized\n        ...\n\n    \"\"\"\n\n    @staticmethod\n    def get_or_create_key(filename=None, alg='sha512'):\n        request = current.request\n        if not filename:\n            filename = os.path.join(request.folder, 'private', 'auth.key')\n        if os.path.exists(filename):\n            key = open(filename, 'r').read().strip()\n        else:\n            key = alg + ':' + web2py_uuid()\n            open(filename, 'w').write(key)\n        return key\n\n    def url(self, f=None, args=None, vars=None, scheme=False):\n        if args is None:\n            args = []\n        if vars is None:\n            vars = {}\n        return URL(c=self.settings.controller,\n                   f=f, args=args, vars=vars, scheme=scheme)\n\n    def here(self):\n        return URL(args=current.request.args, vars=current.request.get_vars)\n\n    def __init__(self, environment=None, db=None, mailer=True,\n                 hmac_key=None, controller='default', function='user',\n                 cas_provider=None, signature=True, secure=False,\n                 csrf_prevention=True, propagate_extension=None,\n                 url_index=None):\n\n        ## next two lines for backward compatibility\n        if not db and environment and isinstance(environment, DAL):\n            db = environment\n        self.db = db\n        self.environment = current\n        self.csrf_prevention = csrf_prevention\n        request = current.request\n        session = current.session\n        auth = session.auth\n        self.user_groups = auth and auth.user_groups or {}\n        if secure:\n            request.requires_https()\n        now = request.now\n        # if we have auth info\n        #    if not expired it, used it\n        #    if expired, clear the session\n        # else, only clear auth info in the session\n        if auth:\n            delta = datetime.timedelta(days=0, seconds=auth.expiration)\n            if auth.last_visit and auth.last_visit + delta > now:\n                self.user = auth.user\n                # this is a trick to speed up sessions to avoid many writes\n                if (now - auth.last_visit).seconds > (auth.expiration / 10):\n                    auth.last_visit = request.now\n            else:\n                self.user = None\n                if session.auth:\n                    del session.auth\n                session.renew(clear_session=True)\n        else:\n            self.user = None\n            if session.auth:\n                del session.auth\n        # ## what happens after login?\n\n        url_index = url_index or URL(controller, 'index')\n        url_login = URL(controller, function, args='login',\n                        extension = propagate_extension)\n        # ## what happens after registration?\n\n        settings = self.settings = Settings()\n        settings.update(Auth.default_settings)\n        settings.update(\n            cas_domains=[request.env.http_host],\n            enable_tokens=False,\n            cas_provider=cas_provider,\n            cas_actions=dict(login='login',\n                             validate='validate',\n                             servicevalidate='serviceValidate',\n                             proxyvalidate='proxyValidate',\n                             logout='logout'),\n            extra_fields={},\n            actions_disabled=[],\n            controller=controller,\n            function=function,\n            login_url=url_login,\n            logged_url=URL(controller, function, args='profile'),\n            download_url=URL(controller, 'download'),\n            mailer=(mailer is True) and Mail() or mailer,\n            on_failed_authorization = URL(controller, function, args='not_authorized'),\n            login_next = url_index,\n            login_onvalidation = [],\n            login_onaccept = [],\n            login_onfail = [],\n            login_methods = [self],\n            login_form = self,\n            logout_next = url_index,\n            logout_onlogout = None,\n            register_next = url_index,\n            register_onvalidation = [],\n            register_onaccept = [],\n            verify_email_next = url_login,\n            verify_email_onaccept = [],\n            profile_next = url_index,\n            profile_onvalidation = [],\n            profile_onaccept = [],\n            retrieve_username_next = url_index,\n            retrieve_password_next = url_index,\n            request_reset_password_next = url_login,\n            reset_password_next = url_index,\n            change_password_next = url_index,\n            change_password_onvalidation = [],\n            change_password_onaccept = [],\n            retrieve_password_onvalidation = [],\n            request_reset_password_onvalidation = [],\n            request_reset_password_onaccept = [],\n            reset_password_onvalidation = [],\n            reset_password_onaccept = [],\n            hmac_key = hmac_key,\n            formstyle = current.response.formstyle,\n            label_separator = current.response.form_label_separator\n        )\n        settings.lock_keys = True\n        # ## these are messages that can be customized\n        messages = self.messages = Messages(current.T)\n        messages.update(Auth.default_messages)\n        messages.update(ajax_failed_authentication=\n                        DIV(H4('NOT AUTHORIZED'),\n                            'Please ',\n                            A('login',\n                              _href=self.settings.login_url +\n                                    ('?_next=' + urllib.quote(current.request.env.http_web2py_component_location))\n                              if current.request.env.http_web2py_component_location else ''),\n                            ' to view this content.',\n                            _class='not-authorized alert alert-block'))\n        messages.lock_keys = True\n\n        # for \"remember me\" option\n        response = current.response\n        if auth and auth.remember_me:\n            # when user wants to be logged in for longer\n            response.session_cookie_expires = auth.expiration\n        if signature:\n            self.define_signature()\n        else:\n            self.signature = None\n\n    def get_vars_next(self):\n        next = current.request.vars._next\n        if isinstance(next, (list, tuple)):\n            next = next[0]\n        return next\n\n    def _get_user_id(self):\n        \"\"\"accessor for auth.user_id\"\"\"\n        return self.user and self.user.id or None\n\n    user_id = property(_get_user_id, doc=\"user.id or None\")\n\n    def table_user(self):\n        return self.db[self.settings.table_user_name]\n\n    def table_group(self):\n        return self.db[self.settings.table_group_name]\n\n    def table_membership(self):\n        return self.db[self.settings.table_membership_name]\n\n    def table_permission(self):\n        return self.db[self.settings.table_permission_name]\n\n    def table_event(self):\n        return self.db[self.settings.table_event_name]\n\n    def table_cas(self):\n        return self.db[self.settings.table_cas_name]\n\n    def table_token(self):\n        return self.db[self.settings.table_token_name]\n\n    def _HTTP(self, *a, **b):\n        \"\"\"\n        only used in lambda: self._HTTP(404)\n        \"\"\"\n\n        raise HTTP(*a, **b)\n\n    def __call__(self):\n        \"\"\"\n        Example:\n            Use as::\n\n                def authentication():\n                    return dict(form=auth())\n\n        \"\"\"\n\n        request = current.request\n        args = request.args\n        if not args:\n            redirect(self.url(args='login', vars=request.vars))\n        elif args[0] in self.settings.actions_disabled:\n            raise HTTP(404)\n        if args[0] in ('login', 'logout', 'register', 'verify_email',\n                       'retrieve_username', 'retrieve_password',\n                       'reset_password', 'request_reset_password',\n                       'change_password', 'profile', 'groups',\n                       'impersonate', 'not_authorized', 'confirm_registration', \n                       'bulk_register','manage_tokens'):\n            if len(request.args) >= 2 and args[0] == 'impersonate':\n                return getattr(self, args[0])(request.args[1])\n            else:\n                return getattr(self, args[0])()\n        elif args[0] == 'cas' and not self.settings.cas_provider:\n            if args(1) == self.settings.cas_actions['login']:\n                return self.cas_login(version=2)\n            elif args(1) == self.settings.cas_actions['validate']:\n                return self.cas_validate(version=1)\n            elif args(1) == self.settings.cas_actions['servicevalidate']:\n                return self.cas_validate(version=2, proxy=False)\n            elif args(1) == self.settings.cas_actions['proxyvalidate']:\n                return self.cas_validate(version=2, proxy=True)\n            elif args(1) == self.settings.cas_actions['logout']:\n                return self.logout(next=request.vars.service or DEFAULT)\n        else:\n            raise HTTP(404)\n\n    def navbar(self, prefix='Welcome', action=None,\n               separators=(' [ ', ' | ', ' ] '), user_identifier=DEFAULT,\n               referrer_actions=DEFAULT, mode='default'):\n        \"\"\" Navbar with support for more templates\n        This uses some code from the old navbar.\n\n        Args:\n            mode: see options for list of\n\n        \"\"\"\n        items = []  # Hold all menu items in a list\n        self.bar = ''  # The final\n        T = current.T\n        referrer_actions = [] if not referrer_actions else referrer_actions\n        if not action:\n            action = self.url(self.settings.function)\n\n        request = current.request\n        if URL() == action:\n            next = ''\n        else:\n            next = '?_next=' + urllib.quote(URL(args=request.args,\n                                                vars=request.get_vars))\n        href = lambda function: '%s/%s%s' % (action, function, next\n                                             if referrer_actions is DEFAULT\n                                             or function in referrer_actions\n                                             else '')\n        if isinstance(prefix, str):\n            prefix = T(prefix)\n        if prefix:\n            prefix = prefix.strip() + ' '\n\n        def Anr(*a, **b):\n            b['_rel'] = 'nofollow'\n            return A(*a, **b)\n\n        if self.user_id:  # User is logged in\n            logout_next = self.settings.logout_next\n            items.append({'name': T('Log Out'),\n                          'href': '%s/logout?_next=%s' % (action,\n                                                          urllib.quote(\n                                                          logout_next)),\n                          'icon': 'icon-off'})\n            if not 'profile' in self.settings.actions_disabled:\n                items.append({'name': T('Profile'), 'href': href('profile'),\n                              'icon': 'icon-user'})\n            if not 'change_password' in self.settings.actions_disabled:\n                items.append({'name': T('Password'),\n                              'href': href('change_password'),\n                              'icon': 'icon-lock'})\n\n            if user_identifier is DEFAULT:\n                user_identifier = '%(first_name)s'\n            if callable(user_identifier):\n                user_identifier = user_identifier(self.user)\n            elif ((isinstance(user_identifier, str) or\n                  type(user_identifier).__name__ == 'lazyT') and\n                  re.search(r'%\\(.+\\)s', user_identifier)):\n                user_identifier = user_identifier % self.user\n            if not user_identifier:\n                user_identifier = ''\n        else:  # User is not logged in\n            items.append({'name': T('Log In'), 'href': href('login'),\n                          'icon': 'icon-off'})\n            if not 'register' in self.settings.actions_disabled:\n                items.append({'name': T('Sign Up'), 'href': href('register'),\n                              'icon': 'icon-user'})\n            if not 'request_reset_password' in self.settings.actions_disabled:\n                items.append({'name': T('Lost password?'),\n                              'href': href('request_reset_password'),\n                              'icon': 'icon-lock'})\n            if (self.settings.use_username and not\n                    'retrieve_username' in self.settings.actions_disabled):\n                items.append({'name': T('Forgot username?'),\n                             'href': href('retrieve_username'),\n                             'icon': 'icon-edit'})\n\n        def menu():  # For inclusion in MENU\n            self.bar = [(items[0]['name'], False, items[0]['href'], [])]\n            del items[0]\n            for item in items:\n                self.bar[0][3].append((item['name'], False, item['href']))\n\n        def bootstrap3():  # Default web2py scaffolding\n            def rename(icon): return icon+' '+icon.replace('icon', 'glyphicon')\n            self.bar = UL(LI(Anr(I(_class=rename('icon '+items[0]['icon'])),\n                                 ' ' + items[0]['name'],\n                                 _href=items[0]['href'])), _class='dropdown-menu')\n            del items[0]\n            for item in items:\n                self.bar.insert(-1, LI(Anr(I(_class=rename('icon '+item['icon'])),\n                                           ' ' + item['name'],\n                                           _href=item['href'])))\n            self.bar.insert(-1, LI('', _class='divider'))\n            if self.user_id:\n                self.bar = LI(Anr(prefix, user_identifier,\n                                  _href='#', _class=\"dropdown-toggle\",\n                                  data={'toggle': 'dropdown'}),\n                              self.bar, _class='dropdown')\n            else:\n                self.bar = LI(Anr(T('Log In'),\n                                  _href='#', _class=\"dropdown-toggle\",\n                                  data={'toggle': 'dropdown'}), self.bar,\n                              _class='dropdown')\n\n        def bare():\n            \"\"\" In order to do advanced customization we only need the\n            prefix, the user_identifier and the href attribute of items\n\n            Examples:\n                Use as::\n\n                # in module custom_layout.py\n                from gluon import *\n                def navbar(auth_navbar):\n                    bar = auth_navbar\n                    user = bar[\"user\"]\n\n                    if not user:\n                        btn_login = A(current.T(\"Login\"),\n                                      _href=bar[\"login\"],\n                                      _class=\"btn btn-success\",\n                                      _rel=\"nofollow\")\n                        btn_register = A(current.T(\"Sign up\"),\n                                         _href=bar[\"register\"],\n                                         _class=\"btn btn-primary\",\n                                         _rel=\"nofollow\")\n                        return DIV(btn_register, btn_login, _class=\"btn-group\")\n                    else:\n                        toggletext = \"%s back %s\" % (bar[\"prefix\"], user)\n                        toggle = A(toggletext,\n                                   _href=\"#\",\n                                   _class=\"dropdown-toggle\",\n                                   _rel=\"nofollow\",\n                                   **{\"_data-toggle\": \"dropdown\"})\n                        li_profile = LI(A(I(_class=\"icon-user\"), ' ',\n                                          current.T(\"Account details\"),\n                                          _href=bar[\"profile\"], _rel=\"nofollow\"))\n                        li_custom = LI(A(I(_class=\"icon-book\"), ' ',\n                                         current.T(\"My Agenda\"),\n                                         _href=\"#\", rel=\"nofollow\"))\n                        li_logout = LI(A(I(_class=\"icon-off\"), ' ',\n                                         current.T(\"logout\"),\n                                         _href=bar[\"logout\"], _rel=\"nofollow\"))\n                        dropdown = UL(li_profile,\n                                      li_custom,\n                                      LI('', _class=\"divider\"),\n                                      li_logout,\n                                      _class=\"dropdown-menu\", _role=\"menu\")\n\n                        return LI(toggle, dropdown, _class=\"dropdown\")\n\n                # in models db.py\n                import custom_layout as custom\n\n                # in layout.html\n                <ul id=\"navbar\" class=\"nav pull-right\">\n                    {{='auth' in globals() and \\\n                      custom.navbar(auth.navbar(mode='bare')) or ''}}</ul>\n\n            \"\"\"\n            bare = {}\n\n            bare['prefix'] = prefix\n            bare['user'] = user_identifier if self.user_id else None\n\n            for i in items:\n                if i['name'] == T('Log In'):\n                    k = 'login'\n                elif i['name'] == T('Sign Up'):\n                    k = 'register'\n                elif i['name'] == T('Lost password?'):\n                    k = 'request_reset_password'\n                elif i['name'] == T('Forgot username?'):\n                    k = 'retrieve_username'\n                elif i['name'] == T('Log Out'):\n                    k = 'logout'\n                elif i['name'] == T('Profile'):\n                    k = 'profile'\n                elif i['name'] == T('Password'):\n                    k = 'change_password'\n\n                bare[k] = i['href']\n\n            self.bar = bare\n\n        options = {'asmenu': menu,\n                   'dropdown': bootstrap3,\n                   'bare': bare\n                   }  # Define custom modes.\n\n        if mode in options and callable(options[mode]):\n            options[mode]()\n        else:\n            s1, s2, s3 = separators\n            if self.user_id:\n                self.bar = SPAN(prefix, user_identifier, s1,\n                                Anr(items[0]['name'],\n                                _href=items[0]['href']), s3,\n                                _class='auth_navbar')\n            else:\n                self.bar = SPAN(s1, Anr(items[0]['name'],\n                                _href=items[0]['href']), s3,\n                                _class='auth_navbar')\n            for item in items[1:]:\n                self.bar.insert(-1, s2)\n                self.bar.insert(-1, Anr(item['name'], _href=item['href']))\n\n        return self.bar\n\n    def __get_migrate(self, tablename, migrate=True):\n\n        if type(migrate).__name__ == 'str':\n            return (migrate + tablename + '.table')\n        elif migrate == False:\n            return False\n        else:\n            return True\n\n    def enable_record_versioning(self,\n                                 tables,\n                                 archive_db=None,\n                                 archive_names='%(tablename)s_archive',\n                                 current_record='current_record',\n                                 current_record_label=None):\n        \"\"\"\n        Used to enable full record versioning (including auth tables)::\n\n            auth = Auth(db)\n            auth.define_tables(signature=True)\n            # define our own tables\n            db.define_table('mything',Field('name'),auth.signature)\n            auth.enable_record_versioning(tables=db)\n\n        tables can be the db (all table) or a list of tables.\n        only tables with modified_by and modified_on fiels (as created\n        by auth.signature) will have versioning. Old record versions will be\n        in table 'mything_archive' automatically defined.\n\n        when you enable enable_record_versioning, records are never\n        deleted but marked with is_active=False.\n\n        enable_record_versioning enables a common_filter for\n        every table that filters out records with is_active = False\n\n        Note:\n            If you use auth.enable_record_versioning,\n            do not use auth.archive or you will end up with duplicates.\n            auth.archive does explicitly what enable_record_versioning\n            does automatically.\n\n        \"\"\"\n        current_record_label = current_record_label or current.T(\n            current_record.replace('_', ' ').title())\n        for table in tables:\n            fieldnames = table.fields()\n            if ('id' in fieldnames and\n                'modified_on' in fieldnames and\n                not current_record in fieldnames):\n                table._enable_record_versioning(\n                    archive_db=archive_db,\n                    archive_name=archive_names,\n                    current_record=current_record,\n                    current_record_label=current_record_label)\n\n    def define_signature(self):\n        db = self.db\n        settings = self.settings\n        request = current.request\n        T = current.T\n        reference_user = 'reference %s' % settings.table_user_name\n\n        def lazy_user(auth=self):\n            return auth.user_id\n\n        def represent(id, record=None, s=settings):\n            try:\n                user = s.table_user(id)\n                return '%s %s' % (user.get(\"first_name\", user.get(\"email\")),\n                                  user.get(\"last_name\", ''))\n            except:\n                return id\n        ondelete = self.settings.ondelete\n        self.signature = Table(\n            self.db, 'auth_signature',\n            Field('is_active', 'boolean',\n                  default=True,\n                  readable=False, writable=False,\n                  label=T('Is Active')),\n            Field('created_on', 'datetime',\n                  default=request.now,\n                  writable=False, readable=False,\n                  label=T('Created On')),\n            Field('created_by',\n                  reference_user,\n                  default=lazy_user, represent=represent,\n                  writable=False, readable=False,\n                  label=T('Created By'), ondelete=ondelete),\n            Field('modified_on', 'datetime',\n                  update=request.now, default=request.now,\n                  writable=False, readable=False,\n                  label=T('Modified On')),\n            Field('modified_by',\n                  reference_user, represent=represent,\n                  default=lazy_user, update=lazy_user,\n                  writable=False, readable=False,\n                  label=T('Modified By'),  ondelete=ondelete))\n\n    def define_tables(self, username=None, signature=None, enable_tokens=False,\n                      migrate=None, fake_migrate=None):\n        \"\"\"\n        To be called unless tables are defined manually\n\n        Examples:\n            Use as::\n\n                # defines all needed tables and table files\n                # 'myprefix_auth_user.table', ...\n                auth.define_tables(migrate='myprefix_')\n\n                # defines all needed tables without migration/table files\n                auth.define_tables(migrate=False)\n\n        \"\"\"\n\n        db = self.db\n        if migrate is None:\n            migrate = db._migrate\n        if fake_migrate is None:\n            fake_migrate = db._fake_migrate\n        settings = self.settings\n        if username is None:\n            username = settings.use_username\n        else:\n            settings.use_username = username\n        settings.enable_tokens = enable_tokens\n        if not self.signature:\n            self.define_signature()\n        if signature == True:\n            signature_list = [self.signature]\n        elif not signature:\n            signature_list = []\n        elif isinstance(signature, Table):\n            signature_list = [signature]\n        else:\n            signature_list = signature\n        is_not_empty = IS_NOT_EMPTY(error_message=self.messages.is_empty)\n        is_crypted = CRYPT(key=settings.hmac_key,\n                           min_length=settings.password_min_length)\n        is_unique_email = [\n            IS_EMAIL(error_message=self.messages.invalid_email),\n            IS_NOT_IN_DB(db, '%s.email' % settings.table_user_name,\n                         error_message=self.messages.email_taken)]\n        if not settings.email_case_sensitive:\n            is_unique_email.insert(1, IS_LOWER())\n        if not settings.table_user_name in db.tables:\n            passfield = settings.password_field\n            extra_fields = settings.extra_fields.get(\n                settings.table_user_name, []) + signature_list\n            if username or settings.cas_provider:\n                is_unique_username = \\\n                    [IS_MATCH('[\\w\\.\\-]+', strict=True,\n                              error_message=self.messages.invalid_username),\n                     IS_NOT_IN_DB(db, '%s.username' % settings.table_user_name,\n                                  error_message=self.messages.username_taken)]\n                if not settings.username_case_sensitive:\n                    is_unique_username.insert(1, IS_LOWER())\n                db.define_table(\n                    settings.table_user_name,\n                    Field('first_name', length=128, default='',\n                          label=self.messages.label_first_name,\n                          requires=is_not_empty),\n                    Field('last_name', length=128, default='',\n                          label=self.messages.label_last_name,\n                          requires=is_not_empty),\n                    Field('email', length=512, default='',\n                          label=self.messages.label_email,\n                          requires=is_unique_email),\n                    Field('username', length=128, default='',\n                          label=self.messages.label_username,\n                          requires=is_unique_username),\n                    Field(passfield, 'password', length=512,\n                          readable=False, label=self.messages.label_password,\n                          requires=[is_crypted]),\n                    Field('registration_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_key),\n                    Field('reset_password_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_reset_password_key),\n                    Field('registration_id', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_id),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(settings.table_user_name,\n                                                   migrate),\n                        fake_migrate=fake_migrate,\n                        format='%(username)s'))\n            else:\n                db.define_table(\n                    settings.table_user_name,\n                    Field('first_name', length=128, default='',\n                          label=self.messages.label_first_name,\n                          requires=is_not_empty),\n                    Field('last_name', length=128, default='',\n                          label=self.messages.label_last_name,\n                          requires=is_not_empty),\n                    Field('email', length=512, default='',\n                          label=self.messages.label_email,\n                          requires=is_unique_email),\n                    Field(passfield, 'password', length=512,\n                          readable=False, label=self.messages.label_password,\n                          requires=[is_crypted]),\n                    Field('registration_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_key),\n                    Field('reset_password_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_reset_password_key),\n                    Field('registration_id', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_id),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(settings.table_user_name,\n                                                   migrate),\n                        fake_migrate=fake_migrate,\n                        format='%(first_name)s %(last_name)s (%(id)s)'))\n        reference_table_user = 'reference %s' % settings.table_user_name\n        if not settings.table_group_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_group_name, []) + signature_list\n            db.define_table(\n                settings.table_group_name,\n                Field('role', length=512, default='',\n                      label=self.messages.label_role,\n                      requires=IS_NOT_IN_DB(db, '%s.role' % settings.table_group_name)),\n                Field('description', 'text',\n                      label=self.messages.label_description),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_group_name, migrate),\n                    fake_migrate=fake_migrate,\n                    format='%(role)s (%(id)s)'))\n        reference_table_group = 'reference %s' % settings.table_group_name\n        if not settings.table_membership_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_membership_name, []) + signature_list\n            db.define_table(\n                settings.table_membership_name,\n                Field('user_id', reference_table_user,\n                      label=self.messages.label_user_id),\n                Field('group_id', reference_table_group,\n                      label=self.messages.label_group_id),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_membership_name, migrate),\n                    fake_migrate=fake_migrate))\n        if not settings.table_permission_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_permission_name, []) + signature_list\n            db.define_table(\n                settings.table_permission_name,\n                Field('group_id', reference_table_group,\n                      label=self.messages.label_group_id),\n                Field('name', default='default', length=512,\n                      label=self.messages.label_name,\n                      requires=is_not_empty),\n                Field('table_name', length=512,\n                      label=self.messages.label_table_name),\n                Field('record_id', 'integer', default=0,\n                      label=self.messages.label_record_id,\n                      requires=IS_INT_IN_RANGE(0, 10 ** 9)),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_permission_name, migrate),\n                    fake_migrate=fake_migrate))\n        if not settings.table_event_name in db.tables:\n            db.define_table(\n                settings.table_event_name,\n                Field('time_stamp', 'datetime',\n                      default=current.request.now,\n                      label=self.messages.label_time_stamp),\n                Field('client_ip',\n                      default=current.request.client,\n                      label=self.messages.label_client_ip),\n                Field('user_id', reference_table_user, default=None,\n                      label=self.messages.label_user_id),\n                Field('origin', default='auth', length=512,\n                      label=self.messages.label_origin,\n                      requires=is_not_empty),\n                Field('description', 'text', default='',\n                      label=self.messages.label_description,\n                      requires=is_not_empty),\n                *settings.extra_fields.get(settings.table_event_name, []),\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_event_name, migrate),\n                    fake_migrate=fake_migrate))\n        now = current.request.now\n        if settings.cas_domains:\n            if not settings.table_cas_name in db.tables:\n                db.define_table(\n                    settings.table_cas_name,\n                    Field('user_id', reference_table_user, default=None,\n                          label=self.messages.label_user_id),\n                    Field('created_on', 'datetime', default=now),\n                    Field('service', requires=IS_URL()),\n                    Field('ticket'),\n                    Field('renew', 'boolean', default=False),\n                    *settings.extra_fields.get(settings.table_cas_name, []),\n                    **dict(\n                        migrate=self.__get_migrate(\n                            settings.table_cas_name, migrate),\n                        fake_migrate=fake_migrate))\n        if settings.enable_tokens:\n            extra_fields = settings.extra_fields.get(\n                settings.table_token_name, []) + signature_list\n            if not settings.table_token_name in db.tables:\n                db.define_table(\n                    settings.table_token_name,\n                    Field('user_id', reference_table_user, default=None,\n                          label=self.messages.label_user_id),\n                    Field('expires_on', 'datetime', default=datetime.datetime(2999,12,31)),\n                    Field('token',writable=False,default=web2py_uuid(),unique=True),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(\n                            settings.table_token_name, migrate),\n                        fake_migrate=fake_migrate))\n        if not db._lazy_tables:\n            settings.table_user = db[settings.table_user_name]\n            settings.table_group = db[settings.table_group_name]\n            settings.table_membership = db[settings.table_membership_name]\n            settings.table_permission = db[settings.table_permission_name]\n            settings.table_event = db[settings.table_event_name]\n            if settings.cas_domains:\n                settings.table_cas = db[settings.table_cas_name]\n\n        if settings.cas_provider:  # THIS IS NOT LAZY\n            settings.actions_disabled = \\\n                ['profile', 'register', 'change_password',\n                 'request_reset_password', 'retrieve_username']\n            from gluon.contrib.login_methods.cas_auth import CasAuth\n            maps = settings.cas_maps\n            if not maps:\n                table_user = self.table_user()\n                maps = dict((name, lambda v, n=name: v.get(n, None)) for name in\n                            table_user.fields if name != 'id'\n                            and table_user[name].readable)\n                maps['registration_id'] = \\\n                    lambda v, p=settings.cas_provider: '%s/%s' % (p, v['user'])\n            actions = [settings.cas_actions['login'],\n                       settings.cas_actions['servicevalidate'],\n                       settings.cas_actions['logout']]\n            settings.login_form = CasAuth(\n                casversion=2,\n                urlbase=settings.cas_provider,\n                actions=actions,\n                maps=maps)\n        return self\n\n    def log_event(self, description, vars=None, origin='auth'):\n        \"\"\"\n        Examples:\n            Use as::\n\n                auth.log_event(description='this happened', origin='auth')\n\n        \"\"\"\n        if not self.settings.logging_enabled or not description:\n            return\n        elif self.is_logged_in():\n            user_id = self.user.id\n        else:\n            user_id = None  # user unknown\n        vars = vars or {}\n        # log messages should not be translated\n        if type(description).__name__ == 'lazyT':\n            description = description.m\n        self.table_event().insert(\n            description=str(description % vars),\n            origin=origin, user_id=user_id)\n\n    def get_or_create_user(self, keys, update_fields=['email'],\n                           login=True, get=True):\n        \"\"\"\n        Used for alternate login methods:\n        If the user exists already then password is updated.\n        If the user doesn't yet exist, then they are created.\n        \"\"\"\n        table_user = self.table_user()\n        user = None\n        checks = []\n        # make a guess about who this user is\n        for fieldname in ['registration_id', 'username', 'email']:\n            if fieldname in table_user.fields() and \\\n                    keys.get(fieldname, None):\n                checks.append(fieldname)\n                value = keys[fieldname]\n                user = table_user(**{fieldname: value})\n                if user:\n                    break\n        if not checks:\n            return None\n        if not 'registration_id' in keys:\n            keys['registration_id'] = keys[checks[0]]\n        # if we think we found the user but registration_id does not match,\n        # make new user\n        if 'registration_id' in checks \\\n                and user \\\n                and user.registration_id \\\n                and ('registration_id' not in keys or user.registration_id != str(keys['registration_id'])):\n            user = None  # THINK MORE ABOUT THIS? DO WE TRUST OPENID PROVIDER?\n        if user:\n            if not get:\n                # added for register_bare to avoid overwriting users\n                return None\n            update_keys = dict(registration_id=keys['registration_id'])\n            for key in update_fields:\n                if key in keys:\n                    update_keys[key] = keys[key]\n            user.update_record(**update_keys)\n        elif checks:\n            if not 'first_name' in keys and 'first_name' in table_user.fields:\n                guess = keys.get('email', 'anonymous').split('@')[0]\n                keys['first_name'] = keys.get('username', guess)\n            user_id = table_user.insert(**table_user._filter_fields(keys))\n            user = table_user[user_id]\n            if self.settings.create_user_groups:\n                group_id = self.add_group(\n                    self.settings.create_user_groups % user)\n                self.add_membership(group_id, user_id)\n            if self.settings.everybody_group_id:\n                self.add_membership(self.settings.everybody_group_id, user_id)\n            if login:\n                self.user = user\n        return user\n\n    def basic(self, basic_auth_realm=False):\n        \"\"\"\n        Performs basic login.\n\n        Args:\n            basic_auth_realm: optional basic http authentication realm. Can take\n                str or unicode or function or callable or boolean.\n\n        reads current.request.env.http_authorization\n        and returns basic_allowed,basic_accepted,user.\n\n        if basic_auth_realm is defined is a callable it's return value\n        is used to set the basic authentication realm, if it's a string\n        its content is used instead.  Otherwise basic authentication realm\n        is set to the application name.\n        If basic_auth_realm is None or False (the default) the behavior\n        is to skip sending any challenge.\n\n        \"\"\"\n        if not self.settings.allow_basic_login:\n            return (False, False, False)\n        basic = current.request.env.http_authorization\n        if basic_auth_realm:\n            if callable(basic_auth_realm):\n                basic_auth_realm = basic_auth_realm()\n            elif isinstance(basic_auth_realm, (unicode, str)):\n                basic_realm = unicode(basic_auth_realm)\n            elif basic_auth_realm is True:\n                basic_realm = u'' + current.request.application\n            http_401 = HTTP(401, u'Not Authorized', **{'WWW-Authenticate': u'Basic realm=\"' + basic_realm + '\"'})\n        if not basic or not basic[:6].lower() == 'basic ':\n            if basic_auth_realm:\n                raise http_401\n            return (True, False, False)\n        (username, sep, password) = base64.b64decode(basic[6:]).partition(':')\n        is_valid_user = sep and self.login_bare(username, password)\n        if not is_valid_user and basic_auth_realm:\n            raise http_401\n        return (True, True, is_valid_user)\n\n    def login_user(self, user):\n        \"\"\"\n        Logins the `user = db.auth_user(id)`\n        \"\"\"\n        from gluon.settings import global_settings\n        if global_settings.web2py_runtime_gae:\n            user = Row(self.table_user()._filter_fields(user, id=True))\n            delattr(user, 'password')\n        else:\n            user = Row(user)\n            for key, value in user.items():\n                if callable(value) or key == 'password':\n                    delattr(user, key)\n        if self.settings.renew_session_onlogin:\n            current.session.renew(clear_session=not self.settings.keep_session_onlogin)\n        current.session.auth = Storage(user=user,\n                                       last_visit=current.request.now,\n                                       expiration=self.settings.expiration,\n                                       hmac_key=web2py_uuid())\n        self.user = user\n        self.update_groups()\n\n    def _get_login_settings(self):\n        table_user = self.table_user()\n        userfield = self.settings.login_userfield or 'username' \\\n            if 'username' in table_user.fields else 'email'\n        passfield = self.settings.password_field\n        return Storage({\"table_user\": table_user,\n                        \"userfield\": userfield,\n                        \"passfield\": passfield})\n\n    def login_bare(self, username, password):\n        \"\"\"\n        Logins user as specified by username (or email) and password\n        \"\"\"\n        settings = self._get_login_settings()\n        user = settings.table_user(**{settings.userfield: \\\n                       username})\n        if user and user.get(settings.passfield, False):\n            password = settings.table_user[\n                settings.passfield].validate(password)[0]\n            if ((user.registration_key is None or\n                 not user.registration_key.strip()) and\n                password == user[settings.passfield]):\n                self.login_user(user)\n                return user\n        else:\n            # user not in database try other login methods\n            for login_method in self.settings.login_methods:\n                if login_method != self and login_method(username, password):\n                    self.user = user\n                    return user\n        return False\n\n    def register_bare(self, **fields):\n        \"\"\"\n        Registers a user as specified by username (or email)\n        and a raw password.\n        \"\"\"\n        settings = self._get_login_settings()\n        # users can register_bare even if no password is provided, \n        # in this case they will have to reset their password to login\n        if fields.get(settings.passfield):\n            fields[settings.passfield] = \\\n                settings.table_user[settings.passfield].validate(fields[settings.passfield])[0]\n        if not fields.get(settings.userfield):\n            raise ValueError(\"register_bare: \" +\n                             \"userfield not provided or invalid\")\n        user = self.get_or_create_user(fields, login=False, get=False, \n                                       update_fields=self.settings.update_fields)\n        if not user:\n            # get or create did not create a user (it ignores duplicate records)\n            return False\n        return user\n\n    def cas_login(self,\n                  next=DEFAULT,\n                  onvalidation=DEFAULT,\n                  onaccept=DEFAULT,\n                  log=DEFAULT,\n                  version=2,\n                  ):\n        request = current.request\n        response = current.response\n        session = current.session\n        db, table = self.db, self.table_cas()\n        session._cas_service = request.vars.service or session._cas_service\n        if not request.env.http_host in self.settings.cas_domains or \\\n                not session._cas_service:\n            raise HTTP(403, 'not authorized')\n\n        def allow_access(interactivelogin=False):\n            row = table(service=session._cas_service, user_id=self.user.id)\n            if row:\n                ticket = row.ticket\n            else:\n                ticket = 'ST-' + web2py_uuid()\n                table.insert(service=session._cas_service,\n                             user_id=self.user.id,\n                             ticket=ticket,\n                             created_on=request.now,\n                             renew=interactivelogin)\n            service = session._cas_service\n            query_sep = '&' if '?' in service else '?'\n            del session._cas_service\n            if 'warn' in request.vars and not interactivelogin:\n                response.headers[\n                    'refresh'] = \"5;URL=%s\" % service + query_sep + \"ticket=\" + ticket\n                return A(\"Continue to %s\" % service,\n                         _href=service + query_sep + \"ticket=\" + ticket)\n            else:\n                redirect(service + query_sep + \"ticket=\" + ticket)\n        if self.is_logged_in() and not 'renew' in request.vars:\n            return allow_access()\n        elif not self.is_logged_in() and 'gateway' in request.vars:\n            redirect(service)\n\n        def cas_onaccept(form, onaccept=onaccept):\n            if not onaccept is DEFAULT:\n                onaccept(form)\n            return allow_access(interactivelogin=True)\n        return self.login(next, onvalidation, cas_onaccept, log)\n\n    def cas_validate(self, version=2, proxy=False):\n        request = current.request\n        db, table = self.db, self.table_cas()\n        current.response.headers['Content-Type'] = 'text'\n        ticket = request.vars.ticket\n        renew = 'renew' in request.vars\n        row = table(ticket=ticket)\n        success = False\n        if row:\n            userfield = self.settings.login_userfield or 'username' \\\n                if 'username' in table.fields else 'email'\n            # If ticket is a service Ticket and RENEW flag respected\n            if ticket[0:3] == 'ST-' and \\\n                    not ((row.renew and renew) ^ renew):\n                user = self.table_user()(row.user_id)\n                row.delete_record()\n                success = True\n\n        def build_response(body):\n            return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' +\\\n                TAG['cas:serviceResponse'](\n                    body, **{'_xmlns:cas': 'http://www.yale.edu/tp/cas'}).xml()\n        if success:\n            if version == 1:\n                message = 'yes\\n%s' % user[userfield]\n            else:  # assume version 2\n                username = user.get('username', user[userfield])\n                message = build_response(\n                    TAG['cas:authenticationSuccess'](\n                        TAG['cas:user'](username),\n                        *[TAG['cas:' + field.name](user[field.name])\n                          for field in self.table_user()\n                          if field.readable]))\n        else:\n            if version == 1:\n                message = 'no\\n'\n            elif row:\n                message = build_response(TAG['cas:authenticationFailure']())\n            else:\n                message = build_response(\n                    TAG['cas:authenticationFailure'](\n                        'Ticket %s not recognized' % ticket,\n                        _code='INVALID TICKET'))\n        raise HTTP(200, message)\n\n    def _reset_two_factor_auth(self, session):\n        \"\"\"When two-step authentication is enabled, this function is used to\n        clear the session after successfully completing second challenge\n        or when the maximum number of tries allowed has expired.\n        \"\"\"\n        session.auth_two_factor_user = None\n        session.auth_two_factor = None\n        session.auth_two_factor_enabled = False\n        # Allow up to 4 attempts (the 1st one plus 3 more)\n        session.auth_two_factor_tries_left = 3\n\n    def login(self,\n              next=DEFAULT,\n              onvalidation=DEFAULT,\n              onaccept=DEFAULT,\n              log=DEFAULT,\n              ):\n        \"\"\"\n        Returns a login form\n        \"\"\"\n\n        table_user = self.table_user()\n        settings = self.settings\n        if 'username' in table_user.fields or \\\n                not settings.login_email_validate:\n            tmpvalidator = IS_NOT_EMPTY(error_message=self.messages.is_empty)\n            if not settings.username_case_sensitive:\n                tmpvalidator = [IS_LOWER(), tmpvalidator]\n        else:\n            tmpvalidator = IS_EMAIL(error_message=self.messages.invalid_email)\n            if not settings.email_case_sensitive:\n                tmpvalidator = [IS_LOWER(), tmpvalidator]\n\n        request = current.request\n        response = current.response\n        session = current.session\n\n        passfield = settings.password_field\n        try:\n            table_user[passfield].requires[-1].min_length = 0\n        except:\n            pass\n\n        ### use session for federated login\n        snext = self.get_vars_next()\n        if snext and self.settings.prevent_open_redirect_attacks:\n            items = snext.split('/')\n            if '//' in snext and items[2] != request.env.http_host:\n                snext = None\n\n        if snext:\n            session._auth_next = snext\n        elif session._auth_next:\n            snext = session._auth_next\n        ### pass\n\n        if next is DEFAULT:\n            # important for security\n            next = settings.login_next\n            if callable(next):\n                next = next()\n            user_next = snext\n            if user_next:\n                external = user_next.split('://')\n                if external[0].lower() in ['http', 'https', 'ftp']:\n                    host_next = user_next.split('//', 1)[-1].split('/')[0]\n                    if host_next in settings.cas_domains:\n                        next = user_next\n                else:\n                    next = user_next\n        if onvalidation is DEFAULT:\n            onvalidation = settings.login_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = settings.login_onaccept\n        if log is DEFAULT:\n            log = self.messages['login_log']\n\n        onfail = settings.login_onfail\n\n        user = None  # default\n\n\n        #Setup the default field used for the form\n        multi_login = False\n        if self.settings.login_userfield:\n            username = self.settings.login_userfield\n        else:\n            if 'username' in table_user.fields:\n                username = 'username'\n            else:\n                username = 'email'\n            if self.settings.multi_login:\n                multi_login = True\n        old_requires = table_user[username].requires\n        table_user[username].requires = tmpvalidator\n\n        # If two-factor authentication is enabled, and the maximum\n        # number of tries allowed is used up, reset the session to\n        # pre-login state with two-factor auth\n        if session.auth_two_factor_enabled and session.auth_two_factor_tries_left < 1:\n            # Exceeded maximum allowed tries for this code. Require user to enter\n            # username and password again.\n            user = None\n            accepted_form = False\n            self._reset_two_factor_auth(session)\n            # Redirect to the default 'next' page without logging\n            # in. If that page requires login, user will be redirected\n            # back to the main login form\n            redirect(next, client_side=settings.client_side)\n\n        # Before showing the default login form, check whether\n        # we are already on the second step of two-step authentication.\n        # If we are, then skip this login form and use the form for the\n        # second challenge instead.\n        # Note to devs: The code inside the if-block is unchanged from the\n        # previous version of this file, other than for indentation inside\n        # to put it inside the if-block\n        if session.auth_two_factor_user is None:\n\n            if settings.remember_me_form:\n                extra_fields = [\n                    Field('remember_me', 'boolean', default=False,\n                          label = self.messages.label_remember_me)]\n            else:\n                extra_fields = []\n\n            # do we use our own login form, or from a central source?\n            if settings.login_form == self:\n                form = SQLFORM(\n                    table_user,\n                    fields=[username, passfield],\n                    hidden=dict(_next=next),\n                    showid=settings.showid,\n                    submit_button=self.messages.login_button,\n                    delete_label=self.messages.delete_label,\n                    formstyle=settings.formstyle,\n                    separator=settings.label_separator,\n                    extra_fields = extra_fields,\n                )\n\n\n                captcha = settings.login_captcha or \\\n                    (settings.login_captcha != False and settings.captcha)\n                if captcha:\n                    addrow(form, captcha.label, captcha, captcha.comment,\n                           settings.formstyle, 'captcha__row')\n                accepted_form = False\n\n                if form.accepts(request, session if self.csrf_prevention else None,\n                                formname='login', dbio=False,\n                                onvalidation=onvalidation,\n                                hideerror=settings.hideerror):\n\n                    accepted_form = True\n                    # check for username in db\n                    entered_username = form.vars[username]\n                    if multi_login and '@' in entered_username:\n                        # if '@' in username check for email, not username\n                        user = table_user(email = entered_username)\n                    else:\n                        user = table_user(**{username: entered_username})\n                    if user:\n                        # user in db, check if registration pending or disabled\n                        temp_user = user\n                        if temp_user.registration_key == 'pending':\n                            response.flash = self.messages.registration_pending\n                            return form\n                        elif temp_user.registration_key in ('disabled', 'blocked'):\n                            response.flash = self.messages.login_disabled\n                            return form\n                        elif (not temp_user.registration_key is None\n                              and temp_user.registration_key.strip()):\n                            response.flash = \\\n                                self.messages.registration_verifying\n                            return form\n                        # try alternate logins 1st as these have the\n                        # current version of the password\n                        user = None\n                        for login_method in settings.login_methods:\n                            if login_method != self and \\\n                                    login_method(request.vars[username],\n                                                 request.vars[passfield]):\n                                if not self in settings.login_methods:\n                                    # do not store password in db\n                                    form.vars[passfield] = None\n                                user = self.get_or_create_user(\n                                    form.vars, settings.update_fields)\n                                break\n                        if not user:\n                            # alternates have failed, maybe because service inaccessible\n                            if settings.login_methods[0] == self:\n                                # try logging in locally using cached credentials\n                                if form.vars.get(passfield, '') == temp_user[passfield]:\n                                    # success\n                                    user = temp_user\n                    else:\n                        # user not in db\n                        if not settings.alternate_requires_registration:\n                            # we're allowed to auto-register users from external systems\n                            for login_method in settings.login_methods:\n                                if login_method != self and \\\n                                        login_method(request.vars[username],\n                                                     request.vars[passfield]):\n                                    if not self in settings.login_methods:\n                                        # do not store password in db\n                                        form.vars[passfield] = None\n                                    user = self.get_or_create_user(\n                                        form.vars, settings.update_fields)\n                                    break\n                    if not user:\n                        self.log_event(self.messages['login_failed_log'],\n                                       request.post_vars)\n                        # invalid login\n                        session.flash = self.messages.invalid_login\n                        callback(onfail, None)\n                        redirect(\n                            self.url(args=request.args, vars=request.get_vars),\n                            client_side=settings.client_side)\n\n            else: # use a central authentication server\n                cas = settings.login_form\n                cas_user = cas.get_user()\n\n                if cas_user:\n                    cas_user[passfield] = None\n                    user = self.get_or_create_user(\n                        table_user._filter_fields(cas_user),\n                        settings.update_fields)\n                elif hasattr(cas, 'login_form'):\n                    return cas.login_form()\n                else:\n                    # we need to pass through login again before going on\n                    next = self.url(settings.function, args='login')\n                    redirect(cas.login_url(next),\n                             client_side=settings.client_side)\n\n        # Extra login logic for two-factor authentication\n        #################################################\n        # If the 'user' variable has a value, this means that the first\n        # authentication step was successful (i.e. user provided correct\n        # username and password at the first challenge).\n        # Check if this user is signed up for two-factor authentication\n        # Default rule is that the user must be part of a group that is called\n        # auth.settings.two_factor_authentication_group\n        if user and self.settings.two_factor_authentication_group:\n            role = self.settings.two_factor_authentication_group\n            session.auth_two_factor_enabled = self.has_membership(user_id=user.id, role=role)\n        # challenge\n        if session.auth_two_factor_enabled:\n            form = SQLFORM.factory(\n                Field('authentication_code',\n                      required=True,\n                      comment='This code was emailed to you and is required for login.'),\n                hidden=dict(_next=next),\n                formstyle=settings.formstyle,\n                separator=settings.label_separator\n            )\n            # accepted_form is used by some default web2py code later in the\n            # function that handles running specified functions before redirect\n            # Set it to False until the challenge form is accepted.\n            accepted_form = False\n            # Handle the case when a user has submitted the login/password\n            # form successfully, and the password has been validated, but\n            # the two-factor form has not been displayed or validated yet.\n            if session.auth_two_factor_user is None and user is not None:\n                session.auth_two_factor_user = user # store the validated user and associate with this session\n                session.auth_two_factor = random.randint(100000, 999999)\n                session.auth_two_factor_tries_left = 3 # Allow user to try up to 4 times\n                # TODO: Add some error checking to handle cases where email cannot be sent\n                self.settings.mailer.send(\n                    to=user.email,\n                    subject=\"Two-step Login Authentication Code\",\n                    message=\"Your temporary login code is {0}\".format(session.auth_two_factor))\n            if form.accepts(request, session if self.csrf_prevention else None,\n                            formname='login', dbio=False,\n                            onvalidation=onvalidation,\n                            hideerror=settings.hideerror):\n                accepted_form = True\n                if form.vars['authentication_code'] == str(session.auth_two_factor):\n                    # Handle the case when the two-factor form has been successfully validated\n                    # and the user was previously stored (the current user should be None because\n                    # in this case, the previous username/password login form should not be displayed.\n                    # This will allow the code after the 2-factor authentication block to proceed as\n                    # normal.\n                    if user is None or user == session.auth_two_factor_user:\n                        user = session.auth_two_factor_user\n                    # For security, because the username stored in the\n                    # session somehow does not match the just validated\n                    # user. Should not be possible without session stealing\n                    # which is hard with SSL.\n                    elif user != session.auth_two_factor_user:\n                        user = None\n                    # Either way, the user and code associated with this session should\n                    # be removed. This handles cases where the session login may have\n                    # expired but browser window is open, so the old session key and\n                    # session usernamem will still exist\n                    self._reset_two_factor_auth(session)\n                else:\n                    # TODO: Limit the number of retries allowed.\n                    response.flash = 'Incorrect code. {0} more attempt(s) remaining.'.format(session.auth_two_factor_tries_left)\n                    session.auth_two_factor_tries_left -= 1\n                    return form\n            else:\n                return form\n        # End login logic for two-factor authentication\n\n        # process authenticated users\n        if user:\n            user = Row(table_user._filter_fields(user, id=True))\n            # process authenticated users\n            # user wants to be logged in for longer\n            self.login_user(user)\n            session.auth.expiration = \\\n                request.post_vars.remember_me and \\\n                settings.long_expiration or \\\n                settings.expiration\n            session.auth.remember_me = 'remember_me' in request.post_vars\n            self.log_event(log, user)\n            session.flash = self.messages.logged_in\n\n        # how to continue\n        if settings.login_form == self:\n            if accepted_form:\n                callback(onaccept, form)\n                if next == session._auth_next:\n                    session._auth_next = None\n                next = replace_id(next, form)\n                redirect(next, client_side=settings.client_side)\n\n            table_user[username].requires = old_requires\n            return form\n        elif user:\n            callback(onaccept, None)\n\n        if next == session._auth_next:\n            del session._auth_next\n        redirect(next, client_side=settings.client_side)\n\n    def logout(self, next=DEFAULT, onlogout=DEFAULT, log=DEFAULT):\n        \"\"\"\n        Logouts and redirects to login\n        \"\"\"\n\n        # Clear out 2-step authentication information if user logs\n        # out. This information is also cleared on successful login.\n        self._reset_two_factor_auth(current.session)\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.logout_next\n        if onlogout is DEFAULT:\n            onlogout = self.settings.logout_onlogout\n        if onlogout:\n            onlogout(self.user)\n        if log is DEFAULT:\n            log = self.messages['logout_log']\n        if self.user:\n            self.log_event(log, self.user)\n        if self.settings.login_form != self:\n            cas = self.settings.login_form\n            cas_user = cas.get_user()\n            if cas_user:\n                next = cas.logout_url(next)\n\n        current.session.auth = None\n        if self.settings.renew_session_onlogout:\n            current.session.renew(clear_session=not self.settings.keep_session_onlogout)\n        current.session.flash = self.messages.logged_out\n        if not next is None:\n            redirect(next)\n\n    def register(self,\n                 next=DEFAULT,\n                 onvalidation=DEFAULT,\n                 onaccept=DEFAULT,\n                 log=DEFAULT,\n                 ):\n        \"\"\"\n        Returns a registration form\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        if self.is_logged_in():\n            redirect(self.settings.logged_url,\n                     client_side=self.settings.client_side)\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.register_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.register_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.register_onaccept\n        if log is DEFAULT:\n            log = self.messages['register_log']\n\n        table_user = self.table_user()\n        if self.settings.login_userfield:\n            username = self.settings.login_userfield\n        elif 'username' in table_user.fields:\n            username = 'username'\n        else:\n            username = 'email'\n\n        # Ensure the username field is unique.\n        unique_validator = IS_NOT_IN_DB(self.db, table_user[username])\n        if not table_user[username].requires:\n            table_user[username].requires = unique_validator\n        elif isinstance(table_user[username].requires, (list, tuple)):\n            if not any([isinstance(validator, IS_NOT_IN_DB) for validator in\n                        table_user[username].requires]):\n                if isinstance(table_user[username].requires, list):\n                    table_user[username].requires.append(unique_validator)\n                else:\n                    table_user[username].requires += (unique_validator, )\n        elif not isinstance(table_user[username].requires, IS_NOT_IN_DB):\n            table_user[username].requires = [table_user[username].requires,\n                                             unique_validator]\n\n        passfield = self.settings.password_field\n        formstyle = self.settings.formstyle\n        if self.settings.register_verify_password:\n            extra_fields = [\n                Field(\"password_two\", \"password\", requires=IS_EQUAL_TO(\n                        request.post_vars.get(passfield, None),\n                        error_message=self.messages.mismatched_password),\n                        label=current.T(\"Confirm Password\"))]\n        else:\n            extra_fields = []\n        form = SQLFORM(table_user,\n                       fields=self.settings.register_fields,\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.register_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=formstyle,\n                       separator=self.settings.label_separator,\n                       extra_fields = extra_fields\n                       )\n\n        captcha = self.settings.register_captcha or self.settings.captcha\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n\n        #Add a message if specified\n        if self.settings.pre_registration_div:\n            addrow(form, '',\n                   DIV(_id=\"pre-reg\", *self.settings.pre_registration_div),\n                   '', formstyle, '')\n\n        table_user.registration_key.default = key = web2py_uuid()\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='register',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            description = self.messages.group_description % form.vars\n            if self.settings.create_user_groups:\n                group_id = self.add_group(\n                    self.settings.create_user_groups % form.vars, description)\n                self.add_membership(group_id, form.vars.id)\n            if self.settings.everybody_group_id:\n                self.add_membership(\n                    self.settings.everybody_group_id, form.vars.id)\n            if self.settings.registration_requires_verification:\n                link = self.url(\n                    self.settings.function, args=('verify_email', key), scheme=True)\n                d = dict(form.vars)\n                d.update(dict(key=key, link=link, username=form.vars[username]))\n                if not (self.settings.mailer and self.settings.mailer.send(\n                        to=form.vars.email,\n                        subject=self.messages.verify_email_subject,\n                        message=self.messages.verify_email % d)):\n                    self.db.rollback()\n                    response.flash = self.messages.unable_send_email\n                    return form\n                session.flash = self.messages.email_sent\n            if self.settings.registration_requires_approval and \\\n               not self.settings.registration_requires_verification:\n                table_user[form.vars.id] = dict(registration_key='pending')\n                session.flash = self.messages.registration_pending\n            elif (not self.settings.registration_requires_verification or\n                      self.settings.login_after_registration):\n                if not self.settings.registration_requires_verification:\n                    table_user[form.vars.id] = dict(registration_key='')\n                session.flash = self.messages.registration_successful\n                user = table_user(**{username: form.vars[username]})\n                self.login_user(user)\n                session.flash = self.messages.logged_in\n            self.log_event(log, form.vars)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n\n        return form\n\n    def is_logged_in(self):\n        \"\"\"\n        Checks if the user is logged in and returns True/False.\n        If so user is in auth.user as well as in session.auth.user\n        \"\"\"\n\n        if self.user:\n            return True\n        return False\n\n    def verify_email(self,\n                     next=DEFAULT,\n                     onaccept=DEFAULT,\n                     log=DEFAULT,\n                     ):\n        \"\"\"\n        Action used to verify the registration email\n        \"\"\"\n\n        key = getarg(-1)\n        table_user = self.table_user()\n        user = table_user(registration_key=key)\n        if not user:\n            redirect(self.settings.login_url)\n        if self.settings.registration_requires_approval:\n            user.update_record(registration_key='pending')\n            current.session.flash = self.messages.registration_pending\n        else:\n            user.update_record(registration_key='')\n            current.session.flash = self.messages.email_verified\n        # make sure session has same user.registrato_key as db record\n        if current.session.auth and current.session.auth.user:\n            current.session.auth.user.registration_key = user.registration_key\n        if log is DEFAULT:\n            log = self.messages['verify_email_log']\n        if next is DEFAULT:\n            next = self.settings.verify_email_next\n        if onaccept is DEFAULT:\n            onaccept = self.settings.verify_email_onaccept\n        self.log_event(log, user)\n        callback(onaccept, user)\n        redirect(next)\n\n    def retrieve_username(self,\n                          next=DEFAULT,\n                          onvalidation=DEFAULT,\n                          onaccept=DEFAULT,\n                          log=DEFAULT,\n                          ):\n        \"\"\"\n        Returns a form to retrieve the user username\n        (only if there is a username field)\n        \"\"\"\n\n        table_user = self.table_user()\n        if not 'username' in table_user.fields:\n            raise HTTP(404)\n        request = current.request\n        response = current.response\n        session = current.session\n        captcha = self.settings.retrieve_username_captcha or \\\n                (self.settings.retrieve_username_captcha != False and self.settings.captcha)\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.retrieve_username_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.retrieve_username_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.retrieve_username_onaccept\n        if log is DEFAULT:\n            log = self.messages['retrieve_username_log']\n        old_requires = table_user.email.requires\n        table_user.email.requires = [IS_IN_DB(self.db, table_user.email,\n            error_message=self.messages.invalid_email)]\n        form = SQLFORM(table_user,\n                       fields=['email'],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.submit_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='retrieve_username', dbio=False,\n                        onvalidation=onvalidation, hideerror=self.settings.hideerror):\n            users = table_user._db(table_user.email==form.vars.email).select()\n            if not users:\n                current.session.flash = \\\n                    self.messages.invalid_email\n                redirect(self.url(args=request.args))\n            username = ', '.join(u.username for u in users)\n            self.settings.mailer.send(to=form.vars.email,\n                                      subject=self.messages.retrieve_username_subject,\n                                      message=self.messages.retrieve_username % dict(username=username))\n            session.flash = self.messages.email_sent\n            for user in users:\n                self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next)\n        table_user.email.requires = old_requires\n        return form\n\n    def random_password(self):\n        import string\n        import random\n        password = ''\n        specials = r'!#$*'\n        for i in range(0, 3):\n            password += random.choice(string.lowercase)\n            password += random.choice(string.uppercase)\n            password += random.choice(string.digits)\n            password += random.choice(specials)\n        return ''.join(random.sample(password, len(password)))\n\n    def reset_password_deprecated(self,\n                                  next=DEFAULT,\n                                  onvalidation=DEFAULT,\n                                  onaccept=DEFAULT,\n                                  log=DEFAULT,\n                                  ):\n        \"\"\"\n        Returns a form to reset the user password (deprecated)\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.retrieve_password_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.retrieve_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.retrieve_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['retrieve_password_log']\n        old_requires = table_user.email.requires\n        table_user.email.requires = [IS_IN_DB(self.db, table_user.email,\n            error_message=self.messages.invalid_email)]\n        form = SQLFORM(table_user,\n                       fields=['email'],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.submit_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='retrieve_password', dbio=False,\n                        onvalidation=onvalidation, hideerror=self.settings.hideerror):\n            user = table_user(email=form.vars.email)\n            if not user:\n                current.session.flash = \\\n                    self.messages.invalid_email\n                redirect(self.url(args=request.args))\n            elif user.registration_key in ('pending', 'disabled', 'blocked'):\n                current.session.flash = \\\n                    self.messages.registration_pending\n                redirect(self.url(args=request.args))\n            password = self.random_password()\n            passfield = self.settings.password_field\n            d = {\n                passfield: str(table_user[passfield].validate(password)[0]),\n                'registration_key': ''\n                }\n            user.update_record(**d)\n            if self.settings.mailer and \\\n               self.settings.mailer.send(to=form.vars.email,\n                                         subject=self.messages.retrieve_password_subject,\n                                         message=self.messages.retrieve_password % dict(password=password)):\n                session.flash = self.messages.email_sent\n            else:\n                session.flash = self.messages.unable_to_send_email\n            self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next)\n        table_user.email.requires = old_requires\n        return form\n\n    def confirm_registration(\n        self,\n        next=DEFAULT,\n        onvalidation=DEFAULT,\n        onaccept=DEFAULT,\n        log=DEFAULT,\n        ):\n        \"\"\"\n        Returns a form to confirm user registration\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        # response = current.response\n        session = current.session\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.reset_password_next\n\n        if self.settings.prevent_password_reset_attacks:\n            key = request.vars.key\n            if not key and len(request.args)>1:\n                key = request.args[-1]\n            if key:\n                session._reset_password_key = key\n                redirect(self.url(args='confirm_registration'))\n            else:\n                key = session._reset_password_key\n        else:\n            key = request.vars.key or getarg(-1)\n        try:\n            t0 = int(key.split('-')[0])\n            if time.time() - t0 > 60 * 60 * 24:\n                raise Exception\n            user = table_user(reset_password_key=key)\n            if not user:\n                raise Exception\n        except Exception as e:\n            session.flash = self.messages.invalid_reset_password\n            redirect(self.url('login', vars=dict(test=e)))\n            redirect(next, client_side=self.settings.client_side)\n        passfield = self.settings.password_field\n        form = SQLFORM.factory(\n            Field('first_name',\n                  label='First Name',\n                  required=True),\n            Field('last_name',\n                  label='Last Name',\n                  required=True),\n            Field('new_password', 'password',\n                  label=self.messages.new_password,\n                  requires=self.table_user()[passfield].requires),\n            Field('new_password2', 'password',\n                  label=self.messages.verify_password,\n                  requires=[IS_EXPR(\n                        'value==%s' % repr(request.vars.new_password),\n                        self.messages.mismatched_password)]),\n            submit_button='Confirm Registration',\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.process().accepted:\n            user.update_record(\n                **{passfield: str(form.vars.new_password),\n                   'first_name': str(form.vars.first_name),\n                   'last_name': str(form.vars.last_name),\n                   'registration_key': '',\n                   'reset_password_key': ''})\n            session.flash = self.messages.password_changed\n            if self.settings.login_after_password_change:\n                self.login_user(user)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def email_registration(self, subject, body, user):\n        \"\"\"\n        Sends and email invitation to a user informing they have been registered with the application\n        \"\"\"\n        reset_password_key = str(int(time.time())) + '-' + web2py_uuid()\n        link = self.url(self.settings.function,\n                        args=('confirm_registration',), vars={'key': reset_password_key},\n                        scheme=True)\n        d = dict(user)\n        d.update(dict(key=reset_password_key, link=link, site=current.request.env.http_host))\n        if self.settings.mailer and self.settings.mailer.send(\n            to=user.email,\n            subject=subject % d,\n            message=body % d):\n            user.update_record(reset_password_key=reset_password_key)\n            return True\n        return False\n\n    def bulk_register(self, max_emails=100):\n        \"\"\"\n        Creates a form for ther user to send invites to other users to join\n        \"\"\"\n        if not self.user:\n            redirect(self.settings.login_url)\n        if not self.setting.bulk_register_enabled:\n            return HTTP(404)\n\n        form = SQLFORM.factory(\n            Field('subject','string',default=self.messages.bulk_invite_subject,requires=IS_NOT_EMPTY()),\n            Field('emails','text',requires=IS_NOT_EMPTY()),\n            Field('message','text',default=self.messages.bulk_invite_body,requires=IS_NOT_EMPTY()),\n            formstyle=self.settings.formstyle)\n\n        if form.process().accepted:\n            emails = re.compile('[^\\s\\'\"@<>,;:]+\\@[^\\s\\'\"@<>,;:]+').findall(form.vars.emails)\n            # send the invitations            \n            emails_sent = []\n            emails_fail = []\n            emails_exist = []\n            for email in emails[:max_emails]:\n                if self.table_user()(email=email):\n                    emails_exist.append(email)\n                else:\n                    user = self.register_bare(email=email)\n                    if self.email_registration(form.vars.subject, form.vars.message, user):\n                        emails_sent.append(email)\n                    else:\n                        emails_fail.append(email)\n            emails_fail += emails[max_emails:]\n            form = DIV(H4('Emails sent'),UL(*[A(x,_href='mailto:'+x) for x in emails_sent]),\n                       H4('Emails failed'),UL(*[A(x,_href='mailto:'+x) for x in emails_fail]),\n                       H4('Emails existing'),UL(*[A(x,_href='mailto:'+x) for x in emails_exist]))\n        return form\n\n    def manage_tokens(self):\n        if not self.user:\n            redirect(self.settings.login_url)        \n        table_token =self.table_token()\n        table_token.user_id.writable = False\n        table_token.user_id.default = self.user.id\n        table_token.token.writable = False\n        if current.request.args(1) == 'new':\n            table_token.token.readable = False\n        form = SQLFORM.grid(table_token, args=['manage_tokens'])\n        return form\n\n    def reset_password(self,\n                       next=DEFAULT,\n                       onvalidation=DEFAULT,\n                       onaccept=DEFAULT,\n                       log=DEFAULT,\n                       ):\n        \"\"\"\n        Returns a form to reset the user password\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        # response = current.response\n        session = current.session\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.reset_password_next\n\n        if self.settings.prevent_password_reset_attacks:\n            key = request.vars.key\n            if key:\n                session._reset_password_key = key\n                redirect(self.url(args='reset_password'))\n            else:\n                key = session._reset_password_key\n        else:\n            key = request.vars.key\n        try:\n            t0 = int(key.split('-')[0])\n            if time.time() - t0 > 60 * 60 * 24:\n                raise Exception\n            user = table_user(reset_password_key=key)\n            if not user:\n                raise Exception\n        except Exception:\n            session.flash = self.messages.invalid_reset_password\n            redirect(next, client_side=self.settings.client_side)\n\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.reset_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.reset_password_onaccept\n\n        passfield = self.settings.password_field\n        form = SQLFORM.factory(\n            Field('new_password', 'password',\n                  label=self.messages.new_password,\n                  requires=self.table_user()[passfield].requires),\n            Field('new_password2', 'password',\n                  label=self.messages.verify_password,\n                  requires=[IS_EXPR(\n                      'value==%s' % repr(request.vars.new_password),\n                                    self.messages.mismatched_password)]),\n            submit_button=self.messages.password_reset_button,\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.accepts(request, session, onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            user.update_record(\n                **{passfield: str(form.vars.new_password),\n                   'registration_key': '',\n                   'reset_password_key': ''})\n            session.flash = self.messages.password_changed\n            if self.settings.login_after_password_change:\n                self.login_user(user)\n            callback(onaccept, form)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def request_reset_password(self,\n                               next=DEFAULT,\n                               onvalidation=DEFAULT,\n                               onaccept=DEFAULT,\n                               log=DEFAULT,\n                               ):\n        \"\"\"\n        Returns a form to reset the user password\n        \"\"\"\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        captcha = self.settings.retrieve_password_captcha or \\\n                (self.settings.retrieve_password_captcha != False and self.settings.captcha)\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.request_reset_password_next\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.request_reset_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.request_reset_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['reset_password_log']\n        userfield = self.settings.login_userfield or 'username' \\\n            if 'username' in table_user.fields else 'email'\n        if userfield == 'email':\n            table_user.email.requires = [\n                IS_EMAIL(error_message=self.messages.invalid_email),\n                IS_IN_DB(self.db, table_user.email,\n                         error_message=self.messages.invalid_email)]\n            if not self.settings.email_case_sensitive:\n                table_user.email.requires.insert(0, IS_LOWER())\n        else:\n            table_user.username.requires = [\n                IS_IN_DB(self.db, table_user.username,\n                         error_message=self.messages.invalid_username)]\n            if not self.settings.username_case_sensitive:\n                table_user.username.requires.insert(0, IS_LOWER())\n\n        form = SQLFORM(table_user,\n                       fields=[userfield],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.password_reset_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='reset_password', dbio=False,\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            user = table_user(**{userfield:form.vars.get(userfield)})\n            if not user:\n                session.flash = self.messages['invalid_%s' % userfield]\n                redirect(self.url(args=request.args),\n                         client_side=self.settings.client_side)\n            elif user.registration_key in ('pending', 'disabled', 'blocked'):\n                session.flash = self.messages.registration_pending\n                redirect(self.url(args=request.args),\n                         client_side=self.settings.client_side)\n            if self.email_reset_password(user):\n                session.flash = self.messages.email_sent\n            else:\n                session.flash = self.messages.unable_to_send_email\n            self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n        # old_requires = table_user.email.requires\n        return form\n\n    def email_reset_password(self, user):\n        reset_password_key = str(int(time.time())) + '-' + web2py_uuid()\n        link = self.url(self.settings.function,\n                        args=('reset_password',), vars={'key': reset_password_key},\n                        scheme=True)\n        d = dict(user)\n        d.update(dict(key=reset_password_key, link=link))\n        if self.settings.mailer and self.settings.mailer.send(\n            to=user.email,\n            subject=self.messages.reset_password_subject,\n            message=self.messages.reset_password % d):\n            user.update_record(reset_password_key=reset_password_key)\n            return True\n        return False\n\n    def retrieve_password(self,\n                          next=DEFAULT,\n                          onvalidation=DEFAULT,\n                          onaccept=DEFAULT,\n                          log=DEFAULT,\n                          ):\n        if self.settings.reset_password_requires_verification:\n            return self.request_reset_password(next, onvalidation, onaccept, log)\n        else:\n            return self.reset_password_deprecated(next, onvalidation, onaccept, log)\n\n    def change_password(self,\n                        next=DEFAULT,\n                        onvalidation=DEFAULT,\n                        onaccept=DEFAULT,\n                        log=DEFAULT,\n                        ):\n        \"\"\"\n        Returns a form that lets the user change password\n        \"\"\"\n\n        if not self.is_logged_in():\n            redirect(self.settings.login_url,\n                     client_side=self.settings.client_side)\n        db = self.db\n        table_user = self.table_user()\n        s = db(table_user.id == self.user.id)\n\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.change_password_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.change_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.change_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['change_password_log']\n        passfield = self.settings.password_field\n        requires = table_user[passfield].requires\n        if not isinstance(requires, (list, tuple)):\n            requires = [requires]\n        requires = filter(lambda t: isinstance(t, CRYPT), requires)\n        if requires:\n            requires[0].min_length = 0\n        form = SQLFORM.factory(\n            Field('old_password', 'password', requires=requires,\n                label=self.messages.old_password),\n            Field('new_password', 'password',\n                label=self.messages.new_password,\n                requires=table_user[passfield].requires),\n            Field('new_password2', 'password',\n                label=self.messages.verify_password,\n                requires=[IS_EXPR(\n                    'value==%s' % repr(request.vars.new_password),\n                              self.messages.mismatched_password)]),\n            submit_button=self.messages.password_change_button,\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.accepts(request, session,\n                        formname='change_password',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n\n            current_user = s.select(limitby=(0, 1), orderby_on_limitby=False).first()\n            if not form.vars['old_password'] == current_user[passfield]:\n                form.errors['old_password'] = self.messages.invalid_password\n            else:\n                d = {passfield: str(form.vars.new_password)}\n                s.update(**d)\n                session.flash = self.messages.password_changed\n                self.log_event(log, self.user)\n                callback(onaccept, form)\n                if not next:\n                    next = self.url(args=request.args)\n                else:\n                    next = replace_id(next, form)\n                redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def profile(self,\n                next=DEFAULT,\n                onvalidation=DEFAULT,\n                onaccept=DEFAULT,\n                log=DEFAULT,\n                ):\n        \"\"\"\n        Returns a form that lets the user change his/her profile\n        \"\"\"\n\n        table_user = self.table_user()\n        if not self.is_logged_in():\n            redirect(self.settings.login_url,\n                     client_side=self.settings.client_side)\n        passfield = self.settings.password_field\n        table_user[passfield].writable = False\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.profile_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.profile_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.profile_onaccept\n        if log is DEFAULT:\n            log = self.messages['profile_log']\n        form = SQLFORM(\n            table_user,\n            self.user.id,\n            fields=self.settings.profile_fields,\n            hidden=dict(_next=next),\n            showid=self.settings.showid,\n            submit_button=self.messages.profile_save_button,\n            delete_label=self.messages.delete_label,\n            upload=self.settings.download_url,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator,\n            deletable=self.settings.allow_delete_accounts,\n            )\n        if form.accepts(request, session,\n                        formname='profile',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            self.user.update(table_user._filter_fields(form.vars))\n            session.flash = self.messages.profile_updated\n            self.log_event(log, self.user)\n            callback(onaccept, form)\n            if form.deleted:\n                return self.logout()\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def run_login_onaccept(self):\n        onaccept = self.settings.login_onaccept\n        if onaccept:\n            form = Storage(dict(vars=self.user))\n            if not isinstance(onaccept, (list, tuple)):\n                onaccept = [onaccept]\n            for callback in onaccept:\n                callback(form)\n\n    def is_impersonating(self):\n        return self.is_logged_in() and 'impersonator' in current.session.auth\n\n    def impersonate(self, user_id=DEFAULT):\n        \"\"\"\n        To use this make a POST to\n        `http://..../impersonate request.post_vars.user_id=<id>`\n\n        Set request.post_vars.user_id to 0 to restore original user.\n\n        requires impersonator is logged in and::\n\n            has_permission('impersonate', 'auth_user', user_id)\n\n        \"\"\"\n        request = current.request\n        session = current.session\n        auth = session.auth\n        table_user = self.table_user()\n        if not self.is_logged_in():\n            raise HTTP(401, \"Not Authorized\")\n        current_id = auth.user.id\n        requested_id = user_id\n        if user_id is DEFAULT:\n            user_id = current.request.post_vars.user_id\n        if user_id and user_id != self.user.id and user_id != '0':\n            if not self.has_permission('impersonate',\n                                       self.table_user(),\n                                       user_id):\n                raise HTTP(403, \"Forbidden\")\n            user = table_user(user_id)\n            if not user:\n                raise HTTP(401, \"Not Authorized\")\n            auth.impersonator = pickle.dumps(session, pickle.HIGHEST_PROTOCOL)\n            auth.user.update(\n                table_user._filter_fields(user, True))\n            self.user = auth.user\n            self.update_groups()\n            log = self.messages['impersonate_log']\n            self.log_event(log, dict(id=current_id, other_id=auth.user.id))\n            self.run_login_onaccept()\n        elif user_id in (0, '0'):\n            if self.is_impersonating():\n                session.clear()\n                session.update(pickle.loads(auth.impersonator))\n                self.user = session.auth.user\n                self.update_groups()\n                self.run_login_onaccept()\n            return None\n        if requested_id is DEFAULT and not request.post_vars:\n            return SQLFORM.factory(Field('user_id', 'integer'))\n        return SQLFORM(table_user, user.id, readonly=True)\n\n    def update_groups(self):\n        if not self.user:\n            return\n        user_groups = self.user_groups = {}\n        if current.session.auth:\n            current.session.auth.user_groups = self.user_groups\n        table_group = self.table_group()\n        table_membership = self.table_membership()\n        memberships = self.db(\n            table_membership.user_id == self.user.id).select()\n        for membership in memberships:\n            group = table_group(membership.group_id)\n            if group:\n                user_groups[membership.group_id] = group.role\n\n    def groups(self):\n        \"\"\"\n        Displays the groups and their roles for the logged in user\n        \"\"\"\n\n        if not self.is_logged_in():\n            redirect(self.settings.login_url)\n        table_membership = self.table_membership()\n        memberships = self.db(\n            table_membership.user_id == self.user.id).select()\n        table = TABLE()\n        for membership in memberships:\n            table_group = self.table_group()\n            groups = self.db(table_group.id == membership.group_id).select()\n            if groups:\n                group = groups[0]\n                table.append(TR(H3(group.role, '(%s)' % group.id)))\n                table.append(TR(P(group.description)))\n        if not memberships:\n            return None\n        return table\n\n    def not_authorized(self):\n        \"\"\"\n        You can change the view for this page to make it look as you like\n        \"\"\"\n        if current.request.ajax:\n            raise HTTP(403, 'ACCESS DENIED')\n        return self.messages.access_denied\n\n    def requires(self, condition, requires_login=True, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in\n        \"\"\"\n\n        def decorator(action):\n\n            def f(*a, **b):\n\n                basic_allowed, basic_accepted, user = self.basic()\n                user = user or self.user\n                if requires_login:\n                    if not user:\n                        if current.request.ajax:\n                            raise HTTP(401, self.messages.ajax_failed_authentication)\n                        elif not otherwise is None:\n                            if callable(otherwise):\n                                return otherwise()\n                            redirect(otherwise)\n                        elif self.settings.allow_basic_login_only or \\\n                                basic_accepted or current.request.is_restful:\n                            raise HTTP(403, \"Not authorized\")\n                        else:\n                            next = self.here()\n                            current.session.flash = current.response.flash\n                            return call_or_redirect(\n                                self.settings.on_failed_authentication,\n                                self.settings.login_url +\n                                    '?_next=' + urllib.quote(next))\n\n                if callable(condition):\n                    flag = condition()\n                else:\n                    flag = condition\n                if not flag:\n                    current.session.flash = self.messages.access_denied\n                    return call_or_redirect(\n                        self.settings.on_failed_authorization)\n                return action(*a, **b)\n            f.__doc__ = action.__doc__\n            f.__name__ = action.__name__\n            f.__dict__.update(action.__dict__)\n            return f\n\n        return decorator\n\n    def requires_login(self, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in\n        \"\"\"\n        return self.requires(True, otherwise=otherwise)\n\n    def requires_login_or_token(self, otherwise=None):\n        if self.settings.enable_tokens == True:\n            user = None\n            request = current.request\n            token = request.env.http_web2py_user_token or request.vars._token\n            table_token = self.table_token()\n            table_user = self.table_user()\n            from gluon.settings import global_settings\n            if global_settings.web2py_runtime_gae:\n                row = table_token(token=token)\n                if row:\n                    user = table_user(row.user_id)\n            else:\n                row = self.db(table_token.token==token)(table_user.id==table_token.user_id).select().first()\n                if row:\n                    user = row[table_user._tablename]\n            if user:\n                self.login_user(user)\n        return self.requires(True, otherwise=otherwise)\n\n    def requires_membership(self, role=None, group_id=None, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of group_id.\n        If role is provided instead of group_id then the\n        group_id is calculated.\n        \"\"\"\n        def has_membership(self=self, group_id=group_id, role=role):\n            return self.has_membership(group_id=group_id, role=role)\n        return self.requires(has_membership, otherwise=otherwise)\n\n    def requires_permission(self, name, table_name='', record_id=0,\n                            otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of any group (role) that\n        has 'name' access to 'table_name', 'record_id'.\n        \"\"\"\n        def has_permission(self=self, name=name, table_name=table_name, record_id=record_id):\n            return self.has_permission(name, table_name, record_id)\n        return self.requires(has_permission, otherwise=otherwise)\n\n    def requires_signature(self, otherwise=None, hash_vars=True):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of group_id.\n        If role is provided instead of group_id then the\n        group_id is calculated.\n        \"\"\"\n        def verify():\n            return URL.verify(current.request, user_signature=True, hash_vars=hash_vars)\n        return self.requires(verify, otherwise)\n\n    def add_group(self, role, description=''):\n        \"\"\"\n        Creates a group associated to a role\n        \"\"\"\n\n        group_id = self.table_group().insert(\n            role=role, description=description)\n        self.log_event(self.messages['add_group_log'],\n                       dict(group_id=group_id, role=role))\n        return group_id\n\n    def del_group(self, group_id):\n        \"\"\"\n        Deletes a group\n        \"\"\"\n        self.db(self.table_group().id == group_id).delete()\n        self.db(self.table_membership().group_id == group_id).delete()\n        self.db(self.table_permission().group_id == group_id).delete()\n        if group_id in self.user_groups: del self.user_groups[group_id]\n        self.log_event(self.messages.del_group_log, dict(group_id=group_id))\n\n    def id_group(self, role):\n        \"\"\"\n        Returns the group_id of the group specified by the role\n        \"\"\"\n        rows = self.db(self.table_group().role == role).select()\n        if not rows:\n            return None\n        return rows[0].id\n\n    def user_group(self, user_id=None):\n        \"\"\"\n        Returns the group_id of the group uniquely associated to this user\n        i.e. `role=user:[user_id]`\n        \"\"\"\n        return self.id_group(self.user_group_role(user_id))\n\n    def user_group_role(self, user_id=None):\n        if not self.settings.create_user_groups:\n            return None\n        if user_id:\n            user = self.table_user()[user_id]\n        else:\n            user = self.user\n        return self.settings.create_user_groups % user\n\n    def has_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Checks if user is member of group_id or role\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        try:\n            group_id = int(group_id)\n        except:\n            group_id = self.id_group(group_id)  # interpret group_id as a role\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        if group_id and user_id and self.db((membership.user_id == user_id)\n                    & (membership.group_id == group_id)).select():\n            r = True\n        else:\n            r = False\n        self.log_event(self.messages['has_membership_log'],\n                       dict(user_id=user_id, group_id=group_id, check=r))\n        return r\n\n    def add_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Gives user_id membership of group_id or role\n        if user is None than user_id is that of current logged in user\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        try:\n            group_id = int(group_id)\n        except:\n            group_id = self.id_group(group_id)  # interpret group_id as a role\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        record = membership(user_id=user_id, group_id=group_id)\n        if record:\n            return record.id\n        else:\n            id = membership.insert(group_id=group_id, user_id=user_id)\n        if role:\n            self.user_groups[group_id] = role\n        else:\n            self.update_groups()\n        self.log_event(self.messages['add_membership_log'],\n                       dict(user_id=user_id, group_id=group_id))\n        return id\n\n    def del_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Revokes membership from group_id to user_id\n        if user_id is None than user_id is that of current logged in user\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        self.log_event(self.messages['del_membership_log'],\n                       dict(user_id=user_id, group_id=group_id))\n        ret = self.db(membership.user_id\n                      == user_id)(membership.group_id\n                                  == group_id).delete()\n        if group_id in self.user_groups: del self.user_groups[group_id]\n        return ret\n\n    def has_permission(self,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       user_id=None,\n                       group_id=None,\n                       ):\n        \"\"\"\n        Checks if user_id or current logged in user is member of a group\n        that has 'name' permission on 'table_name' and 'record_id'\n        if group_id is passed, it checks whether the group has the permission\n        \"\"\"\n\n        if not group_id and self.settings.everybody_group_id and \\\n                self.has_permission(\n            name, table_name, record_id, user_id=None,\n            group_id=self.settings.everybody_group_id):\n                return True\n\n        if not user_id and not group_id and self.user:\n            user_id = self.user.id\n        if user_id:\n            membership = self.table_membership()\n            rows = self.db(membership.user_id\n                           == user_id).select(membership.group_id)\n            groups = set([row.group_id for row in rows])\n            if group_id and not group_id in groups:\n                return False\n        else:\n            groups = set([group_id])\n        permission = self.table_permission()\n        rows = self.db(permission.name == name)(permission.table_name\n                 == str(table_name))(permission.record_id\n                 == record_id).select(permission.group_id)\n        groups_required = set([row.group_id for row in rows])\n        if record_id:\n            rows = self.db(permission.name\n                            == name)(permission.table_name\n                     == str(table_name))(permission.record_id\n                     == 0).select(permission.group_id)\n            groups_required = groups_required.union(set([row.group_id\n                    for row in rows]))\n        if groups.intersection(groups_required):\n            r = True\n        else:\n            r = False\n        if user_id:\n            self.log_event(self.messages['has_permission_log'],\n                           dict(user_id=user_id, name=name,\n                                table_name=table_name, record_id=record_id))\n        return r\n\n    def add_permission(self,\n                       group_id,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       ):\n        \"\"\"\n        Gives group_id 'name' access to 'table_name' and 'record_id'\n        \"\"\"\n\n        permission = self.table_permission()\n        if group_id == 0:\n            group_id = self.user_group()\n        record = self.db(permission.group_id == group_id)(permission.name == name)(permission.table_name == str(table_name))(\n                permission.record_id == long(record_id)).select(limitby=(0, 1), orderby_on_limitby=False).first()\n        if record:\n            id = record.id\n        else:\n            id = permission.insert(group_id=group_id, name=name,\n                                   table_name=str(table_name),\n                                   record_id=long(record_id))\n        self.log_event(self.messages['add_permission_log'],\n                       dict(permission_id=id, group_id=group_id,\n                            name=name, table_name=table_name,\n                            record_id=record_id))\n        return id\n\n    def del_permission(self,\n                       group_id,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       ):\n        \"\"\"\n        Revokes group_id 'name' access to 'table_name' and 'record_id'\n        \"\"\"\n\n        permission = self.table_permission()\n        self.log_event(self.messages['del_permission_log'],\n                       dict(group_id=group_id, name=name,\n                            table_name=table_name, record_id=record_id))\n        return self.db(permission.group_id == group_id)(permission.name\n                 == name)(permission.table_name\n                           == str(table_name))(permission.record_id\n                 == long(record_id)).delete()\n\n    def accessible_query(self, name, table, user_id=None):\n        \"\"\"\n        Returns a query with all accessible records for user_id or\n        the current logged in user\n        this method does not work on GAE because uses JOIN and IN\n\n        Example:\n            Use as::\n\n                db(auth.accessible_query('read', db.mytable)).select(db.mytable.ALL)\n\n        \"\"\"\n        if not user_id:\n            user_id = self.user_id\n        db = self.db\n        if isinstance(table, str) and table in self.db.tables():\n            table = self.db[table]\n        elif isinstance(table, (Set, Query)):\n            # experimental: build a chained query for all tables\n            if isinstance(table, Set):\n                cquery = table.query\n            else:\n                cquery = table\n            tablenames = db._adapter.tables(cquery)\n            for tablename in tablenames:\n                cquery &= self.accessible_query(name, tablename,\n                                                user_id=user_id)\n            return cquery\n        if not isinstance(table, str) and\\\n                self.has_permission(name, table, 0, user_id):\n            return table.id > 0\n        membership = self.table_membership()\n        permission = self.table_permission()\n        query = table.id.belongs(\n            db(membership.user_id == user_id)\n                (membership.group_id == permission.group_id)\n                (permission.name == name)\n                (permission.table_name == table)\n                ._select(permission.record_id))\n        if self.settings.everybody_group_id:\n            query |= table.id.belongs(\n                db(permission.group_id == self.settings.everybody_group_id)\n                    (permission.name == name)\n                    (permission.table_name == table)\n                    ._select(permission.record_id))\n        return query\n\n    @staticmethod\n    def archive(form,\n                archive_table=None,\n                current_record='current_record',\n                archive_current=False,\n                fields=None):\n        \"\"\"\n        If you have a table (db.mytable) that needs full revision history you\n        can just do::\n\n            form=crud.update(db.mytable,myrecord,onaccept=auth.archive)\n\n        or::\n\n            form=SQLFORM(db.mytable,myrecord).process(onaccept=auth.archive)\n\n        crud.archive will define a new table \"mytable_archive\" and store\n        a copy of the current record (if archive_current=True)\n        or a copy of the previous record (if archive_current=False)\n        in the newly created table including a reference\n        to the current record.\n\n        fields allows to specify extra fields that need to be archived.\n\n        If you want to access such table you need to define it yourself\n        in a model::\n\n            db.define_table('mytable_archive',\n                Field('current_record',db.mytable),\n                db.mytable)\n\n        Notice such table includes all fields of db.mytable plus one: current_record.\n        crud.archive does not timestamp the stored record unless your original table\n        has a fields like::\n\n            db.define_table(...,\n                Field('saved_on','datetime',\n                     default=request.now,update=request.now,writable=False),\n                Field('saved_by',auth.user,\n                     default=auth.user_id,update=auth.user_id,writable=False),\n\n        there is nothing special about these fields since they are filled before\n        the record is archived.\n\n        If you want to change the archive table name and the name of the reference field\n        you can do, for example::\n\n            db.define_table('myhistory',\n                Field('parent_record',db.mytable),\n                db.mytable)\n\n        and use it as::\n\n            form=crud.update(db.mytable,myrecord,\n                             onaccept=lambda form:crud.archive(form,\n                             archive_table=db.myhistory,\n                             current_record='parent_record'))\n\n        \"\"\"\n        if not archive_current and not form.record:\n            return None\n        table = form.table\n        if not archive_table:\n            archive_table_name = '%s_archive' % table\n            if not archive_table_name in table._db:\n                table._db.define_table(\n                    archive_table_name,\n                    Field(current_record, table),\n                    *[field.clone(unique=False) for field in table])\n            archive_table = table._db[archive_table_name]\n        new_record = {current_record: form.vars.id}\n        for fieldname in archive_table.fields:\n            if not fieldname in ['id', current_record]:\n                if archive_current and fieldname in form.vars:\n                    new_record[fieldname] = form.vars[fieldname]\n                elif form.record and fieldname in form.record:\n                    new_record[fieldname] = form.record[fieldname]\n        if fields:\n            new_record.update(fields)\n        id = archive_table.insert(**new_record)\n        return id\n\n    def wiki(self,\n             slug=None,\n             env=None,\n             render='markmin',\n             manage_permissions=False,\n             force_prefix='',\n             restrict_search=False,\n             resolve=True,\n             extra=None,\n             menu_groups=None,\n             templates=None,\n             migrate=True,\n             controller=None,\n             function=None,\n             force_render=False,\n             groups=None):\n\n        if controller and function:\n            resolve = False\n\n        if not hasattr(self, '_wiki'):\n            self._wiki = Wiki(self, render=render,\n                              manage_permissions=manage_permissions,\n                              force_prefix=force_prefix,\n                              restrict_search=restrict_search,\n                              env=env, extra=extra or {},\n                              menu_groups=menu_groups,\n                              templates=templates,\n                              migrate=migrate,\n                              controller=controller,\n                              function=function,\n                              groups=groups)\n        else:\n            self._wiki.env.update(env or {})\n\n        # if resolve is set to True, process request as wiki call\n        # resolve=False allows initial setup without wiki redirection\n        wiki = None\n        if resolve:\n            if slug:\n                wiki = self._wiki.read(slug, force_render)\n                if isinstance(wiki, dict) and wiki.has_key('content'):  # FIXME: .has_key() is deprecated\n                    # We don't want to return a dict object, just the wiki\n                    wiki = wiki['content']\n            else:\n                wiki = self._wiki()\n            if isinstance(wiki, basestring):\n                wiki = XML(wiki)\n            return wiki\n\n    def wikimenu(self):\n        \"\"\"To be used in menu.py for app wide wiki menus\"\"\"\n        if (hasattr(self, \"_wiki\") and\n            self._wiki.settings.controller and\n            self._wiki.settings.function):\n            self._wiki.automenu()\n\n\nclass Crud(object):\n\n    def url(self, f=None, args=None, vars=None):\n        \"\"\"\n        This should point to the controller that exposes\n        download and crud\n        \"\"\"\n        if args is None:\n            args = []\n        if vars is None:\n            vars = {}\n        return URL(c=self.settings.controller, f=f, args=args, vars=vars)\n\n    def __init__(self, environment, db=None, controller='default'):\n        self.db = db\n        if not db and environment and isinstance(environment, DAL):\n            self.db = environment\n        elif not db:\n            raise SyntaxError(\"must pass db as first or second argument\")\n        self.environment = current\n        settings = self.settings = Settings()\n        settings.auth = None\n        settings.logger = None\n\n        settings.create_next = None\n        settings.update_next = None\n        settings.controller = controller\n        settings.delete_next = self.url()\n        settings.download_url = self.url('download')\n        settings.create_onvalidation = StorageList()\n        settings.update_onvalidation = StorageList()\n        settings.delete_onvalidation = StorageList()\n        settings.create_onaccept = StorageList()\n        settings.update_onaccept = StorageList()\n        settings.update_ondelete = StorageList()\n        settings.delete_onaccept = StorageList()\n        settings.update_deletable = True\n        settings.showid = False\n        settings.keepvalues = False\n        settings.create_captcha = None\n        settings.update_captcha = None\n        settings.captcha = None\n        settings.formstyle = 'table3cols'\n        settings.label_separator = ': '\n        settings.hideerror = False\n        settings.detect_record_change = True\n        settings.hmac_key = None\n        settings.lock_keys = True\n\n        messages = self.messages = Messages(current.T)\n        messages.submit_button = 'Submit'\n        messages.delete_label = 'Check to delete'\n        messages.record_created = 'Record Created'\n        messages.record_updated = 'Record Updated'\n        messages.record_deleted = 'Record Deleted'\n\n        messages.update_log = 'Record %(id)s updated'\n        messages.create_log = 'Record %(id)s created'\n        messages.read_log = 'Record %(id)s read'\n        messages.delete_log = 'Record %(id)s deleted'\n\n        messages.lock_keys = True\n\n    def __call__(self):\n        args = current.request.args\n        if len(args) < 1:\n            raise HTTP(404)\n        elif args[0] == 'tables':\n            return self.tables()\n        elif len(args) > 1 and not args(1) in self.db.tables:\n            raise HTTP(404)\n        table = self.db[args(1)]\n        if args[0] == 'create':\n            return self.create(table)\n        elif args[0] == 'select':\n            return self.select(table, linkto=self.url(args='read'))\n        elif args[0] == 'search':\n            form, rows = self.search(table, linkto=self.url(args='read'))\n            return DIV(form, SQLTABLE(rows))\n        elif args[0] == 'read':\n            return self.read(table, args(2))\n        elif args[0] == 'update':\n            return self.update(table, args(2))\n        elif args[0] == 'delete':\n            return self.delete(table, args(2))\n        else:\n            raise HTTP(404)\n\n    def log_event(self, message, vars):\n        if self.settings.logger:\n            self.settings.logger.log_event(message, vars, origin='crud')\n\n    def has_permission(self, name, table, record=0):\n        if not self.settings.auth:\n            return True\n        try:\n            record_id = record.id\n        except:\n            record_id = record\n        return self.settings.auth.has_permission(name, str(table), record_id)\n\n    def tables(self):\n        return TABLE(*[TR(A(name,\n                            _href=self.url(args=('select', name))))\n                       for name in self.db.tables])\n\n    @staticmethod\n    def archive(form, archive_table=None, current_record='current_record'):\n        return Auth.archive(form, archive_table=archive_table,\n                            current_record=current_record)\n\n    def update(self,\n               table,\n               record,\n               next=DEFAULT,\n               onvalidation=DEFAULT,\n               onaccept=DEFAULT,\n               ondelete=DEFAULT,\n               log=DEFAULT,\n               message=DEFAULT,\n               deletable=DEFAULT,\n               formname=DEFAULT,\n               **attributes\n               ):\n        if not (isinstance(table, Table) or table in self.db.tables) \\\n                or (isinstance(record, str) and not str(record).isdigit()):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        try:\n            record_id = record.id\n        except:\n            record_id = record or 0\n        if record_id and not self.has_permission('update', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        if not record_id and not self.has_permission('create', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n\n        request = current.request\n        response = current.response\n        session = current.session\n        if request.extension == 'json' and request.vars.json:\n            request.vars.update(json_parser.loads(request.vars.json))\n        if next is DEFAULT:\n            next = request.get_vars._next \\\n                or request.post_vars._next \\\n                or self.settings.update_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.update_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.update_onaccept\n        if ondelete is DEFAULT:\n            ondelete = self.settings.update_ondelete\n        if log is DEFAULT:\n            log = self.messages['update_log']\n        if deletable is DEFAULT:\n            deletable = self.settings.update_deletable\n        if message is DEFAULT:\n            message = self.messages.record_updated\n        if not 'hidden' in attributes:\n            attributes['hidden'] = {}\n        attributes['hidden']['_next'] = next\n        form = SQLFORM(\n            table,\n            record,\n            showid=self.settings.showid,\n            submit_button=self.messages.submit_button,\n            delete_label=self.messages.delete_label,\n            deletable=deletable,\n            upload=self.settings.download_url,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator,\n            **attributes  # contains hidden\n            )\n        self.accepted = False\n        self.deleted = False\n        captcha = self.settings.update_captcha or self.settings.captcha\n        if record and captcha:\n            addrow(form, captcha.label, captcha, captcha.comment,\n                         self.settings.formstyle, 'captcha__row')\n        captcha = self.settings.create_captcha or self.settings.captcha\n        if not record and captcha:\n            addrow(form, captcha.label, captcha, captcha.comment,\n                         self.settings.formstyle, 'captcha__row')\n        if not request.extension in ('html', 'load'):\n            (_session, _formname) = (None, None)\n        else:\n            (_session, _formname) = (\n                session, '%s/%s' % (table._tablename, form.record_id))\n        if not formname is DEFAULT:\n            _formname = formname\n        keepvalues = self.settings.keepvalues\n        if request.vars.delete_this_record:\n            keepvalues = False\n        if isinstance(onvalidation, StorageList):\n            onvalidation = onvalidation.get(table._tablename, [])\n        if form.accepts(request, _session, formname=_formname,\n                        onvalidation=onvalidation, keepvalues=keepvalues,\n                        hideerror=self.settings.hideerror,\n                        detect_record_change=self.settings.detect_record_change):\n            self.accepted = True\n            response.flash = message\n            if log:\n                self.log_event(log, form.vars)\n            if request.vars.delete_this_record:\n                self.deleted = True\n                message = self.messages.record_deleted\n                callback(ondelete, form, table._tablename)\n            response.flash = message\n            callback(onaccept, form, table._tablename)\n            if not request.extension in ('html', 'load'):\n                raise HTTP(200, 'RECORD CREATED/UPDATED')\n            if isinstance(next, (list, tuple)):  # fix issue with 2.6\n                next = next[0]\n            if next:  # Only redirect when explicit\n                next = replace_id(next, form)\n                session.flash = response.flash\n                redirect(next)\n        elif not request.extension in ('html', 'load'):\n            raise HTTP(401, serializers.json(dict(errors=form.errors)))\n        return form\n\n    def create(self,\n               table,\n               next=DEFAULT,\n               onvalidation=DEFAULT,\n               onaccept=DEFAULT,\n               log=DEFAULT,\n               message=DEFAULT,\n               formname=DEFAULT,\n               **attributes\n               ):\n\n        if next is DEFAULT:\n            next = self.settings.create_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.create_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.create_onaccept\n        if log is DEFAULT:\n            log = self.messages['create_log']\n        if message is DEFAULT:\n            message = self.messages.record_created\n        return self.update(\n            table,\n            None,\n            next=next,\n            onvalidation=onvalidation,\n            onaccept=onaccept,\n            log=log,\n            message=message,\n            deletable=False,\n            formname=formname,\n            **attributes\n            )\n\n    def read(self, table, record):\n        if not (isinstance(table, Table) or table in self.db.tables) \\\n                or (isinstance(record, str) and not str(record).isdigit()):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not self.has_permission('read', table, record):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        form = SQLFORM(\n            table,\n            record,\n            readonly=True,\n            comments=False,\n            upload=self.settings.download_url,\n            showid=self.settings.showid,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n            )\n        if not current.request.extension in ('html', 'load'):\n            return table._filter_fields(form.record, id=True)\n        return form\n\n    def delete(self,\n               table,\n               record_id,\n               next=DEFAULT,\n               message=DEFAULT,\n               ):\n        if not (isinstance(table, Table) or table in self.db.tables):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not self.has_permission('delete', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = request.get_vars._next \\\n                or request.post_vars._next \\\n                or self.settings.delete_next\n        if message is DEFAULT:\n            message = self.messages.record_deleted\n        record = table[record_id]\n        if record:\n            callback(self.settings.delete_onvalidation, record)\n            del table[record_id]\n            callback(self.settings.delete_onaccept, record, table._tablename)\n            session.flash = message\n        redirect(next)\n\n    def rows(\n        self,\n        table,\n        query=None,\n        fields=None,\n        orderby=None,\n        limitby=None,\n        ):\n        if not (isinstance(table, Table) or table in self.db.tables):\n            raise HTTP(404)\n        if not self.has_permission('select', table):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        #if record_id and not self.has_permission('select', table):\n        #    redirect(self.settings.auth.settings.on_failed_authorization)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not query:\n            query = table.id > 0\n        if not fields:\n            fields = [field for field in table if field.readable]\n        else:\n            fields = [table[f] if isinstance(f, str) else f for f in fields]\n        rows = self.db(query).select(*fields, **dict(orderby=orderby,\n                                                    limitby=limitby))\n        return rows\n\n    def select(self,\n               table,\n               query=None,\n               fields=None,\n               orderby=None,\n               limitby=None,\n               headers=None,\n               **attr\n               ):\n        headers = headers or {}\n        rows = self.rows(table, query, fields, orderby, limitby)\n        if not rows:\n            return None  # Nicer than an empty table.\n        if not 'upload' in attr:\n            attr['upload'] = self.url('download')\n        if not current.request.extension in ('html', 'load'):\n            return rows.as_list()\n        if not headers:\n            if isinstance(table, str):\n                table = self.db[table]\n            headers = dict((str(k), k.label) for k in table)\n        return SQLTABLE(rows, headers=headers, **attr)\n\n    def get_format(self, field):\n        rtable = field._db[field.type[10:]]\n        format = rtable.get('_format', None)\n        if format and isinstance(format, str):\n            return format[2:-2]\n        return field.name\n\n    def get_query(self, field, op, value, refsearch=False):\n        try:\n            if refsearch:\n                format = self.get_format(field)\n            if op == 'equals':\n                if not refsearch:\n                    return field == value\n                else:\n                    return lambda row: row[field.name][format] == value\n            elif op == 'not equal':\n                if not refsearch:\n                    return field != value\n                else:\n                    return lambda row: row[field.name][format] != value\n            elif op == 'greater than':\n                if not refsearch:\n                    return field > value\n                else:\n                    return lambda row: row[field.name][format] > value\n            elif op == 'less than':\n                if not refsearch:\n                    return field < value\n                else:\n                    return lambda row: row[field.name][format] < value\n            elif op == 'starts with':\n                if not refsearch:\n                    return field.like(value + '%')\n                else:\n                    return lambda row: str(row[field.name][format]).startswith(value)\n            elif op == 'ends with':\n                if not refsearch:\n                    return field.like('%' + value)\n                else:\n                    return lambda row: str(row[field.name][format]).endswith(value)\n            elif op == 'contains':\n                if not refsearch:\n                    return field.like('%' + value + '%')\n                else:\n                    return lambda row: value in row[field.name][format]\n        except:\n            return None\n\n    def search(self, *tables, **args):\n        \"\"\"\n        Creates a search form and its results for a table\n        Examples:\n            Use as::\n\n                form, results = crud.search(db.test,\n                   queries = ['equals', 'not equal', 'contains'],\n                   query_labels={'equals':'Equals',\n                                 'not equal':'Not equal'},\n                   fields = ['id','children'],\n                   field_labels = {\n                       'id':'ID','children':'Children'},\n                   zero='Please choose',\n                   query = (db.test.id > 0)&(db.test.id != 3) )\n\n        \"\"\"\n        table = tables[0]\n        fields = args.get('fields', table.fields)\n        validate = args.get('validate', True)\n        request = current.request\n        db = self.db\n        if not (isinstance(table, Table) or table in db.tables):\n            raise HTTP(404)\n        attributes = {}\n        for key in ('orderby', 'groupby', 'left', 'distinct', 'limitby', 'cache'):\n            if key in args:\n                attributes[key] = args[key]\n        tbl = TABLE()\n        selected = []\n        refsearch = []\n        results = []\n        showall = args.get('showall', False)\n        if showall:\n            selected = fields\n        chkall = args.get('chkall', False)\n        if chkall:\n            for f in fields:\n                request.vars['chk%s' % f] = 'on'\n        ops = args.get('queries', [])\n        zero = args.get('zero', '')\n        if not ops:\n            ops = ['equals', 'not equal', 'greater than',\n                   'less than', 'starts with',\n                   'ends with', 'contains']\n        ops.insert(0, zero)\n        query_labels = args.get('query_labels', {})\n        query = args.get('query', table.id > 0)\n        field_labels = args.get('field_labels', {})\n        for field in fields:\n            field = table[field]\n            if not field.readable:\n                continue\n            fieldname = field.name\n            chkval = request.vars.get('chk' + fieldname, None)\n            txtval = request.vars.get('txt' + fieldname, None)\n            opval = request.vars.get('op' + fieldname, None)\n            row = TR(TD(INPUT(_type=\"checkbox\", _name=\"chk\" + fieldname,\n                              _disabled=(field.type == 'id'),\n                              value=(field.type == 'id' or chkval == 'on'))),\n                     TD(field_labels.get(fieldname, field.label)),\n                     TD(SELECT([OPTION(query_labels.get(op, op),\n                                       _value=op) for op in ops],\n                               _name=\"op\" + fieldname,\n                               value=opval)),\n                     TD(INPUT(_type=\"text\", _name=\"txt\" + fieldname,\n                              _value=txtval, _id='txt' + fieldname,\n                              _class=str(field.type))))\n            tbl.append(row)\n            if request.post_vars and (chkval or field.type == 'id'):\n                if txtval and opval != '':\n                    if field.type[0:10] == 'reference ':\n                        refsearch.append(self.get_query(field, opval, txtval, refsearch=True))\n                    elif validate:\n                        value, error = field.validate(txtval)\n                        if not error:\n                            ### TODO deal with 'starts with', 'ends with', 'contains' on GAE\n                            query &= self.get_query(field, opval, value)\n                        else:\n                            row[3].append(DIV(error, _class='error'))\n                    else:\n                        query &= self.get_query(field, opval, txtval)\n                selected.append(field)\n        form = FORM(tbl, INPUT(_type=\"submit\"))\n        if selected:\n            try:\n                results = db(query).select(*selected, **attributes)\n                for r in refsearch:\n                    results = results.find(r)\n            except:  # hmmm, we should do better here\n                results = None\n        return form, results\n\n\nurllib2.install_opener(urllib2.build_opener(urllib2.HTTPCookieProcessor()))\n\n\ndef fetch(url, data=None, headers=None,\n          cookie=Cookie.SimpleCookie(),\n          user_agent='Mozilla/5.0'):\n    headers = headers or {}\n    if not data is None:\n        data = urllib.urlencode(data)\n    if user_agent:\n        headers['User-agent'] = user_agent\n    headers['Cookie'] = ' '.join(\n        ['%s=%s;' % (c.key, c.value) for c in cookie.values()])\n    try:\n        from google.appengine.api import urlfetch\n    except ImportError:\n        req = urllib2.Request(url, data, headers)\n        html = urllib2.urlopen(req).read()\n    else:\n        method = ((data is None) and urlfetch.GET) or urlfetch.POST\n        while url is not None:\n            response = urlfetch.fetch(url=url, payload=data,\n                                      method=method, headers=headers,\n                                      allow_truncated=False, follow_redirects=False,\n                                      deadline=10)\n            # next request will be a get, so no need to send the data again\n            data = None\n            method = urlfetch.GET\n            # load cookies from the response\n            cookie.load(response.headers.get('set-cookie', ''))\n            url = response.headers.get('location')\n        html = response.content\n    return html\n\nregex_geocode = \\\n    re.compile(r\"\"\"<geometry>[\\W]*?<location>[\\W]*?<lat>(?P<la>[^<]*)</lat>[\\W]*?<lng>(?P<lo>[^<]*)</lng>[\\W]*?</location>\"\"\")\n\n\ndef geocode(address):\n    try:\n        a = urllib.quote(address)\n        txt = fetch('http://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s'\n                     % a)\n        item = regex_geocode.search(txt)\n        (la, lo) = (float(item.group('la')), float(item.group('lo')))\n        return (la, lo)\n    except:\n        return (0.0, 0.0)\n\n\ndef reverse_geocode(lat, lng, lang=None):\n    \"\"\" Try to get an approximate address for a given latitude, longitude. \"\"\"\n    if not lang:\n        lang = current.T.accepted_language\n    try:\n        return json_parser.loads(fetch('http://maps.googleapis.com/maps/api/geocode/json?latlng=%(lat)s,%(lng)s&language=%(lang)s' % locals()))['results'][0]['formatted_address']\n    except:\n        return ''\n\n\ndef universal_caller(f, *a, **b):\n    c = f.func_code.co_argcount\n    n = f.func_code.co_varnames[:c]\n\n    defaults = f.func_defaults or []\n    pos_args = n[0:-len(defaults)]\n    named_args = n[-len(defaults):]\n\n    arg_dict = {}\n\n    # Fill the arg_dict with name and value for the submitted, positional values\n    for pos_index, pos_val in enumerate(a[:c]):\n        arg_dict[n[pos_index]] = pos_val    # n[pos_index] is the name of the argument\n\n    # There might be pos_args left, that are sent as named_values. Gather them as well.\n    # If a argument already is populated with values we simply replaces them.\n    for arg_name in pos_args[len(arg_dict):]:\n        if arg_name in b:\n            arg_dict[arg_name] = b[arg_name]\n\n    if len(arg_dict) >= len(pos_args):\n        # All the positional arguments is found. The function may now be called.\n        # However, we need to update the arg_dict with the values from the named arguments as well.\n        for arg_name in named_args:\n            if arg_name in b:\n                arg_dict[arg_name] = b[arg_name]\n\n        return f(**arg_dict)\n\n    # Raise an error, the function cannot be called.\n    raise HTTP(404, \"Object does not exist\")\n\n\nclass Service(object):\n\n    def __init__(self, environment=None):\n        self.run_procedures = {}\n        self.csv_procedures = {}\n        self.xml_procedures = {}\n        self.rss_procedures = {}\n        self.json_procedures = {}\n        self.jsonrpc_procedures = {}\n        self.jsonrpc2_procedures = {}\n        self.xmlrpc_procedures = {}\n        self.amfrpc_procedures = {}\n        self.amfrpc3_procedures = {}\n        self.soap_procedures = {}\n\n    def run(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.run\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/run/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def csv(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.csv\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/csv/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def xml(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.xml\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/xml/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def rss(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.rss\n                def myfunction():\n                    return dict(title=..., link=..., description=...,\n                        created_on=..., entries=[dict(title=..., link=...,\n                            description=..., created_on=...])\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/rss/myfunction\n\n        \"\"\"\n        self.rss_procedures[f.__name__] = f\n        return f\n\n    def json(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.json\n                def myfunction(a, b):\n                    return [{a: b}]\n                def call():\n                    return service()\n\n            Then call it with:;\n\n                wget http://..../app/default/call/json/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.json_procedures[f.__name__] = f\n        return f\n\n    def jsonrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.jsonrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/jsonrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.jsonrpc_procedures[f.__name__] = f\n        return f\n\n    def jsonrpc2(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.jsonrpc2\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget --post-data '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"myfunction\", \"params\": {\"a\": 1, \"b\": 2}}' http://..../app/default/call/jsonrpc2\n\n        \"\"\"\n        self.jsonrpc2_procedures[f.__name__] = f\n        return f\n\n    def xmlrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.xmlrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            The call it with:\n\n                wget http://..../app/default/call/xmlrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.xmlrpc_procedures[f.__name__] = f\n        return f\n\n    def amfrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.amfrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n\n            Then call it with::\n\n                wget http://..../app/default/call/amfrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.amfrpc_procedures[f.__name__] = f\n        return f\n\n    def amfrpc3(self, domain='default'):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.amfrpc3('domain')\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/amfrpc3/myfunction?a=hello&b=world\n\n        \"\"\"\n        if not isinstance(domain, str):\n            raise SyntaxError(\"AMF3 requires a domain for function\")\n\n        def _amfrpc3(f):\n            if domain:\n                self.amfrpc3_procedures[domain + '.' + f.__name__] = f\n            else:\n                self.amfrpc3_procedures[f.__name__] = f\n            return f\n        return _amfrpc3\n\n    def soap(self, name=None, returns=None, args=None, doc=None):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.soap('MyFunction',returns={'result':int},args={'a':int,'b':int,})\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n        Then call it with::\n\n            from gluon.contrib.pysimplesoap.client import SoapClient\n            client = SoapClient(wsdl=\"http://..../app/default/call/soap?WSDL\")\n            response = client.MyFunction(a=1,b=2)\n            return response['result']\n\n        It also exposes online generated documentation and xml example messages\n        at `http://..../app/default/call/soap`\n        \"\"\"\n\n        def _soap(f):\n            self.soap_procedures[name or f.__name__] = f, returns, args, doc\n            return f\n        return _soap\n\n    def serve_run(self, args=None):\n        request = current.request\n        if not args:\n            args = request.args\n        if args and args[0] in self.run_procedures:\n            return str(universal_caller(self.run_procedures[args[0]],\n                                        *args[1:], **dict(request.vars)))\n        self.error()\n\n    def serve_csv(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'text/x-csv'\n        if not args:\n            args = request.args\n\n        def none_exception(value):\n            if isinstance(value, unicode):\n                return value.encode('utf8')\n            if hasattr(value, 'isoformat'):\n                return value.isoformat()[:19].replace('T', ' ')\n            if value is None:\n                return '<NULL>'\n            return value\n        if args and args[0] in self.run_procedures:\n            import types\n            r = universal_caller(self.run_procedures[args[0]],\n                                 *args[1:], **dict(request.vars))\n            s = cStringIO.StringIO()\n            if hasattr(r, 'export_to_csv_file'):\n                r.export_to_csv_file(s)\n            elif r and not isinstance(r, types.GeneratorType) and isinstance(r[0], (dict, Storage)):\n                import csv\n                writer = csv.writer(s)\n                writer.writerow(r[0].keys())\n                for line in r:\n                    writer.writerow([none_exception(v)\n                                     for v in line.values()])\n            else:\n                import csv\n                writer = csv.writer(s)\n                for line in r:\n                    writer.writerow(line)\n            return s.getvalue()\n        self.error()\n\n    def serve_xml(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'text/xml'\n        if not args:\n            args = request.args\n        if args and args[0] in self.run_procedures:\n            s = universal_caller(self.run_procedures[args[0]],\n                                 *args[1:], **dict(request.vars))\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return serializers.xml(s, quote=False)\n        self.error()\n\n    def serve_rss(self, args=None):\n        request = current.request\n        response = current.response\n        if not args:\n            args = request.args\n        if args and args[0] in self.rss_procedures:\n            feed = universal_caller(self.rss_procedures[args[0]],\n                                    *args[1:], **dict(request.vars))\n        else:\n            self.error()\n        response.headers['Content-Type'] = 'application/rss+xml'\n        return serializers.rss(feed)\n\n    def serve_json(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'application/json; charset=utf-8'\n        if not args:\n            args = request.args\n        d = dict(request.vars)\n        if args and args[0] in self.json_procedures:\n            s = universal_caller(self.json_procedures[args[0]], *args[1:], **d)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return response.json(s)\n        self.error()\n\n    class JsonRpcException(Exception):\n        def __init__(self, code, info):\n            jrpc_error = Service.jsonrpc_errors.get(code)\n            if jrpc_error:\n                self.message, self.description = jrpc_error\n            self.code, self.info = code, info\n\n    # jsonrpc 2.0 error types.  records the following structure {code: (message,meaning)}\n    jsonrpc_errors = {\n        -32700: (\"Parse error. Invalid JSON was received by the server.\",  \"An error occurred on the server while parsing the JSON text.\"),\n        -32600: (\"Invalid Request\", \"The JSON sent is not a valid Request object.\"),\n        -32601: (\"Method not found\", \"The method does not exist / is not available.\"),\n        -32602: (\"Invalid params\", \"Invalid method parameter(s).\"),\n        -32603: (\"Internal error\", \"Internal JSON-RPC error.\"),\n        -32099: (\"Server error\", \"Reserved for implementation-defined server-errors.\")}\n\n    def serve_jsonrpc(self):\n        def return_response(id, result):\n            return serializers.json({'version': '1.1',\n                'id': id, 'result': result, 'error': None})\n\n        def return_error(id, code, message, data=None):\n            error = {'name': 'JSONRPCError',\n                     'code': code, 'message': message}\n            if data is not None:\n                error['data'] = data\n            return serializers.json({'id': id,\n                                     'version': '1.1',\n                                     'error': error,\n                                     })\n\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'application/json; charset=utf-8'\n        methods = self.jsonrpc_procedures\n        data = json_parser.loads(request.body.read())\n        jsonrpc_2 = data.get('jsonrpc')\n        if jsonrpc_2: #hand over to version 2 of the protocol\n            return self.serve_jsonrpc2(data)\n        id, method, params = data.get('id'), data.get('method'), data.get('params', [])\n        if id is None:\n            return return_error(0, 100, 'missing id')\n        if not method in methods:\n            return return_error(id, 100, 'method \"%s\" does not exist' % method)\n        try:\n            if isinstance(params, dict):\n                s = methods[method](**params)\n            else:\n                s = methods[method](*params)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return return_response(id, s)\n        except Service.JsonRpcException, e:\n            return return_error(id, e.code, e.info)\n        except:\n            etype, eval, etb = sys.exc_info()\n            message = '%s: %s' % (etype.__name__, eval)\n            data = request.is_local and traceback.format_tb(etb)\n            logger.warning('jsonrpc exception %s\\n%s' % (message, traceback.format_tb(etb)))\n            return return_error(id, 100, message, data)\n\n    def serve_jsonrpc2(self, data=None, batch_element=False):\n\n        def return_response(id, result):\n            if not must_respond:\n                return None\n            return serializers.json({'jsonrpc': '2.0',\n                'id': id, 'result': result})\n\n        def return_error(id, code, message=None, data=None):\n            error = {'code': code}\n            if Service.jsonrpc_errors.has_key(code):\n                error['message'] = Service.jsonrpc_errors[code][0]\n                error['data'] = Service.jsonrpc_errors[code][1]\n            if message is not None:\n                error['message'] = message\n            if data is not None:\n                error['data'] = data\n            return serializers.json({'jsonrpc': '2.0',\n                                     'id': id,\n                                     'error': error})\n\n        def validate(data):\n            \"\"\"\n            Validate request as defined in: http://www.jsonrpc.org/specification#request_object.\n\n            Args:\n                data(str): The json object.\n\n            Returns:\n                - True -- if successful\n                - False -- if no error should be reported (i.e. data is missing 'id' member)\n\n            Raises:\n                JsonRPCException\n\n            \"\"\"\n\n            iparms = set(data.keys())\n            mandatory_args = set(['jsonrpc', 'method'])\n            missing_args = mandatory_args - iparms\n\n            if missing_args:\n                raise Service.JsonRpcException(-32600, 'Missing arguments %s.' % list(missing_args))\n            if data['jsonrpc'] != '2.0':\n                raise Service.JsonRpcException(-32603, 'Unsupported jsonrpc version \"%s\"' % data['jsonrpc'])\n            if 'id' not in iparms:\n                 return False\n\n            return True\n\n        request = current.request\n        response = current.response\n        if not data:\n            response.headers['Content-Type'] = 'application/json; charset=utf-8'\n            try:\n                data = json_parser.loads(request.body.read())\n            except ValueError:  # decoding error in json lib\n                return return_error(None, -32700)\n\n        # Batch handling\n        if isinstance(data, list) and not batch_element:\n            retlist = []\n            for c in data:\n                retstr = self.serve_jsonrpc2(c, batch_element=True)\n                if retstr:  # do not add empty responses\n                    retlist.append(retstr)\n            if len(retlist) == 0:  # return nothing\n                return ''\n            else:\n                return \"[\" + ','.join(retlist) + \"]\"\n        methods = self.jsonrpc2_procedures\n        methods.update(self.jsonrpc_procedures)\n\n        try:\n            must_respond = validate(data)\n        except Service.JsonRpcException, e:\n            return return_error(None, e.code, e.info)\n\n        id, method, params = data.get('id'), data['method'], data.get('params', '')\n        if not method in methods:\n            return return_error(id, -32601, data='Method \"%s\" does not exist' % method)\n        try:\n            if isinstance(params, dict):\n                s = methods[method](**params)\n            else:\n                s = methods[method](*params)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            if must_respond:\n                return return_response(id, s)\n            else:\n                return ''\n        except HTTP, e:\n            raise e\n        except Service.JsonRpcException, e:\n            return return_error(id, e.code, e.info)\n        except:\n            etype, eval, etb = sys.exc_info()\n            data = '%s: %s\\n' % (etype.__name__, eval) + str(request.is_local and traceback.format_tb(etb))\n            logger.warning('%s: %s\\n%s' % (etype.__name__, eval, traceback.format_tb(etb)))\n            return return_error(id, -32099, data=data)\n\n    def serve_xmlrpc(self):\n        request = current.request\n        response = current.response\n        services = self.xmlrpc_procedures.values()\n        return response.xmlrpc(request, services)\n\n    def serve_amfrpc(self, version=0):\n        try:\n            import pyamf\n            import pyamf.remoting.gateway\n        except:\n            return \"pyamf not installed or not in Python sys.path\"\n        request = current.request\n        response = current.response\n        if version == 3:\n            services = self.amfrpc3_procedures\n            base_gateway = pyamf.remoting.gateway.BaseGateway(services)\n            pyamf_request = pyamf.remoting.decode(request.body)\n        else:\n            services = self.amfrpc_procedures\n            base_gateway = pyamf.remoting.gateway.BaseGateway(services)\n            context = pyamf.get_context(pyamf.AMF0)\n            pyamf_request = pyamf.remoting.decode(request.body, context)\n        pyamf_response = pyamf.remoting.Envelope(pyamf_request.amfVersion)\n        for name, message in pyamf_request:\n            pyamf_response[name] = base_gateway.getProcessor(message)(message)\n        response.headers['Content-Type'] = pyamf.remoting.CONTENT_TYPE\n        if version == 3:\n            return pyamf.remoting.encode(pyamf_response).getvalue()\n        else:\n            return pyamf.remoting.encode(pyamf_response, context).getvalue()\n\n    def serve_soap(self, version=\"1.1\"):\n        try:\n            from gluon.contrib.pysimplesoap.server import SoapDispatcher\n        except:\n            return \"pysimplesoap not installed in contrib\"\n        request = current.request\n        response = current.response\n        procedures = self.soap_procedures\n\n        location = \"%s://%s%s\" % (\n                        request.env.wsgi_url_scheme,\n                        request.env.http_host,\n                        URL(r=request, f=\"call/soap\", vars={}))\n        namespace = 'namespace' in response and response.namespace or location\n        documentation = response.description or ''\n        dispatcher = SoapDispatcher(\n            name=response.title,\n            location=location,\n            action=location,  # SOAPAction\n            namespace=namespace,\n            prefix='pys',\n            documentation=documentation,\n            ns=True)\n        for method, (function, returns, args, doc) in procedures.iteritems():\n            dispatcher.register_function(method, function, returns, args, doc)\n        if request.env.request_method == 'POST':\n            fault = {}\n            # Process normal Soap Operation\n            response.headers['Content-Type'] = 'text/xml'\n            xml = dispatcher.dispatch(request.body.read(), fault=fault)\n            if fault:\n                # May want to consider populating a ticket here...\n                response.status = 500\n            # return the soap response\n            return xml\n        elif 'WSDL' in request.vars:\n            # Return Web Service Description\n            response.headers['Content-Type'] = 'text/xml'\n            return dispatcher.wsdl()\n        elif 'op' in request.vars:\n            # Return method help webpage\n            response.headers['Content-Type'] = 'text/html'\n            method = request.vars['op']\n            sample_req_xml, sample_res_xml, doc = dispatcher.help(method)\n            body = [H1(\"Welcome to Web2Py SOAP webservice gateway\"),\n                    A(\"See all webservice operations\",\n                      _href=URL(r=request, f=\"call/soap\", vars={})),\n                    H2(method),\n                    P(doc),\n                    UL(LI(\"Location: %s\" % dispatcher.location),\n                       LI(\"Namespace: %s\" % dispatcher.namespace),\n                       LI(\"SoapAction: %s\" % dispatcher.action),\n                    ),\n                    H3(\"Sample SOAP XML Request Message:\"),\n                    CODE(sample_req_xml, language=\"xml\"),\n                    H3(\"Sample SOAP XML Response Message:\"),\n                    CODE(sample_res_xml, language=\"xml\"),\n                    ]\n            return {'body': body}\n        else:\n            # Return general help and method list webpage\n            response.headers['Content-Type'] = 'text/html'\n            body = [H1(\"Welcome to Web2Py SOAP webservice gateway\"),\n                    P(response.description),\n                    P(\"The following operations are available\"),\n                    A(\"See WSDL for webservice description\",\n                      _href=URL(r=request, f=\"call/soap\", vars={\"WSDL\":None})),\n                    UL([LI(A(\"%s: %s\" % (method, doc or ''),\n                             _href=URL(r=request, f=\"call/soap\", vars={'op': method})))\n                        for method, doc in dispatcher.list_methods()]),\n                    ]\n            return {'body': body}\n\n    def __call__(self):\n        \"\"\"\n        Registers services with::\n\n            service = Service()\n            @service.run\n            @service.rss\n            @service.json\n            @service.jsonrpc\n            @service.xmlrpc\n            @service.amfrpc\n            @service.amfrpc3('domain')\n            @service.soap('Method', returns={'Result':int}, args={'a':int,'b':int,})\n\n        Exposes services with::\n\n            def call():\n                return service()\n\n        You can call services with::\n\n            http://..../app/default/call/run?[parameters]\n            http://..../app/default/call/rss?[parameters]\n            http://..../app/default/call/json?[parameters]\n            http://..../app/default/call/jsonrpc\n            http://..../app/default/call/xmlrpc\n            http://..../app/default/call/amfrpc\n            http://..../app/default/call/amfrpc3\n            http://..../app/default/call/soap\n\n        \"\"\"\n\n        request = current.request\n        if len(request.args) < 1:\n            raise HTTP(404, \"Not Found\")\n        arg0 = request.args(0)\n        if arg0 == 'run':\n            return self.serve_run(request.args[1:])\n        elif arg0 == 'rss':\n            return self.serve_rss(request.args[1:])\n        elif arg0 == 'csv':\n            return self.serve_csv(request.args[1:])\n        elif arg0 == 'xml':\n            return self.serve_xml(request.args[1:])\n        elif arg0 == 'json':\n            return self.serve_json(request.args[1:])\n        elif arg0 == 'jsonrpc':\n            return self.serve_jsonrpc()\n        elif arg0 == 'jsonrpc2':\n            return self.serve_jsonrpc2()\n        elif arg0 == 'xmlrpc':\n            return self.serve_xmlrpc()\n        elif arg0 == 'amfrpc':\n            return self.serve_amfrpc()\n        elif arg0 == 'amfrpc3':\n            return self.serve_amfrpc(3)\n        elif arg0 == 'soap':\n            return self.serve_soap()\n        else:\n            self.error()\n\n    def error(self):\n        raise HTTP(404, \"Object does not exist\")\n\n\ndef completion(callback):\n    \"\"\"\n    Executes a task on completion of the called action.\n\n    Example:\n        Use as::\n\n            from gluon.tools import completion\n            @completion(lambda d: logging.info(repr(d)))\n            def index():\n                return dict(message='hello')\n\n    It logs the output of the function every time input is called.\n    The argument of completion is executed in a new thread.\n    \"\"\"\n    def _completion(f):\n        def __completion(*a, **b):\n            d = None\n            try:\n                d = f(*a, **b)\n                return d\n            finally:\n                thread.start_new_thread(callback, (d,))\n        return __completion\n    return _completion\n\n\ndef prettydate(d, T=lambda x: x):\n    if isinstance(d, datetime.datetime):\n        dt = datetime.datetime.now() - d\n    elif isinstance(d, datetime.date):\n        dt = datetime.date.today() - d\n    elif not d:\n        return ''\n    else:\n        return '[invalid date]'\n    if dt.days < 0:\n        suffix = ' from now'\n        dt = -dt\n    else:\n        suffix = ' ago'\n    if dt.days >= 2 * 365:\n        return T('%d years' + suffix) % int(dt.days / 365)\n    elif dt.days >= 365:\n        return T('1 year' + suffix)\n    elif dt.days >= 60:\n        return T('%d months' + suffix) % int(dt.days / 30)\n    elif dt.days > 21:\n        return T('1 month' + suffix)\n    elif dt.days >= 14:\n        return T('%d weeks' + suffix) % int(dt.days / 7)\n    elif dt.days >= 7:\n        return T('1 week' + suffix)\n    elif dt.days > 1:\n        return T('%d days' + suffix) % dt.days\n    elif dt.days == 1:\n        return T('1 day' + suffix)\n    elif dt.seconds >= 2 * 60 * 60:\n        return T('%d hours' + suffix) % int(dt.seconds / 3600)\n    elif dt.seconds >= 60 * 60:\n        return T('1 hour' + suffix)\n    elif dt.seconds >= 2 * 60:\n        return T('%d minutes' + suffix) % int(dt.seconds / 60)\n    elif dt.seconds >= 60:\n        return T('1 minute' + suffix)\n    elif dt.seconds > 1:\n        return T('%d seconds' + suffix) % dt.seconds\n    elif dt.seconds == 1:\n        return T('1 second' + suffix)\n    else:\n        return T('now')\n\n\ndef test_thread_separation():\n    def f():\n        c = PluginManager()\n        lock1.acquire()\n        lock2.acquire()\n        c.x = 7\n        lock1.release()\n        lock2.release()\n    lock1 = thread.allocate_lock()\n    lock2 = thread.allocate_lock()\n    lock1.acquire()\n    thread.start_new_thread(f, ())\n    a = PluginManager()\n    a.x = 5\n    lock1.release()\n    lock2.acquire()\n    return a.x\n\n\nclass PluginManager(object):\n    \"\"\"\n\n    Plugin Manager is similar to a storage object but it is a single level\n    singleton. This means that multiple instances within the same thread share\n    the same attributes.\n    Its constructor is also special. The first argument is the name of the\n    plugin you are defining.\n    The named arguments are parameters needed by the plugin with default values.\n    If the parameters were previous defined, the old values are used.\n\n    Example:\n        in some general configuration file::\n\n            plugins = PluginManager()\n            plugins.me.param1=3\n\n        within the plugin model::\n\n            _ = PluginManager('me',param1=5,param2=6,param3=7)\n\n        where the plugin is used::\n\n            >>> print plugins.me.param1\n            3\n            >>> print plugins.me.param2\n            6\n            >>> plugins.me.param3 = 8\n            >>> print plugins.me.param3\n            8\n\n        Here are some tests::\n\n            >>> a=PluginManager()\n            >>> a.x=6\n            >>> b=PluginManager('check')\n            >>> print b.x\n            6\n            >>> b=PluginManager() # reset settings\n            >>> print b.x\n            <Storage {}>\n            >>> b.x=7\n            >>> print a.x\n            7\n            >>> a.y.z=8\n            >>> print b.y.z\n            8\n            >>> test_thread_separation()\n            5\n            >>> plugins=PluginManager('me',db='mydb')\n            >>> print plugins.me.db\n            mydb\n            >>> print 'me' in plugins\n            True\n            >>> print plugins.me.installed\n            True\n\n    \"\"\"\n    instances = {}\n\n    def __new__(cls, *a, **b):\n        id = thread.get_ident()\n        lock = thread.allocate_lock()\n        try:\n            lock.acquire()\n            try:\n                return cls.instances[id]\n            except KeyError:\n                instance = object.__new__(cls, *a, **b)\n                cls.instances[id] = instance\n                return instance\n        finally:\n            lock.release()\n\n    def __init__(self, plugin=None, **defaults):\n        if not plugin:\n            self.__dict__.clear()\n        settings = self.__getattr__(plugin)\n        settings.installed = True\n        settings.update(\n            (k, v) for k, v in defaults.items() if not k in settings)\n\n    def __getattr__(self, key):\n        if not key in self.__dict__:\n            self.__dict__[key] = Storage()\n        return self.__dict__[key]\n\n    def keys(self):\n        return self.__dict__.keys()\n\n    def __contains__(self, key):\n        return key in self.__dict__\n\n\nclass Expose(object):\n    def __init__(self, base=None, basename=None, extensions=None, allow_download=True):\n        \"\"\"\n        Examples:\n            Use as::\n\n                def static():\n                    return dict(files=Expose())\n\n            or::\n\n                def static():\n                    path = os.path.join(request.folder,'static','public')\n                    return dict(files=Expose(path,basename='public'))\n\n        Args:\n            extensions: an optional list of file extensions for filtering\n                displayed files: e.g. `['.py', '.jpg']`\n            allow_download: whether to allow downloading selected files\n\n        \"\"\"\n        current.session.forget()\n        base = base or os.path.join(current.request.folder, 'static')\n        basename = basename or current.request.function\n        self.basename = basename\n\n        if current.request.raw_args:\n            self.args = [arg for arg in current.request.raw_args.split('/') if arg]\n        else:\n            self.args = [arg for arg in current.request.args if arg]\n        filename = os.path.join(base, *self.args)\n        if not os.path.exists(filename):\n            raise HTTP(404, \"FILE NOT FOUND\")\n        if not os.path.normpath(filename).startswith(base):\n            raise HTTP(401, \"NOT AUTHORIZED\")\n        if allow_download and not os.path.isdir(filename):\n            current.response.headers['Content-Type'] = contenttype(filename)\n            raise HTTP(200, open(filename, 'rb'), **current.response.headers)\n        self.path = path = os.path.join(filename, '*')\n        self.folders = [f[len(path) - 1:] for f in sorted(glob.glob(path))\n                            if os.path.isdir(f) and not self.isprivate(f)]\n        self.filenames = [f[len(path) - 1:] for f in sorted(glob.glob(path))\n                            if not os.path.isdir(f) and not self.isprivate(f)]\n        if 'README' in self.filenames:\n            readme = open(os.path.join(filename, 'README')).read()\n            self.paragraph = MARKMIN(readme)\n        else:\n            self.paragraph = None\n        if extensions:\n            self.filenames = [f for f in self.filenames\n                              if os.path.splitext(f)[-1] in extensions]\n\n    def breadcrumbs(self, basename):\n        path = []\n        span = SPAN()\n        span.append(A(basename, _href=URL()))\n        for arg in self.args:\n            span.append('/')\n            path.append(arg)\n            span.append(A(arg, _href=URL(args='/'.join(path))))\n        return span\n\n    def table_folders(self):\n        if self.folders:\n            return SPAN(H3('Folders'), TABLE(\n                    *[TR(TD(A(folder, _href=URL(args=self.args + [folder]))))\n                      for folder in self.folders],\n                     **dict(_class=\"table\")))\n        return ''\n\n    @staticmethod\n    def isprivate(f):\n        return 'private' in f or f.startswith('.') or f.endswith('~')\n\n    @staticmethod\n    def isimage(f):\n        return os.path.splitext(f)[-1].lower() in (\n            '.png', '.jpg', '.jpeg', '.gif', '.tiff')\n\n    def table_files(self, width=160):\n        if self.filenames:\n            return SPAN(H3('Files'),\n                        TABLE(*[TR(TD(A(f, _href=URL(args=self.args + [f]))),\n                                   TD(IMG(_src=URL(args=self.args + [f]),\n                                          _style='max-width:%spx' % width)\n                                      if width and self.isimage(f) else ''))\n                                for f in self.filenames],\n                               **dict(_class=\"table\")))\n        return ''\n\n    def xml(self):\n        return DIV(\n            H2(self.breadcrumbs(self.basename)),\n            self.paragraph or '',\n            self.table_folders(),\n            self.table_files()).xml()\n\n\nclass Wiki(object):\n    everybody = 'everybody'\n    rows_page = 25\n\n    def markmin_base(self, body):\n        return MARKMIN(body, extra=self.settings.extra,\n                       url=True, environment=self.env,\n                       autolinks=lambda link: expand_one(link, {})).xml()\n\n    def render_tags(self, tags):\n        return DIV(\n            _class='w2p_wiki_tags',\n            *[A(t.strip(), _href=URL(args='_search', vars=dict(q=t)))\n              for t in tags or [] if t.strip()])\n\n    def markmin_render(self, page):\n        return self.markmin_base(page.body) + self.render_tags(page.tags).xml()\n\n    def html_render(self, page):\n        html = page.body\n        # @///function -> http://..../function\n        html = replace_at_urls(html, URL)\n        # http://...jpg -> <img src=\"http://...jpg/> or embed\n        html = replace_autolinks(html, lambda link: expand_one(link, {}))\n        # @{component:name} -> <script>embed component name</script>\n        html = replace_components(html, self.env)\n        html = html + self.render_tags(page.tags).xml()\n        return html\n\n    @staticmethod\n    def component(text):\n        \"\"\"\n        In wiki docs allows `@{component:controller/function/args}`\n        which renders as a `LOAD(..., ajax=True)`\n        \"\"\"\n        items = text.split('/')\n        controller, function, args = items[0], items[1], items[2:]\n        return LOAD(controller, function, args=args, ajax=True).xml()\n\n    def get_renderer(self):\n        if isinstance(self.settings.render, basestring):\n            r = getattr(self, \"%s_render\" % self.settings.render)\n        elif callable(self.settings.render):\n            r = self.settings.render\n        elif isinstance(self.settings.render, dict):\n            def custom_render(page):\n                if page.render:\n                    if page.render in self.settings.render.keys():\n                        my_render = self.settings.render[page.render]\n                    else:\n                        my_render = getattr(self, \"%s_render\" % page.render)\n                else:\n                    my_render = self.markmin_render\n                return my_render(page)\n            r = custom_render\n        else:\n            raise ValueError(\n                \"Invalid render type %s\" % type(self.settings.render))\n        return r\n\n    def __init__(self, auth, env=None, render='markmin',\n                 manage_permissions=False, force_prefix='',\n                 restrict_search=False, extra=None,\n                 menu_groups=None, templates=None, migrate=True,\n                 controller=None, function=None, groups=None):\n\n        settings = self.settings = auth.settings.wiki\n\n        \"\"\"\n        Args:\n            render:\n\n                - \"markmin\"\n                - \"html\"\n                - `<function>` : Sets a custom render function\n                - `dict(html=<function>, markmin=...)`: dict(...) allows\n                   multiple custom render functions\n                - \"multiple\" : Is the same as `{}`. It enables per-record\n                   formats using builtins\n\n        \"\"\"\n        engines = set(['markmin', 'html'])\n        show_engine = False\n        if render == \"multiple\":\n            render = {}\n        if isinstance(render, dict):\n            [engines.add(key) for key in render]\n            show_engine = True\n        settings.render = render\n        perms = settings.manage_permissions = manage_permissions\n\n        settings.force_prefix = force_prefix\n        settings.restrict_search = restrict_search\n        settings.extra = extra or {}\n        settings.menu_groups = menu_groups\n        settings.templates = templates\n        settings.controller = controller\n        settings.function = function\n        settings.groups = auth.user_groups.values() \\\n            if groups is None else groups\n\n        db = auth.db\n        self.env = env or {}\n        self.env['component'] = Wiki.component\n        self.auth = auth\n        self.wiki_menu_items = None\n\n        if self.auth.user:\n            self.settings.force_prefix = force_prefix % self.auth.user\n        else:\n            self.settings.force_prefix = force_prefix\n\n        self.host = current.request.env.http_host\n\n        table_definitions = [\n            ('wiki_page', {\n                    'args': [\n                        Field('slug',\n                              requires=[IS_SLUG(),\n                                        IS_NOT_IN_DB(db, 'wiki_page.slug')],\n                              writable=False),\n                        Field('title', length=255, unique=True),\n                        Field('body', 'text', notnull=True),\n                        Field('tags', 'list:string'),\n                        Field('can_read', 'list:string',\n                              writable=perms,\n                              readable=perms,\n                              default=[Wiki.everybody]),\n                        Field('can_edit', 'list:string',\n                              writable=perms, readable=perms,\n                              default=[Wiki.everybody]),\n                        Field('changelog'),\n                        Field('html', 'text',\n                              compute=self.get_renderer(),\n                              readable=False, writable=False),\n                        Field('render', default=\"markmin\",\n                              readable=show_engine,\n                              writable=show_engine,\n                              requires=IS_EMPTY_OR(\n                                  IS_IN_SET(engines))),\n                        auth.signature],\n                    'vars': {'format': '%(title)s', 'migrate': migrate}}),\n            ('wiki_tag', {\n                    'args': [\n                        Field('name'),\n                        Field('wiki_page', 'reference wiki_page'),\n                        auth.signature],\n                    'vars':{'format': '%(title)s', 'migrate': migrate}}),\n            ('wiki_media', {\n                    'args': [\n                        Field('wiki_page', 'reference wiki_page'),\n                        Field('title', required=True),\n                        Field('filename', 'upload', required=True),\n                        auth.signature],\n                    'vars': {'format': '%(title)s', 'migrate': migrate}}),\n            ]\n\n        # define only non-existent tables\n        for key, value in table_definitions:\n            args = []\n            if not key in db.tables():\n                # look for wiki_ extra fields in auth.settings\n                extra_fields = auth.settings.extra_fields\n                if extra_fields:\n                    if key in extra_fields:\n                        if extra_fields[key]:\n                            for field in extra_fields[key]:\n                                args.append(field)\n                args += value['args']\n                db.define_table(key, *args, **value['vars'])\n\n        if self.settings.templates is None and not \\\n           self.settings.manage_permissions:\n            self.settings.templates = db.wiki_page.tags.contains('template') & \\\n                db.wiki_page.can_read.contains('everybody')\n\n        def update_tags_insert(page, id, db=db):\n            for tag in page.tags or []:\n                tag = tag.strip().lower()\n                if tag:\n                    db.wiki_tag.insert(name=tag, wiki_page=id)\n\n        def update_tags_update(dbset, page, db=db):\n            page = dbset.select(limitby=(0, 1)).first()\n            db(db.wiki_tag.wiki_page == page.id).delete()\n            for tag in page.tags or []:\n                tag = tag.strip().lower()\n                if tag:\n                    db.wiki_tag.insert(name=tag, wiki_page=page.id)\n        db.wiki_page._after_insert.append(update_tags_insert)\n        db.wiki_page._after_update.append(update_tags_update)\n\n        if (auth.user and\n            check_credentials(current.request, gae_login=False) and\n            not 'wiki_editor' in auth.user_groups.values() and\n            self.settings.groups == auth.user_groups.values()):\n            group = db.auth_group(role='wiki_editor')\n            gid = group.id if group else db.auth_group.insert(\n                role='wiki_editor')\n            auth.add_membership(gid)\n\n        settings.lock_keys = True\n\n    # WIKI ACCESS POLICY\n\n    def not_authorized(self, page=None):\n        raise HTTP(401)\n\n    def can_read(self, page):\n        if 'everybody' in page.can_read or not \\\n            self.settings.manage_permissions:\n            return True\n        elif self.auth.user:\n            groups = self.settings.groups\n            if ('wiki_editor' in groups or\n                set(groups).intersection(set(page.can_read + page.can_edit)) or\n                page.created_by == self.auth.user.id):\n                return True\n        return False\n\n    def can_edit(self, page=None):\n        if not self.auth.user:\n            redirect(self.auth.settings.login_url)\n        groups = self.settings.groups\n        return ('wiki_editor' in groups or\n                (page is None and 'wiki_author' in groups) or\n                not page is None and (\n                set(groups).intersection(set(page.can_edit)) or\n                page.created_by == self.auth.user.id))\n\n    def can_manage(self):\n        if not self.auth.user:\n            return False\n        groups = self.settings.groups\n        return 'wiki_editor' in groups\n\n    def can_search(self):\n        return True\n\n    def can_see_menu(self):\n        if self.auth.user:\n            if self.settings.menu_groups is None:\n                return True\n            else:\n                groups = self.settings.groups\n                if any(t in self.settings.menu_groups for t in groups):\n                    return True\n        return False\n\n    ### END POLICY\n\n    def automenu(self):\n        \"\"\"adds the menu if not present\"\"\"\n        if (not self.wiki_menu_items and\n            self.settings.controller and\n            self.settings.function):\n            self.wiki_menu_items = self.menu(self.settings.controller,\n                                             self.settings.function)\n            current.response.menu += self.wiki_menu_items\n\n    def __call__(self):\n        request = current.request\n        settings = self.settings\n        settings.controller = settings.controller or request.controller\n        settings.function = settings.function or request.function\n        self.automenu()\n\n        zero = request.args(0) or 'index'\n        if zero and zero.isdigit():\n            return self.media(int(zero))\n        elif not zero or not zero.startswith('_'):\n            return self.read(zero)\n        elif zero == '_edit':\n            return self.edit(request.args(1) or 'index', request.args(2) or 0)\n        elif zero == '_editmedia':\n            return self.editmedia(request.args(1) or 'index')\n        elif zero == '_create':\n            return self.create()\n        elif zero == '_pages':\n            return self.pages()\n        elif zero == '_search':\n            return self.search()\n        elif zero == '_recent':\n            ipage = int(request.vars.page or 0)\n            query = self.auth.db.wiki_page.created_by == request.args(\n                1, cast=int)\n            return self.search(query=query,\n                               orderby=~self.auth.db.wiki_page.created_on,\n                               limitby=(ipage * self.rows_page,\n                                        (ipage + 1) * self.rows_page),\n                               )\n        elif zero == '_cloud':\n            return self.cloud()\n        elif zero == '_preview':\n            return self.preview(self.get_renderer())\n\n    def first_paragraph(self, page):\n        if not self.can_read(page):\n            mm = (page.body or '').replace('\\r', '')\n            ps = [p for p in mm.split('\\n\\n')\n                      if not p.startswith('#') and p.strip()]\n            if ps:\n                return ps[0]\n        return ''\n\n    def fix_hostname(self, body):\n        return (body or '').replace('://HOSTNAME', '://%s' % self.host)\n\n    def read(self, slug, force_render=False):\n        if slug in '_cloud':\n            return self.cloud()\n        elif slug in '_search':\n            return self.search()\n        page = self.auth.db.wiki_page(slug=slug)\n        if page and (not self.can_read(page)):\n            return self.not_authorized(page)\n        if current.request.extension == 'html':\n            if not page:\n                url = URL(args=('_create', slug))\n                return dict(content=A('Create page \"%s\"' % slug, _href=url, _class=\"btn\"))\n            else:\n                html = page.html if not force_render else self.get_renderer()(page)\n                content = XML(self.fix_hostname(html))\n                return dict(title=page.title,\n                            slug=page.slug,\n                            page=page,\n                            content=content,\n                            tags=page.tags,\n                            created_on=page.created_on,\n                            modified_on=page.modified_on)\n        elif current.request.extension == 'load':\n            return self.fix_hostname(page.html) if page else ''\n        else:\n            if not page:\n                raise HTTP(404)\n            else:\n                return dict(title=page.title,\n                            slug=page.slug,\n                            page=page,\n                            content=page.body,\n                            tags=page.tags,\n                            created_on=page.created_on,\n                            modified_on=page.modified_on)\n\n    def edit(self, slug, from_template=0):\n        auth = self.auth\n        db = auth.db\n        page = db.wiki_page(slug=slug)\n        if not self.can_edit(page):\n            return self.not_authorized(page)\n        title_guess = ' '.join(c.capitalize() for c in slug.split('-'))\n        if not page:\n            if not (self.can_manage() or\n                    slug.startswith(self.settings.force_prefix)):\n                current.session.flash = 'slug must have \"%s\" prefix' \\\n                    % self.settings.force_prefix\n                redirect(URL(args=('_create')))\n            db.wiki_page.can_read.default = [Wiki.everybody]\n            db.wiki_page.can_edit.default = [auth.user_group_role()]\n            db.wiki_page.title.default = title_guess\n            db.wiki_page.slug.default = slug\n            if slug == 'wiki-menu':\n                db.wiki_page.body.default = \\\n                    '- Menu Item > @////index\\n- - Submenu > http://web2py.com'\n            else:\n                db.wiki_page.body.default = db(db.wiki_page.id == from_template).select(db.wiki_page.body)[0].body \\\n                    if int(from_template) > 0 else '## %s\\n\\npage content' % title_guess\n        vars = current.request.post_vars\n        if vars.body:\n            vars.body = vars.body.replace('://%s' % self.host, '://HOSTNAME')\n        form = SQLFORM(db.wiki_page, page, deletable=True,\n                       formstyle='table2cols', showid=False).process()\n        if form.deleted:\n            current.session.flash = 'page deleted'\n            redirect(URL())\n        elif form.accepted:\n            current.session.flash = 'page created'\n            redirect(URL(args=slug))\n        script = \"\"\"\n        jQuery(function() {\n            if (!jQuery('#wiki_page_body').length) return;\n            var pagecontent = jQuery('#wiki_page_body');\n            pagecontent.css('font-family',\n                            'Monaco,Menlo,Consolas,\"Courier New\",monospace');\n            var prevbutton = jQuery('<button class=\"btn nopreview\">Preview</button>');\n            var preview = jQuery('<div id=\"preview\"></div>').hide();\n            var previewmedia = jQuery('<div id=\"previewmedia\"></div>');\n            var form = pagecontent.closest('form');\n            preview.insertBefore(form);\n            prevbutton.insertBefore(form);\n            if(%(link_media)s) {\n              var mediabutton = jQuery('<button class=\"btn nopreview\">Media</button>');\n              mediabutton.insertBefore(form);\n              previewmedia.insertBefore(form);\n              mediabutton.click(function() {\n                if (mediabutton.hasClass('nopreview')) {\n                    web2py_component('%(urlmedia)s', 'previewmedia');\n                } else {\n                    previewmedia.empty();\n                }\n                mediabutton.toggleClass('nopreview');\n              });\n            }\n            prevbutton.click(function(e) {\n                e.preventDefault();\n                if (prevbutton.hasClass('nopreview')) {\n                    prevbutton.addClass('preview').removeClass(\n                        'nopreview').html('Edit Source');\n                    try{var wiki_render = jQuery('#wiki_page_render').val()}\n                    catch(e){var wiki_render = null;}\n                    web2py_ajax_page('post', \\\n                        '%(url)s', {body: jQuery('#wiki_page_body').val(), \\\n                                    render: wiki_render}, 'preview');\n                    form.fadeOut('fast', function() {preview.fadeIn()});\n                } else {\n                    prevbutton.addClass(\n                        'nopreview').removeClass('preview').html('Preview');\n                    preview.fadeOut('fast', function() {form.fadeIn()});\n                }\n            })\n        })\n        \"\"\" % dict(url=URL(args=('_preview', slug)), link_media=('true' if page else 'false'),\n                   urlmedia=URL(extension='load',\n                                args=('_editmedia', slug),\n                                vars=dict(embedded=1)))\n        return dict(content=TAG[''](form, SCRIPT(script)))\n\n    def editmedia(self, slug):\n        auth = self.auth\n        db = auth.db\n        page = db.wiki_page(slug=slug)\n        if not (page and self.can_edit(page)):\n            return self.not_authorized(page)\n        self.auth.db.wiki_media.id.represent = lambda id, row: \\\n            id if not row.filename else \\\n            SPAN('@////%i/%s.%s' % (id, IS_SLUG.urlify(row.title.split('.')[0]), row.filename.split('.')[-1]))\n        self.auth.db.wiki_media.wiki_page.default = page.id\n        self.auth.db.wiki_media.wiki_page.writable = False\n        links = []\n        csv = True\n        create = True\n        if current.request.vars.embedded:\n            script = \"var c = jQuery('#wiki_page_body'); c.val(c.val() + jQuery('%s').text()); return false;\"\n            fragment = self.auth.db.wiki_media.id.represent\n            csv = False\n            create = False\n            links= [\n                lambda row:\n                    A('copy into source', _href='#', _onclick=script % (fragment(row.id, row)))\n                    ]\n        content = SQLFORM.grid(\n            self.auth.db.wiki_media.wiki_page == page.id,\n            orderby=self.auth.db.wiki_media.title,\n            links=links,\n            csv=csv,\n            create=create,\n            args=['_editmedia', slug],\n            user_signature=False)\n        return dict(content=content)\n\n    def create(self):\n        if not self.can_edit():\n            return self.not_authorized()\n        db = self.auth.db\n        slugs = db(db.wiki_page.id > 0).select(db.wiki_page.id, db.wiki_page.slug)\n        options = [OPTION(row.slug, _value=row.id) for row in slugs]\n        options.insert(0, OPTION('', _value=''))\n        fields = [Field(\"slug\", default=current.request.args(1) or\n                        self.settings.force_prefix,\n                        requires=(IS_SLUG(), IS_NOT_IN_DB(db, db.wiki_page.slug))),]\n        if self.settings.templates:\n            fields.append(\n                Field(\"from_template\", \"reference wiki_page\",\n                      requires=IS_EMPTY_OR(\n                                   IS_IN_DB(db(self.settings.templates),\n                                            db.wiki_page._id,\n                                            '%(slug)s')),\n                      comment=current.T(\n                        \"Choose Template or empty for new Page\")))\n        form = SQLFORM.factory(*fields, **dict(_class=\"well\"))\n        form.element(\"[type=submit]\").attributes[\"_value\"] = \\\n            current.T(\"Create Page from Slug\")\n\n        if form.process().accepted:\n             form.vars.from_template = 0 if not form.vars.from_template \\\n                 else form.vars.from_template\n             redirect(URL(args=('_edit', form.vars.slug, form.vars.from_template or 0)))  # added param\n        return dict(content=form)\n\n    def pages(self):\n        if not self.can_manage():\n            return self.not_authorized()\n        self.auth.db.wiki_page.slug.represent = lambda slug, row: SPAN(\n            '@////%s' % slug)\n        self.auth.db.wiki_page.title.represent = lambda title, row: \\\n            A(title, _href=URL(args=row.slug))\n        wiki_table = self.auth.db.wiki_page\n        content = SQLFORM.grid(\n            wiki_table,\n            fields=[wiki_table.slug,\n                    wiki_table.title, wiki_table.tags,\n                    wiki_table.can_read, wiki_table.can_edit],\n            links=[\n                lambda row:\n                    A('edit', _href=URL(args=('_edit', row.slug)), _class='btn'),\n                lambda row:\n                    A('media', _href=URL(args=('_editmedia', row.slug)), _class='btn')],\n            details=False, editable=False, deletable=False, create=False,\n            orderby=self.auth.db.wiki_page.title,\n            args=['_pages'],\n            user_signature=False)\n\n        return dict(content=content)\n\n    def media(self, id):\n        request, response, db = current.request, current.response, self.auth.db\n        media = db.wiki_media(id)\n        if media:\n            if self.settings.manage_permissions:\n                page = db.wiki_page(media.wiki_page)\n                if not self.can_read(page):\n                    return self.not_authorized(page)\n            request.args = [media.filename]\n            m = response.download(request, db)\n            current.session.forget()  # get rid of the cookie\n            response.headers['Last-Modified'] = \\\n                request.utcnow.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n            if 'Content-Disposition' in response.headers:\n                del response.headers['Content-Disposition']\n            response.headers['Pragma'] = 'cache'\n            response.headers['Cache-Control'] = 'private'\n            return m\n        else:\n            raise HTTP(404)\n\n    def menu(self, controller='default', function='index'):\n        db = self.auth.db\n        request = current.request\n        menu_page = db.wiki_page(slug='wiki-menu')\n        menu = []\n        if menu_page:\n            tree = {'': menu}\n            regex = re.compile('[\\r\\n\\t]*(?P<base>(\\s*\\-\\s*)+)(?P<title>\\w.*?)\\s+\\>\\s+(?P<link>\\S+)')\n            for match in regex.finditer(self.fix_hostname(menu_page.body)):\n                base = match.group('base').replace(' ', '')\n                title = match.group('title')\n                link = match.group('link')\n                title_page = None\n                if link.startswith('@'):\n                    items = link[2:].split('/')\n                    if len(items) > 3:\n                        title_page = items[3]\n                        link = URL(a=items[0] or None, c=items[1] or controller,\n                                   f=items[2] or function, args=items[3:])\n                parent = tree.get(base[1:], tree[''])\n                subtree = []\n                tree[base] = subtree\n                parent.append((current.T(title),\n                               request.args(0) == title_page,\n                               link, subtree))\n        if self.can_see_menu():\n            submenu = []\n            menu.append((current.T('[Wiki]'), None, None, submenu))\n            if URL() == URL(controller, function):\n                if not str(request.args(0)).startswith('_'):\n                    slug = request.args(0) or 'index'\n                    mode = 1\n                elif request.args(0) == '_edit':\n                    slug = request.args(1) or 'index'\n                    mode = 2\n                elif request.args(0) == '_editmedia':\n                    slug = request.args(1) or 'index'\n                    mode = 3\n                else:\n                    mode = 0\n                if mode in (2, 3):\n                    submenu.append((current.T('View Page'), None,\n                    URL(controller, function, args=slug)))\n                if mode in (1, 3):\n                    submenu.append((current.T('Edit Page'), None,\n                    URL(controller, function, args=('_edit', slug))))\n                if mode in (1, 2):\n                    submenu.append((current.T('Edit Page Media'), None,\n                    URL(controller, function, args=('_editmedia', slug))))\n\n            submenu.append((current.T('Create New Page'), None,\n                            URL(controller, function, args=('_create'))))\n            # Moved next if to inside self.auth.user check\n            if self.can_manage():\n                submenu.append((current.T('Manage Pages'), None,\n                            URL(controller, function, args=('_pages'))))\n                submenu.append((current.T('Edit Menu'), None,\n                            URL(controller, function, args=('_edit', 'wiki-menu'))))\n            # Also moved inside self.auth.user check\n            submenu.append((current.T('Search Pages'), None,\n                        URL(controller, function, args=('_search'))))\n        return menu\n\n    def search(self, tags=None, query=None, cloud=True, preview=True,\n               limitby=(0, 100), orderby=None):\n        if not self.can_search():\n            return self.not_authorized()\n        request = current.request\n        content = CAT()\n        if tags is None and query is None:\n            form = FORM(INPUT(_name='q', requires=IS_NOT_EMPTY(),\n                              value=request.vars.q),\n                        INPUT(_type=\"submit\", _value=current.T('Search')),\n                        _method='GET')\n            content.append(DIV(form, _class='w2p_wiki_form'))\n            if request.vars.q:\n                tags = [v.strip() for v in request.vars.q.split(',')]\n                tags = [v.lower() for v in tags if v]\n        if tags or not query is None:\n            db = self.auth.db\n            count = db.wiki_tag.wiki_page.count()\n            fields = [db.wiki_page.id, db.wiki_page.slug,\n                      db.wiki_page.title, db.wiki_page.tags,\n                      db.wiki_page.can_read]\n            if preview:\n                fields.append(db.wiki_page.body)\n            if query is None:\n                query = (db.wiki_page.id == db.wiki_tag.wiki_page) &\\\n                    (db.wiki_tag.name.belongs(tags))\n                query = query | db.wiki_page.title.contains(request.vars.q)\n            if self.settings.restrict_search and not self.manage():\n                query = query & (db.wiki_page.created_by == self.auth.user_id)\n            pages = db(query).select(count,\n                                     *fields, **dict(orderby=orderby or ~count,\n                                                     groupby=reduce(lambda a, b: a | b, fields),\n                                                     distinct=True,\n                                                     limitby=limitby))\n            if request.extension in ('html', 'load'):\n                if not pages:\n                    content.append(DIV(current.T(\"No results\"),\n                                       _class='w2p_wiki_form'))\n\n                def link(t):\n                    return A(t, _href=URL(args='_search', vars=dict(q=t)))\n                items = [DIV(H3(A(p.wiki_page.title, _href=URL(\n                                    args=p.wiki_page.slug))),\n                             MARKMIN(self.first_paragraph(p.wiki_page))\n                                 if preview else '',\n                             DIV(_class='w2p_wiki_tags',\n                                 *[link(t.strip()) for t in\n                                       p.wiki_page.tags or [] if t.strip()]),\n                             _class='w2p_wiki_search_item')\n                         for p in pages]\n                content.append(DIV(_class='w2p_wiki_pages', *items))\n            else:\n                cloud = False\n                content = [p.wiki_page.as_dict() for p in pages]\n        elif cloud:\n            content.append(self.cloud()['content'])\n        if request.extension == 'load':\n            return content\n        return dict(content=content)\n\n    def cloud(self):\n        db = self.auth.db\n        count = db.wiki_tag.wiki_page.count(distinct=True)\n        ids = db(db.wiki_tag).select(\n            db.wiki_tag.name, count,\n            distinct=True,\n            groupby=db.wiki_tag.name,\n            orderby=~count, limitby=(0, 20))\n        if ids:\n            a, b = ids[0](count), ids[-1](count)\n\n        def style(c):\n            STYLE = 'padding:0 0.2em;line-height:%.2fem;font-size:%.2fem'\n            size = (1.5 * (c - b) / max(a - b, 1) + 1.3)\n            return STYLE % (1.3, size)\n        items = []\n        for item in ids:\n            items.append(A(item.wiki_tag.name,\n                           _style=style(item(count)),\n                           _href=URL(args='_search',\n                                     vars=dict(q=item.wiki_tag.name))))\n            items.append(' ')\n        return dict(content=DIV(_class='w2p_cloud', *items))\n\n    def preview(self, render):\n        request = current.request\n        # FIXME: This is an ugly hack to ensure a default render\n        # engine if not specified (with multiple render engines)\n        if not \"render\" in request.post_vars:\n            request.post_vars.render = None\n        return render(request.post_vars)\n\n\nclass Config(object):\n    def __init__(\n        self,\n        filename,\n        section,\n        default_values={}\n    ):\n        self.config = ConfigParser.ConfigParser(default_values)\n        self.config.read(filename)\n        if not self.config.has_section(section):\n            self.config.add_section(section)\n        self.section  = section\n        self.filename = filename\n\n    def read(self):\n        if not(isinstance(current.session['settings_%s' % self.section], dict)):\n            settings = dict(self.config.items(self.section))\n        else:\n            settings = current.session['settings_%s' % self.section]\n        return settings\n\n    def save(self, options):\n        for option, value in options:\n            self.config.set(self.section, option, value)\n        try:\n            self.config.write(open(self.filename, 'w'))\n            result = True\n        except:\n            current.session['settings_%s' % self.section] = dict(self.config.items(self.section))\n            result = False\n        return result\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n"], "fixing_code": [".*\n*.pyc\n*.pyo\n*~\n#*\n*.1\n*.bak\n*.bak2\n*.svn\n*.w2p\n*.class\n*.rej\n*.orig\nThumbs.db\n.DS_Store\nindex.yaml\nroutes.py\nlogging.conf\ngluon/tests/VERSION\ngluon/tests/sql.log\nhttpserver.log\nhttpserver.pid\nparameters*.py\n./deposit\n./benchmark\n./build\n./dist*\n./dummy_tests\n./optional_contrib\n./ssl\n./docs\n./logs\n./*.zip\n./gluon/*.1\n./gluon/*.txt\n./admin.w2p\n./examples.w2p\ncron.master\napplications/*\n!applications/welcome\n!applications/welcome/*\n!applications/examples\n!applications/examples/*\n!applications/admin\n!applications/admin/*\napplications/*/databases/*\napplications/*/sessions/*\napplications/*/errors/*\napplications/*/cache/*\napplications/*/uploads/*\napplications/*/*.py[oc]\napplications/*/static/temp\napplications/*/progress.log\napplications/examples/static/epydoc\napplications/examples/static/sphinx\napplications/admin/cron/cron.master\nHOWTO-web2py-devel\n*.sublime-project\n*.sublime-workspace\n.idea/*\nsite-packages/\n", "#!/bin/python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n| This file is part of the web2py Web Framework\n| Copyrighted by Massimo Di Pierro <mdipierro@cs.depaul.edu>\n| License: LGPLv3 (http://www.gnu.org/licenses/lgpl.html)\n\nAuth, Mail, PluginManager and various utilities\n------------------------------------------------\n\"\"\"\n\nimport base64\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport datetime\nimport thread\nimport logging\nimport sys\nimport glob\nimport os\nimport re\nimport time\nimport traceback\nimport smtplib\nimport urllib\nimport urllib2\nimport Cookie\nimport cStringIO\nimport ConfigParser\nimport email.utils\nimport random\nfrom email import MIMEBase, MIMEMultipart, MIMEText, Encoders, Header, message_from_string, Charset\n\nfrom gluon.contenttype import contenttype\nfrom gluon.storage import Storage, StorageList, Settings, Messages\nfrom gluon.utils import web2py_uuid\nfrom gluon.fileutils import read_file, check_credentials\nfrom gluon import *\nfrom gluon.contrib.autolinks import expand_one\nfrom gluon.contrib.markmin.markmin2html import \\\n    replace_at_urls, replace_autolinks, replace_components\nfrom pydal.objects import Row, Set, Query\n\nimport gluon.serializers as serializers\n\nTable = DAL.Table\nField = DAL.Field\n\ntry:\n    # try stdlib (Python 2.6)\n    import json as json_parser\nexcept ImportError:\n    try:\n        # try external module\n        import simplejson as json_parser\n    except:\n        # fallback to pure-Python module\n        import gluon.contrib.simplejson as json_parser\n\n__all__ = ['Mail', 'Auth', 'Recaptcha', 'Recaptcha2', 'Crud', 'Service', 'Wiki',\n           'PluginManager', 'fetch', 'geocode', 'reverse_geocode', 'prettydate']\n\n### mind there are two loggers here (logger and crud.settings.logger)!\nlogger = logging.getLogger(\"web2py\")\n\nDEFAULT = lambda: None\n\n\ndef getarg(position, default=None):\n    args = current.request.args\n    if position < 0 and len(args) >= -position:\n        return args[position]\n    elif position >= 0 and len(args) > position:\n        return args[position]\n    else:\n        return default\n\n\ndef callback(actions, form, tablename=None):\n    if actions:\n        if tablename and isinstance(actions, dict):\n            actions = actions.get(tablename, [])\n        if not isinstance(actions, (list, tuple)):\n            actions = [actions]\n        [action(form) for action in actions]\n\n\ndef validators(*a):\n    b = []\n    for item in a:\n        if isinstance(item, (list, tuple)):\n            b = b + list(item)\n        else:\n            b.append(item)\n    return b\n\n\ndef call_or_redirect(f, *args):\n    if callable(f):\n        redirect(f(*args))\n    else:\n        redirect(f)\n\n\ndef replace_id(url, form):\n    if url:\n        url = url.replace('[id]', str(form.vars.id))\n        if url[0] == '/' or url[:4] == 'http':\n            return url\n    return URL(url)\n\n\nclass Mail(object):\n    \"\"\"\n    Class for configuring and sending emails with alternative text / html\n    body, multiple attachments and encryption support\n\n    Works with SMTP and Google App Engine.\n\n    Args:\n        server: SMTP server address in address:port notation\n        sender: sender email address\n        login: sender login name and password in login:password notation\n            or None if no authentication is required\n        tls: enables/disables encryption (True by default)\n\n    In Google App Engine use ::\n\n        server='gae'\n\n    For sake of backward compatibility all fields are optional and default\n    to None, however, to be able to send emails at least server and sender\n    must be specified. They are available under following fields::\n\n        mail.settings.server\n        mail.settings.sender\n        mail.settings.login\n        mail.settings.timeout = 60 # seconds (default)\n\n    When server is 'logging', email is logged but not sent (debug mode)\n\n    Optionally you can use PGP encryption or X509::\n\n        mail.settings.cipher_type = None\n        mail.settings.gpg_home = None\n        mail.settings.sign = True\n        mail.settings.sign_passphrase = None\n        mail.settings.encrypt = True\n        mail.settings.x509_sign_keyfile = None\n        mail.settings.x509_sign_certfile = None\n        mail.settings.x509_sign_chainfile = None\n        mail.settings.x509_nocerts = False\n        mail.settings.x509_crypt_certfiles = None\n\n        cipher_type       : None\n                            gpg - need a python-pyme package and gpgme lib\n                            x509 - smime\n        gpg_home          : you can set a GNUPGHOME environment variable\n                            to specify home of gnupg\n        sign              : sign the message (True or False)\n        sign_passphrase   : passphrase for key signing\n        encrypt           : encrypt the message (True or False). It defaults\n                            to True\n                         ... x509 only ...\n        x509_sign_keyfile : the signers private key filename or\n                            string containing the key. (PEM format)\n        x509_sign_certfile: the signers certificate filename or\n                            string containing the cert. (PEM format)\n        x509_sign_chainfile: sets the optional all-in-one file where you\n                             can assemble the certificates of Certification\n                             Authorities (CA) which form the certificate\n                             chain of email certificate. It can be a\n                             string containing the certs to. (PEM format)\n        x509_nocerts      : if True then no attached certificate in mail\n        x509_crypt_certfiles: the certificates file or strings to encrypt\n                              the messages with can be a file name /\n                              string or a list of file names /\n                              strings (PEM format)\n\n    Examples:\n        Create Mail object with authentication data for remote server::\n\n            mail = Mail('example.com:25', 'me@example.com', 'me:password')\n\n    Notice for GAE users:\n        attachments have an automatic content_id='attachment-i' where i is progressive number\n        in this way the can be referenced from the HTML as <img src=\"cid:attachment-0\" /> etc.\n    \"\"\"\n\n    class Attachment(MIMEBase.MIMEBase):\n        \"\"\"\n        Email attachment\n\n        Args:\n            payload: path to file or file-like object with read() method\n            filename: name of the attachment stored in message; if set to\n                None, it will be fetched from payload path; file-like\n                object payload must have explicit filename specified\n            content_id: id of the attachment; automatically contained within\n                `<` and `>`\n            content_type: content type of the attachment; if set to None,\n                it will be fetched from filename using gluon.contenttype\n                module\n            encoding: encoding of all strings passed to this function (except\n                attachment body)\n\n        Content ID is used to identify attachments within the html body;\n        in example, attached image with content ID 'photo' may be used in\n        html message as a source of img tag `<img src=\"cid:photo\" />`.\n\n        Example::\n            Create attachment from text file::\n\n                attachment = Mail.Attachment('/path/to/file.txt')\n\n                Content-Type: text/plain\n                MIME-Version: 1.0\n                Content-Disposition: attachment; filename=\"file.txt\"\n                Content-Transfer-Encoding: base64\n\n                SOMEBASE64CONTENT=\n\n            Create attachment from image file with custom filename and cid::\n\n                attachment = Mail.Attachment('/path/to/file.png',\n                                                 filename='photo.png',\n                                                 content_id='photo')\n\n                Content-Type: image/png\n                MIME-Version: 1.0\n                Content-Disposition: attachment; filename=\"photo.png\"\n                Content-Id: <photo>\n                Content-Transfer-Encoding: base64\n\n                SOMEOTHERBASE64CONTENT=\n        \"\"\"\n\n        def __init__(\n            self,\n            payload,\n            filename=None,\n            content_id=None,\n            content_type=None,\n                encoding='utf-8'):\n            if isinstance(payload, str):\n                if filename is None:\n                    filename = os.path.basename(payload)\n                payload = read_file(payload, 'rb')\n            else:\n                if filename is None:\n                    raise Exception('Missing attachment name')\n                payload = payload.read()\n            filename = filename.encode(encoding)\n            if content_type is None:\n                content_type = contenttype(filename)\n            self.my_filename = filename\n            self.my_payload = payload\n            MIMEBase.MIMEBase.__init__(self, *content_type.split('/', 1))\n            self.set_payload(payload)\n            self['Content-Disposition'] = 'attachment; filename=\"%s\"' % filename\n            if not content_id is None:\n                self['Content-Id'] = '<%s>' % content_id.encode(encoding)\n            Encoders.encode_base64(self)\n\n    def __init__(self, server=None, sender=None, login=None, tls=True):\n\n        settings = self.settings = Settings()\n        settings.server = server\n        settings.sender = sender\n        settings.login = login\n        settings.tls = tls\n        settings.timeout = 60 # seconds\n        settings.hostname = None\n        settings.ssl = False\n        settings.cipher_type = None\n        settings.gpg_home = None\n        settings.sign = True\n        settings.sign_passphrase = None\n        settings.encrypt = True\n        settings.x509_sign_keyfile = None\n        settings.x509_sign_certfile = None\n        settings.x509_sign_chainfile = None\n        settings.x509_nocerts = False\n        settings.x509_crypt_certfiles = None\n        settings.debug = False\n        settings.lock_keys = True\n        self.result = {}\n        self.error = None\n\n    def send(self,\n             to,\n             subject='[no subject]',\n             message='[no message]',\n             attachments=None,\n             cc=None,\n             bcc=None,\n             reply_to=None,\n             sender=None,\n             encoding='utf-8',\n             raw=False,\n             headers={},\n             from_address=None,\n             cipher_type=None,\n             sign=None,\n             sign_passphrase=None,\n             encrypt=None,\n             x509_sign_keyfile=None,\n             x509_sign_chainfile=None,\n             x509_sign_certfile=None,\n             x509_crypt_certfiles=None,\n             x509_nocerts=None\n             ):\n        \"\"\"\n        Sends an email using data specified in constructor\n\n        Args:\n            to: list or tuple of receiver addresses; will also accept single\n                object\n            subject: subject of the email\n            message: email body text; depends on type of passed object:\n\n                - if 2-list or 2-tuple is passed: first element will be\n                  source of plain text while second of html text;\n                - otherwise: object will be the only source of plain text\n                  and html source will be set to None\n\n                If text or html source is:\n\n                - None: content part will be ignored,\n                - string: content part will be set to it,\n                - file-like object: content part will be fetched from it using\n                  it's read() method\n            attachments: list or tuple of Mail.Attachment objects; will also\n                accept single object\n            cc: list or tuple of carbon copy receiver addresses; will also\n                accept single object\n            bcc: list or tuple of blind carbon copy receiver addresses; will\n                also accept single object\n            reply_to: address to which reply should be composed\n            encoding: encoding of all strings passed to this method (including\n                message bodies)\n            headers: dictionary of headers to refine the headers just before\n                sending mail, e.g. `{'X-Mailer' : 'web2py mailer'}`\n            from_address: address to appear in the 'From:' header, this is not\n                the envelope sender. If not specified the sender will be used\n\n            cipher_type :\n                gpg - need a python-pyme package and gpgme lib\n                x509 - smime\n            gpg_home : you can set a GNUPGHOME environment variable\n                to specify home of gnupg\n            sign : sign the message (True or False)\n            sign_passphrase  : passphrase for key signing\n            encrypt : encrypt the message (True or False). It defaults to True.\n                         ... x509 only ...\n            x509_sign_keyfile : the signers private key filename or\n                string containing the key. (PEM format)\n            x509_sign_certfile: the signers certificate filename or\n                string containing the cert. (PEM format)\n            x509_sign_chainfile: sets the optional all-in-one file where you\n                can assemble the certificates of Certification\n                Authorities (CA) which form the certificate\n                chain of email certificate. It can be a\n                string containing the certs to. (PEM format)\n            x509_nocerts : if True then no attached certificate in mail\n            x509_crypt_certfiles: the certificates file or strings to encrypt\n                the messages with can be a file name / string or\n                a list of file names / strings (PEM format)\n        Examples:\n            Send plain text message to single address::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          'Plain text body of the message')\n\n            Send html message to single address::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          '<html>Plain text body of the message</html>')\n\n            Send text and html message to three addresses (two in cc)::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          ('Plain text body', '<html>html body</html>'),\n                          cc=['other1@example.com', 'other2@example.com'])\n\n            Send html only message with image attachment available from the\n            message by 'photo' content id::\n\n                mail.send('you@example.com',\n                          'Message subject',\n                          (None, '<html><img src=\"cid:photo\" /></html>'),\n                          Mail.Attachment('/path/to/photo.jpg'\n                                          content_id='photo'))\n\n            Send email with two attachments and no body text::\n\n                mail.send('you@example.com,\n                          'Message subject',\n                          None,\n                          [Mail.Attachment('/path/to/fist.file'),\n                           Mail.Attachment('/path/to/second.file')])\n\n        Returns:\n            True on success, False on failure.\n\n        Before return, method updates two object's fields:\n\n            - self.result: return value of smtplib.SMTP.sendmail() or GAE's\n              mail.send_mail() method\n            - self.error: Exception message or None if above was successful\n        \"\"\"\n\n        # We don't want to use base64 encoding for unicode mail\n        Charset.add_charset('utf-8', Charset.QP, Charset.QP, 'utf-8')\n\n        def encode_header(key):\n            if [c for c in key if 32 > ord(c) or ord(c) > 127]:\n                return Header.Header(key.encode('utf-8'), 'utf-8')\n            else:\n                return key\n\n        # encoded or raw text\n        def encoded_or_raw(text):\n            if raw:\n                text = encode_header(text)\n            return text\n\n        sender = sender or self.settings.sender\n\n        if not isinstance(self.settings.server, str):\n            raise Exception('Server address not specified')\n        if not isinstance(sender, str):\n            raise Exception('Sender address not specified')\n\n        if not raw and attachments:\n            # Use multipart/mixed if there is attachments\n            payload_in = MIMEMultipart.MIMEMultipart('mixed')\n        elif raw:\n            # no encoding configuration for raw messages\n            if not isinstance(message, basestring):\n                message = message.read()\n            if isinstance(message, unicode):\n                text = message.encode('utf-8')\n            elif not encoding == 'utf-8':\n                text = message.decode(encoding).encode('utf-8')\n            else:\n                text = message\n            # No charset passed to avoid transport encoding\n            # NOTE: some unicode encoded strings will produce\n            # unreadable mail contents.\n            payload_in = MIMEText.MIMEText(text)\n        if to:\n            if not isinstance(to, (list, tuple)):\n                to = [to]\n        else:\n            raise Exception('Target receiver address not specified')\n        if cc:\n            if not isinstance(cc, (list, tuple)):\n                cc = [cc]\n        if bcc:\n            if not isinstance(bcc, (list, tuple)):\n                bcc = [bcc]\n        if message is None:\n            text = html = None\n        elif isinstance(message, (list, tuple)):\n            text, html = message\n        elif message.strip().startswith('<html') and \\\n                message.strip().endswith('</html>'):\n            text = self.settings.server == 'gae' and message or None\n            html = message\n        else:\n            text = message\n            html = None\n\n        if (not text is None or not html is None) and (not raw):\n\n            if not text is None:\n                if not isinstance(text, basestring):\n                    text = text.read()\n                if isinstance(text, unicode):\n                    text = text.encode('utf-8')\n                elif not encoding == 'utf-8':\n                    text = text.decode(encoding).encode('utf-8')\n            if not html is None:\n                if not isinstance(html, basestring):\n                    html = html.read()\n                if isinstance(html, unicode):\n                    html = html.encode('utf-8')\n                elif not encoding == 'utf-8':\n                    html = html.decode(encoding).encode('utf-8')\n\n            # Construct mime part only if needed\n            if text is not None and html:\n                # We have text and html we need multipart/alternative\n                attachment = MIMEMultipart.MIMEMultipart('alternative')\n                attachment.attach(MIMEText.MIMEText(text, _charset='utf-8'))\n                attachment.attach(\n                    MIMEText.MIMEText(html, 'html', _charset='utf-8'))\n            elif text is not None:\n                attachment = MIMEText.MIMEText(text, _charset='utf-8')\n            elif html:\n                attachment = \\\n                    MIMEText.MIMEText(html, 'html', _charset='utf-8')\n\n            if attachments:\n                # If there is attachments put text and html into\n                # multipart/mixed\n                payload_in.attach(attachment)\n            else:\n                # No attachments no multipart/mixed\n                payload_in = attachment\n\n        if (attachments is None) or raw:\n            pass\n        elif isinstance(attachments, (list, tuple)):\n            for attachment in attachments:\n                payload_in.attach(attachment)\n        else:\n            payload_in.attach(attachments)\n\n        #######################################################\n        #                      CIPHER                         #\n        #######################################################\n        cipher_type = cipher_type or self.settings.cipher_type\n        sign = sign if sign != None else self.settings.sign\n        sign_passphrase = sign_passphrase or self.settings.sign_passphrase\n        encrypt = encrypt if encrypt != None else self.settings.encrypt\n        #######################################################\n        #                       GPGME                         #\n        #######################################################\n        if cipher_type == 'gpg':\n            if self.settings.gpg_home:\n                # Set GNUPGHOME environment variable to set home of gnupg\n                import os\n                os.environ['GNUPGHOME'] = self.settings.gpg_home\n            if not sign and not encrypt:\n                self.error = \"No sign and no encrypt is set but cipher type to gpg\"\n                return False\n\n            # need a python-pyme package and gpgme lib\n            from pyme import core, errors\n            from pyme.constants.sig import mode\n            ############################################\n            #                   sign                   #\n            ############################################\n            if sign:\n                import string\n                core.check_version(None)\n                pin = string.replace(payload_in.as_string(), '\\n', '\\r\\n')\n                plain = core.Data(pin)\n                sig = core.Data()\n                c = core.Context()\n                c.set_armor(1)\n                c.signers_clear()\n                # search for signing key for From:\n                for sigkey in c.op_keylist_all(sender, 1):\n                    if sigkey.can_sign:\n                        c.signers_add(sigkey)\n                if not c.signers_enum(0):\n                    self.error = 'No key for signing [%s]' % sender\n                    return False\n                c.set_passphrase_cb(lambda x, y, z: sign_passphrase)\n                try:\n                    # make a signature\n                    c.op_sign(plain, sig, mode.DETACH)\n                    sig.seek(0, 0)\n                    # make it part of the email\n                    payload = MIMEMultipart.MIMEMultipart('signed',\n                                                          boundary=None,\n                                                          _subparts=None,\n                                                          **dict(\n                                                          micalg=\"pgp-sha1\",\n                                                          protocol=\"application/pgp-signature\"))\n                    # insert the origin payload\n                    payload.attach(payload_in)\n                    # insert the detached signature\n                    p = MIMEBase.MIMEBase(\"application\", 'pgp-signature')\n                    p.set_payload(sig.read())\n                    payload.attach(p)\n                    # it's just a trick to handle the no encryption case\n                    payload_in = payload\n                except errors.GPGMEError, ex:\n                    self.error = \"GPG error: %s\" % ex.getstring()\n                    return False\n            ############################################\n            #                  encrypt                 #\n            ############################################\n            if encrypt:\n                core.check_version(None)\n                plain = core.Data(payload_in.as_string())\n                cipher = core.Data()\n                c = core.Context()\n                c.set_armor(1)\n                # collect the public keys for encryption\n                recipients = []\n                rec = to[:]\n                if cc:\n                    rec.extend(cc)\n                if bcc:\n                    rec.extend(bcc)\n                for addr in rec:\n                    c.op_keylist_start(addr, 0)\n                    r = c.op_keylist_next()\n                    if r is None:\n                        self.error = 'No key for [%s]' % addr\n                        return False\n                    recipients.append(r)\n                try:\n                    # make the encryption\n                    c.op_encrypt(recipients, 1, plain, cipher)\n                    cipher.seek(0, 0)\n                    # make it a part of the email\n                    payload = MIMEMultipart.MIMEMultipart('encrypted',\n                                                          boundary=None,\n                                                          _subparts=None,\n                                                          **dict(protocol=\"application/pgp-encrypted\"))\n                    p = MIMEBase.MIMEBase(\"application\", 'pgp-encrypted')\n                    p.set_payload(\"Version: 1\\r\\n\")\n                    payload.attach(p)\n                    p = MIMEBase.MIMEBase(\"application\", 'octet-stream')\n                    p.set_payload(cipher.read())\n                    payload.attach(p)\n                except errors.GPGMEError, ex:\n                    self.error = \"GPG error: %s\" % ex.getstring()\n                    return False\n        #######################################################\n        #                       X.509                         #\n        #######################################################\n        elif cipher_type == 'x509':\n            if not sign and not encrypt:\n                self.error = \"No sign and no encrypt is set but cipher type to x509\"\n                return False\n            import os\n            x509_sign_keyfile = x509_sign_keyfile or\\\n                                      self.settings.x509_sign_keyfile\n\n            x509_sign_chainfile = x509_sign_chainfile or\\\n                                      self.settings.x509_sign_chainfile\n\n            x509_sign_certfile = x509_sign_certfile or\\\n                                      self.settings.x509_sign_certfile or\\\n                                      x509_sign_keyfile or\\\n                                      self.settings.x509_sign_certfile\n\n            # crypt certfiles could be a string or a list\n            x509_crypt_certfiles = x509_crypt_certfiles or\\\n                                      self.settings.x509_crypt_certfiles\n\n            x509_nocerts = x509_nocerts or\\\n                                      self.settings.x509_nocerts\n\n            # need m2crypto\n            try:\n                from M2Crypto import BIO, SMIME, X509\n            except Exception, e:\n                self.error = \"Can't load M2Crypto module\"\n                return False\n            msg_bio = BIO.MemoryBuffer(payload_in.as_string())\n            s = SMIME.SMIME()\n\n            # SIGN\n            if sign:\n                # key for signing\n                try:\n                    keyfile_bio = BIO.openfile(x509_sign_keyfile)\\\n                        if os.path.isfile(x509_sign_keyfile)\\\n                        else BIO.MemoryBuffer(x509_sign_keyfile)\n                    sign_certfile_bio = BIO.openfile(x509_sign_certfile)\\\n                        if os.path.isfile(x509_sign_certfile)\\\n                        else BIO.MemoryBuffer(x509_sign_certfile)\n                    s.load_key_bio(keyfile_bio, sign_certfile_bio,\n                                   callback=lambda x: sign_passphrase)\n                    if x509_sign_chainfile:\n                        sk = X509.X509_Stack()\n                        chain = X509.load_cert(x509_sign_chainfile)\\\n                            if os.path.isfile(x509_sign_chainfile)\\\n                            else X509.load_cert_string(x509_sign_chainfile)\n                        sk.push(chain)\n                        s.set_x509_stack(sk)\n                except Exception, e:\n                    self.error = \"Something went wrong on certificate / private key loading: <%s>\" % str(e)\n                    return False\n                try:\n                    if x509_nocerts:\n                        flags = SMIME.PKCS7_NOCERTS\n                    else:\n                        flags = 0\n                    if not encrypt:\n                        flags += SMIME.PKCS7_DETACHED\n                    p7 = s.sign(msg_bio, flags=flags)\n                    msg_bio = BIO.MemoryBuffer(payload_in.as_string(\n                    ))  # Recreate coz sign() has consumed it.\n                except Exception, e:\n                    self.error = \"Something went wrong on signing: <%s> %s\" % (\n                        str(e), str(flags))\n                    return False\n\n            # ENCRYPT\n            if encrypt:\n                try:\n                    sk = X509.X509_Stack()\n                    if not isinstance(x509_crypt_certfiles, (list, tuple)):\n                        x509_crypt_certfiles = [x509_crypt_certfiles]\n\n                    # make an encryption cert's stack\n                    for crypt_certfile in x509_crypt_certfiles:\n                        certfile = X509.load_cert(crypt_certfile)\\\n                             if os.path.isfile(crypt_certfile)\\\n                             else X509.load_cert_string(crypt_certfile)\n                        sk.push(certfile)\n                    s.set_x509_stack(sk)\n\n                    s.set_cipher(SMIME.Cipher('des_ede3_cbc'))\n                    tmp_bio = BIO.MemoryBuffer()\n                    if sign:\n                        s.write(tmp_bio, p7)\n                    else:\n                        tmp_bio.write(payload_in.as_string())\n                    p7 = s.encrypt(tmp_bio)\n                except Exception, e:\n                    self.error = \"Something went wrong on encrypting: <%s>\" % str(e)\n                    return False\n\n            # Final stage in sign and encryption\n            out = BIO.MemoryBuffer()\n            if encrypt:\n                s.write(out, p7)\n            else:\n                if sign:\n                    s.write(out, p7, msg_bio, SMIME.PKCS7_DETACHED)\n                else:\n                    out.write('\\r\\n')\n                    out.write(payload_in.as_string())\n            out.close()\n            st = str(out.read())\n            payload = message_from_string(st)\n        else:\n            # no cryptography process as usual\n            payload = payload_in\n\n        if from_address:\n            payload['From'] = encoded_or_raw(from_address.decode(encoding))\n        else:\n            payload['From'] = encoded_or_raw(sender.decode(encoding))\n        origTo = to[:]\n        if to:\n            payload['To'] = encoded_or_raw(', '.join(to).decode(encoding))\n        if reply_to:\n            payload['Reply-To'] = encoded_or_raw(reply_to.decode(encoding))\n        if cc:\n            payload['Cc'] = encoded_or_raw(', '.join(cc).decode(encoding))\n            to.extend(cc)\n        if bcc:\n            to.extend(bcc)\n        payload['Subject'] = encoded_or_raw(subject.decode(encoding))\n        payload['Date'] = email.utils.formatdate()\n        for k, v in headers.iteritems():\n            payload[k] = encoded_or_raw(v.decode(encoding))\n        result = {}\n        try:\n            if self.settings.server == 'logging':\n                logger.warn('email not sent\\n%s\\nFrom: %s\\nTo: %s\\nSubject: %s\\n\\n%s\\n%s\\n' %\n                            ('-' * 40, sender,\n                                ', '.join(to), subject,\n                                text or html, '-' * 40))\n            elif self.settings.server == 'gae':\n                xcc = dict()\n                if cc:\n                    xcc['cc'] = cc\n                if bcc:\n                    xcc['bcc'] = bcc\n                if reply_to:\n                    xcc['reply_to'] = reply_to\n                from google.appengine.api import mail\n                attachments = attachments and [mail.Attachment(\n                        a.my_filename,\n                        a.my_payload,\n                        contebt_id='<attachment-%s>' % k\n                        ) for k,a in enumerate(attachments) if not raw]\n                if attachments:\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), html=html,\n                        attachments=attachments, **xcc)\n                elif html and (not raw):\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), html=html, **xcc)\n                else:\n                    result = mail.send_mail(\n                        sender=sender, to=origTo,\n                        subject=unicode(subject), body=unicode(text), **xcc)\n            else:\n                smtp_args = self.settings.server.split(':')\n                kwargs = dict(timeout=self.settings.timeout)\n                if self.settings.ssl:\n                    server = smtplib.SMTP_SSL(*smtp_args, **kwargs)\n                else:\n                    server = smtplib.SMTP(*smtp_args, **kwargs)\n                if self.settings.tls and not self.settings.ssl:\n                    server.ehlo(self.settings.hostname)\n                    server.starttls()\n                    server.ehlo(self.settings.hostname)\n                if self.settings.login:\n                    server.login(*self.settings.login.split(':', 1))\n                result = server.sendmail(\n                    sender, to, payload.as_string())\n                server.quit()\n        except Exception, e:\n            logger.warn('Mail.send failure:%s' % e)\n            self.result = result\n            self.error = e\n            return False\n        self.result = result\n        self.error = None\n        return True\n\n\nclass Recaptcha(DIV):\n\n    \"\"\"\n    Examples:\n        Use as::\n\n            form = FORM(Recaptcha(public_key='...',private_key='...'))\n\n        or::\n\n            form = SQLFORM(...)\n            form.append(Recaptcha(public_key='...',private_key='...'))\n\n    \"\"\"\n\n    API_SSL_SERVER = 'https://www.google.com/recaptcha/api'\n    API_SERVER = 'http://www.google.com/recaptcha/api'\n    VERIFY_SERVER = 'http://www.google.com/recaptcha/api/verify'\n\n    def __init__(self,\n                 request=None,\n                 public_key='',\n                 private_key='',\n                 use_ssl=False,\n                 error=None,\n                 error_message='invalid',\n                 label='Verify:',\n                 options='',\n                 comment='',\n                 ajax=False\n    ):\n        request = request or current.request\n        self.request_vars = request and request.vars or current.request.vars\n        self.remote_addr = request.env.remote_addr\n        self.public_key = public_key\n        self.private_key = private_key\n        self.use_ssl = use_ssl\n        self.error = error\n        self.errors = Storage()\n        self.error_message = error_message\n        self.components = []\n        self.attributes = {}\n        self.label = label\n        self.options = options\n        self.comment = comment\n        self.ajax = ajax\n\n    def _validate(self):\n\n        # for local testing:\n\n        recaptcha_challenge_field = \\\n            self.request_vars.recaptcha_challenge_field\n        recaptcha_response_field = \\\n            self.request_vars.recaptcha_response_field\n        private_key = self.private_key\n        remoteip = self.remote_addr\n        if not (recaptcha_response_field and recaptcha_challenge_field\n                and len(recaptcha_response_field)\n                and len(recaptcha_challenge_field)):\n            self.errors['captcha'] = self.error_message\n            return False\n        params = urllib.urlencode({\n            'privatekey': private_key,\n            'remoteip': remoteip,\n            'challenge': recaptcha_challenge_field,\n            'response': recaptcha_response_field,\n        })\n        request = urllib2.Request(\n            url=self.VERIFY_SERVER,\n            data=params,\n            headers={'Content-type': 'application/x-www-form-urlencoded',\n                     'User-agent': 'reCAPTCHA Python'})\n        httpresp = urllib2.urlopen(request)\n        return_values = httpresp.read().splitlines()\n        httpresp.close()\n        return_code = return_values[0]\n        if return_code == 'true':\n            del self.request_vars.recaptcha_challenge_field\n            del self.request_vars.recaptcha_response_field\n            self.request_vars.captcha = ''\n            return True\n        else:\n            # In case we get an error code, store it so we can get an error message\n            # from the /api/challenge URL as described in the reCAPTCHA api docs.\n            self.error = return_values[1]\n            self.errors['captcha'] = self.error_message\n            return False\n\n    def xml(self):\n        public_key = self.public_key\n        use_ssl = self.use_ssl\n        error_param = ''\n        if self.error:\n            error_param = '&error=%s' % self.error\n        if use_ssl:\n            server = self.API_SSL_SERVER\n        else:\n            server = self.API_SERVER\n        if not self.ajax:\n            captcha = DIV(\n                SCRIPT(\"var RecaptchaOptions = {%s};\" % self.options),\n                SCRIPT(_type=\"text/javascript\",\n                       _src=\"%s/challenge?k=%s%s\" % (server, public_key, error_param)),\n                TAG.noscript(\n                    IFRAME(\n                        _src=\"%s/noscript?k=%s%s\" % (\n                            server, public_key, error_param),\n                        _height=\"300\", _width=\"500\", _frameborder=\"0\"), BR(),\n                    INPUT(\n                        _type='hidden', _name='recaptcha_response_field',\n                        _value='manual_challenge')), _id='recaptcha')\n\n        else: #use Google's ajax interface, needed for LOADed components\n\n            url_recaptcha_js = \"%s/js/recaptcha_ajax.js\" % server\n            RecaptchaOptions = \"var RecaptchaOptions = {%s}\" % self.options\n            script = \"\"\"%(options)s;\n            jQuery.getScript('%(url)s',function() {\n                Recaptcha.create('%(public_key)s',\n                    'recaptcha',jQuery.extend(RecaptchaOptions,{'callback':Recaptcha.focus_response_field}))\n                }) \"\"\" % ({'options': RecaptchaOptions, 'url': url_recaptcha_js, 'public_key': public_key})\n            captcha = DIV(\n                SCRIPT(\n                    script,\n                    _type=\"text/javascript\",\n                ),\n                TAG.noscript(\n                    IFRAME(\n                        _src=\"%s/noscript?k=%s%s\" % (\n                            server, public_key, error_param),\n                        _height=\"300\", _width=\"500\", _frameborder=\"0\"), BR(),\n                    INPUT(\n                        _type='hidden', _name='recaptcha_response_field',\n                        _value='manual_challenge')), _id='recaptcha')\n\n        if not self.errors.captcha:\n            return XML(captcha).xml()\n        else:\n            captcha.append(DIV(self.errors['captcha'], _class='error'))\n            return XML(captcha).xml()\n\n\nclass Recaptcha2(DIV):\n    \"\"\"\n    Experimental:\n    Creates a DIV holding the newer Recaptcha from Google (v2)\n\n    Args:\n        request : the request. If not passed, uses current request\n        public_key : the public key Google gave you\n        private_key : the private key Google gave you\n        error_message : the error message to show if verification fails\n        label : the label to use\n        options (dict) : takes these parameters\n\n            - hl\n            - theme\n            - type\n            - tabindex\n            - callback\n            - expired-callback\n\n            see https://developers.google.com/recaptcha/docs/display for docs about those\n\n        comment : the comment\n\n    Examples:\n        Use as::\n\n            form = FORM(Recaptcha2(public_key='...',private_key='...'))\n\n        or::\n\n            form = SQLFORM(...)\n            form.append(Recaptcha2(public_key='...',private_key='...'))\n\n        to protect the login page instead, use::\n\n            from gluon.tools import Recaptcha2\n            auth.settings.captcha = Recaptcha2(request, public_key='...',private_key='...')\n\n    \"\"\"\n\n    API_URI = 'https://www.google.com/recaptcha/api.js'\n    VERIFY_SERVER = 'https://www.google.com/recaptcha/api/siteverify'\n\n    def __init__(self,\n                 request=None,\n                 public_key='',\n                 private_key='',\n                 error_message='invalid',\n                 label='Verify:',\n                 options=None,\n                 comment='',\n                 ):\n        request = request or current.request\n        self.request_vars = request and request.vars or current.request.vars\n        self.remote_addr = request.env.remote_addr\n        self.public_key = public_key\n        self.private_key = private_key\n        self.errors = Storage()\n        self.error_message = error_message\n        self.components = []\n        self.attributes = {}\n        self.label = label\n        self.options = options or {}\n        self.comment = comment\n\n    def _validate(self):\n        recaptcha_response_field = self.request_vars.pop('g-recaptcha-response', None)\n        remoteip = self.remote_addr\n        if not recaptcha_response_field:\n            self.errors['captcha'] = self.error_message\n            return False\n        params = urllib.urlencode({\n            'secret': self.private_key,\n            'remoteip': remoteip,\n            'response': recaptcha_response_field,\n        })\n        request = urllib2.Request(\n            url=self.VERIFY_SERVER,\n            data=params,\n            headers={'Content-type': 'application/x-www-form-urlencoded',\n                     'User-agent': 'reCAPTCHA Python'})\n        httpresp = urllib2.urlopen(request)\n        content = httpresp.read()\n        httpresp.close()\n        try:\n            response_dict = json_parser.loads(content)\n        except:\n            self.errors['captcha'] = self.error_message\n            return False\n        if response_dict.get('success', False):\n            self.request_vars.captcha = ''\n            return True\n        else:\n            self.errors['captcha'] = self.error_message\n            return False\n\n    def xml(self):\n        api_uri = self.API_URI\n        hl = self.options.pop('hl', None)\n        if hl:\n            api_uri = self.API_URI + '?hl=%s' % hl\n        public_key = self.public_key\n        self.options['sitekey'] = public_key\n        captcha = DIV(\n            SCRIPT(_src=api_uri, _async='', _defer=''),\n            DIV(_class=\"g-recaptcha\", data=self.options),\n            TAG.noscript(XML(\"\"\"\n<div style=\"width: 302px; height: 352px;\">\n<div style=\"width: 302px; height: 352px; position: relative;\">\n  <div style=\"width: 302px; height: 352px; position: absolute;\">\n    <iframe src=\"https://www.google.com/recaptcha/api/fallback?k=%(public_key)s\"\n            frameborder=\"0\" scrolling=\"no\"\n            style=\"width: 302px; height:352px; border-style: none;\">\n    </iframe>\n  </div>\n  <div style=\"width: 250px; height: 80px; position: absolute; border-style: none;\n              bottom: 21px; left: 25px; margin: 0px; padding: 0px; right: 25px;\">\n    <textarea id=\"g-recaptcha-response\" name=\"g-recaptcha-response\"\n              class=\"g-recaptcha-response\"\n              style=\"width: 250px; height: 80px; border: 1px solid #c1c1c1;\n                     margin: 0px; padding: 0px; resize: none;\" value=\"\">\n    </textarea>\n  </div>\n</div>\n</div>\"\"\" % dict(public_key=public_key))\n            )\n        )\n        if not self.errors.captcha:\n            return XML(captcha).xml()\n        else:\n            captcha.append(DIV(self.errors['captcha'], _class='error'))\n            return XML(captcha).xml()\n\n\n# this should only be used for captcha and perhaps not even for that\ndef addrow(form, a, b, c, style, _id, position=-1):\n    if style == \"divs\":\n        form[0].insert(position, DIV(DIV(LABEL(a), _class='w2p_fl'),\n                                     DIV(b, _class='w2p_fw'),\n                                     DIV(c, _class='w2p_fc'),\n                                     _id=_id))\n    elif style == \"table2cols\":\n        form[0].insert(position, TR(TD(LABEL(a), _class='w2p_fl'),\n                                    TD(c, _class='w2p_fc')))\n        form[0].insert(position + 1, TR(TD(b, _class='w2p_fw'),\n                                        _colspan=2, _id=_id))\n    elif style == \"ul\":\n        form[0].insert(position, LI(DIV(LABEL(a), _class='w2p_fl'),\n                                    DIV(b, _class='w2p_fw'),\n                                    DIV(c, _class='w2p_fc'),\n                                    _id=_id))\n    elif style == \"bootstrap\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label'),\n                                     DIV(b, SPAN(c, _class='inline-help'),\n                                         _class='controls'),\n                                     _class='control-group', _id=_id))\n    elif style == \"bootstrap3_inline\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label col-sm-3'),\n                                     DIV(b, SPAN(c, _class='help-block'),\n                                         _class='col-sm-9'),\n                                     _class='form-group', _id=_id))\n    elif style == \"bootstrap3_stacked\":\n        form[0].insert(position, DIV(LABEL(a, _class='control-label'),\n                                     b, SPAN(c, _class='help-block'),\n                                     _class='form-group', _id=_id))\n    else:\n        form[0].insert(position, TR(TD(LABEL(a), _class='w2p_fl'),\n                                    TD(b, _class='w2p_fw'),\n                                    TD(c, _class='w2p_fc'), _id=_id))\n\n\nclass Auth(object):\n\n    default_settings = dict(\n        hideerror=False,\n        password_min_length=4,\n        cas_maps=None,\n        reset_password_requires_verification=False,\n        registration_requires_verification=False,\n        registration_requires_approval=False,\n        bulk_register_enabled=False,\n        login_after_registration=False,\n        login_after_password_change=True,\n        alternate_requires_registration=False,\n        create_user_groups=\"user_%(id)s\",\n        everybody_group_id=None,\n        manager_actions={},\n        auth_manager_role=None,\n        two_factor_authentication_group = None,\n        login_captcha=None,\n        register_captcha=None,\n        pre_registration_div=None,\n        retrieve_username_captcha=None,\n        retrieve_password_captcha=None,\n        captcha=None,\n        prevent_open_redirect_attacks=True,\n        prevent_password_reset_attacks=True,\n        expiration=3600,            # one hour\n        long_expiration=3600 * 30 * 24,  # one month\n        remember_me_form=True,\n        allow_basic_login=False,\n        allow_basic_login_only=False,\n        on_failed_authentication=lambda x: redirect(x),\n        formstyle=None,\n        label_separator=None,\n        logging_enabled = True,\n        allow_delete_accounts=False,\n        password_field='password',\n        table_user_name='auth_user',\n        table_group_name='auth_group',\n        table_membership_name='auth_membership',\n        table_permission_name='auth_permission',\n        table_event_name='auth_event',\n        table_cas_name='auth_cas',\n        table_token_name='auth_token',\n        table_user=None,\n        table_group=None,\n        table_membership=None,\n        table_permission=None,\n        table_event=None,\n        table_cas=None,\n        showid=False,\n        use_username=False,\n        login_email_validate=True,\n        login_userfield=None,\n        multi_login=False,\n        logout_onlogout=None,\n        register_fields=None,\n        register_verify_password=True,\n        profile_fields=None,\n        email_case_sensitive=True,\n        username_case_sensitive=True,\n        update_fields=['email'],\n        ondelete=\"CASCADE\",\n        client_side=True,\n        renew_session_onlogin=True,\n        renew_session_onlogout=True,\n        keep_session_onlogin=True,\n        keep_session_onlogout=False,\n        wiki=Settings(),\n    )\n        # ## these are messages that can be customized\n    default_messages = dict(\n        login_button='Log In',\n        register_button='Sign Up',\n        password_reset_button='Request reset password',\n        password_change_button='Change password',\n        profile_save_button='Apply changes',\n        submit_button='Submit',\n        verify_password='Verify Password',\n        delete_label='Check to delete',\n        function_disabled='Function disabled',\n        access_denied='Insufficient privileges',\n        registration_verifying='Registration needs verification',\n        registration_pending='Registration is pending approval',\n        email_taken='This email already has an account',\n        invalid_username='Invalid username',\n        username_taken='Username already taken',\n        login_disabled='Login disabled by administrator',\n        logged_in='Logged in',\n        email_sent='Email sent',\n        unable_to_send_email='Unable to send email',\n        email_verified='Email verified',\n        logged_out='Logged out',\n        registration_successful='Registration successful',\n        invalid_email='Invalid email',\n        unable_send_email='Unable to send email',\n        invalid_login='Invalid login',\n        invalid_user='Invalid user',\n        invalid_password='Invalid password',\n        is_empty=\"Cannot be empty\",\n        mismatched_password=\"Password fields don't match\",\n        verify_email='Welcome %(username)s! Click on the link %(link)s to verify your email',\n        verify_email_subject='Email verification',\n        username_sent='Your username was emailed to you',\n        new_password_sent='A new password was emailed to you',\n        password_changed='Password changed',\n        retrieve_username='Your username is: %(username)s',\n        retrieve_username_subject='Username retrieve',\n        retrieve_password='Your password is: %(password)s',\n        retrieve_password_subject='Password retrieve',\n        reset_password='Click on the link %(link)s to reset your password',\n        reset_password_subject='Password reset',\n        bulk_invite_subject='Invitation to join%(site)s',\n        bulk_invite_body='You have been invited to join %(site)s, click %(link)s to complete the process',\n        invalid_reset_password='Invalid reset password',\n        profile_updated='Profile updated',\n        new_password='New password',\n        old_password='Old password',\n        group_description='Group uniquely assigned to user %(id)s',\n        register_log='User %(id)s Registered',\n        login_log='User %(id)s Logged-in',\n        login_failed_log=None,\n        logout_log='User %(id)s Logged-out',\n        profile_log='User %(id)s Profile updated',\n        verify_email_log='User %(id)s Verification email sent',\n        retrieve_username_log='User %(id)s Username retrieved',\n        retrieve_password_log='User %(id)s Password retrieved',\n        reset_password_log='User %(id)s Password reset',\n        change_password_log='User %(id)s Password changed',\n        add_group_log='Group %(group_id)s created',\n        del_group_log='Group %(group_id)s deleted',\n        add_membership_log=None,\n        del_membership_log=None,\n        has_membership_log=None,\n        add_permission_log=None,\n        del_permission_log=None,\n        has_permission_log=None,\n        impersonate_log='User %(id)s is impersonating %(other_id)s',\n        label_first_name='First name',\n        label_last_name='Last name',\n        label_username='Username',\n        label_email='E-mail',\n        label_password='Password',\n        label_registration_key='Registration key',\n        label_reset_password_key='Reset Password key',\n        label_registration_id='Registration identifier',\n        label_role='Role',\n        label_description='Description',\n        label_user_id='User ID',\n        label_group_id='Group ID',\n        label_name='Name',\n        label_table_name='Object or table name',\n        label_record_id='Record ID',\n        label_time_stamp='Timestamp',\n        label_client_ip='Client IP',\n        label_origin='Origin',\n        label_remember_me=\"Remember me (for 30 days)\",\n        verify_password_comment='please input your password again',\n    )\n\n    \"\"\"\n    Class for authentication, authorization, role based access control.\n\n    Includes:\n\n    - registration and profile\n    - login and logout\n    - username and password retrieval\n    - event logging\n    - role creation and assignment\n    - user defined group/role based permission\n\n    Args:\n\n        environment: is there for legacy but unused (awful)\n        db: has to be the database where to create tables for authentication\n        mailer: `Mail(...)` or None (no mailer) or True (make a mailer)\n        hmac_key: can be a hmac_key or hmac_key=Auth.get_or_create_key()\n        controller: (where is the user action?)\n        cas_provider: (delegate authentication to the URL, CAS2)\n\n    Authentication Example::\n\n        from gluon.contrib.utils import *\n        mail=Mail()\n        mail.settings.server='smtp.gmail.com:587'\n        mail.settings.sender='you@somewhere.com'\n        mail.settings.login='username:password'\n        auth=Auth(db)\n        auth.settings.mailer=mail\n        # auth.settings....=...\n        auth.define_tables()\n        def authentication():\n            return dict(form=auth())\n\n    Exposes:\n\n    - `http://.../{application}/{controller}/authentication/login`\n    - `http://.../{application}/{controller}/authentication/logout`\n    - `http://.../{application}/{controller}/authentication/register`\n    - `http://.../{application}/{controller}/authentication/verify_email`\n    - `http://.../{application}/{controller}/authentication/retrieve_username`\n    - `http://.../{application}/{controller}/authentication/retrieve_password`\n    - `http://.../{application}/{controller}/authentication/reset_password`\n    - `http://.../{application}/{controller}/authentication/profile`\n    - `http://.../{application}/{controller}/authentication/change_password`\n\n    On registration a group with role=new_user.id is created\n    and user is given membership of this group.\n\n    You can create a group with::\n\n        group_id=auth.add_group('Manager', 'can access the manage action')\n        auth.add_permission(group_id, 'access to manage')\n\n    Here \"access to manage\" is just a user defined string.\n    You can give access to a user::\n\n        auth.add_membership(group_id, user_id)\n\n    If user id is omitted, the logged in user is assumed\n\n    Then you can decorate any action::\n\n        @auth.requires_permission('access to manage')\n        def manage():\n            return dict()\n\n    You can restrict a permission to a specific table::\n\n        auth.add_permission(group_id, 'edit', db.sometable)\n        @auth.requires_permission('edit', db.sometable)\n\n    Or to a specific record::\n\n        auth.add_permission(group_id, 'edit', db.sometable, 45)\n        @auth.requires_permission('edit', db.sometable, 45)\n\n    If authorization is not granted calls::\n\n        auth.settings.on_failed_authorization\n\n    Other options::\n\n        auth.settings.mailer=None\n        auth.settings.expiration=3600 # seconds\n\n        ...\n\n        ### these are messages that can be customized\n        ...\n\n    \"\"\"\n\n    @staticmethod\n    def get_or_create_key(filename=None, alg='sha512'):\n        request = current.request\n        if not filename:\n            filename = os.path.join(request.folder, 'private', 'auth.key')\n        if os.path.exists(filename):\n            key = open(filename, 'r').read().strip()\n        else:\n            key = alg + ':' + web2py_uuid()\n            open(filename, 'w').write(key)\n        return key\n\n    def url(self, f=None, args=None, vars=None, scheme=False):\n        if args is None:\n            args = []\n        if vars is None:\n            vars = {}\n        return URL(c=self.settings.controller,\n                   f=f, args=args, vars=vars, scheme=scheme)\n\n    def here(self):\n        return URL(args=current.request.args, vars=current.request.get_vars)\n\n    def __init__(self, environment=None, db=None, mailer=True,\n                 hmac_key=None, controller='default', function='user',\n                 cas_provider=None, signature=True, secure=False,\n                 csrf_prevention=True, propagate_extension=None,\n                 url_index=None):\n\n        ## next two lines for backward compatibility\n        if not db and environment and isinstance(environment, DAL):\n            db = environment\n        self.db = db\n        self.environment = current\n        self.csrf_prevention = csrf_prevention\n        request = current.request\n        session = current.session\n        auth = session.auth\n        self.user_groups = auth and auth.user_groups or {}\n        if secure:\n            request.requires_https()\n        now = request.now\n        # if we have auth info\n        #    if not expired it, used it\n        #    if expired, clear the session\n        # else, only clear auth info in the session\n        if auth:\n            delta = datetime.timedelta(days=0, seconds=auth.expiration)\n            if auth.last_visit and auth.last_visit + delta > now:\n                self.user = auth.user\n                # this is a trick to speed up sessions to avoid many writes\n                if (now - auth.last_visit).seconds > (auth.expiration / 10):\n                    auth.last_visit = request.now\n            else:\n                self.user = None\n                if session.auth:\n                    del session.auth\n                session.renew(clear_session=True)\n        else:\n            self.user = None\n            if session.auth:\n                del session.auth\n        # ## what happens after login?\n\n        url_index = url_index or URL(controller, 'index')\n        url_login = URL(controller, function, args='login',\n                        extension = propagate_extension)\n        # ## what happens after registration?\n\n        settings = self.settings = Settings()\n        settings.update(Auth.default_settings)\n        settings.update(\n            cas_domains=[request.env.http_host],\n            enable_tokens=False,\n            cas_provider=cas_provider,\n            cas_actions=dict(login='login',\n                             validate='validate',\n                             servicevalidate='serviceValidate',\n                             proxyvalidate='proxyValidate',\n                             logout='logout'),\n            extra_fields={},\n            actions_disabled=[],\n            controller=controller,\n            function=function,\n            login_url=url_login,\n            logged_url=URL(controller, function, args='profile'),\n            download_url=URL(controller, 'download'),\n            mailer=(mailer is True) and Mail() or mailer,\n            on_failed_authorization = URL(controller, function, args='not_authorized'),\n            login_next = url_index,\n            login_onvalidation = [],\n            login_onaccept = [],\n            login_onfail = [],\n            login_methods = [self],\n            login_form = self,\n            logout_next = url_index,\n            logout_onlogout = None,\n            register_next = url_index,\n            register_onvalidation = [],\n            register_onaccept = [],\n            verify_email_next = url_login,\n            verify_email_onaccept = [],\n            profile_next = url_index,\n            profile_onvalidation = [],\n            profile_onaccept = [],\n            retrieve_username_next = url_index,\n            retrieve_password_next = url_index,\n            request_reset_password_next = url_login,\n            reset_password_next = url_index,\n            change_password_next = url_index,\n            change_password_onvalidation = [],\n            change_password_onaccept = [],\n            retrieve_password_onvalidation = [],\n            request_reset_password_onvalidation = [],\n            request_reset_password_onaccept = [],\n            reset_password_onvalidation = [],\n            reset_password_onaccept = [],\n            hmac_key = hmac_key,\n            formstyle = current.response.formstyle,\n            label_separator = current.response.form_label_separator\n        )\n        settings.lock_keys = True\n        # ## these are messages that can be customized\n        messages = self.messages = Messages(current.T)\n        messages.update(Auth.default_messages)\n        messages.update(ajax_failed_authentication=\n                        DIV(H4('NOT AUTHORIZED'),\n                            'Please ',\n                            A('login',\n                              _href=self.settings.login_url +\n                                    ('?_next=' + urllib.quote(current.request.env.http_web2py_component_location))\n                              if current.request.env.http_web2py_component_location else ''),\n                            ' to view this content.',\n                            _class='not-authorized alert alert-block'))\n        messages.lock_keys = True\n\n        # for \"remember me\" option\n        response = current.response\n        if auth and auth.remember_me:\n            # when user wants to be logged in for longer\n            response.session_cookie_expires = auth.expiration\n        if signature:\n            self.define_signature()\n        else:\n            self.signature = None\n\n    def get_vars_next(self):\n        next = current.request.vars._next\n        if isinstance(next, (list, tuple)):\n            next = next[0]\n        if next and self.settings.prevent_open_redirect_attacks:\n            # Prevent an attacker from adding an arbitrary url after the\n            # _next variable in the request.\n            items = next.split('/')\n            if '//' in next and items[2] != current.request.env.http_host:\n                next = None            \n        return next\n\n    def _get_user_id(self):\n        \"\"\"accessor for auth.user_id\"\"\"\n        return self.user and self.user.id or None\n\n    user_id = property(_get_user_id, doc=\"user.id or None\")\n\n    def table_user(self):\n        return self.db[self.settings.table_user_name]\n\n    def table_group(self):\n        return self.db[self.settings.table_group_name]\n\n    def table_membership(self):\n        return self.db[self.settings.table_membership_name]\n\n    def table_permission(self):\n        return self.db[self.settings.table_permission_name]\n\n    def table_event(self):\n        return self.db[self.settings.table_event_name]\n\n    def table_cas(self):\n        return self.db[self.settings.table_cas_name]\n\n    def table_token(self):\n        return self.db[self.settings.table_token_name]\n\n    def _HTTP(self, *a, **b):\n        \"\"\"\n        only used in lambda: self._HTTP(404)\n        \"\"\"\n\n        raise HTTP(*a, **b)\n\n    def __call__(self):\n        \"\"\"\n        Example:\n            Use as::\n\n                def authentication():\n                    return dict(form=auth())\n\n        \"\"\"\n\n        request = current.request\n        args = request.args\n        if not args:\n            redirect(self.url(args='login', vars=request.vars))\n        elif args[0] in self.settings.actions_disabled:\n            raise HTTP(404)\n        if args[0] in ('login', 'logout', 'register', 'verify_email',\n                       'retrieve_username', 'retrieve_password',\n                       'reset_password', 'request_reset_password',\n                       'change_password', 'profile', 'groups',\n                       'impersonate', 'not_authorized', 'confirm_registration', \n                       'bulk_register','manage_tokens'):\n            if len(request.args) >= 2 and args[0] == 'impersonate':\n                return getattr(self, args[0])(request.args[1])\n            else:\n                return getattr(self, args[0])()\n        elif args[0] == 'cas' and not self.settings.cas_provider:\n            if args(1) == self.settings.cas_actions['login']:\n                return self.cas_login(version=2)\n            elif args(1) == self.settings.cas_actions['validate']:\n                return self.cas_validate(version=1)\n            elif args(1) == self.settings.cas_actions['servicevalidate']:\n                return self.cas_validate(version=2, proxy=False)\n            elif args(1) == self.settings.cas_actions['proxyvalidate']:\n                return self.cas_validate(version=2, proxy=True)\n            elif args(1) == self.settings.cas_actions['logout']:\n                return self.logout(next=request.vars.service or DEFAULT)\n        else:\n            raise HTTP(404)\n\n    def navbar(self, prefix='Welcome', action=None,\n               separators=(' [ ', ' | ', ' ] '), user_identifier=DEFAULT,\n               referrer_actions=DEFAULT, mode='default'):\n        \"\"\" Navbar with support for more templates\n        This uses some code from the old navbar.\n\n        Args:\n            mode: see options for list of\n\n        \"\"\"\n        items = []  # Hold all menu items in a list\n        self.bar = ''  # The final\n        T = current.T\n        referrer_actions = [] if not referrer_actions else referrer_actions\n        if not action:\n            action = self.url(self.settings.function)\n\n        request = current.request\n        if URL() == action:\n            next = ''\n        else:\n            next = '?_next=' + urllib.quote(URL(args=request.args,\n                                                vars=request.get_vars))\n        href = lambda function: '%s/%s%s' % (action, function, next\n                                             if referrer_actions is DEFAULT\n                                             or function in referrer_actions\n                                             else '')\n        if isinstance(prefix, str):\n            prefix = T(prefix)\n        if prefix:\n            prefix = prefix.strip() + ' '\n\n        def Anr(*a, **b):\n            b['_rel'] = 'nofollow'\n            return A(*a, **b)\n\n        if self.user_id:  # User is logged in\n            logout_next = self.settings.logout_next\n            items.append({'name': T('Log Out'),\n                          'href': '%s/logout?_next=%s' % (action,\n                                                          urllib.quote(\n                                                          logout_next)),\n                          'icon': 'icon-off'})\n            if not 'profile' in self.settings.actions_disabled:\n                items.append({'name': T('Profile'), 'href': href('profile'),\n                              'icon': 'icon-user'})\n            if not 'change_password' in self.settings.actions_disabled:\n                items.append({'name': T('Password'),\n                              'href': href('change_password'),\n                              'icon': 'icon-lock'})\n\n            if user_identifier is DEFAULT:\n                user_identifier = '%(first_name)s'\n            if callable(user_identifier):\n                user_identifier = user_identifier(self.user)\n            elif ((isinstance(user_identifier, str) or\n                  type(user_identifier).__name__ == 'lazyT') and\n                  re.search(r'%\\(.+\\)s', user_identifier)):\n                user_identifier = user_identifier % self.user\n            if not user_identifier:\n                user_identifier = ''\n        else:  # User is not logged in\n            items.append({'name': T('Log In'), 'href': href('login'),\n                          'icon': 'icon-off'})\n            if not 'register' in self.settings.actions_disabled:\n                items.append({'name': T('Sign Up'), 'href': href('register'),\n                              'icon': 'icon-user'})\n            if not 'request_reset_password' in self.settings.actions_disabled:\n                items.append({'name': T('Lost password?'),\n                              'href': href('request_reset_password'),\n                              'icon': 'icon-lock'})\n            if (self.settings.use_username and not\n                    'retrieve_username' in self.settings.actions_disabled):\n                items.append({'name': T('Forgot username?'),\n                             'href': href('retrieve_username'),\n                             'icon': 'icon-edit'})\n\n        def menu():  # For inclusion in MENU\n            self.bar = [(items[0]['name'], False, items[0]['href'], [])]\n            del items[0]\n            for item in items:\n                self.bar[0][3].append((item['name'], False, item['href']))\n\n        def bootstrap3():  # Default web2py scaffolding\n            def rename(icon): return icon+' '+icon.replace('icon', 'glyphicon')\n            self.bar = UL(LI(Anr(I(_class=rename('icon '+items[0]['icon'])),\n                                 ' ' + items[0]['name'],\n                                 _href=items[0]['href'])), _class='dropdown-menu')\n            del items[0]\n            for item in items:\n                self.bar.insert(-1, LI(Anr(I(_class=rename('icon '+item['icon'])),\n                                           ' ' + item['name'],\n                                           _href=item['href'])))\n            self.bar.insert(-1, LI('', _class='divider'))\n            if self.user_id:\n                self.bar = LI(Anr(prefix, user_identifier,\n                                  _href='#', _class=\"dropdown-toggle\",\n                                  data={'toggle': 'dropdown'}),\n                              self.bar, _class='dropdown')\n            else:\n                self.bar = LI(Anr(T('Log In'),\n                                  _href='#', _class=\"dropdown-toggle\",\n                                  data={'toggle': 'dropdown'}), self.bar,\n                              _class='dropdown')\n\n        def bare():\n            \"\"\" In order to do advanced customization we only need the\n            prefix, the user_identifier and the href attribute of items\n\n            Examples:\n                Use as::\n\n                # in module custom_layout.py\n                from gluon import *\n                def navbar(auth_navbar):\n                    bar = auth_navbar\n                    user = bar[\"user\"]\n\n                    if not user:\n                        btn_login = A(current.T(\"Login\"),\n                                      _href=bar[\"login\"],\n                                      _class=\"btn btn-success\",\n                                      _rel=\"nofollow\")\n                        btn_register = A(current.T(\"Sign up\"),\n                                         _href=bar[\"register\"],\n                                         _class=\"btn btn-primary\",\n                                         _rel=\"nofollow\")\n                        return DIV(btn_register, btn_login, _class=\"btn-group\")\n                    else:\n                        toggletext = \"%s back %s\" % (bar[\"prefix\"], user)\n                        toggle = A(toggletext,\n                                   _href=\"#\",\n                                   _class=\"dropdown-toggle\",\n                                   _rel=\"nofollow\",\n                                   **{\"_data-toggle\": \"dropdown\"})\n                        li_profile = LI(A(I(_class=\"icon-user\"), ' ',\n                                          current.T(\"Account details\"),\n                                          _href=bar[\"profile\"], _rel=\"nofollow\"))\n                        li_custom = LI(A(I(_class=\"icon-book\"), ' ',\n                                         current.T(\"My Agenda\"),\n                                         _href=\"#\", rel=\"nofollow\"))\n                        li_logout = LI(A(I(_class=\"icon-off\"), ' ',\n                                         current.T(\"logout\"),\n                                         _href=bar[\"logout\"], _rel=\"nofollow\"))\n                        dropdown = UL(li_profile,\n                                      li_custom,\n                                      LI('', _class=\"divider\"),\n                                      li_logout,\n                                      _class=\"dropdown-menu\", _role=\"menu\")\n\n                        return LI(toggle, dropdown, _class=\"dropdown\")\n\n                # in models db.py\n                import custom_layout as custom\n\n                # in layout.html\n                <ul id=\"navbar\" class=\"nav pull-right\">\n                    {{='auth' in globals() and \\\n                      custom.navbar(auth.navbar(mode='bare')) or ''}}</ul>\n\n            \"\"\"\n            bare = {}\n\n            bare['prefix'] = prefix\n            bare['user'] = user_identifier if self.user_id else None\n\n            for i in items:\n                if i['name'] == T('Log In'):\n                    k = 'login'\n                elif i['name'] == T('Sign Up'):\n                    k = 'register'\n                elif i['name'] == T('Lost password?'):\n                    k = 'request_reset_password'\n                elif i['name'] == T('Forgot username?'):\n                    k = 'retrieve_username'\n                elif i['name'] == T('Log Out'):\n                    k = 'logout'\n                elif i['name'] == T('Profile'):\n                    k = 'profile'\n                elif i['name'] == T('Password'):\n                    k = 'change_password'\n\n                bare[k] = i['href']\n\n            self.bar = bare\n\n        options = {'asmenu': menu,\n                   'dropdown': bootstrap3,\n                   'bare': bare\n                   }  # Define custom modes.\n\n        if mode in options and callable(options[mode]):\n            options[mode]()\n        else:\n            s1, s2, s3 = separators\n            if self.user_id:\n                self.bar = SPAN(prefix, user_identifier, s1,\n                                Anr(items[0]['name'],\n                                _href=items[0]['href']), s3,\n                                _class='auth_navbar')\n            else:\n                self.bar = SPAN(s1, Anr(items[0]['name'],\n                                _href=items[0]['href']), s3,\n                                _class='auth_navbar')\n            for item in items[1:]:\n                self.bar.insert(-1, s2)\n                self.bar.insert(-1, Anr(item['name'], _href=item['href']))\n\n        return self.bar\n\n    def __get_migrate(self, tablename, migrate=True):\n\n        if type(migrate).__name__ == 'str':\n            return (migrate + tablename + '.table')\n        elif migrate == False:\n            return False\n        else:\n            return True\n\n    def enable_record_versioning(self,\n                                 tables,\n                                 archive_db=None,\n                                 archive_names='%(tablename)s_archive',\n                                 current_record='current_record',\n                                 current_record_label=None):\n        \"\"\"\n        Used to enable full record versioning (including auth tables)::\n\n            auth = Auth(db)\n            auth.define_tables(signature=True)\n            # define our own tables\n            db.define_table('mything',Field('name'),auth.signature)\n            auth.enable_record_versioning(tables=db)\n\n        tables can be the db (all table) or a list of tables.\n        only tables with modified_by and modified_on fiels (as created\n        by auth.signature) will have versioning. Old record versions will be\n        in table 'mything_archive' automatically defined.\n\n        when you enable enable_record_versioning, records are never\n        deleted but marked with is_active=False.\n\n        enable_record_versioning enables a common_filter for\n        every table that filters out records with is_active = False\n\n        Note:\n            If you use auth.enable_record_versioning,\n            do not use auth.archive or you will end up with duplicates.\n            auth.archive does explicitly what enable_record_versioning\n            does automatically.\n\n        \"\"\"\n        current_record_label = current_record_label or current.T(\n            current_record.replace('_', ' ').title())\n        for table in tables:\n            fieldnames = table.fields()\n            if ('id' in fieldnames and\n                'modified_on' in fieldnames and\n                not current_record in fieldnames):\n                table._enable_record_versioning(\n                    archive_db=archive_db,\n                    archive_name=archive_names,\n                    current_record=current_record,\n                    current_record_label=current_record_label)\n\n    def define_signature(self):\n        db = self.db\n        settings = self.settings\n        request = current.request\n        T = current.T\n        reference_user = 'reference %s' % settings.table_user_name\n\n        def lazy_user(auth=self):\n            return auth.user_id\n\n        def represent(id, record=None, s=settings):\n            try:\n                user = s.table_user(id)\n                return '%s %s' % (user.get(\"first_name\", user.get(\"email\")),\n                                  user.get(\"last_name\", ''))\n            except:\n                return id\n        ondelete = self.settings.ondelete\n        self.signature = Table(\n            self.db, 'auth_signature',\n            Field('is_active', 'boolean',\n                  default=True,\n                  readable=False, writable=False,\n                  label=T('Is Active')),\n            Field('created_on', 'datetime',\n                  default=request.now,\n                  writable=False, readable=False,\n                  label=T('Created On')),\n            Field('created_by',\n                  reference_user,\n                  default=lazy_user, represent=represent,\n                  writable=False, readable=False,\n                  label=T('Created By'), ondelete=ondelete),\n            Field('modified_on', 'datetime',\n                  update=request.now, default=request.now,\n                  writable=False, readable=False,\n                  label=T('Modified On')),\n            Field('modified_by',\n                  reference_user, represent=represent,\n                  default=lazy_user, update=lazy_user,\n                  writable=False, readable=False,\n                  label=T('Modified By'),  ondelete=ondelete))\n\n    def define_tables(self, username=None, signature=None, enable_tokens=False,\n                      migrate=None, fake_migrate=None):\n        \"\"\"\n        To be called unless tables are defined manually\n\n        Examples:\n            Use as::\n\n                # defines all needed tables and table files\n                # 'myprefix_auth_user.table', ...\n                auth.define_tables(migrate='myprefix_')\n\n                # defines all needed tables without migration/table files\n                auth.define_tables(migrate=False)\n\n        \"\"\"\n\n        db = self.db\n        if migrate is None:\n            migrate = db._migrate\n        if fake_migrate is None:\n            fake_migrate = db._fake_migrate\n        settings = self.settings\n        if username is None:\n            username = settings.use_username\n        else:\n            settings.use_username = username\n        settings.enable_tokens = enable_tokens\n        if not self.signature:\n            self.define_signature()\n        if signature == True:\n            signature_list = [self.signature]\n        elif not signature:\n            signature_list = []\n        elif isinstance(signature, Table):\n            signature_list = [signature]\n        else:\n            signature_list = signature\n        is_not_empty = IS_NOT_EMPTY(error_message=self.messages.is_empty)\n        is_crypted = CRYPT(key=settings.hmac_key,\n                           min_length=settings.password_min_length)\n        is_unique_email = [\n            IS_EMAIL(error_message=self.messages.invalid_email),\n            IS_NOT_IN_DB(db, '%s.email' % settings.table_user_name,\n                         error_message=self.messages.email_taken)]\n        if not settings.email_case_sensitive:\n            is_unique_email.insert(1, IS_LOWER())\n        if not settings.table_user_name in db.tables:\n            passfield = settings.password_field\n            extra_fields = settings.extra_fields.get(\n                settings.table_user_name, []) + signature_list\n            if username or settings.cas_provider:\n                is_unique_username = \\\n                    [IS_MATCH('[\\w\\.\\-]+', strict=True,\n                              error_message=self.messages.invalid_username),\n                     IS_NOT_IN_DB(db, '%s.username' % settings.table_user_name,\n                                  error_message=self.messages.username_taken)]\n                if not settings.username_case_sensitive:\n                    is_unique_username.insert(1, IS_LOWER())\n                db.define_table(\n                    settings.table_user_name,\n                    Field('first_name', length=128, default='',\n                          label=self.messages.label_first_name,\n                          requires=is_not_empty),\n                    Field('last_name', length=128, default='',\n                          label=self.messages.label_last_name,\n                          requires=is_not_empty),\n                    Field('email', length=512, default='',\n                          label=self.messages.label_email,\n                          requires=is_unique_email),\n                    Field('username', length=128, default='',\n                          label=self.messages.label_username,\n                          requires=is_unique_username),\n                    Field(passfield, 'password', length=512,\n                          readable=False, label=self.messages.label_password,\n                          requires=[is_crypted]),\n                    Field('registration_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_key),\n                    Field('reset_password_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_reset_password_key),\n                    Field('registration_id', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_id),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(settings.table_user_name,\n                                                   migrate),\n                        fake_migrate=fake_migrate,\n                        format='%(username)s'))\n            else:\n                db.define_table(\n                    settings.table_user_name,\n                    Field('first_name', length=128, default='',\n                          label=self.messages.label_first_name,\n                          requires=is_not_empty),\n                    Field('last_name', length=128, default='',\n                          label=self.messages.label_last_name,\n                          requires=is_not_empty),\n                    Field('email', length=512, default='',\n                          label=self.messages.label_email,\n                          requires=is_unique_email),\n                    Field(passfield, 'password', length=512,\n                          readable=False, label=self.messages.label_password,\n                          requires=[is_crypted]),\n                    Field('registration_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_key),\n                    Field('reset_password_key', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_reset_password_key),\n                    Field('registration_id', length=512,\n                          writable=False, readable=False, default='',\n                          label=self.messages.label_registration_id),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(settings.table_user_name,\n                                                   migrate),\n                        fake_migrate=fake_migrate,\n                        format='%(first_name)s %(last_name)s (%(id)s)'))\n        reference_table_user = 'reference %s' % settings.table_user_name\n        if not settings.table_group_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_group_name, []) + signature_list\n            db.define_table(\n                settings.table_group_name,\n                Field('role', length=512, default='',\n                      label=self.messages.label_role,\n                      requires=IS_NOT_IN_DB(db, '%s.role' % settings.table_group_name)),\n                Field('description', 'text',\n                      label=self.messages.label_description),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_group_name, migrate),\n                    fake_migrate=fake_migrate,\n                    format='%(role)s (%(id)s)'))\n        reference_table_group = 'reference %s' % settings.table_group_name\n        if not settings.table_membership_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_membership_name, []) + signature_list\n            db.define_table(\n                settings.table_membership_name,\n                Field('user_id', reference_table_user,\n                      label=self.messages.label_user_id),\n                Field('group_id', reference_table_group,\n                      label=self.messages.label_group_id),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_membership_name, migrate),\n                    fake_migrate=fake_migrate))\n        if not settings.table_permission_name in db.tables:\n            extra_fields = settings.extra_fields.get(\n                settings.table_permission_name, []) + signature_list\n            db.define_table(\n                settings.table_permission_name,\n                Field('group_id', reference_table_group,\n                      label=self.messages.label_group_id),\n                Field('name', default='default', length=512,\n                      label=self.messages.label_name,\n                      requires=is_not_empty),\n                Field('table_name', length=512,\n                      label=self.messages.label_table_name),\n                Field('record_id', 'integer', default=0,\n                      label=self.messages.label_record_id,\n                      requires=IS_INT_IN_RANGE(0, 10 ** 9)),\n                *extra_fields,\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_permission_name, migrate),\n                    fake_migrate=fake_migrate))\n        if not settings.table_event_name in db.tables:\n            db.define_table(\n                settings.table_event_name,\n                Field('time_stamp', 'datetime',\n                      default=current.request.now,\n                      label=self.messages.label_time_stamp),\n                Field('client_ip',\n                      default=current.request.client,\n                      label=self.messages.label_client_ip),\n                Field('user_id', reference_table_user, default=None,\n                      label=self.messages.label_user_id),\n                Field('origin', default='auth', length=512,\n                      label=self.messages.label_origin,\n                      requires=is_not_empty),\n                Field('description', 'text', default='',\n                      label=self.messages.label_description,\n                      requires=is_not_empty),\n                *settings.extra_fields.get(settings.table_event_name, []),\n                **dict(\n                    migrate=self.__get_migrate(\n                        settings.table_event_name, migrate),\n                    fake_migrate=fake_migrate))\n        now = current.request.now\n        if settings.cas_domains:\n            if not settings.table_cas_name in db.tables:\n                db.define_table(\n                    settings.table_cas_name,\n                    Field('user_id', reference_table_user, default=None,\n                          label=self.messages.label_user_id),\n                    Field('created_on', 'datetime', default=now),\n                    Field('service', requires=IS_URL()),\n                    Field('ticket'),\n                    Field('renew', 'boolean', default=False),\n                    *settings.extra_fields.get(settings.table_cas_name, []),\n                    **dict(\n                        migrate=self.__get_migrate(\n                            settings.table_cas_name, migrate),\n                        fake_migrate=fake_migrate))\n        if settings.enable_tokens:\n            extra_fields = settings.extra_fields.get(\n                settings.table_token_name, []) + signature_list\n            if not settings.table_token_name in db.tables:\n                db.define_table(\n                    settings.table_token_name,\n                    Field('user_id', reference_table_user, default=None,\n                          label=self.messages.label_user_id),\n                    Field('expires_on', 'datetime', default=datetime.datetime(2999,12,31)),\n                    Field('token',writable=False,default=web2py_uuid(),unique=True),\n                    *extra_fields,\n                    **dict(\n                        migrate=self.__get_migrate(\n                            settings.table_token_name, migrate),\n                        fake_migrate=fake_migrate))\n        if not db._lazy_tables:\n            settings.table_user = db[settings.table_user_name]\n            settings.table_group = db[settings.table_group_name]\n            settings.table_membership = db[settings.table_membership_name]\n            settings.table_permission = db[settings.table_permission_name]\n            settings.table_event = db[settings.table_event_name]\n            if settings.cas_domains:\n                settings.table_cas = db[settings.table_cas_name]\n\n        if settings.cas_provider:  # THIS IS NOT LAZY\n            settings.actions_disabled = \\\n                ['profile', 'register', 'change_password',\n                 'request_reset_password', 'retrieve_username']\n            from gluon.contrib.login_methods.cas_auth import CasAuth\n            maps = settings.cas_maps\n            if not maps:\n                table_user = self.table_user()\n                maps = dict((name, lambda v, n=name: v.get(n, None)) for name in\n                            table_user.fields if name != 'id'\n                            and table_user[name].readable)\n                maps['registration_id'] = \\\n                    lambda v, p=settings.cas_provider: '%s/%s' % (p, v['user'])\n            actions = [settings.cas_actions['login'],\n                       settings.cas_actions['servicevalidate'],\n                       settings.cas_actions['logout']]\n            settings.login_form = CasAuth(\n                casversion=2,\n                urlbase=settings.cas_provider,\n                actions=actions,\n                maps=maps)\n        return self\n\n    def log_event(self, description, vars=None, origin='auth'):\n        \"\"\"\n        Examples:\n            Use as::\n\n                auth.log_event(description='this happened', origin='auth')\n\n        \"\"\"\n        if not self.settings.logging_enabled or not description:\n            return\n        elif self.is_logged_in():\n            user_id = self.user.id\n        else:\n            user_id = None  # user unknown\n        vars = vars or {}\n        # log messages should not be translated\n        if type(description).__name__ == 'lazyT':\n            description = description.m\n        self.table_event().insert(\n            description=str(description % vars),\n            origin=origin, user_id=user_id)\n\n    def get_or_create_user(self, keys, update_fields=['email'],\n                           login=True, get=True):\n        \"\"\"\n        Used for alternate login methods:\n        If the user exists already then password is updated.\n        If the user doesn't yet exist, then they are created.\n        \"\"\"\n        table_user = self.table_user()\n        user = None\n        checks = []\n        # make a guess about who this user is\n        for fieldname in ['registration_id', 'username', 'email']:\n            if fieldname in table_user.fields() and \\\n                    keys.get(fieldname, None):\n                checks.append(fieldname)\n                value = keys[fieldname]\n                user = table_user(**{fieldname: value})\n                if user:\n                    break\n        if not checks:\n            return None\n        if not 'registration_id' in keys:\n            keys['registration_id'] = keys[checks[0]]\n        # if we think we found the user but registration_id does not match,\n        # make new user\n        if 'registration_id' in checks \\\n                and user \\\n                and user.registration_id \\\n                and ('registration_id' not in keys or user.registration_id != str(keys['registration_id'])):\n            user = None  # THINK MORE ABOUT THIS? DO WE TRUST OPENID PROVIDER?\n        if user:\n            if not get:\n                # added for register_bare to avoid overwriting users\n                return None\n            update_keys = dict(registration_id=keys['registration_id'])\n            for key in update_fields:\n                if key in keys:\n                    update_keys[key] = keys[key]\n            user.update_record(**update_keys)\n        elif checks:\n            if not 'first_name' in keys and 'first_name' in table_user.fields:\n                guess = keys.get('email', 'anonymous').split('@')[0]\n                keys['first_name'] = keys.get('username', guess)\n            user_id = table_user.insert(**table_user._filter_fields(keys))\n            user = table_user[user_id]\n            if self.settings.create_user_groups:\n                group_id = self.add_group(\n                    self.settings.create_user_groups % user)\n                self.add_membership(group_id, user_id)\n            if self.settings.everybody_group_id:\n                self.add_membership(self.settings.everybody_group_id, user_id)\n            if login:\n                self.user = user\n        return user\n\n    def basic(self, basic_auth_realm=False):\n        \"\"\"\n        Performs basic login.\n\n        Args:\n            basic_auth_realm: optional basic http authentication realm. Can take\n                str or unicode or function or callable or boolean.\n\n        reads current.request.env.http_authorization\n        and returns basic_allowed,basic_accepted,user.\n\n        if basic_auth_realm is defined is a callable it's return value\n        is used to set the basic authentication realm, if it's a string\n        its content is used instead.  Otherwise basic authentication realm\n        is set to the application name.\n        If basic_auth_realm is None or False (the default) the behavior\n        is to skip sending any challenge.\n\n        \"\"\"\n        if not self.settings.allow_basic_login:\n            return (False, False, False)\n        basic = current.request.env.http_authorization\n        if basic_auth_realm:\n            if callable(basic_auth_realm):\n                basic_auth_realm = basic_auth_realm()\n            elif isinstance(basic_auth_realm, (unicode, str)):\n                basic_realm = unicode(basic_auth_realm)\n            elif basic_auth_realm is True:\n                basic_realm = u'' + current.request.application\n            http_401 = HTTP(401, u'Not Authorized', **{'WWW-Authenticate': u'Basic realm=\"' + basic_realm + '\"'})\n        if not basic or not basic[:6].lower() == 'basic ':\n            if basic_auth_realm:\n                raise http_401\n            return (True, False, False)\n        (username, sep, password) = base64.b64decode(basic[6:]).partition(':')\n        is_valid_user = sep and self.login_bare(username, password)\n        if not is_valid_user and basic_auth_realm:\n            raise http_401\n        return (True, True, is_valid_user)\n\n    def login_user(self, user):\n        \"\"\"\n        Logins the `user = db.auth_user(id)`\n        \"\"\"\n        from gluon.settings import global_settings\n        if global_settings.web2py_runtime_gae:\n            user = Row(self.table_user()._filter_fields(user, id=True))\n            delattr(user, 'password')\n        else:\n            user = Row(user)\n            for key, value in user.items():\n                if callable(value) or key == 'password':\n                    delattr(user, key)\n        if self.settings.renew_session_onlogin:\n            current.session.renew(clear_session=not self.settings.keep_session_onlogin)\n        current.session.auth = Storage(user=user,\n                                       last_visit=current.request.now,\n                                       expiration=self.settings.expiration,\n                                       hmac_key=web2py_uuid())\n        self.user = user\n        self.update_groups()\n\n    def _get_login_settings(self):\n        table_user = self.table_user()\n        userfield = self.settings.login_userfield or 'username' \\\n            if 'username' in table_user.fields else 'email'\n        passfield = self.settings.password_field\n        return Storage({\"table_user\": table_user,\n                        \"userfield\": userfield,\n                        \"passfield\": passfield})\n\n    def login_bare(self, username, password):\n        \"\"\"\n        Logins user as specified by username (or email) and password\n        \"\"\"\n        settings = self._get_login_settings()\n        user = settings.table_user(**{settings.userfield: \\\n                       username})\n        if user and user.get(settings.passfield, False):\n            password = settings.table_user[\n                settings.passfield].validate(password)[0]\n            if ((user.registration_key is None or\n                 not user.registration_key.strip()) and\n                password == user[settings.passfield]):\n                self.login_user(user)\n                return user\n        else:\n            # user not in database try other login methods\n            for login_method in self.settings.login_methods:\n                if login_method != self and login_method(username, password):\n                    self.user = user\n                    return user\n        return False\n\n    def register_bare(self, **fields):\n        \"\"\"\n        Registers a user as specified by username (or email)\n        and a raw password.\n        \"\"\"\n        settings = self._get_login_settings()\n        # users can register_bare even if no password is provided, \n        # in this case they will have to reset their password to login\n        if fields.get(settings.passfield):\n            fields[settings.passfield] = \\\n                settings.table_user[settings.passfield].validate(fields[settings.passfield])[0]\n        if not fields.get(settings.userfield):\n            raise ValueError(\"register_bare: \" +\n                             \"userfield not provided or invalid\")\n        user = self.get_or_create_user(fields, login=False, get=False, \n                                       update_fields=self.settings.update_fields)\n        if not user:\n            # get or create did not create a user (it ignores duplicate records)\n            return False\n        return user\n\n    def cas_login(self,\n                  next=DEFAULT,\n                  onvalidation=DEFAULT,\n                  onaccept=DEFAULT,\n                  log=DEFAULT,\n                  version=2,\n                  ):\n        request = current.request\n        response = current.response\n        session = current.session\n        db, table = self.db, self.table_cas()\n        session._cas_service = request.vars.service or session._cas_service\n        if not request.env.http_host in self.settings.cas_domains or \\\n                not session._cas_service:\n            raise HTTP(403, 'not authorized')\n\n        def allow_access(interactivelogin=False):\n            row = table(service=session._cas_service, user_id=self.user.id)\n            if row:\n                ticket = row.ticket\n            else:\n                ticket = 'ST-' + web2py_uuid()\n                table.insert(service=session._cas_service,\n                             user_id=self.user.id,\n                             ticket=ticket,\n                             created_on=request.now,\n                             renew=interactivelogin)\n            service = session._cas_service\n            query_sep = '&' if '?' in service else '?'\n            del session._cas_service\n            if 'warn' in request.vars and not interactivelogin:\n                response.headers[\n                    'refresh'] = \"5;URL=%s\" % service + query_sep + \"ticket=\" + ticket\n                return A(\"Continue to %s\" % service,\n                         _href=service + query_sep + \"ticket=\" + ticket)\n            else:\n                redirect(service + query_sep + \"ticket=\" + ticket)\n        if self.is_logged_in() and not 'renew' in request.vars:\n            return allow_access()\n        elif not self.is_logged_in() and 'gateway' in request.vars:\n            redirect(service)\n\n        def cas_onaccept(form, onaccept=onaccept):\n            if not onaccept is DEFAULT:\n                onaccept(form)\n            return allow_access(interactivelogin=True)\n        return self.login(next, onvalidation, cas_onaccept, log)\n\n    def cas_validate(self, version=2, proxy=False):\n        request = current.request\n        db, table = self.db, self.table_cas()\n        current.response.headers['Content-Type'] = 'text'\n        ticket = request.vars.ticket\n        renew = 'renew' in request.vars\n        row = table(ticket=ticket)\n        success = False\n        if row:\n            userfield = self.settings.login_userfield or 'username' \\\n                if 'username' in table.fields else 'email'\n            # If ticket is a service Ticket and RENEW flag respected\n            if ticket[0:3] == 'ST-' and \\\n                    not ((row.renew and renew) ^ renew):\n                user = self.table_user()(row.user_id)\n                row.delete_record()\n                success = True\n\n        def build_response(body):\n            return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' +\\\n                TAG['cas:serviceResponse'](\n                    body, **{'_xmlns:cas': 'http://www.yale.edu/tp/cas'}).xml()\n        if success:\n            if version == 1:\n                message = 'yes\\n%s' % user[userfield]\n            else:  # assume version 2\n                username = user.get('username', user[userfield])\n                message = build_response(\n                    TAG['cas:authenticationSuccess'](\n                        TAG['cas:user'](username),\n                        *[TAG['cas:' + field.name](user[field.name])\n                          for field in self.table_user()\n                          if field.readable]))\n        else:\n            if version == 1:\n                message = 'no\\n'\n            elif row:\n                message = build_response(TAG['cas:authenticationFailure']())\n            else:\n                message = build_response(\n                    TAG['cas:authenticationFailure'](\n                        'Ticket %s not recognized' % ticket,\n                        _code='INVALID TICKET'))\n        raise HTTP(200, message)\n\n    def _reset_two_factor_auth(self, session):\n        \"\"\"When two-step authentication is enabled, this function is used to\n        clear the session after successfully completing second challenge\n        or when the maximum number of tries allowed has expired.\n        \"\"\"\n        session.auth_two_factor_user = None\n        session.auth_two_factor = None\n        session.auth_two_factor_enabled = False\n        # Allow up to 4 attempts (the 1st one plus 3 more)\n        session.auth_two_factor_tries_left = 3\n\n    def login(self,\n              next=DEFAULT,\n              onvalidation=DEFAULT,\n              onaccept=DEFAULT,\n              log=DEFAULT,\n              ):\n        \"\"\"\n        Returns a login form\n        \"\"\"\n\n        table_user = self.table_user()\n        settings = self.settings\n        if 'username' in table_user.fields or \\\n                not settings.login_email_validate:\n            tmpvalidator = IS_NOT_EMPTY(error_message=self.messages.is_empty)\n            if not settings.username_case_sensitive:\n                tmpvalidator = [IS_LOWER(), tmpvalidator]\n        else:\n            tmpvalidator = IS_EMAIL(error_message=self.messages.invalid_email)\n            if not settings.email_case_sensitive:\n                tmpvalidator = [IS_LOWER(), tmpvalidator]\n\n        request = current.request\n        response = current.response\n        session = current.session\n\n        passfield = settings.password_field\n        try:\n            table_user[passfield].requires[-1].min_length = 0\n        except:\n            pass\n\n        ### use session for federated login\n        snext = self.get_vars_next()\n\n        if snext:\n            session._auth_next = snext\n        elif session._auth_next:\n            snext = session._auth_next\n        ### pass\n\n        if next is DEFAULT:\n            # important for security\n            next = settings.login_next\n            if callable(next):\n                next = next()\n            user_next = snext\n            if user_next:\n                external = user_next.split('://')\n                if external[0].lower() in ['http', 'https', 'ftp']:\n                    host_next = user_next.split('//', 1)[-1].split('/')[0]\n                    if host_next in settings.cas_domains:\n                        next = user_next\n                else:\n                    next = user_next\n        if onvalidation is DEFAULT:\n            onvalidation = settings.login_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = settings.login_onaccept\n        if log is DEFAULT:\n            log = self.messages['login_log']\n\n        onfail = settings.login_onfail\n\n        user = None  # default\n\n\n        #Setup the default field used for the form\n        multi_login = False\n        if self.settings.login_userfield:\n            username = self.settings.login_userfield\n        else:\n            if 'username' in table_user.fields:\n                username = 'username'\n            else:\n                username = 'email'\n            if self.settings.multi_login:\n                multi_login = True\n        old_requires = table_user[username].requires\n        table_user[username].requires = tmpvalidator\n\n        # If two-factor authentication is enabled, and the maximum\n        # number of tries allowed is used up, reset the session to\n        # pre-login state with two-factor auth\n        if session.auth_two_factor_enabled and session.auth_two_factor_tries_left < 1:\n            # Exceeded maximum allowed tries for this code. Require user to enter\n            # username and password again.\n            user = None\n            accepted_form = False\n            self._reset_two_factor_auth(session)\n            # Redirect to the default 'next' page without logging\n            # in. If that page requires login, user will be redirected\n            # back to the main login form\n            redirect(next, client_side=settings.client_side)\n\n        # Before showing the default login form, check whether\n        # we are already on the second step of two-step authentication.\n        # If we are, then skip this login form and use the form for the\n        # second challenge instead.\n        # Note to devs: The code inside the if-block is unchanged from the\n        # previous version of this file, other than for indentation inside\n        # to put it inside the if-block\n        if session.auth_two_factor_user is None:\n\n            if settings.remember_me_form:\n                extra_fields = [\n                    Field('remember_me', 'boolean', default=False,\n                          label = self.messages.label_remember_me)]\n            else:\n                extra_fields = []\n\n            # do we use our own login form, or from a central source?\n            if settings.login_form == self:\n                form = SQLFORM(\n                    table_user,\n                    fields=[username, passfield],\n                    hidden=dict(_next=next),\n                    showid=settings.showid,\n                    submit_button=self.messages.login_button,\n                    delete_label=self.messages.delete_label,\n                    formstyle=settings.formstyle,\n                    separator=settings.label_separator,\n                    extra_fields = extra_fields,\n                )\n\n\n                captcha = settings.login_captcha or \\\n                    (settings.login_captcha != False and settings.captcha)\n                if captcha:\n                    addrow(form, captcha.label, captcha, captcha.comment,\n                           settings.formstyle, 'captcha__row')\n                accepted_form = False\n\n                if form.accepts(request, session if self.csrf_prevention else None,\n                                formname='login', dbio=False,\n                                onvalidation=onvalidation,\n                                hideerror=settings.hideerror):\n\n                    accepted_form = True\n                    # check for username in db\n                    entered_username = form.vars[username]\n                    if multi_login and '@' in entered_username:\n                        # if '@' in username check for email, not username\n                        user = table_user(email = entered_username)\n                    else:\n                        user = table_user(**{username: entered_username})\n                    if user:\n                        # user in db, check if registration pending or disabled\n                        temp_user = user\n                        if temp_user.registration_key == 'pending':\n                            response.flash = self.messages.registration_pending\n                            return form\n                        elif temp_user.registration_key in ('disabled', 'blocked'):\n                            response.flash = self.messages.login_disabled\n                            return form\n                        elif (not temp_user.registration_key is None\n                              and temp_user.registration_key.strip()):\n                            response.flash = \\\n                                self.messages.registration_verifying\n                            return form\n                        # try alternate logins 1st as these have the\n                        # current version of the password\n                        user = None\n                        for login_method in settings.login_methods:\n                            if login_method != self and \\\n                                    login_method(request.vars[username],\n                                                 request.vars[passfield]):\n                                if not self in settings.login_methods:\n                                    # do not store password in db\n                                    form.vars[passfield] = None\n                                user = self.get_or_create_user(\n                                    form.vars, settings.update_fields)\n                                break\n                        if not user:\n                            # alternates have failed, maybe because service inaccessible\n                            if settings.login_methods[0] == self:\n                                # try logging in locally using cached credentials\n                                if form.vars.get(passfield, '') == temp_user[passfield]:\n                                    # success\n                                    user = temp_user\n                    else:\n                        # user not in db\n                        if not settings.alternate_requires_registration:\n                            # we're allowed to auto-register users from external systems\n                            for login_method in settings.login_methods:\n                                if login_method != self and \\\n                                        login_method(request.vars[username],\n                                                     request.vars[passfield]):\n                                    if not self in settings.login_methods:\n                                        # do not store password in db\n                                        form.vars[passfield] = None\n                                    user = self.get_or_create_user(\n                                        form.vars, settings.update_fields)\n                                    break\n                    if not user:\n                        self.log_event(self.messages['login_failed_log'],\n                                       request.post_vars)\n                        # invalid login\n                        session.flash = self.messages.invalid_login\n                        callback(onfail, None)\n                        redirect(\n                            self.url(args=request.args, vars=request.get_vars),\n                            client_side=settings.client_side)\n\n            else: # use a central authentication server\n                cas = settings.login_form\n                cas_user = cas.get_user()\n\n                if cas_user:\n                    cas_user[passfield] = None\n                    user = self.get_or_create_user(\n                        table_user._filter_fields(cas_user),\n                        settings.update_fields)\n                elif hasattr(cas, 'login_form'):\n                    return cas.login_form()\n                else:\n                    # we need to pass through login again before going on\n                    next = self.url(settings.function, args='login')\n                    redirect(cas.login_url(next),\n                             client_side=settings.client_side)\n\n        # Extra login logic for two-factor authentication\n        #################################################\n        # If the 'user' variable has a value, this means that the first\n        # authentication step was successful (i.e. user provided correct\n        # username and password at the first challenge).\n        # Check if this user is signed up for two-factor authentication\n        # Default rule is that the user must be part of a group that is called\n        # auth.settings.two_factor_authentication_group\n        if user and self.settings.two_factor_authentication_group:\n            role = self.settings.two_factor_authentication_group\n            session.auth_two_factor_enabled = self.has_membership(user_id=user.id, role=role)\n        # challenge\n        if session.auth_two_factor_enabled:\n            form = SQLFORM.factory(\n                Field('authentication_code',\n                      required=True,\n                      comment='This code was emailed to you and is required for login.'),\n                hidden=dict(_next=next),\n                formstyle=settings.formstyle,\n                separator=settings.label_separator\n            )\n            # accepted_form is used by some default web2py code later in the\n            # function that handles running specified functions before redirect\n            # Set it to False until the challenge form is accepted.\n            accepted_form = False\n            # Handle the case when a user has submitted the login/password\n            # form successfully, and the password has been validated, but\n            # the two-factor form has not been displayed or validated yet.\n            if session.auth_two_factor_user is None and user is not None:\n                session.auth_two_factor_user = user # store the validated user and associate with this session\n                session.auth_two_factor = random.randint(100000, 999999)\n                session.auth_two_factor_tries_left = 3 # Allow user to try up to 4 times\n                # TODO: Add some error checking to handle cases where email cannot be sent\n                self.settings.mailer.send(\n                    to=user.email,\n                    subject=\"Two-step Login Authentication Code\",\n                    message=\"Your temporary login code is {0}\".format(session.auth_two_factor))\n            if form.accepts(request, session if self.csrf_prevention else None,\n                            formname='login', dbio=False,\n                            onvalidation=onvalidation,\n                            hideerror=settings.hideerror):\n                accepted_form = True\n                if form.vars['authentication_code'] == str(session.auth_two_factor):\n                    # Handle the case when the two-factor form has been successfully validated\n                    # and the user was previously stored (the current user should be None because\n                    # in this case, the previous username/password login form should not be displayed.\n                    # This will allow the code after the 2-factor authentication block to proceed as\n                    # normal.\n                    if user is None or user == session.auth_two_factor_user:\n                        user = session.auth_two_factor_user\n                    # For security, because the username stored in the\n                    # session somehow does not match the just validated\n                    # user. Should not be possible without session stealing\n                    # which is hard with SSL.\n                    elif user != session.auth_two_factor_user:\n                        user = None\n                    # Either way, the user and code associated with this session should\n                    # be removed. This handles cases where the session login may have\n                    # expired but browser window is open, so the old session key and\n                    # session usernamem will still exist\n                    self._reset_two_factor_auth(session)\n                else:\n                    # TODO: Limit the number of retries allowed.\n                    response.flash = 'Incorrect code. {0} more attempt(s) remaining.'.format(session.auth_two_factor_tries_left)\n                    session.auth_two_factor_tries_left -= 1\n                    return form\n            else:\n                return form\n        # End login logic for two-factor authentication\n\n        # process authenticated users\n        if user:\n            user = Row(table_user._filter_fields(user, id=True))\n            # process authenticated users\n            # user wants to be logged in for longer\n            self.login_user(user)\n            session.auth.expiration = \\\n                request.post_vars.remember_me and \\\n                settings.long_expiration or \\\n                settings.expiration\n            session.auth.remember_me = 'remember_me' in request.post_vars\n            self.log_event(log, user)\n            session.flash = self.messages.logged_in\n\n        # how to continue\n        if settings.login_form == self:\n            if accepted_form:\n                callback(onaccept, form)\n                if next == session._auth_next:\n                    session._auth_next = None\n                next = replace_id(next, form)\n                redirect(next, client_side=settings.client_side)\n\n            table_user[username].requires = old_requires\n            return form\n        elif user:\n            callback(onaccept, None)\n\n        if next == session._auth_next:\n            del session._auth_next\n        redirect(next, client_side=settings.client_side)\n\n    def logout(self, next=DEFAULT, onlogout=DEFAULT, log=DEFAULT):\n        \"\"\"\n        Logouts and redirects to login\n        \"\"\"\n\n        # Clear out 2-step authentication information if user logs\n        # out. This information is also cleared on successful login.\n        self._reset_two_factor_auth(current.session)\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.logout_next\n        if onlogout is DEFAULT:\n            onlogout = self.settings.logout_onlogout\n        if onlogout:\n            onlogout(self.user)\n        if log is DEFAULT:\n            log = self.messages['logout_log']\n        if self.user:\n            self.log_event(log, self.user)\n        if self.settings.login_form != self:\n            cas = self.settings.login_form\n            cas_user = cas.get_user()\n            if cas_user:\n                next = cas.logout_url(next)\n\n        current.session.auth = None\n        if self.settings.renew_session_onlogout:\n            current.session.renew(clear_session=not self.settings.keep_session_onlogout)\n        current.session.flash = self.messages.logged_out\n        if not next is None:\n            redirect(next)\n\n    def register(self,\n                 next=DEFAULT,\n                 onvalidation=DEFAULT,\n                 onaccept=DEFAULT,\n                 log=DEFAULT,\n                 ):\n        \"\"\"\n        Returns a registration form\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        if self.is_logged_in():\n            redirect(self.settings.logged_url,\n                     client_side=self.settings.client_side)\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.register_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.register_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.register_onaccept\n        if log is DEFAULT:\n            log = self.messages['register_log']\n\n        table_user = self.table_user()\n        if self.settings.login_userfield:\n            username = self.settings.login_userfield\n        elif 'username' in table_user.fields:\n            username = 'username'\n        else:\n            username = 'email'\n\n        # Ensure the username field is unique.\n        unique_validator = IS_NOT_IN_DB(self.db, table_user[username])\n        if not table_user[username].requires:\n            table_user[username].requires = unique_validator\n        elif isinstance(table_user[username].requires, (list, tuple)):\n            if not any([isinstance(validator, IS_NOT_IN_DB) for validator in\n                        table_user[username].requires]):\n                if isinstance(table_user[username].requires, list):\n                    table_user[username].requires.append(unique_validator)\n                else:\n                    table_user[username].requires += (unique_validator, )\n        elif not isinstance(table_user[username].requires, IS_NOT_IN_DB):\n            table_user[username].requires = [table_user[username].requires,\n                                             unique_validator]\n\n        passfield = self.settings.password_field\n        formstyle = self.settings.formstyle\n        if self.settings.register_verify_password:\n            extra_fields = [\n                Field(\"password_two\", \"password\", requires=IS_EQUAL_TO(\n                        request.post_vars.get(passfield, None),\n                        error_message=self.messages.mismatched_password),\n                        label=current.T(\"Confirm Password\"))]\n        else:\n            extra_fields = []\n        form = SQLFORM(table_user,\n                       fields=self.settings.register_fields,\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.register_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=formstyle,\n                       separator=self.settings.label_separator,\n                       extra_fields = extra_fields\n                       )\n\n        captcha = self.settings.register_captcha or self.settings.captcha\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n\n        #Add a message if specified\n        if self.settings.pre_registration_div:\n            addrow(form, '',\n                   DIV(_id=\"pre-reg\", *self.settings.pre_registration_div),\n                   '', formstyle, '')\n\n        table_user.registration_key.default = key = web2py_uuid()\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='register',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            description = self.messages.group_description % form.vars\n            if self.settings.create_user_groups:\n                group_id = self.add_group(\n                    self.settings.create_user_groups % form.vars, description)\n                self.add_membership(group_id, form.vars.id)\n            if self.settings.everybody_group_id:\n                self.add_membership(\n                    self.settings.everybody_group_id, form.vars.id)\n            if self.settings.registration_requires_verification:\n                link = self.url(\n                    self.settings.function, args=('verify_email', key), scheme=True)\n                d = dict(form.vars)\n                d.update(dict(key=key, link=link, username=form.vars[username]))\n                if not (self.settings.mailer and self.settings.mailer.send(\n                        to=form.vars.email,\n                        subject=self.messages.verify_email_subject,\n                        message=self.messages.verify_email % d)):\n                    self.db.rollback()\n                    response.flash = self.messages.unable_send_email\n                    return form\n                session.flash = self.messages.email_sent\n            if self.settings.registration_requires_approval and \\\n               not self.settings.registration_requires_verification:\n                table_user[form.vars.id] = dict(registration_key='pending')\n                session.flash = self.messages.registration_pending\n            elif (not self.settings.registration_requires_verification or\n                      self.settings.login_after_registration):\n                if not self.settings.registration_requires_verification:\n                    table_user[form.vars.id] = dict(registration_key='')\n                session.flash = self.messages.registration_successful\n                user = table_user(**{username: form.vars[username]})\n                self.login_user(user)\n                session.flash = self.messages.logged_in\n            self.log_event(log, form.vars)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n\n        return form\n\n    def is_logged_in(self):\n        \"\"\"\n        Checks if the user is logged in and returns True/False.\n        If so user is in auth.user as well as in session.auth.user\n        \"\"\"\n\n        if self.user:\n            return True\n        return False\n\n    def verify_email(self,\n                     next=DEFAULT,\n                     onaccept=DEFAULT,\n                     log=DEFAULT,\n                     ):\n        \"\"\"\n        Action used to verify the registration email\n        \"\"\"\n\n        key = getarg(-1)\n        table_user = self.table_user()\n        user = table_user(registration_key=key)\n        if not user:\n            redirect(self.settings.login_url)\n        if self.settings.registration_requires_approval:\n            user.update_record(registration_key='pending')\n            current.session.flash = self.messages.registration_pending\n        else:\n            user.update_record(registration_key='')\n            current.session.flash = self.messages.email_verified\n        # make sure session has same user.registrato_key as db record\n        if current.session.auth and current.session.auth.user:\n            current.session.auth.user.registration_key = user.registration_key\n        if log is DEFAULT:\n            log = self.messages['verify_email_log']\n        if next is DEFAULT:\n            next = self.settings.verify_email_next\n        if onaccept is DEFAULT:\n            onaccept = self.settings.verify_email_onaccept\n        self.log_event(log, user)\n        callback(onaccept, user)\n        redirect(next)\n\n    def retrieve_username(self,\n                          next=DEFAULT,\n                          onvalidation=DEFAULT,\n                          onaccept=DEFAULT,\n                          log=DEFAULT,\n                          ):\n        \"\"\"\n        Returns a form to retrieve the user username\n        (only if there is a username field)\n        \"\"\"\n\n        table_user = self.table_user()\n        if not 'username' in table_user.fields:\n            raise HTTP(404)\n        request = current.request\n        response = current.response\n        session = current.session\n        captcha = self.settings.retrieve_username_captcha or \\\n                (self.settings.retrieve_username_captcha != False and self.settings.captcha)\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.retrieve_username_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.retrieve_username_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.retrieve_username_onaccept\n        if log is DEFAULT:\n            log = self.messages['retrieve_username_log']\n        old_requires = table_user.email.requires\n        table_user.email.requires = [IS_IN_DB(self.db, table_user.email,\n            error_message=self.messages.invalid_email)]\n        form = SQLFORM(table_user,\n                       fields=['email'],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.submit_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='retrieve_username', dbio=False,\n                        onvalidation=onvalidation, hideerror=self.settings.hideerror):\n            users = table_user._db(table_user.email==form.vars.email).select()\n            if not users:\n                current.session.flash = \\\n                    self.messages.invalid_email\n                redirect(self.url(args=request.args))\n            username = ', '.join(u.username for u in users)\n            self.settings.mailer.send(to=form.vars.email,\n                                      subject=self.messages.retrieve_username_subject,\n                                      message=self.messages.retrieve_username % dict(username=username))\n            session.flash = self.messages.email_sent\n            for user in users:\n                self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next)\n        table_user.email.requires = old_requires\n        return form\n\n    def random_password(self):\n        import string\n        import random\n        password = ''\n        specials = r'!#$*'\n        for i in range(0, 3):\n            password += random.choice(string.lowercase)\n            password += random.choice(string.uppercase)\n            password += random.choice(string.digits)\n            password += random.choice(specials)\n        return ''.join(random.sample(password, len(password)))\n\n    def reset_password_deprecated(self,\n                                  next=DEFAULT,\n                                  onvalidation=DEFAULT,\n                                  onaccept=DEFAULT,\n                                  log=DEFAULT,\n                                  ):\n        \"\"\"\n        Returns a form to reset the user password (deprecated)\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.retrieve_password_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.retrieve_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.retrieve_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['retrieve_password_log']\n        old_requires = table_user.email.requires\n        table_user.email.requires = [IS_IN_DB(self.db, table_user.email,\n            error_message=self.messages.invalid_email)]\n        form = SQLFORM(table_user,\n                       fields=['email'],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.submit_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='retrieve_password', dbio=False,\n                        onvalidation=onvalidation, hideerror=self.settings.hideerror):\n            user = table_user(email=form.vars.email)\n            if not user:\n                current.session.flash = \\\n                    self.messages.invalid_email\n                redirect(self.url(args=request.args))\n            elif user.registration_key in ('pending', 'disabled', 'blocked'):\n                current.session.flash = \\\n                    self.messages.registration_pending\n                redirect(self.url(args=request.args))\n            password = self.random_password()\n            passfield = self.settings.password_field\n            d = {\n                passfield: str(table_user[passfield].validate(password)[0]),\n                'registration_key': ''\n                }\n            user.update_record(**d)\n            if self.settings.mailer and \\\n               self.settings.mailer.send(to=form.vars.email,\n                                         subject=self.messages.retrieve_password_subject,\n                                         message=self.messages.retrieve_password % dict(password=password)):\n                session.flash = self.messages.email_sent\n            else:\n                session.flash = self.messages.unable_to_send_email\n            self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next)\n        table_user.email.requires = old_requires\n        return form\n\n    def confirm_registration(\n        self,\n        next=DEFAULT,\n        onvalidation=DEFAULT,\n        onaccept=DEFAULT,\n        log=DEFAULT,\n        ):\n        \"\"\"\n        Returns a form to confirm user registration\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        # response = current.response\n        session = current.session\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.reset_password_next\n\n        if self.settings.prevent_password_reset_attacks:\n            key = request.vars.key\n            if not key and len(request.args)>1:\n                key = request.args[-1]\n            if key:\n                session._reset_password_key = key\n                redirect(self.url(args='confirm_registration'))\n            else:\n                key = session._reset_password_key\n        else:\n            key = request.vars.key or getarg(-1)\n        try:\n            t0 = int(key.split('-')[0])\n            if time.time() - t0 > 60 * 60 * 24:\n                raise Exception\n            user = table_user(reset_password_key=key)\n            if not user:\n                raise Exception\n        except Exception as e:\n            session.flash = self.messages.invalid_reset_password\n            redirect(self.url('login', vars=dict(test=e)))\n            redirect(next, client_side=self.settings.client_side)\n        passfield = self.settings.password_field\n        form = SQLFORM.factory(\n            Field('first_name',\n                  label='First Name',\n                  required=True),\n            Field('last_name',\n                  label='Last Name',\n                  required=True),\n            Field('new_password', 'password',\n                  label=self.messages.new_password,\n                  requires=self.table_user()[passfield].requires),\n            Field('new_password2', 'password',\n                  label=self.messages.verify_password,\n                  requires=[IS_EXPR(\n                        'value==%s' % repr(request.vars.new_password),\n                        self.messages.mismatched_password)]),\n            submit_button='Confirm Registration',\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.process().accepted:\n            user.update_record(\n                **{passfield: str(form.vars.new_password),\n                   'first_name': str(form.vars.first_name),\n                   'last_name': str(form.vars.last_name),\n                   'registration_key': '',\n                   'reset_password_key': ''})\n            session.flash = self.messages.password_changed\n            if self.settings.login_after_password_change:\n                self.login_user(user)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def email_registration(self, subject, body, user):\n        \"\"\"\n        Sends and email invitation to a user informing they have been registered with the application\n        \"\"\"\n        reset_password_key = str(int(time.time())) + '-' + web2py_uuid()\n        link = self.url(self.settings.function,\n                        args=('confirm_registration',), vars={'key': reset_password_key},\n                        scheme=True)\n        d = dict(user)\n        d.update(dict(key=reset_password_key, link=link, site=current.request.env.http_host))\n        if self.settings.mailer and self.settings.mailer.send(\n            to=user.email,\n            subject=subject % d,\n            message=body % d):\n            user.update_record(reset_password_key=reset_password_key)\n            return True\n        return False\n\n    def bulk_register(self, max_emails=100):\n        \"\"\"\n        Creates a form for ther user to send invites to other users to join\n        \"\"\"\n        if not self.user:\n            redirect(self.settings.login_url)\n        if not self.setting.bulk_register_enabled:\n            return HTTP(404)\n\n        form = SQLFORM.factory(\n            Field('subject','string',default=self.messages.bulk_invite_subject,requires=IS_NOT_EMPTY()),\n            Field('emails','text',requires=IS_NOT_EMPTY()),\n            Field('message','text',default=self.messages.bulk_invite_body,requires=IS_NOT_EMPTY()),\n            formstyle=self.settings.formstyle)\n\n        if form.process().accepted:\n            emails = re.compile('[^\\s\\'\"@<>,;:]+\\@[^\\s\\'\"@<>,;:]+').findall(form.vars.emails)\n            # send the invitations            \n            emails_sent = []\n            emails_fail = []\n            emails_exist = []\n            for email in emails[:max_emails]:\n                if self.table_user()(email=email):\n                    emails_exist.append(email)\n                else:\n                    user = self.register_bare(email=email)\n                    if self.email_registration(form.vars.subject, form.vars.message, user):\n                        emails_sent.append(email)\n                    else:\n                        emails_fail.append(email)\n            emails_fail += emails[max_emails:]\n            form = DIV(H4('Emails sent'),UL(*[A(x,_href='mailto:'+x) for x in emails_sent]),\n                       H4('Emails failed'),UL(*[A(x,_href='mailto:'+x) for x in emails_fail]),\n                       H4('Emails existing'),UL(*[A(x,_href='mailto:'+x) for x in emails_exist]))\n        return form\n\n    def manage_tokens(self):\n        if not self.user:\n            redirect(self.settings.login_url)        \n        table_token =self.table_token()\n        table_token.user_id.writable = False\n        table_token.user_id.default = self.user.id\n        table_token.token.writable = False\n        if current.request.args(1) == 'new':\n            table_token.token.readable = False\n        form = SQLFORM.grid(table_token, args=['manage_tokens'])\n        return form\n\n    def reset_password(self,\n                       next=DEFAULT,\n                       onvalidation=DEFAULT,\n                       onaccept=DEFAULT,\n                       log=DEFAULT,\n                       ):\n        \"\"\"\n        Returns a form to reset the user password\n        \"\"\"\n\n        table_user = self.table_user()\n        request = current.request\n        # response = current.response\n        session = current.session\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.reset_password_next\n\n        if self.settings.prevent_password_reset_attacks:\n            key = request.vars.key\n            if key:\n                session._reset_password_key = key\n                redirect(self.url(args='reset_password'))\n            else:\n                key = session._reset_password_key\n        else:\n            key = request.vars.key\n        try:\n            t0 = int(key.split('-')[0])\n            if time.time() - t0 > 60 * 60 * 24:\n                raise Exception\n            user = table_user(reset_password_key=key)\n            if not user:\n                raise Exception\n        except Exception:\n            session.flash = self.messages.invalid_reset_password\n            redirect(next, client_side=self.settings.client_side)\n\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.reset_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.reset_password_onaccept\n\n        passfield = self.settings.password_field\n        form = SQLFORM.factory(\n            Field('new_password', 'password',\n                  label=self.messages.new_password,\n                  requires=self.table_user()[passfield].requires),\n            Field('new_password2', 'password',\n                  label=self.messages.verify_password,\n                  requires=[IS_EXPR(\n                      'value==%s' % repr(request.vars.new_password),\n                                    self.messages.mismatched_password)]),\n            submit_button=self.messages.password_reset_button,\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.accepts(request, session, onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            user.update_record(\n                **{passfield: str(form.vars.new_password),\n                   'registration_key': '',\n                   'reset_password_key': ''})\n            session.flash = self.messages.password_changed\n            if self.settings.login_after_password_change:\n                self.login_user(user)\n            callback(onaccept, form)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def request_reset_password(self,\n                               next=DEFAULT,\n                               onvalidation=DEFAULT,\n                               onaccept=DEFAULT,\n                               log=DEFAULT,\n                               ):\n        \"\"\"\n        Returns a form to reset the user password\n        \"\"\"\n        table_user = self.table_user()\n        request = current.request\n        response = current.response\n        session = current.session\n        captcha = self.settings.retrieve_password_captcha or \\\n                (self.settings.retrieve_password_captcha != False and self.settings.captcha)\n\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.request_reset_password_next\n        if not self.settings.mailer:\n            response.flash = self.messages.function_disabled\n            return ''\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.request_reset_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.request_reset_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['reset_password_log']\n        userfield = self.settings.login_userfield or 'username' \\\n            if 'username' in table_user.fields else 'email'\n        if userfield == 'email':\n            table_user.email.requires = [\n                IS_EMAIL(error_message=self.messages.invalid_email),\n                IS_IN_DB(self.db, table_user.email,\n                         error_message=self.messages.invalid_email)]\n            if not self.settings.email_case_sensitive:\n                table_user.email.requires.insert(0, IS_LOWER())\n        else:\n            table_user.username.requires = [\n                IS_IN_DB(self.db, table_user.username,\n                         error_message=self.messages.invalid_username)]\n            if not self.settings.username_case_sensitive:\n                table_user.username.requires.insert(0, IS_LOWER())\n\n        form = SQLFORM(table_user,\n                       fields=[userfield],\n                       hidden=dict(_next=next),\n                       showid=self.settings.showid,\n                       submit_button=self.messages.password_reset_button,\n                       delete_label=self.messages.delete_label,\n                       formstyle=self.settings.formstyle,\n                       separator=self.settings.label_separator\n                       )\n        if captcha:\n            addrow(form, captcha.label, captcha,\n                   captcha.comment, self.settings.formstyle, 'captcha__row')\n        if form.accepts(request, session if self.csrf_prevention else None,\n                        formname='reset_password', dbio=False,\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            user = table_user(**{userfield:form.vars.get(userfield)})\n            if not user:\n                session.flash = self.messages['invalid_%s' % userfield]\n                redirect(self.url(args=request.args),\n                         client_side=self.settings.client_side)\n            elif user.registration_key in ('pending', 'disabled', 'blocked'):\n                session.flash = self.messages.registration_pending\n                redirect(self.url(args=request.args),\n                         client_side=self.settings.client_side)\n            if self.email_reset_password(user):\n                session.flash = self.messages.email_sent\n            else:\n                session.flash = self.messages.unable_to_send_email\n            self.log_event(log, user)\n            callback(onaccept, form)\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n        # old_requires = table_user.email.requires\n        return form\n\n    def email_reset_password(self, user):\n        reset_password_key = str(int(time.time())) + '-' + web2py_uuid()\n        link = self.url(self.settings.function,\n                        args=('reset_password',), vars={'key': reset_password_key},\n                        scheme=True)\n        d = dict(user)\n        d.update(dict(key=reset_password_key, link=link))\n        if self.settings.mailer and self.settings.mailer.send(\n            to=user.email,\n            subject=self.messages.reset_password_subject,\n            message=self.messages.reset_password % d):\n            user.update_record(reset_password_key=reset_password_key)\n            return True\n        return False\n\n    def retrieve_password(self,\n                          next=DEFAULT,\n                          onvalidation=DEFAULT,\n                          onaccept=DEFAULT,\n                          log=DEFAULT,\n                          ):\n        if self.settings.reset_password_requires_verification:\n            return self.request_reset_password(next, onvalidation, onaccept, log)\n        else:\n            return self.reset_password_deprecated(next, onvalidation, onaccept, log)\n\n    def change_password(self,\n                        next=DEFAULT,\n                        onvalidation=DEFAULT,\n                        onaccept=DEFAULT,\n                        log=DEFAULT,\n                        ):\n        \"\"\"\n        Returns a form that lets the user change password\n        \"\"\"\n\n        if not self.is_logged_in():\n            redirect(self.settings.login_url,\n                     client_side=self.settings.client_side)\n        db = self.db\n        table_user = self.table_user()\n        s = db(table_user.id == self.user.id)\n\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.change_password_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.change_password_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.change_password_onaccept\n        if log is DEFAULT:\n            log = self.messages['change_password_log']\n        passfield = self.settings.password_field\n        requires = table_user[passfield].requires\n        if not isinstance(requires, (list, tuple)):\n            requires = [requires]\n        requires = filter(lambda t: isinstance(t, CRYPT), requires)\n        if requires:\n            requires[0].min_length = 0\n        form = SQLFORM.factory(\n            Field('old_password', 'password', requires=requires,\n                label=self.messages.old_password),\n            Field('new_password', 'password',\n                label=self.messages.new_password,\n                requires=table_user[passfield].requires),\n            Field('new_password2', 'password',\n                label=self.messages.verify_password,\n                requires=[IS_EXPR(\n                    'value==%s' % repr(request.vars.new_password),\n                              self.messages.mismatched_password)]),\n            submit_button=self.messages.password_change_button,\n            hidden=dict(_next=next),\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n        )\n        if form.accepts(request, session,\n                        formname='change_password',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n\n            current_user = s.select(limitby=(0, 1), orderby_on_limitby=False).first()\n            if not form.vars['old_password'] == current_user[passfield]:\n                form.errors['old_password'] = self.messages.invalid_password\n            else:\n                d = {passfield: str(form.vars.new_password)}\n                s.update(**d)\n                session.flash = self.messages.password_changed\n                self.log_event(log, self.user)\n                callback(onaccept, form)\n                if not next:\n                    next = self.url(args=request.args)\n                else:\n                    next = replace_id(next, form)\n                redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def profile(self,\n                next=DEFAULT,\n                onvalidation=DEFAULT,\n                onaccept=DEFAULT,\n                log=DEFAULT,\n                ):\n        \"\"\"\n        Returns a form that lets the user change his/her profile\n        \"\"\"\n\n        table_user = self.table_user()\n        if not self.is_logged_in():\n            redirect(self.settings.login_url,\n                     client_side=self.settings.client_side)\n        passfield = self.settings.password_field\n        table_user[passfield].writable = False\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = self.get_vars_next() or self.settings.profile_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.profile_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.profile_onaccept\n        if log is DEFAULT:\n            log = self.messages['profile_log']\n        form = SQLFORM(\n            table_user,\n            self.user.id,\n            fields=self.settings.profile_fields,\n            hidden=dict(_next=next),\n            showid=self.settings.showid,\n            submit_button=self.messages.profile_save_button,\n            delete_label=self.messages.delete_label,\n            upload=self.settings.download_url,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator,\n            deletable=self.settings.allow_delete_accounts,\n            )\n        if form.accepts(request, session,\n                        formname='profile',\n                        onvalidation=onvalidation,\n                        hideerror=self.settings.hideerror):\n            self.user.update(table_user._filter_fields(form.vars))\n            session.flash = self.messages.profile_updated\n            self.log_event(log, self.user)\n            callback(onaccept, form)\n            if form.deleted:\n                return self.logout()\n            if not next:\n                next = self.url(args=request.args)\n            else:\n                next = replace_id(next, form)\n            redirect(next, client_side=self.settings.client_side)\n        return form\n\n    def run_login_onaccept(self):\n        onaccept = self.settings.login_onaccept\n        if onaccept:\n            form = Storage(dict(vars=self.user))\n            if not isinstance(onaccept, (list, tuple)):\n                onaccept = [onaccept]\n            for callback in onaccept:\n                callback(form)\n\n    def is_impersonating(self):\n        return self.is_logged_in() and 'impersonator' in current.session.auth\n\n    def impersonate(self, user_id=DEFAULT):\n        \"\"\"\n        To use this make a POST to\n        `http://..../impersonate request.post_vars.user_id=<id>`\n\n        Set request.post_vars.user_id to 0 to restore original user.\n\n        requires impersonator is logged in and::\n\n            has_permission('impersonate', 'auth_user', user_id)\n\n        \"\"\"\n        request = current.request\n        session = current.session\n        auth = session.auth\n        table_user = self.table_user()\n        if not self.is_logged_in():\n            raise HTTP(401, \"Not Authorized\")\n        current_id = auth.user.id\n        requested_id = user_id\n        if user_id is DEFAULT:\n            user_id = current.request.post_vars.user_id\n        if user_id and user_id != self.user.id and user_id != '0':\n            if not self.has_permission('impersonate',\n                                       self.table_user(),\n                                       user_id):\n                raise HTTP(403, \"Forbidden\")\n            user = table_user(user_id)\n            if not user:\n                raise HTTP(401, \"Not Authorized\")\n            auth.impersonator = pickle.dumps(session, pickle.HIGHEST_PROTOCOL)\n            auth.user.update(\n                table_user._filter_fields(user, True))\n            self.user = auth.user\n            self.update_groups()\n            log = self.messages['impersonate_log']\n            self.log_event(log, dict(id=current_id, other_id=auth.user.id))\n            self.run_login_onaccept()\n        elif user_id in (0, '0'):\n            if self.is_impersonating():\n                session.clear()\n                session.update(pickle.loads(auth.impersonator))\n                self.user = session.auth.user\n                self.update_groups()\n                self.run_login_onaccept()\n            return None\n        if requested_id is DEFAULT and not request.post_vars:\n            return SQLFORM.factory(Field('user_id', 'integer'))\n        return SQLFORM(table_user, user.id, readonly=True)\n\n    def update_groups(self):\n        if not self.user:\n            return\n        user_groups = self.user_groups = {}\n        if current.session.auth:\n            current.session.auth.user_groups = self.user_groups\n        table_group = self.table_group()\n        table_membership = self.table_membership()\n        memberships = self.db(\n            table_membership.user_id == self.user.id).select()\n        for membership in memberships:\n            group = table_group(membership.group_id)\n            if group:\n                user_groups[membership.group_id] = group.role\n\n    def groups(self):\n        \"\"\"\n        Displays the groups and their roles for the logged in user\n        \"\"\"\n\n        if not self.is_logged_in():\n            redirect(self.settings.login_url)\n        table_membership = self.table_membership()\n        memberships = self.db(\n            table_membership.user_id == self.user.id).select()\n        table = TABLE()\n        for membership in memberships:\n            table_group = self.table_group()\n            groups = self.db(table_group.id == membership.group_id).select()\n            if groups:\n                group = groups[0]\n                table.append(TR(H3(group.role, '(%s)' % group.id)))\n                table.append(TR(P(group.description)))\n        if not memberships:\n            return None\n        return table\n\n    def not_authorized(self):\n        \"\"\"\n        You can change the view for this page to make it look as you like\n        \"\"\"\n        if current.request.ajax:\n            raise HTTP(403, 'ACCESS DENIED')\n        return self.messages.access_denied\n\n    def requires(self, condition, requires_login=True, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in\n        \"\"\"\n\n        def decorator(action):\n\n            def f(*a, **b):\n\n                basic_allowed, basic_accepted, user = self.basic()\n                user = user or self.user\n                if requires_login:\n                    if not user:\n                        if current.request.ajax:\n                            raise HTTP(401, self.messages.ajax_failed_authentication)\n                        elif not otherwise is None:\n                            if callable(otherwise):\n                                return otherwise()\n                            redirect(otherwise)\n                        elif self.settings.allow_basic_login_only or \\\n                                basic_accepted or current.request.is_restful:\n                            raise HTTP(403, \"Not authorized\")\n                        else:\n                            next = self.here()\n                            current.session.flash = current.response.flash\n                            return call_or_redirect(\n                                self.settings.on_failed_authentication,\n                                self.settings.login_url +\n                                    '?_next=' + urllib.quote(next))\n\n                if callable(condition):\n                    flag = condition()\n                else:\n                    flag = condition\n                if not flag:\n                    current.session.flash = self.messages.access_denied\n                    return call_or_redirect(\n                        self.settings.on_failed_authorization)\n                return action(*a, **b)\n            f.__doc__ = action.__doc__\n            f.__name__ = action.__name__\n            f.__dict__.update(action.__dict__)\n            return f\n\n        return decorator\n\n    def requires_login(self, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in\n        \"\"\"\n        return self.requires(True, otherwise=otherwise)\n\n    def requires_login_or_token(self, otherwise=None):\n        if self.settings.enable_tokens == True:\n            user = None\n            request = current.request\n            token = request.env.http_web2py_user_token or request.vars._token\n            table_token = self.table_token()\n            table_user = self.table_user()\n            from gluon.settings import global_settings\n            if global_settings.web2py_runtime_gae:\n                row = table_token(token=token)\n                if row:\n                    user = table_user(row.user_id)\n            else:\n                row = self.db(table_token.token==token)(table_user.id==table_token.user_id).select().first()\n                if row:\n                    user = row[table_user._tablename]\n            if user:\n                self.login_user(user)\n        return self.requires(True, otherwise=otherwise)\n\n    def requires_membership(self, role=None, group_id=None, otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of group_id.\n        If role is provided instead of group_id then the\n        group_id is calculated.\n        \"\"\"\n        def has_membership(self=self, group_id=group_id, role=role):\n            return self.has_membership(group_id=group_id, role=role)\n        return self.requires(has_membership, otherwise=otherwise)\n\n    def requires_permission(self, name, table_name='', record_id=0,\n                            otherwise=None):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of any group (role) that\n        has 'name' access to 'table_name', 'record_id'.\n        \"\"\"\n        def has_permission(self=self, name=name, table_name=table_name, record_id=record_id):\n            return self.has_permission(name, table_name, record_id)\n        return self.requires(has_permission, otherwise=otherwise)\n\n    def requires_signature(self, otherwise=None, hash_vars=True):\n        \"\"\"\n        Decorator that prevents access to action if not logged in or\n        if user logged in is not a member of group_id.\n        If role is provided instead of group_id then the\n        group_id is calculated.\n        \"\"\"\n        def verify():\n            return URL.verify(current.request, user_signature=True, hash_vars=hash_vars)\n        return self.requires(verify, otherwise)\n\n    def add_group(self, role, description=''):\n        \"\"\"\n        Creates a group associated to a role\n        \"\"\"\n\n        group_id = self.table_group().insert(\n            role=role, description=description)\n        self.log_event(self.messages['add_group_log'],\n                       dict(group_id=group_id, role=role))\n        return group_id\n\n    def del_group(self, group_id):\n        \"\"\"\n        Deletes a group\n        \"\"\"\n        self.db(self.table_group().id == group_id).delete()\n        self.db(self.table_membership().group_id == group_id).delete()\n        self.db(self.table_permission().group_id == group_id).delete()\n        if group_id in self.user_groups: del self.user_groups[group_id]\n        self.log_event(self.messages.del_group_log, dict(group_id=group_id))\n\n    def id_group(self, role):\n        \"\"\"\n        Returns the group_id of the group specified by the role\n        \"\"\"\n        rows = self.db(self.table_group().role == role).select()\n        if not rows:\n            return None\n        return rows[0].id\n\n    def user_group(self, user_id=None):\n        \"\"\"\n        Returns the group_id of the group uniquely associated to this user\n        i.e. `role=user:[user_id]`\n        \"\"\"\n        return self.id_group(self.user_group_role(user_id))\n\n    def user_group_role(self, user_id=None):\n        if not self.settings.create_user_groups:\n            return None\n        if user_id:\n            user = self.table_user()[user_id]\n        else:\n            user = self.user\n        return self.settings.create_user_groups % user\n\n    def has_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Checks if user is member of group_id or role\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        try:\n            group_id = int(group_id)\n        except:\n            group_id = self.id_group(group_id)  # interpret group_id as a role\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        if group_id and user_id and self.db((membership.user_id == user_id)\n                    & (membership.group_id == group_id)).select():\n            r = True\n        else:\n            r = False\n        self.log_event(self.messages['has_membership_log'],\n                       dict(user_id=user_id, group_id=group_id, check=r))\n        return r\n\n    def add_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Gives user_id membership of group_id or role\n        if user is None than user_id is that of current logged in user\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        try:\n            group_id = int(group_id)\n        except:\n            group_id = self.id_group(group_id)  # interpret group_id as a role\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        record = membership(user_id=user_id, group_id=group_id)\n        if record:\n            return record.id\n        else:\n            id = membership.insert(group_id=group_id, user_id=user_id)\n        if role:\n            self.user_groups[group_id] = role\n        else:\n            self.update_groups()\n        self.log_event(self.messages['add_membership_log'],\n                       dict(user_id=user_id, group_id=group_id))\n        return id\n\n    def del_membership(self, group_id=None, user_id=None, role=None):\n        \"\"\"\n        Revokes membership from group_id to user_id\n        if user_id is None than user_id is that of current logged in user\n        \"\"\"\n\n        group_id = group_id or self.id_group(role)\n        if not user_id and self.user:\n            user_id = self.user.id\n        membership = self.table_membership()\n        self.log_event(self.messages['del_membership_log'],\n                       dict(user_id=user_id, group_id=group_id))\n        ret = self.db(membership.user_id\n                      == user_id)(membership.group_id\n                                  == group_id).delete()\n        if group_id in self.user_groups: del self.user_groups[group_id]\n        return ret\n\n    def has_permission(self,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       user_id=None,\n                       group_id=None,\n                       ):\n        \"\"\"\n        Checks if user_id or current logged in user is member of a group\n        that has 'name' permission on 'table_name' and 'record_id'\n        if group_id is passed, it checks whether the group has the permission\n        \"\"\"\n\n        if not group_id and self.settings.everybody_group_id and \\\n                self.has_permission(\n            name, table_name, record_id, user_id=None,\n            group_id=self.settings.everybody_group_id):\n                return True\n\n        if not user_id and not group_id and self.user:\n            user_id = self.user.id\n        if user_id:\n            membership = self.table_membership()\n            rows = self.db(membership.user_id\n                           == user_id).select(membership.group_id)\n            groups = set([row.group_id for row in rows])\n            if group_id and not group_id in groups:\n                return False\n        else:\n            groups = set([group_id])\n        permission = self.table_permission()\n        rows = self.db(permission.name == name)(permission.table_name\n                 == str(table_name))(permission.record_id\n                 == record_id).select(permission.group_id)\n        groups_required = set([row.group_id for row in rows])\n        if record_id:\n            rows = self.db(permission.name\n                            == name)(permission.table_name\n                     == str(table_name))(permission.record_id\n                     == 0).select(permission.group_id)\n            groups_required = groups_required.union(set([row.group_id\n                    for row in rows]))\n        if groups.intersection(groups_required):\n            r = True\n        else:\n            r = False\n        if user_id:\n            self.log_event(self.messages['has_permission_log'],\n                           dict(user_id=user_id, name=name,\n                                table_name=table_name, record_id=record_id))\n        return r\n\n    def add_permission(self,\n                       group_id,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       ):\n        \"\"\"\n        Gives group_id 'name' access to 'table_name' and 'record_id'\n        \"\"\"\n\n        permission = self.table_permission()\n        if group_id == 0:\n            group_id = self.user_group()\n        record = self.db(permission.group_id == group_id)(permission.name == name)(permission.table_name == str(table_name))(\n                permission.record_id == long(record_id)).select(limitby=(0, 1), orderby_on_limitby=False).first()\n        if record:\n            id = record.id\n        else:\n            id = permission.insert(group_id=group_id, name=name,\n                                   table_name=str(table_name),\n                                   record_id=long(record_id))\n        self.log_event(self.messages['add_permission_log'],\n                       dict(permission_id=id, group_id=group_id,\n                            name=name, table_name=table_name,\n                            record_id=record_id))\n        return id\n\n    def del_permission(self,\n                       group_id,\n                       name='any',\n                       table_name='',\n                       record_id=0,\n                       ):\n        \"\"\"\n        Revokes group_id 'name' access to 'table_name' and 'record_id'\n        \"\"\"\n\n        permission = self.table_permission()\n        self.log_event(self.messages['del_permission_log'],\n                       dict(group_id=group_id, name=name,\n                            table_name=table_name, record_id=record_id))\n        return self.db(permission.group_id == group_id)(permission.name\n                 == name)(permission.table_name\n                           == str(table_name))(permission.record_id\n                 == long(record_id)).delete()\n\n    def accessible_query(self, name, table, user_id=None):\n        \"\"\"\n        Returns a query with all accessible records for user_id or\n        the current logged in user\n        this method does not work on GAE because uses JOIN and IN\n\n        Example:\n            Use as::\n\n                db(auth.accessible_query('read', db.mytable)).select(db.mytable.ALL)\n\n        \"\"\"\n        if not user_id:\n            user_id = self.user_id\n        db = self.db\n        if isinstance(table, str) and table in self.db.tables():\n            table = self.db[table]\n        elif isinstance(table, (Set, Query)):\n            # experimental: build a chained query for all tables\n            if isinstance(table, Set):\n                cquery = table.query\n            else:\n                cquery = table\n            tablenames = db._adapter.tables(cquery)\n            for tablename in tablenames:\n                cquery &= self.accessible_query(name, tablename,\n                                                user_id=user_id)\n            return cquery\n        if not isinstance(table, str) and\\\n                self.has_permission(name, table, 0, user_id):\n            return table.id > 0\n        membership = self.table_membership()\n        permission = self.table_permission()\n        query = table.id.belongs(\n            db(membership.user_id == user_id)\n                (membership.group_id == permission.group_id)\n                (permission.name == name)\n                (permission.table_name == table)\n                ._select(permission.record_id))\n        if self.settings.everybody_group_id:\n            query |= table.id.belongs(\n                db(permission.group_id == self.settings.everybody_group_id)\n                    (permission.name == name)\n                    (permission.table_name == table)\n                    ._select(permission.record_id))\n        return query\n\n    @staticmethod\n    def archive(form,\n                archive_table=None,\n                current_record='current_record',\n                archive_current=False,\n                fields=None):\n        \"\"\"\n        If you have a table (db.mytable) that needs full revision history you\n        can just do::\n\n            form=crud.update(db.mytable,myrecord,onaccept=auth.archive)\n\n        or::\n\n            form=SQLFORM(db.mytable,myrecord).process(onaccept=auth.archive)\n\n        crud.archive will define a new table \"mytable_archive\" and store\n        a copy of the current record (if archive_current=True)\n        or a copy of the previous record (if archive_current=False)\n        in the newly created table including a reference\n        to the current record.\n\n        fields allows to specify extra fields that need to be archived.\n\n        If you want to access such table you need to define it yourself\n        in a model::\n\n            db.define_table('mytable_archive',\n                Field('current_record',db.mytable),\n                db.mytable)\n\n        Notice such table includes all fields of db.mytable plus one: current_record.\n        crud.archive does not timestamp the stored record unless your original table\n        has a fields like::\n\n            db.define_table(...,\n                Field('saved_on','datetime',\n                     default=request.now,update=request.now,writable=False),\n                Field('saved_by',auth.user,\n                     default=auth.user_id,update=auth.user_id,writable=False),\n\n        there is nothing special about these fields since they are filled before\n        the record is archived.\n\n        If you want to change the archive table name and the name of the reference field\n        you can do, for example::\n\n            db.define_table('myhistory',\n                Field('parent_record',db.mytable),\n                db.mytable)\n\n        and use it as::\n\n            form=crud.update(db.mytable,myrecord,\n                             onaccept=lambda form:crud.archive(form,\n                             archive_table=db.myhistory,\n                             current_record='parent_record'))\n\n        \"\"\"\n        if not archive_current and not form.record:\n            return None\n        table = form.table\n        if not archive_table:\n            archive_table_name = '%s_archive' % table\n            if not archive_table_name in table._db:\n                table._db.define_table(\n                    archive_table_name,\n                    Field(current_record, table),\n                    *[field.clone(unique=False) for field in table])\n            archive_table = table._db[archive_table_name]\n        new_record = {current_record: form.vars.id}\n        for fieldname in archive_table.fields:\n            if not fieldname in ['id', current_record]:\n                if archive_current and fieldname in form.vars:\n                    new_record[fieldname] = form.vars[fieldname]\n                elif form.record and fieldname in form.record:\n                    new_record[fieldname] = form.record[fieldname]\n        if fields:\n            new_record.update(fields)\n        id = archive_table.insert(**new_record)\n        return id\n\n    def wiki(self,\n             slug=None,\n             env=None,\n             render='markmin',\n             manage_permissions=False,\n             force_prefix='',\n             restrict_search=False,\n             resolve=True,\n             extra=None,\n             menu_groups=None,\n             templates=None,\n             migrate=True,\n             controller=None,\n             function=None,\n             force_render=False,\n             groups=None):\n\n        if controller and function:\n            resolve = False\n\n        if not hasattr(self, '_wiki'):\n            self._wiki = Wiki(self, render=render,\n                              manage_permissions=manage_permissions,\n                              force_prefix=force_prefix,\n                              restrict_search=restrict_search,\n                              env=env, extra=extra or {},\n                              menu_groups=menu_groups,\n                              templates=templates,\n                              migrate=migrate,\n                              controller=controller,\n                              function=function,\n                              groups=groups)\n        else:\n            self._wiki.env.update(env or {})\n\n        # if resolve is set to True, process request as wiki call\n        # resolve=False allows initial setup without wiki redirection\n        wiki = None\n        if resolve:\n            if slug:\n                wiki = self._wiki.read(slug, force_render)\n                if isinstance(wiki, dict) and wiki.has_key('content'):  # FIXME: .has_key() is deprecated\n                    # We don't want to return a dict object, just the wiki\n                    wiki = wiki['content']\n            else:\n                wiki = self._wiki()\n            if isinstance(wiki, basestring):\n                wiki = XML(wiki)\n            return wiki\n\n    def wikimenu(self):\n        \"\"\"To be used in menu.py for app wide wiki menus\"\"\"\n        if (hasattr(self, \"_wiki\") and\n            self._wiki.settings.controller and\n            self._wiki.settings.function):\n            self._wiki.automenu()\n\n\nclass Crud(object):\n\n    def url(self, f=None, args=None, vars=None):\n        \"\"\"\n        This should point to the controller that exposes\n        download and crud\n        \"\"\"\n        if args is None:\n            args = []\n        if vars is None:\n            vars = {}\n        return URL(c=self.settings.controller, f=f, args=args, vars=vars)\n\n    def __init__(self, environment, db=None, controller='default'):\n        self.db = db\n        if not db and environment and isinstance(environment, DAL):\n            self.db = environment\n        elif not db:\n            raise SyntaxError(\"must pass db as first or second argument\")\n        self.environment = current\n        settings = self.settings = Settings()\n        settings.auth = None\n        settings.logger = None\n\n        settings.create_next = None\n        settings.update_next = None\n        settings.controller = controller\n        settings.delete_next = self.url()\n        settings.download_url = self.url('download')\n        settings.create_onvalidation = StorageList()\n        settings.update_onvalidation = StorageList()\n        settings.delete_onvalidation = StorageList()\n        settings.create_onaccept = StorageList()\n        settings.update_onaccept = StorageList()\n        settings.update_ondelete = StorageList()\n        settings.delete_onaccept = StorageList()\n        settings.update_deletable = True\n        settings.showid = False\n        settings.keepvalues = False\n        settings.create_captcha = None\n        settings.update_captcha = None\n        settings.captcha = None\n        settings.formstyle = 'table3cols'\n        settings.label_separator = ': '\n        settings.hideerror = False\n        settings.detect_record_change = True\n        settings.hmac_key = None\n        settings.lock_keys = True\n\n        messages = self.messages = Messages(current.T)\n        messages.submit_button = 'Submit'\n        messages.delete_label = 'Check to delete'\n        messages.record_created = 'Record Created'\n        messages.record_updated = 'Record Updated'\n        messages.record_deleted = 'Record Deleted'\n\n        messages.update_log = 'Record %(id)s updated'\n        messages.create_log = 'Record %(id)s created'\n        messages.read_log = 'Record %(id)s read'\n        messages.delete_log = 'Record %(id)s deleted'\n\n        messages.lock_keys = True\n\n    def __call__(self):\n        args = current.request.args\n        if len(args) < 1:\n            raise HTTP(404)\n        elif args[0] == 'tables':\n            return self.tables()\n        elif len(args) > 1 and not args(1) in self.db.tables:\n            raise HTTP(404)\n        table = self.db[args(1)]\n        if args[0] == 'create':\n            return self.create(table)\n        elif args[0] == 'select':\n            return self.select(table, linkto=self.url(args='read'))\n        elif args[0] == 'search':\n            form, rows = self.search(table, linkto=self.url(args='read'))\n            return DIV(form, SQLTABLE(rows))\n        elif args[0] == 'read':\n            return self.read(table, args(2))\n        elif args[0] == 'update':\n            return self.update(table, args(2))\n        elif args[0] == 'delete':\n            return self.delete(table, args(2))\n        else:\n            raise HTTP(404)\n\n    def log_event(self, message, vars):\n        if self.settings.logger:\n            self.settings.logger.log_event(message, vars, origin='crud')\n\n    def has_permission(self, name, table, record=0):\n        if not self.settings.auth:\n            return True\n        try:\n            record_id = record.id\n        except:\n            record_id = record\n        return self.settings.auth.has_permission(name, str(table), record_id)\n\n    def tables(self):\n        return TABLE(*[TR(A(name,\n                            _href=self.url(args=('select', name))))\n                       for name in self.db.tables])\n\n    @staticmethod\n    def archive(form, archive_table=None, current_record='current_record'):\n        return Auth.archive(form, archive_table=archive_table,\n                            current_record=current_record)\n\n    def update(self,\n               table,\n               record,\n               next=DEFAULT,\n               onvalidation=DEFAULT,\n               onaccept=DEFAULT,\n               ondelete=DEFAULT,\n               log=DEFAULT,\n               message=DEFAULT,\n               deletable=DEFAULT,\n               formname=DEFAULT,\n               **attributes\n               ):\n        if not (isinstance(table, Table) or table in self.db.tables) \\\n                or (isinstance(record, str) and not str(record).isdigit()):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        try:\n            record_id = record.id\n        except:\n            record_id = record or 0\n        if record_id and not self.has_permission('update', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        if not record_id and not self.has_permission('create', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n\n        request = current.request\n        response = current.response\n        session = current.session\n        if request.extension == 'json' and request.vars.json:\n            request.vars.update(json_parser.loads(request.vars.json))\n        if next is DEFAULT:\n            next = request.get_vars._next \\\n                or request.post_vars._next \\\n                or self.settings.update_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.update_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.update_onaccept\n        if ondelete is DEFAULT:\n            ondelete = self.settings.update_ondelete\n        if log is DEFAULT:\n            log = self.messages['update_log']\n        if deletable is DEFAULT:\n            deletable = self.settings.update_deletable\n        if message is DEFAULT:\n            message = self.messages.record_updated\n        if not 'hidden' in attributes:\n            attributes['hidden'] = {}\n        attributes['hidden']['_next'] = next\n        form = SQLFORM(\n            table,\n            record,\n            showid=self.settings.showid,\n            submit_button=self.messages.submit_button,\n            delete_label=self.messages.delete_label,\n            deletable=deletable,\n            upload=self.settings.download_url,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator,\n            **attributes  # contains hidden\n            )\n        self.accepted = False\n        self.deleted = False\n        captcha = self.settings.update_captcha or self.settings.captcha\n        if record and captcha:\n            addrow(form, captcha.label, captcha, captcha.comment,\n                         self.settings.formstyle, 'captcha__row')\n        captcha = self.settings.create_captcha or self.settings.captcha\n        if not record and captcha:\n            addrow(form, captcha.label, captcha, captcha.comment,\n                         self.settings.formstyle, 'captcha__row')\n        if not request.extension in ('html', 'load'):\n            (_session, _formname) = (None, None)\n        else:\n            (_session, _formname) = (\n                session, '%s/%s' % (table._tablename, form.record_id))\n        if not formname is DEFAULT:\n            _formname = formname\n        keepvalues = self.settings.keepvalues\n        if request.vars.delete_this_record:\n            keepvalues = False\n        if isinstance(onvalidation, StorageList):\n            onvalidation = onvalidation.get(table._tablename, [])\n        if form.accepts(request, _session, formname=_formname,\n                        onvalidation=onvalidation, keepvalues=keepvalues,\n                        hideerror=self.settings.hideerror,\n                        detect_record_change=self.settings.detect_record_change):\n            self.accepted = True\n            response.flash = message\n            if log:\n                self.log_event(log, form.vars)\n            if request.vars.delete_this_record:\n                self.deleted = True\n                message = self.messages.record_deleted\n                callback(ondelete, form, table._tablename)\n            response.flash = message\n            callback(onaccept, form, table._tablename)\n            if not request.extension in ('html', 'load'):\n                raise HTTP(200, 'RECORD CREATED/UPDATED')\n            if isinstance(next, (list, tuple)):  # fix issue with 2.6\n                next = next[0]\n            if next:  # Only redirect when explicit\n                next = replace_id(next, form)\n                session.flash = response.flash\n                redirect(next)\n        elif not request.extension in ('html', 'load'):\n            raise HTTP(401, serializers.json(dict(errors=form.errors)))\n        return form\n\n    def create(self,\n               table,\n               next=DEFAULT,\n               onvalidation=DEFAULT,\n               onaccept=DEFAULT,\n               log=DEFAULT,\n               message=DEFAULT,\n               formname=DEFAULT,\n               **attributes\n               ):\n\n        if next is DEFAULT:\n            next = self.settings.create_next\n        if onvalidation is DEFAULT:\n            onvalidation = self.settings.create_onvalidation\n        if onaccept is DEFAULT:\n            onaccept = self.settings.create_onaccept\n        if log is DEFAULT:\n            log = self.messages['create_log']\n        if message is DEFAULT:\n            message = self.messages.record_created\n        return self.update(\n            table,\n            None,\n            next=next,\n            onvalidation=onvalidation,\n            onaccept=onaccept,\n            log=log,\n            message=message,\n            deletable=False,\n            formname=formname,\n            **attributes\n            )\n\n    def read(self, table, record):\n        if not (isinstance(table, Table) or table in self.db.tables) \\\n                or (isinstance(record, str) and not str(record).isdigit()):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not self.has_permission('read', table, record):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        form = SQLFORM(\n            table,\n            record,\n            readonly=True,\n            comments=False,\n            upload=self.settings.download_url,\n            showid=self.settings.showid,\n            formstyle=self.settings.formstyle,\n            separator=self.settings.label_separator\n            )\n        if not current.request.extension in ('html', 'load'):\n            return table._filter_fields(form.record, id=True)\n        return form\n\n    def delete(self,\n               table,\n               record_id,\n               next=DEFAULT,\n               message=DEFAULT,\n               ):\n        if not (isinstance(table, Table) or table in self.db.tables):\n            raise HTTP(404)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not self.has_permission('delete', table, record_id):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        request = current.request\n        session = current.session\n        if next is DEFAULT:\n            next = request.get_vars._next \\\n                or request.post_vars._next \\\n                or self.settings.delete_next\n        if message is DEFAULT:\n            message = self.messages.record_deleted\n        record = table[record_id]\n        if record:\n            callback(self.settings.delete_onvalidation, record)\n            del table[record_id]\n            callback(self.settings.delete_onaccept, record, table._tablename)\n            session.flash = message\n        redirect(next)\n\n    def rows(\n        self,\n        table,\n        query=None,\n        fields=None,\n        orderby=None,\n        limitby=None,\n        ):\n        if not (isinstance(table, Table) or table in self.db.tables):\n            raise HTTP(404)\n        if not self.has_permission('select', table):\n            redirect(self.settings.auth.settings.on_failed_authorization)\n        #if record_id and not self.has_permission('select', table):\n        #    redirect(self.settings.auth.settings.on_failed_authorization)\n        if not isinstance(table, Table):\n            table = self.db[table]\n        if not query:\n            query = table.id > 0\n        if not fields:\n            fields = [field for field in table if field.readable]\n        else:\n            fields = [table[f] if isinstance(f, str) else f for f in fields]\n        rows = self.db(query).select(*fields, **dict(orderby=orderby,\n                                                    limitby=limitby))\n        return rows\n\n    def select(self,\n               table,\n               query=None,\n               fields=None,\n               orderby=None,\n               limitby=None,\n               headers=None,\n               **attr\n               ):\n        headers = headers or {}\n        rows = self.rows(table, query, fields, orderby, limitby)\n        if not rows:\n            return None  # Nicer than an empty table.\n        if not 'upload' in attr:\n            attr['upload'] = self.url('download')\n        if not current.request.extension in ('html', 'load'):\n            return rows.as_list()\n        if not headers:\n            if isinstance(table, str):\n                table = self.db[table]\n            headers = dict((str(k), k.label) for k in table)\n        return SQLTABLE(rows, headers=headers, **attr)\n\n    def get_format(self, field):\n        rtable = field._db[field.type[10:]]\n        format = rtable.get('_format', None)\n        if format and isinstance(format, str):\n            return format[2:-2]\n        return field.name\n\n    def get_query(self, field, op, value, refsearch=False):\n        try:\n            if refsearch:\n                format = self.get_format(field)\n            if op == 'equals':\n                if not refsearch:\n                    return field == value\n                else:\n                    return lambda row: row[field.name][format] == value\n            elif op == 'not equal':\n                if not refsearch:\n                    return field != value\n                else:\n                    return lambda row: row[field.name][format] != value\n            elif op == 'greater than':\n                if not refsearch:\n                    return field > value\n                else:\n                    return lambda row: row[field.name][format] > value\n            elif op == 'less than':\n                if not refsearch:\n                    return field < value\n                else:\n                    return lambda row: row[field.name][format] < value\n            elif op == 'starts with':\n                if not refsearch:\n                    return field.like(value + '%')\n                else:\n                    return lambda row: str(row[field.name][format]).startswith(value)\n            elif op == 'ends with':\n                if not refsearch:\n                    return field.like('%' + value)\n                else:\n                    return lambda row: str(row[field.name][format]).endswith(value)\n            elif op == 'contains':\n                if not refsearch:\n                    return field.like('%' + value + '%')\n                else:\n                    return lambda row: value in row[field.name][format]\n        except:\n            return None\n\n    def search(self, *tables, **args):\n        \"\"\"\n        Creates a search form and its results for a table\n        Examples:\n            Use as::\n\n                form, results = crud.search(db.test,\n                   queries = ['equals', 'not equal', 'contains'],\n                   query_labels={'equals':'Equals',\n                                 'not equal':'Not equal'},\n                   fields = ['id','children'],\n                   field_labels = {\n                       'id':'ID','children':'Children'},\n                   zero='Please choose',\n                   query = (db.test.id > 0)&(db.test.id != 3) )\n\n        \"\"\"\n        table = tables[0]\n        fields = args.get('fields', table.fields)\n        validate = args.get('validate', True)\n        request = current.request\n        db = self.db\n        if not (isinstance(table, Table) or table in db.tables):\n            raise HTTP(404)\n        attributes = {}\n        for key in ('orderby', 'groupby', 'left', 'distinct', 'limitby', 'cache'):\n            if key in args:\n                attributes[key] = args[key]\n        tbl = TABLE()\n        selected = []\n        refsearch = []\n        results = []\n        showall = args.get('showall', False)\n        if showall:\n            selected = fields\n        chkall = args.get('chkall', False)\n        if chkall:\n            for f in fields:\n                request.vars['chk%s' % f] = 'on'\n        ops = args.get('queries', [])\n        zero = args.get('zero', '')\n        if not ops:\n            ops = ['equals', 'not equal', 'greater than',\n                   'less than', 'starts with',\n                   'ends with', 'contains']\n        ops.insert(0, zero)\n        query_labels = args.get('query_labels', {})\n        query = args.get('query', table.id > 0)\n        field_labels = args.get('field_labels', {})\n        for field in fields:\n            field = table[field]\n            if not field.readable:\n                continue\n            fieldname = field.name\n            chkval = request.vars.get('chk' + fieldname, None)\n            txtval = request.vars.get('txt' + fieldname, None)\n            opval = request.vars.get('op' + fieldname, None)\n            row = TR(TD(INPUT(_type=\"checkbox\", _name=\"chk\" + fieldname,\n                              _disabled=(field.type == 'id'),\n                              value=(field.type == 'id' or chkval == 'on'))),\n                     TD(field_labels.get(fieldname, field.label)),\n                     TD(SELECT([OPTION(query_labels.get(op, op),\n                                       _value=op) for op in ops],\n                               _name=\"op\" + fieldname,\n                               value=opval)),\n                     TD(INPUT(_type=\"text\", _name=\"txt\" + fieldname,\n                              _value=txtval, _id='txt' + fieldname,\n                              _class=str(field.type))))\n            tbl.append(row)\n            if request.post_vars and (chkval or field.type == 'id'):\n                if txtval and opval != '':\n                    if field.type[0:10] == 'reference ':\n                        refsearch.append(self.get_query(field, opval, txtval, refsearch=True))\n                    elif validate:\n                        value, error = field.validate(txtval)\n                        if not error:\n                            ### TODO deal with 'starts with', 'ends with', 'contains' on GAE\n                            query &= self.get_query(field, opval, value)\n                        else:\n                            row[3].append(DIV(error, _class='error'))\n                    else:\n                        query &= self.get_query(field, opval, txtval)\n                selected.append(field)\n        form = FORM(tbl, INPUT(_type=\"submit\"))\n        if selected:\n            try:\n                results = db(query).select(*selected, **attributes)\n                for r in refsearch:\n                    results = results.find(r)\n            except:  # hmmm, we should do better here\n                results = None\n        return form, results\n\n\nurllib2.install_opener(urllib2.build_opener(urllib2.HTTPCookieProcessor()))\n\n\ndef fetch(url, data=None, headers=None,\n          cookie=Cookie.SimpleCookie(),\n          user_agent='Mozilla/5.0'):\n    headers = headers or {}\n    if not data is None:\n        data = urllib.urlencode(data)\n    if user_agent:\n        headers['User-agent'] = user_agent\n    headers['Cookie'] = ' '.join(\n        ['%s=%s;' % (c.key, c.value) for c in cookie.values()])\n    try:\n        from google.appengine.api import urlfetch\n    except ImportError:\n        req = urllib2.Request(url, data, headers)\n        html = urllib2.urlopen(req).read()\n    else:\n        method = ((data is None) and urlfetch.GET) or urlfetch.POST\n        while url is not None:\n            response = urlfetch.fetch(url=url, payload=data,\n                                      method=method, headers=headers,\n                                      allow_truncated=False, follow_redirects=False,\n                                      deadline=10)\n            # next request will be a get, so no need to send the data again\n            data = None\n            method = urlfetch.GET\n            # load cookies from the response\n            cookie.load(response.headers.get('set-cookie', ''))\n            url = response.headers.get('location')\n        html = response.content\n    return html\n\nregex_geocode = \\\n    re.compile(r\"\"\"<geometry>[\\W]*?<location>[\\W]*?<lat>(?P<la>[^<]*)</lat>[\\W]*?<lng>(?P<lo>[^<]*)</lng>[\\W]*?</location>\"\"\")\n\n\ndef geocode(address):\n    try:\n        a = urllib.quote(address)\n        txt = fetch('http://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s'\n                     % a)\n        item = regex_geocode.search(txt)\n        (la, lo) = (float(item.group('la')), float(item.group('lo')))\n        return (la, lo)\n    except:\n        return (0.0, 0.0)\n\n\ndef reverse_geocode(lat, lng, lang=None):\n    \"\"\" Try to get an approximate address for a given latitude, longitude. \"\"\"\n    if not lang:\n        lang = current.T.accepted_language\n    try:\n        return json_parser.loads(fetch('http://maps.googleapis.com/maps/api/geocode/json?latlng=%(lat)s,%(lng)s&language=%(lang)s' % locals()))['results'][0]['formatted_address']\n    except:\n        return ''\n\n\ndef universal_caller(f, *a, **b):\n    c = f.func_code.co_argcount\n    n = f.func_code.co_varnames[:c]\n\n    defaults = f.func_defaults or []\n    pos_args = n[0:-len(defaults)]\n    named_args = n[-len(defaults):]\n\n    arg_dict = {}\n\n    # Fill the arg_dict with name and value for the submitted, positional values\n    for pos_index, pos_val in enumerate(a[:c]):\n        arg_dict[n[pos_index]] = pos_val    # n[pos_index] is the name of the argument\n\n    # There might be pos_args left, that are sent as named_values. Gather them as well.\n    # If a argument already is populated with values we simply replaces them.\n    for arg_name in pos_args[len(arg_dict):]:\n        if arg_name in b:\n            arg_dict[arg_name] = b[arg_name]\n\n    if len(arg_dict) >= len(pos_args):\n        # All the positional arguments is found. The function may now be called.\n        # However, we need to update the arg_dict with the values from the named arguments as well.\n        for arg_name in named_args:\n            if arg_name in b:\n                arg_dict[arg_name] = b[arg_name]\n\n        return f(**arg_dict)\n\n    # Raise an error, the function cannot be called.\n    raise HTTP(404, \"Object does not exist\")\n\n\nclass Service(object):\n\n    def __init__(self, environment=None):\n        self.run_procedures = {}\n        self.csv_procedures = {}\n        self.xml_procedures = {}\n        self.rss_procedures = {}\n        self.json_procedures = {}\n        self.jsonrpc_procedures = {}\n        self.jsonrpc2_procedures = {}\n        self.xmlrpc_procedures = {}\n        self.amfrpc_procedures = {}\n        self.amfrpc3_procedures = {}\n        self.soap_procedures = {}\n\n    def run(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.run\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/run/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def csv(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.csv\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/csv/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def xml(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.xml\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with::\n\n                wget http://..../app/default/call/xml/myfunction?a=3&b=4\n\n        \"\"\"\n        self.run_procedures[f.__name__] = f\n        return f\n\n    def rss(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.rss\n                def myfunction():\n                    return dict(title=..., link=..., description=...,\n                        created_on=..., entries=[dict(title=..., link=...,\n                            description=..., created_on=...])\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/rss/myfunction\n\n        \"\"\"\n        self.rss_procedures[f.__name__] = f\n        return f\n\n    def json(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.json\n                def myfunction(a, b):\n                    return [{a: b}]\n                def call():\n                    return service()\n\n            Then call it with:;\n\n                wget http://..../app/default/call/json/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.json_procedures[f.__name__] = f\n        return f\n\n    def jsonrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.jsonrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/jsonrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.jsonrpc_procedures[f.__name__] = f\n        return f\n\n    def jsonrpc2(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.jsonrpc2\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget --post-data '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"myfunction\", \"params\": {\"a\": 1, \"b\": 2}}' http://..../app/default/call/jsonrpc2\n\n        \"\"\"\n        self.jsonrpc2_procedures[f.__name__] = f\n        return f\n\n    def xmlrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.xmlrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            The call it with:\n\n                wget http://..../app/default/call/xmlrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.xmlrpc_procedures[f.__name__] = f\n        return f\n\n    def amfrpc(self, f):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.amfrpc\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n\n            Then call it with::\n\n                wget http://..../app/default/call/amfrpc/myfunction?a=hello&b=world\n\n        \"\"\"\n        self.amfrpc_procedures[f.__name__] = f\n        return f\n\n    def amfrpc3(self, domain='default'):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.amfrpc3('domain')\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n            Then call it with:\n\n                wget http://..../app/default/call/amfrpc3/myfunction?a=hello&b=world\n\n        \"\"\"\n        if not isinstance(domain, str):\n            raise SyntaxError(\"AMF3 requires a domain for function\")\n\n        def _amfrpc3(f):\n            if domain:\n                self.amfrpc3_procedures[domain + '.' + f.__name__] = f\n            else:\n                self.amfrpc3_procedures[f.__name__] = f\n            return f\n        return _amfrpc3\n\n    def soap(self, name=None, returns=None, args=None, doc=None):\n        \"\"\"\n        Example:\n            Use as::\n\n                service = Service()\n                @service.soap('MyFunction',returns={'result':int},args={'a':int,'b':int,})\n                def myfunction(a, b):\n                    return a + b\n                def call():\n                    return service()\n\n        Then call it with::\n\n            from gluon.contrib.pysimplesoap.client import SoapClient\n            client = SoapClient(wsdl=\"http://..../app/default/call/soap?WSDL\")\n            response = client.MyFunction(a=1,b=2)\n            return response['result']\n\n        It also exposes online generated documentation and xml example messages\n        at `http://..../app/default/call/soap`\n        \"\"\"\n\n        def _soap(f):\n            self.soap_procedures[name or f.__name__] = f, returns, args, doc\n            return f\n        return _soap\n\n    def serve_run(self, args=None):\n        request = current.request\n        if not args:\n            args = request.args\n        if args and args[0] in self.run_procedures:\n            return str(universal_caller(self.run_procedures[args[0]],\n                                        *args[1:], **dict(request.vars)))\n        self.error()\n\n    def serve_csv(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'text/x-csv'\n        if not args:\n            args = request.args\n\n        def none_exception(value):\n            if isinstance(value, unicode):\n                return value.encode('utf8')\n            if hasattr(value, 'isoformat'):\n                return value.isoformat()[:19].replace('T', ' ')\n            if value is None:\n                return '<NULL>'\n            return value\n        if args and args[0] in self.run_procedures:\n            import types\n            r = universal_caller(self.run_procedures[args[0]],\n                                 *args[1:], **dict(request.vars))\n            s = cStringIO.StringIO()\n            if hasattr(r, 'export_to_csv_file'):\n                r.export_to_csv_file(s)\n            elif r and not isinstance(r, types.GeneratorType) and isinstance(r[0], (dict, Storage)):\n                import csv\n                writer = csv.writer(s)\n                writer.writerow(r[0].keys())\n                for line in r:\n                    writer.writerow([none_exception(v)\n                                     for v in line.values()])\n            else:\n                import csv\n                writer = csv.writer(s)\n                for line in r:\n                    writer.writerow(line)\n            return s.getvalue()\n        self.error()\n\n    def serve_xml(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'text/xml'\n        if not args:\n            args = request.args\n        if args and args[0] in self.run_procedures:\n            s = universal_caller(self.run_procedures[args[0]],\n                                 *args[1:], **dict(request.vars))\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return serializers.xml(s, quote=False)\n        self.error()\n\n    def serve_rss(self, args=None):\n        request = current.request\n        response = current.response\n        if not args:\n            args = request.args\n        if args and args[0] in self.rss_procedures:\n            feed = universal_caller(self.rss_procedures[args[0]],\n                                    *args[1:], **dict(request.vars))\n        else:\n            self.error()\n        response.headers['Content-Type'] = 'application/rss+xml'\n        return serializers.rss(feed)\n\n    def serve_json(self, args=None):\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'application/json; charset=utf-8'\n        if not args:\n            args = request.args\n        d = dict(request.vars)\n        if args and args[0] in self.json_procedures:\n            s = universal_caller(self.json_procedures[args[0]], *args[1:], **d)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return response.json(s)\n        self.error()\n\n    class JsonRpcException(Exception):\n        def __init__(self, code, info):\n            jrpc_error = Service.jsonrpc_errors.get(code)\n            if jrpc_error:\n                self.message, self.description = jrpc_error\n            self.code, self.info = code, info\n\n    # jsonrpc 2.0 error types.  records the following structure {code: (message,meaning)}\n    jsonrpc_errors = {\n        -32700: (\"Parse error. Invalid JSON was received by the server.\",  \"An error occurred on the server while parsing the JSON text.\"),\n        -32600: (\"Invalid Request\", \"The JSON sent is not a valid Request object.\"),\n        -32601: (\"Method not found\", \"The method does not exist / is not available.\"),\n        -32602: (\"Invalid params\", \"Invalid method parameter(s).\"),\n        -32603: (\"Internal error\", \"Internal JSON-RPC error.\"),\n        -32099: (\"Server error\", \"Reserved for implementation-defined server-errors.\")}\n\n    def serve_jsonrpc(self):\n        def return_response(id, result):\n            return serializers.json({'version': '1.1',\n                'id': id, 'result': result, 'error': None})\n\n        def return_error(id, code, message, data=None):\n            error = {'name': 'JSONRPCError',\n                     'code': code, 'message': message}\n            if data is not None:\n                error['data'] = data\n            return serializers.json({'id': id,\n                                     'version': '1.1',\n                                     'error': error,\n                                     })\n\n        request = current.request\n        response = current.response\n        response.headers['Content-Type'] = 'application/json; charset=utf-8'\n        methods = self.jsonrpc_procedures\n        data = json_parser.loads(request.body.read())\n        jsonrpc_2 = data.get('jsonrpc')\n        if jsonrpc_2: #hand over to version 2 of the protocol\n            return self.serve_jsonrpc2(data)\n        id, method, params = data.get('id'), data.get('method'), data.get('params', [])\n        if id is None:\n            return return_error(0, 100, 'missing id')\n        if not method in methods:\n            return return_error(id, 100, 'method \"%s\" does not exist' % method)\n        try:\n            if isinstance(params, dict):\n                s = methods[method](**params)\n            else:\n                s = methods[method](*params)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            return return_response(id, s)\n        except Service.JsonRpcException, e:\n            return return_error(id, e.code, e.info)\n        except:\n            etype, eval, etb = sys.exc_info()\n            message = '%s: %s' % (etype.__name__, eval)\n            data = request.is_local and traceback.format_tb(etb)\n            logger.warning('jsonrpc exception %s\\n%s' % (message, traceback.format_tb(etb)))\n            return return_error(id, 100, message, data)\n\n    def serve_jsonrpc2(self, data=None, batch_element=False):\n\n        def return_response(id, result):\n            if not must_respond:\n                return None\n            return serializers.json({'jsonrpc': '2.0',\n                'id': id, 'result': result})\n\n        def return_error(id, code, message=None, data=None):\n            error = {'code': code}\n            if Service.jsonrpc_errors.has_key(code):\n                error['message'] = Service.jsonrpc_errors[code][0]\n                error['data'] = Service.jsonrpc_errors[code][1]\n            if message is not None:\n                error['message'] = message\n            if data is not None:\n                error['data'] = data\n            return serializers.json({'jsonrpc': '2.0',\n                                     'id': id,\n                                     'error': error})\n\n        def validate(data):\n            \"\"\"\n            Validate request as defined in: http://www.jsonrpc.org/specification#request_object.\n\n            Args:\n                data(str): The json object.\n\n            Returns:\n                - True -- if successful\n                - False -- if no error should be reported (i.e. data is missing 'id' member)\n\n            Raises:\n                JsonRPCException\n\n            \"\"\"\n\n            iparms = set(data.keys())\n            mandatory_args = set(['jsonrpc', 'method'])\n            missing_args = mandatory_args - iparms\n\n            if missing_args:\n                raise Service.JsonRpcException(-32600, 'Missing arguments %s.' % list(missing_args))\n            if data['jsonrpc'] != '2.0':\n                raise Service.JsonRpcException(-32603, 'Unsupported jsonrpc version \"%s\"' % data['jsonrpc'])\n            if 'id' not in iparms:\n                 return False\n\n            return True\n\n        request = current.request\n        response = current.response\n        if not data:\n            response.headers['Content-Type'] = 'application/json; charset=utf-8'\n            try:\n                data = json_parser.loads(request.body.read())\n            except ValueError:  # decoding error in json lib\n                return return_error(None, -32700)\n\n        # Batch handling\n        if isinstance(data, list) and not batch_element:\n            retlist = []\n            for c in data:\n                retstr = self.serve_jsonrpc2(c, batch_element=True)\n                if retstr:  # do not add empty responses\n                    retlist.append(retstr)\n            if len(retlist) == 0:  # return nothing\n                return ''\n            else:\n                return \"[\" + ','.join(retlist) + \"]\"\n        methods = self.jsonrpc2_procedures\n        methods.update(self.jsonrpc_procedures)\n\n        try:\n            must_respond = validate(data)\n        except Service.JsonRpcException, e:\n            return return_error(None, e.code, e.info)\n\n        id, method, params = data.get('id'), data['method'], data.get('params', '')\n        if not method in methods:\n            return return_error(id, -32601, data='Method \"%s\" does not exist' % method)\n        try:\n            if isinstance(params, dict):\n                s = methods[method](**params)\n            else:\n                s = methods[method](*params)\n            if hasattr(s, 'as_list'):\n                s = s.as_list()\n            if must_respond:\n                return return_response(id, s)\n            else:\n                return ''\n        except HTTP, e:\n            raise e\n        except Service.JsonRpcException, e:\n            return return_error(id, e.code, e.info)\n        except:\n            etype, eval, etb = sys.exc_info()\n            data = '%s: %s\\n' % (etype.__name__, eval) + str(request.is_local and traceback.format_tb(etb))\n            logger.warning('%s: %s\\n%s' % (etype.__name__, eval, traceback.format_tb(etb)))\n            return return_error(id, -32099, data=data)\n\n    def serve_xmlrpc(self):\n        request = current.request\n        response = current.response\n        services = self.xmlrpc_procedures.values()\n        return response.xmlrpc(request, services)\n\n    def serve_amfrpc(self, version=0):\n        try:\n            import pyamf\n            import pyamf.remoting.gateway\n        except:\n            return \"pyamf not installed or not in Python sys.path\"\n        request = current.request\n        response = current.response\n        if version == 3:\n            services = self.amfrpc3_procedures\n            base_gateway = pyamf.remoting.gateway.BaseGateway(services)\n            pyamf_request = pyamf.remoting.decode(request.body)\n        else:\n            services = self.amfrpc_procedures\n            base_gateway = pyamf.remoting.gateway.BaseGateway(services)\n            context = pyamf.get_context(pyamf.AMF0)\n            pyamf_request = pyamf.remoting.decode(request.body, context)\n        pyamf_response = pyamf.remoting.Envelope(pyamf_request.amfVersion)\n        for name, message in pyamf_request:\n            pyamf_response[name] = base_gateway.getProcessor(message)(message)\n        response.headers['Content-Type'] = pyamf.remoting.CONTENT_TYPE\n        if version == 3:\n            return pyamf.remoting.encode(pyamf_response).getvalue()\n        else:\n            return pyamf.remoting.encode(pyamf_response, context).getvalue()\n\n    def serve_soap(self, version=\"1.1\"):\n        try:\n            from gluon.contrib.pysimplesoap.server import SoapDispatcher\n        except:\n            return \"pysimplesoap not installed in contrib\"\n        request = current.request\n        response = current.response\n        procedures = self.soap_procedures\n\n        location = \"%s://%s%s\" % (\n                        request.env.wsgi_url_scheme,\n                        request.env.http_host,\n                        URL(r=request, f=\"call/soap\", vars={}))\n        namespace = 'namespace' in response and response.namespace or location\n        documentation = response.description or ''\n        dispatcher = SoapDispatcher(\n            name=response.title,\n            location=location,\n            action=location,  # SOAPAction\n            namespace=namespace,\n            prefix='pys',\n            documentation=documentation,\n            ns=True)\n        for method, (function, returns, args, doc) in procedures.iteritems():\n            dispatcher.register_function(method, function, returns, args, doc)\n        if request.env.request_method == 'POST':\n            fault = {}\n            # Process normal Soap Operation\n            response.headers['Content-Type'] = 'text/xml'\n            xml = dispatcher.dispatch(request.body.read(), fault=fault)\n            if fault:\n                # May want to consider populating a ticket here...\n                response.status = 500\n            # return the soap response\n            return xml\n        elif 'WSDL' in request.vars:\n            # Return Web Service Description\n            response.headers['Content-Type'] = 'text/xml'\n            return dispatcher.wsdl()\n        elif 'op' in request.vars:\n            # Return method help webpage\n            response.headers['Content-Type'] = 'text/html'\n            method = request.vars['op']\n            sample_req_xml, sample_res_xml, doc = dispatcher.help(method)\n            body = [H1(\"Welcome to Web2Py SOAP webservice gateway\"),\n                    A(\"See all webservice operations\",\n                      _href=URL(r=request, f=\"call/soap\", vars={})),\n                    H2(method),\n                    P(doc),\n                    UL(LI(\"Location: %s\" % dispatcher.location),\n                       LI(\"Namespace: %s\" % dispatcher.namespace),\n                       LI(\"SoapAction: %s\" % dispatcher.action),\n                    ),\n                    H3(\"Sample SOAP XML Request Message:\"),\n                    CODE(sample_req_xml, language=\"xml\"),\n                    H3(\"Sample SOAP XML Response Message:\"),\n                    CODE(sample_res_xml, language=\"xml\"),\n                    ]\n            return {'body': body}\n        else:\n            # Return general help and method list webpage\n            response.headers['Content-Type'] = 'text/html'\n            body = [H1(\"Welcome to Web2Py SOAP webservice gateway\"),\n                    P(response.description),\n                    P(\"The following operations are available\"),\n                    A(\"See WSDL for webservice description\",\n                      _href=URL(r=request, f=\"call/soap\", vars={\"WSDL\":None})),\n                    UL([LI(A(\"%s: %s\" % (method, doc or ''),\n                             _href=URL(r=request, f=\"call/soap\", vars={'op': method})))\n                        for method, doc in dispatcher.list_methods()]),\n                    ]\n            return {'body': body}\n\n    def __call__(self):\n        \"\"\"\n        Registers services with::\n\n            service = Service()\n            @service.run\n            @service.rss\n            @service.json\n            @service.jsonrpc\n            @service.xmlrpc\n            @service.amfrpc\n            @service.amfrpc3('domain')\n            @service.soap('Method', returns={'Result':int}, args={'a':int,'b':int,})\n\n        Exposes services with::\n\n            def call():\n                return service()\n\n        You can call services with::\n\n            http://..../app/default/call/run?[parameters]\n            http://..../app/default/call/rss?[parameters]\n            http://..../app/default/call/json?[parameters]\n            http://..../app/default/call/jsonrpc\n            http://..../app/default/call/xmlrpc\n            http://..../app/default/call/amfrpc\n            http://..../app/default/call/amfrpc3\n            http://..../app/default/call/soap\n\n        \"\"\"\n\n        request = current.request\n        if len(request.args) < 1:\n            raise HTTP(404, \"Not Found\")\n        arg0 = request.args(0)\n        if arg0 == 'run':\n            return self.serve_run(request.args[1:])\n        elif arg0 == 'rss':\n            return self.serve_rss(request.args[1:])\n        elif arg0 == 'csv':\n            return self.serve_csv(request.args[1:])\n        elif arg0 == 'xml':\n            return self.serve_xml(request.args[1:])\n        elif arg0 == 'json':\n            return self.serve_json(request.args[1:])\n        elif arg0 == 'jsonrpc':\n            return self.serve_jsonrpc()\n        elif arg0 == 'jsonrpc2':\n            return self.serve_jsonrpc2()\n        elif arg0 == 'xmlrpc':\n            return self.serve_xmlrpc()\n        elif arg0 == 'amfrpc':\n            return self.serve_amfrpc()\n        elif arg0 == 'amfrpc3':\n            return self.serve_amfrpc(3)\n        elif arg0 == 'soap':\n            return self.serve_soap()\n        else:\n            self.error()\n\n    def error(self):\n        raise HTTP(404, \"Object does not exist\")\n\n\ndef completion(callback):\n    \"\"\"\n    Executes a task on completion of the called action.\n\n    Example:\n        Use as::\n\n            from gluon.tools import completion\n            @completion(lambda d: logging.info(repr(d)))\n            def index():\n                return dict(message='hello')\n\n    It logs the output of the function every time input is called.\n    The argument of completion is executed in a new thread.\n    \"\"\"\n    def _completion(f):\n        def __completion(*a, **b):\n            d = None\n            try:\n                d = f(*a, **b)\n                return d\n            finally:\n                thread.start_new_thread(callback, (d,))\n        return __completion\n    return _completion\n\n\ndef prettydate(d, T=lambda x: x):\n    if isinstance(d, datetime.datetime):\n        dt = datetime.datetime.now() - d\n    elif isinstance(d, datetime.date):\n        dt = datetime.date.today() - d\n    elif not d:\n        return ''\n    else:\n        return '[invalid date]'\n    if dt.days < 0:\n        suffix = ' from now'\n        dt = -dt\n    else:\n        suffix = ' ago'\n    if dt.days >= 2 * 365:\n        return T('%d years' + suffix) % int(dt.days / 365)\n    elif dt.days >= 365:\n        return T('1 year' + suffix)\n    elif dt.days >= 60:\n        return T('%d months' + suffix) % int(dt.days / 30)\n    elif dt.days > 21:\n        return T('1 month' + suffix)\n    elif dt.days >= 14:\n        return T('%d weeks' + suffix) % int(dt.days / 7)\n    elif dt.days >= 7:\n        return T('1 week' + suffix)\n    elif dt.days > 1:\n        return T('%d days' + suffix) % dt.days\n    elif dt.days == 1:\n        return T('1 day' + suffix)\n    elif dt.seconds >= 2 * 60 * 60:\n        return T('%d hours' + suffix) % int(dt.seconds / 3600)\n    elif dt.seconds >= 60 * 60:\n        return T('1 hour' + suffix)\n    elif dt.seconds >= 2 * 60:\n        return T('%d minutes' + suffix) % int(dt.seconds / 60)\n    elif dt.seconds >= 60:\n        return T('1 minute' + suffix)\n    elif dt.seconds > 1:\n        return T('%d seconds' + suffix) % dt.seconds\n    elif dt.seconds == 1:\n        return T('1 second' + suffix)\n    else:\n        return T('now')\n\n\ndef test_thread_separation():\n    def f():\n        c = PluginManager()\n        lock1.acquire()\n        lock2.acquire()\n        c.x = 7\n        lock1.release()\n        lock2.release()\n    lock1 = thread.allocate_lock()\n    lock2 = thread.allocate_lock()\n    lock1.acquire()\n    thread.start_new_thread(f, ())\n    a = PluginManager()\n    a.x = 5\n    lock1.release()\n    lock2.acquire()\n    return a.x\n\n\nclass PluginManager(object):\n    \"\"\"\n\n    Plugin Manager is similar to a storage object but it is a single level\n    singleton. This means that multiple instances within the same thread share\n    the same attributes.\n    Its constructor is also special. The first argument is the name of the\n    plugin you are defining.\n    The named arguments are parameters needed by the plugin with default values.\n    If the parameters were previous defined, the old values are used.\n\n    Example:\n        in some general configuration file::\n\n            plugins = PluginManager()\n            plugins.me.param1=3\n\n        within the plugin model::\n\n            _ = PluginManager('me',param1=5,param2=6,param3=7)\n\n        where the plugin is used::\n\n            >>> print plugins.me.param1\n            3\n            >>> print plugins.me.param2\n            6\n            >>> plugins.me.param3 = 8\n            >>> print plugins.me.param3\n            8\n\n        Here are some tests::\n\n            >>> a=PluginManager()\n            >>> a.x=6\n            >>> b=PluginManager('check')\n            >>> print b.x\n            6\n            >>> b=PluginManager() # reset settings\n            >>> print b.x\n            <Storage {}>\n            >>> b.x=7\n            >>> print a.x\n            7\n            >>> a.y.z=8\n            >>> print b.y.z\n            8\n            >>> test_thread_separation()\n            5\n            >>> plugins=PluginManager('me',db='mydb')\n            >>> print plugins.me.db\n            mydb\n            >>> print 'me' in plugins\n            True\n            >>> print plugins.me.installed\n            True\n\n    \"\"\"\n    instances = {}\n\n    def __new__(cls, *a, **b):\n        id = thread.get_ident()\n        lock = thread.allocate_lock()\n        try:\n            lock.acquire()\n            try:\n                return cls.instances[id]\n            except KeyError:\n                instance = object.__new__(cls, *a, **b)\n                cls.instances[id] = instance\n                return instance\n        finally:\n            lock.release()\n\n    def __init__(self, plugin=None, **defaults):\n        if not plugin:\n            self.__dict__.clear()\n        settings = self.__getattr__(plugin)\n        settings.installed = True\n        settings.update(\n            (k, v) for k, v in defaults.items() if not k in settings)\n\n    def __getattr__(self, key):\n        if not key in self.__dict__:\n            self.__dict__[key] = Storage()\n        return self.__dict__[key]\n\n    def keys(self):\n        return self.__dict__.keys()\n\n    def __contains__(self, key):\n        return key in self.__dict__\n\n\nclass Expose(object):\n    def __init__(self, base=None, basename=None, extensions=None, allow_download=True):\n        \"\"\"\n        Examples:\n            Use as::\n\n                def static():\n                    return dict(files=Expose())\n\n            or::\n\n                def static():\n                    path = os.path.join(request.folder,'static','public')\n                    return dict(files=Expose(path,basename='public'))\n\n        Args:\n            extensions: an optional list of file extensions for filtering\n                displayed files: e.g. `['.py', '.jpg']`\n            allow_download: whether to allow downloading selected files\n\n        \"\"\"\n        current.session.forget()\n        base = base or os.path.join(current.request.folder, 'static')\n        basename = basename or current.request.function\n        self.basename = basename\n\n        if current.request.raw_args:\n            self.args = [arg for arg in current.request.raw_args.split('/') if arg]\n        else:\n            self.args = [arg for arg in current.request.args if arg]\n        filename = os.path.join(base, *self.args)\n        if not os.path.exists(filename):\n            raise HTTP(404, \"FILE NOT FOUND\")\n        if not os.path.normpath(filename).startswith(base):\n            raise HTTP(401, \"NOT AUTHORIZED\")\n        if allow_download and not os.path.isdir(filename):\n            current.response.headers['Content-Type'] = contenttype(filename)\n            raise HTTP(200, open(filename, 'rb'), **current.response.headers)\n        self.path = path = os.path.join(filename, '*')\n        self.folders = [f[len(path) - 1:] for f in sorted(glob.glob(path))\n                            if os.path.isdir(f) and not self.isprivate(f)]\n        self.filenames = [f[len(path) - 1:] for f in sorted(glob.glob(path))\n                            if not os.path.isdir(f) and not self.isprivate(f)]\n        if 'README' in self.filenames:\n            readme = open(os.path.join(filename, 'README')).read()\n            self.paragraph = MARKMIN(readme)\n        else:\n            self.paragraph = None\n        if extensions:\n            self.filenames = [f for f in self.filenames\n                              if os.path.splitext(f)[-1] in extensions]\n\n    def breadcrumbs(self, basename):\n        path = []\n        span = SPAN()\n        span.append(A(basename, _href=URL()))\n        for arg in self.args:\n            span.append('/')\n            path.append(arg)\n            span.append(A(arg, _href=URL(args='/'.join(path))))\n        return span\n\n    def table_folders(self):\n        if self.folders:\n            return SPAN(H3('Folders'), TABLE(\n                    *[TR(TD(A(folder, _href=URL(args=self.args + [folder]))))\n                      for folder in self.folders],\n                     **dict(_class=\"table\")))\n        return ''\n\n    @staticmethod\n    def isprivate(f):\n        return 'private' in f or f.startswith('.') or f.endswith('~')\n\n    @staticmethod\n    def isimage(f):\n        return os.path.splitext(f)[-1].lower() in (\n            '.png', '.jpg', '.jpeg', '.gif', '.tiff')\n\n    def table_files(self, width=160):\n        if self.filenames:\n            return SPAN(H3('Files'),\n                        TABLE(*[TR(TD(A(f, _href=URL(args=self.args + [f]))),\n                                   TD(IMG(_src=URL(args=self.args + [f]),\n                                          _style='max-width:%spx' % width)\n                                      if width and self.isimage(f) else ''))\n                                for f in self.filenames],\n                               **dict(_class=\"table\")))\n        return ''\n\n    def xml(self):\n        return DIV(\n            H2(self.breadcrumbs(self.basename)),\n            self.paragraph or '',\n            self.table_folders(),\n            self.table_files()).xml()\n\n\nclass Wiki(object):\n    everybody = 'everybody'\n    rows_page = 25\n\n    def markmin_base(self, body):\n        return MARKMIN(body, extra=self.settings.extra,\n                       url=True, environment=self.env,\n                       autolinks=lambda link: expand_one(link, {})).xml()\n\n    def render_tags(self, tags):\n        return DIV(\n            _class='w2p_wiki_tags',\n            *[A(t.strip(), _href=URL(args='_search', vars=dict(q=t)))\n              for t in tags or [] if t.strip()])\n\n    def markmin_render(self, page):\n        return self.markmin_base(page.body) + self.render_tags(page.tags).xml()\n\n    def html_render(self, page):\n        html = page.body\n        # @///function -> http://..../function\n        html = replace_at_urls(html, URL)\n        # http://...jpg -> <img src=\"http://...jpg/> or embed\n        html = replace_autolinks(html, lambda link: expand_one(link, {}))\n        # @{component:name} -> <script>embed component name</script>\n        html = replace_components(html, self.env)\n        html = html + self.render_tags(page.tags).xml()\n        return html\n\n    @staticmethod\n    def component(text):\n        \"\"\"\n        In wiki docs allows `@{component:controller/function/args}`\n        which renders as a `LOAD(..., ajax=True)`\n        \"\"\"\n        items = text.split('/')\n        controller, function, args = items[0], items[1], items[2:]\n        return LOAD(controller, function, args=args, ajax=True).xml()\n\n    def get_renderer(self):\n        if isinstance(self.settings.render, basestring):\n            r = getattr(self, \"%s_render\" % self.settings.render)\n        elif callable(self.settings.render):\n            r = self.settings.render\n        elif isinstance(self.settings.render, dict):\n            def custom_render(page):\n                if page.render:\n                    if page.render in self.settings.render.keys():\n                        my_render = self.settings.render[page.render]\n                    else:\n                        my_render = getattr(self, \"%s_render\" % page.render)\n                else:\n                    my_render = self.markmin_render\n                return my_render(page)\n            r = custom_render\n        else:\n            raise ValueError(\n                \"Invalid render type %s\" % type(self.settings.render))\n        return r\n\n    def __init__(self, auth, env=None, render='markmin',\n                 manage_permissions=False, force_prefix='',\n                 restrict_search=False, extra=None,\n                 menu_groups=None, templates=None, migrate=True,\n                 controller=None, function=None, groups=None):\n\n        settings = self.settings = auth.settings.wiki\n\n        \"\"\"\n        Args:\n            render:\n\n                - \"markmin\"\n                - \"html\"\n                - `<function>` : Sets a custom render function\n                - `dict(html=<function>, markmin=...)`: dict(...) allows\n                   multiple custom render functions\n                - \"multiple\" : Is the same as `{}`. It enables per-record\n                   formats using builtins\n\n        \"\"\"\n        engines = set(['markmin', 'html'])\n        show_engine = False\n        if render == \"multiple\":\n            render = {}\n        if isinstance(render, dict):\n            [engines.add(key) for key in render]\n            show_engine = True\n        settings.render = render\n        perms = settings.manage_permissions = manage_permissions\n\n        settings.force_prefix = force_prefix\n        settings.restrict_search = restrict_search\n        settings.extra = extra or {}\n        settings.menu_groups = menu_groups\n        settings.templates = templates\n        settings.controller = controller\n        settings.function = function\n        settings.groups = auth.user_groups.values() \\\n            if groups is None else groups\n\n        db = auth.db\n        self.env = env or {}\n        self.env['component'] = Wiki.component\n        self.auth = auth\n        self.wiki_menu_items = None\n\n        if self.auth.user:\n            self.settings.force_prefix = force_prefix % self.auth.user\n        else:\n            self.settings.force_prefix = force_prefix\n\n        self.host = current.request.env.http_host\n\n        table_definitions = [\n            ('wiki_page', {\n                    'args': [\n                        Field('slug',\n                              requires=[IS_SLUG(),\n                                        IS_NOT_IN_DB(db, 'wiki_page.slug')],\n                              writable=False),\n                        Field('title', length=255, unique=True),\n                        Field('body', 'text', notnull=True),\n                        Field('tags', 'list:string'),\n                        Field('can_read', 'list:string',\n                              writable=perms,\n                              readable=perms,\n                              default=[Wiki.everybody]),\n                        Field('can_edit', 'list:string',\n                              writable=perms, readable=perms,\n                              default=[Wiki.everybody]),\n                        Field('changelog'),\n                        Field('html', 'text',\n                              compute=self.get_renderer(),\n                              readable=False, writable=False),\n                        Field('render', default=\"markmin\",\n                              readable=show_engine,\n                              writable=show_engine,\n                              requires=IS_EMPTY_OR(\n                                  IS_IN_SET(engines))),\n                        auth.signature],\n                    'vars': {'format': '%(title)s', 'migrate': migrate}}),\n            ('wiki_tag', {\n                    'args': [\n                        Field('name'),\n                        Field('wiki_page', 'reference wiki_page'),\n                        auth.signature],\n                    'vars':{'format': '%(title)s', 'migrate': migrate}}),\n            ('wiki_media', {\n                    'args': [\n                        Field('wiki_page', 'reference wiki_page'),\n                        Field('title', required=True),\n                        Field('filename', 'upload', required=True),\n                        auth.signature],\n                    'vars': {'format': '%(title)s', 'migrate': migrate}}),\n            ]\n\n        # define only non-existent tables\n        for key, value in table_definitions:\n            args = []\n            if not key in db.tables():\n                # look for wiki_ extra fields in auth.settings\n                extra_fields = auth.settings.extra_fields\n                if extra_fields:\n                    if key in extra_fields:\n                        if extra_fields[key]:\n                            for field in extra_fields[key]:\n                                args.append(field)\n                args += value['args']\n                db.define_table(key, *args, **value['vars'])\n\n        if self.settings.templates is None and not \\\n           self.settings.manage_permissions:\n            self.settings.templates = db.wiki_page.tags.contains('template') & \\\n                db.wiki_page.can_read.contains('everybody')\n\n        def update_tags_insert(page, id, db=db):\n            for tag in page.tags or []:\n                tag = tag.strip().lower()\n                if tag:\n                    db.wiki_tag.insert(name=tag, wiki_page=id)\n\n        def update_tags_update(dbset, page, db=db):\n            page = dbset.select(limitby=(0, 1)).first()\n            db(db.wiki_tag.wiki_page == page.id).delete()\n            for tag in page.tags or []:\n                tag = tag.strip().lower()\n                if tag:\n                    db.wiki_tag.insert(name=tag, wiki_page=page.id)\n        db.wiki_page._after_insert.append(update_tags_insert)\n        db.wiki_page._after_update.append(update_tags_update)\n\n        if (auth.user and\n            check_credentials(current.request, gae_login=False) and\n            not 'wiki_editor' in auth.user_groups.values() and\n            self.settings.groups == auth.user_groups.values()):\n            group = db.auth_group(role='wiki_editor')\n            gid = group.id if group else db.auth_group.insert(\n                role='wiki_editor')\n            auth.add_membership(gid)\n\n        settings.lock_keys = True\n\n    # WIKI ACCESS POLICY\n\n    def not_authorized(self, page=None):\n        raise HTTP(401)\n\n    def can_read(self, page):\n        if 'everybody' in page.can_read or not \\\n            self.settings.manage_permissions:\n            return True\n        elif self.auth.user:\n            groups = self.settings.groups\n            if ('wiki_editor' in groups or\n                set(groups).intersection(set(page.can_read + page.can_edit)) or\n                page.created_by == self.auth.user.id):\n                return True\n        return False\n\n    def can_edit(self, page=None):\n        if not self.auth.user:\n            redirect(self.auth.settings.login_url)\n        groups = self.settings.groups\n        return ('wiki_editor' in groups or\n                (page is None and 'wiki_author' in groups) or\n                not page is None and (\n                set(groups).intersection(set(page.can_edit)) or\n                page.created_by == self.auth.user.id))\n\n    def can_manage(self):\n        if not self.auth.user:\n            return False\n        groups = self.settings.groups\n        return 'wiki_editor' in groups\n\n    def can_search(self):\n        return True\n\n    def can_see_menu(self):\n        if self.auth.user:\n            if self.settings.menu_groups is None:\n                return True\n            else:\n                groups = self.settings.groups\n                if any(t in self.settings.menu_groups for t in groups):\n                    return True\n        return False\n\n    ### END POLICY\n\n    def automenu(self):\n        \"\"\"adds the menu if not present\"\"\"\n        if (not self.wiki_menu_items and\n            self.settings.controller and\n            self.settings.function):\n            self.wiki_menu_items = self.menu(self.settings.controller,\n                                             self.settings.function)\n            current.response.menu += self.wiki_menu_items\n\n    def __call__(self):\n        request = current.request\n        settings = self.settings\n        settings.controller = settings.controller or request.controller\n        settings.function = settings.function or request.function\n        self.automenu()\n\n        zero = request.args(0) or 'index'\n        if zero and zero.isdigit():\n            return self.media(int(zero))\n        elif not zero or not zero.startswith('_'):\n            return self.read(zero)\n        elif zero == '_edit':\n            return self.edit(request.args(1) or 'index', request.args(2) or 0)\n        elif zero == '_editmedia':\n            return self.editmedia(request.args(1) or 'index')\n        elif zero == '_create':\n            return self.create()\n        elif zero == '_pages':\n            return self.pages()\n        elif zero == '_search':\n            return self.search()\n        elif zero == '_recent':\n            ipage = int(request.vars.page or 0)\n            query = self.auth.db.wiki_page.created_by == request.args(\n                1, cast=int)\n            return self.search(query=query,\n                               orderby=~self.auth.db.wiki_page.created_on,\n                               limitby=(ipage * self.rows_page,\n                                        (ipage + 1) * self.rows_page),\n                               )\n        elif zero == '_cloud':\n            return self.cloud()\n        elif zero == '_preview':\n            return self.preview(self.get_renderer())\n\n    def first_paragraph(self, page):\n        if not self.can_read(page):\n            mm = (page.body or '').replace('\\r', '')\n            ps = [p for p in mm.split('\\n\\n')\n                      if not p.startswith('#') and p.strip()]\n            if ps:\n                return ps[0]\n        return ''\n\n    def fix_hostname(self, body):\n        return (body or '').replace('://HOSTNAME', '://%s' % self.host)\n\n    def read(self, slug, force_render=False):\n        if slug in '_cloud':\n            return self.cloud()\n        elif slug in '_search':\n            return self.search()\n        page = self.auth.db.wiki_page(slug=slug)\n        if page and (not self.can_read(page)):\n            return self.not_authorized(page)\n        if current.request.extension == 'html':\n            if not page:\n                url = URL(args=('_create', slug))\n                return dict(content=A('Create page \"%s\"' % slug, _href=url, _class=\"btn\"))\n            else:\n                html = page.html if not force_render else self.get_renderer()(page)\n                content = XML(self.fix_hostname(html))\n                return dict(title=page.title,\n                            slug=page.slug,\n                            page=page,\n                            content=content,\n                            tags=page.tags,\n                            created_on=page.created_on,\n                            modified_on=page.modified_on)\n        elif current.request.extension == 'load':\n            return self.fix_hostname(page.html) if page else ''\n        else:\n            if not page:\n                raise HTTP(404)\n            else:\n                return dict(title=page.title,\n                            slug=page.slug,\n                            page=page,\n                            content=page.body,\n                            tags=page.tags,\n                            created_on=page.created_on,\n                            modified_on=page.modified_on)\n\n    def edit(self, slug, from_template=0):\n        auth = self.auth\n        db = auth.db\n        page = db.wiki_page(slug=slug)\n        if not self.can_edit(page):\n            return self.not_authorized(page)\n        title_guess = ' '.join(c.capitalize() for c in slug.split('-'))\n        if not page:\n            if not (self.can_manage() or\n                    slug.startswith(self.settings.force_prefix)):\n                current.session.flash = 'slug must have \"%s\" prefix' \\\n                    % self.settings.force_prefix\n                redirect(URL(args=('_create')))\n            db.wiki_page.can_read.default = [Wiki.everybody]\n            db.wiki_page.can_edit.default = [auth.user_group_role()]\n            db.wiki_page.title.default = title_guess\n            db.wiki_page.slug.default = slug\n            if slug == 'wiki-menu':\n                db.wiki_page.body.default = \\\n                    '- Menu Item > @////index\\n- - Submenu > http://web2py.com'\n            else:\n                db.wiki_page.body.default = db(db.wiki_page.id == from_template).select(db.wiki_page.body)[0].body \\\n                    if int(from_template) > 0 else '## %s\\n\\npage content' % title_guess\n        vars = current.request.post_vars\n        if vars.body:\n            vars.body = vars.body.replace('://%s' % self.host, '://HOSTNAME')\n        form = SQLFORM(db.wiki_page, page, deletable=True,\n                       formstyle='table2cols', showid=False).process()\n        if form.deleted:\n            current.session.flash = 'page deleted'\n            redirect(URL())\n        elif form.accepted:\n            current.session.flash = 'page created'\n            redirect(URL(args=slug))\n        script = \"\"\"\n        jQuery(function() {\n            if (!jQuery('#wiki_page_body').length) return;\n            var pagecontent = jQuery('#wiki_page_body');\n            pagecontent.css('font-family',\n                            'Monaco,Menlo,Consolas,\"Courier New\",monospace');\n            var prevbutton = jQuery('<button class=\"btn nopreview\">Preview</button>');\n            var preview = jQuery('<div id=\"preview\"></div>').hide();\n            var previewmedia = jQuery('<div id=\"previewmedia\"></div>');\n            var form = pagecontent.closest('form');\n            preview.insertBefore(form);\n            prevbutton.insertBefore(form);\n            if(%(link_media)s) {\n              var mediabutton = jQuery('<button class=\"btn nopreview\">Media</button>');\n              mediabutton.insertBefore(form);\n              previewmedia.insertBefore(form);\n              mediabutton.click(function() {\n                if (mediabutton.hasClass('nopreview')) {\n                    web2py_component('%(urlmedia)s', 'previewmedia');\n                } else {\n                    previewmedia.empty();\n                }\n                mediabutton.toggleClass('nopreview');\n              });\n            }\n            prevbutton.click(function(e) {\n                e.preventDefault();\n                if (prevbutton.hasClass('nopreview')) {\n                    prevbutton.addClass('preview').removeClass(\n                        'nopreview').html('Edit Source');\n                    try{var wiki_render = jQuery('#wiki_page_render').val()}\n                    catch(e){var wiki_render = null;}\n                    web2py_ajax_page('post', \\\n                        '%(url)s', {body: jQuery('#wiki_page_body').val(), \\\n                                    render: wiki_render}, 'preview');\n                    form.fadeOut('fast', function() {preview.fadeIn()});\n                } else {\n                    prevbutton.addClass(\n                        'nopreview').removeClass('preview').html('Preview');\n                    preview.fadeOut('fast', function() {form.fadeIn()});\n                }\n            })\n        })\n        \"\"\" % dict(url=URL(args=('_preview', slug)), link_media=('true' if page else 'false'),\n                   urlmedia=URL(extension='load',\n                                args=('_editmedia', slug),\n                                vars=dict(embedded=1)))\n        return dict(content=TAG[''](form, SCRIPT(script)))\n\n    def editmedia(self, slug):\n        auth = self.auth\n        db = auth.db\n        page = db.wiki_page(slug=slug)\n        if not (page and self.can_edit(page)):\n            return self.not_authorized(page)\n        self.auth.db.wiki_media.id.represent = lambda id, row: \\\n            id if not row.filename else \\\n            SPAN('@////%i/%s.%s' % (id, IS_SLUG.urlify(row.title.split('.')[0]), row.filename.split('.')[-1]))\n        self.auth.db.wiki_media.wiki_page.default = page.id\n        self.auth.db.wiki_media.wiki_page.writable = False\n        links = []\n        csv = True\n        create = True\n        if current.request.vars.embedded:\n            script = \"var c = jQuery('#wiki_page_body'); c.val(c.val() + jQuery('%s').text()); return false;\"\n            fragment = self.auth.db.wiki_media.id.represent\n            csv = False\n            create = False\n            links= [\n                lambda row:\n                    A('copy into source', _href='#', _onclick=script % (fragment(row.id, row)))\n                    ]\n        content = SQLFORM.grid(\n            self.auth.db.wiki_media.wiki_page == page.id,\n            orderby=self.auth.db.wiki_media.title,\n            links=links,\n            csv=csv,\n            create=create,\n            args=['_editmedia', slug],\n            user_signature=False)\n        return dict(content=content)\n\n    def create(self):\n        if not self.can_edit():\n            return self.not_authorized()\n        db = self.auth.db\n        slugs = db(db.wiki_page.id > 0).select(db.wiki_page.id, db.wiki_page.slug)\n        options = [OPTION(row.slug, _value=row.id) for row in slugs]\n        options.insert(0, OPTION('', _value=''))\n        fields = [Field(\"slug\", default=current.request.args(1) or\n                        self.settings.force_prefix,\n                        requires=(IS_SLUG(), IS_NOT_IN_DB(db, db.wiki_page.slug))),]\n        if self.settings.templates:\n            fields.append(\n                Field(\"from_template\", \"reference wiki_page\",\n                      requires=IS_EMPTY_OR(\n                                   IS_IN_DB(db(self.settings.templates),\n                                            db.wiki_page._id,\n                                            '%(slug)s')),\n                      comment=current.T(\n                        \"Choose Template or empty for new Page\")))\n        form = SQLFORM.factory(*fields, **dict(_class=\"well\"))\n        form.element(\"[type=submit]\").attributes[\"_value\"] = \\\n            current.T(\"Create Page from Slug\")\n\n        if form.process().accepted:\n             form.vars.from_template = 0 if not form.vars.from_template \\\n                 else form.vars.from_template\n             redirect(URL(args=('_edit', form.vars.slug, form.vars.from_template or 0)))  # added param\n        return dict(content=form)\n\n    def pages(self):\n        if not self.can_manage():\n            return self.not_authorized()\n        self.auth.db.wiki_page.slug.represent = lambda slug, row: SPAN(\n            '@////%s' % slug)\n        self.auth.db.wiki_page.title.represent = lambda title, row: \\\n            A(title, _href=URL(args=row.slug))\n        wiki_table = self.auth.db.wiki_page\n        content = SQLFORM.grid(\n            wiki_table,\n            fields=[wiki_table.slug,\n                    wiki_table.title, wiki_table.tags,\n                    wiki_table.can_read, wiki_table.can_edit],\n            links=[\n                lambda row:\n                    A('edit', _href=URL(args=('_edit', row.slug)), _class='btn'),\n                lambda row:\n                    A('media', _href=URL(args=('_editmedia', row.slug)), _class='btn')],\n            details=False, editable=False, deletable=False, create=False,\n            orderby=self.auth.db.wiki_page.title,\n            args=['_pages'],\n            user_signature=False)\n\n        return dict(content=content)\n\n    def media(self, id):\n        request, response, db = current.request, current.response, self.auth.db\n        media = db.wiki_media(id)\n        if media:\n            if self.settings.manage_permissions:\n                page = db.wiki_page(media.wiki_page)\n                if not self.can_read(page):\n                    return self.not_authorized(page)\n            request.args = [media.filename]\n            m = response.download(request, db)\n            current.session.forget()  # get rid of the cookie\n            response.headers['Last-Modified'] = \\\n                request.utcnow.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n            if 'Content-Disposition' in response.headers:\n                del response.headers['Content-Disposition']\n            response.headers['Pragma'] = 'cache'\n            response.headers['Cache-Control'] = 'private'\n            return m\n        else:\n            raise HTTP(404)\n\n    def menu(self, controller='default', function='index'):\n        db = self.auth.db\n        request = current.request\n        menu_page = db.wiki_page(slug='wiki-menu')\n        menu = []\n        if menu_page:\n            tree = {'': menu}\n            regex = re.compile('[\\r\\n\\t]*(?P<base>(\\s*\\-\\s*)+)(?P<title>\\w.*?)\\s+\\>\\s+(?P<link>\\S+)')\n            for match in regex.finditer(self.fix_hostname(menu_page.body)):\n                base = match.group('base').replace(' ', '')\n                title = match.group('title')\n                link = match.group('link')\n                title_page = None\n                if link.startswith('@'):\n                    items = link[2:].split('/')\n                    if len(items) > 3:\n                        title_page = items[3]\n                        link = URL(a=items[0] or None, c=items[1] or controller,\n                                   f=items[2] or function, args=items[3:])\n                parent = tree.get(base[1:], tree[''])\n                subtree = []\n                tree[base] = subtree\n                parent.append((current.T(title),\n                               request.args(0) == title_page,\n                               link, subtree))\n        if self.can_see_menu():\n            submenu = []\n            menu.append((current.T('[Wiki]'), None, None, submenu))\n            if URL() == URL(controller, function):\n                if not str(request.args(0)).startswith('_'):\n                    slug = request.args(0) or 'index'\n                    mode = 1\n                elif request.args(0) == '_edit':\n                    slug = request.args(1) or 'index'\n                    mode = 2\n                elif request.args(0) == '_editmedia':\n                    slug = request.args(1) or 'index'\n                    mode = 3\n                else:\n                    mode = 0\n                if mode in (2, 3):\n                    submenu.append((current.T('View Page'), None,\n                    URL(controller, function, args=slug)))\n                if mode in (1, 3):\n                    submenu.append((current.T('Edit Page'), None,\n                    URL(controller, function, args=('_edit', slug))))\n                if mode in (1, 2):\n                    submenu.append((current.T('Edit Page Media'), None,\n                    URL(controller, function, args=('_editmedia', slug))))\n\n            submenu.append((current.T('Create New Page'), None,\n                            URL(controller, function, args=('_create'))))\n            # Moved next if to inside self.auth.user check\n            if self.can_manage():\n                submenu.append((current.T('Manage Pages'), None,\n                            URL(controller, function, args=('_pages'))))\n                submenu.append((current.T('Edit Menu'), None,\n                            URL(controller, function, args=('_edit', 'wiki-menu'))))\n            # Also moved inside self.auth.user check\n            submenu.append((current.T('Search Pages'), None,\n                        URL(controller, function, args=('_search'))))\n        return menu\n\n    def search(self, tags=None, query=None, cloud=True, preview=True,\n               limitby=(0, 100), orderby=None):\n        if not self.can_search():\n            return self.not_authorized()\n        request = current.request\n        content = CAT()\n        if tags is None and query is None:\n            form = FORM(INPUT(_name='q', requires=IS_NOT_EMPTY(),\n                              value=request.vars.q),\n                        INPUT(_type=\"submit\", _value=current.T('Search')),\n                        _method='GET')\n            content.append(DIV(form, _class='w2p_wiki_form'))\n            if request.vars.q:\n                tags = [v.strip() for v in request.vars.q.split(',')]\n                tags = [v.lower() for v in tags if v]\n        if tags or not query is None:\n            db = self.auth.db\n            count = db.wiki_tag.wiki_page.count()\n            fields = [db.wiki_page.id, db.wiki_page.slug,\n                      db.wiki_page.title, db.wiki_page.tags,\n                      db.wiki_page.can_read]\n            if preview:\n                fields.append(db.wiki_page.body)\n            if query is None:\n                query = (db.wiki_page.id == db.wiki_tag.wiki_page) &\\\n                    (db.wiki_tag.name.belongs(tags))\n                query = query | db.wiki_page.title.contains(request.vars.q)\n            if self.settings.restrict_search and not self.manage():\n                query = query & (db.wiki_page.created_by == self.auth.user_id)\n            pages = db(query).select(count,\n                                     *fields, **dict(orderby=orderby or ~count,\n                                                     groupby=reduce(lambda a, b: a | b, fields),\n                                                     distinct=True,\n                                                     limitby=limitby))\n            if request.extension in ('html', 'load'):\n                if not pages:\n                    content.append(DIV(current.T(\"No results\"),\n                                       _class='w2p_wiki_form'))\n\n                def link(t):\n                    return A(t, _href=URL(args='_search', vars=dict(q=t)))\n                items = [DIV(H3(A(p.wiki_page.title, _href=URL(\n                                    args=p.wiki_page.slug))),\n                             MARKMIN(self.first_paragraph(p.wiki_page))\n                                 if preview else '',\n                             DIV(_class='w2p_wiki_tags',\n                                 *[link(t.strip()) for t in\n                                       p.wiki_page.tags or [] if t.strip()]),\n                             _class='w2p_wiki_search_item')\n                         for p in pages]\n                content.append(DIV(_class='w2p_wiki_pages', *items))\n            else:\n                cloud = False\n                content = [p.wiki_page.as_dict() for p in pages]\n        elif cloud:\n            content.append(self.cloud()['content'])\n        if request.extension == 'load':\n            return content\n        return dict(content=content)\n\n    def cloud(self):\n        db = self.auth.db\n        count = db.wiki_tag.wiki_page.count(distinct=True)\n        ids = db(db.wiki_tag).select(\n            db.wiki_tag.name, count,\n            distinct=True,\n            groupby=db.wiki_tag.name,\n            orderby=~count, limitby=(0, 20))\n        if ids:\n            a, b = ids[0](count), ids[-1](count)\n\n        def style(c):\n            STYLE = 'padding:0 0.2em;line-height:%.2fem;font-size:%.2fem'\n            size = (1.5 * (c - b) / max(a - b, 1) + 1.3)\n            return STYLE % (1.3, size)\n        items = []\n        for item in ids:\n            items.append(A(item.wiki_tag.name,\n                           _style=style(item(count)),\n                           _href=URL(args='_search',\n                                     vars=dict(q=item.wiki_tag.name))))\n            items.append(' ')\n        return dict(content=DIV(_class='w2p_cloud', *items))\n\n    def preview(self, render):\n        request = current.request\n        # FIXME: This is an ugly hack to ensure a default render\n        # engine if not specified (with multiple render engines)\n        if not \"render\" in request.post_vars:\n            request.post_vars.render = None\n        return render(request.post_vars)\n\n\nclass Config(object):\n    def __init__(\n        self,\n        filename,\n        section,\n        default_values={}\n    ):\n        self.config = ConfigParser.ConfigParser(default_values)\n        self.config.read(filename)\n        if not self.config.has_section(section):\n            self.config.add_section(section)\n        self.section  = section\n        self.filename = filename\n\n    def read(self):\n        if not(isinstance(current.session['settings_%s' % self.section], dict)):\n            settings = dict(self.config.items(self.section))\n        else:\n            settings = current.session['settings_%s' % self.section]\n        return settings\n\n    def save(self, options):\n        for option, value in options:\n            self.config.set(self.section, option, value)\n        try:\n            self.config.write(open(self.filename, 'w'))\n            result = True\n        except:\n            current.session['settings_%s' % self.section] = dict(self.config.items(self.section))\n            result = False\n        return result\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n"], "filenames": [".gitignore", "gluon/tools.py"], "buggy_code_start_loc": [60, 1543], "buggy_code_end_loc": [60, 2520], "fixing_code_start_loc": [61, 1544], "fixing_code_end_loc": [62, 2521], "type": "CWE-601", "message": "Open redirect vulnerability in gluon/tools.py in Web2py 2.9.11 allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the _next parameter to user/logout.", "other": {"cve": {"id": "CVE-2015-6961", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-18T20:29:00.387", "lastModified": "2017-10-31T22:09:30.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open redirect vulnerability in gluon/tools.py in Web2py 2.9.11 allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the _next parameter to user/logout."}, {"lang": "es", "value": "Una vulnerabilidad de redirecci\u00f3n abierta en gluon/tools.py en Web2py 2.9.11 permite que atacantes remotos redirijan a los usuarios a sitios web arbitrarios y lleven a cabo ataques de phishing mediante una URL en el par\u00e1metro _next en user/logout."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:web2py:web2py:2.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "6E9C27B2-82C3-482B-8B43-A8F35638CC07"}]}]}], "references": [{"url": "https://github.com/web2py/web2py/commit/e31a099cb3456fef471886339653430ae59056b0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/web2py/web2py/issues/731", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/web2py/web2py/commit/e31a099cb3456fef471886339653430ae59056b0"}}