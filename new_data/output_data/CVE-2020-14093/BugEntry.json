{"buggy_code": ["/*\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n *\n *     This program is free software; you can redistribute it and/or modify\n *     it under the terms of the GNU General Public License as published by\n *     the Free Software Foundation; either version 2 of the License, or\n *     (at your option) any later version.\n *\n *     This program is distributed in the hope that it will be useful,\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *     GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with this program; if not, write to the Free Software\n *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n/* Support for IMAP4rev1, with the occasional nod to IMAP 4. */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"mutt.h\"\n#include \"mx.h\"\n#include \"mailbox.h\"\n#include \"globals.h\"\n#include \"sort.h\"\n#include \"browser.h\"\n#include \"imap_private.h\"\n#if defined(USE_SSL)\n# include \"mutt_ssl.h\"\n#endif\n#if defined(USE_ZLIB)\n# include \"mutt_zstrm.h\"\n#endif\n#include \"buffy.h\"\n#if USE_HCACHE\n#include \"hcache.h\"\n#endif\n\n#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n/* imap forward declarations */\nstatic char* imap_get_flags (LIST** hflags, char* s);\nstatic int imap_check_capabilities (IMAP_DATA* idata);\nstatic void imap_set_flag (IMAP_DATA* idata, int aclbit, int flag,\n\t\t\t   const char* str, char* flags, size_t flsize);\n\n/* imap_access: Check permissions on an IMAP mailbox.\n * TODO: ACL checks. Right now we assume if it exists we can\n *       mess with it. */\nint imap_access (const char* path)\n{\n  IMAP_DATA* idata;\n  IMAP_MBOX mx;\n  char buf[LONG_STRING*2];\n  char mailbox[LONG_STRING];\n  char mbox[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path (path, &mx))\n    return -1;\n\n  if (!(idata = imap_conn_find (&mx.account,\n                                option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));\n  if (!*mailbox)\n    strfcpy (mailbox, \"INBOX\", sizeof (mailbox));\n\n  /* we may already be in the folder we're checking */\n  if (!ascii_strcmp(idata->mailbox, mx.mbox))\n  {\n    FREE (&mx.mbox);\n    return 0;\n  }\n  FREE (&mx.mbox);\n\n  if (imap_mboxcache_get (idata, mailbox, 0))\n  {\n    dprint (3, (debugfile, \"imap_access: found %s in cache\\n\", mailbox));\n    return 0;\n  }\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mailbox);\n\n  if (mutt_bit_isset (idata->capabilities, IMAP4REV1))\n    snprintf (buf, sizeof (buf), \"STATUS %s (UIDVALIDITY)\", mbox);\n  else if (mutt_bit_isset (idata->capabilities, STATUS))\n    snprintf (buf, sizeof (buf), \"STATUS %s (UID-VALIDITY)\", mbox);\n  else\n  {\n    dprint (2, (debugfile, \"imap_access: STATUS not supported?\\n\"));\n    return -1;\n  }\n\n  if ((rc = imap_exec (idata, buf, IMAP_CMD_FAIL_OK)) < 0)\n  {\n    dprint (1, (debugfile, \"imap_access: Can't check STATUS of %s\\n\", mbox));\n    return rc;\n  }\n\n  return 0;\n}\n\nint imap_create_mailbox (IMAP_DATA* idata, char* mailbox)\n{\n  char buf[LONG_STRING*2], mbox[LONG_STRING];\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mailbox);\n  snprintf (buf, sizeof (buf), \"CREATE %s\", mbox);\n\n  if (imap_exec (idata, buf, 0) != 0)\n  {\n    mutt_error (_(\"CREATE failed: %s\"), imap_cmd_trailer (idata));\n    return -1;\n  }\n\n  return 0;\n}\n\nint imap_rename_mailbox (IMAP_DATA* idata, IMAP_MBOX* mx, const char* newname)\n{\n  char oldmbox[LONG_STRING];\n  char newmbox[LONG_STRING];\n  BUFFER *b;\n  int rc = 0;\n\n  imap_munge_mbox_name (idata, oldmbox, sizeof (oldmbox), mx->mbox);\n  imap_munge_mbox_name (idata, newmbox, sizeof (newmbox), newname);\n\n  b = mutt_buffer_pool_get ();\n  mutt_buffer_printf (b, \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec (idata, mutt_b2s (b), 0) != 0)\n    rc = -1;\n\n  mutt_buffer_pool_release (&b);\n\n  return rc;\n}\n\nint imap_delete_mailbox (CONTEXT* ctx, IMAP_MBOX mx)\n{\n  char buf[LONG_STRING*2], mbox[LONG_STRING];\n  IMAP_DATA *idata;\n\n  if (!ctx || !ctx->data)\n  {\n    if (!(idata = imap_conn_find (&mx.account,\n                                  option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n    {\n      FREE (&mx.mbox);\n      return -1;\n    }\n  }\n  else\n  {\n    idata = ctx->data;\n  }\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mx.mbox);\n  snprintf (buf, sizeof (buf), \"DELETE %s\", mbox);\n\n  if (imap_exec ((IMAP_DATA*) idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* imap_logout_all: close all open connections. Quick and dirty until we can\n *   make sure we've got all the context we need. */\nvoid imap_logout_all (void)\n{\n  CONNECTION* conn;\n  CONNECTION* tmp;\n\n  conn = mutt_socket_head ();\n\n  while (conn)\n  {\n    tmp = conn->next;\n\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP && conn->fd >= 0)\n    {\n      mutt_message (_(\"Closing connection to %s...\"), conn->account.host);\n      imap_logout ((IMAP_DATA**) (void*) &conn->data);\n      mutt_clear_error ();\n      mutt_socket_free (conn);\n    }\n\n    conn = tmp;\n  }\n}\n\n/* imap_read_literal: read bytes bytes from server into file. Not explicitly\n *   buffered, relies on FILE buffering. NOTE: strips \\r from \\r\\n.\n *   Apparently even literals use \\r\\n-terminated strings ?! */\nint imap_read_literal (FILE* fp, IMAP_DATA* idata, unsigned int bytes, progress_t* pbar)\n{\n  unsigned int pos;\n  char c;\n\n  int r = 0;\n\n  dprint (2, (debugfile, \"imap_read_literal: reading %ld bytes\\n\", bytes));\n\n  for (pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar (idata->conn, &c) != 1)\n    {\n      dprint (1, (debugfile, \"imap_read_literal: error during read, %ld bytes read\\n\", pos));\n      idata->status = IMAP_FATAL;\n\n      return -1;\n    }\n\n#if 1\n    if (r == 1 && c != '\\n')\n      fputc ('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = 1;\n      continue;\n    }\n    else\n      r = 0;\n#endif\n    fputc (c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update (pbar, pos, -1);\n#ifdef DEBUG\n    if (debuglevel >= IMAP_LOG_LTRL)\n      fputc (c, debugfile);\n#endif\n  }\n\n  return 0;\n}\n\n/* imap_expunge_mailbox: Purge IMAP portion of expunged messages from the\n *   context. Must not be done while something has a handle on any headers\n *   (eg inside pager or editor). That is, check IMAP_REOPEN_ALLOW. */\nvoid imap_expunge_mailbox (IMAP_DATA* idata)\n{\n  HEADER* h;\n  int i, cacheno;\n  short old_sort;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n\n  old_sort = Sort;\n  Sort = SORT_ORDER;\n  mutt_sort_headers (idata->ctx, 0);\n\n  for (i = 0; i < idata->ctx->msgcount; i++)\n  {\n    h = idata->ctx->hdrs[i];\n\n    if (h->index == INT_MAX)\n    {\n      dprint (2, (debugfile, \"Expunging message UID %u.\\n\", HEADER_DATA (h)->uid));\n\n      h->active = 0;\n      idata->ctx->size -= h->content->length;\n\n      imap_cache_del (idata, h);\n#if USE_HCACHE\n      imap_hcache_del (idata, HEADER_DATA(h)->uid);\n#endif\n\n      /* free cached body from disk, if necessary */\n      cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n      if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&\n\t  idata->cache[cacheno].path)\n      {\n\tunlink (idata->cache[cacheno].path);\n\tFREE (&idata->cache[cacheno].path);\n      }\n\n      int_hash_delete (idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);\n\n      imap_free_header_data ((IMAP_HEADER_DATA**)&h->data);\n    }\n    else\n    {\n      h->index = i;\n      /* Mutt has several places where it turns off h->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The mx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.\n       */\n      h->active = 1;\n    }\n  }\n\n#if USE_HCACHE\n  imap_hcache_close (idata);\n#endif\n\n  /* We may be called on to expunge at any time. We can't rely on the caller\n   * to always know to rethread */\n  mx_update_tables (idata->ctx, 0);\n  Sort = old_sort;\n  mutt_sort_headers (idata->ctx, 1);\n}\n\n/* imap_check_capabilities: make sure we can log in to this server. */\nstatic int imap_check_capabilities (IMAP_DATA* idata)\n{\n  if (imap_exec (idata, \"CAPABILITY\", 0) != 0)\n  {\n    imap_error (\"imap_check_capabilities\", idata->buf);\n    return -1;\n  }\n\n  if (!(mutt_bit_isset(idata->capabilities,IMAP4) ||\n        mutt_bit_isset(idata->capabilities,IMAP4REV1)))\n  {\n    mutt_error _(\"This IMAP server is ancient. Mutt does not work with it.\");\n    mutt_sleep (2);\t/* pause a moment to let the user see the error */\n\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_conn_find\n *\n * Returns an authenticated IMAP connection matching account, or NULL\n * if that isn't possible.\n *\n * flags:\n *   MUTT_IMAP_CONN_NONEW    - must be an existing connection\n *   MUTT_IMAP_CONN_NOSELECT - must not be in the IMAP_SELECTED state.\n */\nIMAP_DATA* imap_conn_find (const ACCOUNT* account, int flags)\n{\n  CONNECTION* conn = NULL;\n  ACCOUNT* creds = NULL;\n  IMAP_DATA* idata = NULL;\n  int new = 0;\n\n  while ((conn = mutt_conn_find (conn, account)))\n  {\n    if (!creds)\n      creds = &conn->account;\n    else\n      memcpy (&conn->account, creds, sizeof (ACCOUNT));\n\n    idata = (IMAP_DATA*)conn->data;\n    if (flags & MUTT_IMAP_CONN_NONEW)\n    {\n      if (!idata)\n      {\n        /* This should only happen if we've come to the end of the list */\n        mutt_socket_free (conn);\n        return NULL;\n      }\n      else if (idata->state < IMAP_AUTHENTICATED)\n        continue;\n    }\n    if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)\n      continue;\n    if (idata && idata->status == IMAP_FATAL)\n      continue;\n    break;\n  }\n  if (!conn)\n    return NULL; /* this happens when the initial connection fails */\n\n  /* The current connection is a new connection */\n  if (!idata)\n  {\n    idata = imap_new_idata ();\n    conn->data = idata;\n    idata->conn = conn;\n    new = 1;\n  }\n\n  if (idata->state == IMAP_DISCONNECTED)\n    imap_open_connection (idata);\n  if (idata->state == IMAP_CONNECTED)\n  {\n    if (!imap_authenticate (idata))\n    {\n      idata->state = IMAP_AUTHENTICATED;\n      FREE (&idata->capstr);\n      new = 1;\n      if (idata->conn->ssf)\n\tdprint (2, (debugfile, \"Communication encrypted at %d bits\\n\",\n\t\t    idata->conn->ssf));\n    }\n    else\n      mutt_account_unsetpass (&idata->conn->account);\n  }\n  if (new && idata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec (idata, \"CAPABILITY\", IMAP_CMD_FAIL_OK);\n\n#if defined(USE_ZLIB)\n    /* RFC 4978 */\n    if (mutt_bit_isset (idata->capabilities, COMPRESS_DEFLATE))\n    {\n      if (option (OPTIMAPDEFLATE) &&\n\t  imap_exec (idata, \"COMPRESS DEFLATE\", IMAP_CMD_FAIL_OK) == 0)\n\tmutt_zstrm_wrap_conn (idata->conn);\n    }\n#endif\n\n    /* enable RFC6855, if the server supports that */\n    if (mutt_bit_isset (idata->capabilities, ENABLE))\n      imap_exec (idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n\n    /* enable QRESYNC.  Advertising QRESYNC also means CONDSTORE\n     * is supported (even if not advertised), so flip that bit. */\n    if (mutt_bit_isset (idata->capabilities, QRESYNC))\n    {\n      mutt_bit_set (idata->capabilities, CONDSTORE);\n      if (option (OPTIMAPQRESYNC))\n        imap_exec (idata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);\n    }\n\n    /* get root delimiter, '/' as default */\n    idata->delim = '/';\n    imap_exec (idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n    if (option (OPTIMAPCHECKSUBSCRIBED))\n      imap_exec (idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec (idata, NULL, IMAP_CMD_FAIL_OK);\n  }\n\n  if (idata->state < IMAP_AUTHENTICATED)\n    return NULL;\n\n  return idata;\n}\n\nint imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}\n\nvoid imap_close_connection(IMAP_DATA* idata)\n{\n  if (idata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close (idata->conn);\n    idata->state = IMAP_DISCONNECTED;\n  }\n  idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = 0;\n  memset (idata->cmds, 0, sizeof (IMAP_COMMAND) * idata->cmdslots);\n}\n\n/* imap_get_flags: Make a simple list out of a FLAGS response.\n *   return stream following FLAGS response */\nstatic char* imap_get_flags (LIST** hflags, char* s)\n{\n  LIST* flags;\n  char* flag_word;\n  char ctmp;\n\n  /* sanity-check string */\n  if (ascii_strncasecmp (\"FLAGS\", s, 5) != 0)\n  {\n    dprint (1, (debugfile, \"imap_get_flags: not a FLAGS response: %s\\n\",\n                s));\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    dprint (1, (debugfile, \"imap_get_flags: bogus FLAGS response: %s\\n\",\n                s));\n    return NULL;\n  }\n\n  /* create list, update caller's flags handle */\n  flags = mutt_new_list();\n  *hflags = flags;\n\n  while (*s && *s != ')')\n  {\n    s++;\n    SKIPWS(s);\n    flag_word = s;\n    while (*s && (*s != ')') && !ISSPACE (*s))\n      s++;\n    ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_add_list (flags, flag_word);\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    dprint (1, (debugfile,\n                \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s));\n    mutt_free_list (hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\nstatic int imap_open_mailbox (CONTEXT* ctx)\n{\n  IMAP_DATA *idata;\n  IMAP_STATUS* status;\n  char buf[LONG_STRING];\n  char bufout[LONG_STRING*2];\n  int count = 0;\n  IMAP_MBOX mx, pmx;\n  int rc;\n  const char *condstore;\n\n  if (imap_parse_path (ctx->path, &mx))\n  {\n    mutt_error (_(\"%s is an invalid IMAP path\"), ctx->path);\n    return -1;\n  }\n\n  /* we require a connection which isn't currently in IMAP_SELECTED state */\n  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NOSELECT)))\n    goto fail_noidata;\n\n  /* once again the context is new */\n  ctx->data = idata;\n\n  /* Clean up path and replace the one in the ctx */\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n  FREE(&(idata->mailbox));\n  idata->mailbox = safe_strdup (buf);\n  imap_qualify_path (buf, sizeof (buf), &mx, idata->mailbox);\n\n  FREE (&(ctx->path));\n  FREE (&(ctx->realpath));\n  ctx->path = safe_strdup (buf);\n  ctx->realpath = safe_strdup (ctx->path);\n\n  idata->ctx = ctx;\n\n  /* clear mailbox status */\n  idata->status = 0;\n  memset (idata->ctx->rights, 0, sizeof (idata->ctx->rights));\n  idata->newMailCount = 0;\n  idata->max_msn = 0;\n\n  if (!ctx->quiet)\n    mutt_message (_(\"Selecting %s...\"), idata->mailbox);\n  imap_munge_mbox_name (idata, buf, sizeof(buf), idata->mailbox);\n\n  /* pipeline ACL test */\n  if (mutt_bit_isset (idata->capabilities, ACL))\n  {\n    snprintf (bufout, sizeof (bufout), \"MYRIGHTS %s\", buf);\n    imap_exec (idata, bufout, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_LOOKUP);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_READ);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_SEEN);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_INSERT);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_POST);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);\n  }\n  /* pipeline the postponed count if possible */\n  pmx.mbox = NULL;\n  if (mx_is_imap (Postponed) && !imap_parse_path (Postponed, &pmx)\n      && mutt_account_match (&pmx.account, &mx.account))\n    imap_status (Postponed, 1);\n  FREE (&pmx.mbox);\n\n#if USE_HCACHE\n  if (mutt_bit_isset (idata->capabilities, CONDSTORE) &&\n      option (OPTIMAPCONDSTORE))\n    condstore = \" (CONDSTORE)\";\n  else\n#endif\n    condstore = \"\";\n\n  snprintf (bufout, sizeof (bufout), \"%s %s%s\",\n            ctx->readonly ? \"EXAMINE\" : \"SELECT\",\n            buf, condstore);\n\n  idata->state = IMAP_SELECTED;\n\n  imap_cmd_start (idata, bufout);\n\n  status = imap_mboxcache_get (idata, idata->mailbox, 1);\n\n  do\n  {\n    char *pc;\n\n    if ((rc = imap_cmd_step (idata)) != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (ascii_strncasecmp (\"FLAGS\", pc, 5) == 0)\n    {\n      /* don't override PERMANENTFLAGS */\n      if (!idata->flags)\n      {\n\tdprint (3, (debugfile, \"Getting mailbox FLAGS\\n\"));\n\tif ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\t  goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (ascii_strncasecmp (\"OK [PERMANENTFLAGS\", pc, 18) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox PERMANENTFLAGS\\n\"));\n      /* safe to call on NULL */\n      mutt_free_list (&(idata->flags));\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      if ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\tgoto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (ascii_strncasecmp (\"OK [UIDVALIDITY\", pc, 14) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDVALIDITY\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uid_validity) < 0)\n        goto fail;\n      status->uidvalidity = idata->uid_validity;\n    }\n    else if (ascii_strncasecmp (\"OK [UIDNEXT\", pc, 11) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDNEXT\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uidnext) < 0)\n        goto fail;\n      status->uidnext = idata->uidnext;\n    }\n    else if (ascii_strncasecmp (\"OK [HIGHESTMODSEQ\", pc, 17) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox HIGHESTMODSEQ\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoull (pc, &idata->modseq) < 0)\n        goto fail;\n      status->modseq = idata->modseq;\n    }\n    else if (ascii_strncasecmp (\"OK [NOMODSEQ\", pc, 12) == 0)\n    {\n      dprint (3, (debugfile, \"Mailbox has NOMODSEQ set\\n\"));\n      status->modseq = idata->modseq = 0;\n    }\n    else\n    {\n      pc = imap_next_word (pc);\n      if (!ascii_strncasecmp (\"EXISTS\", pc, 6))\n      {\n\tcount = idata->newMailCount;\n\tidata->newMailCount = 0;\n      }\n    }\n  }\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_NO)\n  {\n    char *s;\n    s = imap_next_word (idata->buf); /* skip seq */\n    s = imap_next_word (s); /* Skip response */\n    mutt_error (\"%s\", s);\n    mutt_sleep (2);\n    goto fail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if (!ascii_strncasecmp (imap_get_qualifier (idata->buf), \"[READ-ONLY]\", 11) &&\n      !mutt_bit_isset (idata->capabilities, ACL))\n  {\n    dprint (2, (debugfile, \"Mailbox is read-only.\\n\"));\n    ctx->readonly = 1;\n  }\n\n#ifdef DEBUG\n  /* dump the mailbox flags we've found */\n  if (debuglevel > 2)\n  {\n    if (!idata->flags)\n      dprint (3, (debugfile, \"No folder flags found\\n\"));\n    else\n    {\n      LIST* t = idata->flags;\n\n      dprint (3, (debugfile, \"Mailbox flags: \"));\n\n      t = t->next;\n      while (t)\n      {\n        dprint (3, (debugfile, \"[%s] \", t->data));\n        t = t->next;\n      }\n      dprint (3, (debugfile, \"\\n\"));\n    }\n  }\n#endif\n\n  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))\n    ctx->readonly = 1;\n\n  ctx->hdrmax = count;\n  ctx->hdrs = safe_calloc (count, sizeof (HEADER *));\n  ctx->v2r = safe_calloc (count, sizeof (int));\n  ctx->msgcount = 0;\n\n  if (count && (imap_read_headers (idata, 1, count, 1) < 0))\n  {\n    mutt_error _(\"Error opening mailbox\");\n    mutt_sleep (1);\n    goto fail;\n  }\n\n  imap_disallow_reopen (ctx);\n\n  dprint (2, (debugfile, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount));\n  FREE (&mx.mbox);\n  return 0;\n\nfail:\n  if (idata->state == IMAP_SELECTED)\n    idata->state = IMAP_AUTHENTICATED;\nfail_noidata:\n  FREE (&mx.mbox);\n  return -1;\n}\n\nstatic int imap_open_mailbox_append (CONTEXT *ctx, int flags)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING];\n  char mailbox[LONG_STRING];\n  IMAP_MBOX mx;\n  int rc;\n\n  if (imap_parse_path (ctx->path, &mx))\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  ctx->data = idata;\n\n  imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));\n  if (!*mailbox)\n    strfcpy (mailbox, \"INBOX\", sizeof (mailbox));\n  FREE (&mx.mbox);\n\n  if ((rc = imap_access (ctx->path)) == 0)\n    return 0;\n\n  if (rc == -1)\n    return -1;\n\n  snprintf (buf, sizeof (buf), _(\"Create %s?\"), mailbox);\n  if (option (OPTCONFIRMCREATE) && mutt_yesorno (buf, 1) < 1)\n    return -1;\n\n  if (imap_create_mailbox (idata, mailbox) < 0)\n    return -1;\n\n  return 0;\n}\n\n/* imap_logout: Gracefully log out of server. */\nvoid imap_logout (IMAP_DATA** idata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  (*idata)->status = IMAP_BYE;\n  imap_cmd_start (*idata, \"LOGOUT\");\n  if (ImapPollTimeout <= 0 ||\n      mutt_socket_poll ((*idata)->conn, ImapPollTimeout) != 0)\n  {\n    while (imap_cmd_step (*idata) == IMAP_CMD_CONTINUE)\n      ;\n  }\n\n  mutt_socket_close ((*idata)->conn);\n  imap_free_idata (idata);\n}\n\nstatic int imap_open_new_message (MESSAGE *msg, CONTEXT *dest, HEADER *hdr)\n{\n  BUFFER *tmp = NULL;\n  int rc = -1;\n\n  tmp = mutt_buffer_pool_get ();\n  mutt_buffer_mktemp (tmp);\n  if ((msg->fp = safe_fopen (mutt_b2s (tmp), \"w\")) == NULL)\n  {\n    mutt_perror (mutt_b2s (tmp));\n    goto cleanup;\n  }\n\n  msg->path = safe_strdup (mutt_b2s (tmp));\n  rc = 0;\n\ncleanup:\n  mutt_buffer_pool_release (&tmp);\n  return rc;\n}\n\n/* imap_set_flag: append str to flags if we currently have permission\n *   according to aclbit */\nstatic void imap_set_flag (IMAP_DATA* idata, int aclbit, int flag,\n                           const char *str, char *flags, size_t flsize)\n{\n  if (mutt_bit_isset (idata->ctx->rights, aclbit))\n    if (flag && imap_has_flag (idata->flags, str))\n      safe_strcat (flags, flsize, str);\n}\n\n/* imap_has_flag: do a caseless comparison of the flag against a flag list,\n*   return 1 if found or flag list has '\\*', 0 otherwise */\nint imap_has_flag (LIST* flag_list, const char* flag)\n{\n  if (!flag_list)\n    return 0;\n\n  flag_list = flag_list->next;\n  while (flag_list)\n  {\n    if (!ascii_strncasecmp (flag_list->data, flag, strlen (flag_list->data)))\n      return 1;\n\n    if (!ascii_strncmp (flag_list->data, \"\\\\*\", strlen (flag_list->data)))\n      return 1;\n\n    flag_list = flag_list->next;\n  }\n\n  return 0;\n}\n\n/* Note: headers must be in SORT_ORDER. See imap_exec_msgset for args.\n * Pos is an opaque pointer a la strtok. It should be 0 at first call. */\nstatic int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,\n                              int changed, int invert, int* pos)\n{\n  HEADER** hdrs = idata->ctx->hdrs;\n  int count = 0;\t/* number of messages in message set */\n  int match = 0;\t/* whether current message matches flag condition */\n  unsigned int setstart = 0;\t/* start of current message range */\n  int n;\n  int started = 0;\n\n  hdrs = idata->ctx->hdrs;\n\n  for (n = *pos;\n       (n < idata->ctx->msgcount) && (mutt_buffer_len (buf) < IMAP_MAX_CMDLEN);\n       n++)\n  {\n    match = 0;\n    /* don't include pending expunged messages.\n     *\n     * TODO: can we unset active in cmd_parse_expunge() and\n     * cmd_parse_vanished() instead of checking for index != INT_MAX. */\n    if (hdrs[n]->active && (hdrs[n]->index != INT_MAX))\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)\n            match = invert ^ hdrs[n]->deleted;\n\t  break;\n        case MUTT_FLAG:\n          if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)\n            match = invert ^ hdrs[n]->flagged;\n\t  break;\n        case MUTT_OLD:\n          if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)\n            match = invert ^ hdrs[n]->old;\n\t  break;\n        case MUTT_READ:\n          if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)\n            match = invert ^ hdrs[n]->read;\n\t  break;\n        case MUTT_REPLIED:\n          if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)\n            match = invert ^ hdrs[n]->replied;\n\t  break;\n\n        case MUTT_TAG:\n\t  if (hdrs[n]->tagged)\n\t    match = 1;\n\t  break;\n        case MUTT_TRASH:\n          if (hdrs[n]->deleted && !hdrs[n]->purge)\n            match = 1;\n\t  break;\n      }\n\n    if (match && (!changed || hdrs[n]->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = HEADER_DATA (hdrs[n])->uid;\n        if (started == 0)\n\t{\n\t  mutt_buffer_add_printf (buf, \"%u\", HEADER_DATA (hdrs[n])->uid);\n\t  started = 1;\n\t}\n        else\n\t  mutt_buffer_add_printf (buf, \",%u\", HEADER_DATA (hdrs[n])->uid);\n      }\n      /* tie up if the last message also matches */\n      else if (n == idata->ctx->msgcount-1)\n\tmutt_buffer_add_printf (buf, \":%u\", HEADER_DATA (hdrs[n])->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount-1))\n    {\n      if (HEADER_DATA (hdrs[n-1])->uid > setstart)\n\tmutt_buffer_add_printf (buf, \":%u\", HEADER_DATA (hdrs[n-1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/* Prepares commands for all messages matching conditions (must be flushed\n * with imap_exec)\n * Params:\n *   idata: IMAP_DATA containing context containing header set\n *   pre, post: commands are of the form \"%s %s %s %s\", tag,\n *     pre, message set, post\n *   flag: enum of flag type on which to filter\n *   changed: include only changed messages in message set\n *   invert: invert sense of flag, eg MUTT_READ matches unread messages\n * Returns: number of matched messages, or -1 on failure */\nint imap_exec_msgset (IMAP_DATA* idata, const char* pre, const char* post,\n                      int flag, int changed, int invert)\n{\n  HEADER** hdrs = NULL;\n  short oldsort;\n  BUFFER* cmd;\n  int pos;\n  int rc;\n  int count = 0, reopen_set = 0;\n\n  cmd = mutt_buffer_new ();\n\n  /* Unlike imap_sync_mailbox(), this function can be called when\n   * IMAP_REOPEN_ALLOW is not set.  In that case, the caller isn't\n   * prepared to handle context changes.  Resorting may not always\n   * give the same order, so we must make a copy.\n   *\n   * See the comment in imap_sync_mailbox() for the dangers of running\n   * even queued execs while reopen is set.  To prevent memory\n   * corruption and data loss we must disable reopen for the duration\n   * of the swapped hdrs.\n   */\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n    reopen_set = 1;\n  }\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = idata->ctx->hdrs;\n    idata->ctx->hdrs = safe_malloc (idata->ctx->msgcount * sizeof (HEADER*));\n    memcpy (idata->ctx->hdrs, hdrs, idata->ctx->msgcount * sizeof (HEADER*));\n\n    Sort = SORT_ORDER;\n    qsort (idata->ctx->hdrs, idata->ctx->msgcount, sizeof (HEADER*),\n           mutt_get_sort_func (SORT_ORDER));\n  }\n\n  pos = 0;\n\n  do\n  {\n    mutt_buffer_clear (cmd);\n    mutt_buffer_add_printf (cmd, \"%s \", pre);\n    rc = imap_make_msg_set (idata, cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_add_printf (cmd, \" %s\", post);\n      if (imap_exec (idata, cmd->data, IMAP_CMD_QUEUE))\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  }\n  while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_free (&cmd);\n  if ((oldsort != Sort) || hdrs)\n  {\n    Sort = oldsort;\n    FREE (&idata->ctx->hdrs);\n    idata->ctx->hdrs = hdrs;\n  }\n  if (reopen_set)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n\n  return rc;\n}\n\n/* returns 0 if mutt's flags match cached server flags:\n * EXCLUDING the deleted flag. */\nstatic int compare_flags_for_copy (HEADER* h)\n{\n  IMAP_HEADER_DATA* hd = (IMAP_HEADER_DATA*)h->data;\n\n  if (h->read != hd->read)\n    return 1;\n  if (h->old != hd->old)\n    return 1;\n  if (h->flagged != hd->flagged)\n    return 1;\n  if (h->replied != hd->replied)\n    return 1;\n\n  return 0;\n}\n\n/* Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n * NOTE: This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy (IMAP_DATA *idata, HEADER *hdr, BUFFER *cmd,\n                                int *err_continue)\n{\n  char flags[LONG_STRING];\n  char uid[11];\n\n  if (!compare_flags_for_copy (hdr))\n  {\n    if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n      hdr->changed = 0;\n    return 0;\n  }\n\n  snprintf (uid, sizeof (uid), \"%u\", HEADER_DATA(hdr)->uid);\n  mutt_buffer_clear (cmd);\n  mutt_buffer_addstr (cmd, \"UID STORE \");\n  mutt_buffer_addstr (cmd, uid);\n\n  flags[0] = '\\0';\n\n  imap_set_flag (idata, MUTT_ACL_SEEN, hdr->read, \"\\\\Seen \",\n\t\t flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->old,\n                 \"Old \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->flagged,\n\t\t \"\\\\Flagged \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->replied,\n\t\t \"\\\\Answered \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_DELETE, HEADER_DATA(hdr)->deleted,\n                 \"\\\\Deleted \", flags, sizeof (flags));\n\n  /* now make sure we don't lose custom tags */\n  if (mutt_bit_isset (idata->ctx->rights, MUTT_ACL_WRITE))\n    imap_add_keywords (flags, hdr, idata->flags, sizeof (flags));\n\n  mutt_remove_trailing_ws (flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (!*flags)\n  {\n    imap_set_flag (idata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_DELETE, !HEADER_DATA(hdr)->deleted,\n                   \"\\\\Deleted \", flags, sizeof (flags));\n\n    mutt_remove_trailing_ws (flags);\n\n    mutt_buffer_addstr (cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr (cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr (cmd, flags);\n  mutt_buffer_addstr (cmd, \")\");\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec (idata, cmd->data, 0) != 0) &&\n      err_continue && (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue (\"imap_sync_message: STORE failed\",\n\t\t\t\t   idata->buf);\n    if (*err_continue != MUTT_YES)\n      return -1;\n  }\n\n  if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n    hdr->changed = 0;\n\n  return 0;\n}\n\nstatic int sync_helper (IMAP_DATA* idata, int right, int flag, const char* name)\n{\n  int count = 0;\n  int rc;\n  char buf[LONG_STRING];\n\n  if (!idata->ctx)\n    return -1;\n\n  if (!mutt_bit_isset (idata->ctx->rights, right))\n    return 0;\n\n  if (right == MUTT_ACL_WRITE && !imap_has_flag (idata->flags, name))\n    return 0;\n\n  snprintf (buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  if ((rc = imap_exec_msgset (idata, \"UID STORE\", buf, flag, 1, 0)) < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  if ((rc = imap_exec_msgset (idata, \"UID STORE\", buf, flag, 1, 1)) < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/* update the IMAP server to reflect message changes done within mutt.\n * Arguments\n *   ctx: the current context\n *   expunge: 0 or 1 - do expunge?\n */\nint imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)\n{\n  IMAP_DATA* idata;\n  CONTEXT* appendctx = NULL;\n  HEADER* h;\n  HEADER** hdrs = NULL;\n  int oldsort;\n  int n;\n  int rc, quickdel_rc = 0;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  if (idata->state < IMAP_SELECTED)\n  {\n    dprint (2, (debugfile, \"imap_sync_mailbox: no mailbox selected\\n\"));\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen (ctx);\n\n  if ((rc = imap_check_mailbox (ctx, index_hint, 0)) != 0)\n    goto out;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && mutt_bit_isset (ctx->rights, MUTT_ACL_DELETE))\n  {\n    if ((quickdel_rc = imap_exec_msgset (idata,\n                                         \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                                         MUTT_DELETED, 1, 0)) < 0)\n    {\n      rc = quickdel_rc;\n      mutt_error (_(\"Expunge failed\"));\n      mutt_sleep (1);\n      goto out;\n    }\n\n    if (quickdel_rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (n = 0; n < ctx->msgcount; n++)\n        if (ctx->hdrs[n]->deleted && ctx->hdrs[n]->changed)\n          ctx->hdrs[n]->active = 0;\n      if (!ctx->quiet)\n        mutt_message (_(\"Marking %d messages deleted...\"), quickdel_rc);\n    }\n  }\n\n#if USE_HCACHE\n  idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    h = ctx->hdrs[n];\n\n    if (h->deleted)\n    {\n      imap_cache_del (idata, h);\n#if USE_HCACHE\n      imap_hcache_del (idata, HEADER_DATA(h)->uid);\n#endif\n    }\n\n    if (h->active && h->changed)\n    {\n#if USE_HCACHE\n      imap_hcache_put (idata, h);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      /* TODO: why the h->env check? */\n      if ((h->env && h->env->changed) || h->attach_del)\n      {\n        /* NOTE and TODO:\n         *\n         * The mx_open_mailbox() in append mode below merely hijacks an existing\n         * idata; it doesn't reset idata->ctx.  imap_append_message() ends up\n         * using (borrowing) the same idata we are using.\n         *\n         * Right after the APPEND operation finishes, the server can send an\n         * EXISTS notifying of the new message.  Then, while still inside\n         * imap_append_message(), imap_cmd_step() -> imap_cmd_finish() will\n         * call imap_read_headers() to download those (because the idata's\n         * reopen_allow is set).\n         *\n         * The imap_read_headers() will open (and clobber) the idata->hcache we\n         * just opened above, then close it.\n         *\n         * The easy and less dangerous fix done here (for a stable branch bug\n         * fix) is to close and reopen the header cache around the operation.\n         *\n         * A better fix would be allowing idata->hcache reuse.  When that is\n         * done, the close/reopen in read_headers_condstore_qresync_updates()\n         * can also be removed. */\n#if USE_HCACHE\n        imap_hcache_close (idata);\n#endif\n        if (!ctx->quiet)\n          mutt_message (_(\"Saving changed messages... [%d/%d]\"), n+1,\n                        ctx->msgcount);\n\tif (!appendctx)\n\t  appendctx = mx_open_mailbox (ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);\n\tif (!appendctx)\n\t  dprint (1, (debugfile, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\"));\n\telse\n\t  _mutt_save_message (h, appendctx, 1, 0, 0);\n        /* TODO: why the check for h->env?  Is this possible? */\n        if (h->env)\n          h->env->changed = 0;\n#if USE_HCACHE\n        idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n      }\n    }\n  }\n\n#if USE_HCACHE\n  imap_hcache_close (idata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset.\n   *\n   * Note: sync_helper() may trigger an imap_exec() if the queue fills\n   * up.  Because IMAP_REOPEN_ALLOW is set, this may result in new\n   * messages being downloaded or an expunge being processed.  For new\n   * messages this would both result in memory corruption (since we're\n   * alloc'ing msgcount instead of hdrmax pointers) and data loss of\n   * the new messages.  For an expunge, the restored hdrs would point\n   * to headers that have been freed.\n   *\n   * Since reopen is allowed, we could change this to call\n   * mutt_sort_headers() before and after instead, but the double sort\n   * is noticeably slower.\n   *\n   * So instead, just turn off reopen_allow for the duration of the\n   * swapped hdrs.  The imap_exec() below flushes the queue out,\n   * giving the opportunity to process any reopen events.\n   */\n  imap_disallow_reopen (ctx);\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = ctx->hdrs;\n    ctx->hdrs = safe_malloc (ctx->msgcount * sizeof (HEADER*));\n    memcpy (ctx->hdrs, hdrs, ctx->msgcount * sizeof (HEADER*));\n\n    Sort = SORT_ORDER;\n    qsort (ctx->hdrs, ctx->msgcount, sizeof (HEADER*),\n           mutt_get_sort_func (SORT_ORDER));\n  }\n\n  rc = sync_helper (idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if ((oldsort != Sort) || hdrs)\n  {\n    Sort = oldsort;\n    FREE (&ctx->hdrs);\n    ctx->hdrs = hdrs;\n  }\n  imap_allow_reopen (ctx);\n\n  /* Flush the queued flags if any were changed in sync_helper.\n   * The real (non-flag) changes loop might have flushed quickdel_rc\n   * queued commands, so we double check the cmdbuf isn't empty. */\n  if (((rc > 0) || (quickdel_rc > 0)) && mutt_buffer_len (idata->cmdbuf))\n    if (imap_exec (idata, NULL, 0) != IMAP_CMD_OK)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (ctx->closing)\n    {\n      if (mutt_yesorno (_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)\n      {\n        rc = 0;\n        idata->state = IMAP_AUTHENTICATED;\n        goto out;\n      }\n    }\n    else\n      mutt_error _(\"Error saving flags\");\n    rc = -1;\n    goto out;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    HEADER_DATA(ctx->hdrs[n])->deleted = ctx->hdrs[n]->deleted;\n    HEADER_DATA(ctx->hdrs[n])->flagged = ctx->hdrs[n]->flagged;\n    HEADER_DATA(ctx->hdrs[n])->old = ctx->hdrs[n]->old;\n    HEADER_DATA(ctx->hdrs[n])->read = ctx->hdrs[n]->read;\n    HEADER_DATA(ctx->hdrs[n])->replied = ctx->hdrs[n]->replied;\n    ctx->hdrs[n]->changed = 0;\n  }\n  ctx->changed = 0;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !(ctx->closing) &&\n      mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    if (!ctx->quiet)\n      mutt_message _(\"Expunging messages from server...\");\n    /* Set expunge bit so we don't get spurious reopened messages */\n    idata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec (idata, \"EXPUNGE\", 0) != 0)\n    {\n      idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error (_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);\n      rc = -1;\n      goto out;\n    }\n    idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && ctx->closing)\n  {\n    imap_exec (idata, \"CLOSE\", IMAP_CMD_QUEUE);\n    idata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (option (OPTMESSAGECACHECLEAN))\n    imap_cache_clean (idata);\n\n  rc = 0;\n\nout:\n  imap_disallow_reopen (ctx);\n  if (appendctx)\n  {\n    mx_fastclose_mailbox (appendctx);\n    FREE (&appendctx);\n  }\n  return rc;\n}\n\n/* imap_close_mailbox: clean up IMAP data in CONTEXT */\nint imap_close_mailbox (CONTEXT* ctx)\n{\n  IMAP_DATA* idata;\n  int i;\n\n  idata = (IMAP_DATA*) ctx->data;\n  /* Check to see if the mailbox is actually open */\n  if (!idata)\n    return 0;\n\n  /* imap_open_mailbox_append() borrows the IMAP_DATA temporarily,\n   * just for the connection, but does not set idata->ctx to the\n   * open-append ctx.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up idata.  Otherwise, we don't want to\n   * touch idata - it's still being used.\n   */\n  if (ctx == idata->ctx)\n  {\n    if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)\n    {\n      /* mx_close_mailbox won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (!ctx->deleted)\n        imap_exec (idata, \"CLOSE\", IMAP_CMD_QUEUE);\n      idata->state = IMAP_AUTHENTICATED;\n    }\n\n    idata->reopen = 0;\n    FREE (&(idata->mailbox));\n    mutt_free_list (&idata->flags);\n    idata->ctx = NULL;\n\n    hash_destroy (&idata->uid_hash, NULL);\n    FREE (&idata->msn_index);\n    idata->msn_index_size = 0;\n    idata->max_msn = 0;\n\n    for (i = 0; i < IMAP_CACHE_LEN; i++)\n    {\n      if (idata->cache[i].path)\n      {\n        unlink (idata->cache[i].path);\n        FREE (&idata->cache[i].path);\n      }\n    }\n\n    mutt_bcache_close (&idata->bcache);\n  }\n\n  /* free IMAP part of headers */\n  for (i = 0; i < ctx->msgcount; i++)\n    /* mailbox may not have fully loaded */\n    if (ctx->hdrs[i] && ctx->hdrs[i]->data)\n      imap_free_header_data ((IMAP_HEADER_DATA**)&(ctx->hdrs[i]->data));\n\n  return 0;\n}\n\n/* use the NOOP or IDLE command to poll for new mail\n *\n * return values:\n *\tMUTT_REOPENED\tmailbox has been externally modified\n *\tMUTT_NEW_MAIL\tnew mail has arrived!\n *\t0\t\tno change\n *\t-1\t\terror\n */\nint imap_check_mailbox (CONTEXT *ctx, int *index_hint, int force)\n{\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  IMAP_DATA* idata;\n  int result = 0;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  /* try IDLE first, unless force is set */\n  if (!force && option (OPTIMAPIDLE) && mutt_bit_isset (idata->capabilities, IDLE)\n      && (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))\n  {\n    if (imap_cmd_idle (idata) < 0)\n      return -1;\n  }\n  if (idata->state == IMAP_IDLE)\n  {\n    while ((result = mutt_socket_poll (idata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step (idata) != IMAP_CMD_CONTINUE)\n      {\n        dprint (1, (debugfile, \"Error reading IDLE response\\n\"));\n        return -1;\n      }\n    }\n    if (result < 0)\n    {\n      dprint (1, (debugfile, \"Poll failed, disabling IDLE\\n\"));\n      mutt_bit_unset (idata->capabilities, IDLE);\n    }\n  }\n\n  if ((force ||\n       (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout))\n      && imap_exec (idata, \"NOOP\", IMAP_CMD_POLL) != 0)\n    return -1;\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish (idata);\n\n  if (idata->check_status & IMAP_EXPUNGE_PENDING)\n    result = MUTT_REOPENED;\n  else if (idata->check_status & IMAP_NEWMAIL_PENDING)\n    result = MUTT_NEW_MAIL;\n  else if (idata->check_status & IMAP_FLAGS_PENDING)\n    result = MUTT_FLAGS;\n\n  idata->check_status = 0;\n\n  return result;\n}\n\nstatic int imap_check_mailbox_reopen (CONTEXT *ctx, int *index_hint)\n{\n  int rc;\n\n  imap_allow_reopen (ctx);\n  rc = imap_check_mailbox (ctx, index_hint, 0);\n  imap_disallow_reopen (ctx);\n\n  return rc;\n}\n\nstatic int imap_save_to_header_cache (CONTEXT *ctx, HEADER *h)\n{\n  int rc = 0;\n#ifdef USE_HCACHE\n  int close_hc = 1;\n  IMAP_DATA* idata;\n\n  idata = (IMAP_DATA *)ctx->data;\n  if (idata->hcache)\n    close_hc = 0;\n  else\n    idata->hcache = imap_hcache_open (idata, NULL);\n  rc = imap_hcache_put (idata, h);\n  if (close_hc)\n    imap_hcache_close (idata);\n#endif\n  return rc;\n}\n\n/* split path into (idata,mailbox name) */\nstatic int imap_get_mailbox (const char* path, IMAP_DATA** hidata, char* buf, size_t blen)\n{\n  IMAP_MBOX mx;\n\n  if (imap_parse_path (path, &mx))\n  {\n    dprint (1, (debugfile, \"imap_get_mailbox: Error parsing %s\\n\", path));\n    return -1;\n  }\n  if (!(*hidata = imap_conn_find (&(mx.account), option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path (*hidata, mx.mbox, buf, blen);\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", blen);\n  FREE (&mx.mbox);\n\n  return 0;\n}\n\n/* check for new mail in any subscribed mailboxes. Given a list of mailboxes\n * rather than called once for each so that it can batch the commands and\n * save on round trips. Returns number of mailboxes with new mail. */\nint imap_buffy_check (int force, int check_stats)\n{\n  IMAP_DATA* idata;\n  IMAP_DATA* lastdata = NULL;\n  BUFFY* mailbox;\n  char name[LONG_STRING];\n  char command[LONG_STRING*2];\n  char munged[LONG_STRING];\n  int buffies = 0;\n\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    /* Init newly-added mailboxes */\n    if (! mailbox->magic)\n    {\n      if (mx_is_imap (mutt_b2s (mailbox->pathbuf)))\n        mailbox->magic = MUTT_IMAP;\n    }\n\n    if (mailbox->magic != MUTT_IMAP)\n      continue;\n\n    if (mailbox->nopoll)\n      continue;\n\n    if (imap_get_mailbox (mutt_b2s (mailbox->pathbuf), &idata, name, sizeof (name)) < 0)\n    {\n      mailbox->new = 0;\n      continue;\n    }\n\n    /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n     * IDLEd elsewhere.\n     * idata->mailbox may be NULL for connections other than the current\n     * mailbox's, and shouldn't expand to INBOX in that case. #3216. */\n    if (idata->mailbox && !imap_mxcmp (name, idata->mailbox))\n    {\n      mailbox->new = 0;\n      continue;\n    }\n\n    if (!mutt_bit_isset (idata->capabilities, IMAP4REV1) &&\n        !mutt_bit_isset (idata->capabilities, STATUS))\n    {\n      dprint (2, (debugfile, \"Server doesn't support STATUS\\n\"));\n      continue;\n    }\n\n    if (lastdata && idata != lastdata)\n    {\n      /* Send commands to previous server. Sorting the buffy list\n       * may prevent some infelicitous interleavings */\n      if (imap_exec (lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)\n        dprint (1, (debugfile, \"Error polling mailboxes\\n\"));\n\n      lastdata = NULL;\n    }\n\n    if (!lastdata)\n      lastdata = idata;\n\n    imap_munge_mbox_name (idata, munged, sizeof (munged), name);\n    if (check_stats)\n      snprintf (command, sizeof (command),\n                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);\n    else\n      snprintf (command, sizeof (command),\n                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);\n\n    if (imap_exec (idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)\n    {\n      dprint (1, (debugfile, \"Error queueing command\\n\"));\n      return 0;\n    }\n  }\n\n  if (lastdata && (imap_exec (lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))\n  {\n    dprint (1, (debugfile, \"Error polling mailboxes\\n\"));\n    return 0;\n  }\n\n  /* collect results */\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mailbox->magic == MUTT_IMAP && mailbox->new)\n      buffies++;\n  }\n\n  return buffies;\n}\n\n/* imap_status: returns count of messages in mailbox, or -1 on error.\n * if queue != 0, queue the command and expect it to have been run\n * on the next call (for pipelining the postponed count) */\nint imap_status (const char* path, int queue)\n{\n  static int queued = 0;\n\n  IMAP_DATA *idata;\n  char buf[LONG_STRING*2];\n  char mbox[LONG_STRING];\n  IMAP_STATUS* status;\n\n  if (imap_get_mailbox (path, &idata, buf, sizeof (buf)) < 0)\n    return -1;\n\n  /* We are in the folder we're polling - just return the mailbox count.\n   *\n   * Note that imap_mxcmp() converts NULL to \"INBOX\", so we need to\n   * make sure the idata really is open to a folder. */\n  if (idata->ctx && !imap_mxcmp (buf, idata->mailbox))\n    return idata->ctx->msgcount;\n  else if (mutt_bit_isset(idata->capabilities,IMAP4REV1) ||\n\t   mutt_bit_isset(idata->capabilities,STATUS))\n  {\n    imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n    snprintf (buf, sizeof (buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");\n    imap_unmunge_mbox_name (idata, mbox);\n  }\n  else\n    /* Server does not support STATUS, and this is not the current mailbox.\n     * There is no lightweight way to check recent arrivals */\n    return -1;\n\n  if (queue)\n  {\n    imap_exec (idata, buf, IMAP_CMD_QUEUE);\n    queued = 1;\n    return 0;\n  }\n  else if (!queued)\n    imap_exec (idata, buf, 0);\n\n  queued = 0;\n  if ((status = imap_mboxcache_get (idata, mbox, 0)))\n    return status->messages;\n\n  return 0;\n}\n\n/* return cached mailbox stats or NULL if create is 0 */\nIMAP_STATUS* imap_mboxcache_get (IMAP_DATA* idata, const char* mbox, int create)\n{\n  LIST* cur;\n  IMAP_STATUS* status;\n  IMAP_STATUS scache;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n  void *puidvalidity = NULL;\n  void *puidnext = NULL;\n  void *pmodseq = NULL;\n#endif\n\n  for (cur = idata->mboxcache; cur; cur = cur->next)\n  {\n    status = (IMAP_STATUS*)cur->data;\n\n    if (!imap_mxcmp (mbox, status->name))\n      return status;\n  }\n  status = NULL;\n\n  /* lame */\n  if (create)\n  {\n    memset (&scache, 0, sizeof (scache));\n    scache.name = (char*)mbox;\n    idata->mboxcache = mutt_add_list_n (idata->mboxcache, &scache,\n                                        sizeof (scache));\n    status = imap_mboxcache_get (idata, mbox, 0);\n    status->name = safe_strdup (mbox);\n  }\n\n#ifdef USE_HCACHE\n  hc = imap_hcache_open (idata, mbox);\n  if (hc)\n  {\n    puidvalidity = mutt_hcache_fetch_raw (hc, \"/UIDVALIDITY\", imap_hcache_keylen);\n    puidnext = mutt_hcache_fetch_raw (hc, \"/UIDNEXT\", imap_hcache_keylen);\n    pmodseq = mutt_hcache_fetch_raw (hc, \"/MODSEQ\", imap_hcache_keylen);\n    if (puidvalidity)\n    {\n      if (!status)\n      {\n        mutt_hcache_free ((void **)&puidvalidity);\n        mutt_hcache_free ((void **)&puidnext);\n        mutt_hcache_free ((void **)&pmodseq);\n        mutt_hcache_close (hc);\n        return imap_mboxcache_get (idata, mbox, 1);\n      }\n      memcpy (&status->uidvalidity, puidvalidity, sizeof(unsigned int));\n\n      if (puidnext)\n        memcpy (&status->uidnext, puidnext, sizeof(unsigned int));\n      else\n        status->uidnext = 0;\n\n      if (pmodseq)\n        memcpy (&status->modseq, pmodseq, sizeof(unsigned long long));\n      else\n        status->modseq = 0;\n      dprint (3, (debugfile, \"mboxcache: hcache uidvalidity %u, uidnext %u, modseq %llu\\n\",\n                  status->uidvalidity, status->uidnext, status->modseq));\n    }\n    mutt_hcache_free ((void **)&puidvalidity);\n    mutt_hcache_free ((void **)&puidnext);\n    mutt_hcache_free ((void **)&pmodseq);\n    mutt_hcache_close (hc);\n  }\n#endif\n\n  return status;\n}\n\nvoid imap_mboxcache_free (IMAP_DATA* idata)\n{\n  LIST* cur;\n  IMAP_STATUS* status;\n\n  for (cur = idata->mboxcache; cur; cur = cur->next)\n  {\n    status = (IMAP_STATUS*)cur->data;\n\n    FREE (&status->name);\n  }\n\n  mutt_free_list (&idata->mboxcache);\n}\n\n/* returns number of patterns in the search that should be done server-side\n * (eg are full-text) */\nstatic int do_search (const pattern_t* search, int allpats)\n{\n  int rc = 0;\n  const pattern_t* pat;\n\n  for (pat = search; pat; pat = pat->next)\n  {\n    switch (pat->op)\n    {\n      case MUTT_BODY:\n      case MUTT_HEADER:\n      case MUTT_WHOLE_MSG:\n        if (pat->stringmatch)\n          rc++;\n        break;\n      default:\n        if (pat->child && do_search (pat->child, 1))\n          rc++;\n    }\n\n    if (!allpats)\n      break;\n  }\n\n  return rc;\n}\n\n/* convert mutt pattern_t to IMAP SEARCH command containing only elements\n * that require full-text search (mutt already has what it needs for most\n * match types, and does a better job (eg server doesn't support regexps). */\nstatic int imap_compile_search (const pattern_t* pat, BUFFER* buf)\n{\n  if (! do_search (pat, 0))\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr (buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    if ((clauses = do_search (pat->child, 1)) > 0)\n    {\n      const pattern_t* clause = pat->child;\n\n      mutt_buffer_addch (buf, '(');\n\n      while (clauses)\n      {\n        if (do_search (clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr (buf, \"OR \");\n          clauses--;\n\n          if (imap_compile_search (clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch (buf, ' ');\n\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch (buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr (buf, \"HEADER \");\n\n        /* extract header name */\n        if (! (delim = strchr (pat->p.str, ':')))\n        {\n          mutt_error (_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        mutt_buffer_addch (buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string (term, sizeof (term), delim);\n        mutt_buffer_addstr (buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr (buf, \"BODY \");\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr (buf, \"TEXT \");\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}\n\nint imap_search (CONTEXT* ctx, const pattern_t* pat)\n{\n  BUFFER buf;\n  IMAP_DATA* idata = (IMAP_DATA*)ctx->data;\n  int i;\n\n  for (i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->matched = 0;\n\n  if (!do_search (pat, 1))\n    return 0;\n\n  mutt_buffer_init (&buf);\n  mutt_buffer_addstr (&buf, \"UID SEARCH \");\n  if (imap_compile_search (pat, &buf) < 0)\n  {\n    FREE (&buf.data);\n    return -1;\n  }\n  if (imap_exec (idata, buf.data, 0) < 0)\n  {\n    FREE (&buf.data);\n    return -1;\n  }\n\n  FREE (&buf.data);\n  return 0;\n}\n\nint imap_subscribe (char *path, int subscribe)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING*2];\n  char mbox[LONG_STRING];\n  int mblen;\n  BUFFER err;\n  IMAP_MBOX mx;\n\n  if (!mx_is_imap (path) || imap_parse_path (path, &mx) || !mx.mbox)\n  {\n    mutt_error (_(\"Bad mailbox name\"));\n    return -1;\n  }\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n    goto fail;\n\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n\n  if (option (OPTIMAPCHECKSUBSCRIBED))\n  {\n    mutt_buffer_init (&err);\n    err.dsize = STRING;\n    err.data = safe_malloc (err.dsize);\n    mblen = snprintf (mbox, sizeof (mbox), \"%smailboxes \",\n                      subscribe ? \"\" : \"un\");\n    imap_quote_string_and_backquotes (mbox + mblen, sizeof(mbox) - mblen,\n                                      path);\n    if (mutt_parse_rc_line (mbox, &err))\n      dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", err.data));\n    FREE (&err.data);\n  }\n\n  if (subscribe)\n    mutt_message (_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message (_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n\n  snprintf (buf, sizeof (buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec (idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message (_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message (_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE (&mx.mbox);\n  return 0;\n\nfail:\n  FREE (&mx.mbox);\n  return -1;\n}\n\n/* trim dest to the length of the longest prefix it shares with src,\n * returning the length of the trimmed string */\nstatic size_t\nlongest_common_prefix (char *dest, const char* src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while (pos < dlen && dest[pos] && dest[pos] == src[pos])\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/* look for IMAP URLs to complete from defined mailboxes. Could be extended\n * to complete over open connections and account/folder hooks too. */\nstatic int\nimap_complete_hosts (char *dest, size_t len)\n{\n  BUFFY* mailbox;\n  CONNECTION* conn;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_strlen (dest);\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (!mutt_strncmp (dest, mutt_b2s (mailbox->pathbuf), matchlen))\n    {\n      if (rc)\n      {\n        strfcpy (dest, mutt_b2s (mailbox->pathbuf), len);\n        rc = 0;\n      }\n      else\n        longest_common_prefix (dest, mutt_b2s (mailbox->pathbuf), matchlen, len);\n    }\n  }\n\n  for (conn = mutt_socket_head (); conn; conn = conn->next)\n  {\n    ciss_url_t url;\n    char urlstr[LONG_STRING];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl (&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_ciss_tostring (&url, urlstr, sizeof (urlstr), 0);\n    if (!mutt_strncmp (dest, urlstr, matchlen))\n    {\n      if (rc)\n      {\n        strfcpy (dest, urlstr, len);\n        rc = 0;\n      }\n      else\n        longest_common_prefix (dest, urlstr, matchlen, len);\n    }\n  }\n\n  return rc;\n}\n\n/* imap_complete: given a partial IMAP folder path, return a string which\n *   adds as much to the path as is unique */\nint imap_complete(char* dest, size_t dlen, const char* path)\n{\n  IMAP_DATA* idata;\n  char list[LONG_STRING];\n  char buf[LONG_STRING*2];\n  IMAP_LIST listresp;\n  char completion[LONG_STRING];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  IMAP_MBOX mx;\n  int rc;\n\n  if (imap_parse_path (path, &mx))\n  {\n    strfcpy (dest, path, dlen);\n    return imap_complete_hosts (dest, dlen);\n  }\n\n  /* don't open a new socket just for completion. Instead complete over\n   * known mailboxes/hooks/etc */\n  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NONEW)))\n  {\n    FREE (&mx.mbox);\n    strfcpy (dest, path, dlen);\n    return imap_complete_hosts (dest, dlen);\n  }\n\n  /* reformat path for IMAP list, and append wildcard */\n  /* don't use INBOX in place of \"\" */\n  if (mx.mbox && mx.mbox[0])\n    imap_fix_path (idata, mx.mbox, list, sizeof(list));\n  else\n    list[0] = '\\0';\n\n  /* fire off command */\n  snprintf (buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",\n            option (OPTIMAPLSUB) ? \"LSUB\" : \"LIST\", list);\n\n  imap_cmd_start (idata, buf);\n\n  /* and see what the results are */\n  strfcpy (completion, NONULL(mx.mbox), sizeof(completion));\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step (idata);\n\n    if (rc == IMAP_CMD_CONTINUE && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        strfcpy (completion, listresp.name, sizeof(completion));\n        matchlen = strlen (completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix (completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  }\n  while (rc == IMAP_CMD_CONTINUE);\n  idata->cmddata = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path (dest, dlen, &mx, completion);\n    mutt_pretty_mailbox (dest, dlen);\n\n    FREE (&mx.mbox);\n    return 0;\n  }\n\n  return -1;\n}\n\n/* imap_fast_trash: use server COPY command to copy deleted\n * messages to the trash folder.\n *   Return codes:\n *      -1: error\n *       0: success\n *       1: non-fatal error - try fetch/append */\nint imap_fast_trash (CONTEXT* ctx, char* dest)\n{\n  IMAP_DATA* idata;\n  char mbox[LONG_STRING];\n  char mmbox[LONG_STRING];\n  char prompt[LONG_STRING];\n  int n, rc;\n  IMAP_MBOX mx;\n  int triedcreate = 0;\n  BUFFER *sync_cmd = NULL;\n  int err_continue = MUTT_NO;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  if (imap_parse_path (dest, &mx))\n  {\n    dprint (1, (debugfile, \"imap_fast_trash: bad destination %s\\n\", dest));\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (!mutt_account_match (&(CTX_DATA->conn->account), &(mx.account)))\n  {\n    dprint (3, (debugfile, \"imap_fast_trash: %s not same server as %s\\n\",\n                dest, ctx->path));\n    return 1;\n  }\n\n  imap_fix_path (idata, mx.mbox, mbox, sizeof (mbox));\n  if (!*mbox)\n    strfcpy (mbox, \"INBOX\", sizeof (mbox));\n  imap_munge_mbox_name (idata, mmbox, sizeof (mmbox), mbox);\n\n  sync_cmd = mutt_buffer_new ();\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    if (ctx->hdrs[n]->active && ctx->hdrs[n]->changed &&\n        ctx->hdrs[n]->deleted && !ctx->hdrs[n]->purge)\n    {\n      rc = imap_sync_message_for_copy (idata, ctx->hdrs[n], sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        dprint (1, (debugfile, \"imap_fast_trash: could not sync\\n\"));\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset (idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);\n    if (!rc)\n    {\n      dprint (1, (debugfile, \"imap_fast_trash: No messages to trash\\n\"));\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      dprint (1, (debugfile, \"could not queue copy\\n\"));\n      goto out;\n    }\n    else if (!ctx->quiet)\n      mutt_message (_(\"Copying %d messages to %s...\"), rc, mbox);\n\n    /* let's get it on */\n    rc = imap_exec (idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        dprint (1, (debugfile, \"Already tried to create mailbox %s\\n\", mbox));\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (ascii_strncasecmp (imap_get_qualifier (idata->buf), \"[TRYCREATE]\", 11))\n        break;\n      dprint (3, (debugfile, \"imap_fast_trash: server suggests TRYCREATE\\n\"));\n      snprintf (prompt, sizeof (prompt), _(\"Create %s?\"), mbox);\n      if (option (OPTCONFIRMCREATE) && mutt_yesorno (prompt, 1) < 1)\n      {\n        mutt_clear_error ();\n        goto out;\n      }\n      if (imap_create_mailbox (idata, mbox) < 0)\n        break;\n      triedcreate = 1;\n    }\n  }\n  while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error (\"imap_fast_trash\", idata->buf);\n    goto out;\n  }\n\n  rc = 0;\n\nout:\n  mutt_buffer_free (&sync_cmd);\n  FREE (&mx.mbox);\n\n  return rc < 0 ? -1 : rc;\n}\n\nstruct mx_ops mx_imap_ops = {\n  .open = imap_open_mailbox,\n  .open_append = imap_open_mailbox_append,\n  .close = imap_close_mailbox,\n  .open_msg = imap_fetch_message,\n  .close_msg = imap_close_message,\n  .commit_msg = imap_commit_message,\n  .open_new_msg = imap_open_new_message,\n  .check = imap_check_mailbox_reopen,\n  .sync = NULL,      /* imap syncing is handled by imap_sync_mailbox */\n  .save_to_header_cache = imap_save_to_header_cache,\n};\n"], "fixing_code": ["/*\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n *\n *     This program is free software; you can redistribute it and/or modify\n *     it under the terms of the GNU General Public License as published by\n *     the Free Software Foundation; either version 2 of the License, or\n *     (at your option) any later version.\n *\n *     This program is distributed in the hope that it will be useful,\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *     GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with this program; if not, write to the Free Software\n *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n/* Support for IMAP4rev1, with the occasional nod to IMAP 4. */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"mutt.h\"\n#include \"mx.h\"\n#include \"mailbox.h\"\n#include \"globals.h\"\n#include \"sort.h\"\n#include \"browser.h\"\n#include \"imap_private.h\"\n#if defined(USE_SSL)\n# include \"mutt_ssl.h\"\n#endif\n#if defined(USE_ZLIB)\n# include \"mutt_zstrm.h\"\n#endif\n#include \"buffy.h\"\n#if USE_HCACHE\n#include \"hcache.h\"\n#endif\n\n#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n/* imap forward declarations */\nstatic char* imap_get_flags (LIST** hflags, char* s);\nstatic int imap_check_capabilities (IMAP_DATA* idata);\nstatic void imap_set_flag (IMAP_DATA* idata, int aclbit, int flag,\n\t\t\t   const char* str, char* flags, size_t flsize);\n\n/* imap_access: Check permissions on an IMAP mailbox.\n * TODO: ACL checks. Right now we assume if it exists we can\n *       mess with it. */\nint imap_access (const char* path)\n{\n  IMAP_DATA* idata;\n  IMAP_MBOX mx;\n  char buf[LONG_STRING*2];\n  char mailbox[LONG_STRING];\n  char mbox[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path (path, &mx))\n    return -1;\n\n  if (!(idata = imap_conn_find (&mx.account,\n                                option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));\n  if (!*mailbox)\n    strfcpy (mailbox, \"INBOX\", sizeof (mailbox));\n\n  /* we may already be in the folder we're checking */\n  if (!ascii_strcmp(idata->mailbox, mx.mbox))\n  {\n    FREE (&mx.mbox);\n    return 0;\n  }\n  FREE (&mx.mbox);\n\n  if (imap_mboxcache_get (idata, mailbox, 0))\n  {\n    dprint (3, (debugfile, \"imap_access: found %s in cache\\n\", mailbox));\n    return 0;\n  }\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mailbox);\n\n  if (mutt_bit_isset (idata->capabilities, IMAP4REV1))\n    snprintf (buf, sizeof (buf), \"STATUS %s (UIDVALIDITY)\", mbox);\n  else if (mutt_bit_isset (idata->capabilities, STATUS))\n    snprintf (buf, sizeof (buf), \"STATUS %s (UID-VALIDITY)\", mbox);\n  else\n  {\n    dprint (2, (debugfile, \"imap_access: STATUS not supported?\\n\"));\n    return -1;\n  }\n\n  if ((rc = imap_exec (idata, buf, IMAP_CMD_FAIL_OK)) < 0)\n  {\n    dprint (1, (debugfile, \"imap_access: Can't check STATUS of %s\\n\", mbox));\n    return rc;\n  }\n\n  return 0;\n}\n\nint imap_create_mailbox (IMAP_DATA* idata, char* mailbox)\n{\n  char buf[LONG_STRING*2], mbox[LONG_STRING];\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mailbox);\n  snprintf (buf, sizeof (buf), \"CREATE %s\", mbox);\n\n  if (imap_exec (idata, buf, 0) != 0)\n  {\n    mutt_error (_(\"CREATE failed: %s\"), imap_cmd_trailer (idata));\n    return -1;\n  }\n\n  return 0;\n}\n\nint imap_rename_mailbox (IMAP_DATA* idata, IMAP_MBOX* mx, const char* newname)\n{\n  char oldmbox[LONG_STRING];\n  char newmbox[LONG_STRING];\n  BUFFER *b;\n  int rc = 0;\n\n  imap_munge_mbox_name (idata, oldmbox, sizeof (oldmbox), mx->mbox);\n  imap_munge_mbox_name (idata, newmbox, sizeof (newmbox), newname);\n\n  b = mutt_buffer_pool_get ();\n  mutt_buffer_printf (b, \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec (idata, mutt_b2s (b), 0) != 0)\n    rc = -1;\n\n  mutt_buffer_pool_release (&b);\n\n  return rc;\n}\n\nint imap_delete_mailbox (CONTEXT* ctx, IMAP_MBOX mx)\n{\n  char buf[LONG_STRING*2], mbox[LONG_STRING];\n  IMAP_DATA *idata;\n\n  if (!ctx || !ctx->data)\n  {\n    if (!(idata = imap_conn_find (&mx.account,\n                                  option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n    {\n      FREE (&mx.mbox);\n      return -1;\n    }\n  }\n  else\n  {\n    idata = ctx->data;\n  }\n\n  imap_munge_mbox_name (idata, mbox, sizeof (mbox), mx.mbox);\n  snprintf (buf, sizeof (buf), \"DELETE %s\", mbox);\n\n  if (imap_exec ((IMAP_DATA*) idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* imap_logout_all: close all open connections. Quick and dirty until we can\n *   make sure we've got all the context we need. */\nvoid imap_logout_all (void)\n{\n  CONNECTION* conn;\n  CONNECTION* tmp;\n\n  conn = mutt_socket_head ();\n\n  while (conn)\n  {\n    tmp = conn->next;\n\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP && conn->fd >= 0)\n    {\n      mutt_message (_(\"Closing connection to %s...\"), conn->account.host);\n      imap_logout ((IMAP_DATA**) (void*) &conn->data);\n      mutt_clear_error ();\n      mutt_socket_free (conn);\n    }\n\n    conn = tmp;\n  }\n}\n\n/* imap_read_literal: read bytes bytes from server into file. Not explicitly\n *   buffered, relies on FILE buffering. NOTE: strips \\r from \\r\\n.\n *   Apparently even literals use \\r\\n-terminated strings ?! */\nint imap_read_literal (FILE* fp, IMAP_DATA* idata, unsigned int bytes, progress_t* pbar)\n{\n  unsigned int pos;\n  char c;\n\n  int r = 0;\n\n  dprint (2, (debugfile, \"imap_read_literal: reading %ld bytes\\n\", bytes));\n\n  for (pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar (idata->conn, &c) != 1)\n    {\n      dprint (1, (debugfile, \"imap_read_literal: error during read, %ld bytes read\\n\", pos));\n      idata->status = IMAP_FATAL;\n\n      return -1;\n    }\n\n#if 1\n    if (r == 1 && c != '\\n')\n      fputc ('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = 1;\n      continue;\n    }\n    else\n      r = 0;\n#endif\n    fputc (c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update (pbar, pos, -1);\n#ifdef DEBUG\n    if (debuglevel >= IMAP_LOG_LTRL)\n      fputc (c, debugfile);\n#endif\n  }\n\n  return 0;\n}\n\n/* imap_expunge_mailbox: Purge IMAP portion of expunged messages from the\n *   context. Must not be done while something has a handle on any headers\n *   (eg inside pager or editor). That is, check IMAP_REOPEN_ALLOW. */\nvoid imap_expunge_mailbox (IMAP_DATA* idata)\n{\n  HEADER* h;\n  int i, cacheno;\n  short old_sort;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n\n  old_sort = Sort;\n  Sort = SORT_ORDER;\n  mutt_sort_headers (idata->ctx, 0);\n\n  for (i = 0; i < idata->ctx->msgcount; i++)\n  {\n    h = idata->ctx->hdrs[i];\n\n    if (h->index == INT_MAX)\n    {\n      dprint (2, (debugfile, \"Expunging message UID %u.\\n\", HEADER_DATA (h)->uid));\n\n      h->active = 0;\n      idata->ctx->size -= h->content->length;\n\n      imap_cache_del (idata, h);\n#if USE_HCACHE\n      imap_hcache_del (idata, HEADER_DATA(h)->uid);\n#endif\n\n      /* free cached body from disk, if necessary */\n      cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n      if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&\n\t  idata->cache[cacheno].path)\n      {\n\tunlink (idata->cache[cacheno].path);\n\tFREE (&idata->cache[cacheno].path);\n      }\n\n      int_hash_delete (idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);\n\n      imap_free_header_data ((IMAP_HEADER_DATA**)&h->data);\n    }\n    else\n    {\n      h->index = i;\n      /* Mutt has several places where it turns off h->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The mx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.\n       */\n      h->active = 1;\n    }\n  }\n\n#if USE_HCACHE\n  imap_hcache_close (idata);\n#endif\n\n  /* We may be called on to expunge at any time. We can't rely on the caller\n   * to always know to rethread */\n  mx_update_tables (idata->ctx, 0);\n  Sort = old_sort;\n  mutt_sort_headers (idata->ctx, 1);\n}\n\n/* imap_check_capabilities: make sure we can log in to this server. */\nstatic int imap_check_capabilities (IMAP_DATA* idata)\n{\n  if (imap_exec (idata, \"CAPABILITY\", 0) != 0)\n  {\n    imap_error (\"imap_check_capabilities\", idata->buf);\n    return -1;\n  }\n\n  if (!(mutt_bit_isset(idata->capabilities,IMAP4) ||\n        mutt_bit_isset(idata->capabilities,IMAP4REV1)))\n  {\n    mutt_error _(\"This IMAP server is ancient. Mutt does not work with it.\");\n    mutt_sleep (2);\t/* pause a moment to let the user see the error */\n\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_conn_find\n *\n * Returns an authenticated IMAP connection matching account, or NULL\n * if that isn't possible.\n *\n * flags:\n *   MUTT_IMAP_CONN_NONEW    - must be an existing connection\n *   MUTT_IMAP_CONN_NOSELECT - must not be in the IMAP_SELECTED state.\n */\nIMAP_DATA* imap_conn_find (const ACCOUNT* account, int flags)\n{\n  CONNECTION* conn = NULL;\n  ACCOUNT* creds = NULL;\n  IMAP_DATA* idata = NULL;\n  int new = 0;\n\n  while ((conn = mutt_conn_find (conn, account)))\n  {\n    if (!creds)\n      creds = &conn->account;\n    else\n      memcpy (&conn->account, creds, sizeof (ACCOUNT));\n\n    idata = (IMAP_DATA*)conn->data;\n    if (flags & MUTT_IMAP_CONN_NONEW)\n    {\n      if (!idata)\n      {\n        /* This should only happen if we've come to the end of the list */\n        mutt_socket_free (conn);\n        return NULL;\n      }\n      else if (idata->state < IMAP_AUTHENTICATED)\n        continue;\n    }\n    if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)\n      continue;\n    if (idata && idata->status == IMAP_FATAL)\n      continue;\n    break;\n  }\n  if (!conn)\n    return NULL; /* this happens when the initial connection fails */\n\n  /* The current connection is a new connection */\n  if (!idata)\n  {\n    idata = imap_new_idata ();\n    conn->data = idata;\n    idata->conn = conn;\n    new = 1;\n  }\n\n  if (idata->state == IMAP_DISCONNECTED)\n    imap_open_connection (idata);\n  if (idata->state == IMAP_CONNECTED)\n  {\n    if (!imap_authenticate (idata))\n    {\n      idata->state = IMAP_AUTHENTICATED;\n      FREE (&idata->capstr);\n      new = 1;\n      if (idata->conn->ssf)\n\tdprint (2, (debugfile, \"Communication encrypted at %d bits\\n\",\n\t\t    idata->conn->ssf));\n    }\n    else\n      mutt_account_unsetpass (&idata->conn->account);\n  }\n  if (new && idata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec (idata, \"CAPABILITY\", IMAP_CMD_FAIL_OK);\n\n#if defined(USE_ZLIB)\n    /* RFC 4978 */\n    if (mutt_bit_isset (idata->capabilities, COMPRESS_DEFLATE))\n    {\n      if (option (OPTIMAPDEFLATE) &&\n\t  imap_exec (idata, \"COMPRESS DEFLATE\", IMAP_CMD_FAIL_OK) == 0)\n\tmutt_zstrm_wrap_conn (idata->conn);\n    }\n#endif\n\n    /* enable RFC6855, if the server supports that */\n    if (mutt_bit_isset (idata->capabilities, ENABLE))\n      imap_exec (idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n\n    /* enable QRESYNC.  Advertising QRESYNC also means CONDSTORE\n     * is supported (even if not advertised), so flip that bit. */\n    if (mutt_bit_isset (idata->capabilities, QRESYNC))\n    {\n      mutt_bit_set (idata->capabilities, CONDSTORE);\n      if (option (OPTIMAPQRESYNC))\n        imap_exec (idata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);\n    }\n\n    /* get root delimiter, '/' as default */\n    idata->delim = '/';\n    imap_exec (idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n    if (option (OPTIMAPCHECKSUBSCRIBED))\n      imap_exec (idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec (idata, NULL, IMAP_CMD_FAIL_OK);\n  }\n\n  if (idata->state < IMAP_AUTHENTICATED)\n    return NULL;\n\n  return idata;\n}\n\nint imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (!idata->conn->ssf)\n    {\n      if (option(OPTSSLFORCETLS) ||\n          (query_quadoption (OPT_SSLSTARTTLS,\n                             _(\"Abort unencrypted PREAUTH connection?\")) != MUTT_NO))\n      {\n        mutt_error _(\"Encrypted connection unavailable\");\n        mutt_sleep (1);\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}\n\nvoid imap_close_connection(IMAP_DATA* idata)\n{\n  if (idata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close (idata->conn);\n    idata->state = IMAP_DISCONNECTED;\n  }\n  idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = 0;\n  memset (idata->cmds, 0, sizeof (IMAP_COMMAND) * idata->cmdslots);\n}\n\n/* imap_get_flags: Make a simple list out of a FLAGS response.\n *   return stream following FLAGS response */\nstatic char* imap_get_flags (LIST** hflags, char* s)\n{\n  LIST* flags;\n  char* flag_word;\n  char ctmp;\n\n  /* sanity-check string */\n  if (ascii_strncasecmp (\"FLAGS\", s, 5) != 0)\n  {\n    dprint (1, (debugfile, \"imap_get_flags: not a FLAGS response: %s\\n\",\n                s));\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    dprint (1, (debugfile, \"imap_get_flags: bogus FLAGS response: %s\\n\",\n                s));\n    return NULL;\n  }\n\n  /* create list, update caller's flags handle */\n  flags = mutt_new_list();\n  *hflags = flags;\n\n  while (*s && *s != ')')\n  {\n    s++;\n    SKIPWS(s);\n    flag_word = s;\n    while (*s && (*s != ')') && !ISSPACE (*s))\n      s++;\n    ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_add_list (flags, flag_word);\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    dprint (1, (debugfile,\n                \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s));\n    mutt_free_list (hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\nstatic int imap_open_mailbox (CONTEXT* ctx)\n{\n  IMAP_DATA *idata;\n  IMAP_STATUS* status;\n  char buf[LONG_STRING];\n  char bufout[LONG_STRING*2];\n  int count = 0;\n  IMAP_MBOX mx, pmx;\n  int rc;\n  const char *condstore;\n\n  if (imap_parse_path (ctx->path, &mx))\n  {\n    mutt_error (_(\"%s is an invalid IMAP path\"), ctx->path);\n    return -1;\n  }\n\n  /* we require a connection which isn't currently in IMAP_SELECTED state */\n  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NOSELECT)))\n    goto fail_noidata;\n\n  /* once again the context is new */\n  ctx->data = idata;\n\n  /* Clean up path and replace the one in the ctx */\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n  FREE(&(idata->mailbox));\n  idata->mailbox = safe_strdup (buf);\n  imap_qualify_path (buf, sizeof (buf), &mx, idata->mailbox);\n\n  FREE (&(ctx->path));\n  FREE (&(ctx->realpath));\n  ctx->path = safe_strdup (buf);\n  ctx->realpath = safe_strdup (ctx->path);\n\n  idata->ctx = ctx;\n\n  /* clear mailbox status */\n  idata->status = 0;\n  memset (idata->ctx->rights, 0, sizeof (idata->ctx->rights));\n  idata->newMailCount = 0;\n  idata->max_msn = 0;\n\n  if (!ctx->quiet)\n    mutt_message (_(\"Selecting %s...\"), idata->mailbox);\n  imap_munge_mbox_name (idata, buf, sizeof(buf), idata->mailbox);\n\n  /* pipeline ACL test */\n  if (mutt_bit_isset (idata->capabilities, ACL))\n  {\n    snprintf (bufout, sizeof (bufout), \"MYRIGHTS %s\", buf);\n    imap_exec (idata, bufout, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_LOOKUP);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_READ);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_SEEN);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_INSERT);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_POST);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);\n    mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);\n  }\n  /* pipeline the postponed count if possible */\n  pmx.mbox = NULL;\n  if (mx_is_imap (Postponed) && !imap_parse_path (Postponed, &pmx)\n      && mutt_account_match (&pmx.account, &mx.account))\n    imap_status (Postponed, 1);\n  FREE (&pmx.mbox);\n\n#if USE_HCACHE\n  if (mutt_bit_isset (idata->capabilities, CONDSTORE) &&\n      option (OPTIMAPCONDSTORE))\n    condstore = \" (CONDSTORE)\";\n  else\n#endif\n    condstore = \"\";\n\n  snprintf (bufout, sizeof (bufout), \"%s %s%s\",\n            ctx->readonly ? \"EXAMINE\" : \"SELECT\",\n            buf, condstore);\n\n  idata->state = IMAP_SELECTED;\n\n  imap_cmd_start (idata, bufout);\n\n  status = imap_mboxcache_get (idata, idata->mailbox, 1);\n\n  do\n  {\n    char *pc;\n\n    if ((rc = imap_cmd_step (idata)) != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (ascii_strncasecmp (\"FLAGS\", pc, 5) == 0)\n    {\n      /* don't override PERMANENTFLAGS */\n      if (!idata->flags)\n      {\n\tdprint (3, (debugfile, \"Getting mailbox FLAGS\\n\"));\n\tif ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\t  goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (ascii_strncasecmp (\"OK [PERMANENTFLAGS\", pc, 18) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox PERMANENTFLAGS\\n\"));\n      /* safe to call on NULL */\n      mutt_free_list (&(idata->flags));\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      if ((pc = imap_get_flags (&(idata->flags), pc)) == NULL)\n\tgoto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (ascii_strncasecmp (\"OK [UIDVALIDITY\", pc, 14) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDVALIDITY\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uid_validity) < 0)\n        goto fail;\n      status->uidvalidity = idata->uid_validity;\n    }\n    else if (ascii_strncasecmp (\"OK [UIDNEXT\", pc, 11) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox UIDNEXT\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoui (pc, &idata->uidnext) < 0)\n        goto fail;\n      status->uidnext = idata->uidnext;\n    }\n    else if (ascii_strncasecmp (\"OK [HIGHESTMODSEQ\", pc, 17) == 0)\n    {\n      dprint (3, (debugfile, \"Getting mailbox HIGHESTMODSEQ\\n\"));\n      pc += 3;\n      pc = imap_next_word (pc);\n      if (mutt_atoull (pc, &idata->modseq) < 0)\n        goto fail;\n      status->modseq = idata->modseq;\n    }\n    else if (ascii_strncasecmp (\"OK [NOMODSEQ\", pc, 12) == 0)\n    {\n      dprint (3, (debugfile, \"Mailbox has NOMODSEQ set\\n\"));\n      status->modseq = idata->modseq = 0;\n    }\n    else\n    {\n      pc = imap_next_word (pc);\n      if (!ascii_strncasecmp (\"EXISTS\", pc, 6))\n      {\n\tcount = idata->newMailCount;\n\tidata->newMailCount = 0;\n      }\n    }\n  }\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_NO)\n  {\n    char *s;\n    s = imap_next_word (idata->buf); /* skip seq */\n    s = imap_next_word (s); /* Skip response */\n    mutt_error (\"%s\", s);\n    mutt_sleep (2);\n    goto fail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if (!ascii_strncasecmp (imap_get_qualifier (idata->buf), \"[READ-ONLY]\", 11) &&\n      !mutt_bit_isset (idata->capabilities, ACL))\n  {\n    dprint (2, (debugfile, \"Mailbox is read-only.\\n\"));\n    ctx->readonly = 1;\n  }\n\n#ifdef DEBUG\n  /* dump the mailbox flags we've found */\n  if (debuglevel > 2)\n  {\n    if (!idata->flags)\n      dprint (3, (debugfile, \"No folder flags found\\n\"));\n    else\n    {\n      LIST* t = idata->flags;\n\n      dprint (3, (debugfile, \"Mailbox flags: \"));\n\n      t = t->next;\n      while (t)\n      {\n        dprint (3, (debugfile, \"[%s] \", t->data));\n        t = t->next;\n      }\n      dprint (3, (debugfile, \"\\n\"));\n    }\n  }\n#endif\n\n  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))\n    ctx->readonly = 1;\n\n  ctx->hdrmax = count;\n  ctx->hdrs = safe_calloc (count, sizeof (HEADER *));\n  ctx->v2r = safe_calloc (count, sizeof (int));\n  ctx->msgcount = 0;\n\n  if (count && (imap_read_headers (idata, 1, count, 1) < 0))\n  {\n    mutt_error _(\"Error opening mailbox\");\n    mutt_sleep (1);\n    goto fail;\n  }\n\n  imap_disallow_reopen (ctx);\n\n  dprint (2, (debugfile, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount));\n  FREE (&mx.mbox);\n  return 0;\n\nfail:\n  if (idata->state == IMAP_SELECTED)\n    idata->state = IMAP_AUTHENTICATED;\nfail_noidata:\n  FREE (&mx.mbox);\n  return -1;\n}\n\nstatic int imap_open_mailbox_append (CONTEXT *ctx, int flags)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING];\n  char mailbox[LONG_STRING];\n  IMAP_MBOX mx;\n  int rc;\n\n  if (imap_parse_path (ctx->path, &mx))\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  ctx->data = idata;\n\n  imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));\n  if (!*mailbox)\n    strfcpy (mailbox, \"INBOX\", sizeof (mailbox));\n  FREE (&mx.mbox);\n\n  if ((rc = imap_access (ctx->path)) == 0)\n    return 0;\n\n  if (rc == -1)\n    return -1;\n\n  snprintf (buf, sizeof (buf), _(\"Create %s?\"), mailbox);\n  if (option (OPTCONFIRMCREATE) && mutt_yesorno (buf, 1) < 1)\n    return -1;\n\n  if (imap_create_mailbox (idata, mailbox) < 0)\n    return -1;\n\n  return 0;\n}\n\n/* imap_logout: Gracefully log out of server. */\nvoid imap_logout (IMAP_DATA** idata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  (*idata)->status = IMAP_BYE;\n  imap_cmd_start (*idata, \"LOGOUT\");\n  if (ImapPollTimeout <= 0 ||\n      mutt_socket_poll ((*idata)->conn, ImapPollTimeout) != 0)\n  {\n    while (imap_cmd_step (*idata) == IMAP_CMD_CONTINUE)\n      ;\n  }\n\n  mutt_socket_close ((*idata)->conn);\n  imap_free_idata (idata);\n}\n\nstatic int imap_open_new_message (MESSAGE *msg, CONTEXT *dest, HEADER *hdr)\n{\n  BUFFER *tmp = NULL;\n  int rc = -1;\n\n  tmp = mutt_buffer_pool_get ();\n  mutt_buffer_mktemp (tmp);\n  if ((msg->fp = safe_fopen (mutt_b2s (tmp), \"w\")) == NULL)\n  {\n    mutt_perror (mutt_b2s (tmp));\n    goto cleanup;\n  }\n\n  msg->path = safe_strdup (mutt_b2s (tmp));\n  rc = 0;\n\ncleanup:\n  mutt_buffer_pool_release (&tmp);\n  return rc;\n}\n\n/* imap_set_flag: append str to flags if we currently have permission\n *   according to aclbit */\nstatic void imap_set_flag (IMAP_DATA* idata, int aclbit, int flag,\n                           const char *str, char *flags, size_t flsize)\n{\n  if (mutt_bit_isset (idata->ctx->rights, aclbit))\n    if (flag && imap_has_flag (idata->flags, str))\n      safe_strcat (flags, flsize, str);\n}\n\n/* imap_has_flag: do a caseless comparison of the flag against a flag list,\n*   return 1 if found or flag list has '\\*', 0 otherwise */\nint imap_has_flag (LIST* flag_list, const char* flag)\n{\n  if (!flag_list)\n    return 0;\n\n  flag_list = flag_list->next;\n  while (flag_list)\n  {\n    if (!ascii_strncasecmp (flag_list->data, flag, strlen (flag_list->data)))\n      return 1;\n\n    if (!ascii_strncmp (flag_list->data, \"\\\\*\", strlen (flag_list->data)))\n      return 1;\n\n    flag_list = flag_list->next;\n  }\n\n  return 0;\n}\n\n/* Note: headers must be in SORT_ORDER. See imap_exec_msgset for args.\n * Pos is an opaque pointer a la strtok. It should be 0 at first call. */\nstatic int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,\n                              int changed, int invert, int* pos)\n{\n  HEADER** hdrs = idata->ctx->hdrs;\n  int count = 0;\t/* number of messages in message set */\n  int match = 0;\t/* whether current message matches flag condition */\n  unsigned int setstart = 0;\t/* start of current message range */\n  int n;\n  int started = 0;\n\n  hdrs = idata->ctx->hdrs;\n\n  for (n = *pos;\n       (n < idata->ctx->msgcount) && (mutt_buffer_len (buf) < IMAP_MAX_CMDLEN);\n       n++)\n  {\n    match = 0;\n    /* don't include pending expunged messages.\n     *\n     * TODO: can we unset active in cmd_parse_expunge() and\n     * cmd_parse_vanished() instead of checking for index != INT_MAX. */\n    if (hdrs[n]->active && (hdrs[n]->index != INT_MAX))\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)\n            match = invert ^ hdrs[n]->deleted;\n\t  break;\n        case MUTT_FLAG:\n          if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)\n            match = invert ^ hdrs[n]->flagged;\n\t  break;\n        case MUTT_OLD:\n          if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)\n            match = invert ^ hdrs[n]->old;\n\t  break;\n        case MUTT_READ:\n          if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)\n            match = invert ^ hdrs[n]->read;\n\t  break;\n        case MUTT_REPLIED:\n          if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)\n            match = invert ^ hdrs[n]->replied;\n\t  break;\n\n        case MUTT_TAG:\n\t  if (hdrs[n]->tagged)\n\t    match = 1;\n\t  break;\n        case MUTT_TRASH:\n          if (hdrs[n]->deleted && !hdrs[n]->purge)\n            match = 1;\n\t  break;\n      }\n\n    if (match && (!changed || hdrs[n]->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = HEADER_DATA (hdrs[n])->uid;\n        if (started == 0)\n\t{\n\t  mutt_buffer_add_printf (buf, \"%u\", HEADER_DATA (hdrs[n])->uid);\n\t  started = 1;\n\t}\n        else\n\t  mutt_buffer_add_printf (buf, \",%u\", HEADER_DATA (hdrs[n])->uid);\n      }\n      /* tie up if the last message also matches */\n      else if (n == idata->ctx->msgcount-1)\n\tmutt_buffer_add_printf (buf, \":%u\", HEADER_DATA (hdrs[n])->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount-1))\n    {\n      if (HEADER_DATA (hdrs[n-1])->uid > setstart)\n\tmutt_buffer_add_printf (buf, \":%u\", HEADER_DATA (hdrs[n-1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/* Prepares commands for all messages matching conditions (must be flushed\n * with imap_exec)\n * Params:\n *   idata: IMAP_DATA containing context containing header set\n *   pre, post: commands are of the form \"%s %s %s %s\", tag,\n *     pre, message set, post\n *   flag: enum of flag type on which to filter\n *   changed: include only changed messages in message set\n *   invert: invert sense of flag, eg MUTT_READ matches unread messages\n * Returns: number of matched messages, or -1 on failure */\nint imap_exec_msgset (IMAP_DATA* idata, const char* pre, const char* post,\n                      int flag, int changed, int invert)\n{\n  HEADER** hdrs = NULL;\n  short oldsort;\n  BUFFER* cmd;\n  int pos;\n  int rc;\n  int count = 0, reopen_set = 0;\n\n  cmd = mutt_buffer_new ();\n\n  /* Unlike imap_sync_mailbox(), this function can be called when\n   * IMAP_REOPEN_ALLOW is not set.  In that case, the caller isn't\n   * prepared to handle context changes.  Resorting may not always\n   * give the same order, so we must make a copy.\n   *\n   * See the comment in imap_sync_mailbox() for the dangers of running\n   * even queued execs while reopen is set.  To prevent memory\n   * corruption and data loss we must disable reopen for the duration\n   * of the swapped hdrs.\n   */\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n    reopen_set = 1;\n  }\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = idata->ctx->hdrs;\n    idata->ctx->hdrs = safe_malloc (idata->ctx->msgcount * sizeof (HEADER*));\n    memcpy (idata->ctx->hdrs, hdrs, idata->ctx->msgcount * sizeof (HEADER*));\n\n    Sort = SORT_ORDER;\n    qsort (idata->ctx->hdrs, idata->ctx->msgcount, sizeof (HEADER*),\n           mutt_get_sort_func (SORT_ORDER));\n  }\n\n  pos = 0;\n\n  do\n  {\n    mutt_buffer_clear (cmd);\n    mutt_buffer_add_printf (cmd, \"%s \", pre);\n    rc = imap_make_msg_set (idata, cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_add_printf (cmd, \" %s\", post);\n      if (imap_exec (idata, cmd->data, IMAP_CMD_QUEUE))\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  }\n  while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_free (&cmd);\n  if ((oldsort != Sort) || hdrs)\n  {\n    Sort = oldsort;\n    FREE (&idata->ctx->hdrs);\n    idata->ctx->hdrs = hdrs;\n  }\n  if (reopen_set)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n\n  return rc;\n}\n\n/* returns 0 if mutt's flags match cached server flags:\n * EXCLUDING the deleted flag. */\nstatic int compare_flags_for_copy (HEADER* h)\n{\n  IMAP_HEADER_DATA* hd = (IMAP_HEADER_DATA*)h->data;\n\n  if (h->read != hd->read)\n    return 1;\n  if (h->old != hd->old)\n    return 1;\n  if (h->flagged != hd->flagged)\n    return 1;\n  if (h->replied != hd->replied)\n    return 1;\n\n  return 0;\n}\n\n/* Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n * NOTE: This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy (IMAP_DATA *idata, HEADER *hdr, BUFFER *cmd,\n                                int *err_continue)\n{\n  char flags[LONG_STRING];\n  char uid[11];\n\n  if (!compare_flags_for_copy (hdr))\n  {\n    if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n      hdr->changed = 0;\n    return 0;\n  }\n\n  snprintf (uid, sizeof (uid), \"%u\", HEADER_DATA(hdr)->uid);\n  mutt_buffer_clear (cmd);\n  mutt_buffer_addstr (cmd, \"UID STORE \");\n  mutt_buffer_addstr (cmd, uid);\n\n  flags[0] = '\\0';\n\n  imap_set_flag (idata, MUTT_ACL_SEEN, hdr->read, \"\\\\Seen \",\n\t\t flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->old,\n                 \"Old \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->flagged,\n\t\t \"\\\\Flagged \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->replied,\n\t\t \"\\\\Answered \", flags, sizeof (flags));\n  imap_set_flag (idata, MUTT_ACL_DELETE, HEADER_DATA(hdr)->deleted,\n                 \"\\\\Deleted \", flags, sizeof (flags));\n\n  /* now make sure we don't lose custom tags */\n  if (mutt_bit_isset (idata->ctx->rights, MUTT_ACL_WRITE))\n    imap_add_keywords (flags, hdr, idata->flags, sizeof (flags));\n\n  mutt_remove_trailing_ws (flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (!*flags)\n  {\n    imap_set_flag (idata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof (flags));\n    imap_set_flag (idata, MUTT_ACL_DELETE, !HEADER_DATA(hdr)->deleted,\n                   \"\\\\Deleted \", flags, sizeof (flags));\n\n    mutt_remove_trailing_ws (flags);\n\n    mutt_buffer_addstr (cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr (cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr (cmd, flags);\n  mutt_buffer_addstr (cmd, \")\");\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec (idata, cmd->data, 0) != 0) &&\n      err_continue && (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue (\"imap_sync_message: STORE failed\",\n\t\t\t\t   idata->buf);\n    if (*err_continue != MUTT_YES)\n      return -1;\n  }\n\n  if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n    hdr->changed = 0;\n\n  return 0;\n}\n\nstatic int sync_helper (IMAP_DATA* idata, int right, int flag, const char* name)\n{\n  int count = 0;\n  int rc;\n  char buf[LONG_STRING];\n\n  if (!idata->ctx)\n    return -1;\n\n  if (!mutt_bit_isset (idata->ctx->rights, right))\n    return 0;\n\n  if (right == MUTT_ACL_WRITE && !imap_has_flag (idata->flags, name))\n    return 0;\n\n  snprintf (buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  if ((rc = imap_exec_msgset (idata, \"UID STORE\", buf, flag, 1, 0)) < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  if ((rc = imap_exec_msgset (idata, \"UID STORE\", buf, flag, 1, 1)) < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/* update the IMAP server to reflect message changes done within mutt.\n * Arguments\n *   ctx: the current context\n *   expunge: 0 or 1 - do expunge?\n */\nint imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)\n{\n  IMAP_DATA* idata;\n  CONTEXT* appendctx = NULL;\n  HEADER* h;\n  HEADER** hdrs = NULL;\n  int oldsort;\n  int n;\n  int rc, quickdel_rc = 0;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  if (idata->state < IMAP_SELECTED)\n  {\n    dprint (2, (debugfile, \"imap_sync_mailbox: no mailbox selected\\n\"));\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen (ctx);\n\n  if ((rc = imap_check_mailbox (ctx, index_hint, 0)) != 0)\n    goto out;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && mutt_bit_isset (ctx->rights, MUTT_ACL_DELETE))\n  {\n    if ((quickdel_rc = imap_exec_msgset (idata,\n                                         \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                                         MUTT_DELETED, 1, 0)) < 0)\n    {\n      rc = quickdel_rc;\n      mutt_error (_(\"Expunge failed\"));\n      mutt_sleep (1);\n      goto out;\n    }\n\n    if (quickdel_rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (n = 0; n < ctx->msgcount; n++)\n        if (ctx->hdrs[n]->deleted && ctx->hdrs[n]->changed)\n          ctx->hdrs[n]->active = 0;\n      if (!ctx->quiet)\n        mutt_message (_(\"Marking %d messages deleted...\"), quickdel_rc);\n    }\n  }\n\n#if USE_HCACHE\n  idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    h = ctx->hdrs[n];\n\n    if (h->deleted)\n    {\n      imap_cache_del (idata, h);\n#if USE_HCACHE\n      imap_hcache_del (idata, HEADER_DATA(h)->uid);\n#endif\n    }\n\n    if (h->active && h->changed)\n    {\n#if USE_HCACHE\n      imap_hcache_put (idata, h);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      /* TODO: why the h->env check? */\n      if ((h->env && h->env->changed) || h->attach_del)\n      {\n        /* NOTE and TODO:\n         *\n         * The mx_open_mailbox() in append mode below merely hijacks an existing\n         * idata; it doesn't reset idata->ctx.  imap_append_message() ends up\n         * using (borrowing) the same idata we are using.\n         *\n         * Right after the APPEND operation finishes, the server can send an\n         * EXISTS notifying of the new message.  Then, while still inside\n         * imap_append_message(), imap_cmd_step() -> imap_cmd_finish() will\n         * call imap_read_headers() to download those (because the idata's\n         * reopen_allow is set).\n         *\n         * The imap_read_headers() will open (and clobber) the idata->hcache we\n         * just opened above, then close it.\n         *\n         * The easy and less dangerous fix done here (for a stable branch bug\n         * fix) is to close and reopen the header cache around the operation.\n         *\n         * A better fix would be allowing idata->hcache reuse.  When that is\n         * done, the close/reopen in read_headers_condstore_qresync_updates()\n         * can also be removed. */\n#if USE_HCACHE\n        imap_hcache_close (idata);\n#endif\n        if (!ctx->quiet)\n          mutt_message (_(\"Saving changed messages... [%d/%d]\"), n+1,\n                        ctx->msgcount);\n\tif (!appendctx)\n\t  appendctx = mx_open_mailbox (ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);\n\tif (!appendctx)\n\t  dprint (1, (debugfile, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\"));\n\telse\n\t  _mutt_save_message (h, appendctx, 1, 0, 0);\n        /* TODO: why the check for h->env?  Is this possible? */\n        if (h->env)\n          h->env->changed = 0;\n#if USE_HCACHE\n        idata->hcache = imap_hcache_open (idata, NULL);\n#endif\n      }\n    }\n  }\n\n#if USE_HCACHE\n  imap_hcache_close (idata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset.\n   *\n   * Note: sync_helper() may trigger an imap_exec() if the queue fills\n   * up.  Because IMAP_REOPEN_ALLOW is set, this may result in new\n   * messages being downloaded or an expunge being processed.  For new\n   * messages this would both result in memory corruption (since we're\n   * alloc'ing msgcount instead of hdrmax pointers) and data loss of\n   * the new messages.  For an expunge, the restored hdrs would point\n   * to headers that have been freed.\n   *\n   * Since reopen is allowed, we could change this to call\n   * mutt_sort_headers() before and after instead, but the double sort\n   * is noticeably slower.\n   *\n   * So instead, just turn off reopen_allow for the duration of the\n   * swapped hdrs.  The imap_exec() below flushes the queue out,\n   * giving the opportunity to process any reopen events.\n   */\n  imap_disallow_reopen (ctx);\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = ctx->hdrs;\n    ctx->hdrs = safe_malloc (ctx->msgcount * sizeof (HEADER*));\n    memcpy (ctx->hdrs, hdrs, ctx->msgcount * sizeof (HEADER*));\n\n    Sort = SORT_ORDER;\n    qsort (ctx->hdrs, ctx->msgcount, sizeof (HEADER*),\n           mutt_get_sort_func (SORT_ORDER));\n  }\n\n  rc = sync_helper (idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if ((oldsort != Sort) || hdrs)\n  {\n    Sort = oldsort;\n    FREE (&ctx->hdrs);\n    ctx->hdrs = hdrs;\n  }\n  imap_allow_reopen (ctx);\n\n  /* Flush the queued flags if any were changed in sync_helper.\n   * The real (non-flag) changes loop might have flushed quickdel_rc\n   * queued commands, so we double check the cmdbuf isn't empty. */\n  if (((rc > 0) || (quickdel_rc > 0)) && mutt_buffer_len (idata->cmdbuf))\n    if (imap_exec (idata, NULL, 0) != IMAP_CMD_OK)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (ctx->closing)\n    {\n      if (mutt_yesorno (_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)\n      {\n        rc = 0;\n        idata->state = IMAP_AUTHENTICATED;\n        goto out;\n      }\n    }\n    else\n      mutt_error _(\"Error saving flags\");\n    rc = -1;\n    goto out;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    HEADER_DATA(ctx->hdrs[n])->deleted = ctx->hdrs[n]->deleted;\n    HEADER_DATA(ctx->hdrs[n])->flagged = ctx->hdrs[n]->flagged;\n    HEADER_DATA(ctx->hdrs[n])->old = ctx->hdrs[n]->old;\n    HEADER_DATA(ctx->hdrs[n])->read = ctx->hdrs[n]->read;\n    HEADER_DATA(ctx->hdrs[n])->replied = ctx->hdrs[n]->replied;\n    ctx->hdrs[n]->changed = 0;\n  }\n  ctx->changed = 0;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !(ctx->closing) &&\n      mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    if (!ctx->quiet)\n      mutt_message _(\"Expunging messages from server...\");\n    /* Set expunge bit so we don't get spurious reopened messages */\n    idata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec (idata, \"EXPUNGE\", 0) != 0)\n    {\n      idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error (_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);\n      rc = -1;\n      goto out;\n    }\n    idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && ctx->closing)\n  {\n    imap_exec (idata, \"CLOSE\", IMAP_CMD_QUEUE);\n    idata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (option (OPTMESSAGECACHECLEAN))\n    imap_cache_clean (idata);\n\n  rc = 0;\n\nout:\n  imap_disallow_reopen (ctx);\n  if (appendctx)\n  {\n    mx_fastclose_mailbox (appendctx);\n    FREE (&appendctx);\n  }\n  return rc;\n}\n\n/* imap_close_mailbox: clean up IMAP data in CONTEXT */\nint imap_close_mailbox (CONTEXT* ctx)\n{\n  IMAP_DATA* idata;\n  int i;\n\n  idata = (IMAP_DATA*) ctx->data;\n  /* Check to see if the mailbox is actually open */\n  if (!idata)\n    return 0;\n\n  /* imap_open_mailbox_append() borrows the IMAP_DATA temporarily,\n   * just for the connection, but does not set idata->ctx to the\n   * open-append ctx.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up idata.  Otherwise, we don't want to\n   * touch idata - it's still being used.\n   */\n  if (ctx == idata->ctx)\n  {\n    if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)\n    {\n      /* mx_close_mailbox won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (!ctx->deleted)\n        imap_exec (idata, \"CLOSE\", IMAP_CMD_QUEUE);\n      idata->state = IMAP_AUTHENTICATED;\n    }\n\n    idata->reopen = 0;\n    FREE (&(idata->mailbox));\n    mutt_free_list (&idata->flags);\n    idata->ctx = NULL;\n\n    hash_destroy (&idata->uid_hash, NULL);\n    FREE (&idata->msn_index);\n    idata->msn_index_size = 0;\n    idata->max_msn = 0;\n\n    for (i = 0; i < IMAP_CACHE_LEN; i++)\n    {\n      if (idata->cache[i].path)\n      {\n        unlink (idata->cache[i].path);\n        FREE (&idata->cache[i].path);\n      }\n    }\n\n    mutt_bcache_close (&idata->bcache);\n  }\n\n  /* free IMAP part of headers */\n  for (i = 0; i < ctx->msgcount; i++)\n    /* mailbox may not have fully loaded */\n    if (ctx->hdrs[i] && ctx->hdrs[i]->data)\n      imap_free_header_data ((IMAP_HEADER_DATA**)&(ctx->hdrs[i]->data));\n\n  return 0;\n}\n\n/* use the NOOP or IDLE command to poll for new mail\n *\n * return values:\n *\tMUTT_REOPENED\tmailbox has been externally modified\n *\tMUTT_NEW_MAIL\tnew mail has arrived!\n *\t0\t\tno change\n *\t-1\t\terror\n */\nint imap_check_mailbox (CONTEXT *ctx, int *index_hint, int force)\n{\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  IMAP_DATA* idata;\n  int result = 0;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  /* try IDLE first, unless force is set */\n  if (!force && option (OPTIMAPIDLE) && mutt_bit_isset (idata->capabilities, IDLE)\n      && (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))\n  {\n    if (imap_cmd_idle (idata) < 0)\n      return -1;\n  }\n  if (idata->state == IMAP_IDLE)\n  {\n    while ((result = mutt_socket_poll (idata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step (idata) != IMAP_CMD_CONTINUE)\n      {\n        dprint (1, (debugfile, \"Error reading IDLE response\\n\"));\n        return -1;\n      }\n    }\n    if (result < 0)\n    {\n      dprint (1, (debugfile, \"Poll failed, disabling IDLE\\n\"));\n      mutt_bit_unset (idata->capabilities, IDLE);\n    }\n  }\n\n  if ((force ||\n       (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout))\n      && imap_exec (idata, \"NOOP\", IMAP_CMD_POLL) != 0)\n    return -1;\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish (idata);\n\n  if (idata->check_status & IMAP_EXPUNGE_PENDING)\n    result = MUTT_REOPENED;\n  else if (idata->check_status & IMAP_NEWMAIL_PENDING)\n    result = MUTT_NEW_MAIL;\n  else if (idata->check_status & IMAP_FLAGS_PENDING)\n    result = MUTT_FLAGS;\n\n  idata->check_status = 0;\n\n  return result;\n}\n\nstatic int imap_check_mailbox_reopen (CONTEXT *ctx, int *index_hint)\n{\n  int rc;\n\n  imap_allow_reopen (ctx);\n  rc = imap_check_mailbox (ctx, index_hint, 0);\n  imap_disallow_reopen (ctx);\n\n  return rc;\n}\n\nstatic int imap_save_to_header_cache (CONTEXT *ctx, HEADER *h)\n{\n  int rc = 0;\n#ifdef USE_HCACHE\n  int close_hc = 1;\n  IMAP_DATA* idata;\n\n  idata = (IMAP_DATA *)ctx->data;\n  if (idata->hcache)\n    close_hc = 0;\n  else\n    idata->hcache = imap_hcache_open (idata, NULL);\n  rc = imap_hcache_put (idata, h);\n  if (close_hc)\n    imap_hcache_close (idata);\n#endif\n  return rc;\n}\n\n/* split path into (idata,mailbox name) */\nstatic int imap_get_mailbox (const char* path, IMAP_DATA** hidata, char* buf, size_t blen)\n{\n  IMAP_MBOX mx;\n\n  if (imap_parse_path (path, &mx))\n  {\n    dprint (1, (debugfile, \"imap_get_mailbox: Error parsing %s\\n\", path));\n    return -1;\n  }\n  if (!(*hidata = imap_conn_find (&(mx.account), option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))\n  {\n    FREE (&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path (*hidata, mx.mbox, buf, blen);\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", blen);\n  FREE (&mx.mbox);\n\n  return 0;\n}\n\n/* check for new mail in any subscribed mailboxes. Given a list of mailboxes\n * rather than called once for each so that it can batch the commands and\n * save on round trips. Returns number of mailboxes with new mail. */\nint imap_buffy_check (int force, int check_stats)\n{\n  IMAP_DATA* idata;\n  IMAP_DATA* lastdata = NULL;\n  BUFFY* mailbox;\n  char name[LONG_STRING];\n  char command[LONG_STRING*2];\n  char munged[LONG_STRING];\n  int buffies = 0;\n\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    /* Init newly-added mailboxes */\n    if (! mailbox->magic)\n    {\n      if (mx_is_imap (mutt_b2s (mailbox->pathbuf)))\n        mailbox->magic = MUTT_IMAP;\n    }\n\n    if (mailbox->magic != MUTT_IMAP)\n      continue;\n\n    if (mailbox->nopoll)\n      continue;\n\n    if (imap_get_mailbox (mutt_b2s (mailbox->pathbuf), &idata, name, sizeof (name)) < 0)\n    {\n      mailbox->new = 0;\n      continue;\n    }\n\n    /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n     * IDLEd elsewhere.\n     * idata->mailbox may be NULL for connections other than the current\n     * mailbox's, and shouldn't expand to INBOX in that case. #3216. */\n    if (idata->mailbox && !imap_mxcmp (name, idata->mailbox))\n    {\n      mailbox->new = 0;\n      continue;\n    }\n\n    if (!mutt_bit_isset (idata->capabilities, IMAP4REV1) &&\n        !mutt_bit_isset (idata->capabilities, STATUS))\n    {\n      dprint (2, (debugfile, \"Server doesn't support STATUS\\n\"));\n      continue;\n    }\n\n    if (lastdata && idata != lastdata)\n    {\n      /* Send commands to previous server. Sorting the buffy list\n       * may prevent some infelicitous interleavings */\n      if (imap_exec (lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)\n        dprint (1, (debugfile, \"Error polling mailboxes\\n\"));\n\n      lastdata = NULL;\n    }\n\n    if (!lastdata)\n      lastdata = idata;\n\n    imap_munge_mbox_name (idata, munged, sizeof (munged), name);\n    if (check_stats)\n      snprintf (command, sizeof (command),\n                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);\n    else\n      snprintf (command, sizeof (command),\n                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);\n\n    if (imap_exec (idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)\n    {\n      dprint (1, (debugfile, \"Error queueing command\\n\"));\n      return 0;\n    }\n  }\n\n  if (lastdata && (imap_exec (lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))\n  {\n    dprint (1, (debugfile, \"Error polling mailboxes\\n\"));\n    return 0;\n  }\n\n  /* collect results */\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mailbox->magic == MUTT_IMAP && mailbox->new)\n      buffies++;\n  }\n\n  return buffies;\n}\n\n/* imap_status: returns count of messages in mailbox, or -1 on error.\n * if queue != 0, queue the command and expect it to have been run\n * on the next call (for pipelining the postponed count) */\nint imap_status (const char* path, int queue)\n{\n  static int queued = 0;\n\n  IMAP_DATA *idata;\n  char buf[LONG_STRING*2];\n  char mbox[LONG_STRING];\n  IMAP_STATUS* status;\n\n  if (imap_get_mailbox (path, &idata, buf, sizeof (buf)) < 0)\n    return -1;\n\n  /* We are in the folder we're polling - just return the mailbox count.\n   *\n   * Note that imap_mxcmp() converts NULL to \"INBOX\", so we need to\n   * make sure the idata really is open to a folder. */\n  if (idata->ctx && !imap_mxcmp (buf, idata->mailbox))\n    return idata->ctx->msgcount;\n  else if (mutt_bit_isset(idata->capabilities,IMAP4REV1) ||\n\t   mutt_bit_isset(idata->capabilities,STATUS))\n  {\n    imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n    snprintf (buf, sizeof (buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");\n    imap_unmunge_mbox_name (idata, mbox);\n  }\n  else\n    /* Server does not support STATUS, and this is not the current mailbox.\n     * There is no lightweight way to check recent arrivals */\n    return -1;\n\n  if (queue)\n  {\n    imap_exec (idata, buf, IMAP_CMD_QUEUE);\n    queued = 1;\n    return 0;\n  }\n  else if (!queued)\n    imap_exec (idata, buf, 0);\n\n  queued = 0;\n  if ((status = imap_mboxcache_get (idata, mbox, 0)))\n    return status->messages;\n\n  return 0;\n}\n\n/* return cached mailbox stats or NULL if create is 0 */\nIMAP_STATUS* imap_mboxcache_get (IMAP_DATA* idata, const char* mbox, int create)\n{\n  LIST* cur;\n  IMAP_STATUS* status;\n  IMAP_STATUS scache;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n  void *puidvalidity = NULL;\n  void *puidnext = NULL;\n  void *pmodseq = NULL;\n#endif\n\n  for (cur = idata->mboxcache; cur; cur = cur->next)\n  {\n    status = (IMAP_STATUS*)cur->data;\n\n    if (!imap_mxcmp (mbox, status->name))\n      return status;\n  }\n  status = NULL;\n\n  /* lame */\n  if (create)\n  {\n    memset (&scache, 0, sizeof (scache));\n    scache.name = (char*)mbox;\n    idata->mboxcache = mutt_add_list_n (idata->mboxcache, &scache,\n                                        sizeof (scache));\n    status = imap_mboxcache_get (idata, mbox, 0);\n    status->name = safe_strdup (mbox);\n  }\n\n#ifdef USE_HCACHE\n  hc = imap_hcache_open (idata, mbox);\n  if (hc)\n  {\n    puidvalidity = mutt_hcache_fetch_raw (hc, \"/UIDVALIDITY\", imap_hcache_keylen);\n    puidnext = mutt_hcache_fetch_raw (hc, \"/UIDNEXT\", imap_hcache_keylen);\n    pmodseq = mutt_hcache_fetch_raw (hc, \"/MODSEQ\", imap_hcache_keylen);\n    if (puidvalidity)\n    {\n      if (!status)\n      {\n        mutt_hcache_free ((void **)&puidvalidity);\n        mutt_hcache_free ((void **)&puidnext);\n        mutt_hcache_free ((void **)&pmodseq);\n        mutt_hcache_close (hc);\n        return imap_mboxcache_get (idata, mbox, 1);\n      }\n      memcpy (&status->uidvalidity, puidvalidity, sizeof(unsigned int));\n\n      if (puidnext)\n        memcpy (&status->uidnext, puidnext, sizeof(unsigned int));\n      else\n        status->uidnext = 0;\n\n      if (pmodseq)\n        memcpy (&status->modseq, pmodseq, sizeof(unsigned long long));\n      else\n        status->modseq = 0;\n      dprint (3, (debugfile, \"mboxcache: hcache uidvalidity %u, uidnext %u, modseq %llu\\n\",\n                  status->uidvalidity, status->uidnext, status->modseq));\n    }\n    mutt_hcache_free ((void **)&puidvalidity);\n    mutt_hcache_free ((void **)&puidnext);\n    mutt_hcache_free ((void **)&pmodseq);\n    mutt_hcache_close (hc);\n  }\n#endif\n\n  return status;\n}\n\nvoid imap_mboxcache_free (IMAP_DATA* idata)\n{\n  LIST* cur;\n  IMAP_STATUS* status;\n\n  for (cur = idata->mboxcache; cur; cur = cur->next)\n  {\n    status = (IMAP_STATUS*)cur->data;\n\n    FREE (&status->name);\n  }\n\n  mutt_free_list (&idata->mboxcache);\n}\n\n/* returns number of patterns in the search that should be done server-side\n * (eg are full-text) */\nstatic int do_search (const pattern_t* search, int allpats)\n{\n  int rc = 0;\n  const pattern_t* pat;\n\n  for (pat = search; pat; pat = pat->next)\n  {\n    switch (pat->op)\n    {\n      case MUTT_BODY:\n      case MUTT_HEADER:\n      case MUTT_WHOLE_MSG:\n        if (pat->stringmatch)\n          rc++;\n        break;\n      default:\n        if (pat->child && do_search (pat->child, 1))\n          rc++;\n    }\n\n    if (!allpats)\n      break;\n  }\n\n  return rc;\n}\n\n/* convert mutt pattern_t to IMAP SEARCH command containing only elements\n * that require full-text search (mutt already has what it needs for most\n * match types, and does a better job (eg server doesn't support regexps). */\nstatic int imap_compile_search (const pattern_t* pat, BUFFER* buf)\n{\n  if (! do_search (pat, 0))\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr (buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    if ((clauses = do_search (pat->child, 1)) > 0)\n    {\n      const pattern_t* clause = pat->child;\n\n      mutt_buffer_addch (buf, '(');\n\n      while (clauses)\n      {\n        if (do_search (clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr (buf, \"OR \");\n          clauses--;\n\n          if (imap_compile_search (clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch (buf, ' ');\n\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch (buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr (buf, \"HEADER \");\n\n        /* extract header name */\n        if (! (delim = strchr (pat->p.str, ':')))\n        {\n          mutt_error (_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        mutt_buffer_addch (buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string (term, sizeof (term), delim);\n        mutt_buffer_addstr (buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr (buf, \"BODY \");\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr (buf, \"TEXT \");\n        imap_quote_string (term, sizeof (term), pat->p.str);\n        mutt_buffer_addstr (buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}\n\nint imap_search (CONTEXT* ctx, const pattern_t* pat)\n{\n  BUFFER buf;\n  IMAP_DATA* idata = (IMAP_DATA*)ctx->data;\n  int i;\n\n  for (i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->matched = 0;\n\n  if (!do_search (pat, 1))\n    return 0;\n\n  mutt_buffer_init (&buf);\n  mutt_buffer_addstr (&buf, \"UID SEARCH \");\n  if (imap_compile_search (pat, &buf) < 0)\n  {\n    FREE (&buf.data);\n    return -1;\n  }\n  if (imap_exec (idata, buf.data, 0) < 0)\n  {\n    FREE (&buf.data);\n    return -1;\n  }\n\n  FREE (&buf.data);\n  return 0;\n}\n\nint imap_subscribe (char *path, int subscribe)\n{\n  IMAP_DATA *idata;\n  char buf[LONG_STRING*2];\n  char mbox[LONG_STRING];\n  int mblen;\n  BUFFER err;\n  IMAP_MBOX mx;\n\n  if (!mx_is_imap (path) || imap_parse_path (path, &mx) || !mx.mbox)\n  {\n    mutt_error (_(\"Bad mailbox name\"));\n    return -1;\n  }\n  if (!(idata = imap_conn_find (&(mx.account), 0)))\n    goto fail;\n\n  imap_fix_path (idata, mx.mbox, buf, sizeof (buf));\n  if (!*buf)\n    strfcpy (buf, \"INBOX\", sizeof (buf));\n\n  if (option (OPTIMAPCHECKSUBSCRIBED))\n  {\n    mutt_buffer_init (&err);\n    err.dsize = STRING;\n    err.data = safe_malloc (err.dsize);\n    mblen = snprintf (mbox, sizeof (mbox), \"%smailboxes \",\n                      subscribe ? \"\" : \"un\");\n    imap_quote_string_and_backquotes (mbox + mblen, sizeof(mbox) - mblen,\n                                      path);\n    if (mutt_parse_rc_line (mbox, &err))\n      dprint (1, (debugfile, \"Error adding subscribed mailbox: %s\\n\", err.data));\n    FREE (&err.data);\n  }\n\n  if (subscribe)\n    mutt_message (_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message (_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name (idata, mbox, sizeof(mbox), buf);\n\n  snprintf (buf, sizeof (buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec (idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message (_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message (_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE (&mx.mbox);\n  return 0;\n\nfail:\n  FREE (&mx.mbox);\n  return -1;\n}\n\n/* trim dest to the length of the longest prefix it shares with src,\n * returning the length of the trimmed string */\nstatic size_t\nlongest_common_prefix (char *dest, const char* src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while (pos < dlen && dest[pos] && dest[pos] == src[pos])\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/* look for IMAP URLs to complete from defined mailboxes. Could be extended\n * to complete over open connections and account/folder hooks too. */\nstatic int\nimap_complete_hosts (char *dest, size_t len)\n{\n  BUFFY* mailbox;\n  CONNECTION* conn;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_strlen (dest);\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (!mutt_strncmp (dest, mutt_b2s (mailbox->pathbuf), matchlen))\n    {\n      if (rc)\n      {\n        strfcpy (dest, mutt_b2s (mailbox->pathbuf), len);\n        rc = 0;\n      }\n      else\n        longest_common_prefix (dest, mutt_b2s (mailbox->pathbuf), matchlen, len);\n    }\n  }\n\n  for (conn = mutt_socket_head (); conn; conn = conn->next)\n  {\n    ciss_url_t url;\n    char urlstr[LONG_STRING];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl (&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_ciss_tostring (&url, urlstr, sizeof (urlstr), 0);\n    if (!mutt_strncmp (dest, urlstr, matchlen))\n    {\n      if (rc)\n      {\n        strfcpy (dest, urlstr, len);\n        rc = 0;\n      }\n      else\n        longest_common_prefix (dest, urlstr, matchlen, len);\n    }\n  }\n\n  return rc;\n}\n\n/* imap_complete: given a partial IMAP folder path, return a string which\n *   adds as much to the path as is unique */\nint imap_complete(char* dest, size_t dlen, const char* path)\n{\n  IMAP_DATA* idata;\n  char list[LONG_STRING];\n  char buf[LONG_STRING*2];\n  IMAP_LIST listresp;\n  char completion[LONG_STRING];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  IMAP_MBOX mx;\n  int rc;\n\n  if (imap_parse_path (path, &mx))\n  {\n    strfcpy (dest, path, dlen);\n    return imap_complete_hosts (dest, dlen);\n  }\n\n  /* don't open a new socket just for completion. Instead complete over\n   * known mailboxes/hooks/etc */\n  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NONEW)))\n  {\n    FREE (&mx.mbox);\n    strfcpy (dest, path, dlen);\n    return imap_complete_hosts (dest, dlen);\n  }\n\n  /* reformat path for IMAP list, and append wildcard */\n  /* don't use INBOX in place of \"\" */\n  if (mx.mbox && mx.mbox[0])\n    imap_fix_path (idata, mx.mbox, list, sizeof(list));\n  else\n    list[0] = '\\0';\n\n  /* fire off command */\n  snprintf (buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",\n            option (OPTIMAPLSUB) ? \"LSUB\" : \"LIST\", list);\n\n  imap_cmd_start (idata, buf);\n\n  /* and see what the results are */\n  strfcpy (completion, NONULL(mx.mbox), sizeof(completion));\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step (idata);\n\n    if (rc == IMAP_CMD_CONTINUE && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        strfcpy (completion, listresp.name, sizeof(completion));\n        matchlen = strlen (completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix (completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  }\n  while (rc == IMAP_CMD_CONTINUE);\n  idata->cmddata = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path (dest, dlen, &mx, completion);\n    mutt_pretty_mailbox (dest, dlen);\n\n    FREE (&mx.mbox);\n    return 0;\n  }\n\n  return -1;\n}\n\n/* imap_fast_trash: use server COPY command to copy deleted\n * messages to the trash folder.\n *   Return codes:\n *      -1: error\n *       0: success\n *       1: non-fatal error - try fetch/append */\nint imap_fast_trash (CONTEXT* ctx, char* dest)\n{\n  IMAP_DATA* idata;\n  char mbox[LONG_STRING];\n  char mmbox[LONG_STRING];\n  char prompt[LONG_STRING];\n  int n, rc;\n  IMAP_MBOX mx;\n  int triedcreate = 0;\n  BUFFER *sync_cmd = NULL;\n  int err_continue = MUTT_NO;\n\n  idata = (IMAP_DATA*) ctx->data;\n\n  if (imap_parse_path (dest, &mx))\n  {\n    dprint (1, (debugfile, \"imap_fast_trash: bad destination %s\\n\", dest));\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (!mutt_account_match (&(CTX_DATA->conn->account), &(mx.account)))\n  {\n    dprint (3, (debugfile, \"imap_fast_trash: %s not same server as %s\\n\",\n                dest, ctx->path));\n    return 1;\n  }\n\n  imap_fix_path (idata, mx.mbox, mbox, sizeof (mbox));\n  if (!*mbox)\n    strfcpy (mbox, \"INBOX\", sizeof (mbox));\n  imap_munge_mbox_name (idata, mmbox, sizeof (mmbox), mbox);\n\n  sync_cmd = mutt_buffer_new ();\n  for (n = 0; n < ctx->msgcount; n++)\n  {\n    if (ctx->hdrs[n]->active && ctx->hdrs[n]->changed &&\n        ctx->hdrs[n]->deleted && !ctx->hdrs[n]->purge)\n    {\n      rc = imap_sync_message_for_copy (idata, ctx->hdrs[n], sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        dprint (1, (debugfile, \"imap_fast_trash: could not sync\\n\"));\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset (idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);\n    if (!rc)\n    {\n      dprint (1, (debugfile, \"imap_fast_trash: No messages to trash\\n\"));\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      dprint (1, (debugfile, \"could not queue copy\\n\"));\n      goto out;\n    }\n    else if (!ctx->quiet)\n      mutt_message (_(\"Copying %d messages to %s...\"), rc, mbox);\n\n    /* let's get it on */\n    rc = imap_exec (idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        dprint (1, (debugfile, \"Already tried to create mailbox %s\\n\", mbox));\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (ascii_strncasecmp (imap_get_qualifier (idata->buf), \"[TRYCREATE]\", 11))\n        break;\n      dprint (3, (debugfile, \"imap_fast_trash: server suggests TRYCREATE\\n\"));\n      snprintf (prompt, sizeof (prompt), _(\"Create %s?\"), mbox);\n      if (option (OPTCONFIRMCREATE) && mutt_yesorno (prompt, 1) < 1)\n      {\n        mutt_clear_error ();\n        goto out;\n      }\n      if (imap_create_mailbox (idata, mbox) < 0)\n        break;\n      triedcreate = 1;\n    }\n  }\n  while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error (\"imap_fast_trash\", idata->buf);\n    goto out;\n  }\n\n  rc = 0;\n\nout:\n  mutt_buffer_free (&sync_cmd);\n  FREE (&mx.mbox);\n\n  return rc < 0 ? -1 : rc;\n}\n\nstruct mx_ops mx_imap_ops = {\n  .open = imap_open_mailbox,\n  .open_append = imap_open_mailbox_append,\n  .close = imap_close_mailbox,\n  .open_msg = imap_fetch_message,\n  .close_msg = imap_close_message,\n  .commit_msg = imap_commit_message,\n  .open_new_msg = imap_open_new_message,\n  .check = imap_check_mailbox_reopen,\n  .sync = NULL,      /* imap syncing is handled by imap_sync_mailbox */\n  .save_to_header_cache = imap_save_to_header_cache,\n};\n"], "filenames": ["imap/imap.c"], "buggy_code_start_loc": [532], "buggy_code_end_loc": [532], "fixing_code_start_loc": [533], "fixing_code_end_loc": [549], "type": "CWE-319", "message": "Mutt before 1.14.3 allows an IMAP fcc/postpone man-in-the-middle attack via a PREAUTH response.", "other": {"cve": {"id": "CVE-2020-14093", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-15T05:15:11.300", "lastModified": "2022-04-27T14:16:50.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mutt before 1.14.3 allows an IMAP fcc/postpone man-in-the-middle attack via a PREAUTH response."}, {"lang": "es", "value": "Mutt versiones anteriores a 1.14.3, permite un ataque de tipo man-in-the-middle de fcc/postpone de IMAP por medio de una respuesta PREAUTH"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-319"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.3", "matchCriteriaId": "0571680C-460A-4AF4-9D18-2D08F69C2C14"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00064.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00070.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.mutt.org", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://bugs.gentoo.org/728300", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/muttmua/mutt/commit/3e88866dc60b5fa6aaba6fd7c1710c12c1c3cd01", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-57", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4401-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4707", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4708", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/muttmua/mutt/commit/3e88866dc60b5fa6aaba6fd7c1710c12c1c3cd01"}}