{"buggy_code": ["#include \"logger.h\"\n\n#include <QDateTime>\n\nLogger* Logger::m_instance = 0;\n\nLogger::Logger()\n    : lock(QReadWriteLock::Recursive)\n    , msgCounter(0)\n    , peerCounter(0)\n{\n}\n\nLogger::~Logger() {}\n\nLogger *Logger::instance()\n{\n    return m_instance;\n}\n\nvoid Logger::initInstance()\n{\n    if (!m_instance)\n        m_instance = new Logger;\n}\n\nvoid Logger::freeInstance()\n{\n    if (m_instance) {\n        delete m_instance;\n        m_instance = 0;\n    }\n}\n\nvoid Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}\n\nvoid Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}\n\nQVector<Log::Msg> Logger::getMessages(int lastKnownId) const\n{\n    QReadLocker locker(&lock);\n\n    int diff = msgCounter - lastKnownId - 1;\n    int size = m_messages.size();\n\n    if ((lastKnownId == -1) || (diff >= size))\n        return m_messages;\n\n    if (diff <= 0)\n        return QVector<Log::Msg>();\n\n    return m_messages.mid(size - diff);\n}\n\nQVector<Log::Peer> Logger::getPeers(int lastKnownId) const\n{\n    QReadLocker locker(&lock);\n\n    int diff = peerCounter - lastKnownId - 1;\n    int size = m_peers.size();\n\n    if ((lastKnownId == -1) || (diff >= size))\n        return m_peers;\n\n    if (diff <= 0)\n        return QVector<Log::Peer>();\n\n    return m_peers.mid(size - diff);\n}\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>\n * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#include \"string.h\"\n\n#include <cmath>\n\n#include <QByteArray>\n#include <QtGlobal>\n#include <QLocale>\n#ifdef QBT_USES_QT5\n#include <QCollator>\n#endif\n#ifdef Q_OS_MAC\n#include <QThreadStorage>\n#endif\n\nnamespace\n{\n    class NaturalCompare\n    {\n    public:\n        explicit NaturalCompare(const bool caseSensitive = true)\n            : m_caseSensitive(caseSensitive)\n        {\n#ifdef QBT_USES_QT5\n#if defined(Q_OS_WIN)\n            // Without ICU library, QCollator uses the native API on Windows 7+. But that API\n            // sorts older versions of \u03bcTorrent differently than the newer ones because the\n            // '\u03bc' character is encoded differently and the native API can't cope with that.\n            // So default to using our custom natural sorting algorithm instead.\n            // See #5238 and #5240\n            // Without ICU library, QCollator doesn't support `setNumericMode(true)` on OS older than Win7\n            // if (QSysInfo::windowsVersion() < QSysInfo::WV_WINDOWS7)\n                return;\n#endif\n            m_collator.setNumericMode(true);\n            m_collator.setCaseSensitivity(caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n#endif\n        }\n\n        bool operator()(const QString &left, const QString &right) const\n        {\n#ifdef QBT_USES_QT5\n#if defined(Q_OS_WIN)\n            // Without ICU library, QCollator uses the native API on Windows 7+. But that API\n            // sorts older versions of \u03bcTorrent differently than the newer ones because the\n            // '\u03bc' character is encoded differently and the native API can't cope with that.\n            // So default to using our custom natural sorting algorithm instead.\n            // See #5238 and #5240\n            // Without ICU library, QCollator doesn't support `setNumericMode(true)` on OS older than Win7\n            // if (QSysInfo::windowsVersion() < QSysInfo::WV_WINDOWS7)\n                return lessThan(left, right);\n#endif\n            return (m_collator.compare(left, right) < 0);\n#else\n            return lessThan(left, right);\n#endif\n        }\n\n        bool lessThan(const QString &left, const QString &right) const\n        {\n            // Return value `false` indicates `right` should go before `left`, otherwise, after\n            int posL = 0;\n            int posR = 0;\n            while (true) {\n                while (true) {\n                    if ((posL == left.size()) || (posR == right.size()))\n                        return (left.size() < right.size());  // when a shorter string is another string's prefix, shorter string place before longer string\n\n                    QChar leftChar = m_caseSensitive ? left[posL] : left[posL].toLower();\n                    QChar rightChar = m_caseSensitive ? right[posR] : right[posR].toLower();\n                    if (leftChar == rightChar)\n                        ;  // compare next character\n                    else if (leftChar.isDigit() && rightChar.isDigit())\n                        break; // Both are digits, break this loop and compare numbers\n                    else\n                        return leftChar < rightChar;\n\n                    ++posL;\n                    ++posR;\n                }\n\n                int startL = posL;\n                while ((posL < left.size()) && left[posL].isDigit())\n                    ++posL;\n#ifdef QBT_USES_QT5\n                int numL = left.midRef(startL, posL - startL).toInt();\n#else\n                int numL = left.mid(startL, posL - startL).toInt();\n#endif\n\n                int startR = posR;\n                while ((posR < right.size()) && right[posR].isDigit())\n                    ++posR;\n#ifdef QBT_USES_QT5\n                int numR = right.midRef(startR, posR - startR).toInt();\n#else\n                int numR = right.mid(startR, posR - startR).toInt();\n#endif\n\n                if (numL != numR)\n                    return (numL < numR);\n\n                // Strings + digits do match and we haven't hit string end\n                // Do another round\n            }\n            return false;\n        }\n\n    private:\n#ifdef QBT_USES_QT5\n        QCollator m_collator;\n#endif\n        const bool m_caseSensitive;\n    };\n}\n\nbool Utils::String::naturalCompareCaseSensitive(const QString &left, const QString &right)\n{\n    // provide a single `NaturalCompare` instance for easy use\n    // https://doc.qt.io/qt-5/threads-reentrancy.html\n#ifdef Q_OS_MAC  // workaround for Apple xcode: https://stackoverflow.com/a/29929949\n    static QThreadStorage<NaturalCompare> nCmp;\n    if (!nCmp.hasLocalData()) nCmp.setLocalData(NaturalCompare(true));\n    return (nCmp.localData())(left, right);\n#else\n    thread_local NaturalCompare nCmp(true);\n    return nCmp(left, right);\n#endif\n}\n\nbool Utils::String::naturalCompareCaseInsensitive(const QString &left, const QString &right)\n{\n    // provide a single `NaturalCompare` instance for easy use\n    // https://doc.qt.io/qt-5/threads-reentrancy.html\n#ifdef Q_OS_MAC  // workaround for Apple xcode: https://stackoverflow.com/a/29929949\n    static QThreadStorage<NaturalCompare> nCmp;\n    if (!nCmp.hasLocalData()) nCmp.setLocalData(NaturalCompare(false));\n    return (nCmp.localData())(left, right);\n#else\n    thread_local NaturalCompare nCmp(false);\n    return nCmp(left, right);\n#endif\n}\n\nQString Utils::String::fromStdString(const std::string &str)\n{\n    return QString::fromUtf8(str.c_str());\n}\n\nstd::string Utils::String::toStdString(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toStdString();\n#else\n    QByteArray utf8 = str.toUtf8();\n    return std::string(utf8.constData(), utf8.length());\n#endif\n}\n\n// to send numbers instead of strings with suffixes\nQString Utils::String::fromDouble(double n, int precision)\n{\n    /* HACK because QString rounds up. Eg QString::number(0.999*100.0, 'f' ,1) == 99.9\n    ** but QString::number(0.9999*100.0, 'f' ,1) == 100.0 The problem manifests when\n    ** the number has more digits after the decimal than we want AND the digit after\n    ** our 'wanted' is >= 5. In this case our last digit gets rounded up. So for each\n    ** precision we add an extra 0 behind 1 in the below algorithm. */\n\n    double prec = std::pow(10.0, precision);\n    return QLocale::system().toString(std::floor(n * prec) / prec, 'f', precision);\n}\n\n// Implements constant-time comparison to protect against timing attacks\n// Taken from https://crackstation.net/hashing-security.htm\nbool Utils::String::slowEquals(const QByteArray &a, const QByteArray &b)\n{\n    int lengthA = a.length();\n    int lengthB = b.length();\n\n    int diff = lengthA ^ lengthB;\n    for (int i = 0; (i < lengthA) && (i < lengthB); i++)\n        diff |= a[i] ^ b[i];\n\n    return (diff == 0);\n}\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>\n * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#ifndef UTILS_STRING_H\n#define UTILS_STRING_H\n\n#include <string>\n\nclass QByteArray;\nclass QString;\n\nnamespace Utils\n{\n    namespace String\n    {\n        QString fromStdString(const std::string &str);\n        std::string toStdString(const QString &str);\n        QString fromDouble(double n, int precision);\n\n        // Implements constant-time comparison to protect against timing attacks\n        // Taken from https://crackstation.net/hashing-security.htm\n        bool slowEquals(const QByteArray &a, const QByteArray &b);\n\n        bool naturalCompareCaseSensitive(const QString &left, const QString &right);\n        bool naturalCompareCaseInsensitive(const QString &left, const QString &right);\n    }\n}\n\n#endif // UTILS_STRING_H\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#ifndef DELETIONCONFIRMATIONDLG_H\n#define DELETIONCONFIRMATIONDLG_H\n\n#include <QDialog>\n#include <QPushButton>\n#include \"ui_confirmdeletiondlg.h\"\n#include \"base/preferences.h\"\n#include \"guiiconprovider.h\"\n#include \"base/utils/misc.h\"\n\nclass DeletionConfirmationDlg : public QDialog, private Ui::confirmDeletionDlg {\n  Q_OBJECT\n\n  public:\n  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    // Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }\n\n  bool shouldDeleteLocalFiles() const {\n    return checkPermDelete->isChecked();\n  }\n\n  static bool askForDeletionConfirmation(bool& deleteLocalFiles, const int& size, const QString& name) {\n    DeletionConfirmationDlg dlg(NULL, size, name, deleteLocalFiles);\n    if (dlg.exec() == QDialog::Accepted) {\n      deleteLocalFiles = dlg.shouldDeleteLocalFiles();\n      return true;\n    }\n    return false;\n  }\n\nprivate slots:\n  void updateRememberButtonState() {\n    rememberBtn->setEnabled(checkPermDelete->isChecked() != Preferences::instance()->deleteTorrentFilesAsDefault());\n  }\n\n  void on_rememberBtn_clicked() {\n    Preferences::instance()->setDeleteTorrentFilesAsDefault(checkPermDelete->isChecked());\n    rememberBtn->setEnabled(false);\n  }\n};\n\n#endif // DELETIONCONFIRMATIONDLG_H\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#include <QStandardItemModel>\n#include <QSortFilterProxyModel>\n#include <QSet>\n#include <QHeaderView>\n#include <QMenu>\n#include <QClipboard>\n#include <QMessageBox>\n#include <QWheelEvent>\n#ifdef QBT_USES_QT5\n#include <QTableView>\n#endif\n\n#include \"base/net/reverseresolution.h\"\n#include \"base/bittorrent/torrenthandle.h\"\n#include \"base/bittorrent/peerinfo.h\"\n#include \"base/preferences.h\"\n#include \"base/logger.h\"\n#include \"base/unicodestrings.h\"\n#include \"propertieswidget.h\"\n#include \"base/net/geoipmanager.h\"\n#include \"peersadditiondlg.h\"\n#include \"speedlimitdlg.h\"\n#include \"guiiconprovider.h\"\n#include \"peerlistdelegate.h\"\n#include \"peerlistsortmodel.h\"\n#include \"peerlistwidget.h\"\n\nPeerListWidget::PeerListWidget(PropertiesWidget *parent)\n    : QTreeView(parent)\n    , m_properties(parent)\n{\n    // Load settings\n    loadSettings();\n    // Visual settings\n    setUniformRowHeights(true);\n    setRootIsDecorated(false);\n    setItemsExpandable(false);\n    setAllColumnsShowFocus(true);\n    setSelectionMode(QAbstractItemView::ExtendedSelection);\n    header()->setStretchLastSection(false);\n    // List Model\n    m_listModel = new QStandardItemModel(0, PeerListDelegate::COL_COUNT);\n    m_listModel->setHeaderData(PeerListDelegate::COUNTRY, Qt::Horizontal, tr(\"Country\")); // Country flag column\n    m_listModel->setHeaderData(PeerListDelegate::IP, Qt::Horizontal, tr(\"IP\"));\n    m_listModel->setHeaderData(PeerListDelegate::PORT, Qt::Horizontal, tr(\"Port\"));\n    m_listModel->setHeaderData(PeerListDelegate::FLAGS, Qt::Horizontal, tr(\"Flags\"));\n    m_listModel->setHeaderData(PeerListDelegate::CONNECTION, Qt::Horizontal, tr(\"Connection\"));\n    m_listModel->setHeaderData(PeerListDelegate::CLIENT, Qt::Horizontal, tr(\"Client\", \"i.e.: Client application\"));\n    m_listModel->setHeaderData(PeerListDelegate::PROGRESS, Qt::Horizontal, tr(\"Progress\", \"i.e: % downloaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::DOWN_SPEED, Qt::Horizontal, tr(\"Down Speed\", \"i.e: Download speed\"));\n    m_listModel->setHeaderData(PeerListDelegate::UP_SPEED, Qt::Horizontal, tr(\"Up Speed\", \"i.e: Upload speed\"));\n    m_listModel->setHeaderData(PeerListDelegate::TOT_DOWN, Qt::Horizontal, tr(\"Downloaded\", \"i.e: total data downloaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::TOT_UP, Qt::Horizontal, tr(\"Uploaded\", \"i.e: total data uploaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::RELEVANCE, Qt::Horizontal, tr(\"Relevance\", \"i.e: How relevant this peer is to us. How many pieces it has that we don't.\"));\n    m_listModel->setHeaderData(PeerListDelegate::DOWNLOADING_PIECE, Qt::Horizontal, tr(\"Files\", \"i.e. files that are being downloaded right now\"));\n    // Set header text alignment\n    m_listModel->setHeaderData(PeerListDelegate::PORT, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::PROGRESS, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::DOWN_SPEED, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::UP_SPEED, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::TOT_DOWN, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::TOT_UP, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::RELEVANCE, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    // Proxy model to support sorting without actually altering the underlying model\n    m_proxyModel = new PeerListSortModel();\n    m_proxyModel->setDynamicSortFilter(true);\n    m_proxyModel->setSourceModel(m_listModel);\n    m_proxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);\n    setModel(m_proxyModel);\n    hideColumn(PeerListDelegate::IP_HIDDEN);\n    hideColumn(PeerListDelegate::COL_COUNT);\n    m_resolveCountries = Preferences::instance()->resolvePeerCountries();\n    if (!m_resolveCountries)\n        hideColumn(PeerListDelegate::COUNTRY);\n    //Ensure that at least one column is visible at all times\n    bool atLeastOne = false;\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++) {\n        if (!isColumnHidden(i)) {\n            atLeastOne = true;\n            break;\n        }\n    }\n    if (!atLeastOne)\n        setColumnHidden(PeerListDelegate::IP, false);\n    //To also mitigate the above issue, we have to resize each column when\n    //its size is 0, because explicitly 'showing' the column isn't enough\n    //in the above scenario.\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++)\n        if ((columnWidth(i) <= 0) && !isColumnHidden(i))\n            resizeColumnToContents(i);\n    // Context menu\n    setContextMenuPolicy(Qt::CustomContextMenu);\n    connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(showPeerListMenu(QPoint)));\n    // List delegate\n    m_listDelegate = new PeerListDelegate(this);\n    setItemDelegate(m_listDelegate);\n    // Enable sorting\n    setSortingEnabled(true);\n    // IP to Hostname resolver\n    updatePeerHostNameResolutionState();\n    // SIGNAL/SLOT\n    header()->setContextMenuPolicy(Qt::CustomContextMenu);\n    connect(header(), SIGNAL(customContextMenuRequested(const QPoint &)), this, SLOT(displayToggleColumnsMenu(const QPoint &)));\n    connect(header(), SIGNAL(sectionClicked(int)), SLOT(handleSortColumnChanged(int)));\n    handleSortColumnChanged(header()->sortIndicatorSection());\n    m_copyHotkey = new QShortcut(QKeySequence::Copy, this, SLOT(copySelectedPeers()), 0, Qt::WidgetShortcut);\n\n#ifdef QBT_USES_QT5\n    // This hack fixes reordering of first column with Qt5.\n    // https://github.com/qtproject/qtbase/commit/e0fc088c0c8bc61dbcaf5928b24986cd61a22777\n    QTableView unused;\n    unused.setVerticalHeader(this->header());\n    this->header()->setParent(this);\n    unused.setVerticalHeader(new QHeaderView(Qt::Horizontal));\n#endif\n}\n\nPeerListWidget::~PeerListWidget()\n{\n    saveSettings();\n    delete m_proxyModel;\n    delete m_listModel;\n    delete m_listDelegate;\n    if (m_resolver)\n        delete m_resolver;\n    delete m_copyHotkey;\n}\n\nvoid PeerListWidget::displayToggleColumnsMenu(const QPoint&)\n{\n    QMenu hideshowColumn(this);\n    hideshowColumn.setTitle(tr(\"Column visibility\"));\n    QList<QAction*> actions;\n    for (int i = 0; i < PeerListDelegate::IP_HIDDEN; ++i) {\n        if ((i == PeerListDelegate::COUNTRY) && !Preferences::instance()->resolvePeerCountries()) {\n            actions.append(nullptr); // keep the index in sync\n            continue;\n        }\n        QAction *myAct = hideshowColumn.addAction(m_listModel->headerData(i, Qt::Horizontal, Qt::DisplayRole).toString());\n        myAct->setCheckable(true);\n        myAct->setChecked(!isColumnHidden(i));\n        actions.append(myAct);\n    }\n    int visibleCols = 0;\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++) {\n        if (!isColumnHidden(i))\n            visibleCols++;\n\n        if (visibleCols > 1)\n            break;\n    }\n\n    // Call menu\n    QAction *act = hideshowColumn.exec(QCursor::pos());\n    if (act) {\n        int col = actions.indexOf(act);\n        Q_ASSERT(col >= 0);\n        Q_ASSERT(visibleCols > 0);\n        if (!isColumnHidden(col) && (visibleCols == 1))\n            return;\n        qDebug(\"Toggling column %d visibility\", col);\n        setColumnHidden(col, !isColumnHidden(col));\n        if (!isColumnHidden(col) && (columnWidth(col) <= 5))\n            setColumnWidth(col, 100);\n        saveSettings();\n    }\n}\n\nvoid PeerListWidget::updatePeerHostNameResolutionState()\n{\n    if (Preferences::instance()->resolvePeerHostNames()) {\n        if (!m_resolver) {\n            m_resolver = new Net::ReverseResolution(this);\n            connect(m_resolver, SIGNAL(ipResolved(QString, QString)), SLOT(handleResolved(QString, QString)));\n            loadPeers(m_properties->getCurrentTorrent(), true);\n        }\n    }\n    else if (m_resolver) {\n        delete m_resolver;\n    }\n}\n\nvoid PeerListWidget::updatePeerCountryResolutionState()\n{\n    if (Preferences::instance()->resolvePeerCountries() != m_resolveCountries) {\n        m_resolveCountries = !m_resolveCountries;\n        if (m_resolveCountries) {\n            loadPeers(m_properties->getCurrentTorrent());\n            showColumn(PeerListDelegate::COUNTRY);\n            if (columnWidth(PeerListDelegate::COUNTRY) <= 0)\n                resizeColumnToContents(PeerListDelegate::COUNTRY);\n        }\n        else {\n            hideColumn(PeerListDelegate::COUNTRY);\n        }\n    }\n}\n\nvoid PeerListWidget::showPeerListMenu(const QPoint&)\n{\n    QMenu menu;\n    bool emptyMenu = true;\n    BitTorrent::TorrentHandle *const torrent = m_properties->getCurrentTorrent();\n    if (!torrent) return;\n\n    // Add Peer Action\n    QAction *addPeerAct = 0;\n    if (!torrent->isQueued() && !torrent->isChecking()) {\n        addPeerAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"user-group-new\"), tr(\"Add a new peer...\"));\n        emptyMenu = false;\n    }\n    QAction *banAct = 0;\n    QAction *copyPeerAct = 0;\n    if (!selectionModel()->selectedRows().isEmpty()) {\n        copyPeerAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"edit-copy\"), tr(\"Copy IP:port\"));\n        menu.addSeparator();\n        banAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"user-group-delete\"), tr(\"Ban peer permanently\"));\n        emptyMenu = false;\n    }\n    if (emptyMenu) return;\n    QAction *act = menu.exec(QCursor::pos());\n    if (act == 0) return;\n    if (act == addPeerAct) {\n        QList<BitTorrent::PeerAddress> peersList = PeersAdditionDlg::askForPeers();\n        int peerCount = 0;\n        foreach (const BitTorrent::PeerAddress &addr, peersList) {\n            if (torrent->connectPeer(addr)) {\n                qDebug(\"Adding peer %s...\", qPrintable(addr.ip.toString()));\n                Logger::instance()->addMessage(tr(\"Manually adding peer '%1'...\").arg(addr.ip.toString()));\n                peerCount++;\n            }\n            else {\n                Logger::instance()->addMessage(tr(\"The peer '%1' could not be added to this torrent.\").arg(addr.ip.toString()), Log::WARNING);\n            }\n        }\n        if (peerCount < peersList.length())\n            QMessageBox::information(0, tr(\"Peer addition\"), tr(\"Some peers could not be added. Check the Log for details.\"));\n        else if (peerCount > 0)\n            QMessageBox::information(0, tr(\"Peer addition\"), tr(\"The peers were added to this torrent.\"));\n        return;\n    }\n    if (act == banAct) {\n        banSelectedPeers();\n        return;\n    }\n    if (act == copyPeerAct) {\n        copySelectedPeers();\n        return;\n    }\n}\n\nvoid PeerListWidget::banSelectedPeers()\n{\n    // Confirm first\n    int ret = QMessageBox::question(this, tr(\"Ban peer permanently\"), tr(\"Are you sure you want to ban permanently the selected peers?\"),\n                                    tr(\"&Yes\"), tr(\"&No\"),\n                                    QString(), 0, 1);\n    if (ret)\n        return;\n\n    QModelIndexList selectedIndexes = selectionModel()->selectedRows();\n    foreach (const QModelIndex &index, selectedIndexes) {\n        int row = m_proxyModel->mapToSource(index).row();\n        QString ip = m_listModel->data(m_listModel->index(row, PeerListDelegate::IP_HIDDEN)).toString();\n        qDebug(\"Banning peer %s...\", ip.toLocal8Bit().data());\n        Logger::instance()->addMessage(tr(\"Manually banning peer '%1'...\").arg(ip));\n        BitTorrent::Session::instance()->banIP(ip);\n    }\n    // Refresh list\n    loadPeers(m_properties->getCurrentTorrent());\n}\n\nvoid PeerListWidget::copySelectedPeers()\n{\n    QModelIndexList selectedIndexes = selectionModel()->selectedRows();\n    QStringList selectedPeers;\n    foreach (const QModelIndex &index, selectedIndexes) {\n        int row = m_proxyModel->mapToSource(index).row();\n        QString ip = m_listModel->data(m_listModel->index(row, PeerListDelegate::IP_HIDDEN)).toString();\n        QString myport = m_listModel->data(m_listModel->index(row, PeerListDelegate::PORT)).toString();\n        if (ip.indexOf(\".\") == -1) // IPv6\n            selectedPeers << \"[\" + ip + \"]:\" + myport;\n        else // IPv4\n            selectedPeers << ip + \":\" + myport;\n    }\n    QApplication::clipboard()->setText(selectedPeers.join(\"\\n\"));\n}\n\nvoid PeerListWidget::clear()\n{\n    qDebug(\"clearing peer list\");\n    m_peerItems.clear();\n    m_peerAddresses.clear();\n    m_missingFlags.clear();\n    int nbrows = m_listModel->rowCount();\n    if (nbrows > 0) {\n        qDebug(\"Cleared %d peers\", nbrows);\n        m_listModel->removeRows(0,  nbrows);\n    }\n}\n\nvoid PeerListWidget::loadSettings()\n{\n    header()->restoreState(Preferences::instance()->getPeerListState());\n}\n\nvoid PeerListWidget::saveSettings() const\n{\n    Preferences::instance()->setPeerListState(header()->saveState());\n}\n\nvoid PeerListWidget::loadPeers(BitTorrent::TorrentHandle *const torrent, bool forceHostnameResolution)\n{\n    if (!torrent) return;\n\n    QList<BitTorrent::PeerInfo> peers = torrent->peers();\n    QSet<QString> oldeersSet = m_peerItems.keys().toSet();\n\n    foreach (const BitTorrent::PeerInfo &peer, peers) {\n        BitTorrent::PeerAddress addr = peer.address();\n        if (addr.ip.isNull()) continue;\n\n        QString peerIp = addr.ip.toString();\n        if (m_peerItems.contains(peerIp)) {\n            // Update existing peer\n            updatePeer(peerIp, torrent, peer);\n            oldeersSet.remove(peerIp);\n            if (forceHostnameResolution && m_resolver)\n                m_resolver->resolve(peerIp);\n        }\n        else {\n            // Add new peer\n            m_peerItems[peerIp] = addPeer(peerIp, torrent, peer);\n            m_peerAddresses[peerIp] = addr;\n            // Resolve peer host name is asked\n            if (m_resolver)\n                m_resolver->resolve(peerIp);\n        }\n    }\n    // Delete peers that are gone\n    QSetIterator<QString> it(oldeersSet);\n    while (it.hasNext()) {\n        const QString& ip = it.next();\n        m_missingFlags.remove(ip);\n        m_peerAddresses.remove(ip);\n        QStandardItem *item = m_peerItems.take(ip);\n        m_listModel->removeRow(item->row());\n    }\n}\n\nQStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}\n\nvoid PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}\n\nvoid PeerListWidget::handleResolved(const QString &ip, const QString &hostname)\n{\n    QStandardItem *item = m_peerItems.value(ip, 0);\n    if (item) {\n        qDebug(\"Resolved %s -> %s\", qPrintable(ip), qPrintable(hostname));\n        item->setData(hostname, Qt::DisplayRole);\n    }\n}\n\nvoid PeerListWidget::handleSortColumnChanged(int col)\n{\n    if (col == PeerListDelegate::COUNTRY) {\n        qDebug(\"Sorting by decoration\");\n        m_proxyModel->setSortRole(Qt::ToolTipRole);\n    }\n    else {\n        m_proxyModel->setSortRole(Qt::DisplayRole);\n    }\n}\n\nvoid PeerListWidget::wheelEvent(QWheelEvent *event)\n{\n    event->accept();\n\n    if(event->modifiers() & Qt::ShiftModifier) {\n        // Shift + scroll = horizontal scroll\n        QWheelEvent scrollHEvent(event->pos(), event->globalPos(), event->delta(), event->buttons(), event->modifiers(), Qt::Horizontal);\n        QTreeView::wheelEvent(&scrollHEvent);\n        return;\n    }\n\n    QTreeView::wheelEvent(event);  // event delegated to base class\n}\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#include \"propertieswidget.h\"\n\n#include <QDebug>\n#include <QTimer>\n#include <QListWidgetItem>\n#include <QVBoxLayout>\n#include <QStackedWidget>\n#include <QSplitter>\n#include <QHeaderView>\n#include <QAction>\n#include <QMenu>\n#include <QFileDialog>\n#include <QBitArray>\n\n#include \"base/bittorrent/session.h\"\n#include \"base/preferences.h\"\n#include \"base/utils/fs.h\"\n#include \"base/utils/misc.h\"\n#include \"base/utils/string.h\"\n#include \"base/unicodestrings.h\"\n#include \"proplistdelegate.h\"\n#include \"torrentcontentfiltermodel.h\"\n#include \"torrentcontentmodel.h\"\n#include \"peerlistwidget.h\"\n#include \"speedwidget.h\"\n#include \"trackerlist.h\"\n#include \"mainwindow.h\"\n#include \"messageboxraised.h\"\n#include \"downloadedpiecesbar.h\"\n#include \"pieceavailabilitybar.h\"\n#include \"proptabbar.h\"\n#include \"guiiconprovider.h\"\n#include \"lineedit.h\"\n#include \"transferlistwidget.h\"\n#include \"autoexpandabledialog.h\"\n\nPropertiesWidget::PropertiesWidget(QWidget *parent, MainWindow *main_window, TransferListWidget *transferList)\n    : QWidget(parent), transferList(transferList), main_window(main_window), m_torrent(0)\n{\n    setupUi(this);\n    setAutoFillBackground(true);\n\n    state = VISIBLE;\n\n    // Set Properties list model\n    PropListModel = new TorrentContentFilterModel();\n    filesList->setModel(PropListModel);\n    PropDelegate = new PropListDelegate(this);\n    filesList->setItemDelegate(PropDelegate);\n    filesList->setSortingEnabled(true);\n    // Torrent content filtering\n    m_contentFilterLine = new LineEdit(this);\n    m_contentFilterLine->setPlaceholderText(tr(\"Filter files...\"));\n    m_contentFilterLine->setMaximumSize(300, m_contentFilterLine->size().height());\n    connect(m_contentFilterLine, SIGNAL(textChanged(QString)), this, SLOT(filterText(QString)));\n    contentFilterLayout->insertWidget(3, m_contentFilterLine);\n\n    // SIGNAL/SLOTS\n    connect(filesList, SIGNAL(clicked(const QModelIndex&)), filesList, SLOT(edit(const QModelIndex&)));\n    connect(selectAllButton, SIGNAL(clicked()), PropListModel, SLOT(selectAll()));\n    connect(selectNoneButton, SIGNAL(clicked()), PropListModel, SLOT(selectNone()));\n    connect(filesList, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(displayFilesListMenu(const QPoint&)));\n    connect(filesList, SIGNAL(doubleClicked(const QModelIndex&)), this, SLOT(openDoubleClickedFile(const QModelIndex&)));\n    connect(PropListModel, SIGNAL(filteredFilesChanged()), this, SLOT(filteredFilesChanged()));\n    connect(listWebSeeds, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(displayWebSeedListMenu(const QPoint&)));\n    connect(transferList, SIGNAL(currentTorrentChanged(BitTorrent::TorrentHandle * const)), this, SLOT(loadTorrentInfos(BitTorrent::TorrentHandle * const)));\n    connect(PropDelegate, SIGNAL(filteredFilesChanged()), this, SLOT(filteredFilesChanged()));\n    connect(stackedProperties, SIGNAL(currentChanged(int)), this, SLOT(loadDynamicData()));\n    connect(BitTorrent::Session::instance(), SIGNAL(torrentSavePathChanged(BitTorrent::TorrentHandle * const)), this, SLOT(updateSavePath(BitTorrent::TorrentHandle * const)));\n    connect(BitTorrent::Session::instance(), SIGNAL(torrentMetadataLoaded(BitTorrent::TorrentHandle * const)), this, SLOT(updateTorrentInfos(BitTorrent::TorrentHandle * const)));\n    connect(filesList->header(), SIGNAL(sectionMoved(int,int,int)), this, SLOT(saveSettings()));\n    connect(filesList->header(), SIGNAL(sectionResized(int,int,int)), this, SLOT(saveSettings()));\n    connect(filesList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), this, SLOT(saveSettings()));\n\n#ifdef QBT_USES_QT5\n    // set bar height relative to screen dpi\n    int barHeight = devicePixelRatio() * 18;\n#else\n    // set bar height relative to font height\n    QFont defFont;\n    QFontMetrics fMetrics(defFont, 0); // need to be device-dependent\n    int barHeight = fMetrics.height() * 5 / 4;\n#endif\n\n    // Downloaded pieces progress bar\n    tempProgressBarArea->setVisible(false);\n    downloaded_pieces = new DownloadedPiecesBar(this);\n    groupBarLayout->addWidget(downloaded_pieces, 0, 1);\n    downloaded_pieces->setFixedHeight(barHeight);\n    downloaded_pieces->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);\n\n    // Pieces availability bar\n    tempAvailabilityBarArea->setVisible(false);\n    pieces_availability = new PieceAvailabilityBar(this);\n    groupBarLayout->addWidget(pieces_availability, 1, 1);\n    pieces_availability->setFixedHeight(barHeight);\n    pieces_availability->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);\n\n    // Tracker list\n    trackerList = new TrackerList(this);\n    trackerUpButton->setIcon(GuiIconProvider::instance()->getIcon(\"go-up\"));\n    trackerUpButton->setIconSize(Utils::Misc::smallIconSize());\n    trackerDownButton->setIcon(GuiIconProvider::instance()->getIcon(\"go-down\"));\n    trackerDownButton->setIconSize(Utils::Misc::smallIconSize());\n    connect(trackerUpButton, SIGNAL(clicked()), trackerList, SLOT(moveSelectionUp()));\n    connect(trackerDownButton, SIGNAL(clicked()), trackerList, SLOT(moveSelectionDown()));\n    horizontalLayout_trackers->insertWidget(0, trackerList);\n    connect(trackerList->header(), SIGNAL(sectionMoved(int,int,int)), trackerList, SLOT(saveSettings()));\n    connect(trackerList->header(), SIGNAL(sectionResized(int,int,int)), trackerList, SLOT(saveSettings()));\n    connect(trackerList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), trackerList, SLOT(saveSettings()));\n    // Peers list\n    peersList = new PeerListWidget(this);\n    peerpage_layout->addWidget(peersList);\n    connect(peersList->header(), SIGNAL(sectionMoved(int,int,int)), peersList, SLOT(saveSettings()));\n    connect(peersList->header(), SIGNAL(sectionResized(int,int,int)), peersList, SLOT(saveSettings()));\n    connect(peersList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), peersList, SLOT(saveSettings()));\n    // Speed widget\n    speedWidget = new SpeedWidget(this);\n    speed_layout->addWidget(speedWidget);\n    // Tab bar\n    m_tabBar = new PropTabBar();\n    m_tabBar->setContentsMargins(0, 5, 0, 0);\n    verticalLayout->addLayout(m_tabBar);\n    connect(m_tabBar, SIGNAL(tabChanged(int)), stackedProperties, SLOT(setCurrentIndex(int)));\n    connect(m_tabBar, SIGNAL(tabChanged(int)), this, SLOT(saveSettings()));\n    connect(m_tabBar, SIGNAL(visibilityToggled(bool)), SLOT(setVisibility(bool)));\n    connect(m_tabBar, SIGNAL(visibilityToggled(bool)), this, SLOT(saveSettings()));\n    // Dynamic data refresher\n    refreshTimer = new QTimer(this);\n    connect(refreshTimer, SIGNAL(timeout()), this, SLOT(loadDynamicData()));\n    refreshTimer->start(3000); // 3sec\n    editHotkeyFile = new QShortcut(Qt::Key_F2, filesList, 0, 0, Qt::WidgetShortcut);\n    connect(editHotkeyFile, SIGNAL(activated()), SLOT(renameSelectedFile()));\n    editHotkeyWeb = new QShortcut(Qt::Key_F2, listWebSeeds, 0, 0, Qt::WidgetShortcut);\n    connect(editHotkeyWeb, SIGNAL(activated()), SLOT(editWebSeed()));\n    connect(listWebSeeds, SIGNAL(doubleClicked(QModelIndex)), SLOT(editWebSeed()));\n    deleteHotkeyWeb = new QShortcut(QKeySequence::Delete, listWebSeeds, 0, 0, Qt::WidgetShortcut);\n    connect(deleteHotkeyWeb, SIGNAL(activated()), SLOT(deleteSelectedUrlSeeds()));\n    openHotkeyFile = new QShortcut(Qt::Key_Return, filesList, 0, 0, Qt::WidgetShortcut);\n    connect(openHotkeyFile, SIGNAL(activated()), SLOT(openSelectedFile()));\n}\n\nPropertiesWidget::~PropertiesWidget()\n{\n    qDebug() << Q_FUNC_INFO << \"ENTER\";\n    delete refreshTimer;\n    delete trackerList;\n    delete peersList;\n    delete speedWidget;\n    delete downloaded_pieces;\n    delete pieces_availability;\n    delete PropListModel;\n    delete PropDelegate;\n    delete m_tabBar;\n    delete editHotkeyFile;\n    delete editHotkeyWeb;\n    delete deleteHotkeyWeb;\n    delete openHotkeyFile;\n    qDebug() << Q_FUNC_INFO << \"EXIT\";\n}\n\nvoid PropertiesWidget::showPiecesAvailability(bool show)\n{\n    avail_pieces_lbl->setVisible(show);\n    pieces_availability->setVisible(show);\n    avail_average_lbl->setVisible(show);\n    if (show || !downloaded_pieces->isVisible())\n        line_2->setVisible(show);\n}\n\nvoid PropertiesWidget::showPiecesDownloaded(bool show)\n{\n    downloaded_pieces_lbl->setVisible(show);\n    downloaded_pieces->setVisible(show);\n    progress_lbl->setVisible(show);\n    if (show || !pieces_availability->isVisible())\n        line_2->setVisible(show);\n}\n\nvoid PropertiesWidget::setVisibility(bool visible)\n{\n    if (!visible && ( state == VISIBLE) ) {\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        stackedProperties->setVisible(false);\n        slideSizes = hSplitter->sizes();\n        hSplitter->handle(1)->setVisible(false);\n        hSplitter->handle(1)->setDisabled(true);\n        QList<int> sizes = QList<int>() << hSplitter->geometry().height() - 30 << 30;\n        hSplitter->setSizes(sizes);\n        state = REDUCED;\n        return;\n    }\n\n    if (visible && ( state == REDUCED) ) {\n        stackedProperties->setVisible(true);\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        hSplitter->handle(1)->setDisabled(false);\n        hSplitter->handle(1)->setVisible(true);\n        hSplitter->setSizes(slideSizes);\n        state = VISIBLE;\n        // Force refresh\n        loadDynamicData();\n    }\n}\n\nvoid PropertiesWidget::clear()\n{\n    qDebug(\"Clearing torrent properties\");\n    save_path->clear();\n    lbl_creationDate->clear();\n    label_total_pieces_val->clear();\n    hash_lbl->clear();\n    comment_text->clear();\n    progress_lbl->clear();\n    trackerList->clear();\n    downloaded_pieces->clear();\n    pieces_availability->clear();\n    avail_average_lbl->clear();\n    wasted->clear();\n    upTotal->clear();\n    dlTotal->clear();\n    peersList->clear();\n    lbl_uplimit->clear();\n    lbl_dllimit->clear();\n    lbl_elapsed->clear();\n    lbl_connections->clear();\n    reannounce_lbl->clear();\n    shareRatio->clear();\n    listWebSeeds->clear();\n    m_contentFilterLine->clear();\n    PropListModel->model()->clear();\n    label_eta_val->clear();\n    label_seeds_val->clear();\n    label_peers_val->clear();\n    label_dl_speed_val->clear();\n    label_upload_speed_val->clear();\n    label_total_size_val->clear();\n    label_completed_on_val->clear();\n    label_last_complete_val->clear();\n    label_created_by_val->clear();\n    label_added_on_val->clear();\n}\n\nBitTorrent::TorrentHandle *PropertiesWidget::getCurrentTorrent() const\n{\n    return m_torrent;\n}\n\nvoid PropertiesWidget::updateSavePath(BitTorrent::TorrentHandle *const torrent)\n{\n    if (m_torrent == torrent)\n        save_path->setText(Utils::Fs::toNativePath(m_torrent->savePath()));\n}\n\nvoid PropertiesWidget::loadTrackers(BitTorrent::TorrentHandle *const torrent)\n{\n    if (torrent == m_torrent)\n        trackerList->loadTrackers();\n}\n\nvoid PropertiesWidget::updateTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    if (m_torrent == torrent)\n        loadTorrentInfos(m_torrent);\n}\n\nvoid PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(m_torrent->creator());\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}\n\nvoid PropertiesWidget::readSettings()\n{\n    const Preferences *const pref = Preferences::instance();\n    // Restore splitter sizes\n    QStringList sizes_str = pref->getPropSplitterSizes().split(\",\");\n    if (sizes_str.size() == 2) {\n        slideSizes << sizes_str.first().toInt();\n        slideSizes << sizes_str.last().toInt();\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        hSplitter->setSizes(slideSizes);\n    }\n    const int current_tab = pref->getPropCurTab();\n    const bool visible = pref->getPropVisible();\n    // the following will call saveSettings but shouldn't change any state\n    if (!filesList->header()->restoreState(pref->getPropFileListState()))\n        filesList->header()->resizeSection(0, 400); // Default\n    m_tabBar->setCurrentIndex(current_tab);\n    if (!visible)\n        setVisibility(false);\n}\n\nvoid PropertiesWidget::saveSettings()\n{\n    Preferences *const pref = Preferences::instance();\n    pref->setPropVisible(state==VISIBLE);\n    // Splitter sizes\n    QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n    QList<int> sizes;\n    if (state == VISIBLE)\n        sizes = hSplitter->sizes();\n    else\n        sizes = slideSizes;\n    qDebug(\"Sizes: %d\", sizes.size());\n    if (sizes.size() == 2)\n        pref->setPropSplitterSizes(QString::number(sizes.first()) + ',' + QString::number(sizes.last()));\n    pref->setPropFileListState(filesList->header()->saveState());\n    // Remember current tab\n    pref->setPropCurTab(m_tabBar->currentIndex());\n}\n\nvoid PropertiesWidget::reloadPreferences()\n{\n    // Take program preferences into consideration\n    peersList->updatePeerHostNameResolutionState();\n    peersList->updatePeerCountryResolutionState();\n}\n\nvoid PropertiesWidget::loadDynamicData()\n{\n    // Refresh only if the torrent handle is valid and if visible\n    if (!m_torrent || (main_window->currentTabWidget() != transferList) || (state != VISIBLE)) return;\n\n    // Transfer infos\n    switch (stackedProperties->currentIndex()) {\n    case PropTabBar::MAIN_TAB: {\n        wasted->setText(Utils::Misc::friendlyUnit(m_torrent->wastedSize()));\n\n        upTotal->setText(tr(\"%1 (%2 this session)\").arg(Utils::Misc::friendlyUnit(m_torrent->totalUpload()))\n                         .arg(Utils::Misc::friendlyUnit(m_torrent->totalPayloadUpload())));\n\n        dlTotal->setText(tr(\"%1 (%2 this session)\").arg(Utils::Misc::friendlyUnit(m_torrent->totalDownload()))\n                         .arg(Utils::Misc::friendlyUnit(m_torrent->totalPayloadDownload())));\n\n        lbl_uplimit->setText(m_torrent->uploadLimit() <= 0 ? QString::fromUtf8(C_INFINITY) : Utils::Misc::friendlyUnit(m_torrent->uploadLimit(), true));\n\n        lbl_dllimit->setText(m_torrent->downloadLimit() <= 0 ? QString::fromUtf8(C_INFINITY) : Utils::Misc::friendlyUnit(m_torrent->downloadLimit(), true));\n\n        QString elapsed_txt;\n        if (m_torrent->isSeed())\n            elapsed_txt = tr(\"%1 (seeded for %2)\", \"e.g. 4m39s (seeded for 3m10s)\")\n                          .arg(Utils::Misc::userFriendlyDuration(m_torrent->activeTime()))\n                          .arg(Utils::Misc::userFriendlyDuration(m_torrent->seedingTime()));\n        else\n            elapsed_txt = Utils::Misc::userFriendlyDuration(m_torrent->activeTime());\n        lbl_elapsed->setText(elapsed_txt);\n\n        lbl_connections->setText(tr(\"%1 (%2 max)\", \"%1 and %2 are numbers, e.g. 3 (10 max)\")\n                                 .arg(m_torrent->connectionsCount())\n                                 .arg(m_torrent->connectionsLimit() < 0 ? QString::fromUtf8(C_INFINITY) : QString::number(m_torrent->connectionsLimit())));\n\n        label_eta_val->setText(Utils::Misc::userFriendlyDuration(m_torrent->eta()));\n\n        // Update next announce time\n        reannounce_lbl->setText(Utils::Misc::userFriendlyDuration(m_torrent->nextAnnounce()));\n\n        // Update ratio info\n        const qreal ratio = m_torrent->realRatio();\n        shareRatio->setText(ratio > BitTorrent::TorrentHandle::MAX_RATIO ? QString::fromUtf8(C_INFINITY) : Utils::String::fromDouble(ratio, 2));\n\n        label_seeds_val->setText(tr(\"%1 (%2 total)\", \"%1 and %2 are numbers, e.g. 3 (10 total)\")\n                                 .arg(QString::number(m_torrent->seedsCount()))\n                                 .arg(QString::number(m_torrent->totalSeedsCount())));\n\n        label_peers_val->setText(tr(\"%1 (%2 total)\", \"%1 and %2 are numbers, e.g. 3 (10 total)\")\n                                 .arg(QString::number(m_torrent->leechsCount()))\n                                 .arg(QString::number(m_torrent->totalLeechersCount())));\n\n        label_dl_speed_val->setText(tr(\"%1 (%2 avg.)\", \"%1 and %2 are speed rates, e.g. 200KiB/s (100KiB/s avg.)\")\n                                    .arg(Utils::Misc::friendlyUnit(m_torrent->downloadPayloadRate(), true))\n                                    .arg(Utils::Misc::friendlyUnit(m_torrent->totalDownload() / (1 + m_torrent->activeTime() - m_torrent->finishedTime()), true)));\n\n        label_upload_speed_val->setText(tr(\"%1 (%2 avg.)\", \"%1 and %2 are speed rates, e.g. 200KiB/s (100KiB/s avg.)\")\n                                        .arg(Utils::Misc::friendlyUnit(m_torrent->uploadPayloadRate(), true))\n                                        .arg(Utils::Misc::friendlyUnit(m_torrent->totalUpload() / (1 + m_torrent->activeTime()), true)));\n\n        label_last_complete_val->setText(m_torrent->lastSeenComplete().isValid() ? m_torrent->lastSeenComplete().toString(Qt::DefaultLocaleShortDate) : tr(\"Never\"));\n\n        label_completed_on_val->setText(m_torrent->completedTime().isValid() ? m_torrent->completedTime().toString(Qt::DefaultLocaleShortDate) : \"\");\n\n        label_added_on_val->setText(m_torrent->addedTime().toString(Qt::DefaultLocaleShortDate));\n\n        if (m_torrent->hasMetadata()) {\n            label_total_pieces_val->setText(tr(\"%1 x %2 (have %3)\", \"(torrent pieces) eg 152 x 4MB (have 25)\").arg(m_torrent->piecesCount()).arg(Utils::Misc::friendlyUnit(m_torrent->pieceLength())).arg(m_torrent->piecesHave()));\n\n            if (!m_torrent->isSeed() && !m_torrent->isPaused() && !m_torrent->isQueued() && !m_torrent->isChecking()) {\n                // Pieces availability\n                showPiecesAvailability(true);\n                pieces_availability->setAvailability(m_torrent->pieceAvailability());\n                avail_average_lbl->setText(Utils::String::fromDouble(m_torrent->distributedCopies(), 3));\n            }\n            else {\n                showPiecesAvailability(false);\n            }\n\n            // Progress\n            qreal progress = m_torrent->progress() * 100.;\n            progress_lbl->setText(Utils::String::fromDouble(progress, 1) + \"%\");\n            downloaded_pieces->setProgress(m_torrent->pieces(), m_torrent->downloadingPieces());\n        }\n        else {\n            showPiecesAvailability(false);\n        }\n\n        break;\n    }\n\n    case PropTabBar::TRACKERS_TAB: {\n        // Trackers\n        trackerList->loadTrackers();\n        break;\n    }\n\n    case PropTabBar::PEERS_TAB: {\n        // Load peers\n        peersList->loadPeers(m_torrent);\n        break;\n    }\n\n    case PropTabBar::FILES_TAB: {\n        // Files progress\n        if (m_torrent->hasMetadata()) {\n            qDebug(\"Updating priorities in files tab\");\n            filesList->setUpdatesEnabled(false);\n            PropListModel->model()->updateFilesProgress(m_torrent->filesProgress());\n            // XXX: We don't update file priorities regularly for performance\n            // reasons. This means that priorities will not be updated if\n            // set from the Web UI.\n            // PropListModel->model()->updateFilesPriorities(h.file_priorities());\n            filesList->setUpdatesEnabled(true);\n        }\n        break;\n    }\n\n    default:;\n    }\n}\n\nvoid PropertiesWidget::loadUrlSeeds()\n{\n    listWebSeeds->clear();\n    qDebug(\"Loading URL seeds\");\n    const QList<QUrl> hc_seeds = m_torrent->urlSeeds();\n    // Add url seeds\n    foreach (const QUrl &hc_seed, hc_seeds) {\n        qDebug(\"Loading URL seed: %s\", qPrintable(hc_seed.toString()));\n        new QListWidgetItem(hc_seed.toString(), listWebSeeds);\n    }\n}\n\nvoid PropertiesWidget::openDoubleClickedFile(const QModelIndex &index)\n{\n    if (!index.isValid()) return;\n    if (!m_torrent || !m_torrent->hasMetadata()) return;\n    if (PropListModel->itemType(index) == TorrentContentModelItem::FileType)\n        openFile(index);\n    else\n        openFolder(index, false);\n}\n\nvoid PropertiesWidget::openFile(const QModelIndex &index)\n{\n    int i = PropListModel->getFileIndex(index);\n    const QDir saveDir(m_torrent->savePath(true));\n    const QString filename = m_torrent->filePath(i);\n    const QString file_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(filename));\n    qDebug(\"Trying to open file at %s\", qPrintable(file_path));\n    // Flush data\n    m_torrent->flushCache();\n    Utils::Misc::openPath(file_path);\n}\n\nvoid PropertiesWidget::openFolder(const QModelIndex &index, bool containing_folder)\n{\n    QString absolute_path;\n    // FOLDER\n    if (PropListModel->itemType(index) == TorrentContentModelItem::FolderType) {\n        // Generate relative path to selected folder\n        QStringList path_items;\n        path_items << index.data().toString();\n        QModelIndex parent = PropListModel->parent(index);\n        while (parent.isValid()) {\n            path_items.prepend(parent.data().toString());\n            parent = PropListModel->parent(parent);\n        }\n        if (path_items.isEmpty())\n            return;\n        const QDir saveDir(m_torrent->savePath(true));\n        const QString relative_path = path_items.join(\"/\");\n        absolute_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(relative_path));\n    }\n    else {\n        int i = PropListModel->getFileIndex(index);\n        const QDir saveDir(m_torrent->savePath(true));\n        const QString relative_path = m_torrent->filePath(i);\n        absolute_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(relative_path));\n    }\n\n    // Flush data\n    m_torrent->flushCache();\n    if (containing_folder)\n        Utils::Misc::openFolderSelect(absolute_path);\n    else\n        Utils::Misc::openPath(absolute_path);\n}\n\nvoid PropertiesWidget::displayFilesListMenu(const QPoint &)\n{\n    if (!m_torrent) return;\n\n    QModelIndexList selectedRows = filesList->selectionModel()->selectedRows(0);\n    if (selectedRows.empty())\n        return;\n    QMenu myFilesLlistMenu;\n    QAction *actOpen = 0;\n    QAction *actOpenContainingFolder = 0;\n    QAction *actRename = 0;\n    if (selectedRows.size() == 1) {\n        actOpen = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"folder-documents\"), tr(\"Open\"));\n        actOpenContainingFolder = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"inode-directory\"), tr(\"Open Containing Folder\"));\n        actRename = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-rename\"), tr(\"Rename...\"));\n        myFilesLlistMenu.addSeparator();\n    }\n    QMenu subMenu;\n    if (!m_torrent->isSeed()) {\n        subMenu.setTitle(tr(\"Priority\"));\n        subMenu.addAction(actionNot_downloaded);\n        subMenu.addAction(actionNormal);\n        subMenu.addAction(actionHigh);\n        subMenu.addAction(actionMaximum);\n        myFilesLlistMenu.addMenu(&subMenu);\n    }\n    // Call menu\n    const QAction *act = myFilesLlistMenu.exec(QCursor::pos());\n    // The selected torrent might have disappeared during exec()\n    // from the current view thus leaving invalid indices.\n    const QModelIndex index = *(selectedRows.begin());\n    if (!index.isValid())\n        return;\n    if (act) {\n        if (act == actOpen) {\n            openDoubleClickedFile(index);\n        }\n        else if (act == actOpenContainingFolder) {\n            openFolder(index, true);\n        }\n        else if (act == actRename) {\n            renameSelectedFile();\n        }\n        else {\n            int prio = prio::NORMAL;\n            if (act == actionHigh)\n                prio = prio::HIGH;\n            else if (act == actionMaximum)\n                prio = prio::MAXIMUM;\n            else if (act == actionNot_downloaded)\n                prio = prio::IGNORED;\n\n            qDebug(\"Setting files priority\");\n            foreach (QModelIndex index, selectedRows) {\n                qDebug(\"Setting priority(%d) for file at row %d\", prio, index.row());\n                PropListModel->setData(PropListModel->index(index.row(), PRIORITY, index.parent()), prio);\n            }\n            // Save changes\n            filteredFilesChanged();\n        }\n    }\n}\n\nvoid PropertiesWidget::displayWebSeedListMenu(const QPoint &)\n{\n    if (!m_torrent) return;\n\n    QMenu seedMenu;\n    QModelIndexList rows = listWebSeeds->selectionModel()->selectedRows();\n    QAction *actAdd = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"list-add\"), tr(\"New Web seed\"));\n    QAction *actDel = 0;\n    QAction *actCpy = 0;\n    QAction *actEdit = 0;\n\n    if (rows.size()) {\n        actDel = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"list-remove\"), tr(\"Remove Web seed\"));\n        seedMenu.addSeparator();\n        actCpy = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-copy\"), tr(\"Copy Web seed URL\"));\n        actEdit = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-rename\"), tr(\"Edit Web seed URL\"));\n    }\n\n    const QAction *act = seedMenu.exec(QCursor::pos());\n    if (act) {\n        if (act == actAdd)\n            askWebSeed();\n        else if (act == actDel)\n            deleteSelectedUrlSeeds();\n        else if (act == actCpy)\n            copySelectedWebSeedsToClipboard();\n        else if (act == actEdit)\n            editWebSeed();\n    }\n}\n\nvoid PropertiesWidget::renameSelectedFile()\n{\n    const QModelIndexList selectedIndexes = filesList->selectionModel()->selectedRows(0);\n    if (selectedIndexes.size() != 1)\n        return;\n    const QModelIndex index = selectedIndexes.first();\n    if (!index.isValid())\n        return;\n    // Ask for new name\n    bool ok;\n    QString new_name_last = AutoExpandableDialog::getText(this, tr(\"Rename the file\"),\n                                                          tr(\"New name:\"), QLineEdit::Normal,\n                                                          index.data().toString(), &ok).trimmed();\n    if (ok && !new_name_last.isEmpty()) {\n        if (!Utils::Fs::isValidFileSystemName(new_name_last)) {\n            MessageBoxRaised::warning(this, tr(\"The file could not be renamed\"),\n                                      tr(\"This file name contains forbidden characters, please choose a different one.\"),\n                                      QMessageBox::Ok);\n            return;\n        }\n        if (PropListModel->itemType(index) == TorrentContentModelItem::FileType) {\n            // File renaming\n            const int file_index = PropListModel->getFileIndex(index);\n            if (!m_torrent || !m_torrent->hasMetadata()) return;\n            QString old_name = m_torrent->filePath(file_index);\n            if (old_name.endsWith(\".!qB\") && !new_name_last.endsWith(\".!qB\"))\n                new_name_last += \".!qB\";\n            QStringList path_items = old_name.split(\"/\");\n            path_items.removeLast();\n            path_items << new_name_last;\n            QString new_name = path_items.join(\"/\");\n            if (Utils::Fs::sameFileNames(old_name, new_name)) {\n                qDebug(\"Name did not change\");\n                return;\n            }\n            new_name = Utils::Fs::expandPath(new_name);\n            qDebug(\"New name: %s\", qPrintable(new_name));\n            // Check if that name is already used\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                if (i == file_index) continue;\n                if (Utils::Fs::sameFileNames(m_torrent->filePath(i), new_name)) {\n                    // Display error message\n                    MessageBoxRaised::warning(this, tr(\"The file could not be renamed\"),\n                                              tr(\"This name is already in use in this folder. Please use a different name.\"),\n                                              QMessageBox::Ok);\n                    return;\n                }\n            }\n            const bool force_recheck = QFile::exists(m_torrent->savePath(true) + \"/\" + new_name);\n            qDebug(\"Renaming %s to %s\", qPrintable(old_name), qPrintable(new_name));\n            m_torrent->renameFile(file_index, new_name);\n            // Force recheck\n            if (force_recheck) m_torrent->forceRecheck();\n            // Rename if torrent files model too\n            if (new_name_last.endsWith(\".!qB\"))\n                new_name_last.chop(4);\n            PropListModel->setData(index, new_name_last);\n        }\n        else {\n            // Folder renaming\n            QStringList path_items;\n            path_items << index.data().toString();\n            QModelIndex parent = PropListModel->parent(index);\n            while (parent.isValid()) {\n                path_items.prepend(parent.data().toString());\n                parent = PropListModel->parent(parent);\n            }\n            const QString old_path = path_items.join(\"/\");\n            path_items.removeLast();\n            path_items << new_name_last;\n            QString new_path = path_items.join(\"/\");\n            if (Utils::Fs::sameFileNames(old_path, new_path)) {\n                qDebug(\"Name did not change\");\n                return;\n            }\n            if (!new_path.endsWith(\"/\")) new_path += \"/\";\n            // Check for overwriting\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                const QString &current_name = m_torrent->filePath(i);\n#if defined(Q_OS_UNIX) || defined(Q_WS_QWS)\n                if (current_name.startsWith(new_path, Qt::CaseSensitive)) {\n#else\n                if (current_name.startsWith(new_path, Qt::CaseInsensitive)) {\n#endif\n                    QMessageBox::warning(this, tr(\"The folder could not be renamed\"),\n                                         tr(\"This name is already in use in this folder. Please use a different name.\"),\n                                         QMessageBox::Ok);\n                    return;\n                }\n            }\n            bool force_recheck = false;\n            // Replace path in all files\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                const QString current_name = m_torrent->filePath(i);\n                if (current_name.startsWith(old_path)) {\n                    QString new_name = current_name;\n                    new_name.replace(0, old_path.length(), new_path);\n                    if (!force_recheck && QDir(m_torrent->savePath(true)).exists(new_name))\n                        force_recheck = true;\n                    new_name = Utils::Fs::expandPath(new_name);\n                    qDebug(\"Rename %s to %s\", qPrintable(current_name), qPrintable(new_name));\n                    m_torrent->renameFile(i, new_name);\n                }\n            }\n            // Force recheck\n            if (force_recheck) m_torrent->forceRecheck();\n            // Rename folder in torrent files model too\n            PropListModel->setData(index, new_name_last);\n            // Remove old folder\n            const QDir old_folder(m_torrent->savePath(true) + \"/\" + old_path);\n            int timeout = 10;\n            while (!QDir().rmpath(old_folder.absolutePath()) && timeout > 0) {\n                // FIXME: We should not sleep here (freezes the UI for 1 second)\n                Utils::Misc::msleep(100);\n                --timeout;\n            }\n        }\n    }\n}\n\nvoid PropertiesWidget::openSelectedFile()\n{\n    const QModelIndexList selectedIndexes = filesList->selectionModel()->selectedRows(0);\n    if (selectedIndexes.size() != 1)\n        return;\n    openDoubleClickedFile(selectedIndexes.first());\n}\n\nvoid PropertiesWidget::askWebSeed()\n{\n    bool ok;\n    // Ask user for a new url seed\n    const QString url_seed = AutoExpandableDialog::getText(this, tr(\"New URL seed\", \"New HTTP source\"),\n                                                           tr(\"New URL seed:\"), QLineEdit::Normal,\n                                                           QString::fromUtf8(\"http://www.\"), &ok);\n    if (!ok) return;\n    qDebug(\"Adding %s web seed\", qPrintable(url_seed));\n    if (!listWebSeeds->findItems(url_seed, Qt::MatchFixedString).empty()) {\n        QMessageBox::warning(this, \"qBittorrent\",\n                             tr(\"This URL seed is already in the list.\"),\n                             QMessageBox::Ok);\n        return;\n    }\n    if (m_torrent)\n        m_torrent->addUrlSeeds(QList<QUrl>() << url_seed);\n    // Refresh the seeds list\n    loadUrlSeeds();\n}\n\nvoid PropertiesWidget::deleteSelectedUrlSeeds()\n{\n    const QList<QListWidgetItem *> selectedItems = listWebSeeds->selectedItems();\n    if (selectedItems.isEmpty()) return;\n\n    QList<QUrl> urlSeeds;\n    foreach (const QListWidgetItem *item, selectedItems)\n        urlSeeds << item->text();\n\n    m_torrent->removeUrlSeeds(urlSeeds);\n    // Refresh list\n    loadUrlSeeds();\n}\n\nvoid PropertiesWidget::copySelectedWebSeedsToClipboard() const\n{\n    const QList<QListWidgetItem *> selected_items = listWebSeeds->selectedItems();\n    if (selected_items.isEmpty())\n        return;\n\n    QStringList urls_to_copy;\n    foreach (QListWidgetItem *item, selected_items)\n        urls_to_copy << item->text();\n\n    QApplication::clipboard()->setText(urls_to_copy.join(\"\\n\"));\n}\n\nvoid PropertiesWidget::editWebSeed()\n{\n    const QList<QListWidgetItem *> selected_items = listWebSeeds->selectedItems();\n    if (selected_items.size() != 1)\n        return;\n\n    const QListWidgetItem *selected_item = selected_items.last();\n    const QString old_seed = selected_item->text();\n    bool result;\n    const QString new_seed = AutoExpandableDialog::getText(this, tr(\"Web seed editing\"),\n                                                           tr(\"Web seed URL:\"), QLineEdit::Normal,\n                                                           old_seed, &result);\n    if (!result)\n        return;\n\n    if (!listWebSeeds->findItems(new_seed, Qt::MatchFixedString).empty()) {\n        QMessageBox::warning(this, tr(\"qBittorrent\"),\n                             tr(\"This URL seed is already in the list.\"),\n                             QMessageBox::Ok);\n        return;\n    }\n\n    m_torrent->removeUrlSeeds(QList<QUrl>() << old_seed);\n    m_torrent->addUrlSeeds(QList<QUrl>() << new_seed);\n    loadUrlSeeds();\n}\n\nbool PropertiesWidget::applyPriorities()\n{\n    qDebug(\"Saving files priorities\");\n    const QVector<int> priorities = PropListModel->model()->getFilePriorities();\n    // Prioritize the files\n    qDebug(\"prioritize files: %d\", priorities[0]);\n    m_torrent->prioritizeFiles(priorities);\n    return true;\n}\n\nvoid PropertiesWidget::filteredFilesChanged()\n{\n    if (m_torrent)\n        applyPriorities();\n}\n\nvoid PropertiesWidget::filterText(const QString &filter)\n{\n    PropListModel->setFilterRegExp(QRegExp(filter, Qt::CaseInsensitive, QRegExp::WildcardUnix));\n    if (filter.isEmpty()) {\n        filesList->collapseAll();\n        filesList->expand(PropListModel->index(0, 0));\n    }\n    else {\n        filesList->expandAll();\n    }\n}\n"], "fixing_code": ["#include \"logger.h\"\n\n#include <QDateTime>\n#include \"base/utils/string.h\"\n\nLogger* Logger::m_instance = 0;\n\nLogger::Logger()\n    : lock(QReadWriteLock::Recursive)\n    , msgCounter(0)\n    , peerCounter(0)\n{\n}\n\nLogger::~Logger() {}\n\nLogger *Logger::instance()\n{\n    return m_instance;\n}\n\nvoid Logger::initInstance()\n{\n    if (!m_instance)\n        m_instance = new Logger;\n}\n\nvoid Logger::freeInstance()\n{\n    if (m_instance) {\n        delete m_instance;\n        m_instance = 0;\n    }\n}\n\nvoid Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}\n\nvoid Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}\n\nQVector<Log::Msg> Logger::getMessages(int lastKnownId) const\n{\n    QReadLocker locker(&lock);\n\n    int diff = msgCounter - lastKnownId - 1;\n    int size = m_messages.size();\n\n    if ((lastKnownId == -1) || (diff >= size))\n        return m_messages;\n\n    if (diff <= 0)\n        return QVector<Log::Msg>();\n\n    return m_messages.mid(size - diff);\n}\n\nQVector<Log::Peer> Logger::getPeers(int lastKnownId) const\n{\n    QReadLocker locker(&lock);\n\n    int diff = peerCounter - lastKnownId - 1;\n    int size = m_peers.size();\n\n    if ((lastKnownId == -1) || (diff >= size))\n        return m_peers;\n\n    if (diff <= 0)\n        return QVector<Log::Peer>();\n\n    return m_peers.mid(size - diff);\n}\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>\n * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#include \"string.h\"\n\n#include <cmath>\n\n#include <QByteArray>\n#include <QtGlobal>\n#include <QLocale>\n#ifdef QBT_USES_QT5\n#include <QCollator>\n#endif\n#ifdef Q_OS_MAC\n#include <QThreadStorage>\n#endif\n\nnamespace\n{\n    class NaturalCompare\n    {\n    public:\n        explicit NaturalCompare(const bool caseSensitive = true)\n            : m_caseSensitive(caseSensitive)\n        {\n#ifdef QBT_USES_QT5\n#if defined(Q_OS_WIN)\n            // Without ICU library, QCollator uses the native API on Windows 7+. But that API\n            // sorts older versions of \u03bcTorrent differently than the newer ones because the\n            // '\u03bc' character is encoded differently and the native API can't cope with that.\n            // So default to using our custom natural sorting algorithm instead.\n            // See #5238 and #5240\n            // Without ICU library, QCollator doesn't support `setNumericMode(true)` on OS older than Win7\n            // if (QSysInfo::windowsVersion() < QSysInfo::WV_WINDOWS7)\n                return;\n#endif\n            m_collator.setNumericMode(true);\n            m_collator.setCaseSensitivity(caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n#endif\n        }\n\n        bool operator()(const QString &left, const QString &right) const\n        {\n#ifdef QBT_USES_QT5\n#if defined(Q_OS_WIN)\n            // Without ICU library, QCollator uses the native API on Windows 7+. But that API\n            // sorts older versions of \u03bcTorrent differently than the newer ones because the\n            // '\u03bc' character is encoded differently and the native API can't cope with that.\n            // So default to using our custom natural sorting algorithm instead.\n            // See #5238 and #5240\n            // Without ICU library, QCollator doesn't support `setNumericMode(true)` on OS older than Win7\n            // if (QSysInfo::windowsVersion() < QSysInfo::WV_WINDOWS7)\n                return lessThan(left, right);\n#endif\n            return (m_collator.compare(left, right) < 0);\n#else\n            return lessThan(left, right);\n#endif\n        }\n\n        bool lessThan(const QString &left, const QString &right) const\n        {\n            // Return value `false` indicates `right` should go before `left`, otherwise, after\n            int posL = 0;\n            int posR = 0;\n            while (true) {\n                while (true) {\n                    if ((posL == left.size()) || (posR == right.size()))\n                        return (left.size() < right.size());  // when a shorter string is another string's prefix, shorter string place before longer string\n\n                    QChar leftChar = m_caseSensitive ? left[posL] : left[posL].toLower();\n                    QChar rightChar = m_caseSensitive ? right[posR] : right[posR].toLower();\n                    if (leftChar == rightChar)\n                        ;  // compare next character\n                    else if (leftChar.isDigit() && rightChar.isDigit())\n                        break; // Both are digits, break this loop and compare numbers\n                    else\n                        return leftChar < rightChar;\n\n                    ++posL;\n                    ++posR;\n                }\n\n                int startL = posL;\n                while ((posL < left.size()) && left[posL].isDigit())\n                    ++posL;\n#ifdef QBT_USES_QT5\n                int numL = left.midRef(startL, posL - startL).toInt();\n#else\n                int numL = left.mid(startL, posL - startL).toInt();\n#endif\n\n                int startR = posR;\n                while ((posR < right.size()) && right[posR].isDigit())\n                    ++posR;\n#ifdef QBT_USES_QT5\n                int numR = right.midRef(startR, posR - startR).toInt();\n#else\n                int numR = right.mid(startR, posR - startR).toInt();\n#endif\n\n                if (numL != numR)\n                    return (numL < numR);\n\n                // Strings + digits do match and we haven't hit string end\n                // Do another round\n            }\n            return false;\n        }\n\n    private:\n#ifdef QBT_USES_QT5\n        QCollator m_collator;\n#endif\n        const bool m_caseSensitive;\n    };\n}\n\nbool Utils::String::naturalCompareCaseSensitive(const QString &left, const QString &right)\n{\n    // provide a single `NaturalCompare` instance for easy use\n    // https://doc.qt.io/qt-5/threads-reentrancy.html\n#ifdef Q_OS_MAC  // workaround for Apple xcode: https://stackoverflow.com/a/29929949\n    static QThreadStorage<NaturalCompare> nCmp;\n    if (!nCmp.hasLocalData()) nCmp.setLocalData(NaturalCompare(true));\n    return (nCmp.localData())(left, right);\n#else\n    thread_local NaturalCompare nCmp(true);\n    return nCmp(left, right);\n#endif\n}\n\nbool Utils::String::naturalCompareCaseInsensitive(const QString &left, const QString &right)\n{\n    // provide a single `NaturalCompare` instance for easy use\n    // https://doc.qt.io/qt-5/threads-reentrancy.html\n#ifdef Q_OS_MAC  // workaround for Apple xcode: https://stackoverflow.com/a/29929949\n    static QThreadStorage<NaturalCompare> nCmp;\n    if (!nCmp.hasLocalData()) nCmp.setLocalData(NaturalCompare(false));\n    return (nCmp.localData())(left, right);\n#else\n    thread_local NaturalCompare nCmp(false);\n    return nCmp(left, right);\n#endif\n}\n\nQString Utils::String::fromStdString(const std::string &str)\n{\n    return QString::fromUtf8(str.c_str());\n}\n\nstd::string Utils::String::toStdString(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toStdString();\n#else\n    QByteArray utf8 = str.toUtf8();\n    return std::string(utf8.constData(), utf8.length());\n#endif\n}\n\n// to send numbers instead of strings with suffixes\nQString Utils::String::fromDouble(double n, int precision)\n{\n    /* HACK because QString rounds up. Eg QString::number(0.999*100.0, 'f' ,1) == 99.9\n    ** but QString::number(0.9999*100.0, 'f' ,1) == 100.0 The problem manifests when\n    ** the number has more digits after the decimal than we want AND the digit after\n    ** our 'wanted' is >= 5. In this case our last digit gets rounded up. So for each\n    ** precision we add an extra 0 behind 1 in the below algorithm. */\n\n    double prec = std::pow(10.0, precision);\n    return QLocale::system().toString(std::floor(n * prec) / prec, 'f', precision);\n}\n\n// Implements constant-time comparison to protect against timing attacks\n// Taken from https://crackstation.net/hashing-security.htm\nbool Utils::String::slowEquals(const QByteArray &a, const QByteArray &b)\n{\n    int lengthA = a.length();\n    int lengthB = b.length();\n\n    int diff = lengthA ^ lengthB;\n    for (int i = 0; (i < lengthA) && (i < lengthB); i++)\n        diff |= a[i] ^ b[i];\n\n    return (diff == 0);\n}\n\nQString Utils::String::toHtmlEscaped(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toHtmlEscaped();\n#else\n    return Qt::escape(str);\n#endif\n}\n", "/*\n * Bittorrent Client using Qt and libtorrent.\n * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>\n * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n */\n\n#ifndef UTILS_STRING_H\n#define UTILS_STRING_H\n\n#include <string>\n\nclass QByteArray;\nclass QString;\n\nnamespace Utils\n{\n    namespace String\n    {\n        QString fromStdString(const std::string &str);\n        std::string toStdString(const QString &str);\n        QString fromDouble(double n, int precision);\n\n        // Implements constant-time comparison to protect against timing attacks\n        // Taken from https://crackstation.net/hashing-security.htm\n        bool slowEquals(const QByteArray &a, const QByteArray &b);\n\n        QString toHtmlEscaped(const QString &str);\n\n        bool naturalCompareCaseSensitive(const QString &left, const QString &right);\n        bool naturalCompareCaseInsensitive(const QString &left, const QString &right);\n    }\n}\n\n#endif // UTILS_STRING_H\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#ifndef DELETIONCONFIRMATIONDLG_H\n#define DELETIONCONFIRMATIONDLG_H\n\n#include <QDialog>\n#include <QPushButton>\n#include \"ui_confirmdeletiondlg.h\"\n#include \"base/preferences.h\"\n#include \"base/utils/misc.h\"\n#include \"base/utils/string.h\"\n#include \"guiiconprovider.h\"\n\nclass DeletionConfirmationDlg : public QDialog, private Ui::confirmDeletionDlg {\n  Q_OBJECT\n\n  public:\n  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(Utils::String::toHtmlEscaped(name)));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    // Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }\n\n  bool shouldDeleteLocalFiles() const {\n    return checkPermDelete->isChecked();\n  }\n\n  static bool askForDeletionConfirmation(bool& deleteLocalFiles, const int& size, const QString& name) {\n    DeletionConfirmationDlg dlg(NULL, size, name, deleteLocalFiles);\n    if (dlg.exec() == QDialog::Accepted) {\n      deleteLocalFiles = dlg.shouldDeleteLocalFiles();\n      return true;\n    }\n    return false;\n  }\n\nprivate slots:\n  void updateRememberButtonState() {\n    rememberBtn->setEnabled(checkPermDelete->isChecked() != Preferences::instance()->deleteTorrentFilesAsDefault());\n  }\n\n  void on_rememberBtn_clicked() {\n    Preferences::instance()->setDeleteTorrentFilesAsDefault(checkPermDelete->isChecked());\n    rememberBtn->setEnabled(false);\n  }\n};\n\n#endif // DELETIONCONFIRMATIONDLG_H\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#include <QStandardItemModel>\n#include <QSortFilterProxyModel>\n#include <QSet>\n#include <QHeaderView>\n#include <QMenu>\n#include <QClipboard>\n#include <QMessageBox>\n#include <QWheelEvent>\n#ifdef QBT_USES_QT5\n#include <QTableView>\n#endif\n\n#include \"base/net/reverseresolution.h\"\n#include \"base/bittorrent/torrenthandle.h\"\n#include \"base/bittorrent/peerinfo.h\"\n#include \"base/preferences.h\"\n#include \"base/logger.h\"\n#include \"base/unicodestrings.h\"\n#include \"propertieswidget.h\"\n#include \"base/net/geoipmanager.h\"\n#include \"peersadditiondlg.h\"\n#include \"speedlimitdlg.h\"\n#include \"guiiconprovider.h\"\n#include \"peerlistdelegate.h\"\n#include \"peerlistsortmodel.h\"\n#include \"peerlistwidget.h\"\n\nPeerListWidget::PeerListWidget(PropertiesWidget *parent)\n    : QTreeView(parent)\n    , m_properties(parent)\n{\n    // Load settings\n    loadSettings();\n    // Visual settings\n    setUniformRowHeights(true);\n    setRootIsDecorated(false);\n    setItemsExpandable(false);\n    setAllColumnsShowFocus(true);\n    setSelectionMode(QAbstractItemView::ExtendedSelection);\n    header()->setStretchLastSection(false);\n    // List Model\n    m_listModel = new QStandardItemModel(0, PeerListDelegate::COL_COUNT);\n    m_listModel->setHeaderData(PeerListDelegate::COUNTRY, Qt::Horizontal, tr(\"Country\")); // Country flag column\n    m_listModel->setHeaderData(PeerListDelegate::IP, Qt::Horizontal, tr(\"IP\"));\n    m_listModel->setHeaderData(PeerListDelegate::PORT, Qt::Horizontal, tr(\"Port\"));\n    m_listModel->setHeaderData(PeerListDelegate::FLAGS, Qt::Horizontal, tr(\"Flags\"));\n    m_listModel->setHeaderData(PeerListDelegate::CONNECTION, Qt::Horizontal, tr(\"Connection\"));\n    m_listModel->setHeaderData(PeerListDelegate::CLIENT, Qt::Horizontal, tr(\"Client\", \"i.e.: Client application\"));\n    m_listModel->setHeaderData(PeerListDelegate::PROGRESS, Qt::Horizontal, tr(\"Progress\", \"i.e: % downloaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::DOWN_SPEED, Qt::Horizontal, tr(\"Down Speed\", \"i.e: Download speed\"));\n    m_listModel->setHeaderData(PeerListDelegate::UP_SPEED, Qt::Horizontal, tr(\"Up Speed\", \"i.e: Upload speed\"));\n    m_listModel->setHeaderData(PeerListDelegate::TOT_DOWN, Qt::Horizontal, tr(\"Downloaded\", \"i.e: total data downloaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::TOT_UP, Qt::Horizontal, tr(\"Uploaded\", \"i.e: total data uploaded\"));\n    m_listModel->setHeaderData(PeerListDelegate::RELEVANCE, Qt::Horizontal, tr(\"Relevance\", \"i.e: How relevant this peer is to us. How many pieces it has that we don't.\"));\n    m_listModel->setHeaderData(PeerListDelegate::DOWNLOADING_PIECE, Qt::Horizontal, tr(\"Files\", \"i.e. files that are being downloaded right now\"));\n    // Set header text alignment\n    m_listModel->setHeaderData(PeerListDelegate::PORT, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::PROGRESS, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::DOWN_SPEED, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::UP_SPEED, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::TOT_DOWN, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::TOT_UP, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    m_listModel->setHeaderData(PeerListDelegate::RELEVANCE, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);\n    // Proxy model to support sorting without actually altering the underlying model\n    m_proxyModel = new PeerListSortModel();\n    m_proxyModel->setDynamicSortFilter(true);\n    m_proxyModel->setSourceModel(m_listModel);\n    m_proxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);\n    setModel(m_proxyModel);\n    hideColumn(PeerListDelegate::IP_HIDDEN);\n    hideColumn(PeerListDelegate::COL_COUNT);\n    m_resolveCountries = Preferences::instance()->resolvePeerCountries();\n    if (!m_resolveCountries)\n        hideColumn(PeerListDelegate::COUNTRY);\n    //Ensure that at least one column is visible at all times\n    bool atLeastOne = false;\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++) {\n        if (!isColumnHidden(i)) {\n            atLeastOne = true;\n            break;\n        }\n    }\n    if (!atLeastOne)\n        setColumnHidden(PeerListDelegate::IP, false);\n    //To also mitigate the above issue, we have to resize each column when\n    //its size is 0, because explicitly 'showing' the column isn't enough\n    //in the above scenario.\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++)\n        if ((columnWidth(i) <= 0) && !isColumnHidden(i))\n            resizeColumnToContents(i);\n    // Context menu\n    setContextMenuPolicy(Qt::CustomContextMenu);\n    connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(showPeerListMenu(QPoint)));\n    // List delegate\n    m_listDelegate = new PeerListDelegate(this);\n    setItemDelegate(m_listDelegate);\n    // Enable sorting\n    setSortingEnabled(true);\n    // IP to Hostname resolver\n    updatePeerHostNameResolutionState();\n    // SIGNAL/SLOT\n    header()->setContextMenuPolicy(Qt::CustomContextMenu);\n    connect(header(), SIGNAL(customContextMenuRequested(const QPoint &)), this, SLOT(displayToggleColumnsMenu(const QPoint &)));\n    connect(header(), SIGNAL(sectionClicked(int)), SLOT(handleSortColumnChanged(int)));\n    handleSortColumnChanged(header()->sortIndicatorSection());\n    m_copyHotkey = new QShortcut(QKeySequence::Copy, this, SLOT(copySelectedPeers()), 0, Qt::WidgetShortcut);\n\n#ifdef QBT_USES_QT5\n    // This hack fixes reordering of first column with Qt5.\n    // https://github.com/qtproject/qtbase/commit/e0fc088c0c8bc61dbcaf5928b24986cd61a22777\n    QTableView unused;\n    unused.setVerticalHeader(this->header());\n    this->header()->setParent(this);\n    unused.setVerticalHeader(new QHeaderView(Qt::Horizontal));\n#endif\n}\n\nPeerListWidget::~PeerListWidget()\n{\n    saveSettings();\n    delete m_proxyModel;\n    delete m_listModel;\n    delete m_listDelegate;\n    if (m_resolver)\n        delete m_resolver;\n    delete m_copyHotkey;\n}\n\nvoid PeerListWidget::displayToggleColumnsMenu(const QPoint&)\n{\n    QMenu hideshowColumn(this);\n    hideshowColumn.setTitle(tr(\"Column visibility\"));\n    QList<QAction*> actions;\n    for (int i = 0; i < PeerListDelegate::IP_HIDDEN; ++i) {\n        if ((i == PeerListDelegate::COUNTRY) && !Preferences::instance()->resolvePeerCountries()) {\n            actions.append(nullptr); // keep the index in sync\n            continue;\n        }\n        QAction *myAct = hideshowColumn.addAction(m_listModel->headerData(i, Qt::Horizontal, Qt::DisplayRole).toString());\n        myAct->setCheckable(true);\n        myAct->setChecked(!isColumnHidden(i));\n        actions.append(myAct);\n    }\n    int visibleCols = 0;\n    for (unsigned int i = 0; i < PeerListDelegate::IP_HIDDEN; i++) {\n        if (!isColumnHidden(i))\n            visibleCols++;\n\n        if (visibleCols > 1)\n            break;\n    }\n\n    // Call menu\n    QAction *act = hideshowColumn.exec(QCursor::pos());\n    if (act) {\n        int col = actions.indexOf(act);\n        Q_ASSERT(col >= 0);\n        Q_ASSERT(visibleCols > 0);\n        if (!isColumnHidden(col) && (visibleCols == 1))\n            return;\n        qDebug(\"Toggling column %d visibility\", col);\n        setColumnHidden(col, !isColumnHidden(col));\n        if (!isColumnHidden(col) && (columnWidth(col) <= 5))\n            setColumnWidth(col, 100);\n        saveSettings();\n    }\n}\n\nvoid PeerListWidget::updatePeerHostNameResolutionState()\n{\n    if (Preferences::instance()->resolvePeerHostNames()) {\n        if (!m_resolver) {\n            m_resolver = new Net::ReverseResolution(this);\n            connect(m_resolver, SIGNAL(ipResolved(QString, QString)), SLOT(handleResolved(QString, QString)));\n            loadPeers(m_properties->getCurrentTorrent(), true);\n        }\n    }\n    else if (m_resolver) {\n        delete m_resolver;\n    }\n}\n\nvoid PeerListWidget::updatePeerCountryResolutionState()\n{\n    if (Preferences::instance()->resolvePeerCountries() != m_resolveCountries) {\n        m_resolveCountries = !m_resolveCountries;\n        if (m_resolveCountries) {\n            loadPeers(m_properties->getCurrentTorrent());\n            showColumn(PeerListDelegate::COUNTRY);\n            if (columnWidth(PeerListDelegate::COUNTRY) <= 0)\n                resizeColumnToContents(PeerListDelegate::COUNTRY);\n        }\n        else {\n            hideColumn(PeerListDelegate::COUNTRY);\n        }\n    }\n}\n\nvoid PeerListWidget::showPeerListMenu(const QPoint&)\n{\n    QMenu menu;\n    bool emptyMenu = true;\n    BitTorrent::TorrentHandle *const torrent = m_properties->getCurrentTorrent();\n    if (!torrent) return;\n\n    // Add Peer Action\n    QAction *addPeerAct = 0;\n    if (!torrent->isQueued() && !torrent->isChecking()) {\n        addPeerAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"user-group-new\"), tr(\"Add a new peer...\"));\n        emptyMenu = false;\n    }\n    QAction *banAct = 0;\n    QAction *copyPeerAct = 0;\n    if (!selectionModel()->selectedRows().isEmpty()) {\n        copyPeerAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"edit-copy\"), tr(\"Copy IP:port\"));\n        menu.addSeparator();\n        banAct = menu.addAction(GuiIconProvider::instance()->getIcon(\"user-group-delete\"), tr(\"Ban peer permanently\"));\n        emptyMenu = false;\n    }\n    if (emptyMenu) return;\n    QAction *act = menu.exec(QCursor::pos());\n    if (act == 0) return;\n    if (act == addPeerAct) {\n        QList<BitTorrent::PeerAddress> peersList = PeersAdditionDlg::askForPeers();\n        int peerCount = 0;\n        foreach (const BitTorrent::PeerAddress &addr, peersList) {\n            if (torrent->connectPeer(addr)) {\n                qDebug(\"Adding peer %s...\", qPrintable(addr.ip.toString()));\n                Logger::instance()->addMessage(tr(\"Manually adding peer '%1'...\").arg(addr.ip.toString()));\n                peerCount++;\n            }\n            else {\n                Logger::instance()->addMessage(tr(\"The peer '%1' could not be added to this torrent.\").arg(addr.ip.toString()), Log::WARNING);\n            }\n        }\n        if (peerCount < peersList.length())\n            QMessageBox::information(0, tr(\"Peer addition\"), tr(\"Some peers could not be added. Check the Log for details.\"));\n        else if (peerCount > 0)\n            QMessageBox::information(0, tr(\"Peer addition\"), tr(\"The peers were added to this torrent.\"));\n        return;\n    }\n    if (act == banAct) {\n        banSelectedPeers();\n        return;\n    }\n    if (act == copyPeerAct) {\n        copySelectedPeers();\n        return;\n    }\n}\n\nvoid PeerListWidget::banSelectedPeers()\n{\n    // Confirm first\n    int ret = QMessageBox::question(this, tr(\"Ban peer permanently\"), tr(\"Are you sure you want to ban permanently the selected peers?\"),\n                                    tr(\"&Yes\"), tr(\"&No\"),\n                                    QString(), 0, 1);\n    if (ret)\n        return;\n\n    QModelIndexList selectedIndexes = selectionModel()->selectedRows();\n    foreach (const QModelIndex &index, selectedIndexes) {\n        int row = m_proxyModel->mapToSource(index).row();\n        QString ip = m_listModel->data(m_listModel->index(row, PeerListDelegate::IP_HIDDEN)).toString();\n        qDebug(\"Banning peer %s...\", ip.toLocal8Bit().data());\n        Logger::instance()->addMessage(tr(\"Manually banning peer '%1'...\").arg(ip));\n        BitTorrent::Session::instance()->banIP(ip);\n    }\n    // Refresh list\n    loadPeers(m_properties->getCurrentTorrent());\n}\n\nvoid PeerListWidget::copySelectedPeers()\n{\n    QModelIndexList selectedIndexes = selectionModel()->selectedRows();\n    QStringList selectedPeers;\n    foreach (const QModelIndex &index, selectedIndexes) {\n        int row = m_proxyModel->mapToSource(index).row();\n        QString ip = m_listModel->data(m_listModel->index(row, PeerListDelegate::IP_HIDDEN)).toString();\n        QString myport = m_listModel->data(m_listModel->index(row, PeerListDelegate::PORT)).toString();\n        if (ip.indexOf(\".\") == -1) // IPv6\n            selectedPeers << \"[\" + ip + \"]:\" + myport;\n        else // IPv4\n            selectedPeers << ip + \":\" + myport;\n    }\n    QApplication::clipboard()->setText(selectedPeers.join(\"\\n\"));\n}\n\nvoid PeerListWidget::clear()\n{\n    qDebug(\"clearing peer list\");\n    m_peerItems.clear();\n    m_peerAddresses.clear();\n    m_missingFlags.clear();\n    int nbrows = m_listModel->rowCount();\n    if (nbrows > 0) {\n        qDebug(\"Cleared %d peers\", nbrows);\n        m_listModel->removeRows(0,  nbrows);\n    }\n}\n\nvoid PeerListWidget::loadSettings()\n{\n    header()->restoreState(Preferences::instance()->getPeerListState());\n}\n\nvoid PeerListWidget::saveSettings() const\n{\n    Preferences::instance()->setPeerListState(header()->saveState());\n}\n\nvoid PeerListWidget::loadPeers(BitTorrent::TorrentHandle *const torrent, bool forceHostnameResolution)\n{\n    if (!torrent) return;\n\n    QList<BitTorrent::PeerInfo> peers = torrent->peers();\n    QSet<QString> oldeersSet = m_peerItems.keys().toSet();\n\n    foreach (const BitTorrent::PeerInfo &peer, peers) {\n        BitTorrent::PeerAddress addr = peer.address();\n        if (addr.ip.isNull()) continue;\n\n        QString peerIp = addr.ip.toString();\n        if (m_peerItems.contains(peerIp)) {\n            // Update existing peer\n            updatePeer(peerIp, torrent, peer);\n            oldeersSet.remove(peerIp);\n            if (forceHostnameResolution && m_resolver)\n                m_resolver->resolve(peerIp);\n        }\n        else {\n            // Add new peer\n            m_peerItems[peerIp] = addPeer(peerIp, torrent, peer);\n            m_peerAddresses[peerIp] = addr;\n            // Resolve peer host name is asked\n            if (m_resolver)\n                m_resolver->resolve(peerIp);\n        }\n    }\n    // Delete peers that are gone\n    QSetIterator<QString> it(oldeersSet);\n    while (it.hasNext()) {\n        const QString& ip = it.next();\n        m_missingFlags.remove(ip);\n        m_peerAddresses.remove(ip);\n        QStandardItem *item = m_peerItems.take(ip);\n        m_listModel->removeRow(item->row());\n    }\n}\n\nQStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}\n\nvoid PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}\n\nvoid PeerListWidget::handleResolved(const QString &ip, const QString &hostname)\n{\n    QStandardItem *item = m_peerItems.value(ip, 0);\n    if (item) {\n        qDebug(\"Resolved %s -> %s\", qPrintable(ip), qPrintable(hostname));\n        item->setData(hostname, Qt::DisplayRole);\n    }\n}\n\nvoid PeerListWidget::handleSortColumnChanged(int col)\n{\n    if (col == PeerListDelegate::COUNTRY) {\n        qDebug(\"Sorting by decoration\");\n        m_proxyModel->setSortRole(Qt::ToolTipRole);\n    }\n    else {\n        m_proxyModel->setSortRole(Qt::DisplayRole);\n    }\n}\n\nvoid PeerListWidget::wheelEvent(QWheelEvent *event)\n{\n    event->accept();\n\n    if(event->modifiers() & Qt::ShiftModifier) {\n        // Shift + scroll = horizontal scroll\n        QWheelEvent scrollHEvent(event->pos(), event->globalPos(), event->delta(), event->buttons(), event->modifiers(), Qt::Horizontal);\n        QTreeView::wheelEvent(&scrollHEvent);\n        return;\n    }\n\n    QTreeView::wheelEvent(event);  // event delegated to base class\n}\n", "/*\n * Bittorrent Client using Qt4 and libtorrent.\n * Copyright (C) 2006  Christophe Dumez\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * In addition, as a special exception, the copyright holders give permission to\n * link this program with the OpenSSL project's \"OpenSSL\" library (or with\n * modified versions of it that use the same license as the \"OpenSSL\" library),\n * and distribute the linked executables. You must obey the GNU General Public\n * License in all respects for all of the code used other than \"OpenSSL\".  If you\n * modify file(s), you may extend this exception to your version of the file(s),\n * but you are not obligated to do so. If you do not wish to do so, delete this\n * exception statement from your version.\n *\n * Contact : chris@qbittorrent.org\n */\n\n#include \"propertieswidget.h\"\n\n#include <QDebug>\n#include <QTimer>\n#include <QListWidgetItem>\n#include <QVBoxLayout>\n#include <QStackedWidget>\n#include <QSplitter>\n#include <QHeaderView>\n#include <QAction>\n#include <QMenu>\n#include <QFileDialog>\n#include <QBitArray>\n\n#include \"base/bittorrent/session.h\"\n#include \"base/preferences.h\"\n#include \"base/utils/fs.h\"\n#include \"base/utils/misc.h\"\n#include \"base/utils/string.h\"\n#include \"base/unicodestrings.h\"\n#include \"proplistdelegate.h\"\n#include \"torrentcontentfiltermodel.h\"\n#include \"torrentcontentmodel.h\"\n#include \"peerlistwidget.h\"\n#include \"speedwidget.h\"\n#include \"trackerlist.h\"\n#include \"mainwindow.h\"\n#include \"messageboxraised.h\"\n#include \"downloadedpiecesbar.h\"\n#include \"pieceavailabilitybar.h\"\n#include \"proptabbar.h\"\n#include \"guiiconprovider.h\"\n#include \"lineedit.h\"\n#include \"transferlistwidget.h\"\n#include \"autoexpandabledialog.h\"\n\nPropertiesWidget::PropertiesWidget(QWidget *parent, MainWindow *main_window, TransferListWidget *transferList)\n    : QWidget(parent), transferList(transferList), main_window(main_window), m_torrent(0)\n{\n    setupUi(this);\n    setAutoFillBackground(true);\n\n    state = VISIBLE;\n\n    // Set Properties list model\n    PropListModel = new TorrentContentFilterModel();\n    filesList->setModel(PropListModel);\n    PropDelegate = new PropListDelegate(this);\n    filesList->setItemDelegate(PropDelegate);\n    filesList->setSortingEnabled(true);\n    // Torrent content filtering\n    m_contentFilterLine = new LineEdit(this);\n    m_contentFilterLine->setPlaceholderText(tr(\"Filter files...\"));\n    m_contentFilterLine->setMaximumSize(300, m_contentFilterLine->size().height());\n    connect(m_contentFilterLine, SIGNAL(textChanged(QString)), this, SLOT(filterText(QString)));\n    contentFilterLayout->insertWidget(3, m_contentFilterLine);\n\n    // SIGNAL/SLOTS\n    connect(filesList, SIGNAL(clicked(const QModelIndex&)), filesList, SLOT(edit(const QModelIndex&)));\n    connect(selectAllButton, SIGNAL(clicked()), PropListModel, SLOT(selectAll()));\n    connect(selectNoneButton, SIGNAL(clicked()), PropListModel, SLOT(selectNone()));\n    connect(filesList, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(displayFilesListMenu(const QPoint&)));\n    connect(filesList, SIGNAL(doubleClicked(const QModelIndex&)), this, SLOT(openDoubleClickedFile(const QModelIndex&)));\n    connect(PropListModel, SIGNAL(filteredFilesChanged()), this, SLOT(filteredFilesChanged()));\n    connect(listWebSeeds, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(displayWebSeedListMenu(const QPoint&)));\n    connect(transferList, SIGNAL(currentTorrentChanged(BitTorrent::TorrentHandle * const)), this, SLOT(loadTorrentInfos(BitTorrent::TorrentHandle * const)));\n    connect(PropDelegate, SIGNAL(filteredFilesChanged()), this, SLOT(filteredFilesChanged()));\n    connect(stackedProperties, SIGNAL(currentChanged(int)), this, SLOT(loadDynamicData()));\n    connect(BitTorrent::Session::instance(), SIGNAL(torrentSavePathChanged(BitTorrent::TorrentHandle * const)), this, SLOT(updateSavePath(BitTorrent::TorrentHandle * const)));\n    connect(BitTorrent::Session::instance(), SIGNAL(torrentMetadataLoaded(BitTorrent::TorrentHandle * const)), this, SLOT(updateTorrentInfos(BitTorrent::TorrentHandle * const)));\n    connect(filesList->header(), SIGNAL(sectionMoved(int,int,int)), this, SLOT(saveSettings()));\n    connect(filesList->header(), SIGNAL(sectionResized(int,int,int)), this, SLOT(saveSettings()));\n    connect(filesList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), this, SLOT(saveSettings()));\n\n#ifdef QBT_USES_QT5\n    // set bar height relative to screen dpi\n    int barHeight = devicePixelRatio() * 18;\n#else\n    // set bar height relative to font height\n    QFont defFont;\n    QFontMetrics fMetrics(defFont, 0); // need to be device-dependent\n    int barHeight = fMetrics.height() * 5 / 4;\n#endif\n\n    // Downloaded pieces progress bar\n    tempProgressBarArea->setVisible(false);\n    downloaded_pieces = new DownloadedPiecesBar(this);\n    groupBarLayout->addWidget(downloaded_pieces, 0, 1);\n    downloaded_pieces->setFixedHeight(barHeight);\n    downloaded_pieces->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);\n\n    // Pieces availability bar\n    tempAvailabilityBarArea->setVisible(false);\n    pieces_availability = new PieceAvailabilityBar(this);\n    groupBarLayout->addWidget(pieces_availability, 1, 1);\n    pieces_availability->setFixedHeight(barHeight);\n    pieces_availability->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);\n\n    // Tracker list\n    trackerList = new TrackerList(this);\n    trackerUpButton->setIcon(GuiIconProvider::instance()->getIcon(\"go-up\"));\n    trackerUpButton->setIconSize(Utils::Misc::smallIconSize());\n    trackerDownButton->setIcon(GuiIconProvider::instance()->getIcon(\"go-down\"));\n    trackerDownButton->setIconSize(Utils::Misc::smallIconSize());\n    connect(trackerUpButton, SIGNAL(clicked()), trackerList, SLOT(moveSelectionUp()));\n    connect(trackerDownButton, SIGNAL(clicked()), trackerList, SLOT(moveSelectionDown()));\n    horizontalLayout_trackers->insertWidget(0, trackerList);\n    connect(trackerList->header(), SIGNAL(sectionMoved(int,int,int)), trackerList, SLOT(saveSettings()));\n    connect(trackerList->header(), SIGNAL(sectionResized(int,int,int)), trackerList, SLOT(saveSettings()));\n    connect(trackerList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), trackerList, SLOT(saveSettings()));\n    // Peers list\n    peersList = new PeerListWidget(this);\n    peerpage_layout->addWidget(peersList);\n    connect(peersList->header(), SIGNAL(sectionMoved(int,int,int)), peersList, SLOT(saveSettings()));\n    connect(peersList->header(), SIGNAL(sectionResized(int,int,int)), peersList, SLOT(saveSettings()));\n    connect(peersList->header(), SIGNAL(sortIndicatorChanged(int,Qt::SortOrder)), peersList, SLOT(saveSettings()));\n    // Speed widget\n    speedWidget = new SpeedWidget(this);\n    speed_layout->addWidget(speedWidget);\n    // Tab bar\n    m_tabBar = new PropTabBar();\n    m_tabBar->setContentsMargins(0, 5, 0, 0);\n    verticalLayout->addLayout(m_tabBar);\n    connect(m_tabBar, SIGNAL(tabChanged(int)), stackedProperties, SLOT(setCurrentIndex(int)));\n    connect(m_tabBar, SIGNAL(tabChanged(int)), this, SLOT(saveSettings()));\n    connect(m_tabBar, SIGNAL(visibilityToggled(bool)), SLOT(setVisibility(bool)));\n    connect(m_tabBar, SIGNAL(visibilityToggled(bool)), this, SLOT(saveSettings()));\n    // Dynamic data refresher\n    refreshTimer = new QTimer(this);\n    connect(refreshTimer, SIGNAL(timeout()), this, SLOT(loadDynamicData()));\n    refreshTimer->start(3000); // 3sec\n    editHotkeyFile = new QShortcut(Qt::Key_F2, filesList, 0, 0, Qt::WidgetShortcut);\n    connect(editHotkeyFile, SIGNAL(activated()), SLOT(renameSelectedFile()));\n    editHotkeyWeb = new QShortcut(Qt::Key_F2, listWebSeeds, 0, 0, Qt::WidgetShortcut);\n    connect(editHotkeyWeb, SIGNAL(activated()), SLOT(editWebSeed()));\n    connect(listWebSeeds, SIGNAL(doubleClicked(QModelIndex)), SLOT(editWebSeed()));\n    deleteHotkeyWeb = new QShortcut(QKeySequence::Delete, listWebSeeds, 0, 0, Qt::WidgetShortcut);\n    connect(deleteHotkeyWeb, SIGNAL(activated()), SLOT(deleteSelectedUrlSeeds()));\n    openHotkeyFile = new QShortcut(Qt::Key_Return, filesList, 0, 0, Qt::WidgetShortcut);\n    connect(openHotkeyFile, SIGNAL(activated()), SLOT(openSelectedFile()));\n}\n\nPropertiesWidget::~PropertiesWidget()\n{\n    qDebug() << Q_FUNC_INFO << \"ENTER\";\n    delete refreshTimer;\n    delete trackerList;\n    delete peersList;\n    delete speedWidget;\n    delete downloaded_pieces;\n    delete pieces_availability;\n    delete PropListModel;\n    delete PropDelegate;\n    delete m_tabBar;\n    delete editHotkeyFile;\n    delete editHotkeyWeb;\n    delete deleteHotkeyWeb;\n    delete openHotkeyFile;\n    qDebug() << Q_FUNC_INFO << \"EXIT\";\n}\n\nvoid PropertiesWidget::showPiecesAvailability(bool show)\n{\n    avail_pieces_lbl->setVisible(show);\n    pieces_availability->setVisible(show);\n    avail_average_lbl->setVisible(show);\n    if (show || !downloaded_pieces->isVisible())\n        line_2->setVisible(show);\n}\n\nvoid PropertiesWidget::showPiecesDownloaded(bool show)\n{\n    downloaded_pieces_lbl->setVisible(show);\n    downloaded_pieces->setVisible(show);\n    progress_lbl->setVisible(show);\n    if (show || !pieces_availability->isVisible())\n        line_2->setVisible(show);\n}\n\nvoid PropertiesWidget::setVisibility(bool visible)\n{\n    if (!visible && ( state == VISIBLE) ) {\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        stackedProperties->setVisible(false);\n        slideSizes = hSplitter->sizes();\n        hSplitter->handle(1)->setVisible(false);\n        hSplitter->handle(1)->setDisabled(true);\n        QList<int> sizes = QList<int>() << hSplitter->geometry().height() - 30 << 30;\n        hSplitter->setSizes(sizes);\n        state = REDUCED;\n        return;\n    }\n\n    if (visible && ( state == REDUCED) ) {\n        stackedProperties->setVisible(true);\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        hSplitter->handle(1)->setDisabled(false);\n        hSplitter->handle(1)->setVisible(true);\n        hSplitter->setSizes(slideSizes);\n        state = VISIBLE;\n        // Force refresh\n        loadDynamicData();\n    }\n}\n\nvoid PropertiesWidget::clear()\n{\n    qDebug(\"Clearing torrent properties\");\n    save_path->clear();\n    lbl_creationDate->clear();\n    label_total_pieces_val->clear();\n    hash_lbl->clear();\n    comment_text->clear();\n    progress_lbl->clear();\n    trackerList->clear();\n    downloaded_pieces->clear();\n    pieces_availability->clear();\n    avail_average_lbl->clear();\n    wasted->clear();\n    upTotal->clear();\n    dlTotal->clear();\n    peersList->clear();\n    lbl_uplimit->clear();\n    lbl_dllimit->clear();\n    lbl_elapsed->clear();\n    lbl_connections->clear();\n    reannounce_lbl->clear();\n    shareRatio->clear();\n    listWebSeeds->clear();\n    m_contentFilterLine->clear();\n    PropListModel->model()->clear();\n    label_eta_val->clear();\n    label_seeds_val->clear();\n    label_peers_val->clear();\n    label_dl_speed_val->clear();\n    label_upload_speed_val->clear();\n    label_total_size_val->clear();\n    label_completed_on_val->clear();\n    label_last_complete_val->clear();\n    label_created_by_val->clear();\n    label_added_on_val->clear();\n}\n\nBitTorrent::TorrentHandle *PropertiesWidget::getCurrentTorrent() const\n{\n    return m_torrent;\n}\n\nvoid PropertiesWidget::updateSavePath(BitTorrent::TorrentHandle *const torrent)\n{\n    if (m_torrent == torrent)\n        save_path->setText(Utils::Fs::toNativePath(m_torrent->savePath()));\n}\n\nvoid PropertiesWidget::loadTrackers(BitTorrent::TorrentHandle *const torrent)\n{\n    if (torrent == m_torrent)\n        trackerList->loadTrackers();\n}\n\nvoid PropertiesWidget::updateTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    if (m_torrent == torrent)\n        loadTorrentInfos(m_torrent);\n}\n\nvoid PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}\n\nvoid PropertiesWidget::readSettings()\n{\n    const Preferences *const pref = Preferences::instance();\n    // Restore splitter sizes\n    QStringList sizes_str = pref->getPropSplitterSizes().split(\",\");\n    if (sizes_str.size() == 2) {\n        slideSizes << sizes_str.first().toInt();\n        slideSizes << sizes_str.last().toInt();\n        QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n        hSplitter->setSizes(slideSizes);\n    }\n    const int current_tab = pref->getPropCurTab();\n    const bool visible = pref->getPropVisible();\n    // the following will call saveSettings but shouldn't change any state\n    if (!filesList->header()->restoreState(pref->getPropFileListState()))\n        filesList->header()->resizeSection(0, 400); // Default\n    m_tabBar->setCurrentIndex(current_tab);\n    if (!visible)\n        setVisibility(false);\n}\n\nvoid PropertiesWidget::saveSettings()\n{\n    Preferences *const pref = Preferences::instance();\n    pref->setPropVisible(state==VISIBLE);\n    // Splitter sizes\n    QSplitter *hSplitter = static_cast<QSplitter *>(parentWidget());\n    QList<int> sizes;\n    if (state == VISIBLE)\n        sizes = hSplitter->sizes();\n    else\n        sizes = slideSizes;\n    qDebug(\"Sizes: %d\", sizes.size());\n    if (sizes.size() == 2)\n        pref->setPropSplitterSizes(QString::number(sizes.first()) + ',' + QString::number(sizes.last()));\n    pref->setPropFileListState(filesList->header()->saveState());\n    // Remember current tab\n    pref->setPropCurTab(m_tabBar->currentIndex());\n}\n\nvoid PropertiesWidget::reloadPreferences()\n{\n    // Take program preferences into consideration\n    peersList->updatePeerHostNameResolutionState();\n    peersList->updatePeerCountryResolutionState();\n}\n\nvoid PropertiesWidget::loadDynamicData()\n{\n    // Refresh only if the torrent handle is valid and if visible\n    if (!m_torrent || (main_window->currentTabWidget() != transferList) || (state != VISIBLE)) return;\n\n    // Transfer infos\n    switch (stackedProperties->currentIndex()) {\n    case PropTabBar::MAIN_TAB: {\n        wasted->setText(Utils::Misc::friendlyUnit(m_torrent->wastedSize()));\n\n        upTotal->setText(tr(\"%1 (%2 this session)\").arg(Utils::Misc::friendlyUnit(m_torrent->totalUpload()))\n                         .arg(Utils::Misc::friendlyUnit(m_torrent->totalPayloadUpload())));\n\n        dlTotal->setText(tr(\"%1 (%2 this session)\").arg(Utils::Misc::friendlyUnit(m_torrent->totalDownload()))\n                         .arg(Utils::Misc::friendlyUnit(m_torrent->totalPayloadDownload())));\n\n        lbl_uplimit->setText(m_torrent->uploadLimit() <= 0 ? QString::fromUtf8(C_INFINITY) : Utils::Misc::friendlyUnit(m_torrent->uploadLimit(), true));\n\n        lbl_dllimit->setText(m_torrent->downloadLimit() <= 0 ? QString::fromUtf8(C_INFINITY) : Utils::Misc::friendlyUnit(m_torrent->downloadLimit(), true));\n\n        QString elapsed_txt;\n        if (m_torrent->isSeed())\n            elapsed_txt = tr(\"%1 (seeded for %2)\", \"e.g. 4m39s (seeded for 3m10s)\")\n                          .arg(Utils::Misc::userFriendlyDuration(m_torrent->activeTime()))\n                          .arg(Utils::Misc::userFriendlyDuration(m_torrent->seedingTime()));\n        else\n            elapsed_txt = Utils::Misc::userFriendlyDuration(m_torrent->activeTime());\n        lbl_elapsed->setText(elapsed_txt);\n\n        lbl_connections->setText(tr(\"%1 (%2 max)\", \"%1 and %2 are numbers, e.g. 3 (10 max)\")\n                                 .arg(m_torrent->connectionsCount())\n                                 .arg(m_torrent->connectionsLimit() < 0 ? QString::fromUtf8(C_INFINITY) : QString::number(m_torrent->connectionsLimit())));\n\n        label_eta_val->setText(Utils::Misc::userFriendlyDuration(m_torrent->eta()));\n\n        // Update next announce time\n        reannounce_lbl->setText(Utils::Misc::userFriendlyDuration(m_torrent->nextAnnounce()));\n\n        // Update ratio info\n        const qreal ratio = m_torrent->realRatio();\n        shareRatio->setText(ratio > BitTorrent::TorrentHandle::MAX_RATIO ? QString::fromUtf8(C_INFINITY) : Utils::String::fromDouble(ratio, 2));\n\n        label_seeds_val->setText(tr(\"%1 (%2 total)\", \"%1 and %2 are numbers, e.g. 3 (10 total)\")\n                                 .arg(QString::number(m_torrent->seedsCount()))\n                                 .arg(QString::number(m_torrent->totalSeedsCount())));\n\n        label_peers_val->setText(tr(\"%1 (%2 total)\", \"%1 and %2 are numbers, e.g. 3 (10 total)\")\n                                 .arg(QString::number(m_torrent->leechsCount()))\n                                 .arg(QString::number(m_torrent->totalLeechersCount())));\n\n        label_dl_speed_val->setText(tr(\"%1 (%2 avg.)\", \"%1 and %2 are speed rates, e.g. 200KiB/s (100KiB/s avg.)\")\n                                    .arg(Utils::Misc::friendlyUnit(m_torrent->downloadPayloadRate(), true))\n                                    .arg(Utils::Misc::friendlyUnit(m_torrent->totalDownload() / (1 + m_torrent->activeTime() - m_torrent->finishedTime()), true)));\n\n        label_upload_speed_val->setText(tr(\"%1 (%2 avg.)\", \"%1 and %2 are speed rates, e.g. 200KiB/s (100KiB/s avg.)\")\n                                        .arg(Utils::Misc::friendlyUnit(m_torrent->uploadPayloadRate(), true))\n                                        .arg(Utils::Misc::friendlyUnit(m_torrent->totalUpload() / (1 + m_torrent->activeTime()), true)));\n\n        label_last_complete_val->setText(m_torrent->lastSeenComplete().isValid() ? m_torrent->lastSeenComplete().toString(Qt::DefaultLocaleShortDate) : tr(\"Never\"));\n\n        label_completed_on_val->setText(m_torrent->completedTime().isValid() ? m_torrent->completedTime().toString(Qt::DefaultLocaleShortDate) : \"\");\n\n        label_added_on_val->setText(m_torrent->addedTime().toString(Qt::DefaultLocaleShortDate));\n\n        if (m_torrent->hasMetadata()) {\n            label_total_pieces_val->setText(tr(\"%1 x %2 (have %3)\", \"(torrent pieces) eg 152 x 4MB (have 25)\").arg(m_torrent->piecesCount()).arg(Utils::Misc::friendlyUnit(m_torrent->pieceLength())).arg(m_torrent->piecesHave()));\n\n            if (!m_torrent->isSeed() && !m_torrent->isPaused() && !m_torrent->isQueued() && !m_torrent->isChecking()) {\n                // Pieces availability\n                showPiecesAvailability(true);\n                pieces_availability->setAvailability(m_torrent->pieceAvailability());\n                avail_average_lbl->setText(Utils::String::fromDouble(m_torrent->distributedCopies(), 3));\n            }\n            else {\n                showPiecesAvailability(false);\n            }\n\n            // Progress\n            qreal progress = m_torrent->progress() * 100.;\n            progress_lbl->setText(Utils::String::fromDouble(progress, 1) + \"%\");\n            downloaded_pieces->setProgress(m_torrent->pieces(), m_torrent->downloadingPieces());\n        }\n        else {\n            showPiecesAvailability(false);\n        }\n\n        break;\n    }\n\n    case PropTabBar::TRACKERS_TAB: {\n        // Trackers\n        trackerList->loadTrackers();\n        break;\n    }\n\n    case PropTabBar::PEERS_TAB: {\n        // Load peers\n        peersList->loadPeers(m_torrent);\n        break;\n    }\n\n    case PropTabBar::FILES_TAB: {\n        // Files progress\n        if (m_torrent->hasMetadata()) {\n            qDebug(\"Updating priorities in files tab\");\n            filesList->setUpdatesEnabled(false);\n            PropListModel->model()->updateFilesProgress(m_torrent->filesProgress());\n            // XXX: We don't update file priorities regularly for performance\n            // reasons. This means that priorities will not be updated if\n            // set from the Web UI.\n            // PropListModel->model()->updateFilesPriorities(h.file_priorities());\n            filesList->setUpdatesEnabled(true);\n        }\n        break;\n    }\n\n    default:;\n    }\n}\n\nvoid PropertiesWidget::loadUrlSeeds()\n{\n    listWebSeeds->clear();\n    qDebug(\"Loading URL seeds\");\n    const QList<QUrl> hc_seeds = m_torrent->urlSeeds();\n    // Add url seeds\n    foreach (const QUrl &hc_seed, hc_seeds) {\n        qDebug(\"Loading URL seed: %s\", qPrintable(hc_seed.toString()));\n        new QListWidgetItem(hc_seed.toString(), listWebSeeds);\n    }\n}\n\nvoid PropertiesWidget::openDoubleClickedFile(const QModelIndex &index)\n{\n    if (!index.isValid()) return;\n    if (!m_torrent || !m_torrent->hasMetadata()) return;\n    if (PropListModel->itemType(index) == TorrentContentModelItem::FileType)\n        openFile(index);\n    else\n        openFolder(index, false);\n}\n\nvoid PropertiesWidget::openFile(const QModelIndex &index)\n{\n    int i = PropListModel->getFileIndex(index);\n    const QDir saveDir(m_torrent->savePath(true));\n    const QString filename = m_torrent->filePath(i);\n    const QString file_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(filename));\n    qDebug(\"Trying to open file at %s\", qPrintable(file_path));\n    // Flush data\n    m_torrent->flushCache();\n    Utils::Misc::openPath(file_path);\n}\n\nvoid PropertiesWidget::openFolder(const QModelIndex &index, bool containing_folder)\n{\n    QString absolute_path;\n    // FOLDER\n    if (PropListModel->itemType(index) == TorrentContentModelItem::FolderType) {\n        // Generate relative path to selected folder\n        QStringList path_items;\n        path_items << index.data().toString();\n        QModelIndex parent = PropListModel->parent(index);\n        while (parent.isValid()) {\n            path_items.prepend(parent.data().toString());\n            parent = PropListModel->parent(parent);\n        }\n        if (path_items.isEmpty())\n            return;\n        const QDir saveDir(m_torrent->savePath(true));\n        const QString relative_path = path_items.join(\"/\");\n        absolute_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(relative_path));\n    }\n    else {\n        int i = PropListModel->getFileIndex(index);\n        const QDir saveDir(m_torrent->savePath(true));\n        const QString relative_path = m_torrent->filePath(i);\n        absolute_path = Utils::Fs::expandPath(saveDir.absoluteFilePath(relative_path));\n    }\n\n    // Flush data\n    m_torrent->flushCache();\n    if (containing_folder)\n        Utils::Misc::openFolderSelect(absolute_path);\n    else\n        Utils::Misc::openPath(absolute_path);\n}\n\nvoid PropertiesWidget::displayFilesListMenu(const QPoint &)\n{\n    if (!m_torrent) return;\n\n    QModelIndexList selectedRows = filesList->selectionModel()->selectedRows(0);\n    if (selectedRows.empty())\n        return;\n    QMenu myFilesLlistMenu;\n    QAction *actOpen = 0;\n    QAction *actOpenContainingFolder = 0;\n    QAction *actRename = 0;\n    if (selectedRows.size() == 1) {\n        actOpen = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"folder-documents\"), tr(\"Open\"));\n        actOpenContainingFolder = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"inode-directory\"), tr(\"Open Containing Folder\"));\n        actRename = myFilesLlistMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-rename\"), tr(\"Rename...\"));\n        myFilesLlistMenu.addSeparator();\n    }\n    QMenu subMenu;\n    if (!m_torrent->isSeed()) {\n        subMenu.setTitle(tr(\"Priority\"));\n        subMenu.addAction(actionNot_downloaded);\n        subMenu.addAction(actionNormal);\n        subMenu.addAction(actionHigh);\n        subMenu.addAction(actionMaximum);\n        myFilesLlistMenu.addMenu(&subMenu);\n    }\n    // Call menu\n    const QAction *act = myFilesLlistMenu.exec(QCursor::pos());\n    // The selected torrent might have disappeared during exec()\n    // from the current view thus leaving invalid indices.\n    const QModelIndex index = *(selectedRows.begin());\n    if (!index.isValid())\n        return;\n    if (act) {\n        if (act == actOpen) {\n            openDoubleClickedFile(index);\n        }\n        else if (act == actOpenContainingFolder) {\n            openFolder(index, true);\n        }\n        else if (act == actRename) {\n            renameSelectedFile();\n        }\n        else {\n            int prio = prio::NORMAL;\n            if (act == actionHigh)\n                prio = prio::HIGH;\n            else if (act == actionMaximum)\n                prio = prio::MAXIMUM;\n            else if (act == actionNot_downloaded)\n                prio = prio::IGNORED;\n\n            qDebug(\"Setting files priority\");\n            foreach (QModelIndex index, selectedRows) {\n                qDebug(\"Setting priority(%d) for file at row %d\", prio, index.row());\n                PropListModel->setData(PropListModel->index(index.row(), PRIORITY, index.parent()), prio);\n            }\n            // Save changes\n            filteredFilesChanged();\n        }\n    }\n}\n\nvoid PropertiesWidget::displayWebSeedListMenu(const QPoint &)\n{\n    if (!m_torrent) return;\n\n    QMenu seedMenu;\n    QModelIndexList rows = listWebSeeds->selectionModel()->selectedRows();\n    QAction *actAdd = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"list-add\"), tr(\"New Web seed\"));\n    QAction *actDel = 0;\n    QAction *actCpy = 0;\n    QAction *actEdit = 0;\n\n    if (rows.size()) {\n        actDel = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"list-remove\"), tr(\"Remove Web seed\"));\n        seedMenu.addSeparator();\n        actCpy = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-copy\"), tr(\"Copy Web seed URL\"));\n        actEdit = seedMenu.addAction(GuiIconProvider::instance()->getIcon(\"edit-rename\"), tr(\"Edit Web seed URL\"));\n    }\n\n    const QAction *act = seedMenu.exec(QCursor::pos());\n    if (act) {\n        if (act == actAdd)\n            askWebSeed();\n        else if (act == actDel)\n            deleteSelectedUrlSeeds();\n        else if (act == actCpy)\n            copySelectedWebSeedsToClipboard();\n        else if (act == actEdit)\n            editWebSeed();\n    }\n}\n\nvoid PropertiesWidget::renameSelectedFile()\n{\n    const QModelIndexList selectedIndexes = filesList->selectionModel()->selectedRows(0);\n    if (selectedIndexes.size() != 1)\n        return;\n    const QModelIndex index = selectedIndexes.first();\n    if (!index.isValid())\n        return;\n    // Ask for new name\n    bool ok;\n    QString new_name_last = AutoExpandableDialog::getText(this, tr(\"Rename the file\"),\n                                                          tr(\"New name:\"), QLineEdit::Normal,\n                                                          index.data().toString(), &ok).trimmed();\n    if (ok && !new_name_last.isEmpty()) {\n        if (!Utils::Fs::isValidFileSystemName(new_name_last)) {\n            MessageBoxRaised::warning(this, tr(\"The file could not be renamed\"),\n                                      tr(\"This file name contains forbidden characters, please choose a different one.\"),\n                                      QMessageBox::Ok);\n            return;\n        }\n        if (PropListModel->itemType(index) == TorrentContentModelItem::FileType) {\n            // File renaming\n            const int file_index = PropListModel->getFileIndex(index);\n            if (!m_torrent || !m_torrent->hasMetadata()) return;\n            QString old_name = m_torrent->filePath(file_index);\n            if (old_name.endsWith(\".!qB\") && !new_name_last.endsWith(\".!qB\"))\n                new_name_last += \".!qB\";\n            QStringList path_items = old_name.split(\"/\");\n            path_items.removeLast();\n            path_items << new_name_last;\n            QString new_name = path_items.join(\"/\");\n            if (Utils::Fs::sameFileNames(old_name, new_name)) {\n                qDebug(\"Name did not change\");\n                return;\n            }\n            new_name = Utils::Fs::expandPath(new_name);\n            qDebug(\"New name: %s\", qPrintable(new_name));\n            // Check if that name is already used\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                if (i == file_index) continue;\n                if (Utils::Fs::sameFileNames(m_torrent->filePath(i), new_name)) {\n                    // Display error message\n                    MessageBoxRaised::warning(this, tr(\"The file could not be renamed\"),\n                                              tr(\"This name is already in use in this folder. Please use a different name.\"),\n                                              QMessageBox::Ok);\n                    return;\n                }\n            }\n            const bool force_recheck = QFile::exists(m_torrent->savePath(true) + \"/\" + new_name);\n            qDebug(\"Renaming %s to %s\", qPrintable(old_name), qPrintable(new_name));\n            m_torrent->renameFile(file_index, new_name);\n            // Force recheck\n            if (force_recheck) m_torrent->forceRecheck();\n            // Rename if torrent files model too\n            if (new_name_last.endsWith(\".!qB\"))\n                new_name_last.chop(4);\n            PropListModel->setData(index, new_name_last);\n        }\n        else {\n            // Folder renaming\n            QStringList path_items;\n            path_items << index.data().toString();\n            QModelIndex parent = PropListModel->parent(index);\n            while (parent.isValid()) {\n                path_items.prepend(parent.data().toString());\n                parent = PropListModel->parent(parent);\n            }\n            const QString old_path = path_items.join(\"/\");\n            path_items.removeLast();\n            path_items << new_name_last;\n            QString new_path = path_items.join(\"/\");\n            if (Utils::Fs::sameFileNames(old_path, new_path)) {\n                qDebug(\"Name did not change\");\n                return;\n            }\n            if (!new_path.endsWith(\"/\")) new_path += \"/\";\n            // Check for overwriting\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                const QString &current_name = m_torrent->filePath(i);\n#if defined(Q_OS_UNIX) || defined(Q_WS_QWS)\n                if (current_name.startsWith(new_path, Qt::CaseSensitive)) {\n#else\n                if (current_name.startsWith(new_path, Qt::CaseInsensitive)) {\n#endif\n                    QMessageBox::warning(this, tr(\"The folder could not be renamed\"),\n                                         tr(\"This name is already in use in this folder. Please use a different name.\"),\n                                         QMessageBox::Ok);\n                    return;\n                }\n            }\n            bool force_recheck = false;\n            // Replace path in all files\n            for (int i = 0; i < m_torrent->filesCount(); ++i) {\n                const QString current_name = m_torrent->filePath(i);\n                if (current_name.startsWith(old_path)) {\n                    QString new_name = current_name;\n                    new_name.replace(0, old_path.length(), new_path);\n                    if (!force_recheck && QDir(m_torrent->savePath(true)).exists(new_name))\n                        force_recheck = true;\n                    new_name = Utils::Fs::expandPath(new_name);\n                    qDebug(\"Rename %s to %s\", qPrintable(current_name), qPrintable(new_name));\n                    m_torrent->renameFile(i, new_name);\n                }\n            }\n            // Force recheck\n            if (force_recheck) m_torrent->forceRecheck();\n            // Rename folder in torrent files model too\n            PropListModel->setData(index, new_name_last);\n            // Remove old folder\n            const QDir old_folder(m_torrent->savePath(true) + \"/\" + old_path);\n            int timeout = 10;\n            while (!QDir().rmpath(old_folder.absolutePath()) && timeout > 0) {\n                // FIXME: We should not sleep here (freezes the UI for 1 second)\n                Utils::Misc::msleep(100);\n                --timeout;\n            }\n        }\n    }\n}\n\nvoid PropertiesWidget::openSelectedFile()\n{\n    const QModelIndexList selectedIndexes = filesList->selectionModel()->selectedRows(0);\n    if (selectedIndexes.size() != 1)\n        return;\n    openDoubleClickedFile(selectedIndexes.first());\n}\n\nvoid PropertiesWidget::askWebSeed()\n{\n    bool ok;\n    // Ask user for a new url seed\n    const QString url_seed = AutoExpandableDialog::getText(this, tr(\"New URL seed\", \"New HTTP source\"),\n                                                           tr(\"New URL seed:\"), QLineEdit::Normal,\n                                                           QString::fromUtf8(\"http://www.\"), &ok);\n    if (!ok) return;\n    qDebug(\"Adding %s web seed\", qPrintable(url_seed));\n    if (!listWebSeeds->findItems(url_seed, Qt::MatchFixedString).empty()) {\n        QMessageBox::warning(this, \"qBittorrent\",\n                             tr(\"This URL seed is already in the list.\"),\n                             QMessageBox::Ok);\n        return;\n    }\n    if (m_torrent)\n        m_torrent->addUrlSeeds(QList<QUrl>() << url_seed);\n    // Refresh the seeds list\n    loadUrlSeeds();\n}\n\nvoid PropertiesWidget::deleteSelectedUrlSeeds()\n{\n    const QList<QListWidgetItem *> selectedItems = listWebSeeds->selectedItems();\n    if (selectedItems.isEmpty()) return;\n\n    QList<QUrl> urlSeeds;\n    foreach (const QListWidgetItem *item, selectedItems)\n        urlSeeds << item->text();\n\n    m_torrent->removeUrlSeeds(urlSeeds);\n    // Refresh list\n    loadUrlSeeds();\n}\n\nvoid PropertiesWidget::copySelectedWebSeedsToClipboard() const\n{\n    const QList<QListWidgetItem *> selected_items = listWebSeeds->selectedItems();\n    if (selected_items.isEmpty())\n        return;\n\n    QStringList urls_to_copy;\n    foreach (QListWidgetItem *item, selected_items)\n        urls_to_copy << item->text();\n\n    QApplication::clipboard()->setText(urls_to_copy.join(\"\\n\"));\n}\n\nvoid PropertiesWidget::editWebSeed()\n{\n    const QList<QListWidgetItem *> selected_items = listWebSeeds->selectedItems();\n    if (selected_items.size() != 1)\n        return;\n\n    const QListWidgetItem *selected_item = selected_items.last();\n    const QString old_seed = selected_item->text();\n    bool result;\n    const QString new_seed = AutoExpandableDialog::getText(this, tr(\"Web seed editing\"),\n                                                           tr(\"Web seed URL:\"), QLineEdit::Normal,\n                                                           old_seed, &result);\n    if (!result)\n        return;\n\n    if (!listWebSeeds->findItems(new_seed, Qt::MatchFixedString).empty()) {\n        QMessageBox::warning(this, tr(\"qBittorrent\"),\n                             tr(\"This URL seed is already in the list.\"),\n                             QMessageBox::Ok);\n        return;\n    }\n\n    m_torrent->removeUrlSeeds(QList<QUrl>() << old_seed);\n    m_torrent->addUrlSeeds(QList<QUrl>() << new_seed);\n    loadUrlSeeds();\n}\n\nbool PropertiesWidget::applyPriorities()\n{\n    qDebug(\"Saving files priorities\");\n    const QVector<int> priorities = PropListModel->model()->getFilePriorities();\n    // Prioritize the files\n    qDebug(\"prioritize files: %d\", priorities[0]);\n    m_torrent->prioritizeFiles(priorities);\n    return true;\n}\n\nvoid PropertiesWidget::filteredFilesChanged()\n{\n    if (m_torrent)\n        applyPriorities();\n}\n\nvoid PropertiesWidget::filterText(const QString &filter)\n{\n    PropListModel->setFilterRegExp(QRegExp(filter, Qt::CaseInsensitive, QRegExp::WildcardUnix));\n    if (filter.isEmpty()) {\n        filesList->collapseAll();\n        filesList->expand(PropListModel->index(0, 0));\n    }\n    else {\n        filesList->expandAll();\n    }\n}\n"], "filenames": ["src/base/logger.cpp", "src/base/utils/string.cpp", "src/base/utils/string.h", "src/gui/deletionconfirmationdlg.h", "src/gui/properties/peerlistwidget.cpp", "src/gui/properties/propertieswidget.cpp"], "buggy_code_start_loc": [3, 213, 49, 37, 404, 317], "buggy_code_end_loc": [53, 213, 49, 49, 436, 323], "fixing_code_start_loc": [4, 214, 50, 38, 404, 317], "fixing_code_end_loc": [54, 223, 52, 50, 436, 323], "type": "CWE-79", "message": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.", "other": {"cve": {"id": "CVE-2017-6503", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-06T02:59:00.743", "lastModified": "2017-03-14T01:59:03.880", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS."}, {"lang": "es", "value": "Interfaz web en qBittorrent en versiones anteriores a 3.3.11 no escap\u00f3 de muchos valores, lo que podr\u00eda conducir potencialmente a XSS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qbittorrent:qbittorrent:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.10", "matchCriteriaId": "E5FA12FE-8F2A-4725-A5CB-2D6897FE6A61"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96758", "source": "cve@mitre.org"}, {"url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.qbittorrent.org/news.php", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}]}, "github_commit_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16"}}