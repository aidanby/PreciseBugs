{"buggy_code": ["//\n// Copyright (c) 2016 KAMADA Ken'ichi.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n// SUCH DAMAGE.\n//\n\nuse std::io;\n\nuse crate::error::Error;\n\nconst ASCII_0: u8 = 0x30;\nconst ASCII_9: u8 = 0x39;\n\npub fn read8<R>(reader: &mut R) -> Result<u8, io::Error> where R: io::Read {\n    let mut buf = [0u8; 1];\n    reader.read_exact(&mut buf).and(Ok(buf[0]))\n}\n\npub fn read16<R>(reader: &mut R) -> Result<u16, io::Error> where R: io::Read {\n    let mut buf = [0u8; 2];\n    reader.read_exact(&mut buf)?;\n    Ok(u16::from_be_bytes(buf))\n}\n\npub fn read64<R>(reader: &mut R) -> Result<u64, io::Error> where R: io::Read {\n    let mut buf = [0u8; 8];\n    reader.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}\n\npub trait BufReadExt {\n    fn discard_exact(&mut self, len: usize) -> io::Result<()>;\n}\n\nimpl<T> BufReadExt for T where T: io::BufRead {\n    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {\n        while len > 0 {\n            let consume_len = match self.fill_buf() {\n                Ok(buf) => buf.len().min(len),\n                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            self.consume(consume_len);\n            len -= consume_len;\n        }\n        Ok(())\n    }\n}\n\n// This function must not be called with more than 4 bytes.\npub fn atou16(bytes: &[u8]) -> Result<u16, Error> {\n    if cfg!(debug_assertions) && bytes.len() >= 5 {\n        panic!(\"atou16 accepts up to 4 bytes\");\n    }\n    if bytes.len() == 0 {\n        return Err(Error::InvalidFormat(\"Not a number\"));\n    }\n    let mut n = 0;\n    for &c in bytes {\n        if c < ASCII_0 || ASCII_9 < c {\n            return Err(Error::InvalidFormat(\"Not a number\"));\n        }\n        n = n * 10 + (c - ASCII_0) as u16;\n    }\n    Ok(n)\n}\n\npub fn ctou32(c: u8) -> Result<u32, Error> {\n    if c < ASCII_0 || ASCII_9 < c {\n        return Err(Error::InvalidFormat(\"Not a number\"));\n    }\n    Ok((c - ASCII_0) as u32)\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n    use std::io::ErrorKind;\n    use std::io::Read;\n    use super::*;\n\n    #[test]\n    fn read8_len() {\n        let mut reader = Cursor::new([]);\n        assert_err_kind!(read8(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01]);\n        assert_ok!(read8(&mut reader), 0x01);\n        let mut reader = Cursor::new([0x01, 0x02]);\n        let mut buf = Vec::new();\n        assert_ok!(read8(&mut reader), 0x01);\n        assert_ok!(reader.read_to_end(&mut buf), 1);\n        assert_eq!(buf, [0x02]);\n    }\n\n    #[test]\n    fn read16_len() {\n        let mut reader = Cursor::new([]);\n        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01]);\n        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01, 0x02]);\n        assert_ok!(read16(&mut reader), 0x0102);\n        let mut reader = Cursor::new([0x01, 0x02, 0x03]);\n        let mut buf = Vec::new();\n        assert_ok!(read16(&mut reader), 0x0102);\n        assert_ok!(reader.read_to_end(&mut buf), 1);\n        assert_eq!(buf, [0x03]);\n    }\n\n    #[test]\n    fn atou16_misc() {\n        assert_ok!(atou16(b\"0\"), 0);\n        assert_ok!(atou16(b\"0010\"), 10);\n        assert_ok!(atou16(b\"9999\"), 9999);\n        assert_err_pat!(atou16(b\"\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\"/\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\":\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\"-1\"), Error::InvalidFormat(_));\n    }\n}\n"], "fixing_code": ["//\n// Copyright (c) 2016 KAMADA Ken'ichi.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n// SUCH DAMAGE.\n//\n\nuse std::io;\n\nuse crate::error::Error;\n\nconst ASCII_0: u8 = 0x30;\nconst ASCII_9: u8 = 0x39;\n\npub fn read8<R>(reader: &mut R) -> Result<u8, io::Error> where R: io::Read {\n    let mut buf = [0u8; 1];\n    reader.read_exact(&mut buf).and(Ok(buf[0]))\n}\n\npub fn read16<R>(reader: &mut R) -> Result<u16, io::Error> where R: io::Read {\n    let mut buf = [0u8; 2];\n    reader.read_exact(&mut buf)?;\n    Ok(u16::from_be_bytes(buf))\n}\n\npub fn read64<R>(reader: &mut R) -> Result<u64, io::Error> where R: io::Read {\n    let mut buf = [0u8; 8];\n    reader.read_exact(&mut buf)?;\n    Ok(u64::from_be_bytes(buf))\n}\n\npub trait BufReadExt {\n    fn discard_exact(&mut self, len: usize) -> io::Result<()>;\n}\n\nimpl<T> BufReadExt for T where T: io::BufRead {\n    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {\n        while len > 0 {\n            let consume_len = match self.fill_buf() {\n                Ok(buf) if buf.is_empty() =>\n                    return Err(io::Error::new(\n                        io::ErrorKind::UnexpectedEof, \"unexpected EOF\")),\n                Ok(buf) => buf.len().min(len),\n                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            self.consume(consume_len);\n            len -= consume_len;\n        }\n        Ok(())\n    }\n}\n\n// This function must not be called with more than 4 bytes.\npub fn atou16(bytes: &[u8]) -> Result<u16, Error> {\n    if cfg!(debug_assertions) && bytes.len() >= 5 {\n        panic!(\"atou16 accepts up to 4 bytes\");\n    }\n    if bytes.len() == 0 {\n        return Err(Error::InvalidFormat(\"Not a number\"));\n    }\n    let mut n = 0;\n    for &c in bytes {\n        if c < ASCII_0 || ASCII_9 < c {\n            return Err(Error::InvalidFormat(\"Not a number\"));\n        }\n        n = n * 10 + (c - ASCII_0) as u16;\n    }\n    Ok(n)\n}\n\npub fn ctou32(c: u8) -> Result<u32, Error> {\n    if c < ASCII_0 || ASCII_9 < c {\n        return Err(Error::InvalidFormat(\"Not a number\"));\n    }\n    Ok((c - ASCII_0) as u32)\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n    use std::io::ErrorKind;\n    use std::io::Read;\n    use super::*;\n\n    #[test]\n    fn discard_exact() {\n        let mut buf = b\"abc\".as_ref();\n        buf.discard_exact(1).unwrap();\n        assert_eq!(buf, b\"bc\");\n        buf.discard_exact(2).unwrap();\n        assert_eq!(buf, b\"\");\n        buf.discard_exact(1).unwrap_err();\n    }\n\n    #[test]\n    fn read8_len() {\n        let mut reader = Cursor::new([]);\n        assert_err_kind!(read8(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01]);\n        assert_ok!(read8(&mut reader), 0x01);\n        let mut reader = Cursor::new([0x01, 0x02]);\n        let mut buf = Vec::new();\n        assert_ok!(read8(&mut reader), 0x01);\n        assert_ok!(reader.read_to_end(&mut buf), 1);\n        assert_eq!(buf, [0x02]);\n    }\n\n    #[test]\n    fn read16_len() {\n        let mut reader = Cursor::new([]);\n        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01]);\n        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);\n        let mut reader = Cursor::new([0x01, 0x02]);\n        assert_ok!(read16(&mut reader), 0x0102);\n        let mut reader = Cursor::new([0x01, 0x02, 0x03]);\n        let mut buf = Vec::new();\n        assert_ok!(read16(&mut reader), 0x0102);\n        assert_ok!(reader.read_to_end(&mut buf), 1);\n        assert_eq!(buf, [0x03]);\n    }\n\n    #[test]\n    fn atou16_misc() {\n        assert_ok!(atou16(b\"0\"), 0);\n        assert_ok!(atou16(b\"0010\"), 10);\n        assert_ok!(atou16(b\"9999\"), 9999);\n        assert_err_pat!(atou16(b\"\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\"/\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\":\"), Error::InvalidFormat(_));\n        assert_err_pat!(atou16(b\"-1\"), Error::InvalidFormat(_));\n    }\n}\n"], "filenames": ["src/util.rs"], "buggy_code_start_loc": [58], "buggy_code_end_loc": [102], "fixing_code_start_loc": [59], "fixing_code_end_loc": [116], "type": "CWE-835", "message": "kamadak-exif is an exif parsing library written in pure Rust. In kamadak-exif version 0.5.2, there is an infinite loop in parsing crafted PNG files. Specifically, reader::read_from_container can cause an infinite loop when a crafted PNG file is given. This is fixed in version 0.5.3. No workaround is available. Applications that do not pass files with the PNG signature to Reader::read_from_container are not affected.", "other": {"cve": {"id": "CVE-2021-21235", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-06T02:15:12.967", "lastModified": "2022-10-19T13:00:59.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "kamadak-exif is an exif parsing library written in pure Rust. In kamadak-exif version 0.5.2, there is an infinite loop in parsing crafted PNG files. Specifically, reader::read_from_container can cause an infinite loop when a crafted PNG file is given. This is fixed in version 0.5.3. No workaround is available. Applications that do not pass files with the PNG signature to Reader::read_from_container are not affected."}, {"lang": "es", "value": "kamadak-exif es una biblioteca de an\u00e1lisis exif escrita en Rust puro.&#xa0;En kamadak-exif versi\u00f3n 0.5.2, Se presenta un bucle infinito en el an\u00e1lisis de archivos PNG dise\u00f1ados.&#xa0;Espec\u00edficamente, la funci\u00f3n reader::read_from_container puede causar un bucle infinito cuando se le proporciona un archivo PNG dise\u00f1ado.&#xa0;Esto es corregido en la versi\u00f3n 0.5.3. Ninguna soluci\u00f3n alternativa est\u00e1 disponible.&#xa0;Las aplicaciones que no aprueban archivos con la firma PNG a la funci\u00f3n Reader::read_from_container no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kamadak-exif_project:kamadak-exif:0.5.2:*:*:*:*:rust:*:*", "matchCriteriaId": "58DB84D2-C8B6-43E8-96C1-AE01E3B3ACF8"}]}]}], "references": [{"url": "https://crates.io/crates/kamadak-exif", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/kamadak/exif-rs/commit/f21df24616ea611c5d5d0e0e2f8042eb74d5ff48", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kamadak/exif-rs/security/advisories/GHSA-px9g-8hgv-jvg2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kamadak/exif-rs/commit/f21df24616ea611c5d5d0e0e2f8042eb74d5ff48"}}