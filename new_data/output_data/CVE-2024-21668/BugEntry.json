{"buggy_code": ["//\n//  MmkvHostObject.cpp\n//  Mmkv\n//\n//  Created by Marc Rousavy on 03.09.21.\n//  Copyright \u00a9 2021 Facebook. All rights reserved.\n//\n\n#include \"MmkvHostObject.h\"\n#include \"TypedArray.h\"\n#include <MMKV.h>\n#include <android/log.h>\n#include <string>\n#include <vector>\n\nMmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n\n  if (instance == nullptr) {\n    // Check if instanceId is invalid\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n\n    // Check if encryptionKey is invalid\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}\n\nstd::vector<jsi::PropNameID> MmkvHostObject::getPropertyNames(jsi::Runtime& rt) {\n  std::vector<jsi::PropNameID> result;\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"set\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getBoolean\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getBuffer\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getString\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getNumber\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"contains\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"delete\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getAllKeys\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"deleteAll\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"recrypt\")));\n  return result;\n}\n\njsi::Value MmkvHostObject::get(jsi::Runtime& runtime, const jsi::PropNameID& propNameId) {\n  auto propName = propNameId.utf8(runtime);\n  auto funcName = \"MMKV.\" + propName;\n\n  if (propName == \"set\") {\n    // MMKV.set(key: string, value: string | number | bool | Uint8Array)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        2, // key, value\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime,\n                               \"MMKV::set: First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n\n          if (arguments[1].isBool()) {\n            // bool\n            instance->set(arguments[1].getBool(), keyName);\n          } else if (arguments[1].isNumber()) {\n            // number\n            instance->set(arguments[1].getNumber(), keyName);\n          } else if (arguments[1].isString()) {\n            // string\n            auto stringValue = arguments[1].getString(runtime).utf8(runtime);\n            instance->set(stringValue, keyName);\n          } else if (arguments[1].isObject()) {\n            // object\n            auto object = arguments[1].asObject(runtime);\n            if (isTypedArray(runtime, object)) {\n              // Uint8Array\n              auto typedArray = getTypedArray(runtime, object);\n              auto bufferValue = typedArray.getBuffer(runtime);\n              mmkv::MMBuffer buffer(bufferValue.data(runtime), bufferValue.size(runtime),\n                                    mmkv::MMBufferCopyFlag::MMBufferNoCopy);\n              instance->set(buffer, keyName);\n            } else {\n              // unknown object\n              throw jsi::JSError(\n                  runtime, \"MMKV::set: 'value' argument is an object, but not of type Uint8Array!\");\n            }\n          } else {\n            // unknown type\n            throw jsi::JSError(\n                runtime,\n                \"MMKV::set: 'value' argument is not of type bool, number, string or buffer!\");\n          }\n\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"getBoolean\") {\n    // MMKV.getBoolean(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool hasValue;\n          auto value = instance->getBool(keyName, false, &hasValue);\n          if (hasValue) {\n            return jsi::Value(value);\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getString\") {\n    // MMKV.getString(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          std::string result;\n          bool hasValue = instance->getString(keyName, result);\n          if (hasValue) {\n            return jsi::Value(runtime, jsi::String::createFromUtf8(runtime, result));\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getNumber\") {\n    // MMKV.getNumber(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool hasValue;\n          auto value = instance->getDouble(keyName, 0.0, &hasValue);\n          if (hasValue) {\n            return jsi::Value(value);\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getBuffer\") {\n    // MMKV.getBuffer(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          mmkv::MMBuffer buffer;\n          bool hasValue = instance->getBytes(keyName, buffer);\n          if (hasValue) {\n            auto length = buffer.length();\n            TypedArray<TypedArrayKind::Uint8Array> array(runtime, length);\n            auto data = static_cast<const unsigned char*>(buffer.getPtr());\n            std::vector<unsigned char> vector(length);\n            vector.assign(data, data + length);\n            array.update(runtime, vector);\n            return array;\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"contains\") {\n    // MMKV.contains(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool containsKey = instance->containsKey(keyName);\n          return jsi::Value(containsKey);\n        });\n  }\n\n  if (propName == \"delete\") {\n    // MMKV.delete(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          instance->removeValueForKey(keyName);\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"getAllKeys\") {\n    // MMKV.getAllKeys()\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName), 0,\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          auto keys = instance->allKeys();\n          auto array = jsi::Array(runtime, keys.size());\n          for (int i = 0; i < keys.size(); i++) {\n            array.setValueAtIndex(runtime, i, keys[i]);\n          }\n          return array;\n        });\n  }\n\n  if (propName == \"clearAll\") {\n    // MMKV.clearAll()\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName), 0,\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          instance->clearAll();\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"recrypt\") {\n    // MMKV.recrypt(encryptionKey)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // encryptionKey\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (arguments[0].isUndefined()) {\n            // reset encryption key to \"no encryption\"\n            instance->reKey(std::string());\n          } else if (arguments[0].isString()) {\n            // reKey(..) with new encryption-key\n            auto encryptionKey = arguments[0].getString(runtime).utf8(runtime);\n            instance->reKey(encryptionKey);\n          } else {\n            throw jsi::JSError(\n                runtime,\n                \"First argument ('encryptionKey') has to be of type string (or undefined)!\");\n          }\n          return jsi::Value::undefined();\n        });\n  }\n\n  return jsi::Value::undefined();\n}\n"], "fixing_code": ["//\n//  MmkvHostObject.cpp\n//  Mmkv\n//\n//  Created by Marc Rousavy on 03.09.21.\n//  Copyright \u00a9 2021 Facebook. All rights reserved.\n//\n\n#include \"MmkvHostObject.h\"\n#include \"TypedArray.h\"\n#include <MMKV.h>\n#include <android/log.h>\n#include <string>\n#include <vector>\n\nMmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  bool hasEncryptionKey = cryptKey.size() > 0;\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encrypted: %b)\",\n                      instanceId.c_str(), path.c_str(), hasEncryptionKey);\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n\n  if (instance == nullptr) {\n    // Check if instanceId is invalid\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n\n    // Check if encryptionKey is invalid\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}\n\nstd::vector<jsi::PropNameID> MmkvHostObject::getPropertyNames(jsi::Runtime& rt) {\n  std::vector<jsi::PropNameID> result;\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"set\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getBoolean\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getBuffer\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getString\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getNumber\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"contains\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"delete\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"getAllKeys\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"deleteAll\")));\n  result.push_back(jsi::PropNameID::forUtf8(rt, std::string(\"recrypt\")));\n  return result;\n}\n\njsi::Value MmkvHostObject::get(jsi::Runtime& runtime, const jsi::PropNameID& propNameId) {\n  auto propName = propNameId.utf8(runtime);\n  auto funcName = \"MMKV.\" + propName;\n\n  if (propName == \"set\") {\n    // MMKV.set(key: string, value: string | number | bool | Uint8Array)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        2, // key, value\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime,\n                               \"MMKV::set: First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n\n          if (arguments[1].isBool()) {\n            // bool\n            instance->set(arguments[1].getBool(), keyName);\n          } else if (arguments[1].isNumber()) {\n            // number\n            instance->set(arguments[1].getNumber(), keyName);\n          } else if (arguments[1].isString()) {\n            // string\n            auto stringValue = arguments[1].getString(runtime).utf8(runtime);\n            instance->set(stringValue, keyName);\n          } else if (arguments[1].isObject()) {\n            // object\n            auto object = arguments[1].asObject(runtime);\n            if (isTypedArray(runtime, object)) {\n              // Uint8Array\n              auto typedArray = getTypedArray(runtime, object);\n              auto bufferValue = typedArray.getBuffer(runtime);\n              mmkv::MMBuffer buffer(bufferValue.data(runtime), bufferValue.size(runtime),\n                                    mmkv::MMBufferCopyFlag::MMBufferNoCopy);\n              instance->set(buffer, keyName);\n            } else {\n              // unknown object\n              throw jsi::JSError(\n                  runtime, \"MMKV::set: 'value' argument is an object, but not of type Uint8Array!\");\n            }\n          } else {\n            // unknown type\n            throw jsi::JSError(\n                runtime,\n                \"MMKV::set: 'value' argument is not of type bool, number, string or buffer!\");\n          }\n\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"getBoolean\") {\n    // MMKV.getBoolean(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool hasValue;\n          auto value = instance->getBool(keyName, false, &hasValue);\n          if (hasValue) {\n            return jsi::Value(value);\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getString\") {\n    // MMKV.getString(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          std::string result;\n          bool hasValue = instance->getString(keyName, result);\n          if (hasValue) {\n            return jsi::Value(runtime, jsi::String::createFromUtf8(runtime, result));\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getNumber\") {\n    // MMKV.getNumber(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool hasValue;\n          auto value = instance->getDouble(keyName, 0.0, &hasValue);\n          if (hasValue) {\n            return jsi::Value(value);\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"getBuffer\") {\n    // MMKV.getBuffer(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          mmkv::MMBuffer buffer;\n          bool hasValue = instance->getBytes(keyName, buffer);\n          if (hasValue) {\n            auto length = buffer.length();\n            TypedArray<TypedArrayKind::Uint8Array> array(runtime, length);\n            auto data = static_cast<const unsigned char*>(buffer.getPtr());\n            std::vector<unsigned char> vector(length);\n            vector.assign(data, data + length);\n            array.update(runtime, vector);\n            return array;\n          } else {\n            return jsi::Value::undefined();\n          }\n        });\n  }\n\n  if (propName == \"contains\") {\n    // MMKV.contains(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          bool containsKey = instance->containsKey(keyName);\n          return jsi::Value(containsKey);\n        });\n  }\n\n  if (propName == \"delete\") {\n    // MMKV.delete(key: string)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // key\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (!arguments[0].isString()) {\n            throw jsi::JSError(runtime, \"First argument ('key') has to be of type string!\");\n          }\n\n          auto keyName = arguments[0].getString(runtime).utf8(runtime);\n          instance->removeValueForKey(keyName);\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"getAllKeys\") {\n    // MMKV.getAllKeys()\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName), 0,\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          auto keys = instance->allKeys();\n          auto array = jsi::Array(runtime, keys.size());\n          for (int i = 0; i < keys.size(); i++) {\n            array.setValueAtIndex(runtime, i, keys[i]);\n          }\n          return array;\n        });\n  }\n\n  if (propName == \"clearAll\") {\n    // MMKV.clearAll()\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName), 0,\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          instance->clearAll();\n          return jsi::Value::undefined();\n        });\n  }\n\n  if (propName == \"recrypt\") {\n    // MMKV.recrypt(encryptionKey)\n    return jsi::Function::createFromHostFunction(\n        runtime, jsi::PropNameID::forAscii(runtime, funcName),\n        1, // encryptionKey\n        [this](jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* arguments,\n               size_t count) -> jsi::Value {\n          if (arguments[0].isUndefined()) {\n            // reset encryption key to \"no encryption\"\n            instance->reKey(std::string());\n          } else if (arguments[0].isString()) {\n            // reKey(..) with new encryption-key\n            auto encryptionKey = arguments[0].getString(runtime).utf8(runtime);\n            instance->reKey(encryptionKey);\n          } else {\n            throw jsi::JSError(\n                runtime,\n                \"First argument ('encryptionKey') has to be of type string (or undefined)!\");\n          }\n          return jsi::Value::undefined();\n        });\n  }\n\n  return jsi::Value::undefined();\n}\n"], "filenames": ["android/src/main/cpp/MmkvHostObject.cpp"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [21], "fixing_code_start_loc": [18], "fixing_code_end_loc": [22], "type": "CWE-532", "message": "react-native-mmkv is a library that allows easy use of MMKV inside React Native applications. Before version 2.11.0, the react-native-mmkv logged the optional encryption key for the MMKV database into the Android system log. The key can be obtained by anyone with access to the Android Debugging Bridge (ADB) if it is enabled in the phone settings. This bug is not present on iOS devices. By logging the encryption secret to the system logs, attackers can trivially recover the secret by enabling ADB and undermining an app's thread model. This issue has been patched in version 2.11.0.", "other": {"cve": {"id": "CVE-2024-21668", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-09T19:15:12.330", "lastModified": "2024-01-16T20:37:23.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "react-native-mmkv is a library that allows easy use of MMKV inside React Native applications. Before version 2.11.0, the react-native-mmkv logged the optional encryption key for the MMKV database into the Android system log. The key can be obtained by anyone with access to the Android Debugging Bridge (ADB) if it is enabled in the phone settings. This bug is not present on iOS devices. By logging the encryption secret to the system logs, attackers can trivially recover the secret by enabling ADB and undermining an app's thread model. This issue has been patched in version 2.11.0."}, {"lang": "es", "value": "react-native-mmkv es una librer\u00eda que permite el uso sencillo de MMKV dentro de aplicaciones React Native. Antes de la versi\u00f3n 2.11.0, react-native-mmkv registraba la clave de cifrado opcional para la base de datos MMKV en el registro del sistema Android. Cualquier persona con acceso al Android Debugging Bridge (ADB) puede obtener la clave si est\u00e1 habilitado en la configuraci\u00f3n del tel\u00e9fono. Este error no est\u00e1 presente en dispositivos iOS. Al registrar el secreto de cifrado en los registros del sistema, los atacantes pueden recuperar trivialmente el secreto habilitando ADB y socavando el modelo de subprocesos de una aplicaci\u00f3n. Este problema se solucion\u00f3 en la versi\u00f3n 2.11.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mrousavy:react-native-mmkv:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.11.0", "matchCriteriaId": "2F0F4C50-CDEB-4A18-A8BC-E087D59E6D75"}]}]}], "references": [{"url": "https://github.com/mrousavy/react-native-mmkv/commit/a8995ccb7184281f7d168bad3e9987c9bd05f00d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mrousavy/react-native-mmkv/releases/tag/v2.11.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mrousavy/react-native-mmkv/security/advisories/GHSA-4jh3-6jhv-2mgp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mrousavy/react-native-mmkv/commit/a8995ccb7184281f7d168bad3e9987c9bd05f00d"}}