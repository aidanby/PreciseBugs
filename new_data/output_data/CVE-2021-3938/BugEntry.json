{"buggy_code": ["<?php\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Events\\CheckoutableCheckedIn;\nuse Illuminate\\Support\\Facades\\Gate;\nuse App\\Helpers\\Helper;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Requests\\AssetCheckoutRequest;\nuse App\\Http\\Transformers\\AssetsTransformer;\nuse App\\Http\\Transformers\\DepreciationReportTransformer;\nuse App\\Http\\Transformers\\LicensesTransformer;\nuse App\\Http\\Transformers\\SelectlistTransformer;\nuse App\\Models\\Actionlog;\nuse App\\Models\\Asset;\nuse App\\Models\\AssetModel;\nuse App\\Models\\Company;\nuse App\\Models\\CustomField;\nuse App\\Models\\License;\nuse App\\Models\\Location;\nuse App\\Models\\Setting;\nuse App\\Models\\User;\nuse Auth;\nuse Carbon\\Carbon;\nuse DB;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Requests\\ImageUploadRequest;\nuse Input;\nuse Paginator;\nuse Slack;\nuse Str;\nuse TCPDF;\nuse Validator;\nuse Route;\n\n\n/**\n * This class controls all actions related to assets for\n * the Snipe-IT Asset Management application.\n *\n * @version    v1.0\n * @author [A. Gianotto] [<snipe@snipe.net>]\n */\nclass AssetsController extends Controller\n{\n\n    /**\n     * Returns JSON listing of all assets\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function index(Request $request, $audit = null) \n    {\n\n        \\Log::debug(Route::currentRouteName());\n        \n\n        /**\n         * This looks MAD janky (and it is), but the AssetsController@index does a LOT of heavy lifting throughout the \n         * app. This bit here just makes sure that someone without permission to view assets doesn't \n         * end up with priv escalations because they asked for a different endpoint. \n         * \n         * Since we never gave the specification for which transformer to use before, it should default \n         * gracefully to just use the AssetTransformer by default, which shouldn't break anything. \n         * \n         * It was either this mess, or repeating ALL of the searching and sorting and filtering code, \n         * which would have been far worse of a mess. *sad face*  - snipe (Sept 1, 2021)\n         */\n        if (Route::currentRouteName()=='api.depreciation-report.index') {\n            $transformer = 'App\\Http\\Transformers\\DepreciationReportTransformer';\n            $this->authorize('reports.view');\n        } else {\n            $transformer = 'App\\Http\\Transformers\\AssetsTransformer';\n            $this->authorize('index', Asset::class);          \n        }\n        \n       \n        $settings = Setting::getSettings();\n\n        $allowed_columns = [\n            'id',\n            'name',\n            'asset_tag',\n            'serial',\n            'model_number',\n            'last_checkout',\n            'notes',\n            'expected_checkin',\n            'order_number',\n            'image',\n            'assigned_to',\n            'created_at',\n            'updated_at',\n            'purchase_date',\n            'purchase_cost',\n            'last_audit_date',\n            'next_audit_date',\n            'warranty_months',\n            'checkout_counter',\n            'checkin_counter',\n            'requests_counter',\n        ];\n\n        $filter = array();\n\n        if ($request->filled('filter')) {\n            $filter = json_decode($request->input('filter'), true);\n        }\n\n        $all_custom_fields = CustomField::all(); //used as a 'cache' of custom fields throughout this page load\n        foreach ($all_custom_fields as $field) {\n            $allowed_columns[]=$field->db_column_name();\n        }\n\n        $assets = Company::scopeCompanyables(Asset::select('assets.*'),\"company_id\",\"assets\")\n            ->with('location', 'assetstatus', 'assetlog', 'company', 'defaultLoc','assignedTo',\n                'model.category', 'model.manufacturer', 'model.fieldset','supplier');\n\n        \n        // These are used by the API to query against specific ID numbers.\n        // They are also used by the individual searches on detail pages like\n        // locations, etc.\n        if ($request->filled('status_id')) {\n            $assets->where('assets.status_id', '=', $request->input('status_id'));\n        }\n\n        if ($request->input('requestable')=='true') {\n            $assets->where('assets.requestable', '=', '1');\n        }\n\n        if ($request->filled('model_id')) {\n            $assets->InModelList([$request->input('model_id')]);\n        }\n\n        if ($request->filled('category_id')) {\n            $assets->InCategory($request->input('category_id'));\n        }\n\n        if ($request->filled('location_id')) {\n            $assets->where('assets.location_id', '=', $request->input('location_id'));\n        }\n\n        if ($request->filled('rtd_location_id')) {\n            $assets->where('assets.rtd_location_id', '=', $request->input('rtd_location_id'));\n        }\n\n        if ($request->filled('supplier_id')) {\n            $assets->where('assets.supplier_id', '=', $request->input('supplier_id'));\n        }\n\n        if (($request->filled('assigned_to')) && ($request->filled('assigned_type'))) {\n            $assets->where('assets.assigned_to', '=', $request->input('assigned_to'))\n                ->where('assets.assigned_type', '=', $request->input('assigned_type'));\n        }\n\n        if ($request->filled('company_id')) {\n            $assets->where('assets.company_id', '=', $request->input('company_id'));\n        }\n\n        if ($request->filled('manufacturer_id')) {\n            $assets->ByManufacturer($request->input('manufacturer_id'));\n        }\n\n        if ($request->filled('depreciation_id')) {\n            $assets->ByDepreciationId($request->input('depreciation_id'));\n        }\n\n        $request->filled('order_number') ? $assets = $assets->where('assets.order_number', '=', e($request->get('order_number'))) : '';\n\n        // Set the offset to the API call's offset, unless the offset is higher than the actual count of items in which\n        // case we override with the actual count, so we should return 0 items.\n        $offset = (($assets) && ($request->get('offset') > $assets->count())) ? $assets->count() : $request->get('offset', 0);\n\n\n        // Check to make sure the limit is not higher than the max allowed\n        ((config('app.max_results') >= $request->input('limit')) && ($request->filled('limit'))) ? $limit = $request->input('limit') : $limit = config('app.max_results');\n\n        $order = $request->input('order') === 'asc' ? 'asc' : 'desc';\n\n        // This is used by the audit reporting routes\n        if (Gate::allows('audit', Asset::class)) {\n\n            switch ($audit) {\n                case 'due':\n                    $assets->DueOrOverdueForAudit($settings);\n                    break;\n                case 'overdue':\n                    $assets->overdueForAudit($settings);\n                    break;\n            }\n        }\n\n\n\n        // This is used by the sidenav, mostly\n\n        // We switched from using query scopes here because of a Laravel bug\n        // related to fulltext searches on complex queries.\n        // I am sad. :(\n        switch ($request->input('status')) {\n            case 'Deleted':\n                $assets->onlyTrashed();\n                break;\n            case 'Pending':\n                $assets->join('status_labels AS status_alias',function ($join) {\n                    $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                        ->where('status_alias.deployable','=',0)\n                        ->where('status_alias.pending','=',1)\n                        ->where('status_alias.archived', '=', 0);\n                });\n                break;\n            case 'RTD':\n                $assets->whereNull('assets.assigned_to')\n                    ->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.deployable','=',1)\n                            ->where('status_alias.pending','=',0)\n                            ->where('status_alias.archived', '=', 0);\n                    });\n                break;\n            case 'Undeployable':\n                $assets->Undeployable();\n                break;\n            case 'Archived':\n                $assets->join('status_labels AS status_alias',function ($join) {\n                    $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                        ->where('status_alias.deployable','=',0)\n                        ->where('status_alias.pending','=',0)\n                        ->where('status_alias.archived', '=', 1);\n                });\n                break;\n            case 'Requestable':\n                $assets->where('assets.requestable', '=', 1)\n                    ->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.deployable','=',1)\n                            ->where('status_alias.pending','=',0)\n                            ->where('status_alias.archived', '=', 0);\n                    });\n\n                break;\n            case 'Deployed':\n                // more sad, horrible workarounds for laravel bugs when doing full text searches\n                $assets->where('assets.assigned_to', '>', '0');\n                break;\n            default:\n\n                if ((!$request->filled('status_id')) && ($settings->show_archived_in_list!='1')) {\n                    // terrible workaround for complex-query Laravel bug in fulltext\n                    $assets->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.archived', '=', 0);\n                    });\n\n                    // If there is a status ID, don't take show_archived_in_list into consideration\n                } else {\n                    $assets->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\");\n                    });\n                }\n\n        }\n\n\n        if ((!is_null($filter)) && (count($filter)) > 0) {\n            $assets->ByFilter($filter);\n        } elseif ($request->filled('search')) {\n            $assets->TextSearch($request->input('search'));\n        }\n\n        \n        // This is kinda gross, but we need to do this because the Bootstrap Tables\n        // API passes custom field ordering as custom_fields.fieldname, and we have to strip\n        // that out to let the default sorter below order them correctly on the assets table.\n        $sort_override = str_replace('custom_fields.','', $request->input('sort')) ;\n\n        // This handles all of the pivot sorting (versus the assets.* fields\n        // in the allowed_columns array)\n        $column_sort = in_array($sort_override, $allowed_columns) ? $sort_override : 'assets.created_at';\n\n\n        switch ($sort_override) {\n            case 'model':\n                $assets->OrderModels($order);\n                break;\n            case 'model_number':\n                $assets->OrderModelNumber($order);\n                break;\n            case 'category':\n                $assets->OrderCategory($order);\n                break;\n            case 'manufacturer':\n                $assets->OrderManufacturer($order);\n                break;\n            case 'company':\n                $assets->OrderCompany($order);\n                break;\n            case 'location':\n                $assets->OrderLocation($order);\n            case 'rtd_location':\n                $assets->OrderRtdLocation($order);\n                break;\n            case 'status_label':\n                $assets->OrderStatus($order);\n                break;\n            case 'supplier':\n                $assets->OrderSupplier($order);\n                break;\n            case 'assigned_to':\n                $assets->OrderAssigned($order);\n                break;\n            default:\n                $assets->orderBy($column_sort, $order);\n                break;\n        }\n\n\n        $total = $assets->count();\n        $assets = $assets->skip($offset)->take($limit)->get();\n        \n    \n        /**\n         * Include additional associated relationships\n         */  \n        if ($request->input('components')) {\n            $assets->loadMissing(['components' => function ($query) {\n                $query->orderBy('created_at', 'desc');\n            }]);\n        }\n\n        \n\n\n        /**\n         * Here we're just determining which Transformer (via $transformer) to use based on the \n         * variables we set earlier on in this method - we default to AssetsTransformer.\n         */\n        return (new $transformer)->transformAssets($assets, $total, $request);\n    }\n\n\n    /**\n     * Returns JSON with information about an asset (by tag) for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param string $tag\n     * @since [v4.2.1]\n     * @return JsonResponse\n     */\n    public function showByTag(Request $request, $tag)\n    {\n        if ($asset = Asset::with('assetstatus')->with('assignedTo')->where('asset_tag',$tag)->first()) {\n            $this->authorize('view', $asset);\n            return (new AssetsTransformer)->transformAsset($asset, $request);\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, 'Asset not found'), 200);\n\n    }\n\n    /**\n     * Returns JSON with information about an asset (by serial) for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param string $serial\n     * @since [v4.2.1]\n     * @return JsonResponse\n     */\n    public function showBySerial(Request $request, $serial)\n    {\n        $this->authorize('index', Asset::class);\n\n        $assets = Asset::with('assetstatus')->with('assignedTo');\n\n        if ($request->input('deleted', 'false') === 'true') {\n            $assets = $assets->withTrashed();\n        }\n\n        $assets = $assets->where('serial', $serial)->get();\n        if ($assets) {\n            return (new AssetsTransformer)->transformAssets($assets, $assets->count());\n        } else {\n            return response()->json(Helper::formatStandardApiResponse('error', null, 'Asset not found'), 200);\n        }\n    }\n\n    /**\n     * Returns JSON with information about an asset for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function show(Request $request, $id)\n    {\n        if ($asset = Asset::with('assetstatus')->with('assignedTo')->withTrashed()\n            ->withCount('checkins as checkins_count', 'checkouts as checkouts_count', 'userRequests as user_requests_count')->findOrFail($id)) {\n            $this->authorize('view', $asset);\n            return (new AssetsTransformer)->transformAsset($asset, $request->input('components') );\n        }\n\n\n    }\n    public function licenses(Request $request, $id)\n    {\n        $this->authorize('view', Asset::class);\n        $this->authorize('view', License::class);\n        $asset = Asset::where('id', $id)->withTrashed()->first();\n        $licenses = $asset->licenses()->get();\n        return (new LicensesTransformer())->transformLicenses($licenses, $licenses->count());\n     }\n\n\n    /**\n     * Gets a paginated collection for the select2 menus\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0.16]\n     * @see \\App\\Http\\Transformers\\SelectlistTransformer\n     *\n     */\n    public function selectlist(Request $request)\n    {\n\n        $assets = Company::scopeCompanyables(Asset::select([\n            'assets.id',\n            'assets.name',\n            'assets.asset_tag',\n            'assets.model_id',\n            'assets.assigned_to',\n            'assets.assigned_type',\n            'assets.status_id'\n            ])->with('model', 'assetstatus', 'assignedTo')->NotArchived(), 'company_id', 'assets');\n\n        if ($request->filled('assetStatusType') && $request->input('assetStatusType') === 'RTD') {\n            $assets = $assets->RTD();\n        }\n\n        if ($request->filled('search')) {\n            $assets = $assets->AssignedSearch($request->input('search'));\n        }\n\n\n        $assets = $assets->paginate(50);\n\n        // Loop through and set some custom properties for the transformer to use.\n        // This lets us have more flexibility in special cases like assets, where\n        // they may not have a ->name value but we want to display something anyway\n        foreach ($assets as $asset) {\n\n\n            $asset->use_text = $asset->present()->fullName;\n\n            if (($asset->checkedOutToUser()) && ($asset->assigned)) {\n                $asset->use_text .= ' \u2192 '.$asset->assigned->getFullNameAttribute();\n            }\n\n\n            if ($asset->assetstatus->getStatuslabelType()=='pending') {\n                $asset->use_text .=  '('.$asset->assetstatus->getStatuslabelType().')';\n            }\n\n            $asset->use_image = ($asset->getImageUrl()) ? $asset->getImageUrl() : null;\n        }\n\n        return (new SelectlistTransformer)->transformSelectlist($assets);\n\n    }\n\n\n    /**\n     * Accepts a POST request to create a new asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param \\App\\Http\\Requests\\ImageUploadRequest $request\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function store(ImageUploadRequest $request)\n    {\n\n        $this->authorize('create', Asset::class);\n\n        $asset = new Asset();\n        $asset->model()->associate(AssetModel::find((int) $request->get('model_id')));\n\n        $asset->name                    = $request->get('name');\n        $asset->serial                  = $request->get('serial');\n        $asset->company_id              = Company::getIdForCurrentUser($request->get('company_id'));\n        $asset->model_id                = $request->get('model_id');\n        $asset->order_number            = $request->get('order_number');\n        $asset->notes                   = $request->get('notes');\n        $asset->asset_tag               = $request->get('asset_tag', Asset::autoincrement_asset());\n        $asset->user_id                 = Auth::id();\n        $asset->archived                = '0';\n        $asset->physical                = '1';\n        $asset->depreciate              = '0';\n        $asset->status_id               = $request->get('status_id', 0);\n        $asset->warranty_months         = $request->get('warranty_months', null);\n        $asset->purchase_cost           = Helper::ParseCurrency($request->get('purchase_cost')); // this is the API's store method, so I don't know that I want to do this? Confusing. FIXME (or not?!)\n        $asset->purchase_date           = $request->get('purchase_date', null);\n        $asset->assigned_to             = $request->get('assigned_to', null);\n        $asset->supplier_id             = $request->get('supplier_id', 0);\n        $asset->requestable             = $request->get('requestable', 0);\n        $asset->rtd_location_id         = $request->get('rtd_location_id', null);\n        $asset->location_id             = $request->get('rtd_location_id', null);\n\n        /**\n        * this is here just legacy reasons. Api\\AssetController\n        * used image_source  once to allow encoded image uploads.\n        */\n        if ($request->has('image_source')) {\n            $request->offsetSet('image', $request->offsetGet('image_source'));\n        }     \n\n        $asset = $request->handleImages($asset);\n\n        // Update custom fields in the database.\n        // Validation for these fields is handled through the AssetRequest form request\n        $model = AssetModel::find($request->get('model_id'));\n        if (($model) && ($model->fieldset)) {\n            foreach ($model->fieldset->fields as $field) {\n\n                // Set the field value based on what was sent in the request\n                $field_val = $request->input($field->convertUnicodeDbSlug(), null);\n\n                // If input value is null, use custom field's default value\n                if ($field_val == null) {\n                    \\Log::debug('Field value for '.$field->convertUnicodeDbSlug().' is null');\n                    $field_val = $field->defaultValue($request->get('model_id'));\n                    \\Log::debug('Use the default fieldset value of '.$field->defaultValue($request->get('model_id')));\n                }\n\n                // if the field is set to encrypted, make sure we encrypt the value\n                if ($field->field_encrypted == '1') {\n\n                    \\Log::debug('This model field is encrypted in this fieldset.');\n\n                    if (Gate::allows('admin')) {\n\n                        // If input value is null, use custom field's default value\n                        if (($field_val == null) && ($request->has('model_id')!='')){\n                            $field_val = \\Crypt::encrypt($field->defaultValue($request->get('model_id')));\n                        } else {\n                            $field_val = \\Crypt::encrypt($request->input($field->convertUnicodeDbSlug()));\n                        }\n                    }\n                }\n\n\n                $asset->{$field->convertUnicodeDbSlug()} = $field_val;\n\n            }\n        }\n\n        if ($asset->save()) {\n\n            if ($request->get('assigned_user')) {\n                $target = User::find(request('assigned_user'));\n            } elseif ($request->get('assigned_asset')) {\n                $target = Asset::find(request('assigned_asset'));\n            } elseif ($request->get('assigned_location')) {\n                $target = Location::find(request('assigned_location'));\n            }\n            if (isset($target)) {\n                $asset->checkOut($target, Auth::user(), date('Y-m-d H:i:s'), '', 'Checked out on asset creation', e($request->get('name')));\n            }\n\n            if ($asset->image) {\n                $asset->image = $asset->getImageUrl();\n            }\n\n            return response()->json(Helper::formatStandardApiResponse('success', $asset, trans('admin/hardware/message.create.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', null, $asset->getErrors()), 200);\n    }\n\n\n    /**\n     * Accepts a POST request to update an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param \\App\\Http\\Requests\\ImageUploadRequest $request\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function update(ImageUploadRequest $request, $id)\n    {\n        $this->authorize('update', Asset::class);\n\n        if ($asset = Asset::find($id)) {\n            $asset->fill($request->all());\n\n            ($request->filled('model_id')) ?\n                $asset->model()->associate(AssetModel::find($request->get('model_id'))) : null;\n            ($request->filled('rtd_location_id')) ?\n                $asset->location_id = $request->get('rtd_location_id') : '';\n            ($request->filled('company_id')) ?\n                $asset->company_id = Company::getIdForCurrentUser($request->get('company_id')) : '';\n\n            ($request->filled('rtd_location_id')) ?\n                $asset->location_id = $request->get('rtd_location_id') : null;\n\n            /**\n            * this is here just legacy reasons. Api\\AssetController\n            * used image_source  once to allow encoded image uploads.\n            */\n            if ($request->has('image_source')) {\n                $request->offsetSet('image', $request->offsetGet('image_source'));\n            }     \n\n            $asset = $request->handleImages($asset); \n            \n            // Update custom fields\n            if (($model = AssetModel::find($asset->model_id)) && (isset($model->fieldset))) {\n                foreach ($model->fieldset->fields as $field) {\n                    if ($request->has($field->convertUnicodeDbSlug())) {\n                        if ($field->field_encrypted=='1') {\n                            if (Gate::allows('admin')) {\n                                $asset->{$field->convertUnicodeDbSlug()} = \\Crypt::encrypt($request->input($field->convertUnicodeDbSlug()));\n                            }\n                        } else {\n                            $asset->{$field->convertUnicodeDbSlug()} = $request->input($field->convertUnicodeDbSlug());\n                        }\n                    }\n                }\n            }\n\n\n            if ($asset->save()) {\n\n                if (($request->filled('assigned_user')) && ($target = User::find($request->get('assigned_user')))) {\n                        $location = $target->location_id;\n                } elseif (($request->filled('assigned_asset')) && ($target = Asset::find($request->get('assigned_asset')))) {\n                    $location = $target->location_id;\n\n                    Asset::where('assigned_type', '\\\\App\\\\Models\\\\Asset')->where('assigned_to', $id)\n                        ->update(['location_id' => $target->location_id]);\n\n                } elseif (($request->filled('assigned_location')) && ($target = Location::find($request->get('assigned_location')))) {\n                    $location = $target->id;\n                }\n\n                if (isset($target)) {\n                    $asset->checkOut($target, Auth::user(), date('Y-m-d H:i:s'), '', 'Checked out on asset update', e($request->get('name')), $location);\n                }\n\n                if ($asset->image) {\n                    $asset->image = $asset->getImageUrl();\n                }\n\n                return response()->json(Helper::formatStandardApiResponse('success', $asset, trans('admin/hardware/message.update.success')));\n            }\n            return response()->json(Helper::formatStandardApiResponse('error', null, $asset->getErrors()), 200);\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n\n    /**\n     * Delete a given asset (mark as deleted).\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function destroy($id)\n    {\n        $this->authorize('delete', Asset::class);\n\n        if ($asset = Asset::find($id)) {\n\n            $this->authorize('delete', $asset);\n\n            DB::table('assets')\n                ->where('id', $asset->id)\n                ->update(array('assigned_to' => null));\n\n            $asset->delete();\n\n            return response()->json(Helper::formatStandardApiResponse('success', null, trans('admin/hardware/message.delete.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n    \n\n    /**\n     * Restore a soft-deleted asset.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v5.1.18]\n     * @return JsonResponse\n     */\n    public function restore($assetId = null)\n    {\n        // Get asset information\n        $asset = Asset::withTrashed()->find($assetId);\n        $this->authorize('delete', $asset);\n        if (isset($asset->id)) {\n            // Restore the asset\n            Asset::withTrashed()->where('id', $assetId)->restore();\n\n            $logaction = new Actionlog();\n            $logaction->item_type = Asset::class;\n            $logaction->item_id = $asset->id;\n            $logaction->created_at =  date(\"Y-m-d H:i:s\");\n            $logaction->user_id = Auth::user()->id;\n            $logaction->logaction('restored');\n\n            return response()->json(Helper::formatStandardApiResponse('success', null, trans('admin/hardware/message.restore.success')));\n        \n\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n\n\n    /**\n     * Checkout an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function checkout(AssetCheckoutRequest $request, $asset_id)\n    {\n        $this->authorize('checkout', Asset::class);\n        $asset = Asset::findOrFail($asset_id);\n\n        if (!$asset->availableForCheckout()) {\n            return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.not_available')));\n        }\n\n        $this->authorize('checkout', $asset);\n\n        $error_payload = [];\n        $error_payload['asset'] = [\n            'id' => $asset->id,\n            'asset_tag' => $asset->asset_tag,\n        ];\n\n\n        // This item is checked out to a location\n        if (request('checkout_to_type')=='location') {\n            $target = Location::find(request('assigned_location'));\n            $asset->location_id = ($target) ? $target->id : '';\n            $error_payload['target_id'] = $request->input('assigned_location');\n            $error_payload['target_type'] = 'location';\n\n        } elseif (request('checkout_to_type')=='asset') {\n            $target = Asset::where('id','!=',$asset_id)->find(request('assigned_asset'));\n            $asset->location_id = $target->rtd_location_id;\n            // Override with the asset's location_id if it has one\n            $asset->location_id = (($target) && (isset($target->location_id))) ? $target->location_id : '';\n            $error_payload['target_id'] = $request->input('assigned_asset');\n            $error_payload['target_type'] = 'asset';\n\n        } elseif (request('checkout_to_type')=='user') {\n            // Fetch the target and set the asset's new location_id\n            $target = User::find(request('assigned_user'));\n            $asset->location_id = (($target) && (isset($target->location_id))) ? $target->location_id : '';\n            $error_payload['target_id'] = $request->input('assigned_user');\n            $error_payload['target_type'] = 'user';\n        }\n\n\n\n        if (!isset($target)) {\n            return response()->json(Helper::formatStandardApiResponse('error', $error_payload, 'Checkout target for asset '.e($asset->asset_tag).' is invalid - '.$error_payload['target_type'].' does not exist.'));\n        }\n\n\n\n        $checkout_at = request('checkout_at', date(\"Y-m-d H:i:s\"));\n        $expected_checkin = request('expected_checkin', null);\n        $note = request('note', null);\n        $asset_name = request('name', null);\n\n        // Set the location ID to the RTD location id if there is one\n        // Wait, why are we doing this? This overrides the stuff we set further up, which makes no sense.\n        // TODO: Follow up here. WTF. Commented out for now. \n\n\n//        if ((isset($target->rtd_location_id)) && ($asset->rtd_location_id!='')) {\n//            $asset->location_id = $target->rtd_location_id;\n//        }\n\n\n\n        if ($asset->checkOut($target, Auth::user(), $checkout_at, $expected_checkin, $note, $asset_name, $asset->location_id)) {\n            return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.error')));\n    }\n\n\n    /**\n     * Checkin an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function checkin(Request $request, $asset_id)\n    {\n        $this->authorize('checkin', Asset::class);\n        $asset = Asset::findOrFail($asset_id);\n        $this->authorize('checkin', $asset);\n\n\n        $user = $asset->assignedUser;\n        if (is_null($target = $asset->assignedTo)) {\n            return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.already_checked_in')));\n        }\n\n        $asset->expected_checkin = null;\n        $asset->last_checkout = null;\n        $asset->assigned_to = null;\n        $asset->assignedTo()->disassociate($asset);\n        $asset->accepted = null;\n\n        if ($request->filled('name')) {\n            $asset->name = $request->input('name');\n        }\n        \n        $asset->location_id =  $asset->rtd_location_id;\n\n        if ($request->filled('location_id')) {\n            $asset->location_id =  $request->input('location_id');\n        }\n\n        if ($request->has('status_id')) {\n            $asset->status_id =  $request->input('status_id');\n        }\n\n        if ($asset->save()) {\n            event(new CheckoutableCheckedIn($asset, $target, Auth::user(), $request->input('note')));\n\n            return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.error')));\n    }\n\n\n    /**\n     * Mark an asset as audited\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $id\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function audit(Request $request) {\n\n\n        $this->authorize('audit', Asset::class);\n        $rules = array(\n            'asset_tag' => 'required',\n            'location_id' => 'exists:locations,id|nullable|numeric',\n            'next_audit_date' => 'date|nullable'\n        );\n\n        $validator = Validator::make($request->all(), $rules);\n        if ($validator->fails()) {\n            return response()->json(Helper::formatStandardApiResponse('error', null, $validator->errors()->all()));\n        }\n\n        $settings = Setting::getSettings();\n        $dt = Carbon::now()->addMonths($settings->audit_interval)->toDateString();\n\n        $asset = Asset::where('asset_tag','=', $request->input('asset_tag'))->first();\n\n\n        if ($asset) {\n            // We don't want to log this as a normal update, so let's bypass that\n            $asset->unsetEventDispatcher();\n            $asset->next_audit_date = $dt;\n\n            if ($request->filled('next_audit_date')) {\n                $asset->next_audit_date = $request->input('next_audit_date');\n            }\n\n            // Check to see if they checked the box to update the physical location,\n            // not just note it in the audit notes\n            if ($request->input('update_location')=='1') {\n                $asset->location_id = $request->input('location_id');\n            }\n\n            $asset->last_audit_date = date('Y-m-d H:i:s');\n\n            if ($asset->save()) {\n                $log = $asset->logAudit(request('note'),request('location_id'));\n                return response()->json(Helper::formatStandardApiResponse('success', [\n                    'asset_tag'=> e($asset->asset_tag),\n                    'note'=> e($request->input('note')),\n                    'next_audit_date' => Helper::getFormattedDateObject($asset->next_audit_date)\n                ], trans('admin/hardware/message.audit.success')));\n            }\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.$request->input('asset_tag').' not found'));\n\n\n\n\n\n    }\n\n\n\n    /**\n     * Returns JSON listing of all requestable assets\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function requestable(Request $request)\n    {\n        $this->authorize('viewRequestable', Asset::class);\n\n        $assets = Company::scopeCompanyables(Asset::select('assets.*'),\"company_id\",\"assets\")\n            ->with('location', 'assetstatus', 'assetlog', 'company', 'defaultLoc','assignedTo',\n                'model.category', 'model.manufacturer', 'model.fieldset','supplier')->where('assets.requestable', '=', '1');\n\n        $offset = request('offset', 0);\n        $limit = $request->input('limit', 50);\n        $order = $request->input('order') === 'asc' ? 'asc' : 'desc';\n        $assets->TextSearch($request->input('search'));\n\n        switch ($request->input('sort')) {\n            case 'model':\n                $assets->OrderModels($order);\n                break;\n            case 'model_number':\n                $assets->OrderModelNumber($order);\n                break;\n            case 'category':\n                $assets->OrderCategory($order);\n                break;\n            case 'manufacturer':\n                $assets->OrderManufacturer($order);\n                break;\n            default:\n                $assets->orderBy('assets.created_at', $order);\n                break;\n        }\n\n\n        $total = $assets->count();\n        $assets = $assets->skip($offset)->take($limit)->get();\n        return (new AssetsTransformer)->transformRequestedAssets($assets, $total);\n    }\n}\n"], "fixing_code": ["<?php\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Events\\CheckoutableCheckedIn;\nuse Illuminate\\Support\\Facades\\Gate;\nuse App\\Helpers\\Helper;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Requests\\AssetCheckoutRequest;\nuse App\\Http\\Transformers\\AssetsTransformer;\nuse App\\Http\\Transformers\\DepreciationReportTransformer;\nuse App\\Http\\Transformers\\LicensesTransformer;\nuse App\\Http\\Transformers\\SelectlistTransformer;\nuse App\\Models\\Actionlog;\nuse App\\Models\\Asset;\nuse App\\Models\\AssetModel;\nuse App\\Models\\Company;\nuse App\\Models\\CustomField;\nuse App\\Models\\License;\nuse App\\Models\\Location;\nuse App\\Models\\Setting;\nuse App\\Models\\User;\nuse Auth;\nuse Carbon\\Carbon;\nuse DB;\nuse Illuminate\\Http\\Request;\nuse App\\Http\\Requests\\ImageUploadRequest;\nuse Input;\nuse Paginator;\nuse Slack;\nuse Str;\nuse TCPDF;\nuse Validator;\nuse Route;\n\n\n/**\n * This class controls all actions related to assets for\n * the Snipe-IT Asset Management application.\n *\n * @version    v1.0\n * @author [A. Gianotto] [<snipe@snipe.net>]\n */\nclass AssetsController extends Controller\n{\n\n    /**\n     * Returns JSON listing of all assets\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function index(Request $request, $audit = null) \n    {\n\n        \\Log::debug(Route::currentRouteName());\n        \n\n        /**\n         * This looks MAD janky (and it is), but the AssetsController@index does a LOT of heavy lifting throughout the \n         * app. This bit here just makes sure that someone without permission to view assets doesn't \n         * end up with priv escalations because they asked for a different endpoint. \n         * \n         * Since we never gave the specification for which transformer to use before, it should default \n         * gracefully to just use the AssetTransformer by default, which shouldn't break anything. \n         * \n         * It was either this mess, or repeating ALL of the searching and sorting and filtering code, \n         * which would have been far worse of a mess. *sad face*  - snipe (Sept 1, 2021)\n         */\n        if (Route::currentRouteName()=='api.depreciation-report.index') {\n            $transformer = 'App\\Http\\Transformers\\DepreciationReportTransformer';\n            $this->authorize('reports.view');\n        } else {\n            $transformer = 'App\\Http\\Transformers\\AssetsTransformer';\n            $this->authorize('index', Asset::class);          \n        }\n        \n       \n        $settings = Setting::getSettings();\n\n        $allowed_columns = [\n            'id',\n            'name',\n            'asset_tag',\n            'serial',\n            'model_number',\n            'last_checkout',\n            'notes',\n            'expected_checkin',\n            'order_number',\n            'image',\n            'assigned_to',\n            'created_at',\n            'updated_at',\n            'purchase_date',\n            'purchase_cost',\n            'last_audit_date',\n            'next_audit_date',\n            'warranty_months',\n            'checkout_counter',\n            'checkin_counter',\n            'requests_counter',\n        ];\n\n        $filter = array();\n\n        if ($request->filled('filter')) {\n            $filter = json_decode($request->input('filter'), true);\n        }\n\n        $all_custom_fields = CustomField::all(); //used as a 'cache' of custom fields throughout this page load\n        foreach ($all_custom_fields as $field) {\n            $allowed_columns[]=$field->db_column_name();\n        }\n\n        $assets = Company::scopeCompanyables(Asset::select('assets.*'),\"company_id\",\"assets\")\n            ->with('location', 'assetstatus', 'assetlog', 'company', 'defaultLoc','assignedTo',\n                'model.category', 'model.manufacturer', 'model.fieldset','supplier');\n\n        \n        // These are used by the API to query against specific ID numbers.\n        // They are also used by the individual searches on detail pages like\n        // locations, etc.\n        if ($request->filled('status_id')) {\n            $assets->where('assets.status_id', '=', $request->input('status_id'));\n        }\n\n        if ($request->input('requestable')=='true') {\n            $assets->where('assets.requestable', '=', '1');\n        }\n\n        if ($request->filled('model_id')) {\n            $assets->InModelList([$request->input('model_id')]);\n        }\n\n        if ($request->filled('category_id')) {\n            $assets->InCategory($request->input('category_id'));\n        }\n\n        if ($request->filled('location_id')) {\n            $assets->where('assets.location_id', '=', $request->input('location_id'));\n        }\n\n        if ($request->filled('rtd_location_id')) {\n            $assets->where('assets.rtd_location_id', '=', $request->input('rtd_location_id'));\n        }\n\n        if ($request->filled('supplier_id')) {\n            $assets->where('assets.supplier_id', '=', $request->input('supplier_id'));\n        }\n\n        if (($request->filled('assigned_to')) && ($request->filled('assigned_type'))) {\n            $assets->where('assets.assigned_to', '=', $request->input('assigned_to'))\n                ->where('assets.assigned_type', '=', $request->input('assigned_type'));\n        }\n\n        if ($request->filled('company_id')) {\n            $assets->where('assets.company_id', '=', $request->input('company_id'));\n        }\n\n        if ($request->filled('manufacturer_id')) {\n            $assets->ByManufacturer($request->input('manufacturer_id'));\n        }\n\n        if ($request->filled('depreciation_id')) {\n            $assets->ByDepreciationId($request->input('depreciation_id'));\n        }\n\n        $request->filled('order_number') ? $assets = $assets->where('assets.order_number', '=', e($request->get('order_number'))) : '';\n\n        // Set the offset to the API call's offset, unless the offset is higher than the actual count of items in which\n        // case we override with the actual count, so we should return 0 items.\n        $offset = (($assets) && ($request->get('offset') > $assets->count())) ? $assets->count() : $request->get('offset', 0);\n\n\n        // Check to make sure the limit is not higher than the max allowed\n        ((config('app.max_results') >= $request->input('limit')) && ($request->filled('limit'))) ? $limit = $request->input('limit') : $limit = config('app.max_results');\n\n        $order = $request->input('order') === 'asc' ? 'asc' : 'desc';\n\n        // This is used by the audit reporting routes\n        if (Gate::allows('audit', Asset::class)) {\n\n            switch ($audit) {\n                case 'due':\n                    $assets->DueOrOverdueForAudit($settings);\n                    break;\n                case 'overdue':\n                    $assets->overdueForAudit($settings);\n                    break;\n            }\n        }\n\n\n\n        // This is used by the sidenav, mostly\n\n        // We switched from using query scopes here because of a Laravel bug\n        // related to fulltext searches on complex queries.\n        // I am sad. :(\n        switch ($request->input('status')) {\n            case 'Deleted':\n                $assets->onlyTrashed();\n                break;\n            case 'Pending':\n                $assets->join('status_labels AS status_alias',function ($join) {\n                    $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                        ->where('status_alias.deployable','=',0)\n                        ->where('status_alias.pending','=',1)\n                        ->where('status_alias.archived', '=', 0);\n                });\n                break;\n            case 'RTD':\n                $assets->whereNull('assets.assigned_to')\n                    ->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.deployable','=',1)\n                            ->where('status_alias.pending','=',0)\n                            ->where('status_alias.archived', '=', 0);\n                    });\n                break;\n            case 'Undeployable':\n                $assets->Undeployable();\n                break;\n            case 'Archived':\n                $assets->join('status_labels AS status_alias',function ($join) {\n                    $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                        ->where('status_alias.deployable','=',0)\n                        ->where('status_alias.pending','=',0)\n                        ->where('status_alias.archived', '=', 1);\n                });\n                break;\n            case 'Requestable':\n                $assets->where('assets.requestable', '=', 1)\n                    ->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.deployable','=',1)\n                            ->where('status_alias.pending','=',0)\n                            ->where('status_alias.archived', '=', 0);\n                    });\n\n                break;\n            case 'Deployed':\n                // more sad, horrible workarounds for laravel bugs when doing full text searches\n                $assets->where('assets.assigned_to', '>', '0');\n                break;\n            default:\n\n                if ((!$request->filled('status_id')) && ($settings->show_archived_in_list!='1')) {\n                    // terrible workaround for complex-query Laravel bug in fulltext\n                    $assets->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\")\n                            ->where('status_alias.archived', '=', 0);\n                    });\n\n                    // If there is a status ID, don't take show_archived_in_list into consideration\n                } else {\n                    $assets->join('status_labels AS status_alias',function ($join) {\n                        $join->on('status_alias.id', \"=\", \"assets.status_id\");\n                    });\n                }\n\n        }\n\n\n        if ((!is_null($filter)) && (count($filter)) > 0) {\n            $assets->ByFilter($filter);\n        } elseif ($request->filled('search')) {\n            $assets->TextSearch($request->input('search'));\n        }\n\n        \n        // This is kinda gross, but we need to do this because the Bootstrap Tables\n        // API passes custom field ordering as custom_fields.fieldname, and we have to strip\n        // that out to let the default sorter below order them correctly on the assets table.\n        $sort_override = str_replace('custom_fields.','', $request->input('sort')) ;\n\n        // This handles all of the pivot sorting (versus the assets.* fields\n        // in the allowed_columns array)\n        $column_sort = in_array($sort_override, $allowed_columns) ? $sort_override : 'assets.created_at';\n\n\n        switch ($sort_override) {\n            case 'model':\n                $assets->OrderModels($order);\n                break;\n            case 'model_number':\n                $assets->OrderModelNumber($order);\n                break;\n            case 'category':\n                $assets->OrderCategory($order);\n                break;\n            case 'manufacturer':\n                $assets->OrderManufacturer($order);\n                break;\n            case 'company':\n                $assets->OrderCompany($order);\n                break;\n            case 'location':\n                $assets->OrderLocation($order);\n            case 'rtd_location':\n                $assets->OrderRtdLocation($order);\n                break;\n            case 'status_label':\n                $assets->OrderStatus($order);\n                break;\n            case 'supplier':\n                $assets->OrderSupplier($order);\n                break;\n            case 'assigned_to':\n                $assets->OrderAssigned($order);\n                break;\n            default:\n                $assets->orderBy($column_sort, $order);\n                break;\n        }\n\n\n        $total = $assets->count();\n        $assets = $assets->skip($offset)->take($limit)->get();\n        \n    \n        /**\n         * Include additional associated relationships\n         */  \n        if ($request->input('components')) {\n            $assets->loadMissing(['components' => function ($query) {\n                $query->orderBy('created_at', 'desc');\n            }]);\n        }\n\n        \n\n\n        /**\n         * Here we're just determining which Transformer (via $transformer) to use based on the \n         * variables we set earlier on in this method - we default to AssetsTransformer.\n         */\n        return (new $transformer)->transformAssets($assets, $total, $request);\n    }\n\n\n    /**\n     * Returns JSON with information about an asset (by tag) for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param string $tag\n     * @since [v4.2.1]\n     * @return JsonResponse\n     */\n    public function showByTag(Request $request, $tag)\n    {\n        if ($asset = Asset::with('assetstatus')->with('assignedTo')->where('asset_tag',$tag)->first()) {\n            $this->authorize('view', $asset);\n            return (new AssetsTransformer)->transformAsset($asset, $request);\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, 'Asset not found'), 200);\n\n    }\n\n    /**\n     * Returns JSON with information about an asset (by serial) for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param string $serial\n     * @since [v4.2.1]\n     * @return JsonResponse\n     */\n    public function showBySerial(Request $request, $serial)\n    {\n        $this->authorize('index', Asset::class);\n\n        $assets = Asset::with('assetstatus')->with('assignedTo');\n\n        if ($request->input('deleted', 'false') === 'true') {\n            $assets = $assets->withTrashed();\n        }\n\n        $assets = $assets->where('serial', $serial)->get();\n        if ($assets) {\n            return (new AssetsTransformer)->transformAssets($assets, $assets->count());\n        } else {\n            return response()->json(Helper::formatStandardApiResponse('error', null, 'Asset not found'), 200);\n        }\n    }\n\n    /**\n     * Returns JSON with information about an asset for detail view.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function show(Request $request, $id)\n    {\n        if ($asset = Asset::with('assetstatus')->with('assignedTo')->withTrashed()\n            ->withCount('checkins as checkins_count', 'checkouts as checkouts_count', 'userRequests as user_requests_count')->findOrFail($id)) {\n            $this->authorize('view', $asset);\n            return (new AssetsTransformer)->transformAsset($asset, $request->input('components') );\n        }\n\n\n    }\n    public function licenses(Request $request, $id)\n    {\n        $this->authorize('view', Asset::class);\n        $this->authorize('view', License::class);\n        $asset = Asset::where('id', $id)->withTrashed()->first();\n        $licenses = $asset->licenses()->get();\n        return (new LicensesTransformer())->transformLicenses($licenses, $licenses->count());\n     }\n\n\n    /**\n     * Gets a paginated collection for the select2 menus\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0.16]\n     * @see \\App\\Http\\Transformers\\SelectlistTransformer\n     *\n     */\n    public function selectlist(Request $request)\n    {\n\n        $assets = Company::scopeCompanyables(Asset::select([\n            'assets.id',\n            'assets.name',\n            'assets.asset_tag',\n            'assets.model_id',\n            'assets.assigned_to',\n            'assets.assigned_type',\n            'assets.status_id'\n            ])->with('model', 'assetstatus', 'assignedTo')->NotArchived(), 'company_id', 'assets');\n\n        if ($request->filled('assetStatusType') && $request->input('assetStatusType') === 'RTD') {\n            $assets = $assets->RTD();\n        }\n\n        if ($request->filled('search')) {\n            $assets = $assets->AssignedSearch($request->input('search'));\n        }\n\n\n        $assets = $assets->paginate(50);\n\n        // Loop through and set some custom properties for the transformer to use.\n        // This lets us have more flexibility in special cases like assets, where\n        // they may not have a ->name value but we want to display something anyway\n        foreach ($assets as $asset) {\n\n\n            $asset->use_text = $asset->present()->fullName;\n\n            if (($asset->checkedOutToUser()) && ($asset->assigned)) {\n                $asset->use_text .= ' \u2192 '.$asset->assigned->getFullNameAttribute();\n            }\n\n\n            if ($asset->assetstatus->getStatuslabelType()=='pending') {\n                $asset->use_text .=  '('.$asset->assetstatus->getStatuslabelType().')';\n            }\n\n            $asset->use_image = ($asset->getImageUrl()) ? $asset->getImageUrl() : null;\n        }\n\n        return (new SelectlistTransformer)->transformSelectlist($assets);\n\n    }\n\n\n    /**\n     * Accepts a POST request to create a new asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param \\App\\Http\\Requests\\ImageUploadRequest $request\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function store(ImageUploadRequest $request)\n    {\n\n        $this->authorize('create', Asset::class);\n\n        $asset = new Asset();\n        $asset->model()->associate(AssetModel::find((int) $request->get('model_id')));\n\n        $asset->name                    = $request->get('name');\n        $asset->serial                  = $request->get('serial');\n        $asset->company_id              = Company::getIdForCurrentUser($request->get('company_id'));\n        $asset->model_id                = $request->get('model_id');\n        $asset->order_number            = $request->get('order_number');\n        $asset->notes                   = $request->get('notes');\n        $asset->asset_tag               = $request->get('asset_tag', Asset::autoincrement_asset());\n        $asset->user_id                 = Auth::id();\n        $asset->archived                = '0';\n        $asset->physical                = '1';\n        $asset->depreciate              = '0';\n        $asset->status_id               = $request->get('status_id', 0);\n        $asset->warranty_months         = $request->get('warranty_months', null);\n        $asset->purchase_cost           = Helper::ParseCurrency($request->get('purchase_cost')); // this is the API's store method, so I don't know that I want to do this? Confusing. FIXME (or not?!)\n        $asset->purchase_date           = $request->get('purchase_date', null);\n        $asset->assigned_to             = $request->get('assigned_to', null);\n        $asset->supplier_id             = $request->get('supplier_id', 0);\n        $asset->requestable             = $request->get('requestable', 0);\n        $asset->rtd_location_id         = $request->get('rtd_location_id', null);\n        $asset->location_id             = $request->get('rtd_location_id', null);\n\n        /**\n        * this is here just legacy reasons. Api\\AssetController\n        * used image_source  once to allow encoded image uploads.\n        */\n        if ($request->has('image_source')) {\n            $request->offsetSet('image', $request->offsetGet('image_source'));\n        }     \n\n        $asset = $request->handleImages($asset);\n\n        // Update custom fields in the database.\n        // Validation for these fields is handled through the AssetRequest form request\n        $model = AssetModel::find($request->get('model_id'));\n        if (($model) && ($model->fieldset)) {\n            foreach ($model->fieldset->fields as $field) {\n\n                // Set the field value based on what was sent in the request\n                $field_val = $request->input($field->convertUnicodeDbSlug(), null);\n\n                // If input value is null, use custom field's default value\n                if ($field_val == null) {\n                    \\Log::debug('Field value for '.$field->convertUnicodeDbSlug().' is null');\n                    $field_val = $field->defaultValue($request->get('model_id'));\n                    \\Log::debug('Use the default fieldset value of '.$field->defaultValue($request->get('model_id')));\n                }\n\n                // if the field is set to encrypted, make sure we encrypt the value\n                if ($field->field_encrypted == '1') {\n\n                    \\Log::debug('This model field is encrypted in this fieldset.');\n\n                    if (Gate::allows('admin')) {\n\n                        // If input value is null, use custom field's default value\n                        if (($field_val == null) && ($request->has('model_id')!='')){\n                            $field_val = \\Crypt::encrypt($field->defaultValue($request->get('model_id')));\n                        } else {\n                            $field_val = \\Crypt::encrypt($request->input($field->convertUnicodeDbSlug()));\n                        }\n                    }\n                }\n\n\n                $asset->{$field->convertUnicodeDbSlug()} = $field_val;\n\n            }\n        }\n\n        if ($asset->save()) {\n\n            if ($request->get('assigned_user')) {\n                $target = User::find(request('assigned_user'));\n            } elseif ($request->get('assigned_asset')) {\n                $target = Asset::find(request('assigned_asset'));\n            } elseif ($request->get('assigned_location')) {\n                $target = Location::find(request('assigned_location'));\n            }\n            if (isset($target)) {\n                $asset->checkOut($target, Auth::user(), date('Y-m-d H:i:s'), '', 'Checked out on asset creation', e($request->get('name')));\n            }\n\n            if ($asset->image) {\n                $asset->image = $asset->getImageUrl();\n            }\n\n            return response()->json(Helper::formatStandardApiResponse('success', $asset, trans('admin/hardware/message.create.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', null, $asset->getErrors()), 200);\n    }\n\n\n    /**\n     * Accepts a POST request to update an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param \\App\\Http\\Requests\\ImageUploadRequest $request\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function update(ImageUploadRequest $request, $id)\n    {\n        $this->authorize('update', Asset::class);\n\n        if ($asset = Asset::find($id)) {\n            $asset->fill($request->all());\n\n            ($request->filled('model_id')) ?\n                $asset->model()->associate(AssetModel::find($request->get('model_id'))) : null;\n            ($request->filled('rtd_location_id')) ?\n                $asset->location_id = $request->get('rtd_location_id') : '';\n            ($request->filled('company_id')) ?\n                $asset->company_id = Company::getIdForCurrentUser($request->get('company_id')) : '';\n\n            ($request->filled('rtd_location_id')) ?\n                $asset->location_id = $request->get('rtd_location_id') : null;\n\n            /**\n            * this is here just legacy reasons. Api\\AssetController\n            * used image_source  once to allow encoded image uploads.\n            */\n            if ($request->has('image_source')) {\n                $request->offsetSet('image', $request->offsetGet('image_source'));\n            }     \n\n            $asset = $request->handleImages($asset); \n            \n            // Update custom fields\n            if (($model = AssetModel::find($asset->model_id)) && (isset($model->fieldset))) {\n                foreach ($model->fieldset->fields as $field) {\n                    if ($request->has($field->convertUnicodeDbSlug())) {\n                        if ($field->field_encrypted=='1') {\n                            if (Gate::allows('admin')) {\n                                $asset->{$field->convertUnicodeDbSlug()} = \\Crypt::encrypt($request->input($field->convertUnicodeDbSlug()));\n                            }\n                        } else {\n                            $asset->{$field->convertUnicodeDbSlug()} = $request->input($field->convertUnicodeDbSlug());\n                        }\n                    }\n                }\n            }\n\n\n            if ($asset->save()) {\n\n                if (($request->filled('assigned_user')) && ($target = User::find($request->get('assigned_user')))) {\n                        $location = $target->location_id;\n                } elseif (($request->filled('assigned_asset')) && ($target = Asset::find($request->get('assigned_asset')))) {\n                    $location = $target->location_id;\n\n                    Asset::where('assigned_type', '\\\\App\\\\Models\\\\Asset')->where('assigned_to', $id)\n                        ->update(['location_id' => $target->location_id]);\n\n                } elseif (($request->filled('assigned_location')) && ($target = Location::find($request->get('assigned_location')))) {\n                    $location = $target->id;\n                }\n\n                if (isset($target)) {\n                    $asset->checkOut($target, Auth::user(), date('Y-m-d H:i:s'), '', 'Checked out on asset update', e($request->get('name')), $location);\n                }\n\n                if ($asset->image) {\n                    $asset->image = $asset->getImageUrl();\n                }\n\n                return response()->json(Helper::formatStandardApiResponse('success', $asset, trans('admin/hardware/message.update.success')));\n            }\n            return response()->json(Helper::formatStandardApiResponse('error', null, $asset->getErrors()), 200);\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n\n    /**\n     * Delete a given asset (mark as deleted).\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function destroy($id)\n    {\n        $this->authorize('delete', Asset::class);\n\n        if ($asset = Asset::find($id)) {\n\n            $this->authorize('delete', $asset);\n\n            DB::table('assets')\n                ->where('id', $asset->id)\n                ->update(array('assigned_to' => null));\n\n            $asset->delete();\n\n            return response()->json(Helper::formatStandardApiResponse('success', null, trans('admin/hardware/message.delete.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n    \n\n    /**\n     * Restore a soft-deleted asset.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v5.1.18]\n     * @return JsonResponse\n     */\n    public function restore($assetId = null)\n    {\n        // Get asset information\n        $asset = Asset::withTrashed()->find($assetId);\n        $this->authorize('delete', $asset);\n        if (isset($asset->id)) {\n            // Restore the asset\n            Asset::withTrashed()->where('id', $assetId)->restore();\n\n            $logaction = new Actionlog();\n            $logaction->item_type = Asset::class;\n            $logaction->item_id = $asset->id;\n            $logaction->created_at =  date(\"Y-m-d H:i:s\");\n            $logaction->user_id = Auth::user()->id;\n            $logaction->logaction('restored');\n\n            return response()->json(Helper::formatStandardApiResponse('success', null, trans('admin/hardware/message.restore.success')));\n        \n\n        }\n        return response()->json(Helper::formatStandardApiResponse('error', null, trans('admin/hardware/message.does_not_exist')), 200);\n    }\n\n\n\n    /**\n     * Checkout an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function checkout(AssetCheckoutRequest $request, $asset_id)\n    {\n        $this->authorize('checkout', Asset::class);\n        $asset = Asset::findOrFail($asset_id);\n\n        if (!$asset->availableForCheckout()) {\n            return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.not_available')));\n        }\n\n        $this->authorize('checkout', $asset);\n\n        $error_payload = [];\n        $error_payload['asset'] = [\n            'id' => $asset->id,\n            'asset_tag' => $asset->asset_tag,\n        ];\n\n\n        // This item is checked out to a location\n        if (request('checkout_to_type')=='location') {\n            $target = Location::find(request('assigned_location'));\n            $asset->location_id = ($target) ? $target->id : '';\n            $error_payload['target_id'] = $request->input('assigned_location');\n            $error_payload['target_type'] = 'location';\n\n        } elseif (request('checkout_to_type')=='asset') {\n            $target = Asset::where('id','!=',$asset_id)->find(request('assigned_asset'));\n            $asset->location_id = $target->rtd_location_id;\n            // Override with the asset's location_id if it has one\n            $asset->location_id = (($target) && (isset($target->location_id))) ? $target->location_id : '';\n            $error_payload['target_id'] = $request->input('assigned_asset');\n            $error_payload['target_type'] = 'asset';\n\n        } elseif (request('checkout_to_type')=='user') {\n            // Fetch the target and set the asset's new location_id\n            $target = User::find(request('assigned_user'));\n            $asset->location_id = (($target) && (isset($target->location_id))) ? $target->location_id : '';\n            $error_payload['target_id'] = $request->input('assigned_user');\n            $error_payload['target_type'] = 'user';\n        }\n\n\n\n        if (!isset($target)) {\n            return response()->json(Helper::formatStandardApiResponse('error', $error_payload, 'Checkout target for asset '.e($asset->asset_tag).' is invalid - '.$error_payload['target_type'].' does not exist.'));\n        }\n\n\n\n        $checkout_at = request('checkout_at', date(\"Y-m-d H:i:s\"));\n        $expected_checkin = request('expected_checkin', null);\n        $note = request('note', null);\n        $asset_name = request('name', null);\n\n        // Set the location ID to the RTD location id if there is one\n        // Wait, why are we doing this? This overrides the stuff we set further up, which makes no sense.\n        // TODO: Follow up here. WTF. Commented out for now. \n\n\n//        if ((isset($target->rtd_location_id)) && ($asset->rtd_location_id!='')) {\n//            $asset->location_id = $target->rtd_location_id;\n//        }\n\n\n\n        if ($asset->checkOut($target, Auth::user(), $checkout_at, $expected_checkin, $note, $asset_name, $asset->location_id)) {\n            return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkout.error')));\n    }\n\n\n    /**\n     * Checkin an asset\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $assetId\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function checkin(Request $request, $asset_id)\n    {\n        $this->authorize('checkin', Asset::class);\n        $asset = Asset::findOrFail($asset_id);\n        $this->authorize('checkin', $asset);\n\n\n        $user = $asset->assignedUser;\n        if (is_null($target = $asset->assignedTo)) {\n            return response()->json(Helper::formatStandardApiResponse('error', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.already_checked_in')));\n        }\n\n        $asset->expected_checkin = null;\n        $asset->last_checkout = null;\n        $asset->assigned_to = null;\n        $asset->assignedTo()->disassociate($asset);\n        $asset->accepted = null;\n\n        if ($request->filled('name')) {\n            $asset->name = $request->input('name');\n        }\n        \n        $asset->location_id =  $asset->rtd_location_id;\n\n        if ($request->filled('location_id')) {\n            $asset->location_id =  $request->input('location_id');\n        }\n\n        if ($request->has('status_id')) {\n            $asset->status_id =  $request->input('status_id');\n        }\n\n        if ($asset->save()) {\n            event(new CheckoutableCheckedIn($asset, $target, Auth::user(), $request->input('note')));\n\n            return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.success')));\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('success', ['asset'=> e($asset->asset_tag)], trans('admin/hardware/message.checkin.error')));\n    }\n\n\n    /**\n     * Mark an asset as audited\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @param int $id\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function audit(Request $request) {\n\n\n        $this->authorize('audit', Asset::class);\n        $rules = array(\n            'asset_tag' => 'required',\n            'location_id' => 'exists:locations,id|nullable|numeric',\n            'next_audit_date' => 'date|nullable'\n        );\n\n        $validator = Validator::make($request->all(), $rules);\n        if ($validator->fails()) {\n            return response()->json(Helper::formatStandardApiResponse('error', null, $validator->errors()->all()));\n        }\n\n        $settings = Setting::getSettings();\n        $dt = Carbon::now()->addMonths($settings->audit_interval)->toDateString();\n\n        $asset = Asset::where('asset_tag','=', $request->input('asset_tag'))->first();\n\n\n        if ($asset) {\n            // We don't want to log this as a normal update, so let's bypass that\n            $asset->unsetEventDispatcher();\n            $asset->next_audit_date = $dt;\n\n            if ($request->filled('next_audit_date')) {\n                $asset->next_audit_date = $request->input('next_audit_date');\n            }\n\n            // Check to see if they checked the box to update the physical location,\n            // not just note it in the audit notes\n            if ($request->input('update_location')=='1') {\n                $asset->location_id = $request->input('location_id');\n            }\n\n            $asset->last_audit_date = date('Y-m-d H:i:s');\n\n            if ($asset->save()) {\n                $log = $asset->logAudit(request('note'),request('location_id'));\n                return response()->json(Helper::formatStandardApiResponse('success', [\n                    'asset_tag'=> e($asset->asset_tag),\n                    'note'=> e($request->input('note')),\n                    'next_audit_date' => Helper::getFormattedDateObject($asset->next_audit_date)\n                ], trans('admin/hardware/message.audit.success')));\n            }\n        }\n\n        return response()->json(Helper::formatStandardApiResponse('error', ['asset_tag'=> e($request->input('asset_tag'))], 'Asset with tag '.e($request->input('asset_tag')).' not found'));\n\n\n\n\n\n    }\n\n\n\n    /**\n     * Returns JSON listing of all requestable assets\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return JsonResponse\n     */\n    public function requestable(Request $request)\n    {\n        $this->authorize('viewRequestable', Asset::class);\n\n        $assets = Company::scopeCompanyables(Asset::select('assets.*'),\"company_id\",\"assets\")\n            ->with('location', 'assetstatus', 'assetlog', 'company', 'defaultLoc','assignedTo',\n                'model.category', 'model.manufacturer', 'model.fieldset','supplier')->where('assets.requestable', '=', '1');\n\n        $offset = request('offset', 0);\n        $limit = $request->input('limit', 50);\n        $order = $request->input('order') === 'asc' ? 'asc' : 'desc';\n        $assets->TextSearch($request->input('search'));\n\n        switch ($request->input('sort')) {\n            case 'model':\n                $assets->OrderModels($order);\n                break;\n            case 'model_number':\n                $assets->OrderModelNumber($order);\n                break;\n            case 'category':\n                $assets->OrderCategory($order);\n                break;\n            case 'manufacturer':\n                $assets->OrderManufacturer($order);\n                break;\n            default:\n                $assets->orderBy('assets.created_at', $order);\n                break;\n        }\n\n\n        $total = $assets->count();\n        $assets = $assets->skip($offset)->take($limit)->get();\n        return (new AssetsTransformer)->transformRequestedAssets($assets, $total);\n    }\n}\n"], "filenames": ["app/Http/Controllers/Api/AssetsController.php"], "buggy_code_start_loc": [913], "buggy_code_end_loc": [914], "fixing_code_start_loc": [913], "fixing_code_end_loc": [914], "type": "CWE-79", "message": "snipe-it is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "other": {"cve": {"id": "CVE-2021-3938", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-13T09:15:07.080", "lastModified": "2021-11-16T19:49:24.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snipe-it is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}, {"lang": "es", "value": "snipe-it es vulnerable a una Neutralizaci\u00f3n Inapropiada de Entradas Durante la Generaci\u00f3n de la P\u00e1gina Web (\"Cross-site Scripting\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.1", "matchCriteriaId": "57AF9D3F-71A7-49BC-BEA8-BC6315B348FF"}]}]}], "references": [{"url": "https://github.com/snipe/snipe-it/commit/9ed1442bd124710f4178992cc4eca5236c7396b9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/198a0d67-9189-4170-809b-0f8aea43b063", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snipe/snipe-it/commit/9ed1442bd124710f4178992cc4eca5236c7396b9"}}