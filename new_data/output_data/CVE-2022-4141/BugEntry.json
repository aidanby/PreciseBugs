{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str(T_BE);\n\t    out_str(T_CTI);\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N') && cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\t// When getting a text character and the next character is a\n\t// multi-byte character, it could be a composing character.\n\t// However, don't wait for it to arrive. Also, do enable mapping,\n\t// because if it's put back with vungetc() it's too late to apply\n\t// mapping.\n\t--no_mapping;\n\twhile (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t&& (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t{\n\t    c = plain_vgetc();\n\t    if (!utf_iscomposing(c))\n\t    {\n\t\tvungetc(c);\t\t// it wasn't, put it back\n\t\tbreak;\n\t    }\n\t    else if (cap->ncharC1 == 0)\n\t\tcap->ncharC1 = c;\n\t    else\n\t\tcap->ncharC2 = c;\n\t}\n\t++no_mapping;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN (SHOWCMD_COLS + 1 + 30)\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    // clear the rest of an old message by outputting up to SHOWCMD_COLS\n    // spaces\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize_str(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tflags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n\tif (is_cmdkey)\n\t    cmd_result = do_cmdkey_command(cap->cmdchar, flags);\n\telse\n\t    cmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_locked(cap->oap))\n\treturn;\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(e_changelist_is_empty));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(e_at_start_of_changelist));\n\t    else\n\t\temsg(_(e_at_end_of_changelist));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += + resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize_str(ml_get_curline());\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t0, NULL) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t// If \"restart_edit\" is TRUE, the last but one command is repeated\n\t// instead of the last command (inserting text). This is used for\n\t// CTRL-O <.> in insert mode.\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    if (cmdwin_type != 0)\n\t    {\n\t\temsg(_(e_cmdline_window_already_open));\n\t\treturn;\n\t    }\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n\t    keep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = keep_registers ? '_' : NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "/* normal.c */\nvoid normal_cmd(oparg_T *oap, int toplevel);\nvoid check_visual_highlight(void);\nvoid end_visual_mode(void);\nvoid end_visual_mode_keep_button(void);\nvoid reset_VIsual_and_resel(void);\nvoid reset_VIsual(void);\nvoid restore_visual_mode(void);\nint find_ident_under_cursor(char_u **text, int find_type);\nint find_ident_at_pos(win_T *wp, linenr_T lnum, colnr_T startcol, char_u **text, int *textcol, int find_type);\nvoid prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5);\nvoid prep_redo_num2(int regname, long num1, int cmd1, int cmd2, long num2, int cmd3, int cmd4, int cmd5);\nvoid clearop(oparg_T *oap);\nvoid clearopbeep(oparg_T *oap);\nvoid may_clear_cmdline(void);\nvoid clear_showcmd(void);\nint add_to_showcmd(int c);\nvoid add_to_showcmd_c(int c);\nvoid push_showcmd(void);\nvoid pop_showcmd(void);\nvoid do_check_scrollbind(int check);\nvoid check_scrollbind(linenr_T topline_diff, long leftcol_diff);\nint find_decl(char_u *ptr, int len, int locally, int thisblock, int flags_arg);\nvoid nv_scroll_line(cmdarg_T *cap);\nvoid scroll_redraw(int up, long count);\nvoid handle_tabmenu(void);\nvoid do_nv_ident(int c1, int c2);\nint get_visual_text(cmdarg_T *cap, char_u **pp, int *lenp);\nvoid start_selection(void);\nvoid may_start_select(int c);\nint unadjust_for_sel(void);\nvoid set_cursor_for_append_to_line(void);\n/* vim: set ft=c : */\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements \n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void win_fix_scroll(int resize);\nstatic void win_fix_cursor(int normal);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// When non-zero closing a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int close_disallowed = 0;\n\n/*\n * Disallow changing the window layout (split window, close window, move\n * window).  Resizing is still allowed.\n * Used for autocommands that temporarily use another window and need to\n * make sure the previously selected window is still there.\n * Must be matched with exactly one call to window_layout_unlock()!\n */\n    static void\nwindow_layout_lock(void)\n{\n    ++split_disallowed;\n    ++close_disallowed;\n}\n\n    static void\nwindow_layout_unlock(void)\n{\n    --split_disallowed;\n    --close_disallowed;\n}\n\n/*\n * When the window layout cannot be changed give an error and return TRUE.\n * \"cmd\" indicates the action being performed and is used to pick the relevant\n * error message.\n */\n    int\nwindow_layout_locked(enum CMD_index cmd)\n{\n    if (split_disallowed > 0 || close_disallowed > 0)\n    {\n\tif (close_disallowed == 0 && cmd == CMD_tabnew)\n\t    emsg(_(e_cannot_split_window_when_closing_buffer));\n\telse\n\t    emsg(_(e_not_allowed_to_change_window_layout_in_this_autocmd));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    // In cmdwin, the alternative buffer should be used.\n    return is_in_cmdwin() && prevwin != NULL ? prevwin : curwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\nnewwindow:\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same width and/or height\n    case '=':\n\t\t{\n\t\t    int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_equal(NULL, FALSE,\n\t\t\t   mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');\n\t\t}\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\t(void)add_to_showcmd(xchar);\n\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, UPD_NOT_VALID);\n    redraw_win_later(oldwin, UPD_NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n    else if (*p_spk != 'c' && wp != aucmd_win)\n\twin_fix_scroll(FALSE);\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    if (*p_spk != 'c')\n    {\n\tnewp->w_botline = oldp->w_botline;\n\tnewp->w_prev_height = oldp->w_height - WINBAR_HEIGHT(oldp);\n\tnewp->w_prev_winrow = oldp->w_winrow + 2 * WINBAR_HEIGHT(oldp);\n    }\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(UPD_NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n    if (*p_spk != 'c' && next_curwin != aucmd_win)\n\twin_fix_scroll(TRUE);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_width(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixwidth' set keep the window width if possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minwidth(fr, NOWIN);\n\t\t    new_size = fr->fr_width;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wiw - p_wmw;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wiw)\n\t\t\t    new_size = p_wiw;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmw + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newwidth = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    if (next_curwin_size < 0)\n\t\t\tnext_curwin_size = 0;\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_height(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minheight(fr, NOWIN);\n\t\t    new_size = fr->fr_height;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wh - p_wmh;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wh)\n\t\t\t    new_size = p_wh;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmh + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newheight = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t    win_close_othertab(win, free_buf, prev_curtab);\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n    if (window_layout_locked(CMD_close))\n\treturn FAIL;\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\t// Don't trigger autocmds with a NULL buffer.\n\tblock_autocmds();\n\twin_close_othertab(win, FALSE, prev_curtab);\n\tunblock_autocmds();\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n\n    /*\n     * If last window has a status line now and we don't want one, remove the\n     * status line.  Do this before win_equal(), because it may change the\n     * height of a window\n     */\n    last_status(FALSE);\n\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n    {\n\twin_comp_pos();\n\tif (*p_spk != 'c')\n\t    win_fix_scroll(FALSE);\n    }\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(UPD_NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Make a snapshot of all the window scroll positions and sizes of the current\n * tab page.\n */\n    void\nsnapshot_windows_scroll_size(void)\n{\n    win_T *wp;\n    FOR_ALL_WINDOWS(wp)\n    {\n\twp->w_last_topline = wp->w_topline;\n\twp->w_last_leftcol = wp->w_leftcol;\n\twp->w_last_skipcol = wp->w_skipcol;\n\twp->w_last_width = wp->w_width;\n\twp->w_last_height = wp->w_height;\n    }\n}\n\nstatic int did_initial_scroll_size_snapshot = FALSE;\n\n    void\nmay_make_initial_scroll_size_snapshot(void)\n{\n    if (!did_initial_scroll_size_snapshot)\n    {\n\tdid_initial_scroll_size_snapshot = TRUE;\n\tsnapshot_windows_scroll_size();\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Create a dictionary with information about size and scroll changes in a\n * window.\n * Returns the dictionary with refcount set to one.\n * Returns NULL when out of memory.\n */\n    static dict_T *\nmake_win_info_dict(\n\tint width,\n\tint height,\n\tint topline,\n\tint leftcol,\n\tint skipcol)\n{\n    dict_T *d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n    d->dv_refcount = 1;\n\n    // not actually looping, for breaking out on error\n    while (1)\n    {\n\ttypval_T tv;\n\ttv.v_lock = 0;\n\ttv.v_type = VAR_NUMBER;\n\n\ttv.vval.v_number = width;\n\tif (dict_add_tv(d, \"width\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = height;\n\tif (dict_add_tv(d, \"height\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = topline;\n\tif (dict_add_tv(d, \"topline\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = leftcol;\n\tif (dict_add_tv(d, \"leftcol\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = skipcol;\n\tif (dict_add_tv(d, \"skipcol\", &tv) == FAIL)\n\t    break;\n\treturn d;\n    }\n    dict_unref(d);\n    return NULL;\n}\n#endif\n\n// Return values of check_window_scroll_resize():\n#define CWSR_SCROLLED\t1  // at least one window scrolled\n#define CWSR_RESIZED\t2  // at least one window size changed\n\n/*\n * This function is used for three purposes:\n * 1. Goes over all windows in the current tab page and returns:\n *\t0\t\t\t\tno scrolling and no size changes found\n *\tCWSR_SCROLLED\t\t\tat least one window scrolled\n *\tCWSR_RESIZED\t\t\tat least one window changed size\n *\tCWSR_SCROLLED + CWSR_RESIZED\tboth\n *    \"size_count\" is set to the nr of windows with size changes.\n *    \"first_scroll_win\" is set to the first window with any relevant changes.\n *    \"first_size_win\" is set to the first window with size changes.\n *\n * 2. When the first three arguments are NULL and \"winlist\" is not NULL,\n *    \"winlist\" is set to the list of window IDs with size changes.\n *\n * 3. When the first three arguments are NULL and \"v_event\" is not NULL,\n *    information about changed windows is added to \"v_event\".\n */\n    static int\ncheck_window_scroll_resize(\n\tint\t*size_count,\n\twin_T\t**first_scroll_win,\n\twin_T\t**first_size_win,\n\tlist_T\t*winlist UNUSED,\n\tdict_T\t*v_event UNUSED)\n{\n    int result = 0;\n#ifdef FEAT_EVAL\n    int listidx = 0;\n    int tot_width = 0;\n    int tot_height = 0;\n    int tot_topline = 0;\n    int tot_leftcol = 0;\n    int tot_skipcol = 0;\n#endif\n\n    win_T *wp;\n    FOR_ALL_WINDOWS(wp)\n    {\n\tint size_changed = wp->w_last_width != wp->w_width\n\t\t\t\t\t  || wp->w_last_height != wp->w_height;\n\tif (size_changed)\n\t{\n\t    result |= CWSR_RESIZED;\n#ifdef FEAT_EVAL\n\t    if (winlist != NULL)\n\t    {\n\t\t// Add this window to the list of changed windows.\n\t\ttypval_T tv;\n\t\ttv.v_lock = 0;\n\t\ttv.v_type = VAR_NUMBER;\n\t\ttv.vval.v_number = wp->w_id;\n\t\tlist_set_item(winlist, listidx++, &tv);\n\t    }\n\t    else\n#endif\n\t\tif (size_count != NULL)\n\t    {\n\t\t++*size_count;\n\t\tif (*first_size_win == NULL)\n\t\t    *first_size_win = wp;\n\t\t// For WinScrolled the first window with a size change is used\n\t\t// even when it didn't scroll.\n\t\tif (*first_scroll_win == NULL)\n\t\t    *first_scroll_win = wp;\n\t    }\n\t}\n\n\tint scroll_changed = wp->w_last_topline != wp->w_topline\n\t\t\t\t|| wp->w_last_leftcol != wp->w_leftcol\n\t\t\t\t|| wp->w_last_skipcol != wp->w_skipcol;\n\tif (scroll_changed)\n\t{\n\t    result |= CWSR_SCROLLED;\n\t    if (first_scroll_win != NULL && *first_scroll_win == NULL)\n\t\t*first_scroll_win = wp;\n\t}\n\n#ifdef FEAT_EVAL\n\tif ((size_changed || scroll_changed) && v_event != NULL)\n\t{\n\t    // Add info about this window to the v:event dictionary.\n\t    int width = wp->w_width - wp->w_last_width;\n\t    int height = wp->w_height - wp->w_last_height;\n\t    int topline = wp->w_topline - wp->w_last_topline;\n\t    int leftcol = wp->w_leftcol - wp->w_last_leftcol;\n\t    int skipcol = wp->w_skipcol - wp->w_last_skipcol;\n\t    dict_T *d = make_win_info_dict(width, height,\n\t\t\t\t\t\t    topline, leftcol, skipcol);\n\t    if (d == NULL)\n\t\tbreak;\n\t    char winid[NUMBUFLEN];\n\t    vim_snprintf(winid, sizeof(winid), \"%d\", wp->w_id);\n\t    if (dict_add_dict(v_event, winid, d) == FAIL)\n\t    {\n\t\tdict_unref(d);\n\t\tbreak;\n\t    }\n\t    --d->dv_refcount;\n\n\t    tot_width += abs(width);\n\t    tot_height += abs(height);\n\t    tot_topline += abs(topline);\n\t    tot_leftcol += abs(leftcol);\n\t    tot_skipcol += abs(skipcol);\n\t}\n#endif\n    }\n\n#ifdef FEAT_EVAL\n    if (v_event != NULL)\n    {\n\tdict_T *alldict = make_win_info_dict(tot_width, tot_height,\n\t\t\t\t\ttot_topline, tot_leftcol, tot_skipcol);\n\tif (alldict != NULL)\n\t{\n\t    if (dict_add_dict(v_event, \"all\", alldict) == FAIL)\n\t\tdict_unref(alldict);\n\t    else\n\t\t--alldict->dv_refcount;\n\t}\n    }\n#endif\n\n    return result;\n}\n\n/*\n * Trigger WinScrolled and/or WinResized if any window in the current tab page\n * scrolled or changed size.\n */\n    void\nmay_trigger_win_scrolled_resized(void)\n{\n    static int\t    recursive = FALSE;\n    int\t\t    do_resize = has_winresized();\n    int\t\t    do_scroll = has_winscrolled();\n\n    // Do not trigger WinScrolled or WinResized recursively.  Do not trigger\n    // before the initial snapshot of the w_last_ values was made.\n    if (recursive\n\t    || !(do_scroll || do_resize)\n\t    || !did_initial_scroll_size_snapshot)\n\treturn;\n\n    int size_count = 0;\n    win_T *first_scroll_win = NULL, *first_size_win = NULL;\n    int cwsr = check_window_scroll_resize(&size_count,\n\t\t\t\t\t   &first_scroll_win, &first_size_win,\n\t\t\t\t\t   NULL, NULL);\n    int trigger_resize = do_resize && size_count > 0;\n    int trigger_scroll = do_scroll && cwsr != 0;\n    if (!trigger_resize && !trigger_scroll)\n\treturn;  // no relevant changes\n#ifdef FEAT_EVAL\n    list_T *windows_list = NULL;\n    if (trigger_resize)\n    {\n\t// Create the list for v:event.windows before making the snapshot.\n\twindows_list = list_alloc_with_items(size_count);\n\t(void)check_window_scroll_resize(NULL, NULL, NULL, windows_list, NULL);\n    }\n\n    dict_T *scroll_dict = NULL;\n    if (trigger_scroll)\n    {\n\t// Create the dict with entries for v:event before making the snapshot.\n\tscroll_dict = dict_alloc();\n\tif (scroll_dict != NULL)\n\t{\n\t    scroll_dict->dv_refcount = 1;\n\t    (void)check_window_scroll_resize(NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t\t\t  scroll_dict);\n\t}\n    }\n#endif\n\n    // WinScrolled/WinResized are triggered only once, even when multiple\n    // windows scrolled or changed size.  Store the current values before\n    // triggering the event, if a scroll or resize happens as a side effect\n    // then WinScrolled/WinResized is triggered for that later.\n    snapshot_windows_scroll_size();\n\n    // \"curwin\" may be different from the actual current window, make\n    // sure it can be restored.\n    window_layout_lock();\n    recursive = TRUE;\n\n    // If both are to be triggered do WinResized first.\n    if (trigger_resize)\n    {\n#ifdef FEAT_EVAL\n\tsave_v_event_T  save_v_event;\n\tdict_T\t\t*v_event = get_v_event(&save_v_event);\n\n\tif (dict_add_list(v_event, \"windows\", windows_list) == OK)\n\t{\n\t    dict_set_items_ro(v_event);\n#endif\n\t    char_u winid[NUMBUFLEN];\n\t    vim_snprintf((char *)winid, sizeof(winid), \"%d\",\n\t\t\t\t\t\t\t first_size_win->w_id);\n\t    apply_autocmds(EVENT_WINRESIZED, winid, winid, FALSE,\n\t\t\t\t\t\t     first_size_win->w_buffer);\n#ifdef FEAT_EVAL\n\t}\n\trestore_v_event(v_event, &save_v_event);\n#endif\n    }\n\n    if (trigger_scroll\n#ifdef FEAT_EVAL\n\t    && scroll_dict != NULL\n#endif\n\t    )\n    {\n#ifdef FEAT_EVAL\n\tsave_v_event_T  save_v_event;\n\tdict_T\t\t*v_event = get_v_event(&save_v_event);\n\n\t// Move the entries from scroll_dict to v_event.\n\tdict_extend(v_event, scroll_dict, (char_u *)\"move\", NULL);\n\tdict_set_items_ro(v_event);\n\tdict_unref(scroll_dict);\n#endif\n\tchar_u winid[NUMBUFLEN];\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\",\n\t\t\t\t\t\t       first_scroll_win->w_id);\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE,\n\t\t\t\t\t\t   first_scroll_win->w_buffer);\n#ifdef FEAT_EVAL\n\trestore_v_event(v_event, &save_v_event);\n#endif\n    }\n\n    recursive = FALSE;\n    window_layout_unlock();\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tint\th = tabline_height();\n\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n\tredraw_tabline = TRUE;\n\tif (h != tabline_height())\n\t    shell_new_rows();\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp == curwin)\t\t// don't close current window\n\t    continue;\n\n\t// Check if it's allowed to abandon this window\n\tr = can_abandon(wp->w_buffer, forceit);\n\tif (!win_valid(wp))\t\t// autocommands messed wp up\n\t{\n\t    nextwp = firstwin;\n\t    continue;\n\t}\n\tif (!r)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (message && (p_confirm\n\t\t\t || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(wp->w_buffer, FALSE);\n\t\tif (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t{\n\t\t    nextwp = firstwin;\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (bufIsChanged(wp->w_buffer))\n#endif\n\t\tcontinue;\n\t}\n\twin_close(wp, !buf_hide(wp->w_buffer) && !bufIsChanged(wp->w_buffer));\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Store the relevant window pointers for tab page \"tp\".  To be used before\n * use_tabpage().\n */\n    void\nunuse_tabpage(tabpage_T *tp)\n{\n    tp->tp_topframe = topframe;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_curwin = curwin;\n}\n\n/*\n * Set the relevant pointers to use tab page \"tp\".  May want to call\n * unuse_tabpage() first.\n */\n    void\nuse_tabpage(tabpage_T *tp)\n{\n    curtab = tp;\n    topframe = curtab->tp_topframe;\n    firstwin = curtab->tp_firstwin;\n    lastwin = curtab->tp_lastwin;\n    curwin = curtab->tp_curwin;\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    curtab = first_tabpage;\n    unuse_tabpage(first_tabpage);\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    firstwin->w_prev_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n    if (window_layout_locked(CMD_tabnew))\n\treturn FAIL;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\tfirstwin->w_prev_winrow = firstwin->w_winrow;\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(UPD_NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n\n    reset_dragwin();\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    use_tabpage(tp);\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // Use the stored value of p_ch, so that it can be different for each tab\n    // page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if (row < cmdline_row && cmdline_row <= Rows - p_ch)\n\tclear_cmdline = TRUE;\n\n    // If there was a click in a window, it won't be usable for a following\n    // drag.\n    reset_dragwin();\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    skip_win_fix_scroll = TRUE;\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n    skip_win_fix_scroll = FALSE;\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    if (*p_spk == 'c')\n\tupdate_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    if (*p_spk == 'c')\t\t// assume cursor position needs updating\n\tchanged_line_abv_curs();\n    else\n\twin_fix_cursor(TRUE);\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(UPD_VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after, int hidden)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_next_match_id = 1000;  // up to 1000 can be picked by the user\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    // the timer may have been cleared, making the pointer invalid\n    if (timer_valid(win->w_popup_timer))\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n    if (*p_spk != 'c' && !skip_win_fix_scroll)\n\twin_fix_scroll(TRUE);\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, UPD_NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    if (*p_spk != 'c')\n\twin_fix_scroll(TRUE);\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line height\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    --room;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = MAX(Rows - cmdline_row, 1);\n    curtab->tp_ch_used = p_ch;\n\n    if (*p_spk != 'c')\n\twin_fix_scroll(TRUE);\n\n    redraw_all_later(UPD_SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Handle scroll position for 'splitkeep'.  Replaces scroll_to_fraction()\n * call from win_new_height().  Instead we iterate over all windows in a\n * tabpage and calculate the new scroll position.\n * TODO: Ensure this also works with wrapped lines.\n * Requires topline to be able to be set to a bufferline with some\n * offset(row-wise scrolling/smoothscroll).\n */\n    static void\nwin_fix_scroll(int resize)\n{\n    int\t\tdiff;\n    win_T\t*wp;\n    linenr_T\tlnum;\n\n    skip_update_topline = TRUE;\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Skip when window height has not changed.\n\tif (wp->w_height != wp->w_prev_height)\n\t{\n\t    // If window has moved update botline to keep the same screenlines.\n\t    if (*p_spk == 's' && wp->w_winrow != wp->w_prev_winrow\n\t\t      && wp->w_botline - 1 <= wp->w_buffer->b_ml.ml_line_count)\n\t    {\n\t\tlnum = wp->w_cursor.lnum;\n\t\tdiff = (wp->w_winrow - wp->w_prev_winrow)\n\t\t     + (wp->w_height - wp->w_prev_height);\n\t\twp->w_cursor.lnum = wp->w_botline - 1;\n\t\t//  Add difference in height and row to botline.\n\t\tif (diff > 0)\n\t\t    cursor_down_inner(wp, diff);\n\t\telse\n\t\t    cursor_up_inner(wp, -diff);\n\t\t// Bring the new cursor position to the bottom of the screen.\n\t\twp->w_fraction = FRACTION_MULT;\n\t\tscroll_to_fraction(wp, wp->w_prev_height);\n\t\twp->w_cursor.lnum = lnum;\n\t    }\n\t    else if (wp == curwin)\n\t\twp->w_valid &= ~VALID_CROW;\n\t    invalidate_botline_win(wp);\n\t    validate_botline_win(wp);\n\t}\n\twp->w_prev_height = wp->w_height;\n\twp->w_prev_winrow = wp->w_winrow;\n    }\n    skip_update_topline = FALSE;\n    // Ensure cursor is valid when not in normal mode or when resized.\n    if (!(get_real_state() & (MODE_NORMAL|MODE_CMDLINE|MODE_TERMINAL)))\n\twin_fix_cursor(FALSE);\n    else if (resize)\n\twin_fix_cursor(TRUE);\n}\n\n/*\n * Make sure the cursor position is valid for 'splitkeep'.\n * If it is not, put the cursor position in the jumplist and move it.\n * If we are not in normal mode, scroll to make valid instead.\n */\n    static void\nwin_fix_cursor(int normal)\n{\n    long\tso = get_scrolloff_value();\n    win_T\t*wp = curwin;\n    linenr_T\tnlnum = 0;\n    linenr_T\tlnum = wp->w_cursor.lnum;\n    linenr_T\tbot;\n    linenr_T\ttop;\n\n    if (wp->w_buffer->b_ml.ml_line_count < wp->w_height)\n\treturn;\n    if (skip_win_fix_cursor)\n\treturn;\n\n    // Determine valid cursor range.\n    so = MIN(wp->w_height / 2, so);\n    wp->w_cursor.lnum = wp->w_topline;\n    top = cursor_down_inner(wp, so);\n    wp->w_cursor.lnum = wp->w_botline - 1;\n    bot = cursor_up_inner(wp, so);\n    wp->w_cursor.lnum = lnum;\n    // Check if cursor position is above or below valid cursor range.\n    if (lnum > bot && (wp->w_botline - wp->w_buffer->b_ml.ml_line_count) != 1)\n\tnlnum = bot;\n    else if (lnum < top && wp->w_topline != 1)\n\tnlnum = (so == wp->w_height / 2) ? bot : top;\n\n    if (nlnum)  // Cursor is invalid for current scroll position.\n    {\n\tif (normal)  // Save to jumplist and set cursor to avoid scrolling.\n\t{\n\t    setmark('\\'');\n\t    wp->w_cursor.lnum = nlnum;\n\t}\n\telse  // Scroll instead when not in normal mode.\n\t{\n\t    wp->w_fraction = (nlnum == bot) ? FRACTION_MULT : 0;\n\t    scroll_to_fraction(wp, wp->w_prev_height);\n\t    validate_botline_win(curwin);\n\t}\n    }\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin && *p_spk == 'c')\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n    win_comp_scroll(wp);\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting && *p_spk == 'c')\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    redraw_win_later(wp, UPD_SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    // Should we give an error if width < 0?\n    wp->w_width = width < 0 ? 0 : width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tskip_update_topline = (*p_spk != 'c');\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n\tskip_update_topline = FALSE;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * Command_height: called whenever p_ch has been changed.\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // If the space for the command line is already more than 'cmdheight' there\n    // is nothing to do (window size must have decreased).\n    if (p_ch > old_p_ch && cmdline_row <= Rows - p_ch)\n\treturn;\n\n    // Update cmdline_row to what it should be: just below the last window.\n    cmdline_row = topframe->fr_height + tabline_height();\n\n    // If cmdline_row is smaller than what it is supposed to be for 'cmdheight'\n    // then set old_p_ch to what it would be, so that the windows get resized\n    // properly for the new value.\n    if (cmdline_row < Rows - p_ch)\n\told_p_ch = Rows - cmdline_row;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(UPD_SOME_VALID);\n\t}\n\t// Set prev_height when difference is due to 'laststatus'.\n\tif (abs(wp->w_height - wp->w_prev_height) == 1)\n\t    wp->w_prev_height = wp->w_height;\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Implementation of check_lnums() and check_lnums_nested().\n */\n    static void\ncheck_lnums_both(int do_curwin, int nested)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    int need_adjust;\n\n\t    if (!nested)\n\t    {\n\t\t// save the original cursor position and topline\n\t\twp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t\twp->w_save_cursor.w_topline_save = wp->w_topline;\n\t    }\n\n\t    need_adjust = wp->w_cursor.lnum > curbuf->b_ml.ml_line_count;\n\t    if (need_adjust)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (need_adjust || !nested)\n\t\t// save the (corrected) cursor position\n\t\twp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\n\t    need_adjust = wp->w_topline > curbuf->b_ml.ml_line_count;\n\t    if (need_adjust)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\t    if (need_adjust || !nested)\n\t\t// save the (corrected) topline\n\t\twp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    check_lnums_both(do_curwin, FALSE);\n}\n\n/*\n * Like check_lnums() but for when check_lnums() was already called.\n */\n    void\ncheck_lnums_nested(int do_curwin)\n{\n    check_lnums_both(do_curwin, TRUE);\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it and it was\n\t    // set.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor)\n\t\t\t\t  && wp->w_save_cursor.w_cursor_save.lnum != 0)\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline\n\t\t\t\t      && wp->w_save_cursor.w_topline_save != 0)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(UPD_NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tif (oap != NULL)\n\t    clearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * If text is locked, \"curbuf_lock\" or \"allbuf_lock\" is set:\n * Give an error message, possibly beep and return TRUE.\n * \"oap\" may be NULL.\n */\n    int\ncheck_text_or_curbuf_locked(oparg_T *oap)\n{\n    if (check_text_locked(oap))\n\treturn TRUE;\n    if (curbuf_locked())\n    {\n\tif (oap != NULL)\n\t    clearop(oap);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str(T_BE);\n\t    out_str(T_CTI);\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N') && cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\t// When getting a text character and the next character is a\n\t// multi-byte character, it could be a composing character.\n\t// However, don't wait for it to arrive. Also, do enable mapping,\n\t// because if it's put back with vungetc() it's too late to apply\n\t// mapping.\n\t--no_mapping;\n\twhile (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t&& (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t{\n\t    c = plain_vgetc();\n\t    if (!utf_iscomposing(c))\n\t    {\n\t\tvungetc(c);\t\t// it wasn't, put it back\n\t\tbreak;\n\t    }\n\t    else if (cap->ncharC1 == 0)\n\t\tcap->ncharC1 = c;\n\t    else\n\t\tcap->ncharC2 = c;\n\t}\n\t++no_mapping;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN (SHOWCMD_COLS + 1 + 30)\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    // clear the rest of an old message by outputting up to SHOWCMD_COLS\n    // spaces\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize_str(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize_str(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tflags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n\tif (is_cmdkey)\n\t    cmd_result = do_cmdkey_command(cap->cmdchar, flags);\n\telse\n\t    cmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(e_changelist_is_empty));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(e_at_start_of_changelist));\n\t    else\n\t\temsg(_(e_at_end_of_changelist));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += + resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize_str(ml_get_curline());\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t0, NULL) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t// If \"restart_edit\" is TRUE, the last but one command is repeated\n\t// instead of the last command (inserting text). This is used for\n\t// CTRL-O <.> in insert mode.\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    if (cmdwin_type != 0)\n\t    {\n\t\temsg(_(e_cmdline_window_already_open));\n\t\treturn;\n\t    }\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n\t    keep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = keep_registers ? '_' : NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "/* normal.c */\nint check_text_or_curbuf_locked(oparg_T *oap);\nvoid normal_cmd(oparg_T *oap, int toplevel);\nvoid check_visual_highlight(void);\nvoid end_visual_mode(void);\nvoid end_visual_mode_keep_button(void);\nvoid reset_VIsual_and_resel(void);\nvoid reset_VIsual(void);\nvoid restore_visual_mode(void);\nint find_ident_under_cursor(char_u **text, int find_type);\nint find_ident_at_pos(win_T *wp, linenr_T lnum, colnr_T startcol, char_u **text, int *textcol, int find_type);\nvoid prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5);\nvoid prep_redo_num2(int regname, long num1, int cmd1, int cmd2, long num2, int cmd3, int cmd4, int cmd5);\nvoid clearop(oparg_T *oap);\nvoid clearopbeep(oparg_T *oap);\nvoid may_clear_cmdline(void);\nvoid clear_showcmd(void);\nint add_to_showcmd(int c);\nvoid add_to_showcmd_c(int c);\nvoid push_showcmd(void);\nvoid pop_showcmd(void);\nvoid do_check_scrollbind(int check);\nvoid check_scrollbind(linenr_T topline_diff, long leftcol_diff);\nint find_decl(char_u *ptr, int len, int locally, int thisblock, int flags_arg);\nvoid nv_scroll_line(cmdarg_T *cap);\nvoid scroll_redraw(int up, long count);\nvoid handle_tabmenu(void);\nvoid do_nv_ident(int c1, int c2);\nint get_visual_text(cmdarg_T *cap, char_u **pp, int *lenp);\nvoid start_selection(void);\nvoid may_start_select(int c);\nint unadjust_for_sel(void);\nvoid set_cursor_for_append_to_line(void);\n/* vim: set ft=c : */\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements \n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\u010f\u013d\u2018a\u010f\u013d\u2019a\u010f\u013d\u201ca', substitute('\u010f\u013d\u2018\u010f\u013d\u2019\u010f\u013d\u201c', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" This was editing another file from the expression.\nfunc Test_sub_expr_goto_other_file()\n  call writefile([''], 'Xfileone', 'D')\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd',\n\t\\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])\n\n  func g:SplitGotoFile()\n    exe \"sil! norm 0\\<C-W>gf\"\n    return ''\n  endfunc\n\n  $\n  s/\\%')/\\=g:SplitGotoFile()\n\n  delfunc g:SplitGotoFile\n  bwipe!\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void win_fix_scroll(int resize);\nstatic void win_fix_cursor(int normal);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// When non-zero closing a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int close_disallowed = 0;\n\n/*\n * Disallow changing the window layout (split window, close window, move\n * window).  Resizing is still allowed.\n * Used for autocommands that temporarily use another window and need to\n * make sure the previously selected window is still there.\n * Must be matched with exactly one call to window_layout_unlock()!\n */\n    static void\nwindow_layout_lock(void)\n{\n    ++split_disallowed;\n    ++close_disallowed;\n}\n\n    static void\nwindow_layout_unlock(void)\n{\n    --split_disallowed;\n    --close_disallowed;\n}\n\n/*\n * When the window layout cannot be changed give an error and return TRUE.\n * \"cmd\" indicates the action being performed and is used to pick the relevant\n * error message.\n */\n    int\nwindow_layout_locked(enum CMD_index cmd)\n{\n    if (split_disallowed > 0 || close_disallowed > 0)\n    {\n\tif (close_disallowed == 0 && cmd == CMD_tabnew)\n\t    emsg(_(e_cannot_split_window_when_closing_buffer));\n\telse\n\t    emsg(_(e_not_allowed_to_change_window_layout_in_this_autocmd));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    // In cmdwin, the alternative buffer should be used.\n    return is_in_cmdwin() && prevwin != NULL ? prevwin : curwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\nnewwindow:\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same width and/or height\n    case '=':\n\t\t{\n\t\t    int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_equal(NULL, FALSE,\n\t\t\t   mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');\n\t\t}\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\t\tif (check_text_or_curbuf_locked(NULL))\n\t\t    break;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\t(void)add_to_showcmd(xchar);\n\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, UPD_NOT_VALID);\n    redraw_win_later(oldwin, UPD_NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n    else if (*p_spk != 'c' && wp != aucmd_win)\n\twin_fix_scroll(FALSE);\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    if (*p_spk != 'c')\n    {\n\tnewp->w_botline = oldp->w_botline;\n\tnewp->w_prev_height = oldp->w_height - WINBAR_HEIGHT(oldp);\n\tnewp->w_prev_winrow = oldp->w_winrow + 2 * WINBAR_HEIGHT(oldp);\n    }\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(UPD_NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n    if (*p_spk != 'c' && next_curwin != aucmd_win)\n\twin_fix_scroll(TRUE);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_width(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixwidth' set keep the window width if possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minwidth(fr, NOWIN);\n\t\t    new_size = fr->fr_width;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wiw - p_wmw;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wiw)\n\t\t\t    new_size = p_wiw;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmw + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newwidth = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    if (next_curwin_size < 0)\n\t\t\tnext_curwin_size = 0;\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_height(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minheight(fr, NOWIN);\n\t\t    new_size = fr->fr_height;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wh - p_wmh;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wh)\n\t\t\t    new_size = p_wh;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmh + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newheight = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t    win_close_othertab(win, free_buf, prev_curtab);\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n    if (window_layout_locked(CMD_close))\n\treturn FAIL;\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\t// Don't trigger autocmds with a NULL buffer.\n\tblock_autocmds();\n\twin_close_othertab(win, FALSE, prev_curtab);\n\tunblock_autocmds();\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n\n    /*\n     * If last window has a status line now and we don't want one, remove the\n     * status line.  Do this before win_equal(), because it may change the\n     * height of a window\n     */\n    last_status(FALSE);\n\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n    {\n\twin_comp_pos();\n\tif (*p_spk != 'c')\n\t    win_fix_scroll(FALSE);\n    }\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(UPD_NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Make a snapshot of all the window scroll positions and sizes of the current\n * tab page.\n */\n    void\nsnapshot_windows_scroll_size(void)\n{\n    win_T *wp;\n    FOR_ALL_WINDOWS(wp)\n    {\n\twp->w_last_topline = wp->w_topline;\n\twp->w_last_leftcol = wp->w_leftcol;\n\twp->w_last_skipcol = wp->w_skipcol;\n\twp->w_last_width = wp->w_width;\n\twp->w_last_height = wp->w_height;\n    }\n}\n\nstatic int did_initial_scroll_size_snapshot = FALSE;\n\n    void\nmay_make_initial_scroll_size_snapshot(void)\n{\n    if (!did_initial_scroll_size_snapshot)\n    {\n\tdid_initial_scroll_size_snapshot = TRUE;\n\tsnapshot_windows_scroll_size();\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Create a dictionary with information about size and scroll changes in a\n * window.\n * Returns the dictionary with refcount set to one.\n * Returns NULL when out of memory.\n */\n    static dict_T *\nmake_win_info_dict(\n\tint width,\n\tint height,\n\tint topline,\n\tint leftcol,\n\tint skipcol)\n{\n    dict_T *d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n    d->dv_refcount = 1;\n\n    // not actually looping, for breaking out on error\n    while (1)\n    {\n\ttypval_T tv;\n\ttv.v_lock = 0;\n\ttv.v_type = VAR_NUMBER;\n\n\ttv.vval.v_number = width;\n\tif (dict_add_tv(d, \"width\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = height;\n\tif (dict_add_tv(d, \"height\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = topline;\n\tif (dict_add_tv(d, \"topline\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = leftcol;\n\tif (dict_add_tv(d, \"leftcol\", &tv) == FAIL)\n\t    break;\n\ttv.vval.v_number = skipcol;\n\tif (dict_add_tv(d, \"skipcol\", &tv) == FAIL)\n\t    break;\n\treturn d;\n    }\n    dict_unref(d);\n    return NULL;\n}\n#endif\n\n// Return values of check_window_scroll_resize():\n#define CWSR_SCROLLED\t1  // at least one window scrolled\n#define CWSR_RESIZED\t2  // at least one window size changed\n\n/*\n * This function is used for three purposes:\n * 1. Goes over all windows in the current tab page and returns:\n *\t0\t\t\t\tno scrolling and no size changes found\n *\tCWSR_SCROLLED\t\t\tat least one window scrolled\n *\tCWSR_RESIZED\t\t\tat least one window changed size\n *\tCWSR_SCROLLED + CWSR_RESIZED\tboth\n *    \"size_count\" is set to the nr of windows with size changes.\n *    \"first_scroll_win\" is set to the first window with any relevant changes.\n *    \"first_size_win\" is set to the first window with size changes.\n *\n * 2. When the first three arguments are NULL and \"winlist\" is not NULL,\n *    \"winlist\" is set to the list of window IDs with size changes.\n *\n * 3. When the first three arguments are NULL and \"v_event\" is not NULL,\n *    information about changed windows is added to \"v_event\".\n */\n    static int\ncheck_window_scroll_resize(\n\tint\t*size_count,\n\twin_T\t**first_scroll_win,\n\twin_T\t**first_size_win,\n\tlist_T\t*winlist UNUSED,\n\tdict_T\t*v_event UNUSED)\n{\n    int result = 0;\n#ifdef FEAT_EVAL\n    int listidx = 0;\n    int tot_width = 0;\n    int tot_height = 0;\n    int tot_topline = 0;\n    int tot_leftcol = 0;\n    int tot_skipcol = 0;\n#endif\n\n    win_T *wp;\n    FOR_ALL_WINDOWS(wp)\n    {\n\tint size_changed = wp->w_last_width != wp->w_width\n\t\t\t\t\t  || wp->w_last_height != wp->w_height;\n\tif (size_changed)\n\t{\n\t    result |= CWSR_RESIZED;\n#ifdef FEAT_EVAL\n\t    if (winlist != NULL)\n\t    {\n\t\t// Add this window to the list of changed windows.\n\t\ttypval_T tv;\n\t\ttv.v_lock = 0;\n\t\ttv.v_type = VAR_NUMBER;\n\t\ttv.vval.v_number = wp->w_id;\n\t\tlist_set_item(winlist, listidx++, &tv);\n\t    }\n\t    else\n#endif\n\t\tif (size_count != NULL)\n\t    {\n\t\t++*size_count;\n\t\tif (*first_size_win == NULL)\n\t\t    *first_size_win = wp;\n\t\t// For WinScrolled the first window with a size change is used\n\t\t// even when it didn't scroll.\n\t\tif (*first_scroll_win == NULL)\n\t\t    *first_scroll_win = wp;\n\t    }\n\t}\n\n\tint scroll_changed = wp->w_last_topline != wp->w_topline\n\t\t\t\t|| wp->w_last_leftcol != wp->w_leftcol\n\t\t\t\t|| wp->w_last_skipcol != wp->w_skipcol;\n\tif (scroll_changed)\n\t{\n\t    result |= CWSR_SCROLLED;\n\t    if (first_scroll_win != NULL && *first_scroll_win == NULL)\n\t\t*first_scroll_win = wp;\n\t}\n\n#ifdef FEAT_EVAL\n\tif ((size_changed || scroll_changed) && v_event != NULL)\n\t{\n\t    // Add info about this window to the v:event dictionary.\n\t    int width = wp->w_width - wp->w_last_width;\n\t    int height = wp->w_height - wp->w_last_height;\n\t    int topline = wp->w_topline - wp->w_last_topline;\n\t    int leftcol = wp->w_leftcol - wp->w_last_leftcol;\n\t    int skipcol = wp->w_skipcol - wp->w_last_skipcol;\n\t    dict_T *d = make_win_info_dict(width, height,\n\t\t\t\t\t\t    topline, leftcol, skipcol);\n\t    if (d == NULL)\n\t\tbreak;\n\t    char winid[NUMBUFLEN];\n\t    vim_snprintf(winid, sizeof(winid), \"%d\", wp->w_id);\n\t    if (dict_add_dict(v_event, winid, d) == FAIL)\n\t    {\n\t\tdict_unref(d);\n\t\tbreak;\n\t    }\n\t    --d->dv_refcount;\n\n\t    tot_width += abs(width);\n\t    tot_height += abs(height);\n\t    tot_topline += abs(topline);\n\t    tot_leftcol += abs(leftcol);\n\t    tot_skipcol += abs(skipcol);\n\t}\n#endif\n    }\n\n#ifdef FEAT_EVAL\n    if (v_event != NULL)\n    {\n\tdict_T *alldict = make_win_info_dict(tot_width, tot_height,\n\t\t\t\t\ttot_topline, tot_leftcol, tot_skipcol);\n\tif (alldict != NULL)\n\t{\n\t    if (dict_add_dict(v_event, \"all\", alldict) == FAIL)\n\t\tdict_unref(alldict);\n\t    else\n\t\t--alldict->dv_refcount;\n\t}\n    }\n#endif\n\n    return result;\n}\n\n/*\n * Trigger WinScrolled and/or WinResized if any window in the current tab page\n * scrolled or changed size.\n */\n    void\nmay_trigger_win_scrolled_resized(void)\n{\n    static int\t    recursive = FALSE;\n    int\t\t    do_resize = has_winresized();\n    int\t\t    do_scroll = has_winscrolled();\n\n    // Do not trigger WinScrolled or WinResized recursively.  Do not trigger\n    // before the initial snapshot of the w_last_ values was made.\n    if (recursive\n\t    || !(do_scroll || do_resize)\n\t    || !did_initial_scroll_size_snapshot)\n\treturn;\n\n    int size_count = 0;\n    win_T *first_scroll_win = NULL, *first_size_win = NULL;\n    int cwsr = check_window_scroll_resize(&size_count,\n\t\t\t\t\t   &first_scroll_win, &first_size_win,\n\t\t\t\t\t   NULL, NULL);\n    int trigger_resize = do_resize && size_count > 0;\n    int trigger_scroll = do_scroll && cwsr != 0;\n    if (!trigger_resize && !trigger_scroll)\n\treturn;  // no relevant changes\n#ifdef FEAT_EVAL\n    list_T *windows_list = NULL;\n    if (trigger_resize)\n    {\n\t// Create the list for v:event.windows before making the snapshot.\n\twindows_list = list_alloc_with_items(size_count);\n\t(void)check_window_scroll_resize(NULL, NULL, NULL, windows_list, NULL);\n    }\n\n    dict_T *scroll_dict = NULL;\n    if (trigger_scroll)\n    {\n\t// Create the dict with entries for v:event before making the snapshot.\n\tscroll_dict = dict_alloc();\n\tif (scroll_dict != NULL)\n\t{\n\t    scroll_dict->dv_refcount = 1;\n\t    (void)check_window_scroll_resize(NULL, NULL, NULL, NULL,\n\t\t\t\t\t\t\t\t  scroll_dict);\n\t}\n    }\n#endif\n\n    // WinScrolled/WinResized are triggered only once, even when multiple\n    // windows scrolled or changed size.  Store the current values before\n    // triggering the event, if a scroll or resize happens as a side effect\n    // then WinScrolled/WinResized is triggered for that later.\n    snapshot_windows_scroll_size();\n\n    // \"curwin\" may be different from the actual current window, make\n    // sure it can be restored.\n    window_layout_lock();\n    recursive = TRUE;\n\n    // If both are to be triggered do WinResized first.\n    if (trigger_resize)\n    {\n#ifdef FEAT_EVAL\n\tsave_v_event_T  save_v_event;\n\tdict_T\t\t*v_event = get_v_event(&save_v_event);\n\n\tif (dict_add_list(v_event, \"windows\", windows_list) == OK)\n\t{\n\t    dict_set_items_ro(v_event);\n#endif\n\t    char_u winid[NUMBUFLEN];\n\t    vim_snprintf((char *)winid, sizeof(winid), \"%d\",\n\t\t\t\t\t\t\t first_size_win->w_id);\n\t    apply_autocmds(EVENT_WINRESIZED, winid, winid, FALSE,\n\t\t\t\t\t\t     first_size_win->w_buffer);\n#ifdef FEAT_EVAL\n\t}\n\trestore_v_event(v_event, &save_v_event);\n#endif\n    }\n\n    if (trigger_scroll\n#ifdef FEAT_EVAL\n\t    && scroll_dict != NULL\n#endif\n\t    )\n    {\n#ifdef FEAT_EVAL\n\tsave_v_event_T  save_v_event;\n\tdict_T\t\t*v_event = get_v_event(&save_v_event);\n\n\t// Move the entries from scroll_dict to v_event.\n\tdict_extend(v_event, scroll_dict, (char_u *)\"move\", NULL);\n\tdict_set_items_ro(v_event);\n\tdict_unref(scroll_dict);\n#endif\n\tchar_u winid[NUMBUFLEN];\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\",\n\t\t\t\t\t\t       first_scroll_win->w_id);\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE,\n\t\t\t\t\t\t   first_scroll_win->w_buffer);\n#ifdef FEAT_EVAL\n\trestore_v_event(v_event, &save_v_event);\n#endif\n    }\n\n    recursive = FALSE;\n    window_layout_unlock();\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tint\th = tabline_height();\n\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n\tredraw_tabline = TRUE;\n\tif (h != tabline_height())\n\t    shell_new_rows();\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp == curwin)\t\t// don't close current window\n\t    continue;\n\n\t// Check if it's allowed to abandon this window\n\tr = can_abandon(wp->w_buffer, forceit);\n\tif (!win_valid(wp))\t\t// autocommands messed wp up\n\t{\n\t    nextwp = firstwin;\n\t    continue;\n\t}\n\tif (!r)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (message && (p_confirm\n\t\t\t || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(wp->w_buffer, FALSE);\n\t\tif (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t{\n\t\t    nextwp = firstwin;\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (bufIsChanged(wp->w_buffer))\n#endif\n\t\tcontinue;\n\t}\n\twin_close(wp, !buf_hide(wp->w_buffer) && !bufIsChanged(wp->w_buffer));\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Store the relevant window pointers for tab page \"tp\".  To be used before\n * use_tabpage().\n */\n    void\nunuse_tabpage(tabpage_T *tp)\n{\n    tp->tp_topframe = topframe;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_curwin = curwin;\n}\n\n/*\n * Set the relevant pointers to use tab page \"tp\".  May want to call\n * unuse_tabpage() first.\n */\n    void\nuse_tabpage(tabpage_T *tp)\n{\n    curtab = tp;\n    topframe = curtab->tp_topframe;\n    firstwin = curtab->tp_firstwin;\n    lastwin = curtab->tp_lastwin;\n    curwin = curtab->tp_curwin;\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    curtab = first_tabpage;\n    unuse_tabpage(first_tabpage);\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    firstwin->w_prev_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n    if (window_layout_locked(CMD_tabnew))\n\treturn FAIL;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\tfirstwin->w_prev_winrow = firstwin->w_winrow;\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(UPD_NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n\n    reset_dragwin();\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    use_tabpage(tp);\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // Use the stored value of p_ch, so that it can be different for each tab\n    // page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if (row < cmdline_row && cmdline_row <= Rows - p_ch)\n\tclear_cmdline = TRUE;\n\n    // If there was a click in a window, it won't be usable for a following\n    // drag.\n    reset_dragwin();\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    skip_win_fix_scroll = TRUE;\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n    skip_win_fix_scroll = FALSE;\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    if (*p_spk == 'c')\n\tupdate_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    if (*p_spk == 'c')\t\t// assume cursor position needs updating\n\tchanged_line_abv_curs();\n    else\n\twin_fix_cursor(TRUE);\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(UPD_VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after, int hidden)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_next_match_id = 1000;  // up to 1000 can be picked by the user\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    // the timer may have been cleared, making the pointer invalid\n    if (timer_valid(win->w_popup_timer))\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n    if (*p_spk != 'c' && !skip_win_fix_scroll)\n\twin_fix_scroll(TRUE);\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, UPD_NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    if (*p_spk != 'c')\n\twin_fix_scroll(TRUE);\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line height\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    --room;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = MAX(Rows - cmdline_row, 1);\n    curtab->tp_ch_used = p_ch;\n\n    if (*p_spk != 'c')\n\twin_fix_scroll(TRUE);\n\n    redraw_all_later(UPD_SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(UPD_NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Handle scroll position for 'splitkeep'.  Replaces scroll_to_fraction()\n * call from win_new_height().  Instead we iterate over all windows in a\n * tabpage and calculate the new scroll position.\n * TODO: Ensure this also works with wrapped lines.\n * Requires topline to be able to be set to a bufferline with some\n * offset(row-wise scrolling/smoothscroll).\n */\n    static void\nwin_fix_scroll(int resize)\n{\n    int\t\tdiff;\n    win_T\t*wp;\n    linenr_T\tlnum;\n\n    skip_update_topline = TRUE;\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Skip when window height has not changed.\n\tif (wp->w_height != wp->w_prev_height)\n\t{\n\t    // If window has moved update botline to keep the same screenlines.\n\t    if (*p_spk == 's' && wp->w_winrow != wp->w_prev_winrow\n\t\t      && wp->w_botline - 1 <= wp->w_buffer->b_ml.ml_line_count)\n\t    {\n\t\tlnum = wp->w_cursor.lnum;\n\t\tdiff = (wp->w_winrow - wp->w_prev_winrow)\n\t\t     + (wp->w_height - wp->w_prev_height);\n\t\twp->w_cursor.lnum = wp->w_botline - 1;\n\t\t//  Add difference in height and row to botline.\n\t\tif (diff > 0)\n\t\t    cursor_down_inner(wp, diff);\n\t\telse\n\t\t    cursor_up_inner(wp, -diff);\n\t\t// Bring the new cursor position to the bottom of the screen.\n\t\twp->w_fraction = FRACTION_MULT;\n\t\tscroll_to_fraction(wp, wp->w_prev_height);\n\t\twp->w_cursor.lnum = lnum;\n\t    }\n\t    else if (wp == curwin)\n\t\twp->w_valid &= ~VALID_CROW;\n\t    invalidate_botline_win(wp);\n\t    validate_botline_win(wp);\n\t}\n\twp->w_prev_height = wp->w_height;\n\twp->w_prev_winrow = wp->w_winrow;\n    }\n    skip_update_topline = FALSE;\n    // Ensure cursor is valid when not in normal mode or when resized.\n    if (!(get_real_state() & (MODE_NORMAL|MODE_CMDLINE|MODE_TERMINAL)))\n\twin_fix_cursor(FALSE);\n    else if (resize)\n\twin_fix_cursor(TRUE);\n}\n\n/*\n * Make sure the cursor position is valid for 'splitkeep'.\n * If it is not, put the cursor position in the jumplist and move it.\n * If we are not in normal mode, scroll to make valid instead.\n */\n    static void\nwin_fix_cursor(int normal)\n{\n    long\tso = get_scrolloff_value();\n    win_T\t*wp = curwin;\n    linenr_T\tnlnum = 0;\n    linenr_T\tlnum = wp->w_cursor.lnum;\n    linenr_T\tbot;\n    linenr_T\ttop;\n\n    if (wp->w_buffer->b_ml.ml_line_count < wp->w_height)\n\treturn;\n    if (skip_win_fix_cursor)\n\treturn;\n\n    // Determine valid cursor range.\n    so = MIN(wp->w_height / 2, so);\n    wp->w_cursor.lnum = wp->w_topline;\n    top = cursor_down_inner(wp, so);\n    wp->w_cursor.lnum = wp->w_botline - 1;\n    bot = cursor_up_inner(wp, so);\n    wp->w_cursor.lnum = lnum;\n    // Check if cursor position is above or below valid cursor range.\n    if (lnum > bot && (wp->w_botline - wp->w_buffer->b_ml.ml_line_count) != 1)\n\tnlnum = bot;\n    else if (lnum < top && wp->w_topline != 1)\n\tnlnum = (so == wp->w_height / 2) ? bot : top;\n\n    if (nlnum)  // Cursor is invalid for current scroll position.\n    {\n\tif (normal)  // Save to jumplist and set cursor to avoid scrolling.\n\t{\n\t    setmark('\\'');\n\t    wp->w_cursor.lnum = nlnum;\n\t}\n\telse  // Scroll instead when not in normal mode.\n\t{\n\t    wp->w_fraction = (nlnum == bot) ? FRACTION_MULT : 0;\n\t    scroll_to_fraction(wp, wp->w_prev_height);\n\t    validate_botline_win(curwin);\n\t}\n    }\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin && *p_spk == 'c')\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n    win_comp_scroll(wp);\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting && *p_spk == 'c')\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    redraw_win_later(wp, UPD_SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    // Should we give an error if width < 0?\n    wp->w_width = width < 0 ? 0 : width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tskip_update_topline = (*p_spk != 'c');\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n\tskip_update_topline = FALSE;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * Command_height: called whenever p_ch has been changed.\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // If the space for the command line is already more than 'cmdheight' there\n    // is nothing to do (window size must have decreased).\n    if (p_ch > old_p_ch && cmdline_row <= Rows - p_ch)\n\treturn;\n\n    // Update cmdline_row to what it should be: just below the last window.\n    cmdline_row = topframe->fr_height + tabline_height();\n\n    // If cmdline_row is smaller than what it is supposed to be for 'cmdheight'\n    // then set old_p_ch to what it would be, so that the windows get resized\n    // properly for the new value.\n    if (cmdline_row < Rows - p_ch)\n\told_p_ch = Rows - cmdline_row;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(UPD_SOME_VALID);\n\t}\n\t// Set prev_height when difference is due to 'laststatus'.\n\tif (abs(wp->w_height - wp->w_prev_height) == 1)\n\t    wp->w_prev_height = wp->w_height;\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Implementation of check_lnums() and check_lnums_nested().\n */\n    static void\ncheck_lnums_both(int do_curwin, int nested)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    int need_adjust;\n\n\t    if (!nested)\n\t    {\n\t\t// save the original cursor position and topline\n\t\twp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t\twp->w_save_cursor.w_topline_save = wp->w_topline;\n\t    }\n\n\t    need_adjust = wp->w_cursor.lnum > curbuf->b_ml.ml_line_count;\n\t    if (need_adjust)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (need_adjust || !nested)\n\t\t// save the (corrected) cursor position\n\t\twp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\n\t    need_adjust = wp->w_topline > curbuf->b_ml.ml_line_count;\n\t    if (need_adjust)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\t    if (need_adjust || !nested)\n\t\t// save the (corrected) topline\n\t\twp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    check_lnums_both(do_curwin, FALSE);\n}\n\n/*\n * Like check_lnums() but for when check_lnums() was already called.\n */\n    void\ncheck_lnums_nested(int do_curwin)\n{\n    check_lnums_both(do_curwin, TRUE);\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it and it was\n\t    // set.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor)\n\t\t\t\t  && wp->w_save_cursor.w_cursor_save.lnum != 0)\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline\n\t\t\t\t      && wp->w_save_cursor.w_topline_save != 0)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(UPD_NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/normal.c", "src/proto/normal.pro", "src/testdir/test_substitute.vim", "src/version.c", "src/window.c"], "buggy_code_start_loc": [191, 1, 883, 697, 569], "buggy_code_end_loc": [4036, 1, 1098, 697, 889], "fixing_code_start_loc": [191, 2, 883, 698, 570], "fixing_code_end_loc": [4051, 3, 1118, 700, 891], "type": "CWE-122", "message": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.", "other": {"cve": {"id": "CVE-2022-4141", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-25T14:15:10.737", "lastModified": "2023-05-03T12:16:39.710", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndIncluding": "9.0.0946", "matchCriteriaId": "C961E249-248F-46C0-A6BA-E214B29F4BA7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/20ece512-c600-45ac-8a84-d0931e05541f", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AZ3JMSUCR6Y7626RDWQ2HNSUFIQOJ33G/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/V6ZNKVN4GICORTVFKVCM4MSOXCYWNHUC/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5"}}