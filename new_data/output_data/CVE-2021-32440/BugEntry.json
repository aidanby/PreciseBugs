{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n// Rewrite the good dependencies when an OD AU is extracted from the file\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n\n\n// Update the dependencies when an OD AU is inserted in the file\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp)\n{\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *mpod;\n\tGF_Err e;\n\tGF_ODCom *com;\n\tGF_ODCodec *ODencode;\n\tGF_ODCodec *ODdecode;\n\tu32 i, j;\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\n\t*od_samp = NULL;\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\t//First find the references, and create them if none\n\ttref = mdia->mediaTrack->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&mdia->mediaTrack->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)mdia->mediaTrack, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//then find the OD reference, and create it if none\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\tif (!mpod) {\n\t\tmpod = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!mpod) return GF_OUT_OF_MEM;\n\t\tmpod->reference_type = GF_ISOM_BOX_TYPE_MPOD;\n\t}\n\n\t//OK, create our codecs\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) return GF_OUT_OF_MEM;\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//check our commands\n\t\tswitch (com->tag) {\n\t\t//Rewrite OD Update\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\t//duplicate our command\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\t//both OD and IODs are accepted\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\te = GF_ODF_INVALID_DESCRIPTOR;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\t//get the esd\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&od);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tif (desc->tag == GF_ODF_OD_TAG) {\n\t\t\t\t\tisom_od = (GF_IsomObjectDescriptor *) gf_malloc(sizeof(GF_IsomObjectDescriptor));\n\t\t\t\t\tif (!isom_od) return GF_OUT_OF_MEM;\n\t\t\t\t\tisom_od->tag = GF_ODF_ISOM_OD_TAG;\n\t\t\t\t} else {\n\t\t\t\t\tisom_od = (GF_IsomObjectDescriptor *) gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\t\t\t\t\tif (!isom_od) return GF_OUT_OF_MEM;\n\t\t\t\t\tisom_od->tag = GF_ODF_ISOM_IOD_TAG;\n\t\t\t\t\t//copy PL\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag = ((GF_InitialObjectDescriptor *)od)->inlineProfileFlag;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = ((GF_InitialObjectDescriptor *)od)->IPMPToolList;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = NULL;\n\t\t\t\t}\n\t\t\t\t//in OD stream only ref desc are accepted\n\t\t\t\tisom_od->ES_ID_RefDescriptors = gf_list_new();\n\t\t\t\tisom_od->ES_ID_IncDescriptors = NULL;\n\n\t\t\t\t//TO DO: check that a given sampleDescription exists\n\t\t\t\tisom_od->extensionDescriptors = od->extensionDescriptors;\n\t\t\t\tod->extensionDescriptors = NULL;\n\t\t\t\tisom_od->IPMP_Descriptors = od->IPMP_Descriptors;\n\t\t\t\tod->IPMP_Descriptors = NULL;\n\t\t\t\tisom_od->OCIDescriptors = od->OCIDescriptors;\n\t\t\t\tod->OCIDescriptors = NULL;\n\t\t\t\tisom_od->URLString = od->URLString;\n\t\t\t\tod->URLString = NULL;\n\t\t\t\tisom_od->objectDescriptorID = od->objectDescriptorID;\n\n\t\t\t\tj=0;\n\t\t\t\twhile ((esd = (GF_ESD*)gf_list_enum(od->ESDescriptors, &j))) {\n\t\t\t\t\tref = (GF_ES_ID_Ref *) gf_odf_desc_new(GF_ODF_ESD_REF_TAG);\n\t\t\t\t\tif (!esd->ESID) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOM] Missing ESID on ESD, cannot add track reference in OD frame\"));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\t\t\t\t\t//1 to 1 mapping trackID and ESID. Add this track to MPOD\n\t\t\t\t\t//if track does not exist, this will be remove while reading the OD stream\n\t\t\t\t\te = reftype_AddRefTrack(mpod, esd->ESID, &ref->trackRef);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t\te = gf_odf_desc_add_desc((GF_Descriptor *)isom_od, (GF_Descriptor *)ref);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t//and add the new one to our command\n\t\t\t\tgf_list_add(odU2->objectDescriptors, isom_od);\n\t\t\t}\n\t\t\t//delete the command\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t//and add the new one to the codec\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\t//Rewrite ESD Update\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((esd = (GF_ESD*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tref = (GF_ES_ID_Ref *) gf_odf_desc_new(GF_ODF_ESD_REF_TAG);\n\t\t\t\t//1 to 1 mapping trackID and ESID\n\t\t\t\te = reftype_AddRefTrack(mpod, esd->ESID, &ref->trackRef);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\te = gf_list_add(esdU2->ESDescriptors, ref);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//Brand new case: the ESRemove has to be rewritten too according to the specs...\n\t\tcase GF_ODF_ESD_REMOVE_TAG:\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\t//change the tag for the file format\n\t\t\tesdR2->tag = GF_ODF_ESD_REMOVE_REF_TAG;\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\tif (esdR->NbESDs) {\n\t\t\t\t//alloc our stuff\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t\t//1 to 1 mapping trackID and ESID\n\t\t\t\t\te = reftype_AddRefTrack(mpod, esdR->ES_ID[i], &esdR2->ES_ID[i]);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_com_del(&com);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\t//Add the command as is\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\t*od_samp = gf_isom_sample_new();\n\t(*od_samp)->CTS_Offset = sample->CTS_Offset;\n\t(*od_samp)->DTS = sample->DTS;\n\t(*od_samp)->IsRAP = sample->IsRAP;\n\te = gf_odf_codec_get_au(ODencode, & (*od_samp)->data, & (*od_samp)->dataLength);\n\tif (e) {\n\t\tgf_isom_sample_del(od_samp);\n\t\t*od_samp = NULL;\n\t}\n\nerr_exit:\n\n\tgf_odf_codec_del(ODencode);\n\tgf_odf_codec_del(ODdecode);\n\treturn e;\n}\n\n\n\n// Rewrite the good dependencies when an OD AU is extracted from the file\nstatic u32 Media_FindOD_ID(GF_MediaBox *mdia, GF_ISOSample *sample, u32 track_id)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCom *com;\n\tu32 the_od_id;\n\tGF_ODUpdate *odU;\n\tGF_ESD *esd;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return 0;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return 0;\n\t//no references, nothing to do...\n\tif (!mpod) return 0;\n\n\tthe_od_id = 0;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return 0;\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tGF_List *esd_list = NULL;\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\t\tif (com->tag != GF_ODF_OD_UPDATE_TAG) continue;\n\t\todU = (GF_ODUpdate *) com;\n\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_OD_TAG:\n\t\t\tcase GF_ODF_IOD_TAG:\n\t\t\t\tesd_list = ((GF_ObjectDescriptor *)desc)->ESDescriptors;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj=0;\n\t\t\twhile ((esd = (GF_ESD*)gf_list_enum( esd_list, &j))) {\n\t\t\t\tif (esd->ESID==track_id) {\n\t\t\t\t\tthe_od_id = ((GF_IsomObjectDescriptor*)desc)->objectDescriptorID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (the_od_id) break;\n\t\t}\n\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\tif (the_od_id) break;\n\t}\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\treturn the_od_id; //still 0 if error, no need to check for e\n}\n\n\nGF_EXPORT\nu32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)\n{\n\tu32 i, j, di, the_od_id;\n\tGF_TrackBox *od_tk;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(file, track);\n\tif (!tk) return 0;\n\n\ti=0;\n\twhile ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {\n\t\tif (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\tfor (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);\n\t\t\tthe_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (the_od_id) return the_od_id;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n// Rewrite the good dependencies when an OD AU is extracted from the file\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n\n\n// Update the dependencies when an OD AU is inserted in the file\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp)\n{\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *mpod;\n\tGF_Err e;\n\tGF_ODCom *com;\n\tGF_ODCodec *ODencode;\n\tGF_ODCodec *ODdecode;\n\tu32 i, j;\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\n\t*od_samp = NULL;\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\t//First find the references, and create them if none\n\ttref = mdia->mediaTrack->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&mdia->mediaTrack->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)mdia->mediaTrack, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//then find the OD reference, and create it if none\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\tif (!mpod) {\n\t\tmpod = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!mpod) return GF_OUT_OF_MEM;\n\t\tmpod->reference_type = GF_ISOM_BOX_TYPE_MPOD;\n\t}\n\n\t//OK, create our codecs\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) return GF_OUT_OF_MEM;\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//check our commands\n\t\tswitch (com->tag) {\n\t\t//Rewrite OD Update\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\t//duplicate our command\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\t//both OD and IODs are accepted\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\te = GF_ODF_INVALID_DESCRIPTOR;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\t//get the esd\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&od);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tif (desc->tag == GF_ODF_OD_TAG) {\n\t\t\t\t\tisom_od = (GF_IsomObjectDescriptor *) gf_malloc(sizeof(GF_IsomObjectDescriptor));\n\t\t\t\t\tif (!isom_od) return GF_OUT_OF_MEM;\n\t\t\t\t\tisom_od->tag = GF_ODF_ISOM_OD_TAG;\n\t\t\t\t} else {\n\t\t\t\t\tisom_od = (GF_IsomObjectDescriptor *) gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\t\t\t\t\tif (!isom_od) return GF_OUT_OF_MEM;\n\t\t\t\t\tisom_od->tag = GF_ODF_ISOM_IOD_TAG;\n\t\t\t\t\t//copy PL\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag = ((GF_InitialObjectDescriptor *)od)->inlineProfileFlag;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel = ((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = ((GF_InitialObjectDescriptor *)od)->IPMPToolList;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = NULL;\n\t\t\t\t}\n\t\t\t\t//in OD stream only ref desc are accepted\n\t\t\t\tisom_od->ES_ID_RefDescriptors = gf_list_new();\n\t\t\t\tisom_od->ES_ID_IncDescriptors = NULL;\n\n\t\t\t\t//TO DO: check that a given sampleDescription exists\n\t\t\t\tisom_od->extensionDescriptors = od->extensionDescriptors;\n\t\t\t\tod->extensionDescriptors = NULL;\n\t\t\t\tisom_od->IPMP_Descriptors = od->IPMP_Descriptors;\n\t\t\t\tod->IPMP_Descriptors = NULL;\n\t\t\t\tisom_od->OCIDescriptors = od->OCIDescriptors;\n\t\t\t\tod->OCIDescriptors = NULL;\n\t\t\t\tisom_od->URLString = od->URLString;\n\t\t\t\tod->URLString = NULL;\n\t\t\t\tisom_od->objectDescriptorID = od->objectDescriptorID;\n\n\t\t\t\tj=0;\n\t\t\t\twhile ((esd = (GF_ESD*)gf_list_enum(od->ESDescriptors, &j))) {\n\t\t\t\t\tref = (GF_ES_ID_Ref *) gf_odf_desc_new(GF_ODF_ESD_REF_TAG);\n\t\t\t\t\tif (!esd->ESID) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOM] Missing ESID on ESD, cannot add track reference in OD frame\"));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\t\t\t\t\t//1 to 1 mapping trackID and ESID. Add this track to MPOD\n\t\t\t\t\t//if track does not exist, this will be remove while reading the OD stream\n\t\t\t\t\te = reftype_AddRefTrack(mpod, esd->ESID, &ref->trackRef);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t\te = gf_odf_desc_add_desc((GF_Descriptor *)isom_od, (GF_Descriptor *)ref);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t//and add the new one to our command\n\t\t\t\tgf_list_add(odU2->objectDescriptors, isom_od);\n\t\t\t}\n\t\t\t//delete the command\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t//and add the new one to the codec\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\t//Rewrite ESD Update\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((esd = (GF_ESD*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tref = (GF_ES_ID_Ref *) gf_odf_desc_new(GF_ODF_ESD_REF_TAG);\n\t\t\t\t//1 to 1 mapping trackID and ESID\n\t\t\t\te = reftype_AddRefTrack(mpod, esd->ESID, &ref->trackRef);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\te = gf_list_add(esdU2->ESDescriptors, ref);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//Brand new case: the ESRemove has to be rewritten too according to the specs...\n\t\tcase GF_ODF_ESD_REMOVE_TAG:\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\t//change the tag for the file format\n\t\t\tesdR2->tag = GF_ODF_ESD_REMOVE_REF_TAG;\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\tif (esdR->NbESDs) {\n\t\t\t\t//alloc our stuff\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\t\t//1 to 1 mapping trackID and ESID\n\t\t\t\t\te = reftype_AddRefTrack(mpod, esdR->ES_ID[i], &esdR2->ES_ID[i]);\n\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_com_del(&com);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\t//Add the command as is\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\t*od_samp = gf_isom_sample_new();\n\t(*od_samp)->CTS_Offset = sample->CTS_Offset;\n\t(*od_samp)->DTS = sample->DTS;\n\t(*od_samp)->IsRAP = sample->IsRAP;\n\te = gf_odf_codec_get_au(ODencode, & (*od_samp)->data, & (*od_samp)->dataLength);\n\tif (e) {\n\t\tgf_isom_sample_del(od_samp);\n\t\t*od_samp = NULL;\n\t}\n\nerr_exit:\n\n\tgf_odf_codec_del(ODencode);\n\tgf_odf_codec_del(ODdecode);\n\treturn e;\n}\n\n\n\n// Rewrite the good dependencies when an OD AU is extracted from the file\nstatic u32 Media_FindOD_ID(GF_MediaBox *mdia, GF_ISOSample *sample, u32 track_id)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCom *com;\n\tu32 the_od_id;\n\tGF_ODUpdate *odU;\n\tGF_ESD *esd;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return 0;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return 0;\n\t//no references, nothing to do...\n\tif (!mpod) return 0;\n\n\tthe_od_id = 0;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return 0;\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tGF_List *esd_list = NULL;\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\t\tif (com->tag != GF_ODF_OD_UPDATE_TAG) continue;\n\t\todU = (GF_ODUpdate *) com;\n\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_OD_TAG:\n\t\t\tcase GF_ODF_IOD_TAG:\n\t\t\t\tesd_list = ((GF_ObjectDescriptor *)desc)->ESDescriptors;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj=0;\n\t\t\twhile ((esd = (GF_ESD*)gf_list_enum( esd_list, &j))) {\n\t\t\t\tif (esd->ESID==track_id) {\n\t\t\t\t\tthe_od_id = ((GF_IsomObjectDescriptor*)desc)->objectDescriptorID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (the_od_id) break;\n\t\t}\n\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\tif (the_od_id) break;\n\t}\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\treturn the_od_id; //still 0 if error, no need to check for e\n}\n\n\nGF_EXPORT\nu32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)\n{\n\tu32 i, j, di, the_od_id;\n\tGF_TrackBox *od_tk;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(file, track);\n\tif (!tk) return 0;\n\n\ti=0;\n\twhile ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {\n\t\tif (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\tfor (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);\n\t\t\tthe_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (the_od_id) return the_od_id;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/media_odf.c"], "buggy_code_start_loc": [133], "buggy_code_end_loc": [189], "fixing_code_start_loc": [134], "fixing_code_end_loc": [193], "type": "CWE-476", "message": "The Media_RewriteODFrame function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-32440", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-11T20:15:09.047", "lastModified": "2021-08-16T17:32:28.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Media_RewriteODFrame function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n Media_RewriteODFrame en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/f0ba83717b6e4d7a15a1676d1fe06152e199b011", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1772", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/f0ba83717b6e4d7a15a1676d1fe06152e199b011"}}