{"buggy_code": ["/* Copyright (C) 2013-2014 B.A.T.M.A.N. contributors:\n *\n * Martin Hundeb\u00f8ll <martin@hundeboll.net>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"main.h\"\n#include \"fragmentation.h\"\n#include \"send.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"hard-interface.h\"\n#include \"soft-interface.h\"\n\n\n/**\n * batadv_frag_clear_chain - delete entries in the fragment buffer chain\n * @head: head of chain with entries.\n *\n * Free fragments in the passed hlist. Should be called with appropriate lock.\n */\nstatic void batadv_frag_clear_chain(struct hlist_head *head)\n{\n\tstruct batadv_frag_list_entry *entry;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(entry, node, head, list) {\n\t\thlist_del(&entry->list);\n\t\tkfree_skb(entry->skb);\n\t\tkfree(entry);\n\t}\n}\n\n/**\n * batadv_frag_purge_orig - free fragments associated to an orig\n * @orig_node: originator to free fragments from\n * @check_cb: optional function to tell if an entry should be purged\n */\nvoid batadv_frag_purge_orig(struct batadv_orig_node *orig_node,\n\t\t\t    bool (*check_cb)(struct batadv_frag_table_entry *))\n{\n\tstruct batadv_frag_table_entry *chain;\n\tuint8_t i;\n\n\tfor (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {\n\t\tchain = &orig_node->fragments[i];\n\t\tspin_lock_bh(&orig_node->fragments[i].lock);\n\n\t\tif (!check_cb || check_cb(chain)) {\n\t\t\tbatadv_frag_clear_chain(&orig_node->fragments[i].head);\n\t\t\torig_node->fragments[i].size = 0;\n\t\t}\n\n\t\tspin_unlock_bh(&orig_node->fragments[i].lock);\n\t}\n}\n\n/**\n * batadv_frag_size_limit - maximum possible size of packet to be fragmented\n *\n * Returns the maximum size of payload that can be fragmented.\n */\nstatic int batadv_frag_size_limit(void)\n{\n\tint limit = BATADV_FRAG_MAX_FRAG_SIZE;\n\n\tlimit -= sizeof(struct batadv_frag_packet);\n\tlimit *= BATADV_FRAG_MAX_FRAGMENTS;\n\n\treturn limit;\n}\n\n/**\n * batadv_frag_init_chain - check and prepare fragment chain for new fragment\n * @chain: chain in fragments table to init\n * @seqno: sequence number of the received fragment\n *\n * Make chain ready for a fragment with sequence number \"seqno\". Delete existing\n * entries if they have an \"old\" sequence number.\n *\n * Caller must hold chain->lock.\n *\n * Returns true if chain is empty and caller can just insert the new fragment\n * without searching for the right position.\n */\nstatic bool batadv_frag_init_chain(struct batadv_frag_table_entry *chain,\n\t\t\t\t   uint16_t seqno)\n{\n\tif (chain->seqno == seqno)\n\t\treturn false;\n\n\tif (!hlist_empty(&chain->head))\n\t\tbatadv_frag_clear_chain(&chain->head);\n\n\tchain->size = 0;\n\tchain->seqno = seqno;\n\n\treturn true;\n}\n\n/**\n * batadv_frag_insert_packet - insert a fragment into a fragment chain\n * @orig_node: originator that the fragment was received from\n * @skb: skb to insert\n * @chain_out: list head to attach complete chains of fragments to\n *\n * Insert a new fragment into the reverse ordered chain in the right table\n * entry. The hash table entry is cleared if \"old\" fragments exist in it.\n *\n * Returns true if skb is buffered, false on error. If the chain has all the\n * fragments needed to merge the packet, the chain is moved to the passed head\n * to avoid locking the chain in the table.\n */\nstatic bool batadv_frag_insert_packet(struct batadv_orig_node *orig_node,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct hlist_head *chain_out)\n{\n\tstruct batadv_frag_table_entry *chain;\n\tstruct batadv_frag_list_entry *frag_entry_new = NULL, *frag_entry_curr;\n\tstruct batadv_frag_list_entry *frag_entry_last = NULL;\n\tstruct batadv_frag_packet *frag_packet;\n\tuint8_t bucket;\n\tuint16_t seqno, hdr_size = sizeof(struct batadv_frag_packet);\n\tbool ret = false;\n\n\t/* Linearize packet to avoid linearizing 16 packets in a row when doing\n\t * the later merge. Non-linear merge should be added to remove this\n\t * linearization.\n\t */\n\tif (skb_linearize(skb) < 0)\n\t\tgoto err;\n\n\tfrag_packet = (struct batadv_frag_packet *)skb->data;\n\tseqno = ntohs(frag_packet->seqno);\n\tbucket = seqno % BATADV_FRAG_BUFFER_COUNT;\n\n\tfrag_entry_new = kmalloc(sizeof(*frag_entry_new), GFP_ATOMIC);\n\tif (!frag_entry_new)\n\t\tgoto err;\n\n\tfrag_entry_new->skb = skb;\n\tfrag_entry_new->no = frag_packet->no;\n\n\t/* Select entry in the \"chain table\" and delete any prior fragments\n\t * with another sequence number. batadv_frag_init_chain() returns true,\n\t * if the list is empty at return.\n\t */\n\tchain = &orig_node->fragments[bucket];\n\tspin_lock_bh(&chain->lock);\n\tif (batadv_frag_init_chain(chain, seqno)) {\n\t\thlist_add_head(&frag_entry_new->list, &chain->head);\n\t\tchain->size = skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Find the position for the new fragment. */\n\thlist_for_each_entry(frag_entry_curr, &chain->head, list) {\n\t\t/* Drop packet if fragment already exists. */\n\t\tif (frag_entry_curr->no == frag_entry_new->no)\n\t\t\tgoto err_unlock;\n\n\t\t/* Order fragments from highest to lowest. */\n\t\tif (frag_entry_curr->no < frag_entry_new->no) {\n\t\t\thlist_add_before(&frag_entry_new->list,\n\t\t\t\t\t &frag_entry_curr->list);\n\t\t\tchain->size += skb->len - hdr_size;\n\t\t\tchain->timestamp = jiffies;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* store current entry because it could be the last in list */\n\t\tfrag_entry_last = frag_entry_curr;\n\t}\n\n\t/* Reached the end of the list, so insert after 'frag_entry_last'. */\n\tif (likely(frag_entry_last)) {\n\t\thlist_add_behind(&frag_entry_new->list, &frag_entry_last->list);\n\t\tchain->size += skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tret = true;\n\t}\n\nout:\n\tif (chain->size > batadv_frag_size_limit() ||\n\t    ntohs(frag_packet->total_size) > batadv_frag_size_limit()) {\n\t\t/* Clear chain if total size of either the list or the packet\n\t\t * exceeds the maximum size of one merged packet.\n\t\t */\n\t\tbatadv_frag_clear_chain(&chain->head);\n\t\tchain->size = 0;\n\t} else if (ntohs(frag_packet->total_size) == chain->size) {\n\t\t/* All fragments received. Hand over chain to caller. */\n\t\thlist_move_list(&chain->head, chain_out);\n\t\tchain->size = 0;\n\t}\n\nerr_unlock:\n\tspin_unlock_bh(&chain->lock);\n\nerr:\n\tif (!ret)\n\t\tkfree(frag_entry_new);\n\n\treturn ret;\n}\n\n/**\n * batadv_frag_merge_packets - merge a chain of fragments\n * @chain: head of chain with fragments\n * @skb: packet with total size of skb after merging\n *\n * Expand the first skb in the chain and copy the content of the remaining\n * skb's into the expanded one. After doing so, clear the chain.\n *\n * Returns the merged skb or NULL on error.\n */\nstatic struct sk_buff *\nbatadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\n\t/* Make sure incoming skb has non-bogus data. */\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\n\t/* Remove first entry, as this is the destination for the rest of the\n\t * fragments.\n\t */\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\n\t/* Make room for the rest of the fragments. */\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\n\t/* Move the existing MAC header to just before the payload. (Override\n\t * the fragment header.)\n\t */\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\n\t/* Copy the payload of the each fragment into the last skb */\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\n\nfree:\n\t/* Locking is not needed, because 'chain' is not part of any orig. */\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}\n\n/**\n * batadv_frag_skb_buffer - buffer fragment for later merge\n * @skb: skb to buffer\n * @orig_node_src: originator that the skb is received from\n *\n * Add fragment to buffer and merge fragments if possible.\n *\n * There are three possible outcomes: 1) Packet is merged: Return true and\n * set *skb to merged packet; 2) Packet is buffered: Return true and set *skb\n * to NULL; 3) Error: Return false and leave skb as is.\n */\nbool batadv_frag_skb_buffer(struct sk_buff **skb,\n\t\t\t    struct batadv_orig_node *orig_node_src)\n{\n\tstruct sk_buff *skb_out = NULL;\n\tstruct hlist_head head = HLIST_HEAD_INIT;\n\tbool ret = false;\n\n\t/* Add packet to buffer and table entry if merge is possible. */\n\tif (!batadv_frag_insert_packet(orig_node_src, *skb, &head))\n\t\tgoto out_err;\n\n\t/* Leave if more fragments are needed to merge. */\n\tif (hlist_empty(&head))\n\t\tgoto out;\n\n\tskb_out = batadv_frag_merge_packets(&head, *skb);\n\tif (!skb_out)\n\t\tgoto out_err;\n\nout:\n\t*skb = skb_out;\n\tret = true;\nout_err:\n\treturn ret;\n}\n\n/**\n * batadv_frag_skb_fwd - forward fragments that would exceed MTU when merged\n * @skb: skb to forward\n * @recv_if: interface that the skb is received on\n * @orig_node_src: originator that the skb is received from\n *\n * Look up the next-hop of the fragments payload and check if the merged packet\n * will exceed the MTU towards the next-hop. If so, the fragment is forwarded\n * without merging it.\n *\n * Returns true if the fragment is consumed/forwarded, false otherwise.\n */\nbool batadv_frag_skb_fwd(struct sk_buff *skb,\n\t\t\t struct batadv_hard_iface *recv_if,\n\t\t\t struct batadv_orig_node *orig_node_src)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node_dst = NULL;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct batadv_frag_packet *packet;\n\tuint16_t total_size;\n\tbool ret = false;\n\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\torig_node_dst = batadv_orig_hash_find(bat_priv, packet->dest);\n\tif (!orig_node_dst)\n\t\tgoto out;\n\n\tneigh_node = batadv_find_router(bat_priv, orig_node_dst, recv_if);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\t/* Forward the fragment, if the merged packet would be too big to\n\t * be assembled.\n\t */\n\ttotal_size = ntohs(packet->total_size);\n\tif (total_size > neigh_node->if_incoming->net_dev->mtu) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_FWD);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_FWD_BYTES,\n\t\t\t\t   skb->len + ETH_HLEN);\n\n\t\tpacket->ttl--;\n\t\tbatadv_send_skb_packet(skb, neigh_node->if_incoming,\n\t\t\t\t       neigh_node->addr);\n\t\tret = true;\n\t}\n\nout:\n\tif (orig_node_dst)\n\t\tbatadv_orig_node_free_ref(orig_node_dst);\n\tif (neigh_node)\n\t\tbatadv_neigh_node_free_ref(neigh_node);\n\treturn ret;\n}\n\n/**\n * batadv_frag_create - create a fragment from skb\n * @skb: skb to create fragment from\n * @frag_head: header to use in new fragment\n * @mtu: size of new fragment\n *\n * Split the passed skb into two fragments: A new one with size matching the\n * passed mtu and the old one with the rest. The new skb contains data from the\n * tail of the old skb.\n *\n * Returns the new fragment, NULL on error.\n */\nstatic struct sk_buff *batadv_frag_create(struct sk_buff *skb,\n\t\t\t\t\t  struct batadv_frag_packet *frag_head,\n\t\t\t\t\t  unsigned int mtu)\n{\n\tstruct sk_buff *skb_fragment;\n\tunsigned header_size = sizeof(*frag_head);\n\tunsigned fragment_size = mtu - header_size;\n\n\tskb_fragment = netdev_alloc_skb(NULL, mtu + ETH_HLEN);\n\tif (!skb_fragment)\n\t\tgoto err;\n\n\tskb->priority = TC_PRIO_CONTROL;\n\n\t/* Eat the last mtu-bytes of the skb */\n\tskb_reserve(skb_fragment, header_size + ETH_HLEN);\n\tskb_split(skb, skb_fragment, skb->len - fragment_size);\n\n\t/* Add the header */\n\tskb_push(skb_fragment, header_size);\n\tmemcpy(skb_fragment->data, frag_head, header_size);\n\nerr:\n\treturn skb_fragment;\n}\n\n/**\n * batadv_frag_send_packet - create up to 16 fragments from the passed skb\n * @skb: skb to create fragments from\n * @orig_node: final destination of the created fragments\n * @neigh_node: next-hop of the created fragments\n *\n * Returns true on success, false otherwise.\n */\nbool batadv_frag_send_packet(struct sk_buff *skb,\n\t\t\t     struct batadv_orig_node *orig_node,\n\t\t\t     struct batadv_neigh_node *neigh_node)\n{\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_frag_packet frag_header;\n\tstruct sk_buff *skb_fragment;\n\tunsigned mtu = neigh_node->if_incoming->net_dev->mtu;\n\tunsigned header_size = sizeof(frag_header);\n\tunsigned max_fragment_size, max_packet_size;\n\tbool ret = false;\n\n\t/* To avoid merge and refragmentation at next-hops we never send\n\t * fragments larger than BATADV_FRAG_MAX_FRAG_SIZE\n\t */\n\tmtu = min_t(unsigned, mtu, BATADV_FRAG_MAX_FRAG_SIZE);\n\tmax_fragment_size = (mtu - header_size - ETH_HLEN);\n\tmax_packet_size = max_fragment_size * BATADV_FRAG_MAX_FRAGMENTS;\n\n\t/* Don't even try to fragment, if we need more than 16 fragments */\n\tif (skb->len > max_packet_size)\n\t\tgoto out_err;\n\n\tbat_priv = orig_node->bat_priv;\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out_err;\n\n\t/* Create one header to be copied to all fragments */\n\tfrag_header.packet_type = BATADV_UNICAST_FRAG;\n\tfrag_header.version = BATADV_COMPAT_VERSION;\n\tfrag_header.ttl = BATADV_TTL;\n\tfrag_header.seqno = htons(atomic_inc_return(&bat_priv->frag_seqno));\n\tfrag_header.reserved = 0;\n\tfrag_header.no = 0;\n\tfrag_header.total_size = htons(skb->len);\n\tether_addr_copy(frag_header.orig, primary_if->net_dev->dev_addr);\n\tether_addr_copy(frag_header.dest, orig_node->orig);\n\n\t/* Eat and send fragments from the tail of skb */\n\twhile (skb->len > max_fragment_size) {\n\t\tskb_fragment = batadv_frag_create(skb, &frag_header, mtu);\n\t\tif (!skb_fragment)\n\t\t\tgoto out_err;\n\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t\t   skb_fragment->len + ETH_HLEN);\n\t\tbatadv_send_skb_packet(skb_fragment, neigh_node->if_incoming,\n\t\t\t\t       neigh_node->addr);\n\t\tfrag_header.no++;\n\n\t\t/* The initial check in this function should cover this case */\n\t\tif (frag_header.no == BATADV_FRAG_MAX_FRAGMENTS - 1)\n\t\t\tgoto out_err;\n\t}\n\n\t/* Make room for the fragment header. */\n\tif (batadv_skb_head_push(skb, header_size) < 0 ||\n\t    pskb_expand_head(skb, header_size + ETH_HLEN, 0, GFP_ATOMIC) < 0)\n\t\tgoto out_err;\n\n\tmemcpy(skb->data, &frag_header, header_size);\n\n\t/* Send the last fragment */\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\tbatadv_send_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\n\n\tret = true;\n\nout_err:\n\tif (primary_if)\n\t\tbatadv_hardif_free_ref(primary_if);\n\n\treturn ret;\n}\n"], "fixing_code": ["/* Copyright (C) 2013-2014 B.A.T.M.A.N. contributors:\n *\n * Martin Hundeb\u00f8ll <martin@hundeboll.net>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"main.h\"\n#include \"fragmentation.h\"\n#include \"send.h\"\n#include \"originator.h\"\n#include \"routing.h\"\n#include \"hard-interface.h\"\n#include \"soft-interface.h\"\n\n\n/**\n * batadv_frag_clear_chain - delete entries in the fragment buffer chain\n * @head: head of chain with entries.\n *\n * Free fragments in the passed hlist. Should be called with appropriate lock.\n */\nstatic void batadv_frag_clear_chain(struct hlist_head *head)\n{\n\tstruct batadv_frag_list_entry *entry;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(entry, node, head, list) {\n\t\thlist_del(&entry->list);\n\t\tkfree_skb(entry->skb);\n\t\tkfree(entry);\n\t}\n}\n\n/**\n * batadv_frag_purge_orig - free fragments associated to an orig\n * @orig_node: originator to free fragments from\n * @check_cb: optional function to tell if an entry should be purged\n */\nvoid batadv_frag_purge_orig(struct batadv_orig_node *orig_node,\n\t\t\t    bool (*check_cb)(struct batadv_frag_table_entry *))\n{\n\tstruct batadv_frag_table_entry *chain;\n\tuint8_t i;\n\n\tfor (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {\n\t\tchain = &orig_node->fragments[i];\n\t\tspin_lock_bh(&orig_node->fragments[i].lock);\n\n\t\tif (!check_cb || check_cb(chain)) {\n\t\t\tbatadv_frag_clear_chain(&orig_node->fragments[i].head);\n\t\t\torig_node->fragments[i].size = 0;\n\t\t}\n\n\t\tspin_unlock_bh(&orig_node->fragments[i].lock);\n\t}\n}\n\n/**\n * batadv_frag_size_limit - maximum possible size of packet to be fragmented\n *\n * Returns the maximum size of payload that can be fragmented.\n */\nstatic int batadv_frag_size_limit(void)\n{\n\tint limit = BATADV_FRAG_MAX_FRAG_SIZE;\n\n\tlimit -= sizeof(struct batadv_frag_packet);\n\tlimit *= BATADV_FRAG_MAX_FRAGMENTS;\n\n\treturn limit;\n}\n\n/**\n * batadv_frag_init_chain - check and prepare fragment chain for new fragment\n * @chain: chain in fragments table to init\n * @seqno: sequence number of the received fragment\n *\n * Make chain ready for a fragment with sequence number \"seqno\". Delete existing\n * entries if they have an \"old\" sequence number.\n *\n * Caller must hold chain->lock.\n *\n * Returns true if chain is empty and caller can just insert the new fragment\n * without searching for the right position.\n */\nstatic bool batadv_frag_init_chain(struct batadv_frag_table_entry *chain,\n\t\t\t\t   uint16_t seqno)\n{\n\tif (chain->seqno == seqno)\n\t\treturn false;\n\n\tif (!hlist_empty(&chain->head))\n\t\tbatadv_frag_clear_chain(&chain->head);\n\n\tchain->size = 0;\n\tchain->seqno = seqno;\n\n\treturn true;\n}\n\n/**\n * batadv_frag_insert_packet - insert a fragment into a fragment chain\n * @orig_node: originator that the fragment was received from\n * @skb: skb to insert\n * @chain_out: list head to attach complete chains of fragments to\n *\n * Insert a new fragment into the reverse ordered chain in the right table\n * entry. The hash table entry is cleared if \"old\" fragments exist in it.\n *\n * Returns true if skb is buffered, false on error. If the chain has all the\n * fragments needed to merge the packet, the chain is moved to the passed head\n * to avoid locking the chain in the table.\n */\nstatic bool batadv_frag_insert_packet(struct batadv_orig_node *orig_node,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct hlist_head *chain_out)\n{\n\tstruct batadv_frag_table_entry *chain;\n\tstruct batadv_frag_list_entry *frag_entry_new = NULL, *frag_entry_curr;\n\tstruct batadv_frag_list_entry *frag_entry_last = NULL;\n\tstruct batadv_frag_packet *frag_packet;\n\tuint8_t bucket;\n\tuint16_t seqno, hdr_size = sizeof(struct batadv_frag_packet);\n\tbool ret = false;\n\n\t/* Linearize packet to avoid linearizing 16 packets in a row when doing\n\t * the later merge. Non-linear merge should be added to remove this\n\t * linearization.\n\t */\n\tif (skb_linearize(skb) < 0)\n\t\tgoto err;\n\n\tfrag_packet = (struct batadv_frag_packet *)skb->data;\n\tseqno = ntohs(frag_packet->seqno);\n\tbucket = seqno % BATADV_FRAG_BUFFER_COUNT;\n\n\tfrag_entry_new = kmalloc(sizeof(*frag_entry_new), GFP_ATOMIC);\n\tif (!frag_entry_new)\n\t\tgoto err;\n\n\tfrag_entry_new->skb = skb;\n\tfrag_entry_new->no = frag_packet->no;\n\n\t/* Select entry in the \"chain table\" and delete any prior fragments\n\t * with another sequence number. batadv_frag_init_chain() returns true,\n\t * if the list is empty at return.\n\t */\n\tchain = &orig_node->fragments[bucket];\n\tspin_lock_bh(&chain->lock);\n\tif (batadv_frag_init_chain(chain, seqno)) {\n\t\thlist_add_head(&frag_entry_new->list, &chain->head);\n\t\tchain->size = skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/* Find the position for the new fragment. */\n\thlist_for_each_entry(frag_entry_curr, &chain->head, list) {\n\t\t/* Drop packet if fragment already exists. */\n\t\tif (frag_entry_curr->no == frag_entry_new->no)\n\t\t\tgoto err_unlock;\n\n\t\t/* Order fragments from highest to lowest. */\n\t\tif (frag_entry_curr->no < frag_entry_new->no) {\n\t\t\thlist_add_before(&frag_entry_new->list,\n\t\t\t\t\t &frag_entry_curr->list);\n\t\t\tchain->size += skb->len - hdr_size;\n\t\t\tchain->timestamp = jiffies;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* store current entry because it could be the last in list */\n\t\tfrag_entry_last = frag_entry_curr;\n\t}\n\n\t/* Reached the end of the list, so insert after 'frag_entry_last'. */\n\tif (likely(frag_entry_last)) {\n\t\thlist_add_behind(&frag_entry_new->list, &frag_entry_last->list);\n\t\tchain->size += skb->len - hdr_size;\n\t\tchain->timestamp = jiffies;\n\t\tret = true;\n\t}\n\nout:\n\tif (chain->size > batadv_frag_size_limit() ||\n\t    ntohs(frag_packet->total_size) > batadv_frag_size_limit()) {\n\t\t/* Clear chain if total size of either the list or the packet\n\t\t * exceeds the maximum size of one merged packet.\n\t\t */\n\t\tbatadv_frag_clear_chain(&chain->head);\n\t\tchain->size = 0;\n\t} else if (ntohs(frag_packet->total_size) == chain->size) {\n\t\t/* All fragments received. Hand over chain to caller. */\n\t\thlist_move_list(&chain->head, chain_out);\n\t\tchain->size = 0;\n\t}\n\nerr_unlock:\n\tspin_unlock_bh(&chain->lock);\n\nerr:\n\tif (!ret)\n\t\tkfree(frag_entry_new);\n\n\treturn ret;\n}\n\n/**\n * batadv_frag_merge_packets - merge a chain of fragments\n * @chain: head of chain with fragments\n * @skb: packet with total size of skb after merging\n *\n * Expand the first skb in the chain and copy the content of the remaining\n * skb's into the expanded one. After doing so, clear the chain.\n *\n * Returns the merged skb or NULL on error.\n */\nstatic struct sk_buff *\nbatadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\n\t/* Make sure incoming skb has non-bogus data. */\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\n\t/* Remove first entry, as this is the destination for the rest of the\n\t * fragments.\n\t */\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\n\t/* Make room for the rest of the fragments. */\n\tif (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\n\t/* Move the existing MAC header to just before the payload. (Override\n\t * the fragment header.)\n\t */\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\n\t/* Copy the payload of the each fragment into the last skb */\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\n\nfree:\n\t/* Locking is not needed, because 'chain' is not part of any orig. */\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}\n\n/**\n * batadv_frag_skb_buffer - buffer fragment for later merge\n * @skb: skb to buffer\n * @orig_node_src: originator that the skb is received from\n *\n * Add fragment to buffer and merge fragments if possible.\n *\n * There are three possible outcomes: 1) Packet is merged: Return true and\n * set *skb to merged packet; 2) Packet is buffered: Return true and set *skb\n * to NULL; 3) Error: Return false and leave skb as is.\n */\nbool batadv_frag_skb_buffer(struct sk_buff **skb,\n\t\t\t    struct batadv_orig_node *orig_node_src)\n{\n\tstruct sk_buff *skb_out = NULL;\n\tstruct hlist_head head = HLIST_HEAD_INIT;\n\tbool ret = false;\n\n\t/* Add packet to buffer and table entry if merge is possible. */\n\tif (!batadv_frag_insert_packet(orig_node_src, *skb, &head))\n\t\tgoto out_err;\n\n\t/* Leave if more fragments are needed to merge. */\n\tif (hlist_empty(&head))\n\t\tgoto out;\n\n\tskb_out = batadv_frag_merge_packets(&head, *skb);\n\tif (!skb_out)\n\t\tgoto out_err;\n\nout:\n\t*skb = skb_out;\n\tret = true;\nout_err:\n\treturn ret;\n}\n\n/**\n * batadv_frag_skb_fwd - forward fragments that would exceed MTU when merged\n * @skb: skb to forward\n * @recv_if: interface that the skb is received on\n * @orig_node_src: originator that the skb is received from\n *\n * Look up the next-hop of the fragments payload and check if the merged packet\n * will exceed the MTU towards the next-hop. If so, the fragment is forwarded\n * without merging it.\n *\n * Returns true if the fragment is consumed/forwarded, false otherwise.\n */\nbool batadv_frag_skb_fwd(struct sk_buff *skb,\n\t\t\t struct batadv_hard_iface *recv_if,\n\t\t\t struct batadv_orig_node *orig_node_src)\n{\n\tstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\n\tstruct batadv_orig_node *orig_node_dst = NULL;\n\tstruct batadv_neigh_node *neigh_node = NULL;\n\tstruct batadv_frag_packet *packet;\n\tuint16_t total_size;\n\tbool ret = false;\n\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\torig_node_dst = batadv_orig_hash_find(bat_priv, packet->dest);\n\tif (!orig_node_dst)\n\t\tgoto out;\n\n\tneigh_node = batadv_find_router(bat_priv, orig_node_dst, recv_if);\n\tif (!neigh_node)\n\t\tgoto out;\n\n\t/* Forward the fragment, if the merged packet would be too big to\n\t * be assembled.\n\t */\n\ttotal_size = ntohs(packet->total_size);\n\tif (total_size > neigh_node->if_incoming->net_dev->mtu) {\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_FWD);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_FWD_BYTES,\n\t\t\t\t   skb->len + ETH_HLEN);\n\n\t\tpacket->ttl--;\n\t\tbatadv_send_skb_packet(skb, neigh_node->if_incoming,\n\t\t\t\t       neigh_node->addr);\n\t\tret = true;\n\t}\n\nout:\n\tif (orig_node_dst)\n\t\tbatadv_orig_node_free_ref(orig_node_dst);\n\tif (neigh_node)\n\t\tbatadv_neigh_node_free_ref(neigh_node);\n\treturn ret;\n}\n\n/**\n * batadv_frag_create - create a fragment from skb\n * @skb: skb to create fragment from\n * @frag_head: header to use in new fragment\n * @mtu: size of new fragment\n *\n * Split the passed skb into two fragments: A new one with size matching the\n * passed mtu and the old one with the rest. The new skb contains data from the\n * tail of the old skb.\n *\n * Returns the new fragment, NULL on error.\n */\nstatic struct sk_buff *batadv_frag_create(struct sk_buff *skb,\n\t\t\t\t\t  struct batadv_frag_packet *frag_head,\n\t\t\t\t\t  unsigned int mtu)\n{\n\tstruct sk_buff *skb_fragment;\n\tunsigned header_size = sizeof(*frag_head);\n\tunsigned fragment_size = mtu - header_size;\n\n\tskb_fragment = netdev_alloc_skb(NULL, mtu + ETH_HLEN);\n\tif (!skb_fragment)\n\t\tgoto err;\n\n\tskb->priority = TC_PRIO_CONTROL;\n\n\t/* Eat the last mtu-bytes of the skb */\n\tskb_reserve(skb_fragment, header_size + ETH_HLEN);\n\tskb_split(skb, skb_fragment, skb->len - fragment_size);\n\n\t/* Add the header */\n\tskb_push(skb_fragment, header_size);\n\tmemcpy(skb_fragment->data, frag_head, header_size);\n\nerr:\n\treturn skb_fragment;\n}\n\n/**\n * batadv_frag_send_packet - create up to 16 fragments from the passed skb\n * @skb: skb to create fragments from\n * @orig_node: final destination of the created fragments\n * @neigh_node: next-hop of the created fragments\n *\n * Returns true on success, false otherwise.\n */\nbool batadv_frag_send_packet(struct sk_buff *skb,\n\t\t\t     struct batadv_orig_node *orig_node,\n\t\t\t     struct batadv_neigh_node *neigh_node)\n{\n\tstruct batadv_priv *bat_priv;\n\tstruct batadv_hard_iface *primary_if = NULL;\n\tstruct batadv_frag_packet frag_header;\n\tstruct sk_buff *skb_fragment;\n\tunsigned mtu = neigh_node->if_incoming->net_dev->mtu;\n\tunsigned header_size = sizeof(frag_header);\n\tunsigned max_fragment_size, max_packet_size;\n\tbool ret = false;\n\n\t/* To avoid merge and refragmentation at next-hops we never send\n\t * fragments larger than BATADV_FRAG_MAX_FRAG_SIZE\n\t */\n\tmtu = min_t(unsigned, mtu, BATADV_FRAG_MAX_FRAG_SIZE);\n\tmax_fragment_size = (mtu - header_size - ETH_HLEN);\n\tmax_packet_size = max_fragment_size * BATADV_FRAG_MAX_FRAGMENTS;\n\n\t/* Don't even try to fragment, if we need more than 16 fragments */\n\tif (skb->len > max_packet_size)\n\t\tgoto out_err;\n\n\tbat_priv = orig_node->bat_priv;\n\tprimary_if = batadv_primary_if_get_selected(bat_priv);\n\tif (!primary_if)\n\t\tgoto out_err;\n\n\t/* Create one header to be copied to all fragments */\n\tfrag_header.packet_type = BATADV_UNICAST_FRAG;\n\tfrag_header.version = BATADV_COMPAT_VERSION;\n\tfrag_header.ttl = BATADV_TTL;\n\tfrag_header.seqno = htons(atomic_inc_return(&bat_priv->frag_seqno));\n\tfrag_header.reserved = 0;\n\tfrag_header.no = 0;\n\tfrag_header.total_size = htons(skb->len);\n\tether_addr_copy(frag_header.orig, primary_if->net_dev->dev_addr);\n\tether_addr_copy(frag_header.dest, orig_node->orig);\n\n\t/* Eat and send fragments from the tail of skb */\n\twhile (skb->len > max_fragment_size) {\n\t\tskb_fragment = batadv_frag_create(skb, &frag_header, mtu);\n\t\tif (!skb_fragment)\n\t\t\tgoto out_err;\n\n\t\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\t\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t\t   skb_fragment->len + ETH_HLEN);\n\t\tbatadv_send_skb_packet(skb_fragment, neigh_node->if_incoming,\n\t\t\t\t       neigh_node->addr);\n\t\tfrag_header.no++;\n\n\t\t/* The initial check in this function should cover this case */\n\t\tif (frag_header.no == BATADV_FRAG_MAX_FRAGMENTS - 1)\n\t\t\tgoto out_err;\n\t}\n\n\t/* Make room for the fragment header. */\n\tif (batadv_skb_head_push(skb, header_size) < 0 ||\n\t    pskb_expand_head(skb, header_size + ETH_HLEN, 0, GFP_ATOMIC) < 0)\n\t\tgoto out_err;\n\n\tmemcpy(skb->data, &frag_header, header_size);\n\n\t/* Send the last fragment */\n\tbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);\n\tbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,\n\t\t\t   skb->len + ETH_HLEN);\n\tbatadv_send_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\n\n\tret = true;\n\nout_err:\n\tif (primary_if)\n\t\tbatadv_hardif_free_ref(primary_if);\n\n\treturn ret;\n}\n"], "filenames": ["net/batman-adv/fragmentation.c"], "buggy_code_start_loc": [254], "buggy_code_end_loc": [255], "fixing_code_start_loc": [254], "fixing_code_end_loc": [255], "type": "CWE-399", "message": "The batadv_frag_merge_packets function in net/batman-adv/fragmentation.c in the B.A.T.M.A.N. implementation in the Linux kernel through 3.18.1 uses an incorrect length field during a calculation of an amount of memory, which allows remote attackers to cause a denial of service (mesh-node system crash) via fragmented packets.", "other": {"cve": {"id": "CVE-2014-9428", "sourceIdentifier": "security@debian.org", "published": "2015-01-02T21:59:00.063", "lastModified": "2023-01-20T03:02:37.280", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The batadv_frag_merge_packets function in net/batman-adv/fragmentation.c in the B.A.T.M.A.N. implementation in the Linux kernel through 3.18.1 uses an incorrect length field during a calculation of an amount of memory, which allows remote attackers to cause a denial of service (mesh-node system crash) via fragmented packets."}, {"lang": "es", "value": "La funci\u00f3n batadv_frag_merge_packets en net/batman-adv/fragmentation.c en la implementaci\u00f3n B.A.T.M.A.N. en el kernel de Linux hasta 3.18.1 utiliza un campo de longitud incorrecto durante un c\u00e1lculo de una cantidad de memoria, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda del sistema de modo de malla) a trav\u00e9s de paquetes fragmentados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.14.30", "matchCriteriaId": "24674691-B59E-47C7-8796-C6336AC09B73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.15", "versionEndExcluding": "3.16.35", "matchCriteriaId": "7DC4BA70-B111-4D2E-BC78-6601CED68F08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.4", "matchCriteriaId": "30673775-7C2A-4656-9C7E-5954E17C391C"}]}]}], "references": [{"url": "http://bugs.debian.org/774155", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=5b6698b0e4a37053de35cc24ee695b98a7eb712b", "source": "security@debian.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-January/147864.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-January/147973.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:058", "source": "security@debian.org", "tags": ["Broken Link"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/12/31/7", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.spinics.net/lists/netdev/msg309425.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2515-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2516-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2517-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2518-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.open-mesh.org/pipermail/b.a.t.m.a.n/2014-November/012561.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b"}}