{"buggy_code": ["/*\n * eap.c - Extensible Authentication Protocol for PPP (RFC 2284)\n *\n * Copyright (c) 2001 by Sun Microsystems, Inc.\n * All rights reserved.\n *\n * Non-exclusive rights to redistribute, modify, translate, and use\n * this software in source and binary forms, in whole or in part, is\n * hereby granted, provided that the above copyright notice is\n * duplicated in any source form, and that neither the name of the\n * copyright holder nor the author is used to endorse or promote\n * products derived from this software.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Original version by James Carlson\n *\n * This implementation of EAP supports MD5-Challenge and SRP-SHA1\n * authentication styles.  Note that support of MD5-Challenge is a\n * requirement of RFC 2284, and that it's essentially just a\n * reimplementation of regular RFC 1994 CHAP using EAP messages.\n *\n * As an authenticator (\"server\"), there are multiple phases for each\n * style.  In the first phase of each style, the unauthenticated peer\n * name is queried using the EAP Identity request type.  If the\n * \"remotename\" option is used, then this phase is skipped, because\n * the peer's name is presumed to be known.\n *\n * For MD5-Challenge, there are two phases, and the second phase\n * consists of sending the challenge itself and handling the\n * associated response.\n *\n * For SRP-SHA1, there are four phases.  The second sends 's', 'N',\n * and 'g'.  The reply contains 'A'.  The third sends 'B', and the\n * reply contains 'M1'.  The forth sends the 'M2' value.\n *\n * As an authenticatee (\"client\"), there's just a single phase --\n * responding to the queries generated by the peer.  EAP is an\n * authenticator-driven protocol.\n *\n * Based on draft-ietf-pppext-eap-srp-03.txt.\n */\n\n#define RCSID\t\"$Id: eap.c,v 1.4 2004/11/09 22:39:25 paulus Exp $\"\n\n/*\n * TODO:\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <errno.h>\n\n#include \"pppd.h\"\n#include \"pathnames.h\"\n#include \"md5.h\"\n#include \"eap.h\"\n\n#ifdef USE_SRP\n#include <t_pwd.h>\n#include <t_server.h>\n#include <t_client.h>\n#include \"pppcrypt.h\"\n#endif /* USE_SRP */\n\n#ifndef SHA_DIGESTSIZE\n#define\tSHA_DIGESTSIZE 20\n#endif\n\n\neap_state eap_states[NUM_PPP];\t\t/* EAP state; one for each unit */\n#ifdef USE_SRP\nstatic char *pn_secret = NULL;\t\t/* Pseudonym generating secret */\n#endif\n\n/*\n * Command-line options.\n */\nstatic option_t eap_option_list[] = {\n    { \"eap-restart\", o_int, &eap_states[0].es_server.ea_timeout,\n      \"Set retransmit timeout for EAP Requests (server)\" },\n    { \"eap-max-sreq\", o_int, &eap_states[0].es_server.ea_maxrequests,\n      \"Set max number of EAP Requests sent (server)\" },\n    { \"eap-timeout\", o_int, &eap_states[0].es_client.ea_timeout,\n      \"Set time limit for peer EAP authentication\" },\n    { \"eap-max-rreq\", o_int, &eap_states[0].es_client.ea_maxrequests,\n      \"Set max number of EAP Requests allows (client)\" },\n    { \"eap-interval\", o_int, &eap_states[0].es_rechallenge,\n      \"Set interval for EAP rechallenge\" },\n#ifdef USE_SRP\n    { \"srp-interval\", o_int, &eap_states[0].es_lwrechallenge,\n      \"Set interval for SRP lightweight rechallenge\" },\n    { \"srp-pn-secret\", o_string, &pn_secret,\n      \"Long term pseudonym generation secret\" },\n    { \"srp-use-pseudonym\", o_bool, &eap_states[0].es_usepseudo,\n      \"Use pseudonym if offered one by server\", 1 },\n#endif\n    { NULL }\n};\n\n/*\n * Protocol entry points.\n */\nstatic void eap_init __P((int unit));\nstatic void eap_input __P((int unit, u_char *inp, int inlen));\nstatic void eap_protrej __P((int unit));\nstatic void eap_lowerup __P((int unit));\nstatic void eap_lowerdown __P((int unit));\nstatic int  eap_printpkt __P((u_char *inp, int inlen,\n    void (*)(void *arg, char *fmt, ...), void *arg));\n\nstruct protent eap_protent = {\n\tPPP_EAP,\t\t/* protocol number */\n\teap_init,\t\t/* initialization procedure */\n\teap_input,\t\t/* process a received packet */\n\teap_protrej,\t\t/* process a received protocol-reject */\n\teap_lowerup,\t\t/* lower layer has gone up */\n\teap_lowerdown,\t\t/* lower layer has gone down */\n\tNULL,\t\t\t/* open the protocol */\n\tNULL,\t\t\t/* close the protocol */\n\teap_printpkt,\t\t/* print a packet in readable form */\n\tNULL,\t\t\t/* process a received data packet */\n\t1,\t\t\t/* protocol enabled */\n\t\"EAP\",\t\t\t/* text name of protocol */\n\tNULL,\t\t\t/* text name of corresponding data protocol */\n\teap_option_list,\t/* list of command-line options */\n\tNULL,\t\t\t/* check requested options; assign defaults */\n\tNULL,\t\t\t/* configure interface for demand-dial */\n\tNULL\t\t\t/* say whether to bring up link for this pkt */\n};\n\n/*\n * A well-known 2048 bit modulus.\n */\nstatic const u_char wkmodulus[] = {\n\t0xAC, 0x6B, 0xDB, 0x41, 0x32, 0x4A, 0x9A, 0x9B,\n\t0xF1, 0x66, 0xDE, 0x5E, 0x13, 0x89, 0x58, 0x2F,\n\t0xAF, 0x72, 0xB6, 0x65, 0x19, 0x87, 0xEE, 0x07,\n\t0xFC, 0x31, 0x92, 0x94, 0x3D, 0xB5, 0x60, 0x50,\n\t0xA3, 0x73, 0x29, 0xCB, 0xB4, 0xA0, 0x99, 0xED,\n\t0x81, 0x93, 0xE0, 0x75, 0x77, 0x67, 0xA1, 0x3D,\n\t0xD5, 0x23, 0x12, 0xAB, 0x4B, 0x03, 0x31, 0x0D,\n\t0xCD, 0x7F, 0x48, 0xA9, 0xDA, 0x04, 0xFD, 0x50,\n\t0xE8, 0x08, 0x39, 0x69, 0xED, 0xB7, 0x67, 0xB0,\n\t0xCF, 0x60, 0x95, 0x17, 0x9A, 0x16, 0x3A, 0xB3,\n\t0x66, 0x1A, 0x05, 0xFB, 0xD5, 0xFA, 0xAA, 0xE8,\n\t0x29, 0x18, 0xA9, 0x96, 0x2F, 0x0B, 0x93, 0xB8,\n\t0x55, 0xF9, 0x79, 0x93, 0xEC, 0x97, 0x5E, 0xEA,\n\t0xA8, 0x0D, 0x74, 0x0A, 0xDB, 0xF4, 0xFF, 0x74,\n\t0x73, 0x59, 0xD0, 0x41, 0xD5, 0xC3, 0x3E, 0xA7,\n\t0x1D, 0x28, 0x1E, 0x44, 0x6B, 0x14, 0x77, 0x3B,\n\t0xCA, 0x97, 0xB4, 0x3A, 0x23, 0xFB, 0x80, 0x16,\n\t0x76, 0xBD, 0x20, 0x7A, 0x43, 0x6C, 0x64, 0x81,\n\t0xF1, 0xD2, 0xB9, 0x07, 0x87, 0x17, 0x46, 0x1A,\n\t0x5B, 0x9D, 0x32, 0xE6, 0x88, 0xF8, 0x77, 0x48,\n\t0x54, 0x45, 0x23, 0xB5, 0x24, 0xB0, 0xD5, 0x7D,\n\t0x5E, 0xA7, 0x7A, 0x27, 0x75, 0xD2, 0xEC, 0xFA,\n\t0x03, 0x2C, 0xFB, 0xDB, 0xF5, 0x2F, 0xB3, 0x78,\n\t0x61, 0x60, 0x27, 0x90, 0x04, 0xE5, 0x7A, 0xE6,\n\t0xAF, 0x87, 0x4E, 0x73, 0x03, 0xCE, 0x53, 0x29,\n\t0x9C, 0xCC, 0x04, 0x1C, 0x7B, 0xC3, 0x08, 0xD8,\n\t0x2A, 0x56, 0x98, 0xF3, 0xA8, 0xD0, 0xC3, 0x82,\n\t0x71, 0xAE, 0x35, 0xF8, 0xE9, 0xDB, 0xFB, 0xB6,\n\t0x94, 0xB5, 0xC8, 0x03, 0xD8, 0x9F, 0x7A, 0xE4,\n\t0x35, 0xDE, 0x23, 0x6D, 0x52, 0x5F, 0x54, 0x75,\n\t0x9B, 0x65, 0xE3, 0x72, 0xFC, 0xD6, 0x8E, 0xF2,\n\t0x0F, 0xA7, 0x11, 0x1F, 0x9E, 0x4A, 0xFF, 0x73\n};\n\n/* Local forward declarations. */\nstatic void eap_server_timeout __P((void *arg));\n\n/*\n * Convert EAP state code to printable string for debug.\n */\nstatic const char *\neap_state_name(esc)\nenum eap_state_code esc;\n{\n\tstatic const char *state_names[] = { EAP_STATES };\n\n\treturn (state_names[(int)esc]);\n}\n\n/*\n * eap_init - Initialize state for an EAP user.  This is currently\n * called once by main() during start-up.\n */\nstatic void\neap_init(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tBZERO(esp, sizeof (*esp));\n\tesp->es_unit = unit;\n\tesp->es_server.ea_timeout = EAP_DEFTIMEOUT;\n\tesp->es_server.ea_maxrequests = EAP_DEFTRANSMITS;\n\tesp->es_server.ea_id = (u_char)(drand48() * 0x100);\n\tesp->es_client.ea_timeout = EAP_DEFREQTIME;\n\tesp->es_client.ea_maxrequests = EAP_DEFALLOWREQ;\n}\n\n/*\n * eap_client_timeout - Give up waiting for the peer to send any\n * Request messages.\n */\nstatic void\neap_client_timeout(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *) arg;\n\n\tif (!eap_client_active(esp))\n\t\treturn;\n\n\terror(\"EAP: timeout waiting for Request from peer\");\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n\tesp->es_client.ea_state = eapBadAuth;\n}\n\n/*\n * eap_authwithpeer - Authenticate to our peer (behave as client).\n *\n * Start client state and wait for requests.  This is called only\n * after eap_lowerup.\n */\nvoid\neap_authwithpeer(unit, localname)\nint unit;\nchar *localname;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Save the peer name we're given */\n\tesp->es_client.ea_name = localname;\n\tesp->es_client.ea_namelen = strlen(localname);\n\n\tesp->es_client.ea_state = eapListen;\n\n\t/*\n\t * Start a timer so that if the other end just goes\n\t * silent, we don't sit here waiting forever.\n\t */\n\tif (esp->es_client.ea_timeout > 0)\n\t\tTIMEOUT(eap_client_timeout, (void *)esp,\n\t\t    esp->es_client.ea_timeout);\n}\n\n/*\n * Format a standard EAP Failure message and send it to the peer.\n * (Server operation)\n */\nstatic void\neap_send_failure(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_FAILURE, outp);\n\tesp->es_server.ea_id++;\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tPUTSHORT(EAP_HEADERLEN, outp);\n\n\toutput(esp->es_unit, outpacket_buf, EAP_HEADERLEN + PPP_HDRLEN);\n\n\tesp->es_server.ea_state = eapBadAuth;\n\tauth_peer_fail(esp->es_unit, PPP_EAP);\n}\n\n/*\n * Format a standard EAP Success message and send it to the peer.\n * (Server operation)\n */\nstatic void\neap_send_success(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_SUCCESS, outp);\n\tesp->es_server.ea_id++;\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tPUTSHORT(EAP_HEADERLEN, outp);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + EAP_HEADERLEN);\n\n\tauth_peer_success(esp->es_unit, PPP_EAP, 0,\n\t    esp->es_server.ea_peer, esp->es_server.ea_peerlen);\n}\n\n#ifdef USE_SRP\n/*\n * Set DES key according to pseudonym-generating secret and current\n * date.\n */\nstatic bool\npncrypt_setkey(int timeoffs)\n{\n\tstruct tm *tp;\n\tchar tbuf[9];\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\ttime_t reftime;\n\n\tif (pn_secret == NULL)\n\t\treturn (0);\n\treftime = time(NULL) + timeoffs;\n\ttp = localtime(&reftime);\n\tSHA1Init(&ctxt);\n\tSHA1Update(&ctxt, pn_secret, strlen(pn_secret));\n\tstrftime(tbuf, sizeof (tbuf), \"%Y%m%d\", tp);\n\tSHA1Update(&ctxt, tbuf, strlen(tbuf));\n\tSHA1Final(dig, &ctxt);\n\treturn (DesSetkey(dig));\n}\n\nstatic char base64[] =\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstruct b64state {\n\tu_int32_t bs_bits;\n\tint bs_offs;\n};\n\nstatic int\nb64enc(bs, inp, inlen, outp)\nstruct b64state *bs;\nu_char *inp;\nint inlen;\nu_char *outp;\n{\n\tint outlen = 0;\n\n\twhile (inlen > 0) {\n\t\tbs->bs_bits = (bs->bs_bits << 8) | *inp++;\n\t\tinlen--;\n\t\tbs->bs_offs += 8;\n\t\tif (bs->bs_offs >= 24) {\n\t\t\t*outp++ = base64[(bs->bs_bits >> 18) & 0x3F];\n\t\t\t*outp++ = base64[(bs->bs_bits >> 12) & 0x3F];\n\t\t\t*outp++ = base64[(bs->bs_bits >> 6) & 0x3F];\n\t\t\t*outp++ = base64[bs->bs_bits & 0x3F];\n\t\t\toutlen += 4;\n\t\t\tbs->bs_offs = 0;\n\t\t\tbs->bs_bits = 0;\n\t\t}\n\t}\n\treturn (outlen);\n}\n\nstatic int\nb64flush(bs, outp)\nstruct b64state *bs;\nu_char *outp;\n{\n\tint outlen = 0;\n\n\tif (bs->bs_offs == 8) {\n\t\t*outp++ = base64[(bs->bs_bits >> 2) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits << 4) & 0x3F];\n\t\toutlen = 2;\n\t} else if (bs->bs_offs == 16) {\n\t\t*outp++ = base64[(bs->bs_bits >> 10) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits >> 4) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits << 2) & 0x3F];\n\t\toutlen = 3;\n\t}\n\tbs->bs_offs = 0;\n\tbs->bs_bits = 0;\n\treturn (outlen);\n}\n\nstatic int\nb64dec(bs, inp, inlen, outp)\nstruct b64state *bs;\nu_char *inp;\nint inlen;\nu_char *outp;\n{\n\tint outlen = 0;\n\tchar *cp;\n\n\twhile (inlen > 0) {\n\t\tif ((cp = strchr(base64, *inp++)) == NULL)\n\t\t\tbreak;\n\t\tbs->bs_bits = (bs->bs_bits << 6) | (cp - base64);\n\t\tinlen--;\n\t\tbs->bs_offs += 6;\n\t\tif (bs->bs_offs >= 8) {\n\t\t\t*outp++ = bs->bs_bits >> (bs->bs_offs - 8);\n\t\t\toutlen++;\n\t\t\tbs->bs_offs -= 8;\n\t\t}\n\t}\n\treturn (outlen);\n}\n#endif /* USE_SRP */\n\n/*\n * Assume that current waiting server state is complete and figure\n * next state to use based on available authentication data.  'status'\n * indicates if there was an error in handling the last query.  It is\n * 0 for success and non-zero for failure.\n */\nstatic void\neap_figure_next_state(esp, status)\neap_state *esp;\nint status;\n{\n#ifdef USE_SRP\n\tunsigned char secbuf[MAXWORDLEN], clear[8], *sp, *dp;\n\tstruct t_pw tpw;\n\tstruct t_confent *tce, mytce;\n\tchar *cp, *cp2;\n\tstruct t_server *ts;\n\tint id, i, plen, toffs;\n\tu_char vals[2];\n\tstruct b64state bs;\n#endif /* USE_SRP */\n\n\tesp->es_server.ea_timeout = esp->es_savedtime;\n\tswitch (esp->es_server.ea_state) {\n\tcase eapBadAuth:\n\t\treturn;\n\n\tcase eapIdentify:\n#ifdef USE_SRP\n\t\t/* Discard any previous session. */\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t\tbreak;\n\t\t}\n#ifdef USE_SRP\n\t\t/* If we've got a pseudonym, try to decode to real name. */\n\t\tif (esp->es_server.ea_peerlen > SRP_PSEUDO_LEN &&\n\t\t    strncmp(esp->es_server.ea_peer, SRP_PSEUDO_ID,\n\t\t\tSRP_PSEUDO_LEN) == 0 &&\n\t\t    (esp->es_server.ea_peerlen - SRP_PSEUDO_LEN) * 3 / 4 <\n\t\t    sizeof (secbuf)) {\n\t\t\tBZERO(&bs, sizeof (bs));\n\t\t\tplen = b64dec(&bs,\n\t\t\t    esp->es_server.ea_peer + SRP_PSEUDO_LEN,\n\t\t\t    esp->es_server.ea_peerlen - SRP_PSEUDO_LEN,\n\t\t\t    secbuf);\n\t\t\ttoffs = 0;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tpncrypt_setkey(toffs);\n\t\t\t\ttoffs -= 86400;\n\t\t\t\tif (!DesDecrypt(secbuf, clear)) {\n\t\t\t\t\tdbglog(\"no DES here; cannot decode \"\n\t\t\t\t\t    \"pseudonym\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tid = *(unsigned char *)clear;\n\t\t\t\tif (id + 1 <= plen && id + 9 > plen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (plen % 8 == 0 && i < 5) {\n\t\t\t\t/*\n\t\t\t\t * Note that this is always shorter than the\n\t\t\t\t * original stored string, so there's no need\n\t\t\t\t * to realloc.\n\t\t\t\t */\n\t\t\t\tif ((i = plen = *(unsigned char *)clear) > 7)\n\t\t\t\t\ti = 7;\n\t\t\t\tesp->es_server.ea_peerlen = plen;\n\t\t\t\tdp = (unsigned char *)esp->es_server.ea_peer;\n\t\t\t\tBCOPY(clear + 1, dp, i);\n\t\t\t\tplen -= i;\n\t\t\t\tdp += i;\n\t\t\t\tsp = secbuf + 8;\n\t\t\t\twhile (plen > 0) {\n\t\t\t\t\t(void) DesDecrypt(sp, dp);\n\t\t\t\t\tsp += 8;\n\t\t\t\t\tdp += 8;\n\t\t\t\t\tplen -= 8;\n\t\t\t\t}\n\t\t\t\tesp->es_server.ea_peer[\n\t\t\t\t\tesp->es_server.ea_peerlen] = '\\0';\n\t\t\t\tdbglog(\"decoded pseudonym to \\\"%.*q\\\"\",\n\t\t\t\t    esp->es_server.ea_peerlen,\n\t\t\t\t    esp->es_server.ea_peer);\n\t\t\t} else {\n\t\t\t\tdbglog(\"failed to decode real name\");\n\t\t\t\t/* Stay in eapIdentfy state; requery */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Look up user in secrets database. */\n\t\tif (get_srp_secret(esp->es_unit, esp->es_server.ea_peer,\n\t\t    esp->es_server.ea_name, (char *)secbuf, 1) != 0) {\n\t\t\t/* Set up default in case SRP entry is bad */\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\t/* Get t_confent based on index in srp-secrets */\n\t\t\tid = strtol((char *)secbuf, &cp, 10);\n\t\t\tif (*cp++ != ':' || id < 0)\n\t\t\t\tbreak;\n\t\t\tif (id == 0) {\n\t\t\t\tmytce.index = 0;\n\t\t\t\tmytce.modulus.data = (u_char *)wkmodulus;\n\t\t\t\tmytce.modulus.len = sizeof (wkmodulus);\n\t\t\t\tmytce.generator.data = (u_char *)\"\\002\";\n\t\t\t\tmytce.generator.len = 1;\n\t\t\t\ttce = &mytce;\n\t\t\t} else if ((tce = gettcid(id)) != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Client will have to verify this modulus/\n\t\t\t\t * generator combination, and that will take\n\t\t\t\t * a while.  Lengthen the timeout here.\n\t\t\t\t */\n\t\t\t\tif (esp->es_server.ea_timeout > 0 &&\n\t\t\t\t    esp->es_server.ea_timeout < 30)\n\t\t\t\t\tesp->es_server.ea_timeout = 30;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((cp2 = strchr(cp, ':')) == NULL)\n\t\t\t\tbreak;\n\t\t\t*cp2++ = '\\0';\n\t\t\ttpw.pebuf.name = esp->es_server.ea_peer;\n\t\t\ttpw.pebuf.password.len = t_fromb64((char *)tpw.pwbuf,\n\t\t\t    cp);\n\t\t\ttpw.pebuf.password.data = tpw.pwbuf;\n\t\t\ttpw.pebuf.salt.len = t_fromb64((char *)tpw.saltbuf,\n\t\t\t    cp2);\n\t\t\ttpw.pebuf.salt.data = tpw.saltbuf;\n\t\t\tif ((ts = t_serveropenraw(&tpw.pebuf, tce)) == NULL)\n\t\t\t\tbreak;\n\t\t\tesp->es_server.ea_session = (void *)ts;\n\t\t\tesp->es_server.ea_state = eapSRP1;\n\t\t\tvals[0] = esp->es_server.ea_id + 1;\n\t\t\tvals[1] = EAPT_SRP;\n\t\t\tt_serveraddexdata(ts, vals, 2);\n\t\t\t/* Generate B; must call before t_servergetkey() */\n\t\t\tt_servergenexp(ts);\n\t\t\tbreak;\n\t\t}\n#endif /* USE_SRP */\n\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\tbreak;\n\n\tcase eapSRP1:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status == 1) {\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t} else if (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapSRP2;\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP2:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapSRP3;\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP3:\n\tcase eapSRP4:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t}\n\t\tbreak;\n\n\tcase eapMD5Chall:\n\t\tif (status != 0) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tesp->es_server.ea_state = eapBadAuth;\n\t\tbreak;\n\t}\n\tif (esp->es_server.ea_state == eapBadAuth)\n\t\teap_send_failure(esp);\n}\n\n/*\n * Format an EAP Request message and send it to the peer.  Message\n * type depends on current state.  (Server operation)\n */\nstatic void\neap_send_request(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\tu_char *lenloc;\n\tu_char *ptr;\n\tint outlen;\n\tint challen;\n\tchar *str;\n#ifdef USE_SRP\n\tstruct t_server *ts;\n\tu_char clear[8], cipher[8], dig[SHA_DIGESTSIZE], *optr, *cp;\n\tint i, j;\n\tstruct b64state b64;\n\tSHA1_CTX ctxt;\n#endif /* USE_SRP */\n\n\t/* Handle both initial auth and restart */\n\tif (esp->es_server.ea_state < eapIdentify &&\n\t    esp->es_server.ea_state != eapInitial) {\n\t\tesp->es_server.ea_state = eapIdentify;\n\t\tif (explicit_remote) {\n\t\t\t/*\n\t\t\t * If we already know the peer's\n\t\t\t * unauthenticated name, then there's no\n\t\t\t * reason to ask.  Go to next state instead.\n\t\t\t */\n\t\t\tesp->es_server.ea_peer = remote_name;\n\t\t\tesp->es_server.ea_peerlen = strlen(remote_name);\n\t\t\teap_figure_next_state(esp, 0);\n\t\t}\n\t}\n\n\tif (esp->es_server.ea_maxrequests > 0 &&\n\t    esp->es_server.ea_requests >= esp->es_server.ea_maxrequests) {\n\t\tif (esp->es_server.ea_responses > 0)\n\t\t\terror(\"EAP: too many Requests sent\");\n\t\telse\n\t\t\terror(\"EAP: no response to Requests\");\n\t\teap_send_failure(esp);\n\t\treturn;\n\t}\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_REQUEST, outp);\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tlenloc = outp;\n\tINCPTR(2, outp);\n\n\tswitch (esp->es_server.ea_state) {\n\tcase eapIdentify:\n\t\tPUTCHAR(EAPT_IDENTITY, outp);\n\t\tstr = \"Name\";\n\t\tchallen = strlen(str);\n\t\tBCOPY(str, outp, challen);\n\t\tINCPTR(challen, outp);\n\t\tbreak;\n\n\tcase eapMD5Chall:\n\t\tPUTCHAR(EAPT_MD5CHAP, outp);\n\t\t/*\n\t\t * pick a random challenge length between\n\t\t * MIN_CHALLENGE_LENGTH and MAX_CHALLENGE_LENGTH\n\t\t */\n\t\tchallen = (drand48() *\n\t\t    (MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH)) +\n\t\t\t    MIN_CHALLENGE_LENGTH;\n\t\tPUTCHAR(challen, outp);\n\t\tesp->es_challen = challen;\n\t\tptr = esp->es_challenge;\n\t\twhile (--challen >= 0)\n\t\t\t*ptr++ = (u_char) (drand48() * 0x100);\n\t\tBCOPY(esp->es_challenge, outp, esp->es_challen);\n\t\tINCPTR(esp->es_challen, outp);\n\t\tBCOPY(esp->es_server.ea_name, outp, esp->es_server.ea_namelen);\n\t\tINCPTR(esp->es_server.ea_namelen, outp);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase eapSRP1:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_CHALLENGE, outp);\n\n\t\tPUTCHAR(esp->es_server.ea_namelen, outp);\n\t\tBCOPY(esp->es_server.ea_name, outp, esp->es_server.ea_namelen);\n\t\tINCPTR(esp->es_server.ea_namelen, outp);\n\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tPUTCHAR(ts->s.len, outp);\n\t\tBCOPY(ts->s.data, outp, ts->s.len);\n\t\tINCPTR(ts->s.len, outp);\n\n\t\tif (ts->g.len == 1 && ts->g.data[0] == 2) {\n\t\t\tPUTCHAR(0, outp);\n\t\t} else {\n\t\t\tPUTCHAR(ts->g.len, outp);\n\t\t\tBCOPY(ts->g.data, outp, ts->g.len);\n\t\t\tINCPTR(ts->g.len, outp);\n\t\t}\n\n\t\tif (ts->n.len != sizeof (wkmodulus) ||\n\t\t    BCMP(ts->n.data, wkmodulus, sizeof (wkmodulus)) != 0) {\n\t\t\tBCOPY(ts->n.data, outp, ts->n.len);\n\t\t\tINCPTR(ts->n.len, outp);\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP2:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_SKEY, outp);\n\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tBCOPY(ts->B.data, outp, ts->B.len);\n\t\tINCPTR(ts->B.len, outp);\n\t\tbreak;\n\n\tcase eapSRP3:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_SVALIDATOR, outp);\n\t\tPUTLONG(SRPVAL_EBIT, outp);\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tBCOPY(t_serverresponse(ts), outp, SHA_DIGESTSIZE);\n\t\tINCPTR(SHA_DIGESTSIZE, outp);\n\n\t\tif (pncrypt_setkey(0)) {\n\t\t\t/* Generate pseudonym */\n\t\t\toptr = outp;\n\t\t\tcp = (unsigned char *)esp->es_server.ea_peer;\n\t\t\tif ((j = i = esp->es_server.ea_peerlen) > 7)\n\t\t\t\tj = 7;\n\t\t\tclear[0] = i;\n\t\t\tBCOPY(cp, clear + 1, j);\n\t\t\ti -= j;\n\t\t\tcp += j;\n\t\t\tif (!DesEncrypt(clear, cipher)) {\n\t\t\t\tdbglog(\"no DES here; not generating pseudonym\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBZERO(&b64, sizeof (b64));\n\t\t\toutp++;\t\t/* space for pseudonym length */\n\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\twhile (i >= 8) {\n\t\t\t\t(void) DesEncrypt(cp, cipher);\n\t\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\t\tcp += 8;\n\t\t\t\ti -= 8;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tBCOPY(cp, clear, i);\n\t\t\t\tcp += i;\n\t\t\t\twhile (i < 8) {\n\t\t\t\t\t*cp++ = drand48() * 0x100;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t(void) DesEncrypt(clear, cipher);\n\t\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\t}\n\t\t\toutp += b64flush(&b64, outp);\n\n\t\t\t/* Set length and pad out to next 20 octet boundary */\n\t\t\ti = outp - optr - 1;\n\t\t\t*optr = i;\n\t\t\ti %= SHA_DIGESTSIZE;\n\t\t\tif (i != 0) {\n\t\t\t\twhile (i < SHA_DIGESTSIZE) {\n\t\t\t\t\t*outp++ = drand48() * 0x100;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Obscure the pseudonym with SHA1 hash */\n\t\t\tSHA1Init(&ctxt);\n\t\t\tSHA1Update(&ctxt, &esp->es_server.ea_id, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_peer,\n\t\t\t    esp->es_server.ea_peerlen);\n\t\t\twhile (optr < outp) {\n\t\t\t\tSHA1Final(dig, &ctxt);\n\t\t\t\tcp = dig;\n\t\t\t\twhile (cp < dig + SHA_DIGESTSIZE)\n\t\t\t\t\t*optr++ ^= *cp++;\n\t\t\t\tSHA1Init(&ctxt);\n\t\t\t\tSHA1Update(&ctxt, &esp->es_server.ea_id, 1);\n\t\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t\t    SESSION_KEY_LEN);\n\t\t\t\tSHA1Update(&ctxt, optr - SHA_DIGESTSIZE,\n\t\t\t\t    SHA_DIGESTSIZE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP4:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_LWRECHALLENGE, outp);\n\t\tchallen = MIN_CHALLENGE_LENGTH +\n\t\t    ((MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH) * drand48());\n\t\tesp->es_challen = challen;\n\t\tptr = esp->es_challenge;\n\t\twhile (--challen >= 0)\n\t\t\t*ptr++ = drand48() * 0x100;\n\t\tBCOPY(esp->es_challenge, outp, esp->es_challen);\n\t\tINCPTR(esp->es_challen, outp);\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\treturn;\n\t}\n\n\toutlen = (outp - outpacket_buf) - PPP_HDRLEN;\n\tPUTSHORT(outlen, lenloc);\n\n\toutput(esp->es_unit, outpacket_buf, outlen + PPP_HDRLEN);\n\n\tesp->es_server.ea_requests++;\n\n\tif (esp->es_server.ea_timeout > 0)\n\t\tTIMEOUT(eap_server_timeout, esp, esp->es_server.ea_timeout);\n}\n\n/*\n * eap_authpeer - Authenticate our peer (behave as server).\n *\n * Start server state and send first request.  This is called only\n * after eap_lowerup.\n */\nvoid\neap_authpeer(unit, localname)\nint unit;\nchar *localname;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Save the name we're given. */\n\tesp->es_server.ea_name = localname;\n\tesp->es_server.ea_namelen = strlen(localname);\n\n\tesp->es_savedtime = esp->es_server.ea_timeout;\n\n\t/* Lower layer up yet? */\n\tif (esp->es_server.ea_state == eapInitial ||\n\t    esp->es_server.ea_state == eapPending) {\n\t\tesp->es_server.ea_state = eapPending;\n\t\treturn;\n\t}\n\n\tesp->es_server.ea_state = eapPending;\n\n\t/* ID number not updated here intentionally; hashed into M1 */\n\teap_send_request(esp);\n}\n\n/*\n * eap_server_timeout - Retransmission timer for sending Requests\n * expired.\n */\nstatic void\neap_server_timeout(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *) arg;\n\n\tif (!eap_server_active(esp))\n\t\treturn;\n\n\t/* EAP ID number must not change on timeout. */\n\teap_send_request(esp);\n}\n\n/*\n * When it's time to send rechallenge the peer, this timeout is\n * called.  Once the rechallenge is successful, the response handler\n * will restart the timer.  If it fails, then the link is dropped.\n */\nstatic void\neap_rechallenge(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *)arg;\n\n\tif (esp->es_server.ea_state != eapOpen &&\n\t    esp->es_server.ea_state != eapSRP4)\n\t\treturn;\n\n\tesp->es_server.ea_requests = 0;\n\tesp->es_server.ea_state = eapIdentify;\n\teap_figure_next_state(esp, 0);\n\tesp->es_server.ea_id++;\n\teap_send_request(esp);\n}\n\nstatic void\nsrp_lwrechallenge(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *)arg;\n\n\tif (esp->es_server.ea_state != eapOpen ||\n\t    esp->es_server.ea_type != EAPT_SRP)\n\t\treturn;\n\n\tesp->es_server.ea_requests = 0;\n\tesp->es_server.ea_state = eapSRP4;\n\tesp->es_server.ea_id++;\n\teap_send_request(esp);\n}\n\n/*\n * eap_lowerup - The lower layer is now up.\n *\n * This is called before either eap_authpeer or eap_authwithpeer.  See\n * link_established() in auth.c.  All that's necessary here is to\n * return to closed state so that those two routines will do the right\n * thing.\n */\nstatic void\neap_lowerup(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Discard any (possibly authenticated) peer name. */\n\tif (esp->es_server.ea_peer != NULL &&\n\t    esp->es_server.ea_peer != remote_name)\n\t\tfree(esp->es_server.ea_peer);\n\tesp->es_server.ea_peer = NULL;\n\tif (esp->es_client.ea_peer != NULL)\n\t\tfree(esp->es_client.ea_peer);\n\tesp->es_client.ea_peer = NULL;\n\n\tesp->es_client.ea_state = eapClosed;\n\tesp->es_server.ea_state = eapClosed;\n}\n\n/*\n * eap_lowerdown - The lower layer is now down.\n *\n * Cancel all timeouts and return to initial state.\n */\nstatic void\neap_lowerdown(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tif (eap_client_active(esp) && esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\tif (eap_server_active(esp)) {\n\t\tif (esp->es_server.ea_timeout > 0) {\n\t\t\tUNTIMEOUT(eap_server_timeout, (void *)esp);\n\t\t}\n\t} else {\n\t\tif ((esp->es_server.ea_state == eapOpen ||\n\t\t    esp->es_server.ea_state == eapSRP4) &&\n\t\t    esp->es_rechallenge > 0) {\n\t\t\tUNTIMEOUT(eap_rechallenge, (void *)esp);\n\t\t}\n\t\tif (esp->es_server.ea_state == eapOpen &&\n\t\t    esp->es_lwrechallenge > 0) {\n\t\t\tUNTIMEOUT(srp_lwrechallenge, (void *)esp);\n\t\t}\n\t}\n\n\tesp->es_client.ea_state = esp->es_server.ea_state = eapInitial;\n\tesp->es_client.ea_requests = esp->es_server.ea_requests = 0;\n}\n\n/*\n * eap_protrej - Peer doesn't speak this protocol.\n *\n * This shouldn't happen.  If it does, it represents authentication\n * failure.\n */\nstatic void\neap_protrej(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tif (eap_client_active(esp)) {\n\t\terror(\"EAP authentication failed due to Protocol-Reject\");\n\t\tauth_withpeer_fail(unit, PPP_EAP);\n\t}\n\tif (eap_server_active(esp)) {\n\t\terror(\"EAP authentication of peer failed on Protocol-Reject\");\n\t\tauth_peer_fail(unit, PPP_EAP);\n\t}\n\teap_lowerdown(unit);\n}\n\n/*\n * Format and send a regular EAP Response message.\n */\nstatic void\neap_send_response(esp, id, typenum, str, lenstr)\neap_state *esp;\nu_char id;\nu_char typenum;\nu_char *str;\nint lenstr;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n\n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + sizeof (u_char) + lenstr;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(typenum, outp);\n\tif (lenstr > 0) {\n\t\tBCOPY(str, outp, lenstr);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n/*\n * Format and send an MD5-Challenge EAP Response message.\n */\nstatic void\neap_chap_response(esp, id, hash, name, namelen)\neap_state *esp;\nu_char id;\nu_char *hash;\nchar *name;\nint namelen;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + MD5_SIGNATURE_SIZE +\n\t    namelen;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_MD5CHAP, outp);\n\tPUTCHAR(MD5_SIGNATURE_SIZE, outp);\n\tBCOPY(hash, outp, MD5_SIGNATURE_SIZE);\n\tINCPTR(MD5_SIGNATURE_SIZE, outp);\n\tif (namelen > 0) {\n\t\tBCOPY(name, outp, namelen);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n#ifdef USE_SRP\n/*\n * Format and send a SRP EAP Response message.\n */\nstatic void\neap_srp_response(esp, id, subtypenum, str, lenstr)\neap_state *esp;\nu_char id;\nu_char subtypenum;\nu_char *str;\nint lenstr;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + lenstr;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_SRP, outp);\n\tPUTCHAR(subtypenum, outp);\n\tif (lenstr > 0) {\n\t\tBCOPY(str, outp, lenstr);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n/*\n * Format and send a SRP EAP Client Validator Response message.\n */\nstatic void\neap_srpval_response(esp, id, flags, str)\neap_state *esp;\nu_char id;\nu_int32_t flags;\nu_char *str;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + sizeof (u_int32_t) +\n\t    SHA_DIGESTSIZE;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_SRP, outp);\n\tPUTCHAR(EAPSRP_CVALIDATOR, outp);\n\tPUTLONG(flags, outp);\n\tBCOPY(str, outp, SHA_DIGESTSIZE);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n#endif /* USE_SRP */\n\nstatic void\neap_send_nak(esp, id, type)\neap_state *esp;\nu_char id;\nu_char type;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n\n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char);\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_NAK, outp);\n\tPUTCHAR(type, outp);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n#ifdef USE_SRP\nstatic char *\nname_of_pn_file()\n{\n\tchar *user, *path, *file;\n\tstruct passwd *pw;\n\tsize_t pl;\n\tstatic bool pnlogged = 0;\n\n\tpw = getpwuid(getuid());\n\tif (pw == NULL || (user = pw->pw_dir) == NULL || user[0] == 0) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\tfile = _PATH_PSEUDONYM;\n\tpl = strlen(user) + strlen(file) + 2;\n\tpath = malloc(pl);\n\tif (path == NULL)\n\t\treturn (NULL);\n\t(void) slprintf(path, pl, \"%s/%s\", user, file);\n\tif (!pnlogged) {\n\t\tdbglog(\"pseudonym file: %s\", path);\n\t\tpnlogged = 1;\n\t}\n\treturn (path);\n}\n\nstatic int\nopen_pn_file(modebits)\nmode_t modebits;\n{\n\tchar *path;\n\tint fd, err;\n\n\tif ((path = name_of_pn_file()) == NULL)\n\t\treturn (-1);\n\tfd = open(path, modebits, S_IRUSR | S_IWUSR);\n\terr = errno;\n\tfree(path);\n\terrno = err;\n\treturn (fd);\n}\n\nstatic void\nremove_pn_file()\n{\n\tchar *path;\n\n\tif ((path = name_of_pn_file()) != NULL) {\n\t\t(void) unlink(path);\n\t\t(void) free(path);\n\t}\n}\n\nstatic void\nwrite_pseudonym(esp, inp, len, id)\neap_state *esp;\nu_char *inp;\nint len, id;\n{\n\tu_char val;\n\tu_char *datp, *digp;\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\tint dsize, fd, olen = len;\n\n\t/*\n\t * Do the decoding by working backwards.  This eliminates the need\n\t * to save the decoded output in a separate buffer.\n\t */\n\tval = id;\n\twhile (len > 0) {\n\t\tif ((dsize = len % SHA_DIGESTSIZE) == 0)\n\t\t\tdsize = SHA_DIGESTSIZE;\n\t\tlen -= dsize;\n\t\tdatp = inp + len;\n\t\tSHA1Init(&ctxt);\n\t\tSHA1Update(&ctxt, &val, 1);\n\t\tSHA1Update(&ctxt, esp->es_client.ea_skey, SESSION_KEY_LEN);\n\t\tif (len > 0) {\n\t\t\tSHA1Update(&ctxt, datp, SHA_DIGESTSIZE);\n\t\t} else {\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_name,\n\t\t\t    esp->es_client.ea_namelen);\n\t\t}\n\t\tSHA1Final(dig, &ctxt);\n\t\tfor (digp = dig; digp < dig + SHA_DIGESTSIZE; digp++)\n\t\t\t*datp++ ^= *digp;\n\t}\n\n\t/* Now check that the result is sane */\n\tif (olen <= 0 || *inp + 1 > olen) {\n\t\tdbglog(\"EAP: decoded pseudonym is unusable <%.*B>\", olen, inp);\n\t\treturn;\n\t}\n\n\t/* Save it away */\n\tfd = open_pn_file(O_WRONLY | O_CREAT | O_TRUNC);\n\tif (fd < 0) {\n\t\tdbglog(\"EAP: error saving pseudonym: %m\");\n\t\treturn;\n\t}\n\tlen = write(fd, inp + 1, *inp);\n\tif (close(fd) != -1 && len == *inp) {\n\t\tdbglog(\"EAP: saved pseudonym\");\n\t\tesp->es_usedpseudo = 0;\n\t} else {\n\t\tdbglog(\"EAP: failed to save pseudonym\");\n\t\tremove_pn_file();\n\t}\n}\n#endif /* USE_SRP */\n\n/*\n * eap_request - Receive EAP Request message (client mode).\n */\nstatic void\neap_request(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXWORDLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_client *tc;\n\tstruct t_num sval, gval, Nval, *Ap, Bval;\n\tu_char vals[2];\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\tint fd;\n#endif /* USE_SRP */\n\n\t/*\n\t * Note: we update es_client.ea_id *only if* a Response\n\t * message is being generated.  Otherwise, we leave it the\n\t * same for duplicate detection purposes.\n\t */\n\n\tesp->es_client.ea_requests++;\n\tif (esp->es_client.ea_maxrequests != 0 &&\n\t    esp->es_client.ea_requests > esp->es_client.ea_maxrequests) {\n\t\tinfo(\"EAP: received too many Request messages\");\n\t\tif (esp->es_client.ea_timeout > 0) {\n\t\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\t}\n\t\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n\t\treturn;\n\t}\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Request message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Identity prompt \\\"%.*q\\\"\", len, inp);\n#ifdef USE_SRP\n\t\tif (esp->es_usepseudo &&\n\t\t    (esp->es_usedpseudo == 0 ||\n\t\t\t(esp->es_usedpseudo == 1 &&\n\t\t\t    id == esp->es_client.ea_id))) {\n\t\t\tesp->es_usedpseudo = 1;\n\t\t\t/* Try to get a pseudonym */\n\t\t\tif ((fd = open_pn_file(O_RDONLY)) >= 0) {\n\t\t\t\tstrcpy(rhostname, SRP_PSEUDO_ID);\n\t\t\t\tlen = read(fd, rhostname + SRP_PSEUDO_LEN,\n\t\t\t\t    sizeof (rhostname) - SRP_PSEUDO_LEN);\n\t\t\t\t/* XXX NAI unsupported */\n\t\t\t\tif (len > 0) {\n\t\t\t\t\teap_send_response(esp, id, typenum,\n\t\t\t\t\t    rhostname, len + SRP_PSEUDO_LEN);\n\t\t\t\t}\n\t\t\t\t(void) close(fd);\n\t\t\t\tif (len > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Stop using pseudonym now. */\n\t\tif (esp->es_usepseudo && esp->es_usedpseudo != 2) {\n\t\t\tremove_pn_file();\n\t\t\tesp->es_usedpseudo = 2;\n\t\t}\n#endif /* USE_SRP */\n\t\teap_send_response(esp, id, typenum, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Notification \\\"%.*q\\\"\", len, inp);\n\t\teap_send_response(esp, id, typenum, NULL, 0);\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\t/*\n\t\t * Avoid the temptation to send Response Nak in reply\n\t\t * to Request Nak here.  It can only lead to trouble.\n\t\t */\n\t\twarn(\"EAP: unexpected Nak in Request; ignored\");\n\t\t/* Return because we're waiting for something real. */\n\t\treturn;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Challenge with no data\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen < 8 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Challenge with bad length %d (8..%d)\",\n\t\t\t    vallen, len);\n\t\t\t/* Try something better. */\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (vallen >= len + sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating ourselves with\n\t\t * the specified host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, esp->es_client.ea_name,\n\t\t    rhostname, secret, &secret_len, 0)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth to %q\", rhostname);\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\ttypenum = id;\n\t\tMD5_Update(&mdContext, &typenum, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, inp, vallen);\n\t\tMD5_Final(hash, &mdContext);\n\t\teap_chap_response(esp, id, hash, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received empty SRP Request\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Get subtype */\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tswitch (vallen) {\n\t\tcase EAPSRP_CHALLENGE:\n\t\t\ttc = NULL;\n\t\t\tif (esp->es_client.ea_session != NULL) {\n\t\t\t\ttc = (struct t_client *)esp->es_client.\n\t\t\t\t    ea_session;\n\t\t\t\t/*\n\t\t\t\t * If this is a new challenge, then start\n\t\t\t\t * over with a new client session context.\n\t\t\t\t * Otherwise, just resend last response.\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\tt_clientclose(tc);\n\t\t\t\t\tesp->es_client.ea_session = NULL;\n\t\t\t\t\ttc = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* No session key just yet */\n\t\t\tesp->es_client.ea_skey = NULL;\n\t\t\tif (tc == NULL) {\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (name)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tBCOPY(inp, rhostname, vallen);\n\t\t\t\trhostname[vallen] = '\\0';\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * In case the remote doesn't give us his name,\n\t\t\t\t * use configured name.\n\t\t\t\t */\n\t\t\t\tif (explicit_remote ||\n\t\t\t\t    (remote_name[0] != '\\0' && vallen == 0)) {\n\t\t\t\t\tstrlcpy(rhostname, remote_name,\n\t\t\t\t\t    sizeof (rhostname));\n\t\t\t\t}\n\n\t\t\t\tif (esp->es_client.ea_peer != NULL)\n\t\t\t\t\tfree(esp->es_client.ea_peer);\n\t\t\t\tesp->es_client.ea_peer = strdup(rhostname);\n\t\t\t\tesp->es_client.ea_peerlen = strlen(rhostname);\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (s)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsval.data = inp;\n\t\t\t\tsval.len = vallen;\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen > len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (g)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* If no generator present, then use value 2 */\n\t\t\t\tif (vallen == 0) {\n\t\t\t\t\tgval.data = (u_char *)\"\\002\";\n\t\t\t\t\tgval.len = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgval.data = inp;\n\t\t\t\t\tgval.len = vallen;\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * If no modulus present, then use well-known\n\t\t\t\t * value.\n\t\t\t\t */\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tNval.data = (u_char *)wkmodulus;\n\t\t\t\t\tNval.len = sizeof (wkmodulus);\n\t\t\t\t} else {\n\t\t\t\t\tNval.data = inp;\n\t\t\t\t\tNval.len = len;\n\t\t\t\t}\n\t\t\t\ttc = t_clientopen(esp->es_client.ea_name,\n\t\t\t\t    &Nval, &gval, &sval);\n\t\t\t\tif (tc == NULL) {\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesp->es_client.ea_session = (void *)tc;\n\n\t\t\t\t/* Add Challenge ID & type to verifier */\n\t\t\t\tvals[0] = id;\n\t\t\t\tvals[1] = EAPT_SRP;\n\t\t\t\tt_clientaddexdata(tc, vals, 2);\n\t\t\t}\n\t\t\tAp = t_clientgenexp(tc);\n\t\t\teap_srp_response(esp, id, EAPSRP_CKEY, Ap->data,\n\t\t\t    Ap->len);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SKEY:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 2 without 1\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (esp->es_client.ea_skey != NULL) {\n\t\t\t\t/*\n\t\t\t\t * ID number should not change here.  Warn\n\t\t\t\t * if it does (but otherwise ignore).\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 2 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (get_srp_secret(esp->es_unit,\n\t\t\t\t    esp->es_client.ea_name,\n\t\t\t\t    esp->es_client.ea_peer, secret, 0) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can't work with this peer because\n\t\t\t\t\t * the secret is missing.  Just give\n\t\t\t\t\t * up.\n\t\t\t\t\t */\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBval.data = inp;\n\t\t\t\tBval.len = len;\n\t\t\t\tt_clientpasswd(tc, secret);\n\t\t\t\tBZERO(secret, sizeof (secret));\n\t\t\t\tesp->es_client.ea_skey =\n\t\t\t\t    t_clientgetkey(tc, &Bval);\n\t\t\t\tif (esp->es_client.ea_skey == NULL) {\n\t\t\t\t\t/* Server is rogue; stop now */\n\t\t\t\t\terror(\"EAP: SRP server is rogue\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t}\n\t\t\teap_srpval_response(esp, id, SRPVAL_EBIT,\n\t\t\t    t_clientresponse(tc));\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SVALIDATOR:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL || esp->es_client.ea_skey == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 3 without 1/2\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we're already open, then this ought to be a\n\t\t\t * duplicate.  Otherwise, check that the server is\n\t\t\t * who we think it is.\n\t\t\t */\n\t\t\tif (esp->es_client.ea_state == eapOpen) {\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 3 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen -= sizeof (u_int32_t) + SHA_DIGESTSIZE;\n\t\t\t\tif (len < 0 || t_clientverify(tc, inp +\n\t\t\t\t\tsizeof (u_int32_t)) != 0) {\n\t\t\t\t\terror(\"EAP: SRP server verification \"\n\t\t\t\t\t    \"failed\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t\tGETLONG(esp->es_client.ea_keyflags, inp);\n\t\t\t\t/* Save pseudonym if user wants it. */\n\t\t\t\tif (len > 0 && esp->es_usepseudo) {\n\t\t\t\t\tINCPTR(SHA_DIGESTSIZE, inp);\n\t\t\t\t\twrite_pseudonym(esp, inp, len, id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * We've verified our peer.  We're now mostly done,\n\t\t\t * except for waiting on the regular EAP Success\n\t\t\t * message.\n\t\t\t */\n\t\t\teap_srp_response(esp, id, EAPSRP_ACK, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (len < 4) {\n\t\t\t\twarn(\"EAP: malformed Lightweight rechallenge\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvals[0] = id;\n\t\t\tSHA1Update(&ctxt, vals, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, inp, len);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_name,\n\t\t\t    esp->es_client.ea_namelen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\teap_srp_response(esp, id, EAPSRP_LWRECHALLENGE, dig,\n\t\t\t    SHA_DIGESTSIZE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror(\"EAP: unknown SRP Subtype %d\", vallen);\n\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\tinfo(\"EAP: unknown authentication type %d; Naking\", typenum);\n\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\tbreak;\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\tTIMEOUT(eap_client_timeout, (void *)esp,\n\t\t    esp->es_client.ea_timeout);\n\t}\n\treturn;\n\n#ifdef USE_SRP\nclient_failure:\n\tesp->es_client.ea_state = eapBadAuth;\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\tesp->es_client.ea_session = NULL;\n\tt_clientclose(tc);\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n#endif /* USE_SRP */\n}\n\n/*\n * eap_response - Receive EAP Response message (server mode).\n */\nstatic void\neap_response(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXSECRETLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_server *ts;\n\tstruct t_num A;\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n#endif /* USE_SRP */\n\n\tif (esp->es_server.ea_id != id) {\n\t\tdbglog(\"EAP: discarding Response %d; expected ID %d\", id,\n\t\t    esp->es_server.ea_id);\n\t\treturn;\n\t}\n\n\tesp->es_server.ea_responses++;\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Response message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (esp->es_server.ea_state != eapIdentify) {\n\t\t\tdbglog(\"EAP discarding unwanted Identify \\\"%.q\\\"\", len,\n\t\t\t    inp);\n\t\t\tbreak;\n\t\t}\n\t\tinfo(\"EAP: unauthenticated peer name \\\"%.*q\\\"\", len, inp);\n\t\tif (esp->es_server.ea_peer != NULL &&\n\t\t    esp->es_server.ea_peer != remote_name)\n\t\t\tfree(esp->es_server.ea_peer);\n\t\tesp->es_server.ea_peer = malloc(len + 1);\n\t\tif (esp->es_server.ea_peer == NULL) {\n\t\t\tesp->es_server.ea_peerlen = 0;\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tBCOPY(inp, esp->es_server.ea_peer, len);\n\t\tesp->es_server.ea_peer[len] = '\\0';\n\t\tesp->es_server.ea_peerlen = len;\n\t\teap_figure_next_state(esp, 0);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tdbglog(\"EAP unexpected Notification; response discarded\");\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\tif (len < 1) {\n\t\t\tinfo(\"EAP: Nak Response with no suggested protocol\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\n\t\tif (!explicit_remote && esp->es_server.ea_state == eapIdentify){\n\t\t\t/* Peer cannot Nak Identify Request */\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (vallen) {\n\t\tcase EAPT_SRP:\n\t\t\t/* Run through SRP validator selection again. */\n\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdbglog(\"EAP: peer requesting unknown Type %d\", vallen);\n\t\t\tswitch (esp->es_server.ea_state) {\n\t\t\tcase eapSRP1:\n\t\t\tcase eapSRP2:\n\t\t\tcase eapSRP3:\n\t\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\t\tbreak;\n\t\t\tcase eapMD5Chall:\n\t\t\tcase eapSRP4:\n\t\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (esp->es_server.ea_state != eapMD5Chall) {\n\t\t\terror(\"EAP: unexpected MD5-Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Response with no data\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen != 16 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Response with bad length %d\", vallen);\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (vallen >= len + sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating the specified\n\t\t * host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, rhostname,\n\t\t    esp->es_server.ea_name, secret, &secret_len, 1)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth of %q\", rhostname);\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\tMD5_Update(&mdContext, &esp->es_server.ea_id, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, esp->es_challenge, esp->es_challen);\n\t\tMD5_Final(hash, &mdContext);\n\t\tif (BCMP(hash, inp, MD5_SIGNATURE_SIZE) != 0) {\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tesp->es_server.ea_type = EAPT_MD5CHAP;\n\t\teap_send_success(esp);\n\t\teap_figure_next_state(esp, 0);\n\t\tif (esp->es_rechallenge != 0)\n\t\t\tTIMEOUT(eap_rechallenge, esp, esp->es_rechallenge);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: empty SRP Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(typenum, inp);\n\t\tlen--;\n\t\tswitch (typenum) {\n\t\tcase EAPSRP_CKEY:\n\t\t\tif (esp->es_server.ea_state != eapSRP1) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 1 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tA.data = inp;\n\t\t\tA.len = len;\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tesp->es_server.ea_skey = t_servergetkey(ts, &A);\n\t\t\tif (esp->es_server.ea_skey == NULL) {\n\t\t\t\t/* Client's A value is bogus; terminate now */\n\t\t\t\terror(\"EAP: bogus A value from client\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t} else {\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPSRP_CVALIDATOR:\n\t\t\tif (esp->es_server.ea_state != eapSRP2) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 2 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len < sizeof (u_int32_t) + SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: M1 length %d < %d\", len,\n\t\t\t\t    sizeof (u_int32_t) + SHA_DIGESTSIZE);\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETLONG(esp->es_server.ea_keyflags, inp);\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tif (t_serververify(ts, inp)) {\n\t\t\t\tinfo(\"EAP: unable to validate client identity\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_ACK:\n\t\t\tif (esp->es_server.ea_state != eapSRP3) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 3 Response\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_type = EAPT_SRP;\n\t\t\teap_send_success(esp);\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tif (esp->es_rechallenge != 0)\n\t\t\t\tTIMEOUT(eap_rechallenge, esp,\n\t\t\t\t    esp->es_rechallenge);\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (esp->es_server.ea_state != eapSRP4) {\n\t\t\t\tinfo(\"EAP: unexpected SRP Subtype 4 Response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (len != SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: bad Lightweight rechallenge \"\n\t\t\t\t    \"response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvallen = id;\n\t\t\tSHA1Update(&ctxt, &vallen, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, esp->es_challenge, esp->es_challen);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_peer,\n\t\t\t    esp->es_server.ea_peerlen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\tif (BCMP(dig, inp, SHA_DIGESTSIZE) != 0) {\n\t\t\t\terror(\"EAP: failed Lightweight rechallenge\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\t/* This can't happen. */\n\t\terror(\"EAP: unknown Response type %d; ignored\", typenum);\n\t\treturn;\n\t}\n\n\tif (esp->es_server.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_server_timeout, (void *)esp);\n\t}\n\n\tif (esp->es_server.ea_state != eapBadAuth &&\n\t    esp->es_server.ea_state != eapOpen) {\n\t\tesp->es_server.ea_id++;\n\t\teap_send_request(esp);\n\t}\n}\n\n/*\n * eap_success - Receive EAP Success message (client mode).\n */\nstatic void\neap_success(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tif (esp->es_client.ea_state != eapOpen && !eap_client_active(esp)) {\n\t\tdbglog(\"EAP unexpected success message in state %s (%d)\",\n\t\t    eap_state_name(esp->es_client.ea_state),\n\t\t    esp->es_client.ea_state);\n\t\treturn;\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\n\tif (len > 0) {\n\t\t/* This is odd.  The spec doesn't allow for this. */\n\t\tPRINTMSG(inp, len);\n\t}\n\n\tesp->es_client.ea_state = eapOpen;\n\tauth_withpeer_success(esp->es_unit, PPP_EAP, 0);\n}\n\n/*\n * eap_failure - Receive EAP Failure message (client mode).\n */\nstatic void\neap_failure(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tif (!eap_client_active(esp)) {\n\t\tdbglog(\"EAP unexpected failure message in state %s (%d)\",\n\t\t    eap_state_name(esp->es_client.ea_state),\n\t\t    esp->es_client.ea_state);\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\n\tif (len > 0) {\n\t\t/* This is odd.  The spec doesn't allow for this. */\n\t\tPRINTMSG(inp, len);\n\t}\n\n\tesp->es_client.ea_state = eapBadAuth;\n\n\terror(\"EAP: peer reports authentication failure\");\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n}\n\n/*\n * eap_input - Handle received EAP message.\n */\nstatic void\neap_input(unit, inp, inlen)\nint unit;\nu_char *inp;\nint inlen;\n{\n\teap_state *esp = &eap_states[unit];\n\tu_char code, id;\n\tint len;\n\n\t/*\n\t * Parse header (code, id and length).  If packet too short,\n\t * drop it.\n\t */\n\tif (inlen < EAP_HEADERLEN) {\n\t\terror(\"EAP: packet too short: %d < %d\", inlen, EAP_HEADERLEN);\n\t\treturn;\n\t}\n\tGETCHAR(code, inp);\n\tGETCHAR(id, inp);\n\tGETSHORT(len, inp);\n\tif (len < EAP_HEADERLEN || len > inlen) {\n\t\terror(\"EAP: packet has illegal length field %d (%d..%d)\", len,\n\t\t    EAP_HEADERLEN, inlen);\n\t\treturn;\n\t}\n\tlen -= EAP_HEADERLEN;\n\n\t/* Dispatch based on message code */\n\tswitch (code) {\n\tcase EAP_REQUEST:\n\t\teap_request(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_RESPONSE:\n\t\teap_response(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_SUCCESS:\n\t\teap_success(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_FAILURE:\n\t\teap_failure(esp, inp, id, len);\n\t\tbreak;\n\n\tdefault:\t\t\t\t/* XXX Need code reject */\n\t\t/* Note: it's not legal to send EAP Nak here. */\n\t\twarn(\"EAP: unknown code %d received\", code);\n\t\tbreak;\n\t}\n}\n\n/*\n * eap_printpkt - print the contents of an EAP packet.\n */\nstatic char *eap_codenames[] = {\n\t\"Request\", \"Response\", \"Success\", \"Failure\"\n};\n\nstatic char *eap_typenames[] = {\n\t\"Identity\", \"Notification\", \"Nak\", \"MD5-Challenge\",\n\t\"OTP\", \"Generic-Token\", NULL, NULL,\n\t\"RSA\", \"DSS\", \"KEA\", \"KEA-Validate\",\n\t\"TLS\", \"Defender\", \"Windows 2000\", \"Arcot\",\n\t\"Cisco\", \"Nokia\", \"SRP\"\n};\n\nstatic int\neap_printpkt(inp, inlen, printer, arg)\nu_char *inp;\nint inlen;\nvoid (*printer) __P((void *, char *, ...));\nvoid *arg;\n{\n\tint code, id, len, rtype, vallen;\n\tu_char *pstart;\n\tu_int32_t uval;\n\n\tif (inlen < EAP_HEADERLEN)\n\t\treturn (0);\n\tpstart = inp;\n\tGETCHAR(code, inp);\n\tGETCHAR(id, inp);\n\tGETSHORT(len, inp);\n\tif (len < EAP_HEADERLEN || len > inlen)\n\t\treturn (0);\n\n\tif (code >= 1 && code <= sizeof(eap_codenames) / sizeof(char *))\n\t\tprinter(arg, \" %s\", eap_codenames[code-1]);\n\telse\n\t\tprinter(arg, \" code=0x%x\", code);\n\tprinter(arg, \" id=0x%x\", id);\n\tlen -= EAP_HEADERLEN;\n\tswitch (code) {\n\tcase EAP_REQUEST:\n\t\tif (len < 1) {\n\t\t\tprinter(arg, \" <missing type>\");\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(rtype, inp);\n\t\tlen--;\n\t\tif (rtype >= 1 &&\n\t\t    rtype <= sizeof (eap_typenames) / sizeof (char *))\n\t\t\tprinter(arg, \" %s\", eap_typenames[rtype-1]);\n\t\telse\n\t\t\tprinter(arg, \" type=0x%x\", rtype);\n\t\tswitch (rtype) {\n\t\tcase EAPT_IDENTITY:\n\t\tcase EAPT_NOTIFICATION:\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Message \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No message>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tif (vallen > len)\n\t\t\t\tgoto truncated;\n\t\t\tprinter(arg, \" <Value%.*B>\", vallen, inp);\n\t\t\tINCPTR(vallen, inp);\n\t\t\tlen -= vallen;\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_SRP:\n\t\t\tif (len < 3)\n\t\t\t\tgoto truncated;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \"-%d\", vallen);\n\t\t\tswitch (vallen) {\n\t\t\tcase EAPSRP_CHALLENGE:\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tif (vallen > 0) {\n\t\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\t\tprint_string((char *)inp, vallen, printer,\n\t\t\t\t\t    arg);\n\t\t\t\t\tprinter(arg, \">\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tprinter(arg, \" <s%.*B>\", vallen, inp);\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen > len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tif (vallen == 0) {\n\t\t\t\t\tprinter(arg, \" <Default g=2>\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <g%.*B>\", vallen, inp);\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tprinter(arg, \" <Default N>\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <N%.*B>\", len, inp);\n\t\t\t\t\tINCPTR(len, inp);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_SKEY:\n\t\t\t\tprinter(arg, \" <B%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_SVALIDATOR:\n\t\t\t\tif (len < sizeof (u_int32_t))\n\t\t\t\t\tbreak;\n\t\t\t\tGETLONG(uval, inp);\n\t\t\t\tlen -= sizeof (u_int32_t);\n\t\t\t\tif (uval & SRPVAL_EBIT) {\n\t\t\t\t\tprinter(arg, \" E\");\n\t\t\t\t\tuval &= ~SRPVAL_EBIT;\n\t\t\t\t}\n\t\t\t\tif (uval != 0) {\n\t\t\t\t\tprinter(arg, \" f<%X>\", uval);\n\t\t\t\t}\n\t\t\t\tif ((vallen = len) > SHA_DIGESTSIZE)\n\t\t\t\t\tvallen = SHA_DIGESTSIZE;\n\t\t\t\tprinter(arg, \" <M2%.*B%s>\", len, inp,\n\t\t\t\t    len < SHA_DIGESTSIZE ? \"?\" : \"\");\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tprinter(arg, \" <PN%.*B>\", len, inp);\n\t\t\t\t\tINCPTR(len, inp);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\t\tprinter(arg, \" <Challenge%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAP_RESPONSE:\n\t\tif (len < 1)\n\t\t\tbreak;\n\t\tGETCHAR(rtype, inp);\n\t\tlen--;\n\t\tif (rtype >= 1 &&\n\t\t    rtype <= sizeof (eap_typenames) / sizeof (char *))\n\t\t\tprinter(arg, \" %s\", eap_typenames[rtype-1]);\n\t\telse\n\t\t\tprinter(arg, \" type=0x%x\", rtype);\n\t\tswitch (rtype) {\n\t\tcase EAPT_IDENTITY:\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_NAK:\n\t\t\tif (len <= 0) {\n\t\t\t\tprinter(arg, \" <missing hint>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETCHAR(rtype, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \" <Suggested-type %02X\", rtype);\n\t\t\tif (rtype >= 1 &&\n\t\t\t    rtype < sizeof (eap_typenames) / sizeof (char *))\n\t\t\t\tprinter(arg, \" (%s)\", eap_typenames[rtype-1]);\n\t\t\tprinter(arg, \">\");\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tif (len <= 0) {\n\t\t\t\tprinter(arg, \" <missing length>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tif (vallen > len)\n\t\t\t\tgoto truncated;\n\t\t\tprinter(arg, \" <Value%.*B>\", vallen, inp);\n\t\t\tINCPTR(vallen, inp);\n\t\t\tlen -= vallen;\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_SRP:\n\t\t\tif (len < 1)\n\t\t\t\tgoto truncated;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \"-%d\", vallen);\n\t\t\tswitch (vallen) {\n\t\t\tcase EAPSRP_CKEY:\n\t\t\t\tprinter(arg, \" <A%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_CVALIDATOR:\n\t\t\t\tif (len < sizeof (u_int32_t))\n\t\t\t\t\tbreak;\n\t\t\t\tGETLONG(uval, inp);\n\t\t\t\tlen -= sizeof (u_int32_t);\n\t\t\t\tif (uval & SRPVAL_EBIT) {\n\t\t\t\t\tprinter(arg, \" E\");\n\t\t\t\t\tuval &= ~SRPVAL_EBIT;\n\t\t\t\t}\n\t\t\t\tif (uval != 0) {\n\t\t\t\t\tprinter(arg, \" f<%X>\", uval);\n\t\t\t\t}\n\t\t\t\tprinter(arg, \" <M1%.*B%s>\", len, inp,\n\t\t\t\t    len == SHA_DIGESTSIZE ? \"\" : \"?\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_ACK:\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\t\tprinter(arg, \" <Response%.*B%s>\", len, inp,\n\t\t\t\t    len == SHA_DIGESTSIZE ? \"\" : \"?\");\n\t\t\t\tif ((vallen = len) > SHA_DIGESTSIZE)\n\t\t\t\t\tvallen = SHA_DIGESTSIZE;\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAP_SUCCESS:\t/* No payload expected for these! */\n\tcase EAP_FAILURE:\n\t\tbreak;\n\n\ttruncated:\n\t\tprinter(arg, \" <truncated>\");\n\t\tbreak;\n\t}\n\n\tif (len > 8)\n\t\tprinter(arg, \"%8B...\", inp);\n\telse if (len > 0)\n\t\tprinter(arg, \"%.*B\", len, inp);\n\tINCPTR(len, inp);\n\n\treturn (inp - pstart);\n}\n"], "fixing_code": ["/*\n * eap.c - Extensible Authentication Protocol for PPP (RFC 2284)\n *\n * Copyright (c) 2001 by Sun Microsystems, Inc.\n * All rights reserved.\n *\n * Non-exclusive rights to redistribute, modify, translate, and use\n * this software in source and binary forms, in whole or in part, is\n * hereby granted, provided that the above copyright notice is\n * duplicated in any source form, and that neither the name of the\n * copyright holder nor the author is used to endorse or promote\n * products derived from this software.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Original version by James Carlson\n *\n * This implementation of EAP supports MD5-Challenge and SRP-SHA1\n * authentication styles.  Note that support of MD5-Challenge is a\n * requirement of RFC 2284, and that it's essentially just a\n * reimplementation of regular RFC 1994 CHAP using EAP messages.\n *\n * As an authenticator (\"server\"), there are multiple phases for each\n * style.  In the first phase of each style, the unauthenticated peer\n * name is queried using the EAP Identity request type.  If the\n * \"remotename\" option is used, then this phase is skipped, because\n * the peer's name is presumed to be known.\n *\n * For MD5-Challenge, there are two phases, and the second phase\n * consists of sending the challenge itself and handling the\n * associated response.\n *\n * For SRP-SHA1, there are four phases.  The second sends 's', 'N',\n * and 'g'.  The reply contains 'A'.  The third sends 'B', and the\n * reply contains 'M1'.  The forth sends the 'M2' value.\n *\n * As an authenticatee (\"client\"), there's just a single phase --\n * responding to the queries generated by the peer.  EAP is an\n * authenticator-driven protocol.\n *\n * Based on draft-ietf-pppext-eap-srp-03.txt.\n */\n\n#define RCSID\t\"$Id: eap.c,v 1.4 2004/11/09 22:39:25 paulus Exp $\"\n\n/*\n * TODO:\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <errno.h>\n\n#include \"pppd.h\"\n#include \"pathnames.h\"\n#include \"md5.h\"\n#include \"eap.h\"\n\n#ifdef USE_SRP\n#include <t_pwd.h>\n#include <t_server.h>\n#include <t_client.h>\n#include \"pppcrypt.h\"\n#endif /* USE_SRP */\n\n#ifndef SHA_DIGESTSIZE\n#define\tSHA_DIGESTSIZE 20\n#endif\n\n\neap_state eap_states[NUM_PPP];\t\t/* EAP state; one for each unit */\n#ifdef USE_SRP\nstatic char *pn_secret = NULL;\t\t/* Pseudonym generating secret */\n#endif\n\n/*\n * Command-line options.\n */\nstatic option_t eap_option_list[] = {\n    { \"eap-restart\", o_int, &eap_states[0].es_server.ea_timeout,\n      \"Set retransmit timeout for EAP Requests (server)\" },\n    { \"eap-max-sreq\", o_int, &eap_states[0].es_server.ea_maxrequests,\n      \"Set max number of EAP Requests sent (server)\" },\n    { \"eap-timeout\", o_int, &eap_states[0].es_client.ea_timeout,\n      \"Set time limit for peer EAP authentication\" },\n    { \"eap-max-rreq\", o_int, &eap_states[0].es_client.ea_maxrequests,\n      \"Set max number of EAP Requests allows (client)\" },\n    { \"eap-interval\", o_int, &eap_states[0].es_rechallenge,\n      \"Set interval for EAP rechallenge\" },\n#ifdef USE_SRP\n    { \"srp-interval\", o_int, &eap_states[0].es_lwrechallenge,\n      \"Set interval for SRP lightweight rechallenge\" },\n    { \"srp-pn-secret\", o_string, &pn_secret,\n      \"Long term pseudonym generation secret\" },\n    { \"srp-use-pseudonym\", o_bool, &eap_states[0].es_usepseudo,\n      \"Use pseudonym if offered one by server\", 1 },\n#endif\n    { NULL }\n};\n\n/*\n * Protocol entry points.\n */\nstatic void eap_init __P((int unit));\nstatic void eap_input __P((int unit, u_char *inp, int inlen));\nstatic void eap_protrej __P((int unit));\nstatic void eap_lowerup __P((int unit));\nstatic void eap_lowerdown __P((int unit));\nstatic int  eap_printpkt __P((u_char *inp, int inlen,\n    void (*)(void *arg, char *fmt, ...), void *arg));\n\nstruct protent eap_protent = {\n\tPPP_EAP,\t\t/* protocol number */\n\teap_init,\t\t/* initialization procedure */\n\teap_input,\t\t/* process a received packet */\n\teap_protrej,\t\t/* process a received protocol-reject */\n\teap_lowerup,\t\t/* lower layer has gone up */\n\teap_lowerdown,\t\t/* lower layer has gone down */\n\tNULL,\t\t\t/* open the protocol */\n\tNULL,\t\t\t/* close the protocol */\n\teap_printpkt,\t\t/* print a packet in readable form */\n\tNULL,\t\t\t/* process a received data packet */\n\t1,\t\t\t/* protocol enabled */\n\t\"EAP\",\t\t\t/* text name of protocol */\n\tNULL,\t\t\t/* text name of corresponding data protocol */\n\teap_option_list,\t/* list of command-line options */\n\tNULL,\t\t\t/* check requested options; assign defaults */\n\tNULL,\t\t\t/* configure interface for demand-dial */\n\tNULL\t\t\t/* say whether to bring up link for this pkt */\n};\n\n/*\n * A well-known 2048 bit modulus.\n */\nstatic const u_char wkmodulus[] = {\n\t0xAC, 0x6B, 0xDB, 0x41, 0x32, 0x4A, 0x9A, 0x9B,\n\t0xF1, 0x66, 0xDE, 0x5E, 0x13, 0x89, 0x58, 0x2F,\n\t0xAF, 0x72, 0xB6, 0x65, 0x19, 0x87, 0xEE, 0x07,\n\t0xFC, 0x31, 0x92, 0x94, 0x3D, 0xB5, 0x60, 0x50,\n\t0xA3, 0x73, 0x29, 0xCB, 0xB4, 0xA0, 0x99, 0xED,\n\t0x81, 0x93, 0xE0, 0x75, 0x77, 0x67, 0xA1, 0x3D,\n\t0xD5, 0x23, 0x12, 0xAB, 0x4B, 0x03, 0x31, 0x0D,\n\t0xCD, 0x7F, 0x48, 0xA9, 0xDA, 0x04, 0xFD, 0x50,\n\t0xE8, 0x08, 0x39, 0x69, 0xED, 0xB7, 0x67, 0xB0,\n\t0xCF, 0x60, 0x95, 0x17, 0x9A, 0x16, 0x3A, 0xB3,\n\t0x66, 0x1A, 0x05, 0xFB, 0xD5, 0xFA, 0xAA, 0xE8,\n\t0x29, 0x18, 0xA9, 0x96, 0x2F, 0x0B, 0x93, 0xB8,\n\t0x55, 0xF9, 0x79, 0x93, 0xEC, 0x97, 0x5E, 0xEA,\n\t0xA8, 0x0D, 0x74, 0x0A, 0xDB, 0xF4, 0xFF, 0x74,\n\t0x73, 0x59, 0xD0, 0x41, 0xD5, 0xC3, 0x3E, 0xA7,\n\t0x1D, 0x28, 0x1E, 0x44, 0x6B, 0x14, 0x77, 0x3B,\n\t0xCA, 0x97, 0xB4, 0x3A, 0x23, 0xFB, 0x80, 0x16,\n\t0x76, 0xBD, 0x20, 0x7A, 0x43, 0x6C, 0x64, 0x81,\n\t0xF1, 0xD2, 0xB9, 0x07, 0x87, 0x17, 0x46, 0x1A,\n\t0x5B, 0x9D, 0x32, 0xE6, 0x88, 0xF8, 0x77, 0x48,\n\t0x54, 0x45, 0x23, 0xB5, 0x24, 0xB0, 0xD5, 0x7D,\n\t0x5E, 0xA7, 0x7A, 0x27, 0x75, 0xD2, 0xEC, 0xFA,\n\t0x03, 0x2C, 0xFB, 0xDB, 0xF5, 0x2F, 0xB3, 0x78,\n\t0x61, 0x60, 0x27, 0x90, 0x04, 0xE5, 0x7A, 0xE6,\n\t0xAF, 0x87, 0x4E, 0x73, 0x03, 0xCE, 0x53, 0x29,\n\t0x9C, 0xCC, 0x04, 0x1C, 0x7B, 0xC3, 0x08, 0xD8,\n\t0x2A, 0x56, 0x98, 0xF3, 0xA8, 0xD0, 0xC3, 0x82,\n\t0x71, 0xAE, 0x35, 0xF8, 0xE9, 0xDB, 0xFB, 0xB6,\n\t0x94, 0xB5, 0xC8, 0x03, 0xD8, 0x9F, 0x7A, 0xE4,\n\t0x35, 0xDE, 0x23, 0x6D, 0x52, 0x5F, 0x54, 0x75,\n\t0x9B, 0x65, 0xE3, 0x72, 0xFC, 0xD6, 0x8E, 0xF2,\n\t0x0F, 0xA7, 0x11, 0x1F, 0x9E, 0x4A, 0xFF, 0x73\n};\n\n/* Local forward declarations. */\nstatic void eap_server_timeout __P((void *arg));\n\n/*\n * Convert EAP state code to printable string for debug.\n */\nstatic const char *\neap_state_name(esc)\nenum eap_state_code esc;\n{\n\tstatic const char *state_names[] = { EAP_STATES };\n\n\treturn (state_names[(int)esc]);\n}\n\n/*\n * eap_init - Initialize state for an EAP user.  This is currently\n * called once by main() during start-up.\n */\nstatic void\neap_init(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tBZERO(esp, sizeof (*esp));\n\tesp->es_unit = unit;\n\tesp->es_server.ea_timeout = EAP_DEFTIMEOUT;\n\tesp->es_server.ea_maxrequests = EAP_DEFTRANSMITS;\n\tesp->es_server.ea_id = (u_char)(drand48() * 0x100);\n\tesp->es_client.ea_timeout = EAP_DEFREQTIME;\n\tesp->es_client.ea_maxrequests = EAP_DEFALLOWREQ;\n}\n\n/*\n * eap_client_timeout - Give up waiting for the peer to send any\n * Request messages.\n */\nstatic void\neap_client_timeout(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *) arg;\n\n\tif (!eap_client_active(esp))\n\t\treturn;\n\n\terror(\"EAP: timeout waiting for Request from peer\");\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n\tesp->es_client.ea_state = eapBadAuth;\n}\n\n/*\n * eap_authwithpeer - Authenticate to our peer (behave as client).\n *\n * Start client state and wait for requests.  This is called only\n * after eap_lowerup.\n */\nvoid\neap_authwithpeer(unit, localname)\nint unit;\nchar *localname;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Save the peer name we're given */\n\tesp->es_client.ea_name = localname;\n\tesp->es_client.ea_namelen = strlen(localname);\n\n\tesp->es_client.ea_state = eapListen;\n\n\t/*\n\t * Start a timer so that if the other end just goes\n\t * silent, we don't sit here waiting forever.\n\t */\n\tif (esp->es_client.ea_timeout > 0)\n\t\tTIMEOUT(eap_client_timeout, (void *)esp,\n\t\t    esp->es_client.ea_timeout);\n}\n\n/*\n * Format a standard EAP Failure message and send it to the peer.\n * (Server operation)\n */\nstatic void\neap_send_failure(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_FAILURE, outp);\n\tesp->es_server.ea_id++;\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tPUTSHORT(EAP_HEADERLEN, outp);\n\n\toutput(esp->es_unit, outpacket_buf, EAP_HEADERLEN + PPP_HDRLEN);\n\n\tesp->es_server.ea_state = eapBadAuth;\n\tauth_peer_fail(esp->es_unit, PPP_EAP);\n}\n\n/*\n * Format a standard EAP Success message and send it to the peer.\n * (Server operation)\n */\nstatic void\neap_send_success(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_SUCCESS, outp);\n\tesp->es_server.ea_id++;\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tPUTSHORT(EAP_HEADERLEN, outp);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + EAP_HEADERLEN);\n\n\tauth_peer_success(esp->es_unit, PPP_EAP, 0,\n\t    esp->es_server.ea_peer, esp->es_server.ea_peerlen);\n}\n\n#ifdef USE_SRP\n/*\n * Set DES key according to pseudonym-generating secret and current\n * date.\n */\nstatic bool\npncrypt_setkey(int timeoffs)\n{\n\tstruct tm *tp;\n\tchar tbuf[9];\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\ttime_t reftime;\n\n\tif (pn_secret == NULL)\n\t\treturn (0);\n\treftime = time(NULL) + timeoffs;\n\ttp = localtime(&reftime);\n\tSHA1Init(&ctxt);\n\tSHA1Update(&ctxt, pn_secret, strlen(pn_secret));\n\tstrftime(tbuf, sizeof (tbuf), \"%Y%m%d\", tp);\n\tSHA1Update(&ctxt, tbuf, strlen(tbuf));\n\tSHA1Final(dig, &ctxt);\n\treturn (DesSetkey(dig));\n}\n\nstatic char base64[] =\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstruct b64state {\n\tu_int32_t bs_bits;\n\tint bs_offs;\n};\n\nstatic int\nb64enc(bs, inp, inlen, outp)\nstruct b64state *bs;\nu_char *inp;\nint inlen;\nu_char *outp;\n{\n\tint outlen = 0;\n\n\twhile (inlen > 0) {\n\t\tbs->bs_bits = (bs->bs_bits << 8) | *inp++;\n\t\tinlen--;\n\t\tbs->bs_offs += 8;\n\t\tif (bs->bs_offs >= 24) {\n\t\t\t*outp++ = base64[(bs->bs_bits >> 18) & 0x3F];\n\t\t\t*outp++ = base64[(bs->bs_bits >> 12) & 0x3F];\n\t\t\t*outp++ = base64[(bs->bs_bits >> 6) & 0x3F];\n\t\t\t*outp++ = base64[bs->bs_bits & 0x3F];\n\t\t\toutlen += 4;\n\t\t\tbs->bs_offs = 0;\n\t\t\tbs->bs_bits = 0;\n\t\t}\n\t}\n\treturn (outlen);\n}\n\nstatic int\nb64flush(bs, outp)\nstruct b64state *bs;\nu_char *outp;\n{\n\tint outlen = 0;\n\n\tif (bs->bs_offs == 8) {\n\t\t*outp++ = base64[(bs->bs_bits >> 2) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits << 4) & 0x3F];\n\t\toutlen = 2;\n\t} else if (bs->bs_offs == 16) {\n\t\t*outp++ = base64[(bs->bs_bits >> 10) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits >> 4) & 0x3F];\n\t\t*outp++ = base64[(bs->bs_bits << 2) & 0x3F];\n\t\toutlen = 3;\n\t}\n\tbs->bs_offs = 0;\n\tbs->bs_bits = 0;\n\treturn (outlen);\n}\n\nstatic int\nb64dec(bs, inp, inlen, outp)\nstruct b64state *bs;\nu_char *inp;\nint inlen;\nu_char *outp;\n{\n\tint outlen = 0;\n\tchar *cp;\n\n\twhile (inlen > 0) {\n\t\tif ((cp = strchr(base64, *inp++)) == NULL)\n\t\t\tbreak;\n\t\tbs->bs_bits = (bs->bs_bits << 6) | (cp - base64);\n\t\tinlen--;\n\t\tbs->bs_offs += 6;\n\t\tif (bs->bs_offs >= 8) {\n\t\t\t*outp++ = bs->bs_bits >> (bs->bs_offs - 8);\n\t\t\toutlen++;\n\t\t\tbs->bs_offs -= 8;\n\t\t}\n\t}\n\treturn (outlen);\n}\n#endif /* USE_SRP */\n\n/*\n * Assume that current waiting server state is complete and figure\n * next state to use based on available authentication data.  'status'\n * indicates if there was an error in handling the last query.  It is\n * 0 for success and non-zero for failure.\n */\nstatic void\neap_figure_next_state(esp, status)\neap_state *esp;\nint status;\n{\n#ifdef USE_SRP\n\tunsigned char secbuf[MAXWORDLEN], clear[8], *sp, *dp;\n\tstruct t_pw tpw;\n\tstruct t_confent *tce, mytce;\n\tchar *cp, *cp2;\n\tstruct t_server *ts;\n\tint id, i, plen, toffs;\n\tu_char vals[2];\n\tstruct b64state bs;\n#endif /* USE_SRP */\n\n\tesp->es_server.ea_timeout = esp->es_savedtime;\n\tswitch (esp->es_server.ea_state) {\n\tcase eapBadAuth:\n\t\treturn;\n\n\tcase eapIdentify:\n#ifdef USE_SRP\n\t\t/* Discard any previous session. */\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t\tbreak;\n\t\t}\n#ifdef USE_SRP\n\t\t/* If we've got a pseudonym, try to decode to real name. */\n\t\tif (esp->es_server.ea_peerlen > SRP_PSEUDO_LEN &&\n\t\t    strncmp(esp->es_server.ea_peer, SRP_PSEUDO_ID,\n\t\t\tSRP_PSEUDO_LEN) == 0 &&\n\t\t    (esp->es_server.ea_peerlen - SRP_PSEUDO_LEN) * 3 / 4 <\n\t\t    sizeof (secbuf)) {\n\t\t\tBZERO(&bs, sizeof (bs));\n\t\t\tplen = b64dec(&bs,\n\t\t\t    esp->es_server.ea_peer + SRP_PSEUDO_LEN,\n\t\t\t    esp->es_server.ea_peerlen - SRP_PSEUDO_LEN,\n\t\t\t    secbuf);\n\t\t\ttoffs = 0;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tpncrypt_setkey(toffs);\n\t\t\t\ttoffs -= 86400;\n\t\t\t\tif (!DesDecrypt(secbuf, clear)) {\n\t\t\t\t\tdbglog(\"no DES here; cannot decode \"\n\t\t\t\t\t    \"pseudonym\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tid = *(unsigned char *)clear;\n\t\t\t\tif (id + 1 <= plen && id + 9 > plen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (plen % 8 == 0 && i < 5) {\n\t\t\t\t/*\n\t\t\t\t * Note that this is always shorter than the\n\t\t\t\t * original stored string, so there's no need\n\t\t\t\t * to realloc.\n\t\t\t\t */\n\t\t\t\tif ((i = plen = *(unsigned char *)clear) > 7)\n\t\t\t\t\ti = 7;\n\t\t\t\tesp->es_server.ea_peerlen = plen;\n\t\t\t\tdp = (unsigned char *)esp->es_server.ea_peer;\n\t\t\t\tBCOPY(clear + 1, dp, i);\n\t\t\t\tplen -= i;\n\t\t\t\tdp += i;\n\t\t\t\tsp = secbuf + 8;\n\t\t\t\twhile (plen > 0) {\n\t\t\t\t\t(void) DesDecrypt(sp, dp);\n\t\t\t\t\tsp += 8;\n\t\t\t\t\tdp += 8;\n\t\t\t\t\tplen -= 8;\n\t\t\t\t}\n\t\t\t\tesp->es_server.ea_peer[\n\t\t\t\t\tesp->es_server.ea_peerlen] = '\\0';\n\t\t\t\tdbglog(\"decoded pseudonym to \\\"%.*q\\\"\",\n\t\t\t\t    esp->es_server.ea_peerlen,\n\t\t\t\t    esp->es_server.ea_peer);\n\t\t\t} else {\n\t\t\t\tdbglog(\"failed to decode real name\");\n\t\t\t\t/* Stay in eapIdentfy state; requery */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Look up user in secrets database. */\n\t\tif (get_srp_secret(esp->es_unit, esp->es_server.ea_peer,\n\t\t    esp->es_server.ea_name, (char *)secbuf, 1) != 0) {\n\t\t\t/* Set up default in case SRP entry is bad */\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\t/* Get t_confent based on index in srp-secrets */\n\t\t\tid = strtol((char *)secbuf, &cp, 10);\n\t\t\tif (*cp++ != ':' || id < 0)\n\t\t\t\tbreak;\n\t\t\tif (id == 0) {\n\t\t\t\tmytce.index = 0;\n\t\t\t\tmytce.modulus.data = (u_char *)wkmodulus;\n\t\t\t\tmytce.modulus.len = sizeof (wkmodulus);\n\t\t\t\tmytce.generator.data = (u_char *)\"\\002\";\n\t\t\t\tmytce.generator.len = 1;\n\t\t\t\ttce = &mytce;\n\t\t\t} else if ((tce = gettcid(id)) != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Client will have to verify this modulus/\n\t\t\t\t * generator combination, and that will take\n\t\t\t\t * a while.  Lengthen the timeout here.\n\t\t\t\t */\n\t\t\t\tif (esp->es_server.ea_timeout > 0 &&\n\t\t\t\t    esp->es_server.ea_timeout < 30)\n\t\t\t\t\tesp->es_server.ea_timeout = 30;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((cp2 = strchr(cp, ':')) == NULL)\n\t\t\t\tbreak;\n\t\t\t*cp2++ = '\\0';\n\t\t\ttpw.pebuf.name = esp->es_server.ea_peer;\n\t\t\ttpw.pebuf.password.len = t_fromb64((char *)tpw.pwbuf,\n\t\t\t    cp);\n\t\t\ttpw.pebuf.password.data = tpw.pwbuf;\n\t\t\ttpw.pebuf.salt.len = t_fromb64((char *)tpw.saltbuf,\n\t\t\t    cp2);\n\t\t\ttpw.pebuf.salt.data = tpw.saltbuf;\n\t\t\tif ((ts = t_serveropenraw(&tpw.pebuf, tce)) == NULL)\n\t\t\t\tbreak;\n\t\t\tesp->es_server.ea_session = (void *)ts;\n\t\t\tesp->es_server.ea_state = eapSRP1;\n\t\t\tvals[0] = esp->es_server.ea_id + 1;\n\t\t\tvals[1] = EAPT_SRP;\n\t\t\tt_serveraddexdata(ts, vals, 2);\n\t\t\t/* Generate B; must call before t_servergetkey() */\n\t\t\tt_servergenexp(ts);\n\t\t\tbreak;\n\t\t}\n#endif /* USE_SRP */\n\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\tbreak;\n\n\tcase eapSRP1:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status == 1) {\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t} else if (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapSRP2;\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP2:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapSRP3;\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP3:\n\tcase eapSRP4:\n#ifdef USE_SRP\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tif (ts != NULL && status != 0) {\n\t\t\tt_serverclose(ts);\n\t\t\tesp->es_server.ea_session = NULL;\n\t\t\tesp->es_server.ea_skey = NULL;\n\t\t}\n#endif /* USE_SRP */\n\t\tif (status != 0 || esp->es_server.ea_session == NULL) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t}\n\t\tbreak;\n\n\tcase eapMD5Chall:\n\t\tif (status != 0) {\n\t\t\tesp->es_server.ea_state = eapBadAuth;\n\t\t} else {\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tesp->es_server.ea_state = eapBadAuth;\n\t\tbreak;\n\t}\n\tif (esp->es_server.ea_state == eapBadAuth)\n\t\teap_send_failure(esp);\n}\n\n/*\n * Format an EAP Request message and send it to the peer.  Message\n * type depends on current state.  (Server operation)\n */\nstatic void\neap_send_request(esp)\neap_state *esp;\n{\n\tu_char *outp;\n\tu_char *lenloc;\n\tu_char *ptr;\n\tint outlen;\n\tint challen;\n\tchar *str;\n#ifdef USE_SRP\n\tstruct t_server *ts;\n\tu_char clear[8], cipher[8], dig[SHA_DIGESTSIZE], *optr, *cp;\n\tint i, j;\n\tstruct b64state b64;\n\tSHA1_CTX ctxt;\n#endif /* USE_SRP */\n\n\t/* Handle both initial auth and restart */\n\tif (esp->es_server.ea_state < eapIdentify &&\n\t    esp->es_server.ea_state != eapInitial) {\n\t\tesp->es_server.ea_state = eapIdentify;\n\t\tif (explicit_remote) {\n\t\t\t/*\n\t\t\t * If we already know the peer's\n\t\t\t * unauthenticated name, then there's no\n\t\t\t * reason to ask.  Go to next state instead.\n\t\t\t */\n\t\t\tesp->es_server.ea_peer = remote_name;\n\t\t\tesp->es_server.ea_peerlen = strlen(remote_name);\n\t\t\teap_figure_next_state(esp, 0);\n\t\t}\n\t}\n\n\tif (esp->es_server.ea_maxrequests > 0 &&\n\t    esp->es_server.ea_requests >= esp->es_server.ea_maxrequests) {\n\t\tif (esp->es_server.ea_responses > 0)\n\t\t\terror(\"EAP: too many Requests sent\");\n\t\telse\n\t\t\terror(\"EAP: no response to Requests\");\n\t\teap_send_failure(esp);\n\t\treturn;\n\t}\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_REQUEST, outp);\n\tPUTCHAR(esp->es_server.ea_id, outp);\n\tlenloc = outp;\n\tINCPTR(2, outp);\n\n\tswitch (esp->es_server.ea_state) {\n\tcase eapIdentify:\n\t\tPUTCHAR(EAPT_IDENTITY, outp);\n\t\tstr = \"Name\";\n\t\tchallen = strlen(str);\n\t\tBCOPY(str, outp, challen);\n\t\tINCPTR(challen, outp);\n\t\tbreak;\n\n\tcase eapMD5Chall:\n\t\tPUTCHAR(EAPT_MD5CHAP, outp);\n\t\t/*\n\t\t * pick a random challenge length between\n\t\t * MIN_CHALLENGE_LENGTH and MAX_CHALLENGE_LENGTH\n\t\t */\n\t\tchallen = (drand48() *\n\t\t    (MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH)) +\n\t\t\t    MIN_CHALLENGE_LENGTH;\n\t\tPUTCHAR(challen, outp);\n\t\tesp->es_challen = challen;\n\t\tptr = esp->es_challenge;\n\t\twhile (--challen >= 0)\n\t\t\t*ptr++ = (u_char) (drand48() * 0x100);\n\t\tBCOPY(esp->es_challenge, outp, esp->es_challen);\n\t\tINCPTR(esp->es_challen, outp);\n\t\tBCOPY(esp->es_server.ea_name, outp, esp->es_server.ea_namelen);\n\t\tINCPTR(esp->es_server.ea_namelen, outp);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase eapSRP1:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_CHALLENGE, outp);\n\n\t\tPUTCHAR(esp->es_server.ea_namelen, outp);\n\t\tBCOPY(esp->es_server.ea_name, outp, esp->es_server.ea_namelen);\n\t\tINCPTR(esp->es_server.ea_namelen, outp);\n\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tPUTCHAR(ts->s.len, outp);\n\t\tBCOPY(ts->s.data, outp, ts->s.len);\n\t\tINCPTR(ts->s.len, outp);\n\n\t\tif (ts->g.len == 1 && ts->g.data[0] == 2) {\n\t\t\tPUTCHAR(0, outp);\n\t\t} else {\n\t\t\tPUTCHAR(ts->g.len, outp);\n\t\t\tBCOPY(ts->g.data, outp, ts->g.len);\n\t\t\tINCPTR(ts->g.len, outp);\n\t\t}\n\n\t\tif (ts->n.len != sizeof (wkmodulus) ||\n\t\t    BCMP(ts->n.data, wkmodulus, sizeof (wkmodulus)) != 0) {\n\t\t\tBCOPY(ts->n.data, outp, ts->n.len);\n\t\t\tINCPTR(ts->n.len, outp);\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP2:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_SKEY, outp);\n\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tBCOPY(ts->B.data, outp, ts->B.len);\n\t\tINCPTR(ts->B.len, outp);\n\t\tbreak;\n\n\tcase eapSRP3:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_SVALIDATOR, outp);\n\t\tPUTLONG(SRPVAL_EBIT, outp);\n\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\tassert(ts != NULL);\n\t\tBCOPY(t_serverresponse(ts), outp, SHA_DIGESTSIZE);\n\t\tINCPTR(SHA_DIGESTSIZE, outp);\n\n\t\tif (pncrypt_setkey(0)) {\n\t\t\t/* Generate pseudonym */\n\t\t\toptr = outp;\n\t\t\tcp = (unsigned char *)esp->es_server.ea_peer;\n\t\t\tif ((j = i = esp->es_server.ea_peerlen) > 7)\n\t\t\t\tj = 7;\n\t\t\tclear[0] = i;\n\t\t\tBCOPY(cp, clear + 1, j);\n\t\t\ti -= j;\n\t\t\tcp += j;\n\t\t\tif (!DesEncrypt(clear, cipher)) {\n\t\t\t\tdbglog(\"no DES here; not generating pseudonym\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBZERO(&b64, sizeof (b64));\n\t\t\toutp++;\t\t/* space for pseudonym length */\n\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\twhile (i >= 8) {\n\t\t\t\t(void) DesEncrypt(cp, cipher);\n\t\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\t\tcp += 8;\n\t\t\t\ti -= 8;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tBCOPY(cp, clear, i);\n\t\t\t\tcp += i;\n\t\t\t\twhile (i < 8) {\n\t\t\t\t\t*cp++ = drand48() * 0x100;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t(void) DesEncrypt(clear, cipher);\n\t\t\t\toutp += b64enc(&b64, cipher, 8, outp);\n\t\t\t}\n\t\t\toutp += b64flush(&b64, outp);\n\n\t\t\t/* Set length and pad out to next 20 octet boundary */\n\t\t\ti = outp - optr - 1;\n\t\t\t*optr = i;\n\t\t\ti %= SHA_DIGESTSIZE;\n\t\t\tif (i != 0) {\n\t\t\t\twhile (i < SHA_DIGESTSIZE) {\n\t\t\t\t\t*outp++ = drand48() * 0x100;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Obscure the pseudonym with SHA1 hash */\n\t\t\tSHA1Init(&ctxt);\n\t\t\tSHA1Update(&ctxt, &esp->es_server.ea_id, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_peer,\n\t\t\t    esp->es_server.ea_peerlen);\n\t\t\twhile (optr < outp) {\n\t\t\t\tSHA1Final(dig, &ctxt);\n\t\t\t\tcp = dig;\n\t\t\t\twhile (cp < dig + SHA_DIGESTSIZE)\n\t\t\t\t\t*optr++ ^= *cp++;\n\t\t\t\tSHA1Init(&ctxt);\n\t\t\t\tSHA1Update(&ctxt, &esp->es_server.ea_id, 1);\n\t\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t\t    SESSION_KEY_LEN);\n\t\t\t\tSHA1Update(&ctxt, optr - SHA_DIGESTSIZE,\n\t\t\t\t    SHA_DIGESTSIZE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase eapSRP4:\n\t\tPUTCHAR(EAPT_SRP, outp);\n\t\tPUTCHAR(EAPSRP_LWRECHALLENGE, outp);\n\t\tchallen = MIN_CHALLENGE_LENGTH +\n\t\t    ((MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH) * drand48());\n\t\tesp->es_challen = challen;\n\t\tptr = esp->es_challenge;\n\t\twhile (--challen >= 0)\n\t\t\t*ptr++ = drand48() * 0x100;\n\t\tBCOPY(esp->es_challenge, outp, esp->es_challen);\n\t\tINCPTR(esp->es_challen, outp);\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\treturn;\n\t}\n\n\toutlen = (outp - outpacket_buf) - PPP_HDRLEN;\n\tPUTSHORT(outlen, lenloc);\n\n\toutput(esp->es_unit, outpacket_buf, outlen + PPP_HDRLEN);\n\n\tesp->es_server.ea_requests++;\n\n\tif (esp->es_server.ea_timeout > 0)\n\t\tTIMEOUT(eap_server_timeout, esp, esp->es_server.ea_timeout);\n}\n\n/*\n * eap_authpeer - Authenticate our peer (behave as server).\n *\n * Start server state and send first request.  This is called only\n * after eap_lowerup.\n */\nvoid\neap_authpeer(unit, localname)\nint unit;\nchar *localname;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Save the name we're given. */\n\tesp->es_server.ea_name = localname;\n\tesp->es_server.ea_namelen = strlen(localname);\n\n\tesp->es_savedtime = esp->es_server.ea_timeout;\n\n\t/* Lower layer up yet? */\n\tif (esp->es_server.ea_state == eapInitial ||\n\t    esp->es_server.ea_state == eapPending) {\n\t\tesp->es_server.ea_state = eapPending;\n\t\treturn;\n\t}\n\n\tesp->es_server.ea_state = eapPending;\n\n\t/* ID number not updated here intentionally; hashed into M1 */\n\teap_send_request(esp);\n}\n\n/*\n * eap_server_timeout - Retransmission timer for sending Requests\n * expired.\n */\nstatic void\neap_server_timeout(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *) arg;\n\n\tif (!eap_server_active(esp))\n\t\treturn;\n\n\t/* EAP ID number must not change on timeout. */\n\teap_send_request(esp);\n}\n\n/*\n * When it's time to send rechallenge the peer, this timeout is\n * called.  Once the rechallenge is successful, the response handler\n * will restart the timer.  If it fails, then the link is dropped.\n */\nstatic void\neap_rechallenge(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *)arg;\n\n\tif (esp->es_server.ea_state != eapOpen &&\n\t    esp->es_server.ea_state != eapSRP4)\n\t\treturn;\n\n\tesp->es_server.ea_requests = 0;\n\tesp->es_server.ea_state = eapIdentify;\n\teap_figure_next_state(esp, 0);\n\tesp->es_server.ea_id++;\n\teap_send_request(esp);\n}\n\nstatic void\nsrp_lwrechallenge(arg)\nvoid *arg;\n{\n\teap_state *esp = (eap_state *)arg;\n\n\tif (esp->es_server.ea_state != eapOpen ||\n\t    esp->es_server.ea_type != EAPT_SRP)\n\t\treturn;\n\n\tesp->es_server.ea_requests = 0;\n\tesp->es_server.ea_state = eapSRP4;\n\tesp->es_server.ea_id++;\n\teap_send_request(esp);\n}\n\n/*\n * eap_lowerup - The lower layer is now up.\n *\n * This is called before either eap_authpeer or eap_authwithpeer.  See\n * link_established() in auth.c.  All that's necessary here is to\n * return to closed state so that those two routines will do the right\n * thing.\n */\nstatic void\neap_lowerup(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\t/* Discard any (possibly authenticated) peer name. */\n\tif (esp->es_server.ea_peer != NULL &&\n\t    esp->es_server.ea_peer != remote_name)\n\t\tfree(esp->es_server.ea_peer);\n\tesp->es_server.ea_peer = NULL;\n\tif (esp->es_client.ea_peer != NULL)\n\t\tfree(esp->es_client.ea_peer);\n\tesp->es_client.ea_peer = NULL;\n\n\tesp->es_client.ea_state = eapClosed;\n\tesp->es_server.ea_state = eapClosed;\n}\n\n/*\n * eap_lowerdown - The lower layer is now down.\n *\n * Cancel all timeouts and return to initial state.\n */\nstatic void\neap_lowerdown(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tif (eap_client_active(esp) && esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\tif (eap_server_active(esp)) {\n\t\tif (esp->es_server.ea_timeout > 0) {\n\t\t\tUNTIMEOUT(eap_server_timeout, (void *)esp);\n\t\t}\n\t} else {\n\t\tif ((esp->es_server.ea_state == eapOpen ||\n\t\t    esp->es_server.ea_state == eapSRP4) &&\n\t\t    esp->es_rechallenge > 0) {\n\t\t\tUNTIMEOUT(eap_rechallenge, (void *)esp);\n\t\t}\n\t\tif (esp->es_server.ea_state == eapOpen &&\n\t\t    esp->es_lwrechallenge > 0) {\n\t\t\tUNTIMEOUT(srp_lwrechallenge, (void *)esp);\n\t\t}\n\t}\n\n\tesp->es_client.ea_state = esp->es_server.ea_state = eapInitial;\n\tesp->es_client.ea_requests = esp->es_server.ea_requests = 0;\n}\n\n/*\n * eap_protrej - Peer doesn't speak this protocol.\n *\n * This shouldn't happen.  If it does, it represents authentication\n * failure.\n */\nstatic void\neap_protrej(unit)\nint unit;\n{\n\teap_state *esp = &eap_states[unit];\n\n\tif (eap_client_active(esp)) {\n\t\terror(\"EAP authentication failed due to Protocol-Reject\");\n\t\tauth_withpeer_fail(unit, PPP_EAP);\n\t}\n\tif (eap_server_active(esp)) {\n\t\terror(\"EAP authentication of peer failed on Protocol-Reject\");\n\t\tauth_peer_fail(unit, PPP_EAP);\n\t}\n\teap_lowerdown(unit);\n}\n\n/*\n * Format and send a regular EAP Response message.\n */\nstatic void\neap_send_response(esp, id, typenum, str, lenstr)\neap_state *esp;\nu_char id;\nu_char typenum;\nu_char *str;\nint lenstr;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n\n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + sizeof (u_char) + lenstr;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(typenum, outp);\n\tif (lenstr > 0) {\n\t\tBCOPY(str, outp, lenstr);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n/*\n * Format and send an MD5-Challenge EAP Response message.\n */\nstatic void\neap_chap_response(esp, id, hash, name, namelen)\neap_state *esp;\nu_char id;\nu_char *hash;\nchar *name;\nint namelen;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + MD5_SIGNATURE_SIZE +\n\t    namelen;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_MD5CHAP, outp);\n\tPUTCHAR(MD5_SIGNATURE_SIZE, outp);\n\tBCOPY(hash, outp, MD5_SIGNATURE_SIZE);\n\tINCPTR(MD5_SIGNATURE_SIZE, outp);\n\tif (namelen > 0) {\n\t\tBCOPY(name, outp, namelen);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n#ifdef USE_SRP\n/*\n * Format and send a SRP EAP Response message.\n */\nstatic void\neap_srp_response(esp, id, subtypenum, str, lenstr)\neap_state *esp;\nu_char id;\nu_char subtypenum;\nu_char *str;\nint lenstr;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + lenstr;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_SRP, outp);\n\tPUTCHAR(subtypenum, outp);\n\tif (lenstr > 0) {\n\t\tBCOPY(str, outp, lenstr);\n\t}\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n/*\n * Format and send a SRP EAP Client Validator Response message.\n */\nstatic void\neap_srpval_response(esp, id, flags, str)\neap_state *esp;\nu_char id;\nu_int32_t flags;\nu_char *str;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n    \n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char) + sizeof (u_int32_t) +\n\t    SHA_DIGESTSIZE;\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_SRP, outp);\n\tPUTCHAR(EAPSRP_CVALIDATOR, outp);\n\tPUTLONG(flags, outp);\n\tBCOPY(str, outp, SHA_DIGESTSIZE);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n#endif /* USE_SRP */\n\nstatic void\neap_send_nak(esp, id, type)\neap_state *esp;\nu_char id;\nu_char type;\n{\n\tu_char *outp;\n\tint msglen;\n\n\toutp = outpacket_buf;\n\n\tMAKEHEADER(outp, PPP_EAP);\n\n\tPUTCHAR(EAP_RESPONSE, outp);\n\tPUTCHAR(id, outp);\n\tesp->es_client.ea_id = id;\n\tmsglen = EAP_HEADERLEN + 2 * sizeof (u_char);\n\tPUTSHORT(msglen, outp);\n\tPUTCHAR(EAPT_NAK, outp);\n\tPUTCHAR(type, outp);\n\n\toutput(esp->es_unit, outpacket_buf, PPP_HDRLEN + msglen);\n}\n\n#ifdef USE_SRP\nstatic char *\nname_of_pn_file()\n{\n\tchar *user, *path, *file;\n\tstruct passwd *pw;\n\tsize_t pl;\n\tstatic bool pnlogged = 0;\n\n\tpw = getpwuid(getuid());\n\tif (pw == NULL || (user = pw->pw_dir) == NULL || user[0] == 0) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\tfile = _PATH_PSEUDONYM;\n\tpl = strlen(user) + strlen(file) + 2;\n\tpath = malloc(pl);\n\tif (path == NULL)\n\t\treturn (NULL);\n\t(void) slprintf(path, pl, \"%s/%s\", user, file);\n\tif (!pnlogged) {\n\t\tdbglog(\"pseudonym file: %s\", path);\n\t\tpnlogged = 1;\n\t}\n\treturn (path);\n}\n\nstatic int\nopen_pn_file(modebits)\nmode_t modebits;\n{\n\tchar *path;\n\tint fd, err;\n\n\tif ((path = name_of_pn_file()) == NULL)\n\t\treturn (-1);\n\tfd = open(path, modebits, S_IRUSR | S_IWUSR);\n\terr = errno;\n\tfree(path);\n\terrno = err;\n\treturn (fd);\n}\n\nstatic void\nremove_pn_file()\n{\n\tchar *path;\n\n\tif ((path = name_of_pn_file()) != NULL) {\n\t\t(void) unlink(path);\n\t\t(void) free(path);\n\t}\n}\n\nstatic void\nwrite_pseudonym(esp, inp, len, id)\neap_state *esp;\nu_char *inp;\nint len, id;\n{\n\tu_char val;\n\tu_char *datp, *digp;\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\tint dsize, fd, olen = len;\n\n\t/*\n\t * Do the decoding by working backwards.  This eliminates the need\n\t * to save the decoded output in a separate buffer.\n\t */\n\tval = id;\n\twhile (len > 0) {\n\t\tif ((dsize = len % SHA_DIGESTSIZE) == 0)\n\t\t\tdsize = SHA_DIGESTSIZE;\n\t\tlen -= dsize;\n\t\tdatp = inp + len;\n\t\tSHA1Init(&ctxt);\n\t\tSHA1Update(&ctxt, &val, 1);\n\t\tSHA1Update(&ctxt, esp->es_client.ea_skey, SESSION_KEY_LEN);\n\t\tif (len > 0) {\n\t\t\tSHA1Update(&ctxt, datp, SHA_DIGESTSIZE);\n\t\t} else {\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_name,\n\t\t\t    esp->es_client.ea_namelen);\n\t\t}\n\t\tSHA1Final(dig, &ctxt);\n\t\tfor (digp = dig; digp < dig + SHA_DIGESTSIZE; digp++)\n\t\t\t*datp++ ^= *digp;\n\t}\n\n\t/* Now check that the result is sane */\n\tif (olen <= 0 || *inp + 1 > olen) {\n\t\tdbglog(\"EAP: decoded pseudonym is unusable <%.*B>\", olen, inp);\n\t\treturn;\n\t}\n\n\t/* Save it away */\n\tfd = open_pn_file(O_WRONLY | O_CREAT | O_TRUNC);\n\tif (fd < 0) {\n\t\tdbglog(\"EAP: error saving pseudonym: %m\");\n\t\treturn;\n\t}\n\tlen = write(fd, inp + 1, *inp);\n\tif (close(fd) != -1 && len == *inp) {\n\t\tdbglog(\"EAP: saved pseudonym\");\n\t\tesp->es_usedpseudo = 0;\n\t} else {\n\t\tdbglog(\"EAP: failed to save pseudonym\");\n\t\tremove_pn_file();\n\t}\n}\n#endif /* USE_SRP */\n\n/*\n * eap_request - Receive EAP Request message (client mode).\n */\nstatic void\neap_request(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXWORDLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_client *tc;\n\tstruct t_num sval, gval, Nval, *Ap, Bval;\n\tu_char vals[2];\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n\tint fd;\n#endif /* USE_SRP */\n\n\t/*\n\t * Note: we update es_client.ea_id *only if* a Response\n\t * message is being generated.  Otherwise, we leave it the\n\t * same for duplicate detection purposes.\n\t */\n\n\tesp->es_client.ea_requests++;\n\tif (esp->es_client.ea_maxrequests != 0 &&\n\t    esp->es_client.ea_requests > esp->es_client.ea_maxrequests) {\n\t\tinfo(\"EAP: received too many Request messages\");\n\t\tif (esp->es_client.ea_timeout > 0) {\n\t\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\t}\n\t\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n\t\treturn;\n\t}\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Request message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Identity prompt \\\"%.*q\\\"\", len, inp);\n#ifdef USE_SRP\n\t\tif (esp->es_usepseudo &&\n\t\t    (esp->es_usedpseudo == 0 ||\n\t\t\t(esp->es_usedpseudo == 1 &&\n\t\t\t    id == esp->es_client.ea_id))) {\n\t\t\tesp->es_usedpseudo = 1;\n\t\t\t/* Try to get a pseudonym */\n\t\t\tif ((fd = open_pn_file(O_RDONLY)) >= 0) {\n\t\t\t\tstrcpy(rhostname, SRP_PSEUDO_ID);\n\t\t\t\tlen = read(fd, rhostname + SRP_PSEUDO_LEN,\n\t\t\t\t    sizeof (rhostname) - SRP_PSEUDO_LEN);\n\t\t\t\t/* XXX NAI unsupported */\n\t\t\t\tif (len > 0) {\n\t\t\t\t\teap_send_response(esp, id, typenum,\n\t\t\t\t\t    rhostname, len + SRP_PSEUDO_LEN);\n\t\t\t\t}\n\t\t\t\t(void) close(fd);\n\t\t\t\tif (len > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Stop using pseudonym now. */\n\t\tif (esp->es_usepseudo && esp->es_usedpseudo != 2) {\n\t\t\tremove_pn_file();\n\t\t\tesp->es_usedpseudo = 2;\n\t\t}\n#endif /* USE_SRP */\n\t\teap_send_response(esp, id, typenum, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tif (len > 0)\n\t\t\tinfo(\"EAP: Notification \\\"%.*q\\\"\", len, inp);\n\t\teap_send_response(esp, id, typenum, NULL, 0);\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\t/*\n\t\t * Avoid the temptation to send Response Nak in reply\n\t\t * to Request Nak here.  It can only lead to trouble.\n\t\t */\n\t\twarn(\"EAP: unexpected Nak in Request; ignored\");\n\t\t/* Return because we're waiting for something real. */\n\t\treturn;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Challenge with no data\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen < 8 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Challenge with bad length %d (8..%d)\",\n\t\t\t    vallen, len);\n\t\t\t/* Try something better. */\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (len - vallen >= sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating ourselves with\n\t\t * the specified host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, esp->es_client.ea_name,\n\t\t    rhostname, secret, &secret_len, 0)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth to %q\", rhostname);\n\t\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\ttypenum = id;\n\t\tMD5_Update(&mdContext, &typenum, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, inp, vallen);\n\t\tMD5_Final(hash, &mdContext);\n\t\teap_chap_response(esp, id, hash, esp->es_client.ea_name,\n\t\t    esp->es_client.ea_namelen);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received empty SRP Request\");\n\t\t\t/* Bogus request; wait for something real. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Get subtype */\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tswitch (vallen) {\n\t\tcase EAPSRP_CHALLENGE:\n\t\t\ttc = NULL;\n\t\t\tif (esp->es_client.ea_session != NULL) {\n\t\t\t\ttc = (struct t_client *)esp->es_client.\n\t\t\t\t    ea_session;\n\t\t\t\t/*\n\t\t\t\t * If this is a new challenge, then start\n\t\t\t\t * over with a new client session context.\n\t\t\t\t * Otherwise, just resend last response.\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\tt_clientclose(tc);\n\t\t\t\t\tesp->es_client.ea_session = NULL;\n\t\t\t\t\ttc = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* No session key just yet */\n\t\t\tesp->es_client.ea_skey = NULL;\n\t\t\tif (tc == NULL) {\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (name)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tBCOPY(inp, rhostname, vallen);\n\t\t\t\trhostname[vallen] = '\\0';\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * In case the remote doesn't give us his name,\n\t\t\t\t * use configured name.\n\t\t\t\t */\n\t\t\t\tif (explicit_remote ||\n\t\t\t\t    (remote_name[0] != '\\0' && vallen == 0)) {\n\t\t\t\t\tstrlcpy(rhostname, remote_name,\n\t\t\t\t\t    sizeof (rhostname));\n\t\t\t\t}\n\n\t\t\t\tif (esp->es_client.ea_peer != NULL)\n\t\t\t\t\tfree(esp->es_client.ea_peer);\n\t\t\t\tesp->es_client.ea_peer = strdup(rhostname);\n\t\t\t\tesp->es_client.ea_peerlen = strlen(rhostname);\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (s)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsval.data = inp;\n\t\t\t\tsval.len = vallen;\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen > len) {\n\t\t\t\t\terror(\"EAP: badly-formed SRP Challenge\"\n\t\t\t\t\t    \" (g)\");\n\t\t\t\t\t/* Ignore badly-formed messages */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* If no generator present, then use value 2 */\n\t\t\t\tif (vallen == 0) {\n\t\t\t\t\tgval.data = (u_char *)\"\\002\";\n\t\t\t\t\tgval.len = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgval.data = inp;\n\t\t\t\t\tgval.len = vallen;\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\n\t\t\t\t/*\n\t\t\t\t * If no modulus present, then use well-known\n\t\t\t\t * value.\n\t\t\t\t */\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tNval.data = (u_char *)wkmodulus;\n\t\t\t\t\tNval.len = sizeof (wkmodulus);\n\t\t\t\t} else {\n\t\t\t\t\tNval.data = inp;\n\t\t\t\t\tNval.len = len;\n\t\t\t\t}\n\t\t\t\ttc = t_clientopen(esp->es_client.ea_name,\n\t\t\t\t    &Nval, &gval, &sval);\n\t\t\t\tif (tc == NULL) {\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tesp->es_client.ea_session = (void *)tc;\n\n\t\t\t\t/* Add Challenge ID & type to verifier */\n\t\t\t\tvals[0] = id;\n\t\t\t\tvals[1] = EAPT_SRP;\n\t\t\t\tt_clientaddexdata(tc, vals, 2);\n\t\t\t}\n\t\t\tAp = t_clientgenexp(tc);\n\t\t\teap_srp_response(esp, id, EAPSRP_CKEY, Ap->data,\n\t\t\t    Ap->len);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SKEY:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 2 without 1\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (esp->es_client.ea_skey != NULL) {\n\t\t\t\t/*\n\t\t\t\t * ID number should not change here.  Warn\n\t\t\t\t * if it does (but otherwise ignore).\n\t\t\t\t */\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 2 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (get_srp_secret(esp->es_unit,\n\t\t\t\t    esp->es_client.ea_name,\n\t\t\t\t    esp->es_client.ea_peer, secret, 0) == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Can't work with this peer because\n\t\t\t\t\t * the secret is missing.  Just give\n\t\t\t\t\t * up.\n\t\t\t\t\t */\n\t\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBval.data = inp;\n\t\t\t\tBval.len = len;\n\t\t\t\tt_clientpasswd(tc, secret);\n\t\t\t\tBZERO(secret, sizeof (secret));\n\t\t\t\tesp->es_client.ea_skey =\n\t\t\t\t    t_clientgetkey(tc, &Bval);\n\t\t\t\tif (esp->es_client.ea_skey == NULL) {\n\t\t\t\t\t/* Server is rogue; stop now */\n\t\t\t\t\terror(\"EAP: SRP server is rogue\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t}\n\t\t\teap_srpval_response(esp, id, SRPVAL_EBIT,\n\t\t\t    t_clientresponse(tc));\n\t\t\tbreak;\n\n\t\tcase EAPSRP_SVALIDATOR:\n\t\t\ttc = (struct t_client *)esp->es_client.ea_session;\n\t\t\tif (tc == NULL || esp->es_client.ea_skey == NULL) {\n\t\t\t\twarn(\"EAP: peer sent Subtype 3 without 1/2\");\n\t\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we're already open, then this ought to be a\n\t\t\t * duplicate.  Otherwise, check that the server is\n\t\t\t * who we think it is.\n\t\t\t */\n\t\t\tif (esp->es_client.ea_state == eapOpen) {\n\t\t\t\tif (id != esp->es_client.ea_id) {\n\t\t\t\t\twarn(\"EAP: ID changed from %d to %d \"\n\t\t\t\t\t    \"in SRP Subtype 3 rexmit\",\n\t\t\t\t\t    esp->es_client.ea_id, id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen -= sizeof (u_int32_t) + SHA_DIGESTSIZE;\n\t\t\t\tif (len < 0 || t_clientverify(tc, inp +\n\t\t\t\t\tsizeof (u_int32_t)) != 0) {\n\t\t\t\t\terror(\"EAP: SRP server verification \"\n\t\t\t\t\t    \"failed\");\n\t\t\t\t\tgoto client_failure;\n\t\t\t\t}\n\t\t\t\tGETLONG(esp->es_client.ea_keyflags, inp);\n\t\t\t\t/* Save pseudonym if user wants it. */\n\t\t\t\tif (len > 0 && esp->es_usepseudo) {\n\t\t\t\t\tINCPTR(SHA_DIGESTSIZE, inp);\n\t\t\t\t\twrite_pseudonym(esp, inp, len, id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * We've verified our peer.  We're now mostly done,\n\t\t\t * except for waiting on the regular EAP Success\n\t\t\t * message.\n\t\t\t */\n\t\t\teap_srp_response(esp, id, EAPSRP_ACK, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (len < 4) {\n\t\t\t\twarn(\"EAP: malformed Lightweight rechallenge\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvals[0] = id;\n\t\t\tSHA1Update(&ctxt, vals, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, inp, len);\n\t\t\tSHA1Update(&ctxt, esp->es_client.ea_name,\n\t\t\t    esp->es_client.ea_namelen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\teap_srp_response(esp, id, EAPSRP_LWRECHALLENGE, dig,\n\t\t\t    SHA_DIGESTSIZE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror(\"EAP: unknown SRP Subtype %d\", vallen);\n\t\t\teap_send_nak(esp, id, EAPT_MD5CHAP);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\tinfo(\"EAP: unknown authentication type %d; Naking\", typenum);\n\t\teap_send_nak(esp, id, EAPT_SRP);\n\t\tbreak;\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t\tTIMEOUT(eap_client_timeout, (void *)esp,\n\t\t    esp->es_client.ea_timeout);\n\t}\n\treturn;\n\n#ifdef USE_SRP\nclient_failure:\n\tesp->es_client.ea_state = eapBadAuth;\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\tesp->es_client.ea_session = NULL;\n\tt_clientclose(tc);\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n#endif /* USE_SRP */\n}\n\n/*\n * eap_response - Receive EAP Response message (server mode).\n */\nstatic void\neap_response(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tu_char typenum;\n\tu_char vallen;\n\tint secret_len;\n\tchar secret[MAXSECRETLEN];\n\tchar rhostname[256];\n\tMD5_CTX mdContext;\n\tu_char hash[MD5_SIGNATURE_SIZE];\n#ifdef USE_SRP\n\tstruct t_server *ts;\n\tstruct t_num A;\n\tSHA1_CTX ctxt;\n\tu_char dig[SHA_DIGESTSIZE];\n#endif /* USE_SRP */\n\n\tif (esp->es_server.ea_id != id) {\n\t\tdbglog(\"EAP: discarding Response %d; expected ID %d\", id,\n\t\t    esp->es_server.ea_id);\n\t\treturn;\n\t}\n\n\tesp->es_server.ea_responses++;\n\n\tif (len <= 0) {\n\t\terror(\"EAP: empty Response message discarded\");\n\t\treturn;\n\t}\n\n\tGETCHAR(typenum, inp);\n\tlen--;\n\n\tswitch (typenum) {\n\tcase EAPT_IDENTITY:\n\t\tif (esp->es_server.ea_state != eapIdentify) {\n\t\t\tdbglog(\"EAP discarding unwanted Identify \\\"%.q\\\"\", len,\n\t\t\t    inp);\n\t\t\tbreak;\n\t\t}\n\t\tinfo(\"EAP: unauthenticated peer name \\\"%.*q\\\"\", len, inp);\n\t\tif (esp->es_server.ea_peer != NULL &&\n\t\t    esp->es_server.ea_peer != remote_name)\n\t\t\tfree(esp->es_server.ea_peer);\n\t\tesp->es_server.ea_peer = malloc(len + 1);\n\t\tif (esp->es_server.ea_peer == NULL) {\n\t\t\tesp->es_server.ea_peerlen = 0;\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tBCOPY(inp, esp->es_server.ea_peer, len);\n\t\tesp->es_server.ea_peer[len] = '\\0';\n\t\tesp->es_server.ea_peerlen = len;\n\t\teap_figure_next_state(esp, 0);\n\t\tbreak;\n\n\tcase EAPT_NOTIFICATION:\n\t\tdbglog(\"EAP unexpected Notification; response discarded\");\n\t\tbreak;\n\n\tcase EAPT_NAK:\n\t\tif (len < 1) {\n\t\t\tinfo(\"EAP: Nak Response with no suggested protocol\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\n\t\tif (!explicit_remote && esp->es_server.ea_state == eapIdentify){\n\t\t\t/* Peer cannot Nak Identify Request */\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (vallen) {\n\t\tcase EAPT_SRP:\n\t\t\t/* Run through SRP validator selection again. */\n\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdbglog(\"EAP: peer requesting unknown Type %d\", vallen);\n\t\t\tswitch (esp->es_server.ea_state) {\n\t\t\tcase eapSRP1:\n\t\t\tcase eapSRP2:\n\t\t\tcase eapSRP3:\n\t\t\t\tesp->es_server.ea_state = eapMD5Chall;\n\t\t\t\tbreak;\n\t\t\tcase eapMD5Chall:\n\t\t\tcase eapSRP4:\n\t\t\t\tesp->es_server.ea_state = eapIdentify;\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAPT_MD5CHAP:\n\t\tif (esp->es_server.ea_state != eapMD5Chall) {\n\t\t\terror(\"EAP: unexpected MD5-Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: received MD5-Response with no data\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(vallen, inp);\n\t\tlen--;\n\t\tif (vallen != 16 || vallen > len) {\n\t\t\terror(\"EAP: MD5-Response with bad length %d\", vallen);\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Not so likely to happen. */\n\t\tif (len - vallen >= sizeof (rhostname)) {\n\t\t\tdbglog(\"EAP: trimming really long peer name down\");\n\t\t\tBCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);\n\t\t\trhostname[sizeof (rhostname) - 1] = '\\0';\n\t\t} else {\n\t\t\tBCOPY(inp + vallen, rhostname, len - vallen);\n\t\t\trhostname[len - vallen] = '\\0';\n\t\t}\n\n\t\t/* In case the remote doesn't give us his name. */\n\t\tif (explicit_remote ||\n\t\t    (remote_name[0] != '\\0' && vallen == len))\n\t\t\tstrlcpy(rhostname, remote_name, sizeof (rhostname));\n\n\t\t/*\n\t\t * Get the secret for authenticating the specified\n\t\t * host.\n\t\t */\n\t\tif (!get_secret(esp->es_unit, rhostname,\n\t\t    esp->es_server.ea_name, secret, &secret_len, 1)) {\n\t\t\tdbglog(\"EAP: no MD5 secret for auth of %q\", rhostname);\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tMD5_Init(&mdContext);\n\t\tMD5_Update(&mdContext, &esp->es_server.ea_id, 1);\n\t\tMD5_Update(&mdContext, (u_char *)secret, secret_len);\n\t\tBZERO(secret, sizeof (secret));\n\t\tMD5_Update(&mdContext, esp->es_challenge, esp->es_challen);\n\t\tMD5_Final(hash, &mdContext);\n\t\tif (BCMP(hash, inp, MD5_SIGNATURE_SIZE) != 0) {\n\t\t\teap_send_failure(esp);\n\t\t\tbreak;\n\t\t}\n\t\tesp->es_server.ea_type = EAPT_MD5CHAP;\n\t\teap_send_success(esp);\n\t\teap_figure_next_state(esp, 0);\n\t\tif (esp->es_rechallenge != 0)\n\t\t\tTIMEOUT(eap_rechallenge, esp, esp->es_rechallenge);\n\t\tbreak;\n\n#ifdef USE_SRP\n\tcase EAPT_SRP:\n\t\tif (len < 1) {\n\t\t\terror(\"EAP: empty SRP Response\");\n\t\t\teap_figure_next_state(esp, 1);\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(typenum, inp);\n\t\tlen--;\n\t\tswitch (typenum) {\n\t\tcase EAPSRP_CKEY:\n\t\t\tif (esp->es_server.ea_state != eapSRP1) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 1 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tA.data = inp;\n\t\t\tA.len = len;\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tesp->es_server.ea_skey = t_servergetkey(ts, &A);\n\t\t\tif (esp->es_server.ea_skey == NULL) {\n\t\t\t\t/* Client's A value is bogus; terminate now */\n\t\t\t\terror(\"EAP: bogus A value from client\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t} else {\n\t\t\t\teap_figure_next_state(esp, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPSRP_CVALIDATOR:\n\t\t\tif (esp->es_server.ea_state != eapSRP2) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 2 Response\");\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len < sizeof (u_int32_t) + SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: M1 length %d < %d\", len,\n\t\t\t\t    sizeof (u_int32_t) + SHA_DIGESTSIZE);\n\t\t\t\teap_figure_next_state(esp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETLONG(esp->es_server.ea_keyflags, inp);\n\t\t\tts = (struct t_server *)esp->es_server.ea_session;\n\t\t\tassert(ts != NULL);\n\t\t\tif (t_serververify(ts, inp)) {\n\t\t\t\tinfo(\"EAP: unable to validate client identity\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_ACK:\n\t\t\tif (esp->es_server.ea_state != eapSRP3) {\n\t\t\t\terror(\"EAP: unexpected SRP Subtype 3 Response\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_type = EAPT_SRP;\n\t\t\teap_send_success(esp);\n\t\t\teap_figure_next_state(esp, 0);\n\t\t\tif (esp->es_rechallenge != 0)\n\t\t\t\tTIMEOUT(eap_rechallenge, esp,\n\t\t\t\t    esp->es_rechallenge);\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\n\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\tif (esp->es_server.ea_state != eapSRP4) {\n\t\t\t\tinfo(\"EAP: unexpected SRP Subtype 4 Response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (len != SHA_DIGESTSIZE) {\n\t\t\t\terror(\"EAP: bad Lightweight rechallenge \"\n\t\t\t\t    \"response\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSHA1Init(&ctxt);\n\t\t\tvallen = id;\n\t\t\tSHA1Update(&ctxt, &vallen, 1);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_skey,\n\t\t\t    SESSION_KEY_LEN);\n\t\t\tSHA1Update(&ctxt, esp->es_challenge, esp->es_challen);\n\t\t\tSHA1Update(&ctxt, esp->es_server.ea_peer,\n\t\t\t    esp->es_server.ea_peerlen);\n\t\t\tSHA1Final(dig, &ctxt);\n\t\t\tif (BCMP(dig, inp, SHA_DIGESTSIZE) != 0) {\n\t\t\t\terror(\"EAP: failed Lightweight rechallenge\");\n\t\t\t\teap_send_failure(esp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tesp->es_server.ea_state = eapOpen;\n\t\t\tif (esp->es_lwrechallenge != 0)\n\t\t\t\tTIMEOUT(srp_lwrechallenge, esp,\n\t\t\t\t    esp->es_lwrechallenge);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* USE_SRP */\n\n\tdefault:\n\t\t/* This can't happen. */\n\t\terror(\"EAP: unknown Response type %d; ignored\", typenum);\n\t\treturn;\n\t}\n\n\tif (esp->es_server.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_server_timeout, (void *)esp);\n\t}\n\n\tif (esp->es_server.ea_state != eapBadAuth &&\n\t    esp->es_server.ea_state != eapOpen) {\n\t\tesp->es_server.ea_id++;\n\t\teap_send_request(esp);\n\t}\n}\n\n/*\n * eap_success - Receive EAP Success message (client mode).\n */\nstatic void\neap_success(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tif (esp->es_client.ea_state != eapOpen && !eap_client_active(esp)) {\n\t\tdbglog(\"EAP unexpected success message in state %s (%d)\",\n\t\t    eap_state_name(esp->es_client.ea_state),\n\t\t    esp->es_client.ea_state);\n\t\treturn;\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\n\tif (len > 0) {\n\t\t/* This is odd.  The spec doesn't allow for this. */\n\t\tPRINTMSG(inp, len);\n\t}\n\n\tesp->es_client.ea_state = eapOpen;\n\tauth_withpeer_success(esp->es_unit, PPP_EAP, 0);\n}\n\n/*\n * eap_failure - Receive EAP Failure message (client mode).\n */\nstatic void\neap_failure(esp, inp, id, len)\neap_state *esp;\nu_char *inp;\nint id;\nint len;\n{\n\tif (!eap_client_active(esp)) {\n\t\tdbglog(\"EAP unexpected failure message in state %s (%d)\",\n\t\t    eap_state_name(esp->es_client.ea_state),\n\t\t    esp->es_client.ea_state);\n\t}\n\n\tif (esp->es_client.ea_timeout > 0) {\n\t\tUNTIMEOUT(eap_client_timeout, (void *)esp);\n\t}\n\n\tif (len > 0) {\n\t\t/* This is odd.  The spec doesn't allow for this. */\n\t\tPRINTMSG(inp, len);\n\t}\n\n\tesp->es_client.ea_state = eapBadAuth;\n\n\terror(\"EAP: peer reports authentication failure\");\n\tauth_withpeer_fail(esp->es_unit, PPP_EAP);\n}\n\n/*\n * eap_input - Handle received EAP message.\n */\nstatic void\neap_input(unit, inp, inlen)\nint unit;\nu_char *inp;\nint inlen;\n{\n\teap_state *esp = &eap_states[unit];\n\tu_char code, id;\n\tint len;\n\n\t/*\n\t * Parse header (code, id and length).  If packet too short,\n\t * drop it.\n\t */\n\tif (inlen < EAP_HEADERLEN) {\n\t\terror(\"EAP: packet too short: %d < %d\", inlen, EAP_HEADERLEN);\n\t\treturn;\n\t}\n\tGETCHAR(code, inp);\n\tGETCHAR(id, inp);\n\tGETSHORT(len, inp);\n\tif (len < EAP_HEADERLEN || len > inlen) {\n\t\terror(\"EAP: packet has illegal length field %d (%d..%d)\", len,\n\t\t    EAP_HEADERLEN, inlen);\n\t\treturn;\n\t}\n\tlen -= EAP_HEADERLEN;\n\n\t/* Dispatch based on message code */\n\tswitch (code) {\n\tcase EAP_REQUEST:\n\t\teap_request(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_RESPONSE:\n\t\teap_response(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_SUCCESS:\n\t\teap_success(esp, inp, id, len);\n\t\tbreak;\n\n\tcase EAP_FAILURE:\n\t\teap_failure(esp, inp, id, len);\n\t\tbreak;\n\n\tdefault:\t\t\t\t/* XXX Need code reject */\n\t\t/* Note: it's not legal to send EAP Nak here. */\n\t\twarn(\"EAP: unknown code %d received\", code);\n\t\tbreak;\n\t}\n}\n\n/*\n * eap_printpkt - print the contents of an EAP packet.\n */\nstatic char *eap_codenames[] = {\n\t\"Request\", \"Response\", \"Success\", \"Failure\"\n};\n\nstatic char *eap_typenames[] = {\n\t\"Identity\", \"Notification\", \"Nak\", \"MD5-Challenge\",\n\t\"OTP\", \"Generic-Token\", NULL, NULL,\n\t\"RSA\", \"DSS\", \"KEA\", \"KEA-Validate\",\n\t\"TLS\", \"Defender\", \"Windows 2000\", \"Arcot\",\n\t\"Cisco\", \"Nokia\", \"SRP\"\n};\n\nstatic int\neap_printpkt(inp, inlen, printer, arg)\nu_char *inp;\nint inlen;\nvoid (*printer) __P((void *, char *, ...));\nvoid *arg;\n{\n\tint code, id, len, rtype, vallen;\n\tu_char *pstart;\n\tu_int32_t uval;\n\n\tif (inlen < EAP_HEADERLEN)\n\t\treturn (0);\n\tpstart = inp;\n\tGETCHAR(code, inp);\n\tGETCHAR(id, inp);\n\tGETSHORT(len, inp);\n\tif (len < EAP_HEADERLEN || len > inlen)\n\t\treturn (0);\n\n\tif (code >= 1 && code <= sizeof(eap_codenames) / sizeof(char *))\n\t\tprinter(arg, \" %s\", eap_codenames[code-1]);\n\telse\n\t\tprinter(arg, \" code=0x%x\", code);\n\tprinter(arg, \" id=0x%x\", id);\n\tlen -= EAP_HEADERLEN;\n\tswitch (code) {\n\tcase EAP_REQUEST:\n\t\tif (len < 1) {\n\t\t\tprinter(arg, \" <missing type>\");\n\t\t\tbreak;\n\t\t}\n\t\tGETCHAR(rtype, inp);\n\t\tlen--;\n\t\tif (rtype >= 1 &&\n\t\t    rtype <= sizeof (eap_typenames) / sizeof (char *))\n\t\t\tprinter(arg, \" %s\", eap_typenames[rtype-1]);\n\t\telse\n\t\t\tprinter(arg, \" type=0x%x\", rtype);\n\t\tswitch (rtype) {\n\t\tcase EAPT_IDENTITY:\n\t\tcase EAPT_NOTIFICATION:\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Message \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No message>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tif (vallen > len)\n\t\t\t\tgoto truncated;\n\t\t\tprinter(arg, \" <Value%.*B>\", vallen, inp);\n\t\t\tINCPTR(vallen, inp);\n\t\t\tlen -= vallen;\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_SRP:\n\t\t\tif (len < 3)\n\t\t\t\tgoto truncated;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \"-%d\", vallen);\n\t\t\tswitch (vallen) {\n\t\t\tcase EAPSRP_CHALLENGE:\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tif (vallen > 0) {\n\t\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\t\tprint_string((char *)inp, vallen, printer,\n\t\t\t\t\t    arg);\n\t\t\t\t\tprinter(arg, \">\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen >= len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tprinter(arg, \" <s%.*B>\", vallen, inp);\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tGETCHAR(vallen, inp);\n\t\t\t\tlen--;\n\t\t\t\tif (vallen > len)\n\t\t\t\t\tgoto truncated;\n\t\t\t\tif (vallen == 0) {\n\t\t\t\t\tprinter(arg, \" <Default g=2>\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <g%.*B>\", vallen, inp);\n\t\t\t\t}\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tprinter(arg, \" <Default N>\");\n\t\t\t\t} else {\n\t\t\t\t\tprinter(arg, \" <N%.*B>\", len, inp);\n\t\t\t\t\tINCPTR(len, inp);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_SKEY:\n\t\t\t\tprinter(arg, \" <B%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_SVALIDATOR:\n\t\t\t\tif (len < sizeof (u_int32_t))\n\t\t\t\t\tbreak;\n\t\t\t\tGETLONG(uval, inp);\n\t\t\t\tlen -= sizeof (u_int32_t);\n\t\t\t\tif (uval & SRPVAL_EBIT) {\n\t\t\t\t\tprinter(arg, \" E\");\n\t\t\t\t\tuval &= ~SRPVAL_EBIT;\n\t\t\t\t}\n\t\t\t\tif (uval != 0) {\n\t\t\t\t\tprinter(arg, \" f<%X>\", uval);\n\t\t\t\t}\n\t\t\t\tif ((vallen = len) > SHA_DIGESTSIZE)\n\t\t\t\t\tvallen = SHA_DIGESTSIZE;\n\t\t\t\tprinter(arg, \" <M2%.*B%s>\", len, inp,\n\t\t\t\t    len < SHA_DIGESTSIZE ? \"?\" : \"\");\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tprinter(arg, \" <PN%.*B>\", len, inp);\n\t\t\t\t\tINCPTR(len, inp);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\t\tprinter(arg, \" <Challenge%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAP_RESPONSE:\n\t\tif (len < 1)\n\t\t\tbreak;\n\t\tGETCHAR(rtype, inp);\n\t\tlen--;\n\t\tif (rtype >= 1 &&\n\t\t    rtype <= sizeof (eap_typenames) / sizeof (char *))\n\t\t\tprinter(arg, \" %s\", eap_typenames[rtype-1]);\n\t\telse\n\t\t\tprinter(arg, \" type=0x%x\", rtype);\n\t\tswitch (rtype) {\n\t\tcase EAPT_IDENTITY:\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_NAK:\n\t\t\tif (len <= 0) {\n\t\t\t\tprinter(arg, \" <missing hint>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETCHAR(rtype, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \" <Suggested-type %02X\", rtype);\n\t\t\tif (rtype >= 1 &&\n\t\t\t    rtype < sizeof (eap_typenames) / sizeof (char *))\n\t\t\t\tprinter(arg, \" (%s)\", eap_typenames[rtype-1]);\n\t\t\tprinter(arg, \">\");\n\t\t\tbreak;\n\n\t\tcase EAPT_MD5CHAP:\n\t\t\tif (len <= 0) {\n\t\t\t\tprinter(arg, \" <missing length>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tif (vallen > len)\n\t\t\t\tgoto truncated;\n\t\t\tprinter(arg, \" <Value%.*B>\", vallen, inp);\n\t\t\tINCPTR(vallen, inp);\n\t\t\tlen -= vallen;\n\t\t\tif (len > 0) {\n\t\t\t\tprinter(arg, \" <Name \");\n\t\t\t\tprint_string((char *)inp, len, printer, arg);\n\t\t\t\tprinter(arg, \">\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprinter(arg, \" <No name>\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EAPT_SRP:\n\t\t\tif (len < 1)\n\t\t\t\tgoto truncated;\n\t\t\tGETCHAR(vallen, inp);\n\t\t\tlen--;\n\t\t\tprinter(arg, \"-%d\", vallen);\n\t\t\tswitch (vallen) {\n\t\t\tcase EAPSRP_CKEY:\n\t\t\t\tprinter(arg, \" <A%.*B>\", len, inp);\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_CVALIDATOR:\n\t\t\t\tif (len < sizeof (u_int32_t))\n\t\t\t\t\tbreak;\n\t\t\t\tGETLONG(uval, inp);\n\t\t\t\tlen -= sizeof (u_int32_t);\n\t\t\t\tif (uval & SRPVAL_EBIT) {\n\t\t\t\t\tprinter(arg, \" E\");\n\t\t\t\t\tuval &= ~SRPVAL_EBIT;\n\t\t\t\t}\n\t\t\t\tif (uval != 0) {\n\t\t\t\t\tprinter(arg, \" f<%X>\", uval);\n\t\t\t\t}\n\t\t\t\tprinter(arg, \" <M1%.*B%s>\", len, inp,\n\t\t\t\t    len == SHA_DIGESTSIZE ? \"\" : \"?\");\n\t\t\t\tINCPTR(len, inp);\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_ACK:\n\t\t\t\tbreak;\n\n\t\t\tcase EAPSRP_LWRECHALLENGE:\n\t\t\t\tprinter(arg, \" <Response%.*B%s>\", len, inp,\n\t\t\t\t    len == SHA_DIGESTSIZE ? \"\" : \"?\");\n\t\t\t\tif ((vallen = len) > SHA_DIGESTSIZE)\n\t\t\t\t\tvallen = SHA_DIGESTSIZE;\n\t\t\t\tINCPTR(vallen, inp);\n\t\t\t\tlen -= vallen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EAP_SUCCESS:\t/* No payload expected for these! */\n\tcase EAP_FAILURE:\n\t\tbreak;\n\n\ttruncated:\n\t\tprinter(arg, \" <truncated>\");\n\t\tbreak;\n\t}\n\n\tif (len > 8)\n\t\tprinter(arg, \"%8B...\", inp);\n\telse if (len > 0)\n\t\tprinter(arg, \"%.*B\", len, inp);\n\tINCPTR(len, inp);\n\n\treturn (inp - pstart);\n}\n"], "filenames": ["pppd/eap.c"], "buggy_code_start_loc": [1423], "buggy_code_end_loc": [1850], "fixing_code_start_loc": [1423], "fixing_code_end_loc": [1850], "type": "CWE-120", "message": "eap.c in pppd in ppp 2.4.2 through 2.4.8 has an rhostname buffer overflow in the eap_request and eap_response functions.", "other": {"cve": {"id": "CVE-2020-8597", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-03T23:15:11.387", "lastModified": "2023-05-05T17:48:17.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "eap.c in pppd in ppp 2.4.2 through 2.4.8 has an rhostname buffer overflow in the eap_request and eap_response functions."}, {"lang": "es", "value": "El archivo eap.c en pppd en ppp versiones 2.4.2 hasta 2.4.8, presenta un desbordamiento del b\u00fafer de rhostname en las funciones eap_request y eap_response."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:point-to-point_protocol_project:point-to-point_protocol:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.2", "versionEndIncluding": "2.4.8", "matchCriteriaId": "44FFBFCB-AFCE-4EE3-BA1E-5E0D0D60FFC1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:wago:pfc_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "03.04.10\\(16\\)", "matchCriteriaId": "8C3DA645-3F47-4B59-B56B-AB16431D0950"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:wago:pfc100:-:*:*:*:*:*:*:*", "matchCriteriaId": "8F636354-95A2-4B36-9666-1FA57F185432"}, {"vulnerable": false, "criteria": "cpe:2.3:h:wago:pfc200:-:*:*:*:*:*:*:*", "matchCriteriaId": "688A3248-7EAA-499D-A47C-A4D4900CDBD1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/156662/pppd-2.4.8-Buffer-Overflow.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/156802/pppd-2.4.8-Buffer-Overflow.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2020/Mar/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0630", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0631", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0633", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0634", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-809841.pdf", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/paulusmack/ppp/commit/8d7970b8f3db727fe798b65f3377fe6787575426", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kb.netgear.com/000061806/Security-Advisory-for-Unauthenticated-Remote-Buffer-Overflow-Attack-in-PPPD-on-WAC510-PSV-2020-0136", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00005.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UNJNHWOO4XF73M2W56ILZUY4JQG3JXIR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YOFDAIOWSWPG732ASYUZNINMXDHY4APE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-19", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200313-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://us-cert.cisa.gov/ics/advisories/icsa-20-224-04", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://usn.ubuntu.com/4288-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4288-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4632", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kb.cert.org/vuls/id/782301", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://www.synology.com/security/advisory/Synology_SA_20_02", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/paulusmack/ppp/commit/8d7970b8f3db727fe798b65f3377fe6787575426"}}