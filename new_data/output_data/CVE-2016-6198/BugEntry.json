{"buggy_code": ["/*\n *  linux/fs/open.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/namei.h>\n#include <linux/backing-dev.h>\n#include <linux/capability.h>\n#include <linux/securebits.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n#include <linux/personality.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/rcupdate.h>\n#include <linux/audit.h>\n#include <linux/falloc.h>\n#include <linux/fs_struct.h>\n#include <linux/ima.h>\n#include <linux/dnotify.h>\n#include <linux/compat.h>\n\n#include \"internal.h\"\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}\n\nlong vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_truncate);\n\nstatic long do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(truncate, const char __user *, path, long, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n#endif\n\nstatic long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(ftruncate, unsigned int, fd, unsigned long, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(ftruncate, unsigned int, fd, compat_ulong_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n#endif\n\n/* LFS versions of truncate are only needed on 32 bit machines */\n#if BITS_PER_LONG == 32\nSYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\nSYSCALL_DEFINE2(ftruncate64, unsigned int, fd, loff_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 0);\n}\n#endif /* BITS_PER_LONG == 32 */\n\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\t/*\n\t * Let individual file system decide if it supports preallocation\n\t * for directories or not.\n\t */\n\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tsb_start_write(inode->i_sb);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tsb_end_write(inode->i_sb);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfs_fallocate);\n\nSYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}\n\n/*\n * access() needs to use the real uid/gid, not the effective uid/gid.\n * We do this by temporarily clearing all FS-related capabilities and\n * switching the fsuid/fsgid around to the real ones.\n */\nSYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n{\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct path path;\n\tstruct inode *inode;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\n\tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n\t\treturn -EINVAL;\n\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\treturn -ENOMEM;\n\n\toverride_cred->fsuid = override_cred->uid;\n\toverride_cred->fsgid = override_cred->gid;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t/* Clear the capabilities if we switch to a non-root user */\n\t\tkuid_t root_uid = make_kuid(override_cred->user_ns, 0);\n\t\tif (!uid_eq(override_cred->uid, root_uid))\n\t\t\tcap_clear(override_cred->cap_effective);\n\t\telse\n\t\t\toverride_cred->cap_effective =\n\t\t\t\toverride_cred->cap_permitted;\n\t}\n\n\told_cred = override_creds(override_cred);\nretry:\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (res)\n\t\tgoto out;\n\n\tinode = d_backing_inode(path.dentry);\n\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\t/*\n\t\t * MAY_EXEC on regular files is denied if the fs is mounted\n\t\t * with the \"noexec\" flag.\n\t\t */\n\t\tres = -EACCES;\n\t\tif (path_noexec(&path))\n\t\t\tgoto out_path_release;\n\t}\n\n\tres = inode_permission(inode, mode | MAY_ACCESS);\n\t/* SuS v2 requires we report a read only fs too */\n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\n\t\tgoto out_path_release;\n\t/*\n\t * This is a rare case where using __mnt_is_readonly()\n\t * is OK without a mnt_want/drop_write() pair.  Since\n\t * no actual write to the fs is performed here, we do\n\t * not need to telegraph to that to anyone.\n\t *\n\t * By doing this, we accept that this access is\n\t * inherently racy and know that the fs may change\n\t * state before we even see this result.\n\t */\n\tif (__mnt_is_readonly(path.mnt))\n\t\tres = -EROFS;\n\nout_path_release:\n\tpath_put(&path);\n\tif (retry_estale(res, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\treturn res;\n}\n\nSYSCALL_DEFINE2(access, const char __user *, filename, int, mode)\n{\n\treturn sys_faccessat(AT_FDCWD, filename, mode);\n}\n\nSYSCALL_DEFINE1(chdir, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_pwd(current->fs, &path);\n\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(fchdir, unsigned int, fd)\n{\n\tstruct fd f = fdget_raw(fd);\n\tstruct inode *inode;\n\tint error = -EBADF;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\tinode = file_inode(f.file);\n\n\terror = -ENOTDIR;\n\tif (!S_ISDIR(inode->i_mode))\n\t\tgoto out_putf;\n\n\terror = inode_permission(inode, MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &f.file->f_path);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_root(current->fs, &path);\n\terror = 0;\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nstatic int chmod_common(struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\taudit_file(f.file);\n\t\terr = chmod_common(&f.file->f_path, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, umode_t, mode)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (!error) {\n\t\terror = chmod_common(&path, mode);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode)\n{\n\treturn sys_fchmodat(AT_FDCWD, filename, mode);\n}\n\nstatic int chown_common(struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(chown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn sys_fchownat(AT_FDCWD, filename, user, group, 0);\n}\n\nSYSCALL_DEFINE3(lchown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn sys_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t    AT_SYMLINK_NOFOLLOW);\n}\n\nSYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = mnt_want_write_file(f.file);\n\tif (error)\n\t\tgoto out_fput;\n\taudit_file(f.file);\n\terror = chown_common(&f.file->f_path, user, group);\n\tmnt_drop_write_file(f.file);\nout_fput:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nint open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}\n\n/**\n * finish_open - finish opening a file\n * @file: file pointer\n * @dentry: pointer to dentry\n * @open: open callback\n * @opened: state of open\n *\n * This can be used to finish opening a file passed to i_op->atomic_open().\n *\n * If the open callback is set to NULL, then the standard f_op->open()\n * filesystem callback is substituted.\n *\n * NB: the dentry reference is _not_ consumed.  If, for example, the dentry is\n * the return value of d_splice_alias(), then the caller needs to perform dput()\n * on it after finish_open().\n *\n * On successful return @file is a fully instantiated open file.  After this, if\n * an error occurs in ->atomic_open(), it needs to clean up with fput().\n *\n * Returns zero on success or -errno if the open failed.\n */\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, d_backing_inode(dentry), open,\n\t\t\t       current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}\nEXPORT_SYMBOL(finish_open);\n\n/**\n * finish_no_open - finish ->atomic_open() without opening the file\n *\n * @file: file pointer\n * @dentry: dentry or NULL (as returned from ->lookup())\n *\n * This can be used to set the result of a successful lookup in ->atomic_open().\n *\n * NB: unlike finish_open() this function does consume the dentry reference and\n * the caller need not dput() it.\n *\n * Returns \"1\" which must be the return value of ->atomic_open() after having\n * called this function.\n */\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}\nEXPORT_SYMBOL(finish_no_open);\n\nchar *file_path(struct file *filp, char *buf, int buflen)\n{\n\treturn d_path(&filp->f_path, buf, buflen);\n}\nEXPORT_SYMBOL(file_path);\n\n/**\n * vfs_open - open the file at the given path\n * @path: path to open\n * @file: newly allocated file with f_flag initialized\n * @cred: credentials to use\n */\nint vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\n\treturn do_dentry_open(file, inode, NULL, cred);\n}\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL(dentry_open);\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}\n\n/**\n * file_open_name - open file and return file pointer\n *\n * @name:\tstruct filename containing path to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}\n\n/**\n * filp_open - open file and return file pointer\n *\n * @filename:\tpath to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}\nEXPORT_SYMBOL(filp_open);\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}\nEXPORT_SYMBOL(file_open_root);\n\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}\n\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}\n\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(dfd, filename, flags, mode);\n}\n\n#ifndef __alpha__\n\n/*\n * For backward compatibility?  Maybe this should be moved\n * into arch/i386 instead?\n */\nSYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)\n{\n\treturn sys_open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode);\n}\n\n#endif\n\n/*\n * \"id\" is the POSIX thread ID. We use the\n * files pointer for this..\n */\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(filp_close);\n\n/*\n * Careful here! We test whether the file pointer is NULL before\n * releasing the fd. This ensures that one clone task can't release\n * an fd while another clone is opening it.\n */\nSYSCALL_DEFINE1(close, unsigned int, fd)\n{\n\tint retval = __close_fd(current->files, fd);\n\n\t/* can't restart close syscall because file table entry was cleared */\n\tif (unlikely(retval == -ERESTARTSYS ||\n\t\t     retval == -ERESTARTNOINTR ||\n\t\t     retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}\nEXPORT_SYMBOL(sys_close);\n\n/*\n * This routine simulates a hangup on the tty, to arrange that users\n * are given clean terminals at login time.\n */\nSYSCALL_DEFINE0(vhangup)\n{\n\tif (capable(CAP_SYS_TTY_CONFIG)) {\n\t\ttty_vhangup_self();\n\t\treturn 0;\n\t}\n\treturn -EPERM;\n}\n\n/*\n * Called when an inode is about to be open.\n * We use this to disallow opening large files on 32bit systems if\n * the caller didn't specify O_LARGEFILE.  On 64bit systems we force\n * on this flag in sys_open.\n */\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(generic_file_open);\n\n/*\n * This is used by subsystems that don't want seekable\n * file descriptors. The function is not supposed to ever fail, the only\n * reason it returns an 'int' and not 'void' is so that it can be plugged\n * directly into file_operations structure.\n */\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(nonseekable_open);\n", "#ifndef __LINUX_DCACHE_H\n#define __LINUX_DCACHE_H\n\n#include <linux/atomic.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/rculist_bl.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/cache.h>\n#include <linux/rcupdate.h>\n#include <linux/lockref.h>\n\nstruct path;\nstruct vfsmount;\n\n/*\n * linux/include/linux/dcache.h\n *\n * Dirent cache data structures\n *\n * (C) Copyright 1997 Thomas Schoebel-Theuer,\n * with heavy changes by Linus Torvalds\n */\n\n#define IS_ROOT(x) ((x) == (x)->d_parent)\n\n/* The hash is always the low bits of hash_len */\n#ifdef __LITTLE_ENDIAN\n #define HASH_LEN_DECLARE u32 hash; u32 len\n #define bytemask_from_count(cnt)\t(~(~0ul << (cnt)*8))\n#else\n #define HASH_LEN_DECLARE u32 len; u32 hash\n #define bytemask_from_count(cnt)\t(~(~0ul >> (cnt)*8))\n#endif\n\n/*\n * \"quick string\" -- eases parameter passing, but more importantly\n * saves \"metadata\" about the string (ie length and the hash).\n *\n * hash comes first so it snuggles against d_parent in the\n * dentry.\n */\nstruct qstr {\n\tunion {\n\t\tstruct {\n\t\t\tHASH_LEN_DECLARE;\n\t\t};\n\t\tu64 hash_len;\n\t};\n\tconst unsigned char *name;\n};\n\n#define QSTR_INIT(n,l) { { { .len = l } }, .name = n }\n#define hashlen_hash(hashlen) ((u32) (hashlen))\n#define hashlen_len(hashlen)  ((u32)((hashlen) >> 32))\n#define hashlen_create(hash,len) (((u64)(len)<<32)|(u32)(hash))\n\nstruct dentry_stat_t {\n\tlong nr_dentry;\n\tlong nr_unused;\n\tlong age_limit;          /* age in seconds */\n\tlong want_pages;         /* pages requested by system */\n\tlong dummy[2];\n};\nextern struct dentry_stat_t dentry_stat;\n\n/* Name hashing routines. Initial hash value */\n/* Hash courtesy of the R5 hash in reiserfs modulo sign bits */\n#define init_name_hash()\t\t0\n\n/* partial hash update function. Assume roughly 4 bits per character */\nstatic inline unsigned long\npartial_name_hash(unsigned long c, unsigned long prevhash)\n{\n\treturn (prevhash + (c << 4) + (c >> 4)) * 11;\n}\n\n/*\n * Finally: cut down the number of bits to a int value (and try to avoid\n * losing bits)\n */\nstatic inline unsigned long end_name_hash(unsigned long hash)\n{\n\treturn (unsigned int) hash;\n}\n\n/* Compute the hash for a name string. */\nextern unsigned int full_name_hash(const unsigned char *, unsigned int);\n\n/*\n * Try to keep struct dentry aligned on 64 byte cachelines (this will\n * give reasonable cacheline footprint with larger lines without the\n * large memory footprint increase).\n */\n#ifdef CONFIG_64BIT\n# define DNAME_INLINE_LEN 32 /* 192 bytes */\n#else\n# ifdef CONFIG_SMP\n#  define DNAME_INLINE_LEN 36 /* 128 bytes */\n# else\n#  define DNAME_INLINE_LEN 40 /* 128 bytes */\n# endif\n#endif\n\n#define d_lock\td_lockref.lock\n\nstruct dentry {\n\t/* RCU lookup touched fields */\n\tunsigned int d_flags;\t\t/* protected by d_lock */\n\tseqcount_t d_seq;\t\t/* per dentry seqlock */\n\tstruct hlist_bl_node d_hash;\t/* lookup hash list */\n\tstruct dentry *d_parent;\t/* parent directory */\n\tstruct qstr d_name;\n\tstruct inode *d_inode;\t\t/* Where the name belongs to - NULL is\n\t\t\t\t\t * negative */\n\tunsigned char d_iname[DNAME_INLINE_LEN];\t/* small names */\n\n\t/* Ref lookup also touches following */\n\tstruct lockref d_lockref;\t/* per-dentry lock and refcount */\n\tconst struct dentry_operations *d_op;\n\tstruct super_block *d_sb;\t/* The root of the dentry tree */\n\tunsigned long d_time;\t\t/* used by d_revalidate */\n\tvoid *d_fsdata;\t\t\t/* fs-specific data */\n\n\tstruct list_head d_lru;\t\t/* LRU list */\n\tstruct list_head d_child;\t/* child of parent list */\n\tstruct list_head d_subdirs;\t/* our children */\n\t/*\n\t * d_alias and d_rcu can share memory\n\t */\n\tunion {\n\t\tstruct hlist_node d_alias;\t/* inode alias list */\n\t \tstruct rcu_head d_rcu;\n\t} d_u;\n};\n\n/*\n * dentry->d_lock spinlock nesting subclasses:\n *\n * 0: normal\n * 1: nested\n */\nenum dentry_d_lock_class\n{\n\tDENTRY_D_LOCK_NORMAL, /* implicitly used by plain spin_lock() APIs. */\n\tDENTRY_D_LOCK_NESTED\n};\n\nstruct dentry_operations {\n\tint (*d_revalidate)(struct dentry *, unsigned int);\n\tint (*d_weak_revalidate)(struct dentry *, unsigned int);\n\tint (*d_hash)(const struct dentry *, struct qstr *);\n\tint (*d_compare)(const struct dentry *, const struct dentry *,\n\t\t\tunsigned int, const char *, const struct qstr *);\n\tint (*d_delete)(const struct dentry *);\n\tvoid (*d_release)(struct dentry *);\n\tvoid (*d_prune)(struct dentry *);\n\tvoid (*d_iput)(struct dentry *, struct inode *);\n\tchar *(*d_dname)(struct dentry *, char *, int);\n\tstruct vfsmount *(*d_automount)(struct path *);\n\tint (*d_manage)(struct dentry *, bool);\n\tstruct inode *(*d_select_inode)(struct dentry *, unsigned);\n\tstruct dentry *(*d_real)(struct dentry *, struct inode *);\n} ____cacheline_aligned;\n\n/*\n * Locking rules for dentry_operations callbacks are to be found in\n * Documentation/filesystems/Locking. Keep it updated!\n *\n * FUrther descriptions are found in Documentation/filesystems/vfs.txt.\n * Keep it updated too!\n */\n\n/* d_flags entries */\n#define DCACHE_OP_HASH\t\t\t0x00000001\n#define DCACHE_OP_COMPARE\t\t0x00000002\n#define DCACHE_OP_REVALIDATE\t\t0x00000004\n#define DCACHE_OP_DELETE\t\t0x00000008\n#define DCACHE_OP_PRUNE\t\t\t0x00000010\n\n#define\tDCACHE_DISCONNECTED\t\t0x00000020\n     /* This dentry is possibly not currently connected to the dcache tree, in\n      * which case its parent will either be itself, or will have this flag as\n      * well.  nfsd will not use a dentry with this bit set, but will first\n      * endeavour to clear the bit either by discovering that it is connected,\n      * or by performing lookup operations.   Any filesystem which supports\n      * nfsd_operations MUST have a lookup function which, if it finds a\n      * directory inode with a DCACHE_DISCONNECTED dentry, will d_move that\n      * dentry into place and return that dentry rather than the passed one,\n      * typically using d_splice_alias. */\n\n#define DCACHE_REFERENCED\t\t0x00000040 /* Recently used, don't discard. */\n#define DCACHE_RCUACCESS\t\t0x00000080 /* Entry has ever been RCU-visible */\n\n#define DCACHE_CANT_MOUNT\t\t0x00000100\n#define DCACHE_GENOCIDE\t\t\t0x00000200\n#define DCACHE_SHRINK_LIST\t\t0x00000400\n\n#define DCACHE_OP_WEAK_REVALIDATE\t0x00000800\n\n#define DCACHE_NFSFS_RENAMED\t\t0x00001000\n     /* this dentry has been \"silly renamed\" and has to be deleted on the last\n      * dput() */\n#define DCACHE_COOKIE\t\t\t0x00002000 /* For use by dcookie subsystem */\n#define DCACHE_FSNOTIFY_PARENT_WATCHED\t0x00004000\n     /* Parent inode is watched by some fsnotify listener */\n\n#define DCACHE_DENTRY_KILLED\t\t0x00008000\n\n#define DCACHE_MOUNTED\t\t\t0x00010000 /* is a mountpoint */\n#define DCACHE_NEED_AUTOMOUNT\t\t0x00020000 /* handle automount on this dir */\n#define DCACHE_MANAGE_TRANSIT\t\t0x00040000 /* manage transit from this dirent */\n#define DCACHE_MANAGED_DENTRY \\\n\t(DCACHE_MOUNTED|DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT)\n\n#define DCACHE_LRU_LIST\t\t\t0x00080000\n\n#define DCACHE_ENTRY_TYPE\t\t0x00700000\n#define DCACHE_MISS_TYPE\t\t0x00000000 /* Negative dentry (maybe fallthru to nowhere) */\n#define DCACHE_WHITEOUT_TYPE\t\t0x00100000 /* Whiteout dentry (stop pathwalk) */\n#define DCACHE_DIRECTORY_TYPE\t\t0x00200000 /* Normal directory */\n#define DCACHE_AUTODIR_TYPE\t\t0x00300000 /* Lookupless directory (presumed automount) */\n#define DCACHE_REGULAR_TYPE\t\t0x00400000 /* Regular file type (or fallthru to such) */\n#define DCACHE_SPECIAL_TYPE\t\t0x00500000 /* Other file type (or fallthru to such) */\n#define DCACHE_SYMLINK_TYPE\t\t0x00600000 /* Symlink (or fallthru to such) */\n\n#define DCACHE_MAY_FREE\t\t\t0x00800000\n#define DCACHE_FALLTHRU\t\t\t0x01000000 /* Fall through to lower layer */\n#define DCACHE_OP_SELECT_INODE\t\t0x02000000 /* Unioned entry: dcache op selects inode */\n\n#define DCACHE_ENCRYPTED_WITH_KEY\t0x04000000 /* dir is encrypted with a valid key */\n#define DCACHE_OP_REAL\t\t\t0x08000000\n\nextern seqlock_t rename_lock;\n\n/*\n * These are the low-level FS interfaces to the dcache..\n */\nextern void d_instantiate(struct dentry *, struct inode *);\nextern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);\nextern int d_instantiate_no_diralias(struct dentry *, struct inode *);\nextern void __d_drop(struct dentry *dentry);\nextern void d_drop(struct dentry *dentry);\nextern void d_delete(struct dentry *);\nextern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op);\n\n/* allocate/de-allocate */\nextern struct dentry * d_alloc(struct dentry *, const struct qstr *);\nextern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);\nextern struct dentry * d_splice_alias(struct inode *, struct dentry *);\nextern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);\nextern struct dentry * d_exact_alias(struct dentry *, struct inode *);\nextern struct dentry *d_find_any_alias(struct inode *inode);\nextern struct dentry * d_obtain_alias(struct inode *);\nextern struct dentry * d_obtain_root(struct inode *);\nextern void shrink_dcache_sb(struct super_block *);\nextern void shrink_dcache_parent(struct dentry *);\nextern void shrink_dcache_for_umount(struct super_block *);\nextern void d_invalidate(struct dentry *);\n\n/* only used at mount-time */\nextern struct dentry * d_make_root(struct inode *);\n\n/* <clickety>-<click> the ramfs-type tree */\nextern void d_genocide(struct dentry *);\n\nextern void d_tmpfile(struct dentry *, struct inode *);\n\nextern struct dentry *d_find_alias(struct inode *);\nextern void d_prune_aliases(struct inode *);\n\n/* test whether we have any submounts in a subdir tree */\nextern int have_submounts(struct dentry *);\n\n/*\n * This adds the entry to the hash queues.\n */\nextern void d_rehash(struct dentry *);\n \nextern void d_add(struct dentry *, struct inode *);\n\nextern void dentry_update_name_case(struct dentry *, struct qstr *);\n\n/* used for rename() and baskets */\nextern void d_move(struct dentry *, struct dentry *);\nextern void d_exchange(struct dentry *, struct dentry *);\nextern struct dentry *d_ancestor(struct dentry *, struct dentry *);\n\n/* appendix may either be NULL or be used for transname suffixes */\nextern struct dentry *d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);\nextern struct dentry *__d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name, unsigned *seq);\n\nstatic inline unsigned d_count(const struct dentry *dentry)\n{\n\treturn dentry->d_lockref.count;\n}\n\n/*\n * helper function for dentry_operations.d_dname() members\n */\nextern __printf(4, 5)\nchar *dynamic_dname(struct dentry *, char *, int, const char *, ...);\nextern char *simple_dname(struct dentry *, char *, int);\n\nextern char *__d_path(const struct path *, const struct path *, char *, int);\nextern char *d_absolute_path(const struct path *, char *, int);\nextern char *d_path(const struct path *, char *, int);\nextern char *dentry_path_raw(struct dentry *, char *, int);\nextern char *dentry_path(struct dentry *, char *, int);\n\n/* Allocation counts.. */\n\n/**\n *\tdget, dget_dlock -\tget a reference to a dentry\n *\t@dentry: dentry to get a reference to\n *\n *\tGiven a dentry or %NULL pointer increment the reference count\n *\tif appropriate and return the dentry. A dentry will not be \n *\tdestroyed when it has references.\n */\nstatic inline struct dentry *dget_dlock(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tdentry->d_lockref.count++;\n\treturn dentry;\n}\n\nstatic inline struct dentry *dget(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tlockref_get(&dentry->d_lockref);\n\treturn dentry;\n}\n\nextern struct dentry *dget_parent(struct dentry *dentry);\n\n/**\n *\td_unhashed -\tis dentry hashed\n *\t@dentry: entry to check\n *\n *\tReturns true if the dentry passed is not currently hashed.\n */\n \nstatic inline int d_unhashed(const struct dentry *dentry)\n{\n\treturn hlist_bl_unhashed(&dentry->d_hash);\n}\n\nstatic inline int d_unlinked(const struct dentry *dentry)\n{\n\treturn d_unhashed(dentry) && !IS_ROOT(dentry);\n}\n\nstatic inline int cant_mount(const struct dentry *dentry)\n{\n\treturn (dentry->d_flags & DCACHE_CANT_MOUNT);\n}\n\nstatic inline void dont_mount(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_CANT_MOUNT;\n\tspin_unlock(&dentry->d_lock);\n}\n\nextern void dput(struct dentry *);\n\nstatic inline bool d_managed(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MANAGED_DENTRY;\n}\n\nstatic inline bool d_mountpoint(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MOUNTED;\n}\n\n/*\n * Directory cache entry type accessor functions.\n */\nstatic inline unsigned __d_entry_type(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_ENTRY_TYPE;\n}\n\nstatic inline bool d_is_miss(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_MISS_TYPE;\n}\n\nstatic inline bool d_is_whiteout(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_WHITEOUT_TYPE;\n}\n\nstatic inline bool d_can_lookup(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_DIRECTORY_TYPE;\n}\n\nstatic inline bool d_is_autodir(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_AUTODIR_TYPE;\n}\n\nstatic inline bool d_is_dir(const struct dentry *dentry)\n{\n\treturn d_can_lookup(dentry) || d_is_autodir(dentry);\n}\n\nstatic inline bool d_is_symlink(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SYMLINK_TYPE;\n}\n\nstatic inline bool d_is_reg(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_REGULAR_TYPE;\n}\n\nstatic inline bool d_is_special(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SPECIAL_TYPE;\n}\n\nstatic inline bool d_is_file(const struct dentry *dentry)\n{\n\treturn d_is_reg(dentry) || d_is_special(dentry);\n}\n\nstatic inline bool d_is_negative(const struct dentry *dentry)\n{\n\t// TODO: check d_is_whiteout(dentry) also.\n\treturn d_is_miss(dentry);\n}\n\nstatic inline bool d_is_positive(const struct dentry *dentry)\n{\n\treturn !d_is_negative(dentry);\n}\n\n/**\n * d_really_is_negative - Determine if a dentry is really negative (ignoring fallthroughs)\n * @dentry: The dentry in question\n *\n * Returns true if the dentry represents either an absent name or a name that\n * doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent\n * a true miss, a whiteout that isn't represented by a 0,0 chardev or a\n * fallthrough marker in an opaque directory.\n *\n * Note!  (1) This should be used *only* by a filesystem to examine its own\n * dentries.  It should not be used to look at some other filesystem's\n * dentries.  (2) It should also be used in combination with d_inode() to get\n * the inode.  (3) The dentry may have something attached to ->d_lower and the\n * type field of the flags may be set to something other than miss or whiteout.\n */\nstatic inline bool d_really_is_negative(const struct dentry *dentry)\n{\n\treturn dentry->d_inode == NULL;\n}\n\n/**\n * d_really_is_positive - Determine if a dentry is really positive (ignoring fallthroughs)\n * @dentry: The dentry in question\n *\n * Returns true if the dentry represents a name that maps to an inode\n * (ie. ->d_inode is not NULL).  The dentry might still represent a whiteout if\n * that is represented on medium as a 0,0 chardev.\n *\n * Note!  (1) This should be used *only* by a filesystem to examine its own\n * dentries.  It should not be used to look at some other filesystem's\n * dentries.  (2) It should also be used in combination with d_inode() to get\n * the inode.\n */\nstatic inline bool d_really_is_positive(const struct dentry *dentry)\n{\n\treturn dentry->d_inode != NULL;\n}\n\nstatic inline int simple_positive(struct dentry *dentry)\n{\n\treturn d_really_is_positive(dentry) && !d_unhashed(dentry);\n}\n\nextern void d_set_fallthru(struct dentry *dentry);\n\nstatic inline bool d_is_fallthru(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_FALLTHRU;\n}\n\n\nextern int sysctl_vfs_cache_pressure;\n\nstatic inline unsigned long vfs_pressure_ratio(unsigned long val)\n{\n\treturn mult_frac(val, sysctl_vfs_cache_pressure, 100);\n}\n\n/**\n * d_inode - Get the actual inode of this dentry\n * @dentry: The dentry to query\n *\n * This is the helper normal filesystems should use to get at their own inodes\n * in their own dentries and ignore the layering superimposed upon them.\n */\nstatic inline struct inode *d_inode(const struct dentry *dentry)\n{\n\treturn dentry->d_inode;\n}\n\n/**\n * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()\n * @dentry: The dentry to query\n *\n * This is the helper normal filesystems should use to get at their own inodes\n * in their own dentries and ignore the layering superimposed upon them.\n */\nstatic inline struct inode *d_inode_rcu(const struct dentry *dentry)\n{\n\treturn ACCESS_ONCE(dentry->d_inode);\n}\n\n/**\n * d_backing_inode - Get upper or lower inode we should be using\n * @upper: The upper layer\n *\n * This is the helper that should be used to get at the inode that will be used\n * if this dentry were to be opened as a file.  The inode may be on the upper\n * dentry or it may be on a lower dentry pinned by the upper.\n *\n * Normal filesystems should not use this to access their own inodes.\n */\nstatic inline struct inode *d_backing_inode(const struct dentry *upper)\n{\n\tstruct inode *inode = upper->d_inode;\n\n\treturn inode;\n}\n\n/**\n * d_backing_dentry - Get upper or lower dentry we should be using\n * @upper: The upper layer\n *\n * This is the helper that should be used to get the dentry of the inode that\n * will be used if this dentry were opened as a file.  It may be the upper\n * dentry or it may be a lower dentry pinned by the upper.\n *\n * Normal filesystems should not use this to access their own dentries.\n */\nstatic inline struct dentry *d_backing_dentry(struct dentry *upper)\n{\n\treturn upper;\n}\n\nstatic inline struct dentry *d_real(struct dentry *dentry)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REAL))\n\t\treturn dentry->d_op->d_real(dentry, NULL);\n\telse\n\t\treturn dentry;\n}\n\n#endif\t/* __LINUX_DCACHE_H */\n"], "fixing_code": ["/*\n *  linux/fs/open.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fsnotify.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/namei.h>\n#include <linux/backing-dev.h>\n#include <linux/capability.h>\n#include <linux/securebits.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n#include <linux/personality.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/rcupdate.h>\n#include <linux/audit.h>\n#include <linux/falloc.h>\n#include <linux/fs_struct.h>\n#include <linux/ima.h>\n#include <linux/dnotify.h>\n#include <linux/compat.h>\n\n#include \"internal.h\"\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}\n\nlong vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_truncate);\n\nstatic long do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(truncate, const char __user *, path, long, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n#endif\n\nstatic long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(ftruncate, unsigned int, fd, unsigned long, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(ftruncate, unsigned int, fd, compat_ulong_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n#endif\n\n/* LFS versions of truncate are only needed on 32 bit machines */\n#if BITS_PER_LONG == 32\nSYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}\n\nSYSCALL_DEFINE2(ftruncate64, unsigned int, fd, loff_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 0);\n}\n#endif /* BITS_PER_LONG == 32 */\n\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\t/*\n\t * Let individual file system decide if it supports preallocation\n\t * for directories or not.\n\t */\n\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tsb_start_write(inode->i_sb);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tsb_end_write(inode->i_sb);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfs_fallocate);\n\nSYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}\n\n/*\n * access() needs to use the real uid/gid, not the effective uid/gid.\n * We do this by temporarily clearing all FS-related capabilities and\n * switching the fsuid/fsgid around to the real ones.\n */\nSYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n{\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct path path;\n\tstruct inode *inode;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\n\tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n\t\treturn -EINVAL;\n\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\treturn -ENOMEM;\n\n\toverride_cred->fsuid = override_cred->uid;\n\toverride_cred->fsgid = override_cred->gid;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t/* Clear the capabilities if we switch to a non-root user */\n\t\tkuid_t root_uid = make_kuid(override_cred->user_ns, 0);\n\t\tif (!uid_eq(override_cred->uid, root_uid))\n\t\t\tcap_clear(override_cred->cap_effective);\n\t\telse\n\t\t\toverride_cred->cap_effective =\n\t\t\t\toverride_cred->cap_permitted;\n\t}\n\n\told_cred = override_creds(override_cred);\nretry:\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (res)\n\t\tgoto out;\n\n\tinode = d_backing_inode(path.dentry);\n\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\t/*\n\t\t * MAY_EXEC on regular files is denied if the fs is mounted\n\t\t * with the \"noexec\" flag.\n\t\t */\n\t\tres = -EACCES;\n\t\tif (path_noexec(&path))\n\t\t\tgoto out_path_release;\n\t}\n\n\tres = inode_permission(inode, mode | MAY_ACCESS);\n\t/* SuS v2 requires we report a read only fs too */\n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\n\t\tgoto out_path_release;\n\t/*\n\t * This is a rare case where using __mnt_is_readonly()\n\t * is OK without a mnt_want/drop_write() pair.  Since\n\t * no actual write to the fs is performed here, we do\n\t * not need to telegraph to that to anyone.\n\t *\n\t * By doing this, we accept that this access is\n\t * inherently racy and know that the fs may change\n\t * state before we even see this result.\n\t */\n\tif (__mnt_is_readonly(path.mnt))\n\t\tres = -EROFS;\n\nout_path_release:\n\tpath_put(&path);\n\tif (retry_estale(res, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\treturn res;\n}\n\nSYSCALL_DEFINE2(access, const char __user *, filename, int, mode)\n{\n\treturn sys_faccessat(AT_FDCWD, filename, mode);\n}\n\nSYSCALL_DEFINE1(chdir, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_pwd(current->fs, &path);\n\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(fchdir, unsigned int, fd)\n{\n\tstruct fd f = fdget_raw(fd);\n\tstruct inode *inode;\n\tint error = -EBADF;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\tinode = file_inode(f.file);\n\n\terror = -ENOTDIR;\n\tif (!S_ISDIR(inode->i_mode))\n\t\tgoto out_putf;\n\n\terror = inode_permission(inode, MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &f.file->f_path);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_root(current->fs, &path);\n\terror = 0;\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nstatic int chmod_common(struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\taudit_file(f.file);\n\t\terr = chmod_common(&f.file->f_path, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, umode_t, mode)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (!error) {\n\t\terror = chmod_common(&path, mode);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode)\n{\n\treturn sys_fchmodat(AT_FDCWD, filename, mode);\n}\n\nstatic int chown_common(struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(chown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn sys_fchownat(AT_FDCWD, filename, user, group, 0);\n}\n\nSYSCALL_DEFINE3(lchown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn sys_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t    AT_SYMLINK_NOFOLLOW);\n}\n\nSYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = mnt_want_write_file(f.file);\n\tif (error)\n\t\tgoto out_fput;\n\taudit_file(f.file);\n\terror = chown_common(&f.file->f_path, user, group);\n\tmnt_drop_write_file(f.file);\nout_fput:\n\tfdput(f);\nout:\n\treturn error;\n}\n\nint open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}\n\n/**\n * finish_open - finish opening a file\n * @file: file pointer\n * @dentry: pointer to dentry\n * @open: open callback\n * @opened: state of open\n *\n * This can be used to finish opening a file passed to i_op->atomic_open().\n *\n * If the open callback is set to NULL, then the standard f_op->open()\n * filesystem callback is substituted.\n *\n * NB: the dentry reference is _not_ consumed.  If, for example, the dentry is\n * the return value of d_splice_alias(), then the caller needs to perform dput()\n * on it after finish_open().\n *\n * On successful return @file is a fully instantiated open file.  After this, if\n * an error occurs in ->atomic_open(), it needs to clean up with fput().\n *\n * Returns zero on success or -errno if the open failed.\n */\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, d_backing_inode(dentry), open,\n\t\t\t       current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}\nEXPORT_SYMBOL(finish_open);\n\n/**\n * finish_no_open - finish ->atomic_open() without opening the file\n *\n * @file: file pointer\n * @dentry: dentry or NULL (as returned from ->lookup())\n *\n * This can be used to set the result of a successful lookup in ->atomic_open().\n *\n * NB: unlike finish_open() this function does consume the dentry reference and\n * the caller need not dput() it.\n *\n * Returns \"1\" which must be the return value of ->atomic_open() after having\n * called this function.\n */\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}\nEXPORT_SYMBOL(finish_no_open);\n\nchar *file_path(struct file *filp, char *buf, int buflen)\n{\n\treturn d_path(&filp->f_path, buf, buflen);\n}\nEXPORT_SYMBOL(file_path);\n\n/**\n * vfs_open - open the file at the given path\n * @path: path to open\n * @file: newly allocated file with f_flag initialized\n * @cred: credentials to use\n */\nint vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, inode, NULL, cred);\n}\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\nEXPORT_SYMBOL(dentry_open);\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}\n\n/**\n * file_open_name - open file and return file pointer\n *\n * @name:\tstruct filename containing path to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}\n\n/**\n * filp_open - open file and return file pointer\n *\n * @filename:\tpath to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}\nEXPORT_SYMBOL(filp_open);\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}\nEXPORT_SYMBOL(file_open_root);\n\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}\n\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}\n\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(dfd, filename, flags, mode);\n}\n\n#ifndef __alpha__\n\n/*\n * For backward compatibility?  Maybe this should be moved\n * into arch/i386 instead?\n */\nSYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)\n{\n\treturn sys_open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode);\n}\n\n#endif\n\n/*\n * \"id\" is the POSIX thread ID. We use the\n * files pointer for this..\n */\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(filp_close);\n\n/*\n * Careful here! We test whether the file pointer is NULL before\n * releasing the fd. This ensures that one clone task can't release\n * an fd while another clone is opening it.\n */\nSYSCALL_DEFINE1(close, unsigned int, fd)\n{\n\tint retval = __close_fd(current->files, fd);\n\n\t/* can't restart close syscall because file table entry was cleared */\n\tif (unlikely(retval == -ERESTARTSYS ||\n\t\t     retval == -ERESTARTNOINTR ||\n\t\t     retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}\nEXPORT_SYMBOL(sys_close);\n\n/*\n * This routine simulates a hangup on the tty, to arrange that users\n * are given clean terminals at login time.\n */\nSYSCALL_DEFINE0(vhangup)\n{\n\tif (capable(CAP_SYS_TTY_CONFIG)) {\n\t\ttty_vhangup_self();\n\t\treturn 0;\n\t}\n\treturn -EPERM;\n}\n\n/*\n * Called when an inode is about to be open.\n * We use this to disallow opening large files on 32bit systems if\n * the caller didn't specify O_LARGEFILE.  On 64bit systems we force\n * on this flag in sys_open.\n */\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(generic_file_open);\n\n/*\n * This is used by subsystems that don't want seekable\n * file descriptors. The function is not supposed to ever fail, the only\n * reason it returns an 'int' and not 'void' is so that it can be plugged\n * directly into file_operations structure.\n */\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(nonseekable_open);\n", "#ifndef __LINUX_DCACHE_H\n#define __LINUX_DCACHE_H\n\n#include <linux/atomic.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/rculist_bl.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/cache.h>\n#include <linux/rcupdate.h>\n#include <linux/lockref.h>\n\nstruct path;\nstruct vfsmount;\n\n/*\n * linux/include/linux/dcache.h\n *\n * Dirent cache data structures\n *\n * (C) Copyright 1997 Thomas Schoebel-Theuer,\n * with heavy changes by Linus Torvalds\n */\n\n#define IS_ROOT(x) ((x) == (x)->d_parent)\n\n/* The hash is always the low bits of hash_len */\n#ifdef __LITTLE_ENDIAN\n #define HASH_LEN_DECLARE u32 hash; u32 len\n #define bytemask_from_count(cnt)\t(~(~0ul << (cnt)*8))\n#else\n #define HASH_LEN_DECLARE u32 len; u32 hash\n #define bytemask_from_count(cnt)\t(~(~0ul >> (cnt)*8))\n#endif\n\n/*\n * \"quick string\" -- eases parameter passing, but more importantly\n * saves \"metadata\" about the string (ie length and the hash).\n *\n * hash comes first so it snuggles against d_parent in the\n * dentry.\n */\nstruct qstr {\n\tunion {\n\t\tstruct {\n\t\t\tHASH_LEN_DECLARE;\n\t\t};\n\t\tu64 hash_len;\n\t};\n\tconst unsigned char *name;\n};\n\n#define QSTR_INIT(n,l) { { { .len = l } }, .name = n }\n#define hashlen_hash(hashlen) ((u32) (hashlen))\n#define hashlen_len(hashlen)  ((u32)((hashlen) >> 32))\n#define hashlen_create(hash,len) (((u64)(len)<<32)|(u32)(hash))\n\nstruct dentry_stat_t {\n\tlong nr_dentry;\n\tlong nr_unused;\n\tlong age_limit;          /* age in seconds */\n\tlong want_pages;         /* pages requested by system */\n\tlong dummy[2];\n};\nextern struct dentry_stat_t dentry_stat;\n\n/* Name hashing routines. Initial hash value */\n/* Hash courtesy of the R5 hash in reiserfs modulo sign bits */\n#define init_name_hash()\t\t0\n\n/* partial hash update function. Assume roughly 4 bits per character */\nstatic inline unsigned long\npartial_name_hash(unsigned long c, unsigned long prevhash)\n{\n\treturn (prevhash + (c << 4) + (c >> 4)) * 11;\n}\n\n/*\n * Finally: cut down the number of bits to a int value (and try to avoid\n * losing bits)\n */\nstatic inline unsigned long end_name_hash(unsigned long hash)\n{\n\treturn (unsigned int) hash;\n}\n\n/* Compute the hash for a name string. */\nextern unsigned int full_name_hash(const unsigned char *, unsigned int);\n\n/*\n * Try to keep struct dentry aligned on 64 byte cachelines (this will\n * give reasonable cacheline footprint with larger lines without the\n * large memory footprint increase).\n */\n#ifdef CONFIG_64BIT\n# define DNAME_INLINE_LEN 32 /* 192 bytes */\n#else\n# ifdef CONFIG_SMP\n#  define DNAME_INLINE_LEN 36 /* 128 bytes */\n# else\n#  define DNAME_INLINE_LEN 40 /* 128 bytes */\n# endif\n#endif\n\n#define d_lock\td_lockref.lock\n\nstruct dentry {\n\t/* RCU lookup touched fields */\n\tunsigned int d_flags;\t\t/* protected by d_lock */\n\tseqcount_t d_seq;\t\t/* per dentry seqlock */\n\tstruct hlist_bl_node d_hash;\t/* lookup hash list */\n\tstruct dentry *d_parent;\t/* parent directory */\n\tstruct qstr d_name;\n\tstruct inode *d_inode;\t\t/* Where the name belongs to - NULL is\n\t\t\t\t\t * negative */\n\tunsigned char d_iname[DNAME_INLINE_LEN];\t/* small names */\n\n\t/* Ref lookup also touches following */\n\tstruct lockref d_lockref;\t/* per-dentry lock and refcount */\n\tconst struct dentry_operations *d_op;\n\tstruct super_block *d_sb;\t/* The root of the dentry tree */\n\tunsigned long d_time;\t\t/* used by d_revalidate */\n\tvoid *d_fsdata;\t\t\t/* fs-specific data */\n\n\tstruct list_head d_lru;\t\t/* LRU list */\n\tstruct list_head d_child;\t/* child of parent list */\n\tstruct list_head d_subdirs;\t/* our children */\n\t/*\n\t * d_alias and d_rcu can share memory\n\t */\n\tunion {\n\t\tstruct hlist_node d_alias;\t/* inode alias list */\n\t \tstruct rcu_head d_rcu;\n\t} d_u;\n};\n\n/*\n * dentry->d_lock spinlock nesting subclasses:\n *\n * 0: normal\n * 1: nested\n */\nenum dentry_d_lock_class\n{\n\tDENTRY_D_LOCK_NORMAL, /* implicitly used by plain spin_lock() APIs. */\n\tDENTRY_D_LOCK_NESTED\n};\n\nstruct dentry_operations {\n\tint (*d_revalidate)(struct dentry *, unsigned int);\n\tint (*d_weak_revalidate)(struct dentry *, unsigned int);\n\tint (*d_hash)(const struct dentry *, struct qstr *);\n\tint (*d_compare)(const struct dentry *, const struct dentry *,\n\t\t\tunsigned int, const char *, const struct qstr *);\n\tint (*d_delete)(const struct dentry *);\n\tvoid (*d_release)(struct dentry *);\n\tvoid (*d_prune)(struct dentry *);\n\tvoid (*d_iput)(struct dentry *, struct inode *);\n\tchar *(*d_dname)(struct dentry *, char *, int);\n\tstruct vfsmount *(*d_automount)(struct path *);\n\tint (*d_manage)(struct dentry *, bool);\n\tstruct inode *(*d_select_inode)(struct dentry *, unsigned);\n\tstruct dentry *(*d_real)(struct dentry *, struct inode *);\n} ____cacheline_aligned;\n\n/*\n * Locking rules for dentry_operations callbacks are to be found in\n * Documentation/filesystems/Locking. Keep it updated!\n *\n * FUrther descriptions are found in Documentation/filesystems/vfs.txt.\n * Keep it updated too!\n */\n\n/* d_flags entries */\n#define DCACHE_OP_HASH\t\t\t0x00000001\n#define DCACHE_OP_COMPARE\t\t0x00000002\n#define DCACHE_OP_REVALIDATE\t\t0x00000004\n#define DCACHE_OP_DELETE\t\t0x00000008\n#define DCACHE_OP_PRUNE\t\t\t0x00000010\n\n#define\tDCACHE_DISCONNECTED\t\t0x00000020\n     /* This dentry is possibly not currently connected to the dcache tree, in\n      * which case its parent will either be itself, or will have this flag as\n      * well.  nfsd will not use a dentry with this bit set, but will first\n      * endeavour to clear the bit either by discovering that it is connected,\n      * or by performing lookup operations.   Any filesystem which supports\n      * nfsd_operations MUST have a lookup function which, if it finds a\n      * directory inode with a DCACHE_DISCONNECTED dentry, will d_move that\n      * dentry into place and return that dentry rather than the passed one,\n      * typically using d_splice_alias. */\n\n#define DCACHE_REFERENCED\t\t0x00000040 /* Recently used, don't discard. */\n#define DCACHE_RCUACCESS\t\t0x00000080 /* Entry has ever been RCU-visible */\n\n#define DCACHE_CANT_MOUNT\t\t0x00000100\n#define DCACHE_GENOCIDE\t\t\t0x00000200\n#define DCACHE_SHRINK_LIST\t\t0x00000400\n\n#define DCACHE_OP_WEAK_REVALIDATE\t0x00000800\n\n#define DCACHE_NFSFS_RENAMED\t\t0x00001000\n     /* this dentry has been \"silly renamed\" and has to be deleted on the last\n      * dput() */\n#define DCACHE_COOKIE\t\t\t0x00002000 /* For use by dcookie subsystem */\n#define DCACHE_FSNOTIFY_PARENT_WATCHED\t0x00004000\n     /* Parent inode is watched by some fsnotify listener */\n\n#define DCACHE_DENTRY_KILLED\t\t0x00008000\n\n#define DCACHE_MOUNTED\t\t\t0x00010000 /* is a mountpoint */\n#define DCACHE_NEED_AUTOMOUNT\t\t0x00020000 /* handle automount on this dir */\n#define DCACHE_MANAGE_TRANSIT\t\t0x00040000 /* manage transit from this dirent */\n#define DCACHE_MANAGED_DENTRY \\\n\t(DCACHE_MOUNTED|DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT)\n\n#define DCACHE_LRU_LIST\t\t\t0x00080000\n\n#define DCACHE_ENTRY_TYPE\t\t0x00700000\n#define DCACHE_MISS_TYPE\t\t0x00000000 /* Negative dentry (maybe fallthru to nowhere) */\n#define DCACHE_WHITEOUT_TYPE\t\t0x00100000 /* Whiteout dentry (stop pathwalk) */\n#define DCACHE_DIRECTORY_TYPE\t\t0x00200000 /* Normal directory */\n#define DCACHE_AUTODIR_TYPE\t\t0x00300000 /* Lookupless directory (presumed automount) */\n#define DCACHE_REGULAR_TYPE\t\t0x00400000 /* Regular file type (or fallthru to such) */\n#define DCACHE_SPECIAL_TYPE\t\t0x00500000 /* Other file type (or fallthru to such) */\n#define DCACHE_SYMLINK_TYPE\t\t0x00600000 /* Symlink (or fallthru to such) */\n\n#define DCACHE_MAY_FREE\t\t\t0x00800000\n#define DCACHE_FALLTHRU\t\t\t0x01000000 /* Fall through to lower layer */\n#define DCACHE_OP_SELECT_INODE\t\t0x02000000 /* Unioned entry: dcache op selects inode */\n\n#define DCACHE_ENCRYPTED_WITH_KEY\t0x04000000 /* dir is encrypted with a valid key */\n#define DCACHE_OP_REAL\t\t\t0x08000000\n\nextern seqlock_t rename_lock;\n\n/*\n * These are the low-level FS interfaces to the dcache..\n */\nextern void d_instantiate(struct dentry *, struct inode *);\nextern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);\nextern int d_instantiate_no_diralias(struct dentry *, struct inode *);\nextern void __d_drop(struct dentry *dentry);\nextern void d_drop(struct dentry *dentry);\nextern void d_delete(struct dentry *);\nextern void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op);\n\n/* allocate/de-allocate */\nextern struct dentry * d_alloc(struct dentry *, const struct qstr *);\nextern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);\nextern struct dentry * d_splice_alias(struct inode *, struct dentry *);\nextern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);\nextern struct dentry * d_exact_alias(struct dentry *, struct inode *);\nextern struct dentry *d_find_any_alias(struct inode *inode);\nextern struct dentry * d_obtain_alias(struct inode *);\nextern struct dentry * d_obtain_root(struct inode *);\nextern void shrink_dcache_sb(struct super_block *);\nextern void shrink_dcache_parent(struct dentry *);\nextern void shrink_dcache_for_umount(struct super_block *);\nextern void d_invalidate(struct dentry *);\n\n/* only used at mount-time */\nextern struct dentry * d_make_root(struct inode *);\n\n/* <clickety>-<click> the ramfs-type tree */\nextern void d_genocide(struct dentry *);\n\nextern void d_tmpfile(struct dentry *, struct inode *);\n\nextern struct dentry *d_find_alias(struct inode *);\nextern void d_prune_aliases(struct inode *);\n\n/* test whether we have any submounts in a subdir tree */\nextern int have_submounts(struct dentry *);\n\n/*\n * This adds the entry to the hash queues.\n */\nextern void d_rehash(struct dentry *);\n \nextern void d_add(struct dentry *, struct inode *);\n\nextern void dentry_update_name_case(struct dentry *, struct qstr *);\n\n/* used for rename() and baskets */\nextern void d_move(struct dentry *, struct dentry *);\nextern void d_exchange(struct dentry *, struct dentry *);\nextern struct dentry *d_ancestor(struct dentry *, struct dentry *);\n\n/* appendix may either be NULL or be used for transname suffixes */\nextern struct dentry *d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *d_hash_and_lookup(struct dentry *, struct qstr *);\nextern struct dentry *__d_lookup(const struct dentry *, const struct qstr *);\nextern struct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name, unsigned *seq);\n\nstatic inline unsigned d_count(const struct dentry *dentry)\n{\n\treturn dentry->d_lockref.count;\n}\n\n/*\n * helper function for dentry_operations.d_dname() members\n */\nextern __printf(4, 5)\nchar *dynamic_dname(struct dentry *, char *, int, const char *, ...);\nextern char *simple_dname(struct dentry *, char *, int);\n\nextern char *__d_path(const struct path *, const struct path *, char *, int);\nextern char *d_absolute_path(const struct path *, char *, int);\nextern char *d_path(const struct path *, char *, int);\nextern char *dentry_path_raw(struct dentry *, char *, int);\nextern char *dentry_path(struct dentry *, char *, int);\n\n/* Allocation counts.. */\n\n/**\n *\tdget, dget_dlock -\tget a reference to a dentry\n *\t@dentry: dentry to get a reference to\n *\n *\tGiven a dentry or %NULL pointer increment the reference count\n *\tif appropriate and return the dentry. A dentry will not be \n *\tdestroyed when it has references.\n */\nstatic inline struct dentry *dget_dlock(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tdentry->d_lockref.count++;\n\treturn dentry;\n}\n\nstatic inline struct dentry *dget(struct dentry *dentry)\n{\n\tif (dentry)\n\t\tlockref_get(&dentry->d_lockref);\n\treturn dentry;\n}\n\nextern struct dentry *dget_parent(struct dentry *dentry);\n\n/**\n *\td_unhashed -\tis dentry hashed\n *\t@dentry: entry to check\n *\n *\tReturns true if the dentry passed is not currently hashed.\n */\n \nstatic inline int d_unhashed(const struct dentry *dentry)\n{\n\treturn hlist_bl_unhashed(&dentry->d_hash);\n}\n\nstatic inline int d_unlinked(const struct dentry *dentry)\n{\n\treturn d_unhashed(dentry) && !IS_ROOT(dentry);\n}\n\nstatic inline int cant_mount(const struct dentry *dentry)\n{\n\treturn (dentry->d_flags & DCACHE_CANT_MOUNT);\n}\n\nstatic inline void dont_mount(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_CANT_MOUNT;\n\tspin_unlock(&dentry->d_lock);\n}\n\nextern void dput(struct dentry *);\n\nstatic inline bool d_managed(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MANAGED_DENTRY;\n}\n\nstatic inline bool d_mountpoint(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_MOUNTED;\n}\n\n/*\n * Directory cache entry type accessor functions.\n */\nstatic inline unsigned __d_entry_type(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_ENTRY_TYPE;\n}\n\nstatic inline bool d_is_miss(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_MISS_TYPE;\n}\n\nstatic inline bool d_is_whiteout(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_WHITEOUT_TYPE;\n}\n\nstatic inline bool d_can_lookup(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_DIRECTORY_TYPE;\n}\n\nstatic inline bool d_is_autodir(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_AUTODIR_TYPE;\n}\n\nstatic inline bool d_is_dir(const struct dentry *dentry)\n{\n\treturn d_can_lookup(dentry) || d_is_autodir(dentry);\n}\n\nstatic inline bool d_is_symlink(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SYMLINK_TYPE;\n}\n\nstatic inline bool d_is_reg(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_REGULAR_TYPE;\n}\n\nstatic inline bool d_is_special(const struct dentry *dentry)\n{\n\treturn __d_entry_type(dentry) == DCACHE_SPECIAL_TYPE;\n}\n\nstatic inline bool d_is_file(const struct dentry *dentry)\n{\n\treturn d_is_reg(dentry) || d_is_special(dentry);\n}\n\nstatic inline bool d_is_negative(const struct dentry *dentry)\n{\n\t// TODO: check d_is_whiteout(dentry) also.\n\treturn d_is_miss(dentry);\n}\n\nstatic inline bool d_is_positive(const struct dentry *dentry)\n{\n\treturn !d_is_negative(dentry);\n}\n\n/**\n * d_really_is_negative - Determine if a dentry is really negative (ignoring fallthroughs)\n * @dentry: The dentry in question\n *\n * Returns true if the dentry represents either an absent name or a name that\n * doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent\n * a true miss, a whiteout that isn't represented by a 0,0 chardev or a\n * fallthrough marker in an opaque directory.\n *\n * Note!  (1) This should be used *only* by a filesystem to examine its own\n * dentries.  It should not be used to look at some other filesystem's\n * dentries.  (2) It should also be used in combination with d_inode() to get\n * the inode.  (3) The dentry may have something attached to ->d_lower and the\n * type field of the flags may be set to something other than miss or whiteout.\n */\nstatic inline bool d_really_is_negative(const struct dentry *dentry)\n{\n\treturn dentry->d_inode == NULL;\n}\n\n/**\n * d_really_is_positive - Determine if a dentry is really positive (ignoring fallthroughs)\n * @dentry: The dentry in question\n *\n * Returns true if the dentry represents a name that maps to an inode\n * (ie. ->d_inode is not NULL).  The dentry might still represent a whiteout if\n * that is represented on medium as a 0,0 chardev.\n *\n * Note!  (1) This should be used *only* by a filesystem to examine its own\n * dentries.  It should not be used to look at some other filesystem's\n * dentries.  (2) It should also be used in combination with d_inode() to get\n * the inode.\n */\nstatic inline bool d_really_is_positive(const struct dentry *dentry)\n{\n\treturn dentry->d_inode != NULL;\n}\n\nstatic inline int simple_positive(struct dentry *dentry)\n{\n\treturn d_really_is_positive(dentry) && !d_unhashed(dentry);\n}\n\nextern void d_set_fallthru(struct dentry *dentry);\n\nstatic inline bool d_is_fallthru(const struct dentry *dentry)\n{\n\treturn dentry->d_flags & DCACHE_FALLTHRU;\n}\n\n\nextern int sysctl_vfs_cache_pressure;\n\nstatic inline unsigned long vfs_pressure_ratio(unsigned long val)\n{\n\treturn mult_frac(val, sysctl_vfs_cache_pressure, 100);\n}\n\n/**\n * d_inode - Get the actual inode of this dentry\n * @dentry: The dentry to query\n *\n * This is the helper normal filesystems should use to get at their own inodes\n * in their own dentries and ignore the layering superimposed upon them.\n */\nstatic inline struct inode *d_inode(const struct dentry *dentry)\n{\n\treturn dentry->d_inode;\n}\n\n/**\n * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()\n * @dentry: The dentry to query\n *\n * This is the helper normal filesystems should use to get at their own inodes\n * in their own dentries and ignore the layering superimposed upon them.\n */\nstatic inline struct inode *d_inode_rcu(const struct dentry *dentry)\n{\n\treturn ACCESS_ONCE(dentry->d_inode);\n}\n\n/**\n * d_backing_inode - Get upper or lower inode we should be using\n * @upper: The upper layer\n *\n * This is the helper that should be used to get at the inode that will be used\n * if this dentry were to be opened as a file.  The inode may be on the upper\n * dentry or it may be on a lower dentry pinned by the upper.\n *\n * Normal filesystems should not use this to access their own inodes.\n */\nstatic inline struct inode *d_backing_inode(const struct dentry *upper)\n{\n\tstruct inode *inode = upper->d_inode;\n\n\treturn inode;\n}\n\n/**\n * d_backing_dentry - Get upper or lower dentry we should be using\n * @upper: The upper layer\n *\n * This is the helper that should be used to get the dentry of the inode that\n * will be used if this dentry were opened as a file.  It may be the upper\n * dentry or it may be a lower dentry pinned by the upper.\n *\n * Normal filesystems should not use this to access their own dentries.\n */\nstatic inline struct dentry *d_backing_dentry(struct dentry *upper)\n{\n\treturn upper;\n}\n\nstatic inline struct dentry *d_real(struct dentry *dentry)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REAL))\n\t\treturn dentry->d_op->d_real(dentry, NULL);\n\telse\n\t\treturn dentry;\n}\n\nstatic inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\n\treturn inode;\n}\n\n\n#endif\t/* __LINUX_DCACHE_H */\n"], "filenames": ["fs/open.c", "include/linux/dcache.h"], "buggy_code_start_loc": [843, 567], "buggy_code_end_loc": [853, 567], "fixing_code_start_loc": [843, 568], "fixing_code_end_loc": [848, 580], "type": "CWE-284", "message": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.", "other": {"cve": {"id": "CVE-2016-6198", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:13.457", "lastModified": "2019-12-27T16:08:47.953", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c."}, {"lang": "es", "value": "La capa del sistema de archivos en el kernel de Linux en versiones anteriores a 4.5.5 procede con operaciones de cambio de nombre despu\u00e9s de que un archivo OverlayFS es cambiado de nombre a un self-hardlink, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda de sistema) a trav\u00e9s de una llamada al sistema, relacionado con fs/namei.c y fs/open.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.4", "matchCriteriaId": "1C36E5B8-129B-488B-B732-83E71CF311DD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:*:*:*:*:*:*:*", "matchCriteriaId": "CC7A498A-A669-4C42-8134-86103C799D13"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:vm_server:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "45DC1391-1EFC-49D7-9DD5-D9D9C5DFE746"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=54d5ca871e72f2bb172ec9323497f01cd5091ec7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1847.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1875.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.5.5", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/11/8", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/ovmbulletinjul2016-3090546.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/91709", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1036273", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1355654", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7"}}