{"buggy_code": ["<?php\n/**\n * Multisite WordPress API\n *\n * @package WordPress\n * @subpackage Multisite\n * @since 3.0.0\n */\n\n/**\n * Gets the network's site and user counts.\n *\n * @since MU 1.0\n *\n * @return array Site and user count for the network.\n */\nfunction get_sitestats() {\n\t$stats = array(\n\t\t'blogs' => get_blog_count(),\n\t\t'users' => get_user_count(),\n\t);\n\n\treturn $stats;\n}\n\n/**\n * Get one of a user's active blogs\n *\n * Returns the user's primary blog, if they have one and\n * it is active. If it's inactive, function returns another\n * active blog of the user. If none are found, the user\n * is added as a Subscriber to the Dashboard Blog and that blog\n * is returned.\n *\n * @since MU 1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $user_id The unique ID of the user\n * @return WP_Site|void The blog object\n */\nfunction get_active_blog_for_user( $user_id ) {\n\tglobal $wpdb;\n\t$blogs = get_blogs_of_user( $user_id );\n\tif ( empty( $blogs ) )\n\t\treturn;\n\n\tif ( !is_multisite() )\n\t\treturn $blogs[$wpdb->blogid];\n\n\t$primary_blog = get_user_meta( $user_id, 'primary_blog', true );\n\t$first_blog = current($blogs);\n\tif ( false !== $primary_blog ) {\n\t\tif ( ! isset( $blogs[ $primary_blog ] ) ) {\n\t\t\tupdate_user_meta( $user_id, 'primary_blog', $first_blog->userblog_id );\n\t\t\t$primary = get_site( $first_blog->userblog_id );\n\t\t} else {\n\t\t\t$primary = get_site( $primary_blog );\n\t\t}\n\t} else {\n\t\t//TODO Review this call to add_user_to_blog too - to get here the user must have a role on this blog?\n\t\tadd_user_to_blog( $first_blog->userblog_id, $user_id, 'subscriber' );\n\t\tupdate_user_meta( $user_id, 'primary_blog', $first_blog->userblog_id );\n\t\t$primary = $first_blog;\n\t}\n\n\tif ( ( ! is_object( $primary ) ) || ( $primary->archived == 1 || $primary->spam == 1 || $primary->deleted == 1 ) ) {\n\t\t$blogs = get_blogs_of_user( $user_id, true ); // if a user's primary blog is shut down, check their other blogs.\n\t\t$ret = false;\n\t\tif ( is_array( $blogs ) && count( $blogs ) > 0 ) {\n\t\t\tforeach ( (array) $blogs as $blog_id => $blog ) {\n\t\t\t\tif ( $blog->site_id != $wpdb->siteid )\n\t\t\t\t\tcontinue;\n\t\t\t\t$details = get_site( $blog_id );\n\t\t\t\tif ( is_object( $details ) && $details->archived == 0 && $details->spam == 0 && $details->deleted == 0 ) {\n\t\t\t\t\t$ret = $blog;\n\t\t\t\t\tif ( get_user_meta( $user_id , 'primary_blog', true ) != $blog_id )\n\t\t\t\t\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\t\t\t\t\tif ( !get_user_meta($user_id , 'source_domain', true) )\n\t\t\t\t\t\tupdate_user_meta( $user_id, 'source_domain', $blog->domain );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\treturn $ret;\n\t} else {\n\t\treturn $primary;\n\t}\n}\n\n/**\n * The number of active users in your installation.\n *\n * The count is cached and updated twice daily. This is not a live count.\n *\n * @since MU 2.7\n *\n * @return int\n */\nfunction get_user_count() {\n\treturn get_site_option( 'user_count' );\n}\n\n/**\n * The number of active sites on your installation.\n *\n * The count is cached and updated twice daily. This is not a live count.\n *\n * @since MU 1.0\n *\n * @param int $network_id Deprecated, not supported.\n * @return int\n */\nfunction get_blog_count( $network_id = 0 ) {\n\tif ( func_num_args() )\n\t\t_deprecated_argument( __FUNCTION__, '3.1.0' );\n\n\treturn get_site_option( 'blog_count' );\n}\n\n/**\n * Get a blog post from any site on the network.\n *\n * @since MU 1.0\n *\n * @param int $blog_id ID of the blog.\n * @param int $post_id ID of the post you're looking for.\n * @return WP_Post|null WP_Post on success or null on failure\n */\nfunction get_blog_post( $blog_id, $post_id ) {\n\tswitch_to_blog( $blog_id );\n\t$post = get_post( $post_id );\n\trestore_current_blog();\n\n\treturn $post;\n}\n\n/**\n * Adds a user to a blog.\n *\n * Use the {@see 'add_user_to_blog'} action to fire an event when users are added to a blog.\n *\n * @since MU 1.0\n *\n * @param int    $blog_id ID of the blog you're adding the user to.\n * @param int    $user_id ID of the user you're adding.\n * @param string $role    The role you want the user to have\n * @return true|WP_Error\n */\nfunction add_user_to_blog( $blog_id, $user_id, $role ) {\n\tswitch_to_blog($blog_id);\n\n\t$user = get_userdata( $user_id );\n\n\tif ( ! $user ) {\n\t\trestore_current_blog();\n\t\treturn new WP_Error( 'user_does_not_exist', __( 'The requested user does not exist.' ) );\n\t}\n\n\tif ( !get_user_meta($user_id, 'primary_blog', true) ) {\n\t\tupdate_user_meta($user_id, 'primary_blog', $blog_id);\n\t\t$site = get_site( $blog_id );\n\t\tupdate_user_meta( $user_id, 'source_domain', $site->domain );\n\t}\n\n\t$user->set_role($role);\n\n\t/**\n\t * Fires immediately after a user is added to a site.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $user_id User ID.\n\t * @param string $role    User role.\n\t * @param int    $blog_id Blog ID.\n\t */\n\tdo_action( 'add_user_to_blog', $user_id, $role, $blog_id );\n\twp_cache_delete( $user_id, 'users' );\n\twp_cache_delete( $blog_id . '_user_count', 'blog-details' );\n\trestore_current_blog();\n\treturn true;\n}\n\n/**\n * Remove a user from a blog.\n *\n * Use the {@see 'remove_user_from_blog'} action to fire an event when\n * users are removed from a blog.\n *\n * Accepts an optional `$reassign` parameter, if you want to\n * reassign the user's blog posts to another user upon removal.\n *\n * @since MU 1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int    $user_id  ID of the user you're removing.\n * @param int    $blog_id  ID of the blog you're removing the user from.\n * @param string $reassign Optional. A user to whom to reassign posts.\n * @return true|WP_Error\n */\nfunction remove_user_from_blog($user_id, $blog_id = '', $reassign = '') {\n\tglobal $wpdb;\n\tswitch_to_blog($blog_id);\n\t$user_id = (int) $user_id;\n\t/**\n\t * Fires before a user is removed from a site.\n\t *\n\t * @since MU\n\t *\n\t * @param int $user_id User ID.\n\t * @param int $blog_id Blog ID.\n\t */\n\tdo_action( 'remove_user_from_blog', $user_id, $blog_id );\n\n\t// If being removed from the primary blog, set a new primary if the user is assigned\n\t// to multiple blogs.\n\t$primary_blog = get_user_meta($user_id, 'primary_blog', true);\n\tif ( $primary_blog == $blog_id ) {\n\t\t$new_id = '';\n\t\t$new_domain = '';\n\t\t$blogs = get_blogs_of_user($user_id);\n\t\tforeach ( (array) $blogs as $blog ) {\n\t\t\tif ( $blog->userblog_id == $blog_id )\n\t\t\t\tcontinue;\n\t\t\t$new_id = $blog->userblog_id;\n\t\t\t$new_domain = $blog->domain;\n\t\t\tbreak;\n\t\t}\n\n\t\tupdate_user_meta($user_id, 'primary_blog', $new_id);\n\t\tupdate_user_meta($user_id, 'source_domain', $new_domain);\n\t}\n\n\t// wp_revoke_user($user_id);\n\t$user = get_userdata( $user_id );\n\tif ( ! $user ) {\n\t\trestore_current_blog();\n\t\treturn new WP_Error('user_does_not_exist', __('That user does not exist.'));\n\t}\n\n\t$user->remove_all_caps();\n\n\t$blogs = get_blogs_of_user($user_id);\n\tif ( count($blogs) == 0 ) {\n\t\tupdate_user_meta($user_id, 'primary_blog', '');\n\t\tupdate_user_meta($user_id, 'source_domain', '');\n\t}\n\n\tif ( $reassign != '' ) {\n\t\t$reassign = (int) $reassign;\n\t\t$post_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT ID FROM $wpdb->posts WHERE post_author = %d\", $user_id ) );\n\t\t$link_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT link_id FROM $wpdb->links WHERE link_owner = %d\", $user_id ) );\n\n\t\tif ( ! empty( $post_ids ) ) {\n\t\t\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET post_author = %d WHERE post_author = %d\", $reassign, $user_id ) );\n\t\t\tarray_walk( $post_ids, 'clean_post_cache' );\n\t\t}\n\n\t\tif ( ! empty( $link_ids ) ) {\n\t\t\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->links SET link_owner = %d WHERE link_owner = %d\", $reassign, $user_id ) );\n\t\t\tarray_walk( $link_ids, 'clean_bookmark_cache' );\n\t\t}\n\t}\n\n\trestore_current_blog();\n\n\treturn true;\n}\n\n/**\n * Get the permalink for a post on another blog.\n *\n * @since MU 1.0\n *\n * @param int $blog_id ID of the source blog.\n * @param int $post_id ID of the desired post.\n * @return string The post's permalink\n */\nfunction get_blog_permalink( $blog_id, $post_id ) {\n\tswitch_to_blog( $blog_id );\n\t$link = get_permalink( $post_id );\n\trestore_current_blog();\n\n\treturn $link;\n}\n\n/**\n * Get a blog's numeric ID from its URL.\n *\n * On a subdirectory installation like example.com/blog1/,\n * $domain will be the root 'example.com' and $path the\n * subdirectory '/blog1/'. With subdomains like blog1.example.com,\n * $domain is 'blog1.example.com' and $path is '/'.\n *\n * @since MU 2.6.5\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain\n * @param string $path   Optional. Not required for subdomain installations.\n * @return int 0 if no blog found, otherwise the ID of the matching blog\n */\nfunction get_blog_id_from_url( $domain, $path = '/' ) {\n\t$domain = strtolower( $domain );\n\t$path = strtolower( $path );\n\t$id = wp_cache_get( md5( $domain . $path ), 'blog-id-cache' );\n\n\tif ( $id == -1 ) // blog does not exist\n\t\treturn 0;\n\telseif ( $id )\n\t\treturn (int) $id;\n\n\t$args = array(\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'fields' => 'ids',\n\t);\n\t$result = get_sites( $args );\n\t$id = array_shift( $result );\n\n\tif ( ! $id ) {\n\t\twp_cache_set( md5( $domain . $path ), -1, 'blog-id-cache' );\n\t\treturn 0;\n\t}\n\n\twp_cache_set( md5( $domain . $path ), $id, 'blog-id-cache' );\n\n\treturn $id;\n}\n\n// Admin functions\n\n/**\n * Checks an email address against a list of banned domains.\n *\n * This function checks against the Banned Email Domains list\n * at wp-admin/network/settings.php. The check is only run on\n * self-registrations; user creation at wp-admin/network/users.php\n * bypasses this check.\n *\n * @since MU\n *\n * @param string $user_email The email provided by the user at registration.\n * @return bool Returns true when the email address is banned.\n */\nfunction is_email_address_unsafe( $user_email ) {\n\t$banned_names = get_site_option( 'banned_email_domains' );\n\tif ( $banned_names && ! is_array( $banned_names ) )\n\t\t$banned_names = explode( \"\\n\", $banned_names );\n\n\t$is_email_address_unsafe = false;\n\n\tif ( $banned_names && is_array( $banned_names ) ) {\n\t\t$banned_names = array_map( 'strtolower', $banned_names );\n\t\t$normalized_email = strtolower( $user_email );\n\n\t\tlist( $email_local_part, $email_domain ) = explode( '@', $normalized_email );\n\n\t\tforeach ( $banned_names as $banned_domain ) {\n\t\t\tif ( ! $banned_domain )\n\t\t\t\tcontinue;\n\n\t\t\tif ( $email_domain == $banned_domain ) {\n\t\t\t\t$is_email_address_unsafe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$dotted_domain = \".$banned_domain\";\n\t\t\tif ( $dotted_domain === substr( $normalized_email, -strlen( $dotted_domain ) ) ) {\n\t\t\t\t$is_email_address_unsafe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters whether an email address is unsafe.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param bool   $is_email_address_unsafe Whether the email address is \"unsafe\". Default false.\n\t * @param string $user_email              User email address.\n\t */\n\treturn apply_filters( 'is_email_address_unsafe', $is_email_address_unsafe, $user_email );\n}\n\n/**\n * Sanitize and validate data required for a user sign-up.\n *\n * Verifies the validity and uniqueness of user names and user email addresses,\n * and checks email addresses against admin-provided domain whitelists and blacklists.\n *\n * The {@see 'wpmu_validate_user_signup'} hook provides an easy way to modify the sign-up\n * process. The value $result, which is passed to the hook, contains both the user-provided\n * info and the error messages created by the function. {@see 'wpmu_validate_user_signup'}\n * allows you to process the data in any way you'd like, and unset the relevant errors if\n * necessary.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $user_name  The login name provided by the user.\n * @param string $user_email The email provided by the user.\n * @return array Contains username, email, and error messages.\n */\nfunction wpmu_validate_user_signup($user_name, $user_email) {\n\tglobal $wpdb;\n\n\t$errors = new WP_Error();\n\n\t$orig_username = $user_name;\n\t$user_name = preg_replace( '/\\s+/', '', sanitize_user( $user_name, true ) );\n\n\tif ( $user_name != $orig_username || preg_match( '/[^a-z0-9]/', $user_name ) ) {\n\t\t$errors->add( 'user_name', __( 'Usernames can only contain lowercase letters (a-z) and numbers.' ) );\n\t\t$user_name = $orig_username;\n\t}\n\n\t$user_email = sanitize_email( $user_email );\n\n\tif ( empty( $user_name ) )\n\t   \t$errors->add('user_name', __( 'Please enter a username.' ) );\n\n\t$illegal_names = get_site_option( 'illegal_names' );\n\tif ( ! is_array( $illegal_names ) ) {\n\t\t$illegal_names = array(  'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );\n\t\tadd_site_option( 'illegal_names', $illegal_names );\n\t}\n\tif ( in_array( $user_name, $illegal_names ) ) {\n\t\t$errors->add( 'user_name',  __( 'Sorry, that username is not allowed.' ) );\n\t}\n\n\t/** This filter is documented in wp-includes/user.php */\n\t$illegal_logins = (array) apply_filters( 'illegal_user_logins', array() );\n\n\tif ( in_array( strtolower( $user_name ), array_map( 'strtolower', $illegal_logins ) ) ) {\n\t\t$errors->add( 'user_name',  __( 'Sorry, that username is not allowed.' ) );\n\t}\n\n\tif ( is_email_address_unsafe( $user_email ) )\n\t\t$errors->add('user_email',  __('You cannot use that email address to signup. We are having problems with them blocking some of our email. Please use another email provider.'));\n\n\tif ( strlen( $user_name ) < 4 )\n\t\t$errors->add('user_name',  __( 'Username must be at least 4 characters.' ) );\n\n\tif ( strlen( $user_name ) > 60 ) {\n\t\t$errors->add( 'user_name', __( 'Username may not be longer than 60 characters.' ) );\n\t}\n\n\t// all numeric?\n\tif ( preg_match( '/^[0-9]*$/', $user_name ) )\n\t\t$errors->add('user_name', __('Sorry, usernames must have letters too!'));\n\n\tif ( !is_email( $user_email ) )\n\t\t$errors->add('user_email', __( 'Please enter a valid email address.' ) );\n\n\t$limited_email_domains = get_site_option( 'limited_email_domains' );\n\tif ( is_array( $limited_email_domains ) && ! empty( $limited_email_domains ) ) {\n\t\t$emaildomain = substr( $user_email, 1 + strpos( $user_email, '@' ) );\n\t\tif ( ! in_array( $emaildomain, $limited_email_domains ) ) {\n\t\t\t$errors->add('user_email', __('Sorry, that email address is not allowed!'));\n\t\t}\n\t}\n\n\t// Check if the username has been used already.\n\tif ( username_exists($user_name) )\n\t\t$errors->add( 'user_name', __( 'Sorry, that username already exists!' ) );\n\n\t// Check if the email address has been used already.\n\tif ( email_exists($user_email) )\n\t\t$errors->add( 'user_email', __( 'Sorry, that email address is already used!' ) );\n\n\t// Has someone already signed up for this username?\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE user_login = %s\", $user_name) );\n\tif ( $signup != null ) {\n\t\t$registered_at =  mysql2date('U', $signup->registered);\n\t\t$now = current_time( 'timestamp', true );\n\t\t$diff = $now - $registered_at;\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'user_login' => $user_name ) );\n\t\telse\n\t\t\t$errors->add('user_name', __('That username is currently reserved but may be available in a couple of days.'));\n\t}\n\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE user_email = %s\", $user_email) );\n\tif ( $signup != null ) {\n\t\t$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'user_email' => $user_email ) );\n\t\telse\n\t\t\t$errors->add('user_email', __('That email address has already been used. Please check your inbox for an activation email. It will become available in a couple of days if you do nothing.'));\n\t}\n\n\t$result = array('user_name' => $user_name, 'orig_username' => $orig_username, 'user_email' => $user_email, 'errors' => $errors);\n\n\t/**\n\t * Filters the validated user registration details.\n\t *\n\t * This does not allow you to override the username or email of the user during\n\t * registration. The values are solely used for validation and error handling.\n\t *\n\t * @since MU\n\t *\n\t * @param array $result {\n\t *     The array of user name, email and the error messages.\n\t *\n\t *     @type string   $user_name     Sanitized and unique username.\n\t *     @type string   $orig_username Original username.\n\t *     @type string   $user_email    User email address.\n\t *     @type WP_Error $errors        WP_Error object containing any errors found.\n\t * }\n\t */\n\treturn apply_filters( 'wpmu_validate_user_signup', $result );\n}\n\n/**\n * Processes new site registrations.\n *\n * Checks the data provided by the user during blog signup. Verifies\n * the validity and uniqueness of blog paths and domains.\n *\n * This function prevents the current user from registering a new site\n * with a blogname equivalent to another user's login name. Passing the\n * $user parameter to the function, where $user is the other user, is\n * effectively an override of this limitation.\n *\n * Filter {@see 'wpmu_validate_blog_signup'} if you want to modify\n * the way that WordPress validates new site signups.\n *\n * @since MU\n *\n * @global wpdb   $wpdb\n * @global string $domain\n *\n * @param string         $blogname   The blog name provided by the user. Must be unique.\n * @param string         $blog_title The blog title provided by the user.\n * @param WP_User|string $user       Optional. The user object to check against the new site name.\n * @return array Contains the new site data and error messages.\n */\nfunction wpmu_validate_blog_signup( $blogname, $blog_title, $user = '' ) {\n\tglobal $wpdb, $domain;\n\n\t$current_network = get_network();\n\t$base = $current_network->path;\n\n\t$blog_title = strip_tags( $blog_title );\n\n\t$errors = new WP_Error();\n\t$illegal_names = get_site_option( 'illegal_names' );\n\tif ( $illegal_names == false ) {\n\t\t$illegal_names = array( 'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );\n\t\tadd_site_option( 'illegal_names', $illegal_names );\n\t}\n\n\t/*\n\t * On sub dir installs, some names are so illegal, only a filter can\n\t * spring them from jail.\n\t */\n\tif ( ! is_subdomain_install() ) {\n\t\t$illegal_names = array_merge( $illegal_names, get_subdirectory_reserved_names() );\n\t}\n\n\tif ( empty( $blogname ) )\n\t\t$errors->add('blogname', __( 'Please enter a site name.' ) );\n\n\tif ( preg_match( '/[^a-z0-9]+/', $blogname ) ) {\n\t\t$errors->add( 'blogname', __( 'Site names can only contain lowercase letters (a-z) and numbers.' ) );\n\t}\n\n\tif ( in_array( $blogname, $illegal_names ) )\n\t\t$errors->add('blogname',  __( 'That name is not allowed.' ) );\n\n\tif ( strlen( $blogname ) < 4 && !is_super_admin() )\n\t\t$errors->add('blogname',  __( 'Site name must be at least 4 characters.' ) );\n\n\t// do not allow users to create a blog that conflicts with a page on the main blog.\n\tif ( !is_subdomain_install() && $wpdb->get_var( $wpdb->prepare( \"SELECT post_name FROM \" . $wpdb->get_blog_prefix( $current_network->site_id ) . \"posts WHERE post_type = 'page' AND post_name = %s\", $blogname ) ) )\n\t\t$errors->add( 'blogname', __( 'Sorry, you may not use that site name.' ) );\n\n\t// all numeric?\n\tif ( preg_match( '/^[0-9]*$/', $blogname ) )\n\t\t$errors->add('blogname', __('Sorry, site names must have letters too!'));\n\n\t/**\n\t * Filters the new site name during registration.\n\t *\n\t * The name is the site's subdomain or the site's subdirectory\n\t * path depending on the network settings.\n\t *\n\t * @since MU\n\t *\n\t * @param string $blogname Site name.\n\t */\n\t$blogname = apply_filters( 'newblogname', $blogname );\n\n\t$blog_title = wp_unslash(  $blog_title );\n\n\tif ( empty( $blog_title ) )\n\t\t$errors->add('blog_title', __( 'Please enter a site title.' ) );\n\n\t// Check if the domain/path has been used already.\n\tif ( is_subdomain_install() ) {\n\t\t$mydomain = $blogname . '.' . preg_replace( '|^www\\.|', '', $domain );\n\t\t$path = $base;\n\t} else {\n\t\t$mydomain = \"$domain\";\n\t\t$path = $base.$blogname.'/';\n\t}\n\tif ( domain_exists($mydomain, $path, $current_network->id) )\n\t\t$errors->add( 'blogname', __( 'Sorry, that site already exists!' ) );\n\n\tif ( username_exists( $blogname ) ) {\n\t\tif ( ! is_object( $user ) || ( is_object($user) && ( $user->user_login != $blogname ) ) )\n\t\t\t$errors->add( 'blogname', __( 'Sorry, that site is reserved!' ) );\n\t}\n\n\t// Has someone already signed up for this domain?\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE domain = %s AND path = %s\", $mydomain, $path) ); // TODO: Check email too?\n\tif ( ! empty($signup) ) {\n\t\t$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'domain' => $mydomain , 'path' => $path ) );\n\t\telse\n\t\t\t$errors->add('blogname', __('That site is currently reserved but may be available in a couple days.'));\n\t}\n\n\t$result = array('domain' => $mydomain, 'path' => $path, 'blogname' => $blogname, 'blog_title' => $blog_title, 'user' => $user, 'errors' => $errors);\n\n\t/**\n\t * Filters site details and error messages following registration.\n\t *\n\t * @since MU\n\t *\n\t * @param array $result {\n\t *     Array of domain, path, blog name, blog title, user and error messages.\n\t *\n\t *     @type string         $domain     Domain for the site.\n\t *     @type string         $path       Path for the site. Used in subdirectory installs.\n\t *     @type string         $blogname   The unique site name (slug).\n\t *     @type string         $blog_title Blog title.\n\t *     @type string|WP_User $user       By default, an empty string. A user object if provided.\n\t *     @type WP_Error       $errors     WP_Error containing any errors found.\n\t * }\n\t */\n\treturn apply_filters( 'wpmu_validate_blog_signup', $result );\n}\n\n/**\n * Record site signup information for future activation.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain     The requested domain.\n * @param string $path       The requested path.\n * @param string $title      The requested site title.\n * @param string $user       The user's requested login name.\n * @param string $user_email The user's email address.\n * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n */\nfunction wpmu_signup_blog( $domain, $path, $title, $user, $user_email, $meta = array() )  {\n\tglobal $wpdb;\n\n\t$key = substr( md5( time() . rand() . $domain ), 0, 16 );\n\t$meta = serialize($meta);\n\n\t$wpdb->insert( $wpdb->signups, array(\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'title' => $title,\n\t\t'user_login' => $user,\n\t\t'user_email' => $user_email,\n\t\t'registered' => current_time('mysql', true),\n\t\t'activation_key' => $key,\n\t\t'meta' => $meta\n\t) );\n\n\t/**\n\t * Fires after site signup information has been written to the database.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $domain     The requested domain.\n\t * @param string $path       The requested path.\n\t * @param string $title      The requested site title.\n\t * @param string $user       The user's requested login name.\n\t * @param string $user_email The user's email address.\n\t * @param string $key        The user's activation key\n\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t */\n\tdo_action( 'after_signup_site', $domain, $path, $title, $user, $user_email, $key, $meta );\n}\n\n/**\n * Record user signup information for future activation.\n *\n * This function is used when user registration is open but\n * new site registration is not.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $user       The user's requested login name.\n * @param string $user_email The user's email address.\n * @param array  $meta       By default, this is an empty array.\n */\nfunction wpmu_signup_user( $user, $user_email, $meta = array() ) {\n\tglobal $wpdb;\n\n\t// Format data\n\t$user = preg_replace( '/\\s+/', '', sanitize_user( $user, true ) );\n\t$user_email = sanitize_email( $user_email );\n\t$key = substr( md5( time() . rand() . $user_email ), 0, 16 );\n\t$meta = serialize($meta);\n\n\t$wpdb->insert( $wpdb->signups, array(\n\t\t'domain' => '',\n\t\t'path' => '',\n\t\t'title' => '',\n\t\t'user_login' => $user,\n\t\t'user_email' => $user_email,\n\t\t'registered' => current_time('mysql', true),\n\t\t'activation_key' => $key,\n\t\t'meta' => $meta\n\t) );\n\n\t/**\n\t * Fires after a user's signup information has been written to the database.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $user       The user's requested login name.\n\t * @param string $user_email The user's email address.\n\t * @param string $key        The user's activation key\n\t * @param array  $meta       Additional signup meta. By default, this is an empty array.\n\t */\n\tdo_action( 'after_signup_user', $user, $user_email, $key, $meta );\n}\n\n/**\n * Notify user of signup success.\n *\n * This is the notification function used when site registration\n * is enabled.\n *\n * Filter {@see 'wpmu_signup_blog_notification'} to bypass this function or\n * replace it with your own notification behavior.\n *\n * Filter {@see 'wpmu_signup_blog_notification_email'} and\n * {@see 'wpmu_signup_blog_notification_subject'} to change the content\n * and subject line of the email sent to newly registered users.\n *\n * @since MU\n *\n * @param string $domain     The new blog domain.\n * @param string $path       The new blog path.\n * @param string $title      The site title.\n * @param string $user_login The user's login name.\n * @param string $user_email The user's email address.\n * @param string $key        The activation key created in wpmu_signup_blog()\n * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n * @return bool\n */\nfunction wpmu_signup_blog_notification( $domain, $path, $title, $user_login, $user_email, $key, $meta = array() ) {\n\t/**\n\t * Filters whether to bypass the new site email notification.\n\t *\n\t * @since MU\n\t *\n\t * @param string|bool $domain     Site domain.\n\t * @param string      $path       Site path.\n\t * @param string      $title      Site title.\n\t * @param string      $user_login User login name.\n\t * @param string      $user_email User email address.\n\t * @param string      $key        Activation key created in wpmu_signup_blog().\n\t * @param array       $meta       By default, contains the requested privacy setting and lang_id.\n\t */\n\tif ( ! apply_filters( 'wpmu_signup_blog_notification', $domain, $path, $title, $user_login, $user_email, $key, $meta ) ) {\n\t\treturn false;\n\t}\n\n\t// Send email with activation link.\n\tif ( !is_subdomain_install() || get_current_network_id() != 1 )\n\t\t$activate_url = network_site_url(\"wp-activate.php?key=$key\");\n\telse\n\t\t$activate_url = \"http://{$domain}{$path}wp-activate.php?key=$key\"; // @todo use *_url() API\n\n\t$activate_url = esc_url($activate_url);\n\t$admin_email = get_site_option( 'admin_email' );\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\n\t$user = get_user_by( 'login', $user_login );\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t$message = sprintf(\n\t\t/**\n\t\t * Filters the message content of the new blog notification email.\n\t\t *\n\t\t * Content should be formatted for transmission via wp_mail().\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $content    Content of the notification email.\n\t\t * @param string $domain     Site domain.\n\t\t * @param string $path       Site path.\n\t\t * @param string $title      Site title.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_blog().\n\t\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_blog_notification_email',\n\t\t\t__( \"To activate your blog, please click the following link:\\n\\n%s\\n\\nAfter you activate, you will receive *another email* with your login.\\n\\nAfter you activate, you can visit your site here:\\n\\n%s\" ),\n\t\t\t$domain, $path, $title, $user_login, $user_email, $key, $meta\n\t\t),\n\t\t$activate_url,\n\t\tesc_url( \"http://{$domain}{$path}\" ),\n\t\t$key\n\t);\n\t// TODO: Don't hard code activation link.\n\t$subject = sprintf(\n\t\t/**\n\t\t * Filters the subject of the new blog notification email.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $subject    Subject of the notification email.\n\t\t * @param string $domain     Site domain.\n\t\t * @param string $path       Site path.\n\t\t * @param string $title      Site title.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_blog().\n\t\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_blog_notification_subject',\n\t\t\t/* translators: New site notification email subject. 1: Network name, 2: New site URL */\n\t\t\t_x( '[%1$s] Activate %2$s', 'New site notification email subject' ),\n\t\t\t$domain, $path, $title, $user_login, $user_email, $key, $meta\n\t\t),\n\t\t$from_name,\n\t\tesc_url( 'http://' . $domain . $path )\n\t);\n\twp_mail( $user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Notify user of signup success.\n *\n * This is the notification function used when no new site has\n * been requested.\n *\n * Filter {@see 'wpmu_signup_user_notification'} to bypass this function or\n * replace it with your own notification behavior.\n *\n * Filter {@see 'wpmu_signup_user_notification_email'} and\n * {@see 'wpmu_signup_user_notification_subject'} to change the content\n * and subject line of the email sent to newly registered users.\n *\n * @since MU\n *\n * @param string $user_login The user's login name.\n * @param string $user_email The user's email address.\n * @param string $key        The activation key created in wpmu_signup_user()\n * @param array  $meta       By default, an empty array.\n * @return bool\n */\nfunction wpmu_signup_user_notification( $user_login, $user_email, $key, $meta = array() ) {\n\t/**\n\t * Filters whether to bypass the email notification for new user sign-up.\n\t *\n\t * @since MU\n\t *\n\t * @param string $user_login User login name.\n\t * @param string $user_email User email address.\n\t * @param string $key        Activation key created in wpmu_signup_user().\n\t * @param array  $meta       Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_signup_user_notification', $user_login, $user_email, $key, $meta ) )\n\t\treturn false;\n\n\t$user = get_user_by( 'login', $user_login );\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t// Send email with activation link.\n\t$admin_email = get_site_option( 'admin_email' );\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = sprintf(\n\t\t/**\n\t\t * Filters the content of the notification email for new user sign-up.\n\t\t *\n\t\t * Content should be formatted for transmission via wp_mail().\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $content    Content of the notification email.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_user().\n\t\t * @param array  $meta       Signup meta data.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_user_notification_email',\n\t\t\t__( \"To activate your user, please click the following link:\\n\\n%s\\n\\nAfter you activate, you will receive *another email* with your login.\" ),\n\t\t\t$user_login, $user_email, $key, $meta\n\t\t),\n\t\tsite_url( \"wp-activate.php?key=$key\" )\n\t);\n\t// TODO: Don't hard code activation link.\n\t$subject = sprintf(\n\t\t/**\n\t\t * Filters the subject of the notification email of new user signup.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $subject    Subject of the notification email.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_user().\n\t\t * @param array  $meta       Signup meta data.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_user_notification_subject',\n\t\t\t/* translators: New user notification email subject. 1: Network name, 2: New user login */\n\t\t\t_x( '[%1$s] Activate %2$s', 'New user notification email subject' ),\n\t\t\t$user_login, $user_email, $key, $meta\n\t\t),\n\t\t$from_name,\n\t\t$user_login\n\t);\n\twp_mail( $user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Activate a signup.\n *\n * Hook to {@see 'wpmu_activate_user'} or {@see 'wpmu_activate_blog'} for events\n * that should happen only when users or sites are self-created (since\n * those actions are not called when users and sites are created\n * by a Super Admin).\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $key The activation key provided to the user.\n * @return array|WP_Error An array containing information about the activated user and/or blog\n */\nfunction wpmu_activate_signup($key) {\n\tglobal $wpdb;\n\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE activation_key = %s\", $key) );\n\n\tif ( empty( $signup ) )\n\t\treturn new WP_Error( 'invalid_key', __( 'Invalid activation key.' ) );\n\n\tif ( $signup->active ) {\n\t\tif ( empty( $signup->domain ) )\n\t\t\treturn new WP_Error( 'already_active', __( 'The user is already active.' ), $signup );\n\t\telse\n\t\t\treturn new WP_Error( 'already_active', __( 'The site is already active.' ), $signup );\n\t}\n\n\t$meta = maybe_unserialize($signup->meta);\n\t$password = wp_generate_password( 12, false );\n\n\t$user_id = username_exists($signup->user_login);\n\n\tif ( ! $user_id )\n\t\t$user_id = wpmu_create_user($signup->user_login, $password, $signup->user_email);\n\telse\n\t\t$user_already_exists = true;\n\n\tif ( ! $user_id )\n\t\treturn new WP_Error('create_user', __('Could not create user'), $signup);\n\n\t$now = current_time('mysql', true);\n\n\tif ( empty($signup->domain) ) {\n\t\t$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );\n\n\t\tif ( isset( $user_already_exists ) )\n\t\t\treturn new WP_Error( 'user_already_exists', __( 'That username is already activated.' ), $signup);\n\n\t\t/**\n\t\t * Fires immediately after a new user is activated.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param int   $user_id  User ID.\n\t\t * @param int   $password User password.\n\t\t * @param array $meta     Signup meta data.\n\t\t */\n\t\tdo_action( 'wpmu_activate_user', $user_id, $password, $meta );\n\t\treturn array( 'user_id' => $user_id, 'password' => $password, 'meta' => $meta );\n\t}\n\n\t$blog_id = wpmu_create_blog( $signup->domain, $signup->path, $signup->title, $user_id, $meta, $wpdb->siteid );\n\n\t// TODO: What to do if we create a user but cannot create a blog?\n\tif ( is_wp_error($blog_id) ) {\n\t\t// If blog is taken, that means a previous attempt to activate this blog failed in between creating the blog and\n\t\t// setting the activation flag. Let's just set the active flag and instruct the user to reset their password.\n\t\tif ( 'blog_taken' == $blog_id->get_error_code() ) {\n\t\t\t$blog_id->add_data( $signup );\n\t\t\t$wpdb->update( $wpdb->signups, array( 'active' => 1, 'activated' => $now ), array( 'activation_key' => $key ) );\n\t\t}\n\t\treturn $blog_id;\n\t}\n\n\t$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );\n\t/**\n\t * Fires immediately after a site is activated.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $blog_id       Blog ID.\n\t * @param int    $user_id       User ID.\n\t * @param int    $password      User password.\n\t * @param string $signup_title  Site title.\n\t * @param array  $meta          Signup meta data.\n\t */\n\tdo_action( 'wpmu_activate_blog', $blog_id, $user_id, $password, $signup->title, $meta );\n\n\treturn array('blog_id' => $blog_id, 'user_id' => $user_id, 'password' => $password, 'title' => $signup->title, 'meta' => $meta);\n}\n\n/**\n * Create a user.\n *\n * This function runs when a user self-registers as well as when\n * a Super Admin creates a new user. Hook to {@see 'wpmu_new_user'} for events\n * that should affect all new users, but only on Multisite (otherwise\n * use {@see'user_register'}).\n *\n * @since MU\n *\n * @param string $user_name The new user's login name.\n * @param string $password  The new user's password.\n * @param string $email     The new user's email address.\n * @return int|false Returns false on failure, or int $user_id on success\n */\nfunction wpmu_create_user( $user_name, $password, $email ) {\n\t$user_name = preg_replace( '/\\s+/', '', sanitize_user( $user_name, true ) );\n\n\t$user_id = wp_create_user( $user_name, $password, $email );\n\tif ( is_wp_error( $user_id ) )\n\t\treturn false;\n\n\t// Newly created users have no roles or caps until they are added to a blog.\n\tdelete_user_option( $user_id, 'capabilities' );\n\tdelete_user_option( $user_id, 'user_level' );\n\n\t/**\n\t * Fires immediately after a new user is created.\n\t *\n\t * @since MU\n\t *\n\t * @param int $user_id User ID.\n\t */\n\tdo_action( 'wpmu_new_user', $user_id );\n\n\treturn $user_id;\n}\n\n/**\n * Create a site.\n *\n * This function runs when a user self-registers a new site as well\n * as when a Super Admin creates a new site. Hook to {@see 'wpmu_new_blog'}\n * for events that should affect all new sites.\n *\n * On subdirectory installs, $domain is the same as the main site's\n * domain, and the path is the subdirectory name (eg 'example.com'\n * and '/blog1/'). On subdomain installs, $domain is the new subdomain +\n * root domain (eg 'blog1.example.com'), and $path is '/'.\n *\n * @since MU\n *\n * @param string $domain  The new site's domain.\n * @param string $path    The new site's path.\n * @param string $title   The new site's title.\n * @param int    $user_id The user ID of the new site's admin.\n * @param array  $meta    Optional. Used to set initial site options.\n * @param int    $site_id Optional. Only relevant on multi-network installs.\n * @return int|WP_Error Returns WP_Error object on failure, int $blog_id on success\n */\nfunction wpmu_create_blog( $domain, $path, $title, $user_id, $meta = array(), $site_id = 1 ) {\n\t$defaults = array(\n\t\t'public' => 0,\n\t\t'WPLANG' => get_site_option( 'WPLANG' ),\n\t);\n\t$meta = wp_parse_args( $meta, $defaults );\n\n\t$domain = preg_replace( '/\\s+/', '', sanitize_user( $domain, true ) );\n\n\tif ( is_subdomain_install() )\n\t\t$domain = str_replace( '@', '', $domain );\n\n\t$title = strip_tags( $title );\n\t$user_id = (int) $user_id;\n\n\tif ( empty($path) )\n\t\t$path = '/';\n\n\t// Check if the domain has been used already. We should return an error message.\n\tif ( domain_exists($domain, $path, $site_id) )\n\t\treturn new WP_Error( 'blog_taken', __( 'Sorry, that site already exists!' ) );\n\n\tif ( ! wp_installing() ) {\n\t\twp_installing( true );\n\t}\n\n\tif ( ! $blog_id = insert_blog($domain, $path, $site_id) )\n\t\treturn new WP_Error('insert_blog', __('Could not create site.'));\n\n\tswitch_to_blog($blog_id);\n\tinstall_blog($blog_id, $title);\n\twp_install_defaults($user_id);\n\n\tadd_user_to_blog($blog_id, $user_id, 'administrator');\n\n\tforeach ( $meta as $key => $value ) {\n\t\tif ( in_array( $key, array( 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id' ) ) )\n\t\t\tupdate_blog_status( $blog_id, $key, $value );\n\t\telse\n\t\t\tupdate_option( $key, $value );\n\t}\n\n\tupdate_option( 'blog_public', (int) $meta['public'] );\n\n\tif ( ! is_super_admin( $user_id ) && ! get_user_meta( $user_id, 'primary_blog', true ) )\n\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\n\trestore_current_blog();\n\t/**\n\t * Fires immediately after a new site is created.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $blog_id Blog ID.\n\t * @param int    $user_id User ID.\n\t * @param string $domain  Site domain.\n\t * @param string $path    Site path.\n\t * @param int    $site_id Site ID. Only relevant on multi-network installs.\n\t * @param array  $meta    Meta data. Used to set initial site options.\n\t */\n\tdo_action( 'wpmu_new_blog', $blog_id, $user_id, $domain, $path, $site_id, $meta );\n\n\twp_cache_set( 'last_changed', microtime(), 'sites' );\n\n\treturn $blog_id;\n}\n\n/**\n * Notifies the network admin that a new site has been activated.\n *\n * Filter {@see 'newblog_notify_siteadmin'} to change the content of\n * the notification email.\n *\n * @since MU\n *\n * @param int    $blog_id    The new site's ID.\n * @param string $deprecated Not used.\n * @return bool\n */\nfunction newblog_notify_siteadmin( $blog_id, $deprecated = '' ) {\n\tif ( get_site_option( 'registrationnotification' ) != 'yes' )\n\t\treturn false;\n\n\t$email = get_site_option( 'admin_email' );\n\tif ( is_email($email) == false )\n\t\treturn false;\n\n\t$options_site_url = esc_url(network_admin_url('settings.php'));\n\n\tswitch_to_blog( $blog_id );\n\t$blogname = get_option( 'blogname' );\n\t$siteurl = site_url();\n\trestore_current_blog();\n\n\t/* translators: New site notification email. 1: Site URL, 2: User IP address, 3: Settings screen URL */\n\t$msg = sprintf( __( 'New Site: %1$s\nURL: %2$s\nRemote IP: %3$s\n\nDisable these notifications: %4$s' ), $blogname, $siteurl, wp_unslash( $_SERVER['REMOTE_ADDR'] ), $options_site_url);\n\t/**\n\t * Filters the message body of the new site activation email sent\n\t * to the network administrator.\n\t *\n\t * @since MU\n\t *\n\t * @param string $msg Email body.\n\t */\n\t$msg = apply_filters( 'newblog_notify_siteadmin', $msg );\n\n\twp_mail( $email, sprintf( __( 'New Site Registration: %s' ), $siteurl ), $msg );\n\treturn true;\n}\n\n/**\n * Notifies the network admin that a new user has been activated.\n *\n * Filter {@see 'newuser_notify_siteadmin'} to change the content of\n * the notification email.\n *\n * @since MU\n *\n * @param int $user_id The new user's ID.\n * @return bool\n */\nfunction newuser_notify_siteadmin( $user_id ) {\n\tif ( get_site_option( 'registrationnotification' ) != 'yes' )\n\t\treturn false;\n\n\t$email = get_site_option( 'admin_email' );\n\n\tif ( is_email($email) == false )\n\t\treturn false;\n\n\t$user = get_userdata( $user_id );\n\n\t$options_site_url = esc_url(network_admin_url('settings.php'));\n\t/* translators: New user notification email. 1: User login, 2: User IP address, 3: Settings screen URL */\n\t$msg = sprintf(__('New User: %1$s\nRemote IP: %2$s\n\nDisable these notifications: %3$s'), $user->user_login, wp_unslash( $_SERVER['REMOTE_ADDR'] ), $options_site_url);\n\n\t/**\n\t * Filters the message body of the new user activation email sent\n\t * to the network administrator.\n\t *\n\t * @since MU\n\t *\n\t * @param string  $msg  Email body.\n\t * @param WP_User $user WP_User instance of the new user.\n\t */\n\t$msg = apply_filters( 'newuser_notify_siteadmin', $msg, $user );\n\twp_mail( $email, sprintf(__('New User Registration: %s'), $user->user_login), $msg );\n\treturn true;\n}\n\n/**\n * Check whether a blogname is already taken.\n *\n * Used during the new site registration process to ensure\n * that each blogname is unique.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain  The domain to be checked.\n * @param string $path    The path to be checked.\n * @param int    $site_id Optional. Relevant only on multi-network installs.\n * @return int\n */\nfunction domain_exists($domain, $path, $site_id = 1) {\n\t$path = trailingslashit( $path );\n\t$args = array(\n\t\t'network_id' => $site_id,\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'fields' => 'ids',\n\t);\n\t$result = get_sites( $args );\n\t$result = array_shift( $result );\n\n\t/**\n\t * Filters whether a blogname is taken.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param int|null $result  The blog_id if the blogname exists, null otherwise.\n\t * @param string   $domain  Domain to be checked.\n\t * @param string   $path    Path to be checked.\n\t * @param int      $site_id Site ID. Relevant only on multi-network installs.\n\t */\n\treturn apply_filters( 'domain_exists', $result, $domain, $path, $site_id );\n}\n\n/**\n * Store basic site info in the blogs table.\n *\n * This function creates a row in the wp_blogs table and returns\n * the new blog's ID. It is the first step in creating a new blog.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain  The domain of the new site.\n * @param string $path    The path of the new site.\n * @param int    $site_id Unless you're running a multi-network install, be sure to set this value to 1.\n * @return int|false The ID of the new row\n */\nfunction insert_blog($domain, $path, $site_id) {\n\tglobal $wpdb;\n\n\t$path = trailingslashit($path);\n\t$site_id = (int) $site_id;\n\n\t$result = $wpdb->insert( $wpdb->blogs, array('site_id' => $site_id, 'domain' => $domain, 'path' => $path, 'registered' => current_time('mysql')) );\n\tif ( ! $result )\n\t\treturn false;\n\n\t$blog_id = $wpdb->insert_id;\n\trefresh_blog_details( $blog_id );\n\n\twp_maybe_update_network_site_counts();\n\n\treturn $blog_id;\n}\n\n/**\n * Install an empty blog.\n *\n * Creates the new blog tables and options. If calling this function\n * directly, be sure to use switch_to_blog() first, so that $wpdb\n * points to the new blog.\n *\n * @since MU\n *\n * @global wpdb     $wpdb\n * @global WP_Roles $wp_roles\n *\n * @param int    $blog_id    The value returned by insert_blog().\n * @param string $blog_title The title of the new site.\n */\nfunction install_blog( $blog_id, $blog_title = '' ) {\n\tglobal $wpdb, $wp_roles;\n\n\t// Cast for security\n\t$blog_id = (int) $blog_id;\n\n\trequire_once( ABSPATH . 'wp-admin/includes/upgrade.php' );\n\n\t$suppress = $wpdb->suppress_errors();\n\tif ( $wpdb->get_results( \"DESCRIBE {$wpdb->posts}\" ) )\n\t\tdie( '<h1>' . __( 'Already Installed' ) . '</h1><p>' . __( 'You appear to have already installed WordPress. To reinstall please clear your old database tables first.' ) . '</p></body></html>' );\n\t$wpdb->suppress_errors( $suppress );\n\n\t$url = get_blogaddress_by_id( $blog_id );\n\n\t// Set everything up\n\tmake_db_current_silent( 'blog' );\n\tpopulate_options();\n\tpopulate_roles();\n\n\t// populate_roles() clears previous role definitions so we start over.\n\t$wp_roles = new WP_Roles();\n\n\t$siteurl = $home = untrailingslashit( $url );\n\n\tif ( ! is_subdomain_install() ) {\n\n \t\tif ( 'https' === parse_url( get_site_option( 'siteurl' ), PHP_URL_SCHEME ) ) {\n \t\t\t$siteurl = set_url_scheme( $siteurl, 'https' );\n \t\t}\n \t\tif ( 'https' === parse_url( get_home_url( get_network()->site_id ), PHP_URL_SCHEME ) ) {\n \t\t\t$home = set_url_scheme( $home, 'https' );\n \t\t}\n\n\t}\n\n\tupdate_option( 'siteurl', $siteurl );\n\tupdate_option( 'home', $home );\n\n\tif ( get_site_option( 'ms_files_rewriting' ) )\n\t\tupdate_option( 'upload_path', UPLOADBLOGSDIR . \"/$blog_id/files\" );\n\telse\n\t\tupdate_option( 'upload_path', get_blog_option( get_network()->site_id, 'upload_path' ) );\n\n\tupdate_option( 'blogname', wp_unslash( $blog_title ) );\n\tupdate_option( 'admin_email', '' );\n\n\t// remove all perms\n\t$table_prefix = $wpdb->get_blog_prefix();\n\tdelete_metadata( 'user', 0, $table_prefix . 'user_level',   null, true ); // delete all\n\tdelete_metadata( 'user', 0, $table_prefix . 'capabilities', null, true ); // delete all\n}\n\n/**\n * Set blog defaults.\n *\n * This function creates a row in the wp_blogs table.\n *\n * @since MU\n * @deprecated MU\n * @deprecated Use wp_install_defaults()\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $blog_id Ignored in this function.\n * @param int $user_id\n */\nfunction install_blog_defaults($blog_id, $user_id) {\n\tglobal $wpdb;\n\n\trequire_once( ABSPATH . 'wp-admin/includes/upgrade.php' );\n\n\t$suppress = $wpdb->suppress_errors();\n\n\twp_install_defaults($user_id);\n\n\t$wpdb->suppress_errors( $suppress );\n}\n\n/**\n * Notify a user that their blog activation has been successful.\n *\n * Filter {@see 'wpmu_welcome_notification'} to disable or bypass.\n *\n * Filter {@see 'update_welcome_email'} and {@see 'update_welcome_subject'} to\n * modify the content and subject line of the notification email.\n *\n * @since MU\n *\n * @param int    $blog_id\n * @param int    $user_id\n * @param string $password\n * @param string $title    The new blog's title\n * @param array  $meta     Optional. Not used in the default function, but is passed along to hooks for customization.\n * @return bool\n */\nfunction wpmu_welcome_notification( $blog_id, $user_id, $password, $title, $meta = array() ) {\n\t$current_network = get_network();\n\n\t/**\n\t * Filters whether to bypass the welcome email after site activation.\n\t *\n\t * Returning false disables the welcome email.\n\t *\n\t * @since MU\n\t *\n\t * @param int|bool $blog_id  Blog ID.\n\t * @param int      $user_id  User ID.\n\t * @param string   $password User password.\n\t * @param string   $title    Site title.\n\t * @param array    $meta     Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_welcome_notification', $blog_id, $user_id, $password, $title, $meta ) )\n\t\treturn false;\n\n\t$user = get_userdata( $user_id );\n\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t$welcome_email = get_site_option( 'welcome_email' );\n\tif ( $welcome_email == false ) {\n\t\t/* translators: Do not translate USERNAME, SITE_NAME, BLOG_URL, PASSWORD: those are placeholders. */\n\t\t$welcome_email = __( 'Howdy USERNAME,\n\nYour new SITE_NAME site has been successfully set up at:\nBLOG_URL\n\nYou can log in to the administrator account with the following information:\n\nUsername: USERNAME\nPassword: PASSWORD\nLog in here: BLOG_URLwp-login.php\n\nWe hope you enjoy your new site. Thanks!\n\n--The Team @ SITE_NAME' );\n\t}\n\n\t$url = get_blogaddress_by_id($blog_id);\n\n\t$welcome_email = str_replace( 'SITE_NAME', $current_network->site_name, $welcome_email );\n\t$welcome_email = str_replace( 'BLOG_TITLE', $title, $welcome_email );\n\t$welcome_email = str_replace( 'BLOG_URL', $url, $welcome_email );\n\t$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );\n\t$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );\n\n\t/**\n\t * Filters the content of the welcome email after site activation.\n\t *\n\t * Content should be formatted for transmission via wp_mail().\n\t *\n\t * @since MU\n\t *\n\t * @param string $welcome_email Message body of the email.\n\t * @param int    $blog_id       Blog ID.\n\t * @param int    $user_id       User ID.\n\t * @param string $password      User password.\n\t * @param string $title         Site title.\n\t * @param array  $meta          Signup meta data.\n\t */\n\t$welcome_email = apply_filters( 'update_welcome_email', $welcome_email, $blog_id, $user_id, $password, $title, $meta );\n\t$admin_email = get_site_option( 'admin_email' );\n\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = $welcome_email;\n\n\tif ( empty( $current_network->site_name ) )\n\t\t$current_network->site_name = 'WordPress';\n\n\t/* translators: New site notification email subject. 1: Network name, 2: New site name */\n\t$subject = __( 'New %1$s Site: %2$s' );\n\n\t/**\n\t * Filters the subject of the welcome email after site activation.\n\t *\n\t * @since MU\n\t *\n\t * @param string $subject Subject of the email.\n\t */\n\t$subject = apply_filters( 'update_welcome_subject', sprintf( $subject, $current_network->site_name, wp_unslash( $title ) ) );\n\twp_mail( $user->user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Notify a user that their account activation has been successful.\n *\n * Filter {@see 'wpmu_welcome_user_notification'} to disable or bypass.\n *\n * Filter {@see 'update_welcome_user_email'} and {@see 'update_welcome_user_subject'} to\n * modify the content and subject line of the notification email.\n *\n * @since MU\n *\n * @param int    $user_id\n * @param string $password\n * @param array  $meta     Optional. Not used in the default function, but is passed along to hooks for customization.\n * @return bool\n */\nfunction wpmu_welcome_user_notification( $user_id, $password, $meta = array() ) {\n\t$current_network = get_network();\n\n\t/**\n \t * Filters whether to bypass the welcome email after user activation.\n\t *\n\t * Returning false disables the welcome email.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $user_id  User ID.\n\t * @param string $password User password.\n\t * @param array  $meta     Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_welcome_user_notification', $user_id, $password, $meta ) )\n\t\treturn false;\n\n\t$welcome_email = get_site_option( 'welcome_user_email' );\n\n\t$user = get_userdata( $user_id );\n\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t/**\n\t * Filters the content of the welcome email after user activation.\n\t *\n\t * Content should be formatted for transmission via wp_mail().\n\t *\n\t * @since MU\n\t *\n\t * @param string $welcome_email The message body of the account activation success email.\n\t * @param int    $user_id       User ID.\n\t * @param string $password      User password.\n\t * @param array  $meta          Signup meta data.\n\t */\n\t$welcome_email = apply_filters( 'update_welcome_user_email', $welcome_email, $user_id, $password, $meta );\n\t$welcome_email = str_replace( 'SITE_NAME', $current_network->site_name, $welcome_email );\n\t$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );\n\t$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );\n\t$welcome_email = str_replace( 'LOGINLINK', wp_login_url(), $welcome_email );\n\n\t$admin_email = get_site_option( 'admin_email' );\n\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = $welcome_email;\n\n\tif ( empty( $current_network->site_name ) )\n\t\t$current_network->site_name = 'WordPress';\n\n\t/* translators: New user notification email subject. 1: Network name, 2: New user login */\n\t$subject = __( 'New %1$s User: %2$s' );\n\n\t/**\n\t * Filters the subject of the welcome email after user activation.\n\t *\n\t * @since MU\n\t *\n\t * @param string $subject Subject of the email.\n\t */\n\t$subject = apply_filters( 'update_welcome_user_subject', sprintf( $subject, $current_network->site_name, $user->user_login) );\n\twp_mail( $user->user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Get the current network.\n *\n * Returns an object containing the 'id', 'domain', 'path', and 'site_name'\n * properties of the network being viewed.\n *\n * @see wpmu_current_site()\n *\n * @since MU\n *\n * @global WP_Network $current_site\n *\n * @return WP_Network\n */\nfunction get_current_site() {\n\tglobal $current_site;\n\treturn $current_site;\n}\n\n/**\n * Get a user's most recent post.\n *\n * Walks through each of a user's blogs to find the post with\n * the most recent post_date_gmt.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $user_id\n * @return array Contains the blog_id, post_id, post_date_gmt, and post_gmt_ts\n */\nfunction get_most_recent_post_of_user( $user_id ) {\n\tglobal $wpdb;\n\n\t$user_blogs = get_blogs_of_user( (int) $user_id );\n\t$most_recent_post = array();\n\n\t// Walk through each blog and get the most recent post\n\t// published by $user_id\n\tforeach ( (array) $user_blogs as $blog ) {\n\t\t$prefix = $wpdb->get_blog_prefix( $blog->userblog_id );\n\t\t$recent_post = $wpdb->get_row( $wpdb->prepare(\"SELECT ID, post_date_gmt FROM {$prefix}posts WHERE post_author = %d AND post_type = 'post' AND post_status = 'publish' ORDER BY post_date_gmt DESC LIMIT 1\", $user_id ), ARRAY_A);\n\n\t\t// Make sure we found a post\n\t\tif ( isset($recent_post['ID']) ) {\n\t\t\t$post_gmt_ts = strtotime($recent_post['post_date_gmt']);\n\n\t\t\t// If this is the first post checked or if this post is\n\t\t\t// newer than the current recent post, make it the new\n\t\t\t// most recent post.\n\t\t\tif ( !isset($most_recent_post['post_gmt_ts']) || ( $post_gmt_ts > $most_recent_post['post_gmt_ts'] ) ) {\n\t\t\t\t$most_recent_post = array(\n\t\t\t\t\t'blog_id'\t\t=> $blog->userblog_id,\n\t\t\t\t\t'post_id'\t\t=> $recent_post['ID'],\n\t\t\t\t\t'post_date_gmt'\t=> $recent_post['post_date_gmt'],\n\t\t\t\t\t'post_gmt_ts'\t=> $post_gmt_ts\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn $most_recent_post;\n}\n\n// Misc functions\n\n/**\n * Get the size of a directory.\n *\n * A helper function that is used primarily to check whether\n * a blog has exceeded its allowed upload space.\n *\n * @since MU\n *\n * @param string $directory Full path of a directory.\n * @return int Size of the directory in MB.\n */\nfunction get_dirsize( $directory ) {\n\t$dirsize = get_transient( 'dirsize_cache' );\n\tif ( is_array( $dirsize ) && isset( $dirsize[ $directory ][ 'size' ] ) )\n\t\treturn $dirsize[ $directory ][ 'size' ];\n\n\tif ( ! is_array( $dirsize ) )\n\t\t$dirsize = array();\n\n\t// Exclude individual site directories from the total when checking the main site,\n\t// as they are subdirectories and should not be counted.\n\tif ( is_main_site() ) {\n\t\t$dirsize[ $directory ][ 'size' ] = recurse_dirsize( $directory, $directory . '/sites' );\n\t} else {\n\t\t$dirsize[ $directory ][ 'size' ] = recurse_dirsize( $directory );\n\t}\n\n\tset_transient( 'dirsize_cache', $dirsize, HOUR_IN_SECONDS );\n\treturn $dirsize[ $directory ][ 'size' ];\n}\n\n/**\n * Get the size of a directory recursively.\n *\n * Used by get_dirsize() to get a directory's size when it contains\n * other directories.\n *\n * @since MU\n * @since 4.3.0 $exclude parameter added.\n *\n * @param string $directory Full path of a directory.\n * @param string $exclude   Optional. Full path of a subdirectory to exclude from the total.\n * @return int|false Size in MB if a valid directory. False if not.\n */\nfunction recurse_dirsize( $directory, $exclude = null ) {\n\t$size = 0;\n\n\t$directory = untrailingslashit( $directory );\n\n\tif ( ! file_exists( $directory ) || ! is_dir( $directory ) || ! is_readable( $directory ) || $directory === $exclude ) {\n\t\treturn false;\n\t}\n\n\tif ($handle = opendir($directory)) {\n\t\twhile(($file = readdir($handle)) !== false) {\n\t\t\t$path = $directory.'/'.$file;\n\t\t\tif ($file != '.' && $file != '..') {\n\t\t\t\tif (is_file($path)) {\n\t\t\t\t\t$size += filesize($path);\n\t\t\t\t} elseif (is_dir($path)) {\n\t\t\t\t\t$handlesize = recurse_dirsize( $path, $exclude );\n\t\t\t\t\tif ($handlesize > 0)\n\t\t\t\t\t\t$size += $handlesize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir($handle);\n\t}\n\treturn $size;\n}\n\n/**\n * Check an array of MIME types against a whitelist.\n *\n * WordPress ships with a set of allowed upload filetypes,\n * which is defined in wp-includes/functions.php in\n * get_allowed_mime_types(). This function is used to filter\n * that list against the filetype whitelist provided by Multisite\n * Super Admins at wp-admin/network/settings.php.\n *\n * @since MU\n *\n * @param array $mimes\n * @return array\n */\nfunction check_upload_mimes( $mimes ) {\n\t$site_exts = explode( ' ', get_site_option( 'upload_filetypes', 'jpg jpeg png gif' ) );\n\t$site_mimes = array();\n\tforeach ( $site_exts as $ext ) {\n\t\tforeach ( $mimes as $ext_pattern => $mime ) {\n\t\t\tif ( $ext != '' && strpos( $ext_pattern, $ext ) !== false )\n\t\t\t\t$site_mimes[$ext_pattern] = $mime;\n\t\t}\n\t}\n\treturn $site_mimes;\n}\n\n/**\n * Update a blog's post count.\n *\n * WordPress MS stores a blog's post count as an option so as\n * to avoid extraneous COUNTs when a blog's details are fetched\n * with get_site(). This function is called when posts are published\n * or unpublished to make sure the count stays current.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $deprecated Not used.\n */\nfunction update_posts_count( $deprecated = '' ) {\n\tglobal $wpdb;\n\tupdate_option( 'post_count', (int) $wpdb->get_var( \"SELECT COUNT(ID) FROM {$wpdb->posts} WHERE post_status = 'publish' and post_type = 'post'\" ) );\n}\n\n/**\n * Logs user registrations.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $blog_id\n * @param int $user_id\n */\nfunction wpmu_log_new_registrations( $blog_id, $user_id ) {\n\tglobal $wpdb;\n\t$user = get_userdata( (int) $user_id );\n\tif ( $user )\n\t\t$wpdb->insert( $wpdb->registration_log, array('email' => $user->user_email, 'IP' => preg_replace( '/[^0-9., ]/', '', wp_unslash( $_SERVER['REMOTE_ADDR'] ) ), 'blog_id' => $blog_id, 'date_registered' => current_time('mysql')) );\n}\n\n/**\n * Maintains a canonical list of terms by syncing terms created for each blog with the global terms table.\n *\n * @since 3.0.0\n *\n * @see term_id_filter\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar int $global_terms_recurse\n *\n * @param int    $term_id    An ID for a term on the current blog.\n * @param string $deprecated Not used.\n * @return int An ID from the global terms table mapped from $term_id.\n */\nfunction global_terms( $term_id, $deprecated = '' ) {\n\tglobal $wpdb;\n\tstatic $global_terms_recurse = null;\n\n\tif ( !global_terms_enabled() )\n\t\treturn $term_id;\n\n\t// prevent a race condition\n\t$recurse_start = false;\n\tif ( $global_terms_recurse === null ) {\n\t\t$recurse_start = true;\n\t\t$global_terms_recurse = 1;\n\t} elseif ( 10 < $global_terms_recurse++ ) {\n\t\treturn $term_id;\n\t}\n\n\t$term_id = intval( $term_id );\n\t$c = $wpdb->get_row( $wpdb->prepare( \"SELECT * FROM $wpdb->terms WHERE term_id = %d\", $term_id ) );\n\n\t$global_id = $wpdb->get_var( $wpdb->prepare( \"SELECT cat_ID FROM $wpdb->sitecategories WHERE category_nicename = %s\", $c->slug ) );\n\tif ( $global_id == null ) {\n\t\t$used_global_id = $wpdb->get_var( $wpdb->prepare( \"SELECT cat_ID FROM $wpdb->sitecategories WHERE cat_ID = %d\", $c->term_id ) );\n\t\tif ( null == $used_global_id ) {\n\t\t\t$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $term_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );\n\t\t\t$global_id = $wpdb->insert_id;\n\t\t\tif ( empty( $global_id ) )\n\t\t\t\treturn $term_id;\n\t\t} else {\n\t\t\t$max_global_id = $wpdb->get_var( \"SELECT MAX(cat_ID) FROM $wpdb->sitecategories\" );\n\t\t\t$max_local_id = $wpdb->get_var( \"SELECT MAX(term_id) FROM $wpdb->terms\" );\n\t\t\t$new_global_id = max( $max_global_id, $max_local_id ) + mt_rand( 100, 400 );\n\t\t\t$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $new_global_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );\n\t\t\t$global_id = $wpdb->insert_id;\n\t\t}\n\t} elseif ( $global_id != $term_id ) {\n\t\t$local_id = $wpdb->get_var( $wpdb->prepare( \"SELECT term_id FROM $wpdb->terms WHERE term_id = %d\", $global_id ) );\n\t\tif ( null != $local_id ) {\n\t\t\tglobal_terms( $local_id );\n\t\t\tif ( 10 < $global_terms_recurse ) {\n\t\t\t\t$global_id = $term_id;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( $global_id != $term_id ) {\n\t\tif ( get_option( 'default_category' ) == $term_id )\n\t\t\tupdate_option( 'default_category', $global_id );\n\n\t\t$wpdb->update( $wpdb->terms, array('term_id' => $global_id), array('term_id' => $term_id) );\n\t\t$wpdb->update( $wpdb->term_taxonomy, array('term_id' => $global_id), array('term_id' => $term_id) );\n\t\t$wpdb->update( $wpdb->term_taxonomy, array('parent' => $global_id), array('parent' => $term_id) );\n\n\t\tclean_term_cache($term_id);\n\t}\n\tif ( $recurse_start )\n\t\t$global_terms_recurse = null;\n\n\treturn $global_id;\n}\n\n/**\n * Ensure that the current site's domain is listed in the allowed redirect host list.\n *\n * @see wp_validate_redirect()\n * @since MU\n *\n * @param array|string $deprecated Not used.\n * @return array The current site's domain\n */\nfunction redirect_this_site( $deprecated = '' ) {\n\treturn array( get_network()->domain );\n}\n\n/**\n * Check whether an upload is too big.\n *\n * @since MU\n *\n * @blessed\n *\n * @param array $upload\n * @return string|array If the upload is under the size limit, $upload is returned. Otherwise returns an error message.\n */\nfunction upload_is_file_too_big( $upload ) {\n\tif ( ! is_array( $upload ) || defined( 'WP_IMPORTING' ) || get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn $upload;\n\n\tif ( strlen( $upload['bits'] )  > ( KB_IN_BYTES * get_site_option( 'fileupload_maxk', 1500 ) ) ) {\n\t\treturn sprintf( __( 'This file is too big. Files must be less than %d KB in size.' ) . '<br />', get_site_option( 'fileupload_maxk', 1500 ) );\n\t}\n\n\treturn $upload;\n}\n\n/**\n * Add a nonce field to the signup page.\n *\n * @since MU\n */\nfunction signup_nonce_fields() {\n\t$id = mt_rand();\n\techo \"<input type='hidden' name='signup_form_id' value='{$id}' />\";\n\twp_nonce_field('signup_form_' . $id, '_signup_form', false);\n}\n\n/**\n * Process the signup nonce created in signup_nonce_fields().\n *\n * @since MU\n *\n * @param array $result\n * @return array\n */\nfunction signup_nonce_check( $result ) {\n\tif ( !strpos( $_SERVER[ 'PHP_SELF' ], 'wp-signup.php' ) )\n\t\treturn $result;\n\n\tif ( wp_create_nonce('signup_form_' . $_POST[ 'signup_form_id' ]) != $_POST['_signup_form'] )\n\t\twp_die( __( 'Please try again.' ) );\n\n\treturn $result;\n}\n\n/**\n * Correct 404 redirects when NOBLOGREDIRECT is defined.\n *\n * @since MU\n */\nfunction maybe_redirect_404() {\n\t/**\n\t * Filters the redirect URL for 404s on the main site.\n\t *\n\t * The filter is only evaluated if the NOBLOGREDIRECT constant is defined.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param string $no_blog_redirect The redirect URL defined in NOBLOGREDIRECT.\n\t */\n\tif ( is_main_site() && is_404() && defined( 'NOBLOGREDIRECT' ) && ( $destination = apply_filters( 'blog_redirect_404', NOBLOGREDIRECT ) ) ) {\n\t\tif ( $destination == '%siteurl%' )\n\t\t\t$destination = network_home_url();\n\t\twp_redirect( $destination );\n\t\texit();\n\t}\n}\n\n/**\n * Add a new user to a blog by visiting /newbloguser/username/.\n *\n * This will only work when the user's details are saved as an option\n * keyed as 'new_user_x', where 'x' is the username of the user to be\n * added, as when a user is invited through the regular WP Add User interface.\n *\n * @since MU\n */\nfunction maybe_add_existing_user_to_blog() {\n\tif ( false === strpos( $_SERVER[ 'REQUEST_URI' ], '/newbloguser/' ) )\n\t\treturn;\n\n\t$parts = explode( '/', $_SERVER[ 'REQUEST_URI' ] );\n\t$key = array_pop( $parts );\n\n\tif ( $key == '' )\n\t\t$key = array_pop( $parts );\n\n\t$details = get_option( 'new_user_' . $key );\n\tif ( !empty( $details ) )\n\t\tdelete_option( 'new_user_' . $key );\n\n\tif ( empty( $details ) || is_wp_error( add_existing_user_to_blog( $details ) ) )\n\t\twp_die( sprintf(__('An error occurred adding you to this site. Back to the <a href=\"%s\">homepage</a>.'), home_url() ) );\n\n\twp_die( sprintf( __( 'You have been added to this site. Please visit the <a href=\"%s\">homepage</a> or <a href=\"%s\">log in</a> using your username and password.' ), home_url(), admin_url() ), __( 'WordPress &rsaquo; Success' ), array( 'response' => 200 ) );\n}\n\n/**\n * Add a user to a blog based on details from maybe_add_existing_user_to_blog().\n *\n * @since MU\n *\n * @param array $details\n * @return true|WP_Error|void\n */\nfunction add_existing_user_to_blog( $details = false ) {\n\tif ( is_array( $details ) ) {\n\t\t$blog_id = get_current_blog_id();\n\t\t$result = add_user_to_blog( $blog_id, $details[ 'user_id' ], $details[ 'role' ] );\n\t\t/**\n\t\t * Fires immediately after an existing user is added to a site.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param int   $user_id User ID.\n\t\t * @param mixed $result  True on success or a WP_Error object if the user doesn't exist.\n\t\t */\n\t\tdo_action( 'added_existing_user', $details['user_id'], $result );\n\t\treturn $result;\n\t}\n}\n\n/**\n * Adds a newly created user to the appropriate blog\n *\n * To add a user in general, use add_user_to_blog(). This function\n * is specifically hooked into the {@see 'wpmu_activate_user'} action.\n *\n * @since MU\n * @see add_user_to_blog()\n *\n * @param int   $user_id\n * @param mixed $password Ignored.\n * @param array $meta\n */\nfunction add_new_user_to_blog( $user_id, $password, $meta ) {\n\tif ( !empty( $meta[ 'add_to_blog' ] ) ) {\n\t\t$blog_id = $meta[ 'add_to_blog' ];\n\t\t$role = $meta[ 'new_role' ];\n\t\tremove_user_from_blog($user_id, get_network()->site_id); // remove user from main blog.\n\t\tadd_user_to_blog( $blog_id, $user_id, $role );\n\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\t}\n}\n\n/**\n * Correct From host on outgoing mail to match the site domain\n *\n * @since MU\n *\n * @param PHPMailer $phpmailer The PHPMailer instance, passed by reference.\n */\nfunction fix_phpmailer_messageid( $phpmailer ) {\n\t$phpmailer->Hostname = get_network()->domain;\n}\n\n/**\n * Check to see whether a user is marked as a spammer, based on user login.\n *\n * @since MU\n *\n * @param string|WP_User $user Optional. Defaults to current user. WP_User object,\n * \t                           or user login name as a string.\n * @return bool\n */\nfunction is_user_spammy( $user = null ) {\n    if ( ! ( $user instanceof WP_User ) ) {\n\t\tif ( $user ) {\n\t\t\t$user = get_user_by( 'login', $user );\n\t\t} else {\n\t\t\t$user = wp_get_current_user();\n\t\t}\n\t}\n\n\treturn $user && isset( $user->spam ) && 1 == $user->spam;\n}\n\n/**\n * Update this blog's 'public' setting in the global blogs table.\n *\n * Public blogs have a setting of 1, private blogs are 0.\n *\n * @since MU\n *\n * @param int $old_value\n * @param int $value     The new public value\n */\nfunction update_blog_public( $old_value, $value ) {\n\tupdate_blog_status( get_current_blog_id(), 'public', (int) $value );\n}\n\n/**\n * Check whether a usermeta key has to do with the current blog.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $key\n * @param int    $user_id Optional. Defaults to current user.\n * @param int    $blog_id Optional. Defaults to current blog.\n * @return bool\n */\nfunction is_user_option_local( $key, $user_id = 0, $blog_id = 0 ) {\n\tglobal $wpdb;\n\n\t$current_user = wp_get_current_user();\n\tif ( $blog_id == 0 ) {\n\t\t$blog_id = $wpdb->blogid;\n\t}\n\t$local_key = $wpdb->get_blog_prefix( $blog_id ) . $key;\n\n\treturn isset( $current_user->$local_key );\n}\n\n/**\n * Check whether users can self-register, based on Network settings.\n *\n * @since MU\n *\n * @return bool\n */\nfunction users_can_register_signup_filter() {\n\t$registration = get_site_option('registration');\n\treturn ( $registration == 'all' || $registration == 'user' );\n}\n\n/**\n * Ensure that the welcome message is not empty. Currently unused.\n *\n * @since MU\n *\n * @param string $text\n * @return string\n */\nfunction welcome_user_msg_filter( $text ) {\n\tif ( !$text ) {\n\t\tremove_filter( 'site_option_welcome_user_email', 'welcome_user_msg_filter' );\n\n\t\t/* translators: Do not translate USERNAME, PASSWORD, LOGINLINK, SITE_NAME: those are placeholders. */\n\t\t$text = __( 'Howdy USERNAME,\n\nYour new account is set up.\n\nYou can log in with the following information:\nUsername: USERNAME\nPassword: PASSWORD\nLOGINLINK\n\nThanks!\n\n--The Team @ SITE_NAME' );\n\t\tupdate_site_option( 'welcome_user_email', $text );\n\t}\n\treturn $text;\n}\n\n/**\n * Whether to force SSL on content.\n *\n * @since 2.8.5\n *\n * @staticvar bool $forced_content\n *\n * @param bool $force\n * @return bool True if forced, false if not forced.\n */\nfunction force_ssl_content( $force = '' ) {\n\tstatic $forced_content = false;\n\n\tif ( '' != $force ) {\n\t\t$old_forced = $forced_content;\n\t\t$forced_content = $force;\n\t\treturn $old_forced;\n\t}\n\n\treturn $forced_content;\n}\n\n/**\n * Formats a URL to use https.\n *\n * Useful as a filter.\n *\n * @since 2.8.5\n *\n * @param string $url URL\n * @return string URL with https as the scheme\n */\nfunction filter_SSL( $url ) {\n\tif ( ! is_string( $url ) )\n\t\treturn get_bloginfo( 'url' ); // Return home blog url with proper scheme\n\n\tif ( force_ssl_content() && is_ssl() )\n\t\t$url = set_url_scheme( $url, 'https' );\n\n\treturn $url;\n}\n\n/**\n * Schedule update of the network-wide counts for the current network.\n *\n * @since 3.1.0\n */\nfunction wp_schedule_update_network_counts() {\n\tif ( !is_main_site() )\n\t\treturn;\n\n\tif ( ! wp_next_scheduled('update_network_counts') && ! wp_installing() )\n\t\twp_schedule_event(time(), 'twicedaily', 'update_network_counts');\n}\n\n/**\n * Update the network-wide counts for the current network.\n *\n * @since 3.1.0\n */\nfunction wp_update_network_counts() {\n\twp_update_network_user_counts();\n\twp_update_network_site_counts();\n}\n\n/**\n * Update the count of sites for the current network.\n *\n * If enabled through the {@see 'enable_live_network_counts'} filter, update the sites count\n * on a network when a site is created or its status is updated.\n *\n * @since 3.7.0\n */\nfunction wp_maybe_update_network_site_counts() {\n\t$is_small_network = ! wp_is_large_network( 'sites' );\n\n\t/**\n\t * Filters whether to update network site or user counts when a new site is created.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @see wp_is_large_network()\n\t *\n\t * @param bool   $small_network Whether the network is considered small.\n\t * @param string $context       Context. Either 'users' or 'sites'.\n\t */\n\tif ( ! apply_filters( 'enable_live_network_counts', $is_small_network, 'sites' ) )\n\t\treturn;\n\n\twp_update_network_site_counts();\n}\n\n/**\n * Update the network-wide users count.\n *\n * If enabled through the {@see 'enable_live_network_counts'} filter, update the users count\n * on a network when a user is created or its status is updated.\n *\n * @since 3.7.0\n */\nfunction wp_maybe_update_network_user_counts() {\n\t$is_small_network = ! wp_is_large_network( 'users' );\n\n\t/** This filter is documented in wp-includes/ms-functions.php */\n\tif ( ! apply_filters( 'enable_live_network_counts', $is_small_network, 'users' ) )\n\t\treturn;\n\n\twp_update_network_user_counts();\n}\n\n/**\n * Update the network-wide site count.\n *\n * @since 3.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction wp_update_network_site_counts() {\n\tglobal $wpdb;\n\n\t$count = get_sites( array(\n\t\t'network_id' => $wpdb->siteid,\n\t\t'spam'       => 0,\n\t\t'deleted'    => 0,\n\t\t'archived'   => 0,\n\t\t'count'      => true,\n\t) );\n\n\tupdate_site_option( 'blog_count', $count );\n}\n\n/**\n * Update the network-wide user count.\n *\n * @since 3.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction wp_update_network_user_counts() {\n\tglobal $wpdb;\n\n\t$count = $wpdb->get_var( \"SELECT COUNT(ID) as c FROM $wpdb->users WHERE spam = '0' AND deleted = '0'\" );\n\tupdate_site_option( 'user_count', $count );\n}\n\n/**\n * Returns the space used by the current blog.\n *\n * @since 3.5.0\n *\n * @return int Used space in megabytes\n */\nfunction get_space_used() {\n\t/**\n\t * Filters the amount of storage space used by the current site.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param int|bool $space_used The amount of used space, in megabytes. Default false.\n\t */\n\t$space_used = apply_filters( 'pre_get_space_used', false );\n\tif ( false === $space_used ) {\n\t\t$upload_dir = wp_upload_dir();\n\t\t$space_used = get_dirsize( $upload_dir['basedir'] ) / MB_IN_BYTES;\n\t}\n\n\treturn $space_used;\n}\n\n/**\n * Returns the upload quota for the current blog.\n *\n * @since MU\n *\n * @return int Quota in megabytes\n */\nfunction get_space_allowed() {\n\t$space_allowed = get_option( 'blog_upload_space' );\n\n\tif ( ! is_numeric( $space_allowed ) )\n\t\t$space_allowed = get_site_option( 'blog_upload_space' );\n\n\tif ( ! is_numeric( $space_allowed ) )\n\t\t$space_allowed = 100;\n\n\t/**\n\t * Filters the upload quota for the current site.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param int $space_allowed Upload quota in megabytes for the current blog.\n\t */\n\treturn apply_filters( 'get_space_allowed', $space_allowed );\n}\n\n/**\n * Determines if there is any upload space left in the current blog's quota.\n *\n * @since 3.0.0\n *\n * @return int of upload space available in bytes\n */\nfunction get_upload_space_available() {\n\t$allowed = get_space_allowed();\n\tif ( $allowed < 0 ) {\n\t\t$allowed = 0;\n\t}\n\t$space_allowed = $allowed * MB_IN_BYTES;\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn $space_allowed;\n\n\t$space_used = get_space_used() * MB_IN_BYTES;\n\n\tif ( ( $space_allowed - $space_used ) <= 0 )\n\t\treturn 0;\n\n\treturn $space_allowed - $space_used;\n}\n\n/**\n * Determines if there is any upload space left in the current blog's quota.\n *\n * @since 3.0.0\n * @return bool True if space is available, false otherwise.\n */\nfunction is_upload_space_available() {\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn true;\n\n\treturn (bool) get_upload_space_available();\n}\n\n/**\n * Filters the maximum upload file size allowed, in bytes.\n *\n * @since 3.0.0\n *\n * @param  int $size Upload size limit in bytes.\n * @return int       Upload size limit in bytes.\n */\nfunction upload_size_limit_filter( $size ) {\n\t$fileupload_maxk = KB_IN_BYTES * get_site_option( 'fileupload_maxk', 1500 );\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn min( $size, $fileupload_maxk );\n\n\treturn min( $size, $fileupload_maxk, get_upload_space_available() );\n}\n\n/**\n * Whether or not we have a large network.\n *\n * The default criteria for a large network is either more than 10,000 users or more than 10,000 sites.\n * Plugins can alter this criteria using the {@see 'wp_is_large_network'} filter.\n *\n * @since 3.3.0\n * @param string $using 'sites or 'users'. Default is 'sites'.\n * @return bool True if the network meets the criteria for large. False otherwise.\n */\nfunction wp_is_large_network( $using = 'sites' ) {\n\tif ( 'users' == $using ) {\n\t\t$count = get_user_count();\n\t\t/**\n\t\t * Filters whether the network is considered large.\n\t\t *\n\t\t * @since 3.3.0\n\t\t *\n\t\t * @param bool   $is_large_network Whether the network has more than 10000 users or sites.\n\t\t * @param string $component        The component to count. Accepts 'users', or 'sites'.\n\t\t * @param int    $count            The count of items for the component.\n\t\t */\n\t\treturn apply_filters( 'wp_is_large_network', $count > 10000, 'users', $count );\n\t}\n\n\t$count = get_blog_count();\n\t/** This filter is documented in wp-includes/ms-functions.php */\n\treturn apply_filters( 'wp_is_large_network', $count > 10000, 'sites', $count );\n}\n\n/**\n * Retrieves a list of reserved site on a sub-directory Multisite install.\n *\n * @since 4.4.0\n *\n * @return array $names Array of reserved subdirectory names.\n */\nfunction get_subdirectory_reserved_names() {\n\t$names = array(\n\t\t'page', 'comments', 'blog', 'files', 'feed', 'wp-admin',\n\t\t'wp-content', 'wp-includes', 'wp-json', 'embed'\n\t);\n\n\t/**\n\t * Filters reserved site names on a sub-directory Multisite install.\n\t *\n\t * @since 3.0.0\n\t * @since 4.4.0 'wp-admin', 'wp-content', 'wp-includes', 'wp-json', and 'embed' were added\n\t *              to the reserved names list.\n\t *\n\t * @param array $subdirectory_reserved_names Array of reserved names.\n\t */\n\treturn apply_filters( 'subdirectory_reserved_names', $names );\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39772';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Multisite WordPress API\n *\n * @package WordPress\n * @subpackage Multisite\n * @since 3.0.0\n */\n\n/**\n * Gets the network's site and user counts.\n *\n * @since MU 1.0\n *\n * @return array Site and user count for the network.\n */\nfunction get_sitestats() {\n\t$stats = array(\n\t\t'blogs' => get_blog_count(),\n\t\t'users' => get_user_count(),\n\t);\n\n\treturn $stats;\n}\n\n/**\n * Get one of a user's active blogs\n *\n * Returns the user's primary blog, if they have one and\n * it is active. If it's inactive, function returns another\n * active blog of the user. If none are found, the user\n * is added as a Subscriber to the Dashboard Blog and that blog\n * is returned.\n *\n * @since MU 1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $user_id The unique ID of the user\n * @return WP_Site|void The blog object\n */\nfunction get_active_blog_for_user( $user_id ) {\n\tglobal $wpdb;\n\t$blogs = get_blogs_of_user( $user_id );\n\tif ( empty( $blogs ) )\n\t\treturn;\n\n\tif ( !is_multisite() )\n\t\treturn $blogs[$wpdb->blogid];\n\n\t$primary_blog = get_user_meta( $user_id, 'primary_blog', true );\n\t$first_blog = current($blogs);\n\tif ( false !== $primary_blog ) {\n\t\tif ( ! isset( $blogs[ $primary_blog ] ) ) {\n\t\t\tupdate_user_meta( $user_id, 'primary_blog', $first_blog->userblog_id );\n\t\t\t$primary = get_site( $first_blog->userblog_id );\n\t\t} else {\n\t\t\t$primary = get_site( $primary_blog );\n\t\t}\n\t} else {\n\t\t//TODO Review this call to add_user_to_blog too - to get here the user must have a role on this blog?\n\t\tadd_user_to_blog( $first_blog->userblog_id, $user_id, 'subscriber' );\n\t\tupdate_user_meta( $user_id, 'primary_blog', $first_blog->userblog_id );\n\t\t$primary = $first_blog;\n\t}\n\n\tif ( ( ! is_object( $primary ) ) || ( $primary->archived == 1 || $primary->spam == 1 || $primary->deleted == 1 ) ) {\n\t\t$blogs = get_blogs_of_user( $user_id, true ); // if a user's primary blog is shut down, check their other blogs.\n\t\t$ret = false;\n\t\tif ( is_array( $blogs ) && count( $blogs ) > 0 ) {\n\t\t\tforeach ( (array) $blogs as $blog_id => $blog ) {\n\t\t\t\tif ( $blog->site_id != $wpdb->siteid )\n\t\t\t\t\tcontinue;\n\t\t\t\t$details = get_site( $blog_id );\n\t\t\t\tif ( is_object( $details ) && $details->archived == 0 && $details->spam == 0 && $details->deleted == 0 ) {\n\t\t\t\t\t$ret = $blog;\n\t\t\t\t\tif ( get_user_meta( $user_id , 'primary_blog', true ) != $blog_id )\n\t\t\t\t\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\t\t\t\t\tif ( !get_user_meta($user_id , 'source_domain', true) )\n\t\t\t\t\t\tupdate_user_meta( $user_id, 'source_domain', $blog->domain );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\treturn $ret;\n\t} else {\n\t\treturn $primary;\n\t}\n}\n\n/**\n * The number of active users in your installation.\n *\n * The count is cached and updated twice daily. This is not a live count.\n *\n * @since MU 2.7\n *\n * @return int\n */\nfunction get_user_count() {\n\treturn get_site_option( 'user_count' );\n}\n\n/**\n * The number of active sites on your installation.\n *\n * The count is cached and updated twice daily. This is not a live count.\n *\n * @since MU 1.0\n *\n * @param int $network_id Deprecated, not supported.\n * @return int\n */\nfunction get_blog_count( $network_id = 0 ) {\n\tif ( func_num_args() )\n\t\t_deprecated_argument( __FUNCTION__, '3.1.0' );\n\n\treturn get_site_option( 'blog_count' );\n}\n\n/**\n * Get a blog post from any site on the network.\n *\n * @since MU 1.0\n *\n * @param int $blog_id ID of the blog.\n * @param int $post_id ID of the post you're looking for.\n * @return WP_Post|null WP_Post on success or null on failure\n */\nfunction get_blog_post( $blog_id, $post_id ) {\n\tswitch_to_blog( $blog_id );\n\t$post = get_post( $post_id );\n\trestore_current_blog();\n\n\treturn $post;\n}\n\n/**\n * Adds a user to a blog.\n *\n * Use the {@see 'add_user_to_blog'} action to fire an event when users are added to a blog.\n *\n * @since MU 1.0\n *\n * @param int    $blog_id ID of the blog you're adding the user to.\n * @param int    $user_id ID of the user you're adding.\n * @param string $role    The role you want the user to have\n * @return true|WP_Error\n */\nfunction add_user_to_blog( $blog_id, $user_id, $role ) {\n\tswitch_to_blog($blog_id);\n\n\t$user = get_userdata( $user_id );\n\n\tif ( ! $user ) {\n\t\trestore_current_blog();\n\t\treturn new WP_Error( 'user_does_not_exist', __( 'The requested user does not exist.' ) );\n\t}\n\n\tif ( !get_user_meta($user_id, 'primary_blog', true) ) {\n\t\tupdate_user_meta($user_id, 'primary_blog', $blog_id);\n\t\t$site = get_site( $blog_id );\n\t\tupdate_user_meta( $user_id, 'source_domain', $site->domain );\n\t}\n\n\t$user->set_role($role);\n\n\t/**\n\t * Fires immediately after a user is added to a site.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $user_id User ID.\n\t * @param string $role    User role.\n\t * @param int    $blog_id Blog ID.\n\t */\n\tdo_action( 'add_user_to_blog', $user_id, $role, $blog_id );\n\twp_cache_delete( $user_id, 'users' );\n\twp_cache_delete( $blog_id . '_user_count', 'blog-details' );\n\trestore_current_blog();\n\treturn true;\n}\n\n/**\n * Remove a user from a blog.\n *\n * Use the {@see 'remove_user_from_blog'} action to fire an event when\n * users are removed from a blog.\n *\n * Accepts an optional `$reassign` parameter, if you want to\n * reassign the user's blog posts to another user upon removal.\n *\n * @since MU 1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int    $user_id  ID of the user you're removing.\n * @param int    $blog_id  ID of the blog you're removing the user from.\n * @param string $reassign Optional. A user to whom to reassign posts.\n * @return true|WP_Error\n */\nfunction remove_user_from_blog($user_id, $blog_id = '', $reassign = '') {\n\tglobal $wpdb;\n\tswitch_to_blog($blog_id);\n\t$user_id = (int) $user_id;\n\t/**\n\t * Fires before a user is removed from a site.\n\t *\n\t * @since MU\n\t *\n\t * @param int $user_id User ID.\n\t * @param int $blog_id Blog ID.\n\t */\n\tdo_action( 'remove_user_from_blog', $user_id, $blog_id );\n\n\t// If being removed from the primary blog, set a new primary if the user is assigned\n\t// to multiple blogs.\n\t$primary_blog = get_user_meta($user_id, 'primary_blog', true);\n\tif ( $primary_blog == $blog_id ) {\n\t\t$new_id = '';\n\t\t$new_domain = '';\n\t\t$blogs = get_blogs_of_user($user_id);\n\t\tforeach ( (array) $blogs as $blog ) {\n\t\t\tif ( $blog->userblog_id == $blog_id )\n\t\t\t\tcontinue;\n\t\t\t$new_id = $blog->userblog_id;\n\t\t\t$new_domain = $blog->domain;\n\t\t\tbreak;\n\t\t}\n\n\t\tupdate_user_meta($user_id, 'primary_blog', $new_id);\n\t\tupdate_user_meta($user_id, 'source_domain', $new_domain);\n\t}\n\n\t// wp_revoke_user($user_id);\n\t$user = get_userdata( $user_id );\n\tif ( ! $user ) {\n\t\trestore_current_blog();\n\t\treturn new WP_Error('user_does_not_exist', __('That user does not exist.'));\n\t}\n\n\t$user->remove_all_caps();\n\n\t$blogs = get_blogs_of_user($user_id);\n\tif ( count($blogs) == 0 ) {\n\t\tupdate_user_meta($user_id, 'primary_blog', '');\n\t\tupdate_user_meta($user_id, 'source_domain', '');\n\t}\n\n\tif ( $reassign != '' ) {\n\t\t$reassign = (int) $reassign;\n\t\t$post_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT ID FROM $wpdb->posts WHERE post_author = %d\", $user_id ) );\n\t\t$link_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT link_id FROM $wpdb->links WHERE link_owner = %d\", $user_id ) );\n\n\t\tif ( ! empty( $post_ids ) ) {\n\t\t\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET post_author = %d WHERE post_author = %d\", $reassign, $user_id ) );\n\t\t\tarray_walk( $post_ids, 'clean_post_cache' );\n\t\t}\n\n\t\tif ( ! empty( $link_ids ) ) {\n\t\t\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->links SET link_owner = %d WHERE link_owner = %d\", $reassign, $user_id ) );\n\t\t\tarray_walk( $link_ids, 'clean_bookmark_cache' );\n\t\t}\n\t}\n\n\trestore_current_blog();\n\n\treturn true;\n}\n\n/**\n * Get the permalink for a post on another blog.\n *\n * @since MU 1.0\n *\n * @param int $blog_id ID of the source blog.\n * @param int $post_id ID of the desired post.\n * @return string The post's permalink\n */\nfunction get_blog_permalink( $blog_id, $post_id ) {\n\tswitch_to_blog( $blog_id );\n\t$link = get_permalink( $post_id );\n\trestore_current_blog();\n\n\treturn $link;\n}\n\n/**\n * Get a blog's numeric ID from its URL.\n *\n * On a subdirectory installation like example.com/blog1/,\n * $domain will be the root 'example.com' and $path the\n * subdirectory '/blog1/'. With subdomains like blog1.example.com,\n * $domain is 'blog1.example.com' and $path is '/'.\n *\n * @since MU 2.6.5\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain\n * @param string $path   Optional. Not required for subdomain installations.\n * @return int 0 if no blog found, otherwise the ID of the matching blog\n */\nfunction get_blog_id_from_url( $domain, $path = '/' ) {\n\t$domain = strtolower( $domain );\n\t$path = strtolower( $path );\n\t$id = wp_cache_get( md5( $domain . $path ), 'blog-id-cache' );\n\n\tif ( $id == -1 ) // blog does not exist\n\t\treturn 0;\n\telseif ( $id )\n\t\treturn (int) $id;\n\n\t$args = array(\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'fields' => 'ids',\n\t);\n\t$result = get_sites( $args );\n\t$id = array_shift( $result );\n\n\tif ( ! $id ) {\n\t\twp_cache_set( md5( $domain . $path ), -1, 'blog-id-cache' );\n\t\treturn 0;\n\t}\n\n\twp_cache_set( md5( $domain . $path ), $id, 'blog-id-cache' );\n\n\treturn $id;\n}\n\n// Admin functions\n\n/**\n * Checks an email address against a list of banned domains.\n *\n * This function checks against the Banned Email Domains list\n * at wp-admin/network/settings.php. The check is only run on\n * self-registrations; user creation at wp-admin/network/users.php\n * bypasses this check.\n *\n * @since MU\n *\n * @param string $user_email The email provided by the user at registration.\n * @return bool Returns true when the email address is banned.\n */\nfunction is_email_address_unsafe( $user_email ) {\n\t$banned_names = get_site_option( 'banned_email_domains' );\n\tif ( $banned_names && ! is_array( $banned_names ) )\n\t\t$banned_names = explode( \"\\n\", $banned_names );\n\n\t$is_email_address_unsafe = false;\n\n\tif ( $banned_names && is_array( $banned_names ) ) {\n\t\t$banned_names = array_map( 'strtolower', $banned_names );\n\t\t$normalized_email = strtolower( $user_email );\n\n\t\tlist( $email_local_part, $email_domain ) = explode( '@', $normalized_email );\n\n\t\tforeach ( $banned_names as $banned_domain ) {\n\t\t\tif ( ! $banned_domain )\n\t\t\t\tcontinue;\n\n\t\t\tif ( $email_domain == $banned_domain ) {\n\t\t\t\t$is_email_address_unsafe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$dotted_domain = \".$banned_domain\";\n\t\t\tif ( $dotted_domain === substr( $normalized_email, -strlen( $dotted_domain ) ) ) {\n\t\t\t\t$is_email_address_unsafe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters whether an email address is unsafe.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param bool   $is_email_address_unsafe Whether the email address is \"unsafe\". Default false.\n\t * @param string $user_email              User email address.\n\t */\n\treturn apply_filters( 'is_email_address_unsafe', $is_email_address_unsafe, $user_email );\n}\n\n/**\n * Sanitize and validate data required for a user sign-up.\n *\n * Verifies the validity and uniqueness of user names and user email addresses,\n * and checks email addresses against admin-provided domain whitelists and blacklists.\n *\n * The {@see 'wpmu_validate_user_signup'} hook provides an easy way to modify the sign-up\n * process. The value $result, which is passed to the hook, contains both the user-provided\n * info and the error messages created by the function. {@see 'wpmu_validate_user_signup'}\n * allows you to process the data in any way you'd like, and unset the relevant errors if\n * necessary.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $user_name  The login name provided by the user.\n * @param string $user_email The email provided by the user.\n * @return array Contains username, email, and error messages.\n */\nfunction wpmu_validate_user_signup($user_name, $user_email) {\n\tglobal $wpdb;\n\n\t$errors = new WP_Error();\n\n\t$orig_username = $user_name;\n\t$user_name = preg_replace( '/\\s+/', '', sanitize_user( $user_name, true ) );\n\n\tif ( $user_name != $orig_username || preg_match( '/[^a-z0-9]/', $user_name ) ) {\n\t\t$errors->add( 'user_name', __( 'Usernames can only contain lowercase letters (a-z) and numbers.' ) );\n\t\t$user_name = $orig_username;\n\t}\n\n\t$user_email = sanitize_email( $user_email );\n\n\tif ( empty( $user_name ) )\n\t   \t$errors->add('user_name', __( 'Please enter a username.' ) );\n\n\t$illegal_names = get_site_option( 'illegal_names' );\n\tif ( ! is_array( $illegal_names ) ) {\n\t\t$illegal_names = array(  'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );\n\t\tadd_site_option( 'illegal_names', $illegal_names );\n\t}\n\tif ( in_array( $user_name, $illegal_names ) ) {\n\t\t$errors->add( 'user_name',  __( 'Sorry, that username is not allowed.' ) );\n\t}\n\n\t/** This filter is documented in wp-includes/user.php */\n\t$illegal_logins = (array) apply_filters( 'illegal_user_logins', array() );\n\n\tif ( in_array( strtolower( $user_name ), array_map( 'strtolower', $illegal_logins ) ) ) {\n\t\t$errors->add( 'user_name',  __( 'Sorry, that username is not allowed.' ) );\n\t}\n\n\tif ( is_email_address_unsafe( $user_email ) )\n\t\t$errors->add('user_email',  __('You cannot use that email address to signup. We are having problems with them blocking some of our email. Please use another email provider.'));\n\n\tif ( strlen( $user_name ) < 4 )\n\t\t$errors->add('user_name',  __( 'Username must be at least 4 characters.' ) );\n\n\tif ( strlen( $user_name ) > 60 ) {\n\t\t$errors->add( 'user_name', __( 'Username may not be longer than 60 characters.' ) );\n\t}\n\n\t// all numeric?\n\tif ( preg_match( '/^[0-9]*$/', $user_name ) )\n\t\t$errors->add('user_name', __('Sorry, usernames must have letters too!'));\n\n\tif ( !is_email( $user_email ) )\n\t\t$errors->add('user_email', __( 'Please enter a valid email address.' ) );\n\n\t$limited_email_domains = get_site_option( 'limited_email_domains' );\n\tif ( is_array( $limited_email_domains ) && ! empty( $limited_email_domains ) ) {\n\t\t$emaildomain = substr( $user_email, 1 + strpos( $user_email, '@' ) );\n\t\tif ( ! in_array( $emaildomain, $limited_email_domains ) ) {\n\t\t\t$errors->add('user_email', __('Sorry, that email address is not allowed!'));\n\t\t}\n\t}\n\n\t// Check if the username has been used already.\n\tif ( username_exists($user_name) )\n\t\t$errors->add( 'user_name', __( 'Sorry, that username already exists!' ) );\n\n\t// Check if the email address has been used already.\n\tif ( email_exists($user_email) )\n\t\t$errors->add( 'user_email', __( 'Sorry, that email address is already used!' ) );\n\n\t// Has someone already signed up for this username?\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE user_login = %s\", $user_name) );\n\tif ( $signup != null ) {\n\t\t$registered_at =  mysql2date('U', $signup->registered);\n\t\t$now = current_time( 'timestamp', true );\n\t\t$diff = $now - $registered_at;\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'user_login' => $user_name ) );\n\t\telse\n\t\t\t$errors->add('user_name', __('That username is currently reserved but may be available in a couple of days.'));\n\t}\n\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE user_email = %s\", $user_email) );\n\tif ( $signup != null ) {\n\t\t$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'user_email' => $user_email ) );\n\t\telse\n\t\t\t$errors->add('user_email', __('That email address has already been used. Please check your inbox for an activation email. It will become available in a couple of days if you do nothing.'));\n\t}\n\n\t$result = array('user_name' => $user_name, 'orig_username' => $orig_username, 'user_email' => $user_email, 'errors' => $errors);\n\n\t/**\n\t * Filters the validated user registration details.\n\t *\n\t * This does not allow you to override the username or email of the user during\n\t * registration. The values are solely used for validation and error handling.\n\t *\n\t * @since MU\n\t *\n\t * @param array $result {\n\t *     The array of user name, email and the error messages.\n\t *\n\t *     @type string   $user_name     Sanitized and unique username.\n\t *     @type string   $orig_username Original username.\n\t *     @type string   $user_email    User email address.\n\t *     @type WP_Error $errors        WP_Error object containing any errors found.\n\t * }\n\t */\n\treturn apply_filters( 'wpmu_validate_user_signup', $result );\n}\n\n/**\n * Processes new site registrations.\n *\n * Checks the data provided by the user during blog signup. Verifies\n * the validity and uniqueness of blog paths and domains.\n *\n * This function prevents the current user from registering a new site\n * with a blogname equivalent to another user's login name. Passing the\n * $user parameter to the function, where $user is the other user, is\n * effectively an override of this limitation.\n *\n * Filter {@see 'wpmu_validate_blog_signup'} if you want to modify\n * the way that WordPress validates new site signups.\n *\n * @since MU\n *\n * @global wpdb   $wpdb\n * @global string $domain\n *\n * @param string         $blogname   The blog name provided by the user. Must be unique.\n * @param string         $blog_title The blog title provided by the user.\n * @param WP_User|string $user       Optional. The user object to check against the new site name.\n * @return array Contains the new site data and error messages.\n */\nfunction wpmu_validate_blog_signup( $blogname, $blog_title, $user = '' ) {\n\tglobal $wpdb, $domain;\n\n\t$current_network = get_network();\n\t$base = $current_network->path;\n\n\t$blog_title = strip_tags( $blog_title );\n\n\t$errors = new WP_Error();\n\t$illegal_names = get_site_option( 'illegal_names' );\n\tif ( $illegal_names == false ) {\n\t\t$illegal_names = array( 'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );\n\t\tadd_site_option( 'illegal_names', $illegal_names );\n\t}\n\n\t/*\n\t * On sub dir installs, some names are so illegal, only a filter can\n\t * spring them from jail.\n\t */\n\tif ( ! is_subdomain_install() ) {\n\t\t$illegal_names = array_merge( $illegal_names, get_subdirectory_reserved_names() );\n\t}\n\n\tif ( empty( $blogname ) )\n\t\t$errors->add('blogname', __( 'Please enter a site name.' ) );\n\n\tif ( preg_match( '/[^a-z0-9]+/', $blogname ) ) {\n\t\t$errors->add( 'blogname', __( 'Site names can only contain lowercase letters (a-z) and numbers.' ) );\n\t}\n\n\tif ( in_array( $blogname, $illegal_names ) )\n\t\t$errors->add('blogname',  __( 'That name is not allowed.' ) );\n\n\tif ( strlen( $blogname ) < 4 && !is_super_admin() )\n\t\t$errors->add('blogname',  __( 'Site name must be at least 4 characters.' ) );\n\n\t// do not allow users to create a blog that conflicts with a page on the main blog.\n\tif ( !is_subdomain_install() && $wpdb->get_var( $wpdb->prepare( \"SELECT post_name FROM \" . $wpdb->get_blog_prefix( $current_network->site_id ) . \"posts WHERE post_type = 'page' AND post_name = %s\", $blogname ) ) )\n\t\t$errors->add( 'blogname', __( 'Sorry, you may not use that site name.' ) );\n\n\t// all numeric?\n\tif ( preg_match( '/^[0-9]*$/', $blogname ) )\n\t\t$errors->add('blogname', __('Sorry, site names must have letters too!'));\n\n\t/**\n\t * Filters the new site name during registration.\n\t *\n\t * The name is the site's subdomain or the site's subdirectory\n\t * path depending on the network settings.\n\t *\n\t * @since MU\n\t *\n\t * @param string $blogname Site name.\n\t */\n\t$blogname = apply_filters( 'newblogname', $blogname );\n\n\t$blog_title = wp_unslash(  $blog_title );\n\n\tif ( empty( $blog_title ) )\n\t\t$errors->add('blog_title', __( 'Please enter a site title.' ) );\n\n\t// Check if the domain/path has been used already.\n\tif ( is_subdomain_install() ) {\n\t\t$mydomain = $blogname . '.' . preg_replace( '|^www\\.|', '', $domain );\n\t\t$path = $base;\n\t} else {\n\t\t$mydomain = \"$domain\";\n\t\t$path = $base.$blogname.'/';\n\t}\n\tif ( domain_exists($mydomain, $path, $current_network->id) )\n\t\t$errors->add( 'blogname', __( 'Sorry, that site already exists!' ) );\n\n\tif ( username_exists( $blogname ) ) {\n\t\tif ( ! is_object( $user ) || ( is_object($user) && ( $user->user_login != $blogname ) ) )\n\t\t\t$errors->add( 'blogname', __( 'Sorry, that site is reserved!' ) );\n\t}\n\n\t// Has someone already signed up for this domain?\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE domain = %s AND path = %s\", $mydomain, $path) ); // TODO: Check email too?\n\tif ( ! empty($signup) ) {\n\t\t$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);\n\t\t// If registered more than two days ago, cancel registration and let this signup go through.\n\t\tif ( $diff > 2 * DAY_IN_SECONDS )\n\t\t\t$wpdb->delete( $wpdb->signups, array( 'domain' => $mydomain , 'path' => $path ) );\n\t\telse\n\t\t\t$errors->add('blogname', __('That site is currently reserved but may be available in a couple days.'));\n\t}\n\n\t$result = array('domain' => $mydomain, 'path' => $path, 'blogname' => $blogname, 'blog_title' => $blog_title, 'user' => $user, 'errors' => $errors);\n\n\t/**\n\t * Filters site details and error messages following registration.\n\t *\n\t * @since MU\n\t *\n\t * @param array $result {\n\t *     Array of domain, path, blog name, blog title, user and error messages.\n\t *\n\t *     @type string         $domain     Domain for the site.\n\t *     @type string         $path       Path for the site. Used in subdirectory installs.\n\t *     @type string         $blogname   The unique site name (slug).\n\t *     @type string         $blog_title Blog title.\n\t *     @type string|WP_User $user       By default, an empty string. A user object if provided.\n\t *     @type WP_Error       $errors     WP_Error containing any errors found.\n\t * }\n\t */\n\treturn apply_filters( 'wpmu_validate_blog_signup', $result );\n}\n\n/**\n * Record site signup information for future activation.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain     The requested domain.\n * @param string $path       The requested path.\n * @param string $title      The requested site title.\n * @param string $user       The user's requested login name.\n * @param string $user_email The user's email address.\n * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n */\nfunction wpmu_signup_blog( $domain, $path, $title, $user, $user_email, $meta = array() )  {\n\tglobal $wpdb;\n\n\t$key = substr( md5( time() . wp_rand() . $domain ), 0, 16 );\n\t$meta = serialize($meta);\n\n\t$wpdb->insert( $wpdb->signups, array(\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'title' => $title,\n\t\t'user_login' => $user,\n\t\t'user_email' => $user_email,\n\t\t'registered' => current_time('mysql', true),\n\t\t'activation_key' => $key,\n\t\t'meta' => $meta\n\t) );\n\n\t/**\n\t * Fires after site signup information has been written to the database.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $domain     The requested domain.\n\t * @param string $path       The requested path.\n\t * @param string $title      The requested site title.\n\t * @param string $user       The user's requested login name.\n\t * @param string $user_email The user's email address.\n\t * @param string $key        The user's activation key\n\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t */\n\tdo_action( 'after_signup_site', $domain, $path, $title, $user, $user_email, $key, $meta );\n}\n\n/**\n * Record user signup information for future activation.\n *\n * This function is used when user registration is open but\n * new site registration is not.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $user       The user's requested login name.\n * @param string $user_email The user's email address.\n * @param array  $meta       By default, this is an empty array.\n */\nfunction wpmu_signup_user( $user, $user_email, $meta = array() ) {\n\tglobal $wpdb;\n\n\t// Format data\n\t$user = preg_replace( '/\\s+/', '', sanitize_user( $user, true ) );\n\t$user_email = sanitize_email( $user_email );\n\t$key = substr( md5( time() . wp_rand() . $user_email ), 0, 16 );\n\t$meta = serialize($meta);\n\n\t$wpdb->insert( $wpdb->signups, array(\n\t\t'domain' => '',\n\t\t'path' => '',\n\t\t'title' => '',\n\t\t'user_login' => $user,\n\t\t'user_email' => $user_email,\n\t\t'registered' => current_time('mysql', true),\n\t\t'activation_key' => $key,\n\t\t'meta' => $meta\n\t) );\n\n\t/**\n\t * Fires after a user's signup information has been written to the database.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $user       The user's requested login name.\n\t * @param string $user_email The user's email address.\n\t * @param string $key        The user's activation key\n\t * @param array  $meta       Additional signup meta. By default, this is an empty array.\n\t */\n\tdo_action( 'after_signup_user', $user, $user_email, $key, $meta );\n}\n\n/**\n * Notify user of signup success.\n *\n * This is the notification function used when site registration\n * is enabled.\n *\n * Filter {@see 'wpmu_signup_blog_notification'} to bypass this function or\n * replace it with your own notification behavior.\n *\n * Filter {@see 'wpmu_signup_blog_notification_email'} and\n * {@see 'wpmu_signup_blog_notification_subject'} to change the content\n * and subject line of the email sent to newly registered users.\n *\n * @since MU\n *\n * @param string $domain     The new blog domain.\n * @param string $path       The new blog path.\n * @param string $title      The site title.\n * @param string $user_login The user's login name.\n * @param string $user_email The user's email address.\n * @param string $key        The activation key created in wpmu_signup_blog()\n * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n * @return bool\n */\nfunction wpmu_signup_blog_notification( $domain, $path, $title, $user_login, $user_email, $key, $meta = array() ) {\n\t/**\n\t * Filters whether to bypass the new site email notification.\n\t *\n\t * @since MU\n\t *\n\t * @param string|bool $domain     Site domain.\n\t * @param string      $path       Site path.\n\t * @param string      $title      Site title.\n\t * @param string      $user_login User login name.\n\t * @param string      $user_email User email address.\n\t * @param string      $key        Activation key created in wpmu_signup_blog().\n\t * @param array       $meta       By default, contains the requested privacy setting and lang_id.\n\t */\n\tif ( ! apply_filters( 'wpmu_signup_blog_notification', $domain, $path, $title, $user_login, $user_email, $key, $meta ) ) {\n\t\treturn false;\n\t}\n\n\t// Send email with activation link.\n\tif ( !is_subdomain_install() || get_current_network_id() != 1 )\n\t\t$activate_url = network_site_url(\"wp-activate.php?key=$key\");\n\telse\n\t\t$activate_url = \"http://{$domain}{$path}wp-activate.php?key=$key\"; // @todo use *_url() API\n\n\t$activate_url = esc_url($activate_url);\n\t$admin_email = get_site_option( 'admin_email' );\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\n\t$user = get_user_by( 'login', $user_login );\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t$message = sprintf(\n\t\t/**\n\t\t * Filters the message content of the new blog notification email.\n\t\t *\n\t\t * Content should be formatted for transmission via wp_mail().\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $content    Content of the notification email.\n\t\t * @param string $domain     Site domain.\n\t\t * @param string $path       Site path.\n\t\t * @param string $title      Site title.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_blog().\n\t\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_blog_notification_email',\n\t\t\t__( \"To activate your blog, please click the following link:\\n\\n%s\\n\\nAfter you activate, you will receive *another email* with your login.\\n\\nAfter you activate, you can visit your site here:\\n\\n%s\" ),\n\t\t\t$domain, $path, $title, $user_login, $user_email, $key, $meta\n\t\t),\n\t\t$activate_url,\n\t\tesc_url( \"http://{$domain}{$path}\" ),\n\t\t$key\n\t);\n\t// TODO: Don't hard code activation link.\n\t$subject = sprintf(\n\t\t/**\n\t\t * Filters the subject of the new blog notification email.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $subject    Subject of the notification email.\n\t\t * @param string $domain     Site domain.\n\t\t * @param string $path       Site path.\n\t\t * @param string $title      Site title.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_blog().\n\t\t * @param array  $meta       By default, contains the requested privacy setting and lang_id.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_blog_notification_subject',\n\t\t\t/* translators: New site notification email subject. 1: Network name, 2: New site URL */\n\t\t\t_x( '[%1$s] Activate %2$s', 'New site notification email subject' ),\n\t\t\t$domain, $path, $title, $user_login, $user_email, $key, $meta\n\t\t),\n\t\t$from_name,\n\t\tesc_url( 'http://' . $domain . $path )\n\t);\n\twp_mail( $user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Notify user of signup success.\n *\n * This is the notification function used when no new site has\n * been requested.\n *\n * Filter {@see 'wpmu_signup_user_notification'} to bypass this function or\n * replace it with your own notification behavior.\n *\n * Filter {@see 'wpmu_signup_user_notification_email'} and\n * {@see 'wpmu_signup_user_notification_subject'} to change the content\n * and subject line of the email sent to newly registered users.\n *\n * @since MU\n *\n * @param string $user_login The user's login name.\n * @param string $user_email The user's email address.\n * @param string $key        The activation key created in wpmu_signup_user()\n * @param array  $meta       By default, an empty array.\n * @return bool\n */\nfunction wpmu_signup_user_notification( $user_login, $user_email, $key, $meta = array() ) {\n\t/**\n\t * Filters whether to bypass the email notification for new user sign-up.\n\t *\n\t * @since MU\n\t *\n\t * @param string $user_login User login name.\n\t * @param string $user_email User email address.\n\t * @param string $key        Activation key created in wpmu_signup_user().\n\t * @param array  $meta       Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_signup_user_notification', $user_login, $user_email, $key, $meta ) )\n\t\treturn false;\n\n\t$user = get_user_by( 'login', $user_login );\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t// Send email with activation link.\n\t$admin_email = get_site_option( 'admin_email' );\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = sprintf(\n\t\t/**\n\t\t * Filters the content of the notification email for new user sign-up.\n\t\t *\n\t\t * Content should be formatted for transmission via wp_mail().\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $content    Content of the notification email.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_user().\n\t\t * @param array  $meta       Signup meta data.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_user_notification_email',\n\t\t\t__( \"To activate your user, please click the following link:\\n\\n%s\\n\\nAfter you activate, you will receive *another email* with your login.\" ),\n\t\t\t$user_login, $user_email, $key, $meta\n\t\t),\n\t\tsite_url( \"wp-activate.php?key=$key\" )\n\t);\n\t// TODO: Don't hard code activation link.\n\t$subject = sprintf(\n\t\t/**\n\t\t * Filters the subject of the notification email of new user signup.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param string $subject    Subject of the notification email.\n\t\t * @param string $user_login User login name.\n\t\t * @param string $user_email User email address.\n\t\t * @param string $key        Activation key created in wpmu_signup_user().\n\t\t * @param array  $meta       Signup meta data.\n\t\t */\n\t\tapply_filters( 'wpmu_signup_user_notification_subject',\n\t\t\t/* translators: New user notification email subject. 1: Network name, 2: New user login */\n\t\t\t_x( '[%1$s] Activate %2$s', 'New user notification email subject' ),\n\t\t\t$user_login, $user_email, $key, $meta\n\t\t),\n\t\t$from_name,\n\t\t$user_login\n\t);\n\twp_mail( $user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Activate a signup.\n *\n * Hook to {@see 'wpmu_activate_user'} or {@see 'wpmu_activate_blog'} for events\n * that should happen only when users or sites are self-created (since\n * those actions are not called when users and sites are created\n * by a Super Admin).\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $key The activation key provided to the user.\n * @return array|WP_Error An array containing information about the activated user and/or blog\n */\nfunction wpmu_activate_signup($key) {\n\tglobal $wpdb;\n\n\t$signup = $wpdb->get_row( $wpdb->prepare(\"SELECT * FROM $wpdb->signups WHERE activation_key = %s\", $key) );\n\n\tif ( empty( $signup ) )\n\t\treturn new WP_Error( 'invalid_key', __( 'Invalid activation key.' ) );\n\n\tif ( $signup->active ) {\n\t\tif ( empty( $signup->domain ) )\n\t\t\treturn new WP_Error( 'already_active', __( 'The user is already active.' ), $signup );\n\t\telse\n\t\t\treturn new WP_Error( 'already_active', __( 'The site is already active.' ), $signup );\n\t}\n\n\t$meta = maybe_unserialize($signup->meta);\n\t$password = wp_generate_password( 12, false );\n\n\t$user_id = username_exists($signup->user_login);\n\n\tif ( ! $user_id )\n\t\t$user_id = wpmu_create_user($signup->user_login, $password, $signup->user_email);\n\telse\n\t\t$user_already_exists = true;\n\n\tif ( ! $user_id )\n\t\treturn new WP_Error('create_user', __('Could not create user'), $signup);\n\n\t$now = current_time('mysql', true);\n\n\tif ( empty($signup->domain) ) {\n\t\t$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );\n\n\t\tif ( isset( $user_already_exists ) )\n\t\t\treturn new WP_Error( 'user_already_exists', __( 'That username is already activated.' ), $signup);\n\n\t\t/**\n\t\t * Fires immediately after a new user is activated.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param int   $user_id  User ID.\n\t\t * @param int   $password User password.\n\t\t * @param array $meta     Signup meta data.\n\t\t */\n\t\tdo_action( 'wpmu_activate_user', $user_id, $password, $meta );\n\t\treturn array( 'user_id' => $user_id, 'password' => $password, 'meta' => $meta );\n\t}\n\n\t$blog_id = wpmu_create_blog( $signup->domain, $signup->path, $signup->title, $user_id, $meta, $wpdb->siteid );\n\n\t// TODO: What to do if we create a user but cannot create a blog?\n\tif ( is_wp_error($blog_id) ) {\n\t\t// If blog is taken, that means a previous attempt to activate this blog failed in between creating the blog and\n\t\t// setting the activation flag. Let's just set the active flag and instruct the user to reset their password.\n\t\tif ( 'blog_taken' == $blog_id->get_error_code() ) {\n\t\t\t$blog_id->add_data( $signup );\n\t\t\t$wpdb->update( $wpdb->signups, array( 'active' => 1, 'activated' => $now ), array( 'activation_key' => $key ) );\n\t\t}\n\t\treturn $blog_id;\n\t}\n\n\t$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );\n\t/**\n\t * Fires immediately after a site is activated.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $blog_id       Blog ID.\n\t * @param int    $user_id       User ID.\n\t * @param int    $password      User password.\n\t * @param string $signup_title  Site title.\n\t * @param array  $meta          Signup meta data.\n\t */\n\tdo_action( 'wpmu_activate_blog', $blog_id, $user_id, $password, $signup->title, $meta );\n\n\treturn array('blog_id' => $blog_id, 'user_id' => $user_id, 'password' => $password, 'title' => $signup->title, 'meta' => $meta);\n}\n\n/**\n * Create a user.\n *\n * This function runs when a user self-registers as well as when\n * a Super Admin creates a new user. Hook to {@see 'wpmu_new_user'} for events\n * that should affect all new users, but only on Multisite (otherwise\n * use {@see'user_register'}).\n *\n * @since MU\n *\n * @param string $user_name The new user's login name.\n * @param string $password  The new user's password.\n * @param string $email     The new user's email address.\n * @return int|false Returns false on failure, or int $user_id on success\n */\nfunction wpmu_create_user( $user_name, $password, $email ) {\n\t$user_name = preg_replace( '/\\s+/', '', sanitize_user( $user_name, true ) );\n\n\t$user_id = wp_create_user( $user_name, $password, $email );\n\tif ( is_wp_error( $user_id ) )\n\t\treturn false;\n\n\t// Newly created users have no roles or caps until they are added to a blog.\n\tdelete_user_option( $user_id, 'capabilities' );\n\tdelete_user_option( $user_id, 'user_level' );\n\n\t/**\n\t * Fires immediately after a new user is created.\n\t *\n\t * @since MU\n\t *\n\t * @param int $user_id User ID.\n\t */\n\tdo_action( 'wpmu_new_user', $user_id );\n\n\treturn $user_id;\n}\n\n/**\n * Create a site.\n *\n * This function runs when a user self-registers a new site as well\n * as when a Super Admin creates a new site. Hook to {@see 'wpmu_new_blog'}\n * for events that should affect all new sites.\n *\n * On subdirectory installs, $domain is the same as the main site's\n * domain, and the path is the subdirectory name (eg 'example.com'\n * and '/blog1/'). On subdomain installs, $domain is the new subdomain +\n * root domain (eg 'blog1.example.com'), and $path is '/'.\n *\n * @since MU\n *\n * @param string $domain  The new site's domain.\n * @param string $path    The new site's path.\n * @param string $title   The new site's title.\n * @param int    $user_id The user ID of the new site's admin.\n * @param array  $meta    Optional. Used to set initial site options.\n * @param int    $site_id Optional. Only relevant on multi-network installs.\n * @return int|WP_Error Returns WP_Error object on failure, int $blog_id on success\n */\nfunction wpmu_create_blog( $domain, $path, $title, $user_id, $meta = array(), $site_id = 1 ) {\n\t$defaults = array(\n\t\t'public' => 0,\n\t\t'WPLANG' => get_site_option( 'WPLANG' ),\n\t);\n\t$meta = wp_parse_args( $meta, $defaults );\n\n\t$domain = preg_replace( '/\\s+/', '', sanitize_user( $domain, true ) );\n\n\tif ( is_subdomain_install() )\n\t\t$domain = str_replace( '@', '', $domain );\n\n\t$title = strip_tags( $title );\n\t$user_id = (int) $user_id;\n\n\tif ( empty($path) )\n\t\t$path = '/';\n\n\t// Check if the domain has been used already. We should return an error message.\n\tif ( domain_exists($domain, $path, $site_id) )\n\t\treturn new WP_Error( 'blog_taken', __( 'Sorry, that site already exists!' ) );\n\n\tif ( ! wp_installing() ) {\n\t\twp_installing( true );\n\t}\n\n\tif ( ! $blog_id = insert_blog($domain, $path, $site_id) )\n\t\treturn new WP_Error('insert_blog', __('Could not create site.'));\n\n\tswitch_to_blog($blog_id);\n\tinstall_blog($blog_id, $title);\n\twp_install_defaults($user_id);\n\n\tadd_user_to_blog($blog_id, $user_id, 'administrator');\n\n\tforeach ( $meta as $key => $value ) {\n\t\tif ( in_array( $key, array( 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id' ) ) )\n\t\t\tupdate_blog_status( $blog_id, $key, $value );\n\t\telse\n\t\t\tupdate_option( $key, $value );\n\t}\n\n\tupdate_option( 'blog_public', (int) $meta['public'] );\n\n\tif ( ! is_super_admin( $user_id ) && ! get_user_meta( $user_id, 'primary_blog', true ) )\n\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\n\trestore_current_blog();\n\t/**\n\t * Fires immediately after a new site is created.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $blog_id Blog ID.\n\t * @param int    $user_id User ID.\n\t * @param string $domain  Site domain.\n\t * @param string $path    Site path.\n\t * @param int    $site_id Site ID. Only relevant on multi-network installs.\n\t * @param array  $meta    Meta data. Used to set initial site options.\n\t */\n\tdo_action( 'wpmu_new_blog', $blog_id, $user_id, $domain, $path, $site_id, $meta );\n\n\twp_cache_set( 'last_changed', microtime(), 'sites' );\n\n\treturn $blog_id;\n}\n\n/**\n * Notifies the network admin that a new site has been activated.\n *\n * Filter {@see 'newblog_notify_siteadmin'} to change the content of\n * the notification email.\n *\n * @since MU\n *\n * @param int    $blog_id    The new site's ID.\n * @param string $deprecated Not used.\n * @return bool\n */\nfunction newblog_notify_siteadmin( $blog_id, $deprecated = '' ) {\n\tif ( get_site_option( 'registrationnotification' ) != 'yes' )\n\t\treturn false;\n\n\t$email = get_site_option( 'admin_email' );\n\tif ( is_email($email) == false )\n\t\treturn false;\n\n\t$options_site_url = esc_url(network_admin_url('settings.php'));\n\n\tswitch_to_blog( $blog_id );\n\t$blogname = get_option( 'blogname' );\n\t$siteurl = site_url();\n\trestore_current_blog();\n\n\t/* translators: New site notification email. 1: Site URL, 2: User IP address, 3: Settings screen URL */\n\t$msg = sprintf( __( 'New Site: %1$s\nURL: %2$s\nRemote IP: %3$s\n\nDisable these notifications: %4$s' ), $blogname, $siteurl, wp_unslash( $_SERVER['REMOTE_ADDR'] ), $options_site_url);\n\t/**\n\t * Filters the message body of the new site activation email sent\n\t * to the network administrator.\n\t *\n\t * @since MU\n\t *\n\t * @param string $msg Email body.\n\t */\n\t$msg = apply_filters( 'newblog_notify_siteadmin', $msg );\n\n\twp_mail( $email, sprintf( __( 'New Site Registration: %s' ), $siteurl ), $msg );\n\treturn true;\n}\n\n/**\n * Notifies the network admin that a new user has been activated.\n *\n * Filter {@see 'newuser_notify_siteadmin'} to change the content of\n * the notification email.\n *\n * @since MU\n *\n * @param int $user_id The new user's ID.\n * @return bool\n */\nfunction newuser_notify_siteadmin( $user_id ) {\n\tif ( get_site_option( 'registrationnotification' ) != 'yes' )\n\t\treturn false;\n\n\t$email = get_site_option( 'admin_email' );\n\n\tif ( is_email($email) == false )\n\t\treturn false;\n\n\t$user = get_userdata( $user_id );\n\n\t$options_site_url = esc_url(network_admin_url('settings.php'));\n\t/* translators: New user notification email. 1: User login, 2: User IP address, 3: Settings screen URL */\n\t$msg = sprintf(__('New User: %1$s\nRemote IP: %2$s\n\nDisable these notifications: %3$s'), $user->user_login, wp_unslash( $_SERVER['REMOTE_ADDR'] ), $options_site_url);\n\n\t/**\n\t * Filters the message body of the new user activation email sent\n\t * to the network administrator.\n\t *\n\t * @since MU\n\t *\n\t * @param string  $msg  Email body.\n\t * @param WP_User $user WP_User instance of the new user.\n\t */\n\t$msg = apply_filters( 'newuser_notify_siteadmin', $msg, $user );\n\twp_mail( $email, sprintf(__('New User Registration: %s'), $user->user_login), $msg );\n\treturn true;\n}\n\n/**\n * Check whether a blogname is already taken.\n *\n * Used during the new site registration process to ensure\n * that each blogname is unique.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain  The domain to be checked.\n * @param string $path    The path to be checked.\n * @param int    $site_id Optional. Relevant only on multi-network installs.\n * @return int\n */\nfunction domain_exists($domain, $path, $site_id = 1) {\n\t$path = trailingslashit( $path );\n\t$args = array(\n\t\t'network_id' => $site_id,\n\t\t'domain' => $domain,\n\t\t'path' => $path,\n\t\t'fields' => 'ids',\n\t);\n\t$result = get_sites( $args );\n\t$result = array_shift( $result );\n\n\t/**\n\t * Filters whether a blogname is taken.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param int|null $result  The blog_id if the blogname exists, null otherwise.\n\t * @param string   $domain  Domain to be checked.\n\t * @param string   $path    Path to be checked.\n\t * @param int      $site_id Site ID. Relevant only on multi-network installs.\n\t */\n\treturn apply_filters( 'domain_exists', $result, $domain, $path, $site_id );\n}\n\n/**\n * Store basic site info in the blogs table.\n *\n * This function creates a row in the wp_blogs table and returns\n * the new blog's ID. It is the first step in creating a new blog.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $domain  The domain of the new site.\n * @param string $path    The path of the new site.\n * @param int    $site_id Unless you're running a multi-network install, be sure to set this value to 1.\n * @return int|false The ID of the new row\n */\nfunction insert_blog($domain, $path, $site_id) {\n\tglobal $wpdb;\n\n\t$path = trailingslashit($path);\n\t$site_id = (int) $site_id;\n\n\t$result = $wpdb->insert( $wpdb->blogs, array('site_id' => $site_id, 'domain' => $domain, 'path' => $path, 'registered' => current_time('mysql')) );\n\tif ( ! $result )\n\t\treturn false;\n\n\t$blog_id = $wpdb->insert_id;\n\trefresh_blog_details( $blog_id );\n\n\twp_maybe_update_network_site_counts();\n\n\treturn $blog_id;\n}\n\n/**\n * Install an empty blog.\n *\n * Creates the new blog tables and options. If calling this function\n * directly, be sure to use switch_to_blog() first, so that $wpdb\n * points to the new blog.\n *\n * @since MU\n *\n * @global wpdb     $wpdb\n * @global WP_Roles $wp_roles\n *\n * @param int    $blog_id    The value returned by insert_blog().\n * @param string $blog_title The title of the new site.\n */\nfunction install_blog( $blog_id, $blog_title = '' ) {\n\tglobal $wpdb, $wp_roles;\n\n\t// Cast for security\n\t$blog_id = (int) $blog_id;\n\n\trequire_once( ABSPATH . 'wp-admin/includes/upgrade.php' );\n\n\t$suppress = $wpdb->suppress_errors();\n\tif ( $wpdb->get_results( \"DESCRIBE {$wpdb->posts}\" ) )\n\t\tdie( '<h1>' . __( 'Already Installed' ) . '</h1><p>' . __( 'You appear to have already installed WordPress. To reinstall please clear your old database tables first.' ) . '</p></body></html>' );\n\t$wpdb->suppress_errors( $suppress );\n\n\t$url = get_blogaddress_by_id( $blog_id );\n\n\t// Set everything up\n\tmake_db_current_silent( 'blog' );\n\tpopulate_options();\n\tpopulate_roles();\n\n\t// populate_roles() clears previous role definitions so we start over.\n\t$wp_roles = new WP_Roles();\n\n\t$siteurl = $home = untrailingslashit( $url );\n\n\tif ( ! is_subdomain_install() ) {\n\n \t\tif ( 'https' === parse_url( get_site_option( 'siteurl' ), PHP_URL_SCHEME ) ) {\n \t\t\t$siteurl = set_url_scheme( $siteurl, 'https' );\n \t\t}\n \t\tif ( 'https' === parse_url( get_home_url( get_network()->site_id ), PHP_URL_SCHEME ) ) {\n \t\t\t$home = set_url_scheme( $home, 'https' );\n \t\t}\n\n\t}\n\n\tupdate_option( 'siteurl', $siteurl );\n\tupdate_option( 'home', $home );\n\n\tif ( get_site_option( 'ms_files_rewriting' ) )\n\t\tupdate_option( 'upload_path', UPLOADBLOGSDIR . \"/$blog_id/files\" );\n\telse\n\t\tupdate_option( 'upload_path', get_blog_option( get_network()->site_id, 'upload_path' ) );\n\n\tupdate_option( 'blogname', wp_unslash( $blog_title ) );\n\tupdate_option( 'admin_email', '' );\n\n\t// remove all perms\n\t$table_prefix = $wpdb->get_blog_prefix();\n\tdelete_metadata( 'user', 0, $table_prefix . 'user_level',   null, true ); // delete all\n\tdelete_metadata( 'user', 0, $table_prefix . 'capabilities', null, true ); // delete all\n}\n\n/**\n * Set blog defaults.\n *\n * This function creates a row in the wp_blogs table.\n *\n * @since MU\n * @deprecated MU\n * @deprecated Use wp_install_defaults()\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $blog_id Ignored in this function.\n * @param int $user_id\n */\nfunction install_blog_defaults($blog_id, $user_id) {\n\tglobal $wpdb;\n\n\trequire_once( ABSPATH . 'wp-admin/includes/upgrade.php' );\n\n\t$suppress = $wpdb->suppress_errors();\n\n\twp_install_defaults($user_id);\n\n\t$wpdb->suppress_errors( $suppress );\n}\n\n/**\n * Notify a user that their blog activation has been successful.\n *\n * Filter {@see 'wpmu_welcome_notification'} to disable or bypass.\n *\n * Filter {@see 'update_welcome_email'} and {@see 'update_welcome_subject'} to\n * modify the content and subject line of the notification email.\n *\n * @since MU\n *\n * @param int    $blog_id\n * @param int    $user_id\n * @param string $password\n * @param string $title    The new blog's title\n * @param array  $meta     Optional. Not used in the default function, but is passed along to hooks for customization.\n * @return bool\n */\nfunction wpmu_welcome_notification( $blog_id, $user_id, $password, $title, $meta = array() ) {\n\t$current_network = get_network();\n\n\t/**\n\t * Filters whether to bypass the welcome email after site activation.\n\t *\n\t * Returning false disables the welcome email.\n\t *\n\t * @since MU\n\t *\n\t * @param int|bool $blog_id  Blog ID.\n\t * @param int      $user_id  User ID.\n\t * @param string   $password User password.\n\t * @param string   $title    Site title.\n\t * @param array    $meta     Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_welcome_notification', $blog_id, $user_id, $password, $title, $meta ) )\n\t\treturn false;\n\n\t$user = get_userdata( $user_id );\n\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t$welcome_email = get_site_option( 'welcome_email' );\n\tif ( $welcome_email == false ) {\n\t\t/* translators: Do not translate USERNAME, SITE_NAME, BLOG_URL, PASSWORD: those are placeholders. */\n\t\t$welcome_email = __( 'Howdy USERNAME,\n\nYour new SITE_NAME site has been successfully set up at:\nBLOG_URL\n\nYou can log in to the administrator account with the following information:\n\nUsername: USERNAME\nPassword: PASSWORD\nLog in here: BLOG_URLwp-login.php\n\nWe hope you enjoy your new site. Thanks!\n\n--The Team @ SITE_NAME' );\n\t}\n\n\t$url = get_blogaddress_by_id($blog_id);\n\n\t$welcome_email = str_replace( 'SITE_NAME', $current_network->site_name, $welcome_email );\n\t$welcome_email = str_replace( 'BLOG_TITLE', $title, $welcome_email );\n\t$welcome_email = str_replace( 'BLOG_URL', $url, $welcome_email );\n\t$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );\n\t$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );\n\n\t/**\n\t * Filters the content of the welcome email after site activation.\n\t *\n\t * Content should be formatted for transmission via wp_mail().\n\t *\n\t * @since MU\n\t *\n\t * @param string $welcome_email Message body of the email.\n\t * @param int    $blog_id       Blog ID.\n\t * @param int    $user_id       User ID.\n\t * @param string $password      User password.\n\t * @param string $title         Site title.\n\t * @param array  $meta          Signup meta data.\n\t */\n\t$welcome_email = apply_filters( 'update_welcome_email', $welcome_email, $blog_id, $user_id, $password, $title, $meta );\n\t$admin_email = get_site_option( 'admin_email' );\n\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = $welcome_email;\n\n\tif ( empty( $current_network->site_name ) )\n\t\t$current_network->site_name = 'WordPress';\n\n\t/* translators: New site notification email subject. 1: Network name, 2: New site name */\n\t$subject = __( 'New %1$s Site: %2$s' );\n\n\t/**\n\t * Filters the subject of the welcome email after site activation.\n\t *\n\t * @since MU\n\t *\n\t * @param string $subject Subject of the email.\n\t */\n\t$subject = apply_filters( 'update_welcome_subject', sprintf( $subject, $current_network->site_name, wp_unslash( $title ) ) );\n\twp_mail( $user->user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Notify a user that their account activation has been successful.\n *\n * Filter {@see 'wpmu_welcome_user_notification'} to disable or bypass.\n *\n * Filter {@see 'update_welcome_user_email'} and {@see 'update_welcome_user_subject'} to\n * modify the content and subject line of the notification email.\n *\n * @since MU\n *\n * @param int    $user_id\n * @param string $password\n * @param array  $meta     Optional. Not used in the default function, but is passed along to hooks for customization.\n * @return bool\n */\nfunction wpmu_welcome_user_notification( $user_id, $password, $meta = array() ) {\n\t$current_network = get_network();\n\n\t/**\n \t * Filters whether to bypass the welcome email after user activation.\n\t *\n\t * Returning false disables the welcome email.\n\t *\n\t * @since MU\n\t *\n\t * @param int    $user_id  User ID.\n\t * @param string $password User password.\n\t * @param array  $meta     Signup meta data.\n\t */\n\tif ( ! apply_filters( 'wpmu_welcome_user_notification', $user_id, $password, $meta ) )\n\t\treturn false;\n\n\t$welcome_email = get_site_option( 'welcome_user_email' );\n\n\t$user = get_userdata( $user_id );\n\n\t$switched_locale = switch_to_locale( get_user_locale( $user ) );\n\n\t/**\n\t * Filters the content of the welcome email after user activation.\n\t *\n\t * Content should be formatted for transmission via wp_mail().\n\t *\n\t * @since MU\n\t *\n\t * @param string $welcome_email The message body of the account activation success email.\n\t * @param int    $user_id       User ID.\n\t * @param string $password      User password.\n\t * @param array  $meta          Signup meta data.\n\t */\n\t$welcome_email = apply_filters( 'update_welcome_user_email', $welcome_email, $user_id, $password, $meta );\n\t$welcome_email = str_replace( 'SITE_NAME', $current_network->site_name, $welcome_email );\n\t$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );\n\t$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );\n\t$welcome_email = str_replace( 'LOGINLINK', wp_login_url(), $welcome_email );\n\n\t$admin_email = get_site_option( 'admin_email' );\n\n\tif ( $admin_email == '' )\n\t\t$admin_email = 'support@' . $_SERVER['SERVER_NAME'];\n\n\t$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );\n\t$message_headers = \"From: \\\"{$from_name}\\\" <{$admin_email}>\\n\" . \"Content-Type: text/plain; charset=\\\"\" . get_option('blog_charset') . \"\\\"\\n\";\n\t$message = $welcome_email;\n\n\tif ( empty( $current_network->site_name ) )\n\t\t$current_network->site_name = 'WordPress';\n\n\t/* translators: New user notification email subject. 1: Network name, 2: New user login */\n\t$subject = __( 'New %1$s User: %2$s' );\n\n\t/**\n\t * Filters the subject of the welcome email after user activation.\n\t *\n\t * @since MU\n\t *\n\t * @param string $subject Subject of the email.\n\t */\n\t$subject = apply_filters( 'update_welcome_user_subject', sprintf( $subject, $current_network->site_name, $user->user_login) );\n\twp_mail( $user->user_email, wp_specialchars_decode( $subject ), $message, $message_headers );\n\n\tif ( $switched_locale ) {\n\t\trestore_previous_locale();\n\t}\n\n\treturn true;\n}\n\n/**\n * Get the current network.\n *\n * Returns an object containing the 'id', 'domain', 'path', and 'site_name'\n * properties of the network being viewed.\n *\n * @see wpmu_current_site()\n *\n * @since MU\n *\n * @global WP_Network $current_site\n *\n * @return WP_Network\n */\nfunction get_current_site() {\n\tglobal $current_site;\n\treturn $current_site;\n}\n\n/**\n * Get a user's most recent post.\n *\n * Walks through each of a user's blogs to find the post with\n * the most recent post_date_gmt.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $user_id\n * @return array Contains the blog_id, post_id, post_date_gmt, and post_gmt_ts\n */\nfunction get_most_recent_post_of_user( $user_id ) {\n\tglobal $wpdb;\n\n\t$user_blogs = get_blogs_of_user( (int) $user_id );\n\t$most_recent_post = array();\n\n\t// Walk through each blog and get the most recent post\n\t// published by $user_id\n\tforeach ( (array) $user_blogs as $blog ) {\n\t\t$prefix = $wpdb->get_blog_prefix( $blog->userblog_id );\n\t\t$recent_post = $wpdb->get_row( $wpdb->prepare(\"SELECT ID, post_date_gmt FROM {$prefix}posts WHERE post_author = %d AND post_type = 'post' AND post_status = 'publish' ORDER BY post_date_gmt DESC LIMIT 1\", $user_id ), ARRAY_A);\n\n\t\t// Make sure we found a post\n\t\tif ( isset($recent_post['ID']) ) {\n\t\t\t$post_gmt_ts = strtotime($recent_post['post_date_gmt']);\n\n\t\t\t// If this is the first post checked or if this post is\n\t\t\t// newer than the current recent post, make it the new\n\t\t\t// most recent post.\n\t\t\tif ( !isset($most_recent_post['post_gmt_ts']) || ( $post_gmt_ts > $most_recent_post['post_gmt_ts'] ) ) {\n\t\t\t\t$most_recent_post = array(\n\t\t\t\t\t'blog_id'\t\t=> $blog->userblog_id,\n\t\t\t\t\t'post_id'\t\t=> $recent_post['ID'],\n\t\t\t\t\t'post_date_gmt'\t=> $recent_post['post_date_gmt'],\n\t\t\t\t\t'post_gmt_ts'\t=> $post_gmt_ts\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn $most_recent_post;\n}\n\n// Misc functions\n\n/**\n * Get the size of a directory.\n *\n * A helper function that is used primarily to check whether\n * a blog has exceeded its allowed upload space.\n *\n * @since MU\n *\n * @param string $directory Full path of a directory.\n * @return int Size of the directory in MB.\n */\nfunction get_dirsize( $directory ) {\n\t$dirsize = get_transient( 'dirsize_cache' );\n\tif ( is_array( $dirsize ) && isset( $dirsize[ $directory ][ 'size' ] ) )\n\t\treturn $dirsize[ $directory ][ 'size' ];\n\n\tif ( ! is_array( $dirsize ) )\n\t\t$dirsize = array();\n\n\t// Exclude individual site directories from the total when checking the main site,\n\t// as they are subdirectories and should not be counted.\n\tif ( is_main_site() ) {\n\t\t$dirsize[ $directory ][ 'size' ] = recurse_dirsize( $directory, $directory . '/sites' );\n\t} else {\n\t\t$dirsize[ $directory ][ 'size' ] = recurse_dirsize( $directory );\n\t}\n\n\tset_transient( 'dirsize_cache', $dirsize, HOUR_IN_SECONDS );\n\treturn $dirsize[ $directory ][ 'size' ];\n}\n\n/**\n * Get the size of a directory recursively.\n *\n * Used by get_dirsize() to get a directory's size when it contains\n * other directories.\n *\n * @since MU\n * @since 4.3.0 $exclude parameter added.\n *\n * @param string $directory Full path of a directory.\n * @param string $exclude   Optional. Full path of a subdirectory to exclude from the total.\n * @return int|false Size in MB if a valid directory. False if not.\n */\nfunction recurse_dirsize( $directory, $exclude = null ) {\n\t$size = 0;\n\n\t$directory = untrailingslashit( $directory );\n\n\tif ( ! file_exists( $directory ) || ! is_dir( $directory ) || ! is_readable( $directory ) || $directory === $exclude ) {\n\t\treturn false;\n\t}\n\n\tif ($handle = opendir($directory)) {\n\t\twhile(($file = readdir($handle)) !== false) {\n\t\t\t$path = $directory.'/'.$file;\n\t\t\tif ($file != '.' && $file != '..') {\n\t\t\t\tif (is_file($path)) {\n\t\t\t\t\t$size += filesize($path);\n\t\t\t\t} elseif (is_dir($path)) {\n\t\t\t\t\t$handlesize = recurse_dirsize( $path, $exclude );\n\t\t\t\t\tif ($handlesize > 0)\n\t\t\t\t\t\t$size += $handlesize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir($handle);\n\t}\n\treturn $size;\n}\n\n/**\n * Check an array of MIME types against a whitelist.\n *\n * WordPress ships with a set of allowed upload filetypes,\n * which is defined in wp-includes/functions.php in\n * get_allowed_mime_types(). This function is used to filter\n * that list against the filetype whitelist provided by Multisite\n * Super Admins at wp-admin/network/settings.php.\n *\n * @since MU\n *\n * @param array $mimes\n * @return array\n */\nfunction check_upload_mimes( $mimes ) {\n\t$site_exts = explode( ' ', get_site_option( 'upload_filetypes', 'jpg jpeg png gif' ) );\n\t$site_mimes = array();\n\tforeach ( $site_exts as $ext ) {\n\t\tforeach ( $mimes as $ext_pattern => $mime ) {\n\t\t\tif ( $ext != '' && strpos( $ext_pattern, $ext ) !== false )\n\t\t\t\t$site_mimes[$ext_pattern] = $mime;\n\t\t}\n\t}\n\treturn $site_mimes;\n}\n\n/**\n * Update a blog's post count.\n *\n * WordPress MS stores a blog's post count as an option so as\n * to avoid extraneous COUNTs when a blog's details are fetched\n * with get_site(). This function is called when posts are published\n * or unpublished to make sure the count stays current.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $deprecated Not used.\n */\nfunction update_posts_count( $deprecated = '' ) {\n\tglobal $wpdb;\n\tupdate_option( 'post_count', (int) $wpdb->get_var( \"SELECT COUNT(ID) FROM {$wpdb->posts} WHERE post_status = 'publish' and post_type = 'post'\" ) );\n}\n\n/**\n * Logs user registrations.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $blog_id\n * @param int $user_id\n */\nfunction wpmu_log_new_registrations( $blog_id, $user_id ) {\n\tglobal $wpdb;\n\t$user = get_userdata( (int) $user_id );\n\tif ( $user )\n\t\t$wpdb->insert( $wpdb->registration_log, array('email' => $user->user_email, 'IP' => preg_replace( '/[^0-9., ]/', '', wp_unslash( $_SERVER['REMOTE_ADDR'] ) ), 'blog_id' => $blog_id, 'date_registered' => current_time('mysql')) );\n}\n\n/**\n * Maintains a canonical list of terms by syncing terms created for each blog with the global terms table.\n *\n * @since 3.0.0\n *\n * @see term_id_filter\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar int $global_terms_recurse\n *\n * @param int    $term_id    An ID for a term on the current blog.\n * @param string $deprecated Not used.\n * @return int An ID from the global terms table mapped from $term_id.\n */\nfunction global_terms( $term_id, $deprecated = '' ) {\n\tglobal $wpdb;\n\tstatic $global_terms_recurse = null;\n\n\tif ( !global_terms_enabled() )\n\t\treturn $term_id;\n\n\t// prevent a race condition\n\t$recurse_start = false;\n\tif ( $global_terms_recurse === null ) {\n\t\t$recurse_start = true;\n\t\t$global_terms_recurse = 1;\n\t} elseif ( 10 < $global_terms_recurse++ ) {\n\t\treturn $term_id;\n\t}\n\n\t$term_id = intval( $term_id );\n\t$c = $wpdb->get_row( $wpdb->prepare( \"SELECT * FROM $wpdb->terms WHERE term_id = %d\", $term_id ) );\n\n\t$global_id = $wpdb->get_var( $wpdb->prepare( \"SELECT cat_ID FROM $wpdb->sitecategories WHERE category_nicename = %s\", $c->slug ) );\n\tif ( $global_id == null ) {\n\t\t$used_global_id = $wpdb->get_var( $wpdb->prepare( \"SELECT cat_ID FROM $wpdb->sitecategories WHERE cat_ID = %d\", $c->term_id ) );\n\t\tif ( null == $used_global_id ) {\n\t\t\t$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $term_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );\n\t\t\t$global_id = $wpdb->insert_id;\n\t\t\tif ( empty( $global_id ) )\n\t\t\t\treturn $term_id;\n\t\t} else {\n\t\t\t$max_global_id = $wpdb->get_var( \"SELECT MAX(cat_ID) FROM $wpdb->sitecategories\" );\n\t\t\t$max_local_id = $wpdb->get_var( \"SELECT MAX(term_id) FROM $wpdb->terms\" );\n\t\t\t$new_global_id = max( $max_global_id, $max_local_id ) + mt_rand( 100, 400 );\n\t\t\t$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $new_global_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );\n\t\t\t$global_id = $wpdb->insert_id;\n\t\t}\n\t} elseif ( $global_id != $term_id ) {\n\t\t$local_id = $wpdb->get_var( $wpdb->prepare( \"SELECT term_id FROM $wpdb->terms WHERE term_id = %d\", $global_id ) );\n\t\tif ( null != $local_id ) {\n\t\t\tglobal_terms( $local_id );\n\t\t\tif ( 10 < $global_terms_recurse ) {\n\t\t\t\t$global_id = $term_id;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( $global_id != $term_id ) {\n\t\tif ( get_option( 'default_category' ) == $term_id )\n\t\t\tupdate_option( 'default_category', $global_id );\n\n\t\t$wpdb->update( $wpdb->terms, array('term_id' => $global_id), array('term_id' => $term_id) );\n\t\t$wpdb->update( $wpdb->term_taxonomy, array('term_id' => $global_id), array('term_id' => $term_id) );\n\t\t$wpdb->update( $wpdb->term_taxonomy, array('parent' => $global_id), array('parent' => $term_id) );\n\n\t\tclean_term_cache($term_id);\n\t}\n\tif ( $recurse_start )\n\t\t$global_terms_recurse = null;\n\n\treturn $global_id;\n}\n\n/**\n * Ensure that the current site's domain is listed in the allowed redirect host list.\n *\n * @see wp_validate_redirect()\n * @since MU\n *\n * @param array|string $deprecated Not used.\n * @return array The current site's domain\n */\nfunction redirect_this_site( $deprecated = '' ) {\n\treturn array( get_network()->domain );\n}\n\n/**\n * Check whether an upload is too big.\n *\n * @since MU\n *\n * @blessed\n *\n * @param array $upload\n * @return string|array If the upload is under the size limit, $upload is returned. Otherwise returns an error message.\n */\nfunction upload_is_file_too_big( $upload ) {\n\tif ( ! is_array( $upload ) || defined( 'WP_IMPORTING' ) || get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn $upload;\n\n\tif ( strlen( $upload['bits'] )  > ( KB_IN_BYTES * get_site_option( 'fileupload_maxk', 1500 ) ) ) {\n\t\treturn sprintf( __( 'This file is too big. Files must be less than %d KB in size.' ) . '<br />', get_site_option( 'fileupload_maxk', 1500 ) );\n\t}\n\n\treturn $upload;\n}\n\n/**\n * Add a nonce field to the signup page.\n *\n * @since MU\n */\nfunction signup_nonce_fields() {\n\t$id = mt_rand();\n\techo \"<input type='hidden' name='signup_form_id' value='{$id}' />\";\n\twp_nonce_field('signup_form_' . $id, '_signup_form', false);\n}\n\n/**\n * Process the signup nonce created in signup_nonce_fields().\n *\n * @since MU\n *\n * @param array $result\n * @return array\n */\nfunction signup_nonce_check( $result ) {\n\tif ( !strpos( $_SERVER[ 'PHP_SELF' ], 'wp-signup.php' ) )\n\t\treturn $result;\n\n\tif ( wp_create_nonce('signup_form_' . $_POST[ 'signup_form_id' ]) != $_POST['_signup_form'] )\n\t\twp_die( __( 'Please try again.' ) );\n\n\treturn $result;\n}\n\n/**\n * Correct 404 redirects when NOBLOGREDIRECT is defined.\n *\n * @since MU\n */\nfunction maybe_redirect_404() {\n\t/**\n\t * Filters the redirect URL for 404s on the main site.\n\t *\n\t * The filter is only evaluated if the NOBLOGREDIRECT constant is defined.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param string $no_blog_redirect The redirect URL defined in NOBLOGREDIRECT.\n\t */\n\tif ( is_main_site() && is_404() && defined( 'NOBLOGREDIRECT' ) && ( $destination = apply_filters( 'blog_redirect_404', NOBLOGREDIRECT ) ) ) {\n\t\tif ( $destination == '%siteurl%' )\n\t\t\t$destination = network_home_url();\n\t\twp_redirect( $destination );\n\t\texit();\n\t}\n}\n\n/**\n * Add a new user to a blog by visiting /newbloguser/username/.\n *\n * This will only work when the user's details are saved as an option\n * keyed as 'new_user_x', where 'x' is the username of the user to be\n * added, as when a user is invited through the regular WP Add User interface.\n *\n * @since MU\n */\nfunction maybe_add_existing_user_to_blog() {\n\tif ( false === strpos( $_SERVER[ 'REQUEST_URI' ], '/newbloguser/' ) )\n\t\treturn;\n\n\t$parts = explode( '/', $_SERVER[ 'REQUEST_URI' ] );\n\t$key = array_pop( $parts );\n\n\tif ( $key == '' )\n\t\t$key = array_pop( $parts );\n\n\t$details = get_option( 'new_user_' . $key );\n\tif ( !empty( $details ) )\n\t\tdelete_option( 'new_user_' . $key );\n\n\tif ( empty( $details ) || is_wp_error( add_existing_user_to_blog( $details ) ) )\n\t\twp_die( sprintf(__('An error occurred adding you to this site. Back to the <a href=\"%s\">homepage</a>.'), home_url() ) );\n\n\twp_die( sprintf( __( 'You have been added to this site. Please visit the <a href=\"%s\">homepage</a> or <a href=\"%s\">log in</a> using your username and password.' ), home_url(), admin_url() ), __( 'WordPress &rsaquo; Success' ), array( 'response' => 200 ) );\n}\n\n/**\n * Add a user to a blog based on details from maybe_add_existing_user_to_blog().\n *\n * @since MU\n *\n * @param array $details\n * @return true|WP_Error|void\n */\nfunction add_existing_user_to_blog( $details = false ) {\n\tif ( is_array( $details ) ) {\n\t\t$blog_id = get_current_blog_id();\n\t\t$result = add_user_to_blog( $blog_id, $details[ 'user_id' ], $details[ 'role' ] );\n\t\t/**\n\t\t * Fires immediately after an existing user is added to a site.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param int   $user_id User ID.\n\t\t * @param mixed $result  True on success or a WP_Error object if the user doesn't exist.\n\t\t */\n\t\tdo_action( 'added_existing_user', $details['user_id'], $result );\n\t\treturn $result;\n\t}\n}\n\n/**\n * Adds a newly created user to the appropriate blog\n *\n * To add a user in general, use add_user_to_blog(). This function\n * is specifically hooked into the {@see 'wpmu_activate_user'} action.\n *\n * @since MU\n * @see add_user_to_blog()\n *\n * @param int   $user_id\n * @param mixed $password Ignored.\n * @param array $meta\n */\nfunction add_new_user_to_blog( $user_id, $password, $meta ) {\n\tif ( !empty( $meta[ 'add_to_blog' ] ) ) {\n\t\t$blog_id = $meta[ 'add_to_blog' ];\n\t\t$role = $meta[ 'new_role' ];\n\t\tremove_user_from_blog($user_id, get_network()->site_id); // remove user from main blog.\n\t\tadd_user_to_blog( $blog_id, $user_id, $role );\n\t\tupdate_user_meta( $user_id, 'primary_blog', $blog_id );\n\t}\n}\n\n/**\n * Correct From host on outgoing mail to match the site domain\n *\n * @since MU\n *\n * @param PHPMailer $phpmailer The PHPMailer instance, passed by reference.\n */\nfunction fix_phpmailer_messageid( $phpmailer ) {\n\t$phpmailer->Hostname = get_network()->domain;\n}\n\n/**\n * Check to see whether a user is marked as a spammer, based on user login.\n *\n * @since MU\n *\n * @param string|WP_User $user Optional. Defaults to current user. WP_User object,\n * \t                           or user login name as a string.\n * @return bool\n */\nfunction is_user_spammy( $user = null ) {\n    if ( ! ( $user instanceof WP_User ) ) {\n\t\tif ( $user ) {\n\t\t\t$user = get_user_by( 'login', $user );\n\t\t} else {\n\t\t\t$user = wp_get_current_user();\n\t\t}\n\t}\n\n\treturn $user && isset( $user->spam ) && 1 == $user->spam;\n}\n\n/**\n * Update this blog's 'public' setting in the global blogs table.\n *\n * Public blogs have a setting of 1, private blogs are 0.\n *\n * @since MU\n *\n * @param int $old_value\n * @param int $value     The new public value\n */\nfunction update_blog_public( $old_value, $value ) {\n\tupdate_blog_status( get_current_blog_id(), 'public', (int) $value );\n}\n\n/**\n * Check whether a usermeta key has to do with the current blog.\n *\n * @since MU\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $key\n * @param int    $user_id Optional. Defaults to current user.\n * @param int    $blog_id Optional. Defaults to current blog.\n * @return bool\n */\nfunction is_user_option_local( $key, $user_id = 0, $blog_id = 0 ) {\n\tglobal $wpdb;\n\n\t$current_user = wp_get_current_user();\n\tif ( $blog_id == 0 ) {\n\t\t$blog_id = $wpdb->blogid;\n\t}\n\t$local_key = $wpdb->get_blog_prefix( $blog_id ) . $key;\n\n\treturn isset( $current_user->$local_key );\n}\n\n/**\n * Check whether users can self-register, based on Network settings.\n *\n * @since MU\n *\n * @return bool\n */\nfunction users_can_register_signup_filter() {\n\t$registration = get_site_option('registration');\n\treturn ( $registration == 'all' || $registration == 'user' );\n}\n\n/**\n * Ensure that the welcome message is not empty. Currently unused.\n *\n * @since MU\n *\n * @param string $text\n * @return string\n */\nfunction welcome_user_msg_filter( $text ) {\n\tif ( !$text ) {\n\t\tremove_filter( 'site_option_welcome_user_email', 'welcome_user_msg_filter' );\n\n\t\t/* translators: Do not translate USERNAME, PASSWORD, LOGINLINK, SITE_NAME: those are placeholders. */\n\t\t$text = __( 'Howdy USERNAME,\n\nYour new account is set up.\n\nYou can log in with the following information:\nUsername: USERNAME\nPassword: PASSWORD\nLOGINLINK\n\nThanks!\n\n--The Team @ SITE_NAME' );\n\t\tupdate_site_option( 'welcome_user_email', $text );\n\t}\n\treturn $text;\n}\n\n/**\n * Whether to force SSL on content.\n *\n * @since 2.8.5\n *\n * @staticvar bool $forced_content\n *\n * @param bool $force\n * @return bool True if forced, false if not forced.\n */\nfunction force_ssl_content( $force = '' ) {\n\tstatic $forced_content = false;\n\n\tif ( '' != $force ) {\n\t\t$old_forced = $forced_content;\n\t\t$forced_content = $force;\n\t\treturn $old_forced;\n\t}\n\n\treturn $forced_content;\n}\n\n/**\n * Formats a URL to use https.\n *\n * Useful as a filter.\n *\n * @since 2.8.5\n *\n * @param string $url URL\n * @return string URL with https as the scheme\n */\nfunction filter_SSL( $url ) {\n\tif ( ! is_string( $url ) )\n\t\treturn get_bloginfo( 'url' ); // Return home blog url with proper scheme\n\n\tif ( force_ssl_content() && is_ssl() )\n\t\t$url = set_url_scheme( $url, 'https' );\n\n\treturn $url;\n}\n\n/**\n * Schedule update of the network-wide counts for the current network.\n *\n * @since 3.1.0\n */\nfunction wp_schedule_update_network_counts() {\n\tif ( !is_main_site() )\n\t\treturn;\n\n\tif ( ! wp_next_scheduled('update_network_counts') && ! wp_installing() )\n\t\twp_schedule_event(time(), 'twicedaily', 'update_network_counts');\n}\n\n/**\n * Update the network-wide counts for the current network.\n *\n * @since 3.1.0\n */\nfunction wp_update_network_counts() {\n\twp_update_network_user_counts();\n\twp_update_network_site_counts();\n}\n\n/**\n * Update the count of sites for the current network.\n *\n * If enabled through the {@see 'enable_live_network_counts'} filter, update the sites count\n * on a network when a site is created or its status is updated.\n *\n * @since 3.7.0\n */\nfunction wp_maybe_update_network_site_counts() {\n\t$is_small_network = ! wp_is_large_network( 'sites' );\n\n\t/**\n\t * Filters whether to update network site or user counts when a new site is created.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @see wp_is_large_network()\n\t *\n\t * @param bool   $small_network Whether the network is considered small.\n\t * @param string $context       Context. Either 'users' or 'sites'.\n\t */\n\tif ( ! apply_filters( 'enable_live_network_counts', $is_small_network, 'sites' ) )\n\t\treturn;\n\n\twp_update_network_site_counts();\n}\n\n/**\n * Update the network-wide users count.\n *\n * If enabled through the {@see 'enable_live_network_counts'} filter, update the users count\n * on a network when a user is created or its status is updated.\n *\n * @since 3.7.0\n */\nfunction wp_maybe_update_network_user_counts() {\n\t$is_small_network = ! wp_is_large_network( 'users' );\n\n\t/** This filter is documented in wp-includes/ms-functions.php */\n\tif ( ! apply_filters( 'enable_live_network_counts', $is_small_network, 'users' ) )\n\t\treturn;\n\n\twp_update_network_user_counts();\n}\n\n/**\n * Update the network-wide site count.\n *\n * @since 3.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction wp_update_network_site_counts() {\n\tglobal $wpdb;\n\n\t$count = get_sites( array(\n\t\t'network_id' => $wpdb->siteid,\n\t\t'spam'       => 0,\n\t\t'deleted'    => 0,\n\t\t'archived'   => 0,\n\t\t'count'      => true,\n\t) );\n\n\tupdate_site_option( 'blog_count', $count );\n}\n\n/**\n * Update the network-wide user count.\n *\n * @since 3.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction wp_update_network_user_counts() {\n\tglobal $wpdb;\n\n\t$count = $wpdb->get_var( \"SELECT COUNT(ID) as c FROM $wpdb->users WHERE spam = '0' AND deleted = '0'\" );\n\tupdate_site_option( 'user_count', $count );\n}\n\n/**\n * Returns the space used by the current blog.\n *\n * @since 3.5.0\n *\n * @return int Used space in megabytes\n */\nfunction get_space_used() {\n\t/**\n\t * Filters the amount of storage space used by the current site.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param int|bool $space_used The amount of used space, in megabytes. Default false.\n\t */\n\t$space_used = apply_filters( 'pre_get_space_used', false );\n\tif ( false === $space_used ) {\n\t\t$upload_dir = wp_upload_dir();\n\t\t$space_used = get_dirsize( $upload_dir['basedir'] ) / MB_IN_BYTES;\n\t}\n\n\treturn $space_used;\n}\n\n/**\n * Returns the upload quota for the current blog.\n *\n * @since MU\n *\n * @return int Quota in megabytes\n */\nfunction get_space_allowed() {\n\t$space_allowed = get_option( 'blog_upload_space' );\n\n\tif ( ! is_numeric( $space_allowed ) )\n\t\t$space_allowed = get_site_option( 'blog_upload_space' );\n\n\tif ( ! is_numeric( $space_allowed ) )\n\t\t$space_allowed = 100;\n\n\t/**\n\t * Filters the upload quota for the current site.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param int $space_allowed Upload quota in megabytes for the current blog.\n\t */\n\treturn apply_filters( 'get_space_allowed', $space_allowed );\n}\n\n/**\n * Determines if there is any upload space left in the current blog's quota.\n *\n * @since 3.0.0\n *\n * @return int of upload space available in bytes\n */\nfunction get_upload_space_available() {\n\t$allowed = get_space_allowed();\n\tif ( $allowed < 0 ) {\n\t\t$allowed = 0;\n\t}\n\t$space_allowed = $allowed * MB_IN_BYTES;\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn $space_allowed;\n\n\t$space_used = get_space_used() * MB_IN_BYTES;\n\n\tif ( ( $space_allowed - $space_used ) <= 0 )\n\t\treturn 0;\n\n\treturn $space_allowed - $space_used;\n}\n\n/**\n * Determines if there is any upload space left in the current blog's quota.\n *\n * @since 3.0.0\n * @return bool True if space is available, false otherwise.\n */\nfunction is_upload_space_available() {\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn true;\n\n\treturn (bool) get_upload_space_available();\n}\n\n/**\n * Filters the maximum upload file size allowed, in bytes.\n *\n * @since 3.0.0\n *\n * @param  int $size Upload size limit in bytes.\n * @return int       Upload size limit in bytes.\n */\nfunction upload_size_limit_filter( $size ) {\n\t$fileupload_maxk = KB_IN_BYTES * get_site_option( 'fileupload_maxk', 1500 );\n\tif ( get_site_option( 'upload_space_check_disabled' ) )\n\t\treturn min( $size, $fileupload_maxk );\n\n\treturn min( $size, $fileupload_maxk, get_upload_space_available() );\n}\n\n/**\n * Whether or not we have a large network.\n *\n * The default criteria for a large network is either more than 10,000 users or more than 10,000 sites.\n * Plugins can alter this criteria using the {@see 'wp_is_large_network'} filter.\n *\n * @since 3.3.0\n * @param string $using 'sites or 'users'. Default is 'sites'.\n * @return bool True if the network meets the criteria for large. False otherwise.\n */\nfunction wp_is_large_network( $using = 'sites' ) {\n\tif ( 'users' == $using ) {\n\t\t$count = get_user_count();\n\t\t/**\n\t\t * Filters whether the network is considered large.\n\t\t *\n\t\t * @since 3.3.0\n\t\t *\n\t\t * @param bool   $is_large_network Whether the network has more than 10000 users or sites.\n\t\t * @param string $component        The component to count. Accepts 'users', or 'sites'.\n\t\t * @param int    $count            The count of items for the component.\n\t\t */\n\t\treturn apply_filters( 'wp_is_large_network', $count > 10000, 'users', $count );\n\t}\n\n\t$count = get_blog_count();\n\t/** This filter is documented in wp-includes/ms-functions.php */\n\treturn apply_filters( 'wp_is_large_network', $count > 10000, 'sites', $count );\n}\n\n/**\n * Retrieves a list of reserved site on a sub-directory Multisite install.\n *\n * @since 4.4.0\n *\n * @return array $names Array of reserved subdirectory names.\n */\nfunction get_subdirectory_reserved_names() {\n\t$names = array(\n\t\t'page', 'comments', 'blog', 'files', 'feed', 'wp-admin',\n\t\t'wp-content', 'wp-includes', 'wp-json', 'embed'\n\t);\n\n\t/**\n\t * Filters reserved site names on a sub-directory Multisite install.\n\t *\n\t * @since 3.0.0\n\t * @since 4.4.0 'wp-admin', 'wp-content', 'wp-includes', 'wp-json', and 'embed' were added\n\t *              to the reserved names list.\n\t *\n\t * @param array $subdirectory_reserved_names Array of reserved names.\n\t */\n\treturn apply_filters( 'subdirectory_reserved_names', $names );\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39795';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/ms-functions.php", "wp-includes/version.php"], "buggy_code_start_loc": [672, 7], "buggy_code_end_loc": [723, 8], "fixing_code_start_loc": [672, 7], "fixing_code_end_loc": [723, 8], "type": "CWE-338", "message": "wp-includes/ms-functions.php in the Multisite WordPress API in WordPress before 4.7.1 does not properly choose random numbers for keys, which makes it easier for remote attackers to bypass intended access restrictions via a crafted (1) site signup or (2) user signup.", "other": {"cve": {"id": "CVE-2017-5493", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-15T02:59:03.077", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "wp-includes/ms-functions.php in the Multisite WordPress API in WordPress before 4.7.1 does not properly choose random numbers for keys, which makes it easier for remote attackers to bypass intended access restrictions via a crafted (1) site signup or (2) user signup."}, {"lang": "es", "value": "wp-includes/ms-functions.php en la API Multisite WordPress en WordPress en versiones anteriores a 4.7.1 no elige adecuadamente los n\u00fameros aleatorios para claves, lo que hace que m\u00e1s f\u00e1cil para atacantes remotos eludir las restricciones destinadas al acceso a trav\u00e9s de una inscripci\u00f3n del (1) sitio o (2) usuario manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7", "matchCriteriaId": "5C55F44C-4A71-4C47-9908-071A23D46939"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3779", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/14/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95401", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037591", "source": "cve@mitre.org"}, {"url": "https://codex.wordpress.org/Version_4.7.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/cea9e2dc62abf777e06b12ec4ad9d1aaa49b29f4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://wordpress.org/news/2017/01/wordpress-4-7-1-security-and-maintenance-release/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8721", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/cea9e2dc62abf777e06b12ec4ad9d1aaa49b29f4"}}