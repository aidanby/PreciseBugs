{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) International Business Machines Corp., 2000-2004\n *   Portions Copyright (C) Christoph Hellwig, 2001-2002\n */\n\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\tinode->i_link = JFS_IP(inode)->i_inline;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tinode->i_link[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n/*\n * Workhorse of both fsync & write_inode\n */\nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on read-only volume\",\n\t\t\t\tinode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tif (inode->i_nlink == 0)\n\t\treturn 0;\n\t/*\n\t * If COMMIT_DIRTY is not set, the inode isn't really dirty.\n\t * It has been committed since the last change, but was still\n\t * on the dirty inode list.\n\t */\n\tif (!test_cflag(COMMIT_Dirty, inode)) {\n\t\t/* Make sure committed changes hit the disk */\n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);\n\t\treturn 0;\n\t}\n\n\tif (jfs_commit_inode(inode, wait)) {\n\t\tjfs_err(\"jfs_write_inode: jfs_commit_inode failed!\");\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}\n\nvoid jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}\n\nvoid jfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstatic int noisy = 5;\n\n\tif (isReadOnly(inode)) {\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\t/* kernel allows writes to devices on read-only\n\t\t\t * partitions and may try to mark inode dirty\n\t\t\t */\n\t\t\tjfs_err(\"jfs_dirty_inode called on read-only volume\");\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn;\n\t}\n\n\tset_cflag(COMMIT_Dirty, inode);\n}\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}\n\nstatic int jfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, jfs_get_block, wbc);\n}\n\nstatic int jfs_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, jfs_get_block);\n}\n\nstatic int jfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, jfs_get_block);\n}\n\nstatic void jfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, jfs_get_block);\n}\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}\n\nstatic int jfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tjfs_get_block);\n\tif (unlikely(ret))\n\t\tjfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t jfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, jfs_get_block);\n}\n\nstatic ssize_t jfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter, jfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif (end > isize)\n\t\t\tjfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}\n\nconst struct address_space_operations jfs_aops = {\n\t.set_page_dirty\t= __set_page_dirty_buffers,\n\t.readpage\t= jfs_readpage,\n\t.readahead\t= jfs_readahead,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\n/*\n * Guts of jfs_truncate.  Called with locks already held.  Can be called\n * with directory for truncating directory index table.\n */\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = current_time(ip);\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}\n\nvoid jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) International Business Machines Corp., 2000-2004\n *   Portions Copyright (C) Christoph Hellwig, 2001-2002\n */\n\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/uio.h>\n#include <linux/writeback.h>\n#include \"jfs_incore.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\tinode->i_link = JFS_IP(inode)->i_inline;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tinode->i_link[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n/*\n * Workhorse of both fsync & write_inode\n */\nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on read-only volume\",\n\t\t\t\tinode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}\n\nint jfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tif (inode->i_nlink == 0)\n\t\treturn 0;\n\t/*\n\t * If COMMIT_DIRTY is not set, the inode isn't really dirty.\n\t * It has been committed since the last change, but was still\n\t * on the dirty inode list.\n\t */\n\tif (!test_cflag(COMMIT_Dirty, inode)) {\n\t\t/* Make sure committed changes hit the disk */\n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);\n\t\treturn 0;\n\t}\n\n\tif (jfs_commit_inode(inode, wait)) {\n\t\tjfs_err(\"jfs_write_inode: jfs_commit_inode failed!\");\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}\n\nvoid jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n\t\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}\n\nvoid jfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstatic int noisy = 5;\n\n\tif (isReadOnly(inode)) {\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\t/* kernel allows writes to devices on read-only\n\t\t\t * partitions and may try to mark inode dirty\n\t\t\t */\n\t\t\tjfs_err(\"jfs_dirty_inode called on read-only volume\");\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn;\n\t}\n\n\tset_cflag(COMMIT_Dirty, inode);\n}\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}\n\nstatic int jfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, jfs_get_block, wbc);\n}\n\nstatic int jfs_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, jfs_get_block);\n}\n\nstatic int jfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, jfs_get_block);\n}\n\nstatic void jfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, jfs_get_block);\n}\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}\n\nstatic int jfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tjfs_get_block);\n\tif (unlikely(ret))\n\t\tjfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t jfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, jfs_get_block);\n}\n\nstatic ssize_t jfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter, jfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif (end > isize)\n\t\t\tjfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}\n\nconst struct address_space_operations jfs_aops = {\n\t.set_page_dirty\t= __set_page_dirty_buffers,\n\t.readpage\t= jfs_readpage,\n\t.readahead\t= jfs_readahead,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\n/*\n * Guts of jfs_truncate.  Called with locks already held.  Can be called\n * with directory for truncating directory index table.\n */\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = current_time(ip);\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}\n\nvoid jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}\n"], "filenames": ["fs/jfs/inode.c"], "buggy_code_start_loc": [148], "buggy_code_end_loc": [155], "fixing_code_start_loc": [149], "fixing_code_end_loc": [156], "type": "CWE-476", "message": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.", "other": {"cve": {"id": "CVE-2022-3202", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-14T15:15:11.453", "lastModified": "2023-02-28T18:34:00.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information."}, {"lang": "es", "value": "Un fallo de desreferencia de puntero NULL en diFree en el archivo fs/jfs/inode.c en Journaled File System (JFS) en el kernel de Linux. Esto podr\u00eda permitir a un atacante local bloquear el sistema o filtrar informaci\u00f3n interna del kernel"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18", "matchCriteriaId": "FE93544F-B946-47CF-9697-FBF3484FCB92"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20221228-0007/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47"}}