{"buggy_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n\nstatic void jsB_new_Object(js_State *J)\n{\n\tif (js_isundefined(J, 1) || js_isnull(J, 1))\n\t\tjs_newobject(J);\n\telse\n\t\tjs_pushobject(J, js_toobject(J, 1));\n}\n\nstatic void jsB_Object(js_State *J)\n{\n\tif (js_isundefined(J, 1) || js_isnull(J, 1))\n\t\tjs_newobject(J);\n\telse\n\t\tjs_pushobject(J, js_toobject(J, 1));\n}\n\nstatic void Op_toString(js_State *J)\n{\n\tif (js_isundefined(J, 0))\n\t\tjs_pushliteral(J, \"[object Undefined]\");\n\telse if (js_isnull(J, 0))\n\t\tjs_pushliteral(J, \"[object Null]\");\n\telse {\n\t\tjs_Object *self = js_toobject(J, 0);\n\t\tswitch (self->type) {\n\t\tcase JS_COBJECT: js_pushliteral(J, \"[object Object]\"); break;\n\t\tcase JS_CARRAY: js_pushliteral(J, \"[object Array]\"); break;\n\t\tcase JS_CFUNCTION: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CSCRIPT: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CCFUNCTION: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CERROR: js_pushliteral(J, \"[object Error]\"); break;\n\t\tcase JS_CBOOLEAN: js_pushliteral(J, \"[object Boolean]\"); break;\n\t\tcase JS_CNUMBER: js_pushliteral(J, \"[object Number]\"); break;\n\t\tcase JS_CSTRING: js_pushliteral(J, \"[object String]\"); break;\n\t\tcase JS_CREGEXP: js_pushliteral(J, \"[object RegExp]\"); break;\n\t\tcase JS_CDATE: js_pushliteral(J, \"[object Date]\"); break;\n\t\tcase JS_CMATH: js_pushliteral(J, \"[object Math]\"); break;\n\t\tcase JS_CJSON: js_pushliteral(J, \"[object JSON]\"); break;\n\t\tcase JS_CARGUMENTS: js_pushliteral(J, \"[object Arguments]\"); break;\n\t\tcase JS_CITERATOR: js_pushliteral(J, \"[object Iterator]\"); break;\n\t\tcase JS_CUSERDATA:\n\t\t\tjs_pushliteral(J, \"[object \");\n\t\t\tjs_pushliteral(J, self->u.user.tag);\n\t\t\tjs_concat(J);\n\t\t\tjs_pushliteral(J, \"]\");\n\t\t\tjs_concat(J);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void Op_valueOf(js_State *J)\n{\n\tjs_copy(J, 0);\n}\n\nstatic void Op_hasOwnProperty(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tconst char *name = js_tostring(J, 1);\n\tjs_Property *ref;\n\tint k;\n\n\tif (self->type == JS_CSTRING) {\n\t\tif (js_isarrayindex(J, name, &k) && k >= 0 && k < self->u.s.length) {\n\t\t\tjs_pushboolean(J, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (self->type == JS_CARRAY && self->u.a.simple) {\n\t\tif (js_isarrayindex(J, name, &k) && k >= 0 && k < self->u.a.length) {\n\t\t\tjs_pushboolean(J, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tref = jsV_getownproperty(J, self, name);\n\tjs_pushboolean(J, ref != NULL);\n}\n\nstatic void Op_isPrototypeOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (js_isobject(J, 1)) {\n\t\tjs_Object *V = js_toobject(J, 1);\n\t\tdo {\n\t\t\tV = V->prototype;\n\t\t\tif (V == self) {\n\t\t\t\tjs_pushboolean(J, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} while (V);\n\t}\n\tjs_pushboolean(J, 0);\n}\n\nstatic void Op_propertyIsEnumerable(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tconst char *name = js_tostring(J, 1);\n\tjs_Property *ref = jsV_getownproperty(J, self, name);\n\tjs_pushboolean(J, ref && !(ref->atts & JS_DONTENUM));\n}\n\nstatic void O_getPrototypeOf(js_State *J)\n{\n\tjs_Object *obj;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tif (obj->prototype)\n\t\tjs_pushobject(J, obj->prototype);\n\telse\n\t\tjs_pushnull(J);\n}\n\nstatic void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\t// TODO: builtin properties (string and array index and length, regexp flags, etc)\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_setproperty(J, -2, \"value\");\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_setproperty(J, -2, \"writable\");\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"get\");\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"set\");\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_setproperty(J, -2, \"enumerable\");\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_setproperty(J, -2, \"configurable\");\n\t}\n}\n\nstatic int O_getOwnPropertyNames_walk(js_State *J, js_Property *ref, int i)\n{\n\tif (ref->left->level)\n\t\ti = O_getOwnPropertyNames_walk(J, ref->left, i);\n\tjs_pushliteral(J, ref->name);\n\tjs_setindex(J, -2, i++);\n\tif (ref->right->level)\n\t\ti = O_getOwnPropertyNames_walk(J, ref->right, i);\n\treturn i;\n}\n\nstatic void O_getOwnPropertyNames(js_State *J)\n{\n\tjs_Object *obj;\n\tchar name[32];\n\tint k;\n\tint i;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\n\tjs_newarray(J);\n\n\tif (obj->properties->level)\n\t\ti = O_getOwnPropertyNames_walk(J, obj->properties, 0);\n\telse\n\t\ti = 0;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tjs_pushliteral(J, \"length\");\n\t\tjs_setindex(J, -2, i++);\n\t\tif (obj->u.a.simple) {\n\t\t\tfor (k = 0; k < obj->u.a.length; ++k) {\n\t\t\t\tjs_itoa(name, k);\n\t\t\t\tjs_pushstring(J, name);\n\t\t\t\tjs_setindex(J, -2, i++);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->type == JS_CSTRING) {\n\t\tjs_pushliteral(J, \"length\");\n\t\tjs_setindex(J, -2, i++);\n\t\tfor (k = 0; k < obj->u.s.length; ++k) {\n\t\t\tjs_itoa(name, k);\n\t\t\tjs_pushstring(J, name);\n\t\t\tjs_setindex(J, -2, i++);\n\t\t}\n\t}\n\n\tif (obj->type == JS_CREGEXP) {\n\t\tjs_pushliteral(J, \"source\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"global\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"ignoreCase\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"multiline\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"lastIndex\");\n\t\tjs_setindex(J, -2, i++);\n\t}\n}\n\nstatic void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_setproperty(J, -3, name);\n\t}\n\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\n\tjs_defaccessor(J, -4, name, atts);\n\n\tjs_pop(J, 2);\n}\n\nstatic void O_defineProperty(js_State *J)\n{\n\tif (!js_isobject(J, 1)) js_typeerror(J, \"not an object\");\n\tif (!js_isobject(J, 3)) js_typeerror(J, \"not an object\");\n\tToPropertyDescriptor(J, js_toobject(J, 1), js_tostring(J, 2), js_toobject(J, 3));\n\tjs_copy(J, 1);\n}\n\nstatic void O_defineProperties_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_defineProperties_walk(J, ref->left);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tjs_pushvalue(J, ref->value);\n\t\tToPropertyDescriptor(J, js_toobject(J, 1), ref->name, js_toobject(J, -1));\n\t\tjs_pop(J, 1);\n\t}\n\tif (ref->right->level)\n\t\tO_defineProperties_walk(J, ref->right);\n}\n\nstatic void O_defineProperties(js_State *J)\n{\n\tjs_Object *props;\n\n\tif (!js_isobject(J, 1)) js_typeerror(J, \"not an object\");\n\tif (!js_isobject(J, 2)) js_typeerror(J, \"not an object\");\n\n\tprops = js_toobject(J, 2);\n\tif (props->properties->level)\n\t\tO_defineProperties_walk(J, props->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic void O_create_walk(js_State *J, js_Object *obj, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_create_walk(J, obj, ref->left);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tif (ref->value.type != JS_TOBJECT)\n\t\t\tjs_typeerror(J, \"not an object\");\n\t\tToPropertyDescriptor(J, obj, ref->name, ref->value.u.object);\n\t}\n\tif (ref->right->level)\n\t\tO_create_walk(J, obj, ref->right);\n}\n\nstatic void O_create(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Object *proto;\n\tjs_Object *props;\n\n\tif (js_isobject(J, 1))\n\t\tproto = js_toobject(J, 1);\n\telse if (js_isnull(J, 1))\n\t\tproto = NULL;\n\telse\n\t\tjs_typeerror(J, \"not an object or null\");\n\n\tobj = jsV_newobject(J, JS_COBJECT, proto);\n\tjs_pushobject(J, obj);\n\n\tif (js_isdefined(J, 2)) {\n\t\tif (!js_isobject(J, 2))\n\t\t\tjs_typeerror(J, \"not an object\");\n\t\tprops = js_toobject(J, 2);\n\t\tif (props->properties->level)\n\t\t\tO_create_walk(J, obj, props->properties);\n\t}\n}\n\nstatic int O_keys_walk(js_State *J, js_Property *ref, int i)\n{\n\tif (ref->left->level)\n\t\ti = O_keys_walk(J, ref->left, i);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tjs_pushliteral(J, ref->name);\n\t\tjs_setindex(J, -2, i++);\n\t}\n\tif (ref->right->level)\n\t\ti = O_keys_walk(J, ref->right, i);\n\treturn i;\n}\n\nstatic void O_keys(js_State *J)\n{\n\tjs_Object *obj;\n\tint i, k;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\n\tjs_newarray(J);\n\n\tif (obj->properties->level)\n\t\ti = O_keys_walk(J, obj->properties, 0);\n\telse\n\t\ti = 0;\n\n\tif (obj->type == JS_CSTRING) {\n\t\tfor (k = 0; k < obj->u.s.length; ++k) {\n\t\t\tjs_pushnumber(J, k);\n\t\t\tjs_setindex(J, -2, i++);\n\t\t}\n\t}\n}\n\nstatic void O_preventExtensions(js_State *J)\n{\n\tjs_Object *obj;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\tjs_copy(J, 1);\n}\n\nstatic void O_isExtensible(js_State *J)\n{\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tjs_pushboolean(J, js_toobject(J, 1)->extensible);\n}\n\nstatic void O_seal_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_seal_walk(J, ref->left);\n\tref->atts |= JS_DONTCONF;\n\tif (ref->right->level)\n\t\tO_seal_walk(J, ref->right);\n}\n\nstatic void O_seal(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\n\tif (obj->properties->level)\n\t\tO_seal_walk(J, obj->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic int O_isSealed_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tif (!O_isSealed_walk(J, ref->left))\n\t\t\treturn 0;\n\tif (!(ref->atts & JS_DONTCONF))\n\t\treturn 0;\n\tif (ref->right->level)\n\t\tif (!O_isSealed_walk(J, ref->right))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void O_isSealed(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tif (obj->extensible) {\n\t\tjs_pushboolean(J, 0);\n\t\treturn;\n\t}\n\n\tif (obj->properties->level)\n\t\tjs_pushboolean(J, O_isSealed_walk(J, obj->properties));\n\telse\n\t\tjs_pushboolean(J, 1);\n}\n\nstatic void O_freeze_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_freeze_walk(J, ref->left);\n\tref->atts |= JS_READONLY | JS_DONTCONF;\n\tif (ref->right->level)\n\t\tO_freeze_walk(J, ref->right);\n}\n\nstatic void O_freeze(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\n\tif (obj->properties->level)\n\t\tO_freeze_walk(J, obj->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic int O_isFrozen_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tif (!O_isFrozen_walk(J, ref->left))\n\t\t\treturn 0;\n\tif (!(ref->atts & JS_READONLY))\n\t\treturn 0;\n\tif (!(ref->atts & JS_DONTCONF))\n\t\treturn 0;\n\tif (ref->right->level)\n\t\tif (!O_isFrozen_walk(J, ref->right))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void O_isFrozen(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\n\tif (obj->properties->level) {\n\t\tif (!O_isFrozen_walk(J, obj->properties)) {\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tjs_pushboolean(J, !obj->extensible);\n}\n\nvoid jsB_initobject(js_State *J)\n{\n\tjs_pushobject(J, J->Object_prototype);\n\t{\n\t\tjsB_propf(J, \"Object.prototype.toString\", Op_toString, 0);\n\t\tjsB_propf(J, \"Object.prototype.toLocaleString\", Op_toString, 0);\n\t\tjsB_propf(J, \"Object.prototype.valueOf\", Op_valueOf, 0);\n\t\tjsB_propf(J, \"Object.prototype.hasOwnProperty\", Op_hasOwnProperty, 1);\n\t\tjsB_propf(J, \"Object.prototype.isPrototypeOf\", Op_isPrototypeOf, 1);\n\t\tjsB_propf(J, \"Object.prototype.propertyIsEnumerable\", Op_propertyIsEnumerable, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Object, jsB_new_Object, \"Object\", 1);\n\t{\n\t\t/* ES5 */\n\t\tjsB_propf(J, \"Object.getPrototypeOf\", O_getPrototypeOf, 1);\n\t\tjsB_propf(J, \"Object.getOwnPropertyDescriptor\", O_getOwnPropertyDescriptor, 2);\n\t\tjsB_propf(J, \"Object.getOwnPropertyNames\", O_getOwnPropertyNames, 1);\n\t\tjsB_propf(J, \"Object.create\", O_create, 2);\n\t\tjsB_propf(J, \"Object.defineProperty\", O_defineProperty, 3);\n\t\tjsB_propf(J, \"Object.defineProperties\", O_defineProperties, 2);\n\t\tjsB_propf(J, \"Object.seal\", O_seal, 1);\n\t\tjsB_propf(J, \"Object.freeze\", O_freeze, 1);\n\t\tjsB_propf(J, \"Object.preventExtensions\", O_preventExtensions, 1);\n\t\tjsB_propf(J, \"Object.isSealed\", O_isSealed, 1);\n\t\tjsB_propf(J, \"Object.isFrozen\", O_isFrozen, 1);\n\t\tjsB_propf(J, \"Object.isExtensible\", O_isExtensible, 1);\n\t\tjsB_propf(J, \"Object.keys\", O_keys, 1);\n\t}\n\tjs_defglobal(J, \"Object\", JS_DONTENUM);\n}\n"], "fixing_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n\nstatic void jsB_new_Object(js_State *J)\n{\n\tif (js_isundefined(J, 1) || js_isnull(J, 1))\n\t\tjs_newobject(J);\n\telse\n\t\tjs_pushobject(J, js_toobject(J, 1));\n}\n\nstatic void jsB_Object(js_State *J)\n{\n\tif (js_isundefined(J, 1) || js_isnull(J, 1))\n\t\tjs_newobject(J);\n\telse\n\t\tjs_pushobject(J, js_toobject(J, 1));\n}\n\nstatic void Op_toString(js_State *J)\n{\n\tif (js_isundefined(J, 0))\n\t\tjs_pushliteral(J, \"[object Undefined]\");\n\telse if (js_isnull(J, 0))\n\t\tjs_pushliteral(J, \"[object Null]\");\n\telse {\n\t\tjs_Object *self = js_toobject(J, 0);\n\t\tswitch (self->type) {\n\t\tcase JS_COBJECT: js_pushliteral(J, \"[object Object]\"); break;\n\t\tcase JS_CARRAY: js_pushliteral(J, \"[object Array]\"); break;\n\t\tcase JS_CFUNCTION: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CSCRIPT: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CCFUNCTION: js_pushliteral(J, \"[object Function]\"); break;\n\t\tcase JS_CERROR: js_pushliteral(J, \"[object Error]\"); break;\n\t\tcase JS_CBOOLEAN: js_pushliteral(J, \"[object Boolean]\"); break;\n\t\tcase JS_CNUMBER: js_pushliteral(J, \"[object Number]\"); break;\n\t\tcase JS_CSTRING: js_pushliteral(J, \"[object String]\"); break;\n\t\tcase JS_CREGEXP: js_pushliteral(J, \"[object RegExp]\"); break;\n\t\tcase JS_CDATE: js_pushliteral(J, \"[object Date]\"); break;\n\t\tcase JS_CMATH: js_pushliteral(J, \"[object Math]\"); break;\n\t\tcase JS_CJSON: js_pushliteral(J, \"[object JSON]\"); break;\n\t\tcase JS_CARGUMENTS: js_pushliteral(J, \"[object Arguments]\"); break;\n\t\tcase JS_CITERATOR: js_pushliteral(J, \"[object Iterator]\"); break;\n\t\tcase JS_CUSERDATA:\n\t\t\tjs_pushliteral(J, \"[object \");\n\t\t\tjs_pushliteral(J, self->u.user.tag);\n\t\t\tjs_concat(J);\n\t\t\tjs_pushliteral(J, \"]\");\n\t\t\tjs_concat(J);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void Op_valueOf(js_State *J)\n{\n\tjs_copy(J, 0);\n}\n\nstatic void Op_hasOwnProperty(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tconst char *name = js_tostring(J, 1);\n\tjs_Property *ref;\n\tint k;\n\n\tif (self->type == JS_CSTRING) {\n\t\tif (js_isarrayindex(J, name, &k) && k >= 0 && k < self->u.s.length) {\n\t\t\tjs_pushboolean(J, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (self->type == JS_CARRAY && self->u.a.simple) {\n\t\tif (js_isarrayindex(J, name, &k) && k >= 0 && k < self->u.a.length) {\n\t\t\tjs_pushboolean(J, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tref = jsV_getownproperty(J, self, name);\n\tjs_pushboolean(J, ref != NULL);\n}\n\nstatic void Op_isPrototypeOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (js_isobject(J, 1)) {\n\t\tjs_Object *V = js_toobject(J, 1);\n\t\tdo {\n\t\t\tV = V->prototype;\n\t\t\tif (V == self) {\n\t\t\t\tjs_pushboolean(J, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} while (V);\n\t}\n\tjs_pushboolean(J, 0);\n}\n\nstatic void Op_propertyIsEnumerable(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tconst char *name = js_tostring(J, 1);\n\tjs_Property *ref = jsV_getownproperty(J, self, name);\n\tjs_pushboolean(J, ref && !(ref->atts & JS_DONTENUM));\n}\n\nstatic void O_getPrototypeOf(js_State *J)\n{\n\tjs_Object *obj;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tif (obj->prototype)\n\t\tjs_pushobject(J, obj->prototype);\n\telse\n\t\tjs_pushnull(J);\n}\n\nstatic void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\t// TODO: builtin properties (string and array index and length, regexp flags, etc)\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_defproperty(J, -2, \"value\", 0);\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_defproperty(J, -2, \"writable\", 0);\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_defproperty(J, -2, \"get\", 0);\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_defproperty(J, -2, \"set\", 0);\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_defproperty(J, -2, \"enumerable\", 0);\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_defproperty(J, -2, \"configurable\", 0);\n\t}\n}\n\nstatic int O_getOwnPropertyNames_walk(js_State *J, js_Property *ref, int i)\n{\n\tif (ref->left->level)\n\t\ti = O_getOwnPropertyNames_walk(J, ref->left, i);\n\tjs_pushliteral(J, ref->name);\n\tjs_setindex(J, -2, i++);\n\tif (ref->right->level)\n\t\ti = O_getOwnPropertyNames_walk(J, ref->right, i);\n\treturn i;\n}\n\nstatic void O_getOwnPropertyNames(js_State *J)\n{\n\tjs_Object *obj;\n\tchar name[32];\n\tint k;\n\tint i;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\n\tjs_newarray(J);\n\n\tif (obj->properties->level)\n\t\ti = O_getOwnPropertyNames_walk(J, obj->properties, 0);\n\telse\n\t\ti = 0;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tjs_pushliteral(J, \"length\");\n\t\tjs_setindex(J, -2, i++);\n\t\tif (obj->u.a.simple) {\n\t\t\tfor (k = 0; k < obj->u.a.length; ++k) {\n\t\t\t\tjs_itoa(name, k);\n\t\t\t\tjs_pushstring(J, name);\n\t\t\t\tjs_setindex(J, -2, i++);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->type == JS_CSTRING) {\n\t\tjs_pushliteral(J, \"length\");\n\t\tjs_setindex(J, -2, i++);\n\t\tfor (k = 0; k < obj->u.s.length; ++k) {\n\t\t\tjs_itoa(name, k);\n\t\t\tjs_pushstring(J, name);\n\t\t\tjs_setindex(J, -2, i++);\n\t\t}\n\t}\n\n\tif (obj->type == JS_CREGEXP) {\n\t\tjs_pushliteral(J, \"source\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"global\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"ignoreCase\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"multiline\");\n\t\tjs_setindex(J, -2, i++);\n\t\tjs_pushliteral(J, \"lastIndex\");\n\t\tjs_setindex(J, -2, i++);\n\t}\n}\n\nstatic void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_defproperty(J, -3, name, 0);\n\t}\n\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\n\tjs_defaccessor(J, -4, name, atts);\n\n\tjs_pop(J, 2);\n}\n\nstatic void O_defineProperty(js_State *J)\n{\n\tif (!js_isobject(J, 1)) js_typeerror(J, \"not an object\");\n\tif (!js_isobject(J, 3)) js_typeerror(J, \"not an object\");\n\tToPropertyDescriptor(J, js_toobject(J, 1), js_tostring(J, 2), js_toobject(J, 3));\n\tjs_copy(J, 1);\n}\n\nstatic void O_defineProperties_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_defineProperties_walk(J, ref->left);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tjs_pushvalue(J, ref->value);\n\t\tToPropertyDescriptor(J, js_toobject(J, 1), ref->name, js_toobject(J, -1));\n\t\tjs_pop(J, 1);\n\t}\n\tif (ref->right->level)\n\t\tO_defineProperties_walk(J, ref->right);\n}\n\nstatic void O_defineProperties(js_State *J)\n{\n\tjs_Object *props;\n\n\tif (!js_isobject(J, 1)) js_typeerror(J, \"not an object\");\n\tif (!js_isobject(J, 2)) js_typeerror(J, \"not an object\");\n\n\tprops = js_toobject(J, 2);\n\tif (props->properties->level)\n\t\tO_defineProperties_walk(J, props->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic void O_create_walk(js_State *J, js_Object *obj, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_create_walk(J, obj, ref->left);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tif (ref->value.type != JS_TOBJECT)\n\t\t\tjs_typeerror(J, \"not an object\");\n\t\tToPropertyDescriptor(J, obj, ref->name, ref->value.u.object);\n\t}\n\tif (ref->right->level)\n\t\tO_create_walk(J, obj, ref->right);\n}\n\nstatic void O_create(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Object *proto;\n\tjs_Object *props;\n\n\tif (js_isobject(J, 1))\n\t\tproto = js_toobject(J, 1);\n\telse if (js_isnull(J, 1))\n\t\tproto = NULL;\n\telse\n\t\tjs_typeerror(J, \"not an object or null\");\n\n\tobj = jsV_newobject(J, JS_COBJECT, proto);\n\tjs_pushobject(J, obj);\n\n\tif (js_isdefined(J, 2)) {\n\t\tif (!js_isobject(J, 2))\n\t\t\tjs_typeerror(J, \"not an object\");\n\t\tprops = js_toobject(J, 2);\n\t\tif (props->properties->level)\n\t\t\tO_create_walk(J, obj, props->properties);\n\t}\n}\n\nstatic int O_keys_walk(js_State *J, js_Property *ref, int i)\n{\n\tif (ref->left->level)\n\t\ti = O_keys_walk(J, ref->left, i);\n\tif (!(ref->atts & JS_DONTENUM)) {\n\t\tjs_pushliteral(J, ref->name);\n\t\tjs_setindex(J, -2, i++);\n\t}\n\tif (ref->right->level)\n\t\ti = O_keys_walk(J, ref->right, i);\n\treturn i;\n}\n\nstatic void O_keys(js_State *J)\n{\n\tjs_Object *obj;\n\tint i, k;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\n\tjs_newarray(J);\n\n\tif (obj->properties->level)\n\t\ti = O_keys_walk(J, obj->properties, 0);\n\telse\n\t\ti = 0;\n\n\tif (obj->type == JS_CSTRING) {\n\t\tfor (k = 0; k < obj->u.s.length; ++k) {\n\t\t\tjs_pushnumber(J, k);\n\t\t\tjs_setindex(J, -2, i++);\n\t\t}\n\t}\n}\n\nstatic void O_preventExtensions(js_State *J)\n{\n\tjs_Object *obj;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\tjs_copy(J, 1);\n}\n\nstatic void O_isExtensible(js_State *J)\n{\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tjs_pushboolean(J, js_toobject(J, 1)->extensible);\n}\n\nstatic void O_seal_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_seal_walk(J, ref->left);\n\tref->atts |= JS_DONTCONF;\n\tif (ref->right->level)\n\t\tO_seal_walk(J, ref->right);\n}\n\nstatic void O_seal(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\n\tif (obj->properties->level)\n\t\tO_seal_walk(J, obj->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic int O_isSealed_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tif (!O_isSealed_walk(J, ref->left))\n\t\t\treturn 0;\n\tif (!(ref->atts & JS_DONTCONF))\n\t\treturn 0;\n\tif (ref->right->level)\n\t\tif (!O_isSealed_walk(J, ref->right))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void O_isSealed(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tif (obj->extensible) {\n\t\tjs_pushboolean(J, 0);\n\t\treturn;\n\t}\n\n\tif (obj->properties->level)\n\t\tjs_pushboolean(J, O_isSealed_walk(J, obj->properties));\n\telse\n\t\tjs_pushboolean(J, 1);\n}\n\nstatic void O_freeze_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tO_freeze_walk(J, ref->left);\n\tref->atts |= JS_READONLY | JS_DONTCONF;\n\tif (ref->right->level)\n\t\tO_freeze_walk(J, ref->right);\n}\n\nstatic void O_freeze(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\tjsR_unflattenarray(J, obj);\n\tobj->extensible = 0;\n\n\tif (obj->properties->level)\n\t\tO_freeze_walk(J, obj->properties);\n\n\tjs_copy(J, 1);\n}\n\nstatic int O_isFrozen_walk(js_State *J, js_Property *ref)\n{\n\tif (ref->left->level)\n\t\tif (!O_isFrozen_walk(J, ref->left))\n\t\t\treturn 0;\n\tif (!(ref->atts & JS_READONLY))\n\t\treturn 0;\n\tif (!(ref->atts & JS_DONTCONF))\n\t\treturn 0;\n\tif (ref->right->level)\n\t\tif (!O_isFrozen_walk(J, ref->right))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void O_isFrozen(js_State *J)\n{\n\tjs_Object *obj;\n\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\n\tobj = js_toobject(J, 1);\n\n\tif (obj->properties->level) {\n\t\tif (!O_isFrozen_walk(J, obj->properties)) {\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tjs_pushboolean(J, !obj->extensible);\n}\n\nvoid jsB_initobject(js_State *J)\n{\n\tjs_pushobject(J, J->Object_prototype);\n\t{\n\t\tjsB_propf(J, \"Object.prototype.toString\", Op_toString, 0);\n\t\tjsB_propf(J, \"Object.prototype.toLocaleString\", Op_toString, 0);\n\t\tjsB_propf(J, \"Object.prototype.valueOf\", Op_valueOf, 0);\n\t\tjsB_propf(J, \"Object.prototype.hasOwnProperty\", Op_hasOwnProperty, 1);\n\t\tjsB_propf(J, \"Object.prototype.isPrototypeOf\", Op_isPrototypeOf, 1);\n\t\tjsB_propf(J, \"Object.prototype.propertyIsEnumerable\", Op_propertyIsEnumerable, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Object, jsB_new_Object, \"Object\", 1);\n\t{\n\t\t/* ES5 */\n\t\tjsB_propf(J, \"Object.getPrototypeOf\", O_getPrototypeOf, 1);\n\t\tjsB_propf(J, \"Object.getOwnPropertyDescriptor\", O_getOwnPropertyDescriptor, 2);\n\t\tjsB_propf(J, \"Object.getOwnPropertyNames\", O_getOwnPropertyNames, 1);\n\t\tjsB_propf(J, \"Object.create\", O_create, 2);\n\t\tjsB_propf(J, \"Object.defineProperty\", O_defineProperty, 3);\n\t\tjsB_propf(J, \"Object.defineProperties\", O_defineProperties, 2);\n\t\tjsB_propf(J, \"Object.seal\", O_seal, 1);\n\t\tjsB_propf(J, \"Object.freeze\", O_freeze, 1);\n\t\tjsB_propf(J, \"Object.preventExtensions\", O_preventExtensions, 1);\n\t\tjsB_propf(J, \"Object.isSealed\", O_isSealed, 1);\n\t\tjsB_propf(J, \"Object.isFrozen\", O_isFrozen, 1);\n\t\tjsB_propf(J, \"Object.isExtensible\", O_isExtensible, 1);\n\t\tjsB_propf(J, \"Object.keys\", O_keys, 1);\n\t}\n\tjs_defglobal(J, \"Object\", JS_DONTENUM);\n}\n"], "filenames": ["jsobject.c"], "buggy_code_start_loc": [137], "buggy_code_end_loc": [252], "fixing_code_start_loc": [137], "fixing_code_end_loc": [252], "type": "CWE-119", "message": "A logical issue in O_getOwnPropertyDescriptor() in Artifex MuJS 1.0.0 through 1.3.x before 1.3.2 allows an attacker to achieve Remote Code Execution through memory corruption, via the loading of a crafted JavaScript file.", "other": {"cve": {"id": "CVE-2022-44789", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-23T21:15:11.167", "lastModified": "2023-02-01T15:59:10.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A logical issue in O_getOwnPropertyDescriptor() in Artifex MuJS 1.0.0 through 1.3.x before 1.3.2 allows an attacker to achieve Remote Code Execution through memory corruption, via the loading of a crafted JavaScript file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mujs:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.3.2", "matchCriteriaId": "8A2B9F74-4DBF-4E5E-86F2-C2C8698FB4DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/alalng/CVE-2022-44789/blob/main/PublicReferenceURL.txt", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ccxvii/mujs/commit/edb50ad66f7601ca9a3544a0e9045e8a8c60561f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ccxvii/mujs/releases/tag/1.3.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MC6PLHTXHZ7GW7QQGTLBHLXL47UHTHXO/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5291", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ccxvii/mujs/commit/edb50ad66f7601ca9a3544a0e9045e8a8c60561f"}}