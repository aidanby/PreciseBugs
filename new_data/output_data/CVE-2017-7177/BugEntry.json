{"buggy_code": ["/* Copyright (C) 2007-2012 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n#include \"suricata-common.h\"\n#include \"conf.h\"\n#include \"defrag-hash.h\"\n#include \"defrag-queue.h\"\n#include \"defrag-config.h\"\n#include \"util-random.h\"\n#include \"util-byte.h\"\n#include \"util-misc.h\"\n#include \"util-hash-lookup3.h\"\n\nstatic DefragTracker *DefragTrackerGetUsedDefragTracker(void);\n\n/** queue with spare tracker */\nstatic DefragTrackerQueue defragtracker_spare_q;\n\nuint32_t DefragTrackerSpareQueueGetSize(void)\n{\n    return DefragTrackerQueueLen(&defragtracker_spare_q);\n}\n\nvoid DefragTrackerMoveToSpare(DefragTracker *h)\n{\n    DefragTrackerEnqueue(&defragtracker_spare_q, h);\n    (void) SC_ATOMIC_SUB(defragtracker_counter, 1);\n}\n\nDefragTracker *DefragTrackerAlloc(void)\n{\n    if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n        return NULL;\n    }\n\n    (void) SC_ATOMIC_ADD(defrag_memuse, sizeof(DefragTracker));\n\n    DefragTracker *dt = SCMalloc(sizeof(DefragTracker));\n    if (unlikely(dt == NULL))\n        goto error;\n\n    memset(dt, 0x00, sizeof(DefragTracker));\n\n    SCMutexInit(&dt->lock, NULL);\n    SC_ATOMIC_INIT(dt->use_cnt);\n    return dt;\n\nerror:\n    return NULL;\n}\n\nvoid DefragTrackerFree(DefragTracker *dt)\n{\n    if (dt != NULL) {\n        DefragTrackerClearMemory(dt);\n\n        SCMutexDestroy(&dt->lock);\n        SCFree(dt);\n        (void) SC_ATOMIC_SUB(defrag_memuse, sizeof(DefragTracker));\n    }\n}\n\n#define DefragTrackerIncrUsecnt(dt) \\\n    SC_ATOMIC_ADD((dt)->use_cnt, 1)\n#define DefragTrackerDecrUsecnt(dt) \\\n    SC_ATOMIC_SUB((dt)->use_cnt, 1)\n\nstatic void DefragTrackerInit(DefragTracker *dt, Packet *p)\n{\n    /* copy address */\n    COPY_ADDRESS(&p->src, &dt->src_addr);\n    COPY_ADDRESS(&p->dst, &dt->dst_addr);\n\n    if (PKT_IS_IPV4(p)) {\n        dt->id = (int32_t)IPV4_GET_IPID(p);\n        dt->af = AF_INET;\n    } else {\n        dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n        dt->af = AF_INET6;\n    }\n    dt->vlan_id[0] = p->vlan_id[0];\n    dt->vlan_id[1] = p->vlan_id[1];\n    dt->policy = DefragGetOsPolicy(p);\n    dt->host_timeout = DefragPolicyGetHostTimeout(p);\n    dt->remove = 0;\n    dt->seen_last = 0;\n\n    TAILQ_INIT(&dt->frags);\n    (void) DefragTrackerIncrUsecnt(dt);\n}\n\nvoid DefragTrackerRelease(DefragTracker *t)\n{\n    (void) DefragTrackerDecrUsecnt(t);\n    SCMutexUnlock(&t->lock);\n}\n\nvoid DefragTrackerClearMemory(DefragTracker *dt)\n{\n    DefragTrackerFreeFrags(dt);\n    SC_ATOMIC_DESTROY(dt->use_cnt);\n}\n\n#define DEFRAG_DEFAULT_HASHSIZE 4096\n#define DEFRAG_DEFAULT_MEMCAP 16777216\n#define DEFRAG_DEFAULT_PREALLOC 1000\n\n/** \\brief initialize the configuration\n *  \\warning Not thread safe */\nvoid DefragInitConfig(char quiet)\n{\n    SCLogDebug(\"initializing defrag engine...\");\n\n    memset(&defrag_config,  0, sizeof(defrag_config));\n    //SC_ATOMIC_INIT(flow_flags);\n    SC_ATOMIC_INIT(defragtracker_counter);\n    SC_ATOMIC_INIT(defrag_memuse);\n    SC_ATOMIC_INIT(defragtracker_prune_idx);\n    DefragTrackerQueueInit(&defragtracker_spare_q);\n\n#ifndef AFLFUZZ_NO_RANDOM\n    unsigned int seed = RandomTimePreseed();\n    /* set defaults */\n    defrag_config.hash_rand   = (int)(DEFRAG_DEFAULT_HASHSIZE * (rand_r(&seed) / RAND_MAX + 1.0));\n#endif\n    defrag_config.hash_size   = DEFRAG_DEFAULT_HASHSIZE;\n    defrag_config.memcap      = DEFRAG_DEFAULT_MEMCAP;\n    defrag_config.prealloc    = DEFRAG_DEFAULT_PREALLOC;\n\n    /* Check if we have memcap and hash_size defined at config */\n    char *conf_val;\n    uint32_t configval = 0;\n\n    /** set config values for memcap, prealloc and hash_size */\n    if ((ConfGet(\"defrag.memcap\", &conf_val)) == 1)\n    {\n        if (ParseSizeStringU64(conf_val, &defrag_config.memcap) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing defrag.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       conf_val);\n            exit(EXIT_FAILURE);\n        }\n    }\n    if ((ConfGet(\"defrag.hash-size\", &conf_val)) == 1)\n    {\n        if (ByteExtractStringUint32(&configval, 10, strlen(conf_val),\n                                    conf_val) > 0) {\n            defrag_config.hash_size = configval;\n        } else {\n            WarnInvalidConfEntry(\"defrag.hash-size\", \"%\"PRIu32, defrag_config.hash_size);\n        }\n    }\n\n\n    if ((ConfGet(\"defrag.trackers\", &conf_val)) == 1)\n    {\n        if (ByteExtractStringUint32(&configval, 10, strlen(conf_val),\n                                    conf_val) > 0) {\n            defrag_config.prealloc = configval;\n        } else {\n            WarnInvalidConfEntry(\"defrag.trackers\", \"%\"PRIu32, defrag_config.prealloc);\n        }\n    }\n    SCLogDebug(\"DefragTracker config from suricata.yaml: memcap: %\"PRIu64\", hash-size: \"\n               \"%\"PRIu32\", prealloc: %\"PRIu32, defrag_config.memcap,\n               defrag_config.hash_size, defrag_config.prealloc);\n\n    /* alloc hash memory */\n    uint64_t hash_size = defrag_config.hash_size * sizeof(DefragTrackerHashRow);\n    if (!(DEFRAG_CHECK_MEMCAP(hash_size))) {\n        SCLogError(SC_ERR_DEFRAG_INIT, \"allocating defrag hash failed: \"\n                \"max defrag memcap is smaller than projected hash size. \"\n                \"Memcap: %\"PRIu64\", Hash table size %\"PRIu64\". Calculate \"\n                \"total hash size by multiplying \\\"defrag.hash-size\\\" with %\"PRIuMAX\", \"\n                \"which is the hash bucket size.\", defrag_config.memcap, hash_size,\n                (uintmax_t)sizeof(DefragTrackerHashRow));\n        exit(EXIT_FAILURE);\n    }\n    defragtracker_hash = SCCalloc(defrag_config.hash_size, sizeof(DefragTrackerHashRow));\n    if (unlikely(defragtracker_hash == NULL)) {\n        SCLogError(SC_ERR_FATAL, \"Fatal error encountered in DefragTrackerInitConfig. Exiting...\");\n        exit(EXIT_FAILURE);\n    }\n    memset(defragtracker_hash, 0, defrag_config.hash_size * sizeof(DefragTrackerHashRow));\n\n    uint32_t i = 0;\n    for (i = 0; i < defrag_config.hash_size; i++) {\n        DRLOCK_INIT(&defragtracker_hash[i]);\n    }\n    (void) SC_ATOMIC_ADD(defrag_memuse, (defrag_config.hash_size * sizeof(DefragTrackerHashRow)));\n\n    if (quiet == FALSE) {\n        SCLogConfig(\"allocated %llu bytes of memory for the defrag hash... \"\n                  \"%\" PRIu32 \" buckets of size %\" PRIuMAX \"\",\n                  SC_ATOMIC_GET(defrag_memuse), defrag_config.hash_size,\n                  (uintmax_t)sizeof(DefragTrackerHashRow));\n    }\n\n    if ((ConfGet(\"defrag.prealloc\", &conf_val)) == 1)\n    {\n        if (ConfValIsTrue(conf_val)) {\n            /* pre allocate defrag trackers */\n            for (i = 0; i < defrag_config.prealloc; i++) {\n                if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n                    SCLogError(SC_ERR_DEFRAG_INIT, \"preallocating defrag trackers failed: \"\n                            \"max defrag memcap reached. Memcap %\"PRIu64\", \"\n                            \"Memuse %\"PRIu64\".\", defrag_config.memcap,\n                            ((uint64_t)SC_ATOMIC_GET(defrag_memuse) + (uint64_t)sizeof(DefragTracker)));\n                    exit(EXIT_FAILURE);\n                }\n\n                DefragTracker *h = DefragTrackerAlloc();\n                if (h == NULL) {\n                    SCLogError(SC_ERR_DEFRAG_INIT, \"preallocating defrag failed: %s\", strerror(errno));\n                    exit(EXIT_FAILURE);\n                }\n                DefragTrackerEnqueue(&defragtracker_spare_q,h);\n            }\n            if (quiet == FALSE) {\n                SCLogConfig(\"preallocated %\" PRIu32 \" defrag trackers of size %\" PRIuMAX \"\",\n                        defragtracker_spare_q.len, (uintmax_t)sizeof(DefragTracker));\n            }\n        }\n    }\n\n    if (quiet == FALSE) {\n        SCLogConfig(\"defrag memory usage: %llu bytes, maximum: %\"PRIu64,\n                SC_ATOMIC_GET(defrag_memuse), defrag_config.memcap);\n    }\n\n    return;\n}\n\n/** \\brief print some defrag stats\n *  \\warning Not thread safe */\nstatic void DefragTrackerPrintStats (void)\n{\n}\n\n/** \\brief shutdown the flow engine\n *  \\warning Not thread safe */\nvoid DefragHashShutdown(void)\n{\n    DefragTracker *dt;\n    uint32_t u;\n\n    DefragTrackerPrintStats();\n\n    /* free spare queue */\n    while((dt = DefragTrackerDequeue(&defragtracker_spare_q))) {\n        BUG_ON(SC_ATOMIC_GET(dt->use_cnt) > 0);\n        DefragTrackerFree(dt);\n    }\n\n    /* clear and free the hash */\n    if (defragtracker_hash != NULL) {\n        for (u = 0; u < defrag_config.hash_size; u++) {\n            dt = defragtracker_hash[u].head;\n            while (dt) {\n                DefragTracker *n = dt->hnext;\n                DefragTrackerClearMemory(dt);\n                DefragTrackerFree(dt);\n                dt = n;\n            }\n\n            DRLOCK_DESTROY(&defragtracker_hash[u]);\n        }\n        SCFree(defragtracker_hash);\n        defragtracker_hash = NULL;\n    }\n    (void) SC_ATOMIC_SUB(defrag_memuse, defrag_config.hash_size * sizeof(DefragTrackerHashRow));\n    DefragTrackerQueueDestroy(&defragtracker_spare_q);\n\n    SC_ATOMIC_DESTROY(defragtracker_prune_idx);\n    SC_ATOMIC_DESTROY(defrag_memuse);\n    SC_ATOMIC_DESTROY(defragtracker_counter);\n    //SC_ATOMIC_DESTROY(flow_flags);\n    return;\n}\n\n/** \\brief compare two raw ipv6 addrs\n *\n *  \\note we don't care about the real ipv6 ip's, this is just\n *        to consistently fill the DefragHashKey6 struct, without all\n *        the ntohl calls.\n *\n *  \\warning do not use elsewhere unless you know what you're doing.\n *           detect-engine-address-ipv6.c's AddressIPv6GtU32 is likely\n *           what you are looking for.\n */\nstatic inline int DefragHashRawAddressIPv6GtU32(uint32_t *a, uint32_t *b)\n{\n    int i;\n\n    for (i = 0; i < 4; i++) {\n        if (a[i] > b[i])\n            return 1;\n        if (a[i] < b[i])\n            break;\n    }\n\n    return 0;\n}\n\ntypedef struct DefragHashKey4_ {\n    union {\n        struct {\n            uint32_t src, dst;\n            uint32_t id;\n            uint16_t vlan_id[2];\n        };\n        uint32_t u32[4];\n    };\n} DefragHashKey4;\n\ntypedef struct DefragHashKey6_ {\n    union {\n        struct {\n            uint32_t src[4], dst[4];\n            uint32_t id;\n            uint16_t vlan_id[2];\n        };\n        uint32_t u32[10];\n    };\n} DefragHashKey6;\n\n/* calculate the hash key for this packet\n *\n * we're using:\n *  hash_rand -- set at init time\n *  source address\n *  destination address\n *  id\n *  vlan_id\n */\nstatic inline uint32_t DefragHashGetKey(Packet *p)\n{\n    uint32_t key;\n\n    if (p->ip4h != NULL) {\n        DefragHashKey4 dhk;\n        if (p->src.addr_data32[0] > p->dst.addr_data32[0]) {\n            dhk.src = p->src.addr_data32[0];\n            dhk.dst = p->dst.addr_data32[0];\n        } else {\n            dhk.src = p->dst.addr_data32[0];\n            dhk.dst = p->src.addr_data32[0];\n        }\n        dhk.id = (uint32_t)IPV4_GET_IPID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 4, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else if (p->ip6h != NULL) {\n        DefragHashKey6 dhk;\n        if (DefragHashRawAddressIPv6GtU32(p->src.addr_data32, p->dst.addr_data32)) {\n            dhk.src[0] = p->src.addr_data32[0];\n            dhk.src[1] = p->src.addr_data32[1];\n            dhk.src[2] = p->src.addr_data32[2];\n            dhk.src[3] = p->src.addr_data32[3];\n            dhk.dst[0] = p->dst.addr_data32[0];\n            dhk.dst[1] = p->dst.addr_data32[1];\n            dhk.dst[2] = p->dst.addr_data32[2];\n            dhk.dst[3] = p->dst.addr_data32[3];\n        } else {\n            dhk.src[0] = p->dst.addr_data32[0];\n            dhk.src[1] = p->dst.addr_data32[1];\n            dhk.src[2] = p->dst.addr_data32[2];\n            dhk.src[3] = p->dst.addr_data32[3];\n            dhk.dst[0] = p->src.addr_data32[0];\n            dhk.dst[1] = p->src.addr_data32[1];\n            dhk.dst[2] = p->src.addr_data32[2];\n            dhk.dst[3] = p->src.addr_data32[3];\n        }\n        dhk.id = IPV6_EXTHDR_GET_FH_ID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 10, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else\n        key = 0;\n\n    return key;\n}\n\n/* Since two or more trackers can have the same hash key, we need to compare\n * the tracker with the current tracker key. */\n#define CMP_DEFRAGTRACKER(d1,d2,id) \\\n    (((CMP_ADDR(&(d1)->src_addr, &(d2)->src) && \\\n       CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n      (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n       CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n     (d1)->id == (id) && \\\n     (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n     (d1)->vlan_id[1] == (d2)->vlan_id[1])\n\nstatic inline int DefragTrackerCompare(DefragTracker *t, Packet *p)\n{\n    uint32_t id;\n    if (PKT_IS_IPV4(p)) {\n        id = (uint32_t)IPV4_GET_IPID(p);\n    } else {\n        id = IPV6_EXTHDR_GET_FH_ID(p);\n    }\n\n    return CMP_DEFRAGTRACKER(t, p, id);\n}\n\n/**\n *  \\brief Get a new defrag tracker\n *\n *  Get a new defrag tracker. We're checking memcap first and will try to make room\n *  if the memcap is reached.\n *\n *  \\retval dt *LOCKED* tracker on succes, NULL on error.\n */\nstatic DefragTracker *DefragTrackerGetNew(Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get a tracker from the spare queue */\n    dt = DefragTrackerDequeue(&defragtracker_spare_q);\n    if (dt == NULL) {\n        /* If we reached the max memcap, we get a used tracker */\n        if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n            /* declare state of emergency */\n            //if (!(SC_ATOMIC_GET(defragtracker_flags) & DEFRAG_EMERGENCY)) {\n            //    SC_ATOMIC_OR(defragtracker_flags, DEFRAG_EMERGENCY);\n\n                /* under high load, waking up the flow mgr each time leads\n                 * to high cpu usage. Flows are not timed out much faster if\n                 * we check a 1000 times a second. */\n            //    FlowWakeupFlowManagerThread();\n            //}\n\n            dt = DefragTrackerGetUsedDefragTracker();\n            if (dt == NULL) {\n                return NULL;\n            }\n\n            /* freed a tracker, but it's unlocked */\n        } else {\n            /* now see if we can alloc a new tracker */\n            dt = DefragTrackerAlloc();\n            if (dt == NULL) {\n                return NULL;\n            }\n\n            /* tracker is initialized but *unlocked* */\n        }\n    } else {\n        /* tracker has been recycled before it went into the spare queue */\n\n        /* tracker is initialized (recylced) but *unlocked* */\n    }\n\n    (void) SC_ATOMIC_ADD(defragtracker_counter, 1);\n    SCMutexLock(&dt->lock);\n    return dt;\n}\n\n/* DefragGetTrackerFromHash\n *\n * Hash retrieval function for trackers. Looks up the hash bucket containing the\n * tracker pointer. Then compares the packet with the found tracker to see if it is\n * the tracker we need. If it isn't, walk the list until the right tracker is found.\n *\n * returns a *LOCKED* tracker or NULL\n */\nDefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get the key to our bucket */\n    uint32_t key = DefragHashGetKey(p);\n    /* get our hash bucket and lock it */\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n\n    /* see if the bucket already has a tracker */\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n\n        /* tracker is locked */\n        hb->head = dt;\n        hb->tail = dt;\n\n        /* got one, now lock, initialize and return */\n        DefragTrackerInit(dt,p);\n\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n\n    /* ok, we have a tracker in the bucket. Let's find out if it is our tracker */\n    dt = hb->head;\n\n    /* see if this is the tracker we are looking for */\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; /* previous tracker */\n\n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n\n                /* tracker is locked */\n\n                dt->hprev = pdt;\n\n                /* initialize and return */\n                DefragTrackerInit(dt,p);\n\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n\n            if (DefragTrackerCompare(dt, p) != 0) {\n                /* we found our tracker, lets put it on top of the\n                 * hash list -- this rewards active trackers */\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n\n                /* found our tracker, lock & return */\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n\n    /* lock & return */\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}\n\n/** \\brief look up a tracker in the hash\n *\n *  \\param a address to look up\n *\n *  \\retval h *LOCKED* tracker or NULL\n */\nDefragTracker *DefragLookupTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get the key to our bucket */\n    uint32_t key = DefragHashGetKey(p);\n    /* get our hash bucket and lock it */\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n\n    /* see if the bucket already has a tracker */\n    if (hb->head == NULL) {\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n\n    /* ok, we have a tracker in the bucket. Let's find out if it is our tracker */\n    dt = hb->head;\n\n    /* see if this is the tracker we are looking for */\n    if (DefragTrackerCompare(dt, p) == 0) {\n        while (dt) {\n            dt = dt->hnext;\n\n            if (dt == NULL) {\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n\n            if (DefragTrackerCompare(dt, p) != 0) {\n                /* we found our tracker, lets put it on top of the\n                 * hash list -- this rewards active tracker */\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n\n                /* found our tracker, lock & return */\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n\n    /* lock & return */\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}\n\n/** \\internal\n *  \\brief Get a tracker from the hash directly.\n *\n *  Called in conditions where the spare queue is empty and memcap is reached.\n *\n *  Walks the hash until a tracker can be freed. \"defragtracker_prune_idx\" atomic int makes\n *  sure we don't start at the top each time since that would clear the top of\n *  the hash leading to longer and longer search times under high pressure (observed).\n *\n *  \\retval dt tracker or NULL\n */\nstatic DefragTracker *DefragTrackerGetUsedDefragTracker(void)\n{\n    uint32_t idx = SC_ATOMIC_GET(defragtracker_prune_idx) % defrag_config.hash_size;\n    uint32_t cnt = defrag_config.hash_size;\n\n    while (cnt--) {\n        if (++idx >= defrag_config.hash_size)\n            idx = 0;\n\n        DefragTrackerHashRow *hb = &defragtracker_hash[idx];\n\n        if (DRLOCK_TRYLOCK(hb) != 0)\n            continue;\n\n        DefragTracker *dt = hb->tail;\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            continue;\n        }\n\n        if (SCMutexTrylock(&dt->lock) != 0) {\n            DRLOCK_UNLOCK(hb);\n            continue;\n        }\n\n        /** never prune a tracker that is used by a packets\n         *  we are currently processing in one of the threads */\n        if (SC_ATOMIC_GET(dt->use_cnt) > 0) {\n            DRLOCK_UNLOCK(hb);\n            SCMutexUnlock(&dt->lock);\n            continue;\n        }\n\n        /* remove from the hash */\n        if (dt->hprev != NULL)\n            dt->hprev->hnext = dt->hnext;\n        if (dt->hnext != NULL)\n            dt->hnext->hprev = dt->hprev;\n        if (hb->head == dt)\n            hb->head = dt->hnext;\n        if (hb->tail == dt)\n            hb->tail = dt->hprev;\n\n        dt->hnext = NULL;\n        dt->hprev = NULL;\n        DRLOCK_UNLOCK(hb);\n\n        DefragTrackerClearMemory(dt);\n\n        SCMutexUnlock(&dt->lock);\n\n        (void) SC_ATOMIC_ADD(defragtracker_prune_idx, (defrag_config.hash_size - cnt));\n        return dt;\n    }\n\n    return NULL;\n}\n\n\n", "/* Copyright (C) 2007-2012 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Endace Technology Limited, Jason Ish <jason.ish@endace.com>\n *\n * Defragmentation module.\n * References:\n *   - RFC 815\n *   - OpenBSD PF's IP normalizaton (pf_norm.c)\n *\n * \\todo pool for frag packet storage\n * \\todo policy bsd-right\n * \\todo profile hash function\n * \\todo log anomalies\n */\n\n#include \"suricata-common.h\"\n\n#include \"queue.h\"\n\n#include \"suricata.h\"\n#include \"threads.h\"\n#include \"conf.h\"\n#include \"decode-ipv6.h\"\n#include \"util-hashlist.h\"\n#include \"util-pool.h\"\n#include \"util-time.h\"\n#include \"util-print.h\"\n#include \"util-debug.h\"\n#include \"util-fix_checksum.h\"\n#include \"util-random.h\"\n#include \"stream-tcp-private.h\"\n#include \"stream-tcp-reassemble.h\"\n#include \"util-host-os-info.h\"\n\n#include \"defrag.h\"\n#include \"defrag-hash.h\"\n#include \"defrag-queue.h\"\n#include \"defrag-config.h\"\n\n#include \"tmqh-packetpool.h\"\n#include \"decode.h\"\n\n#ifdef UNITTESTS\n#include \"util-unittest.h\"\n#endif\n\n#define DEFAULT_DEFRAG_HASH_SIZE 0xffff\n#define DEFAULT_DEFRAG_POOL_SIZE 0xffff\n\n/**\n * Default timeout (in seconds) before a defragmentation tracker will\n * be released.\n */\n#define TIMEOUT_DEFAULT 60\n\n/**\n * Maximum allowed timeout, 24 hours.\n */\n#define TIMEOUT_MAX (60 * 60 * 24)\n\n/**\n * Minimum allowed timeout, 1 second.\n */\n#define TIMEOUT_MIN 1\n\n/** Fragment reassembly policies. */\nenum defrag_policies {\n    DEFRAG_POLICY_FIRST = 1,\n    DEFRAG_POLICY_LAST,\n    DEFRAG_POLICY_BSD,\n    DEFRAG_POLICY_BSD_RIGHT,\n    DEFRAG_POLICY_LINUX,\n    DEFRAG_POLICY_WINDOWS,\n    DEFRAG_POLICY_SOLARIS,\n\n    DEFRAG_POLICY_DEFAULT = DEFRAG_POLICY_BSD,\n};\n\nstatic int default_policy = DEFRAG_POLICY_BSD;\n\n/** The global DefragContext so all threads operate from the same\n * context. */\nstatic DefragContext *defrag_context;\n\n/**\n * Utility/debugging function to dump the frags associated with a\n * tracker.  Only enable when unit tests are enabled.\n */\n#if 0\n#ifdef UNITTESTS\nstatic void\nDumpFrags(DefragTracker *tracker)\n{\n    Frag *frag;\n\n    printf(\"Dumping frags for packet: ID=%d\\n\", tracker->id);\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        printf(\"-> Frag: frag_offset=%d, frag_len=%d, data_len=%d, ltrim=%d, skip=%d\\n\", frag->offset, frag->len, frag->data_len, frag->ltrim, frag->skip);\n        PrintRawDataFp(stdout, frag->pkt, frag->len);\n    }\n}\n#endif /* UNITTESTS */\n#endif\n\n/**\n * \\brief Reset a frag for reuse in a pool.\n */\nstatic void\nDefragFragReset(Frag *frag)\n{\n    if (frag->pkt != NULL)\n        SCFree(frag->pkt);\n    memset(frag, 0, sizeof(*frag));\n}\n\n/**\n * \\brief Allocate a new frag for use in a pool.\n */\nstatic int\nDefragFragInit(void *data, void *initdata)\n{\n    Frag *frag = data;\n\n    memset(frag, 0, sizeof(*frag));\n    return 1;\n}\n\n/**\n * \\brief Free all frags associated with a tracker.\n */\nvoid\nDefragTrackerFreeFrags(DefragTracker *tracker)\n{\n    Frag *frag;\n\n    /* Lock the frag pool as we'll be return items to it. */\n    SCMutexLock(&defrag_context->frag_pool_lock);\n\n    while ((frag = TAILQ_FIRST(&tracker->frags)) != NULL) {\n        TAILQ_REMOVE(&tracker->frags, frag, next);\n\n        /* Don't SCFree the frag, just give it back to its pool. */\n        DefragFragReset(frag);\n        PoolReturn(defrag_context->frag_pool, frag);\n    }\n\n    SCMutexUnlock(&defrag_context->frag_pool_lock);\n}\n\n/**\n * \\brief Create a new DefragContext.\n *\n * \\retval On success a return an initialized DefragContext, otherwise\n *     NULL will be returned.\n */\nstatic DefragContext *\nDefragContextNew(void)\n{\n    DefragContext *dc;\n\n    dc = SCCalloc(1, sizeof(*dc));\n    if (unlikely(dc == NULL))\n        return NULL;\n\n    /* Initialize the pool of trackers. */\n    intmax_t tracker_pool_size;\n    if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size) || tracker_pool_size == 0) {\n        tracker_pool_size = DEFAULT_DEFRAG_HASH_SIZE;\n    }\n\n    /* Initialize the pool of frags. */\n    intmax_t frag_pool_size;\n    if (!ConfGetInt(\"defrag.max-frags\", &frag_pool_size) || frag_pool_size == 0) {\n        frag_pool_size = DEFAULT_DEFRAG_POOL_SIZE;\n    }\n    intmax_t frag_pool_prealloc = frag_pool_size / 2;\n    dc->frag_pool = PoolInit(frag_pool_size, frag_pool_prealloc,\n        sizeof(Frag),\n        NULL, DefragFragInit, dc, NULL, NULL);\n    if (dc->frag_pool == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC,\n            \"Defrag: Failed to initialize fragment pool.\");\n        exit(EXIT_FAILURE);\n    }\n    if (SCMutexInit(&dc->frag_pool_lock, NULL) != 0) {\n        SCLogError(SC_ERR_MUTEX,\n            \"Defrag: Failed to initialize frag pool mutex.\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Set the default timeout. */\n    intmax_t timeout;\n    if (!ConfGetInt(\"defrag.timeout\", &timeout)) {\n        dc->timeout = TIMEOUT_DEFAULT;\n    }\n    else {\n        if (timeout < TIMEOUT_MIN) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT,\n                \"defrag: Timeout less than minimum allowed value.\");\n            exit(EXIT_FAILURE);\n        }\n        else if (timeout > TIMEOUT_MAX) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT,\n                \"defrag: Tiemout greater than maximum allowed value.\");\n            exit(EXIT_FAILURE);\n        }\n        dc->timeout = timeout;\n    }\n\n    SCLogDebug(\"Defrag Initialized:\");\n    SCLogDebug(\"\\tTimeout: %\"PRIuMAX, (uintmax_t)dc->timeout);\n    SCLogDebug(\"\\tMaximum defrag trackers: %\"PRIuMAX, tracker_pool_size);\n    SCLogDebug(\"\\tPreallocated defrag trackers: %\"PRIuMAX, tracker_pool_size);\n    SCLogDebug(\"\\tMaximum fragments: %\"PRIuMAX, (uintmax_t)frag_pool_size);\n    SCLogDebug(\"\\tPreallocated fragments: %\"PRIuMAX, (uintmax_t)frag_pool_prealloc);\n\n    return dc;\n}\n\nstatic void\nDefragContextDestroy(DefragContext *dc)\n{\n    if (dc == NULL)\n        return;\n\n    PoolFree(dc->frag_pool);\n    SCFree(dc);\n}\n\n/**\n * Attempt to re-assemble a packet.\n *\n * \\param tracker The defragmentation tracker to reassemble from.\n */\nstatic Packet *\nDefrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)\n{\n    Packet *rp = NULL;\n\n    /* Should not be here unless we have seen the last fragment. */\n    if (!tracker->seen_last)\n        return NULL;\n\n    /* Check that we have all the data. Relies on the fact that\n     * fragments are inserted if frag_offset order. */\n    Frag *frag;\n    int len = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n\n        if (frag == TAILQ_FIRST(&tracker->frags)) {\n            if (frag->offset != 0) {\n                goto done;\n            }\n            len = frag->data_len;\n        }\n        else {\n            if (frag->offset > len) {\n                /* This fragment starts after the end of the previous\n                 * fragment.  We have a hole. */\n                goto done;\n            }\n            else {\n                len += frag->data_len;\n            }\n        }\n    }\n\n    /* Allocate a Packet for the reassembled packet.  On failure we\n     * SCFree all the resources held by this tracker. */\n    rp = PacketDefragPktSetup(p, NULL, 0, IPV4_GET_IPPROTO(p));\n    if (rp == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"\n                   \"fragmentation re-assembly, dumping fragments.\");\n        goto error_remove_tracker;\n    }\n    PKT_SET_SRC(rp, PKT_SRC_DEFRAG);\n    rp->flags |= PKT_REBUILT_FRAGMENT;\n    rp->recursion_level = p->recursion_level;\n\n    int fragmentable_offset = 0;\n    int fragmentable_len = 0;\n    int hlen = 0;\n    int ip_hdr_offset = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,\n                frag, frag->data_len, frag->offset, frag->pcap_cnt);\n\n        if (frag->skip)\n            continue;\n        if (frag->data_len - frag->ltrim <= 0)\n            continue;\n        if (frag->offset == 0) {\n\n            if (PacketCopyData(rp, frag->pkt, frag->len) == -1)\n                goto error_remove_tracker;\n\n            hlen = frag->hlen;\n            ip_hdr_offset = frag->ip_hdr_offset;\n\n            /* This is the start of the fragmentable portion of the\n             * first packet.  All fragment offsets are relative to\n             * this. */\n            fragmentable_offset = frag->ip_hdr_offset + frag->hlen;\n            fragmentable_len = frag->data_len;\n        }\n        else {\n            int pkt_end = fragmentable_offset + frag->offset + frag->data_len;\n            if (pkt_end > (int)MAX_PAYLOAD_SIZE) {\n                SCLogWarning(SC_ERR_REASSEMBLY, \"Failed re-assemble \"\n                        \"fragmented packet, exceeds size of packet buffer.\");\n                goto error_remove_tracker;\n            }\n            if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,\n                frag->pkt + frag->data_offset + frag->ltrim,\n                frag->data_len - frag->ltrim) == -1) {\n                goto error_remove_tracker;\n            }\n            if (frag->offset + frag->data_len > fragmentable_len)\n                fragmentable_len = frag->offset + frag->data_len;\n        }\n\n        if (!frag->more_frags) {\n            break;\n        }\n    }\n\n    SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",\n            ip_hdr_offset, hlen, fragmentable_len);\n\n    rp->ip4h = (IPV4Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);\n    int old = rp->ip4h->ip_len + rp->ip4h->ip_off;\n    rp->ip4h->ip_len = htons(fragmentable_len + hlen);\n    rp->ip4h->ip_off = 0;\n    rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum,\n        old, rp->ip4h->ip_len + rp->ip4h->ip_off);\n    SET_PKT_LEN(rp, ip_hdr_offset + hlen + fragmentable_len);\n\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\ndone:\n    return rp;\n\nerror_remove_tracker:\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\n    if (rp != NULL)\n        PacketFreeOrRelease(rp);\n    return NULL;\n}\n\n/**\n * Attempt to re-assemble a packet.\n *\n * \\param tracker The defragmentation tracker to reassemble from.\n */\nstatic Packet *\nDefrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)\n{\n    Packet *rp = NULL;\n\n    /* Should not be here unless we have seen the last fragment. */\n    if (!tracker->seen_last)\n        return NULL;\n\n    /* Check that we have all the data. Relies on the fact that\n     * fragments are inserted if frag_offset order. */\n    Frag *frag;\n    int len = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n\n        if (frag == TAILQ_FIRST(&tracker->frags)) {\n            if (frag->offset != 0) {\n                goto done;\n            }\n            len = frag->data_len;\n        }\n        else {\n            if (frag->offset > len) {\n                /* This fragment starts after the end of the previous\n                 * fragment.  We have a hole. */\n                goto done;\n            }\n            else {\n                len += frag->data_len;\n            }\n        }\n    }\n\n    /* Allocate a Packet for the reassembled packet.  On failure we\n     * SCFree all the resources held by this tracker. */\n    rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h,\n            IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);\n    if (rp == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"\n                \"fragmentation re-assembly, dumping fragments.\");\n        goto error_remove_tracker;\n    }\n    PKT_SET_SRC(rp, PKT_SRC_DEFRAG);\n\n    int unfragmentable_len = 0;\n    int fragmentable_offset = 0;\n    int fragmentable_len = 0;\n    int ip_hdr_offset = 0;\n    uint8_t next_hdr = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n        if (frag->data_len - frag->ltrim <= 0)\n            continue;\n        if (frag->offset == 0) {\n            IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt +\n                frag->frag_hdr_offset);\n            next_hdr = frag_hdr->ip6fh_nxt;\n\n            /* This is the first packet, we use this packets link and\n             * IPv6 headers. We also copy in its data, but remove the\n             * fragmentation header. */\n            if (PacketCopyData(rp, frag->pkt, frag->frag_hdr_offset) == -1)\n                goto error_remove_tracker;\n            if (PacketCopyDataOffset(rp, frag->frag_hdr_offset,\n                frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),\n                frag->data_len) == -1)\n                goto error_remove_tracker;\n            ip_hdr_offset = frag->ip_hdr_offset;\n\n            /* This is the start of the fragmentable portion of the\n             * first packet.  All fragment offsets are relative to\n             * this. */\n            fragmentable_offset = frag->frag_hdr_offset;\n            fragmentable_len = frag->data_len;\n\n            /* unfragmentable part is the part between the ipv6 header\n             * and the frag header. */\n            unfragmentable_len = (fragmentable_offset - ip_hdr_offset) - IPV6_HEADER_LEN;\n            if (unfragmentable_len >= fragmentable_offset)\n                goto error_remove_tracker;\n        }\n        else {\n            if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,\n                frag->pkt + frag->data_offset + frag->ltrim,\n                frag->data_len - frag->ltrim) == -1)\n                goto error_remove_tracker;\n            if (frag->offset + frag->data_len > fragmentable_len)\n                fragmentable_len = frag->offset + frag->data_len;\n        }\n\n        if (!frag->more_frags) {\n            break;\n        }\n    }\n\n    rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);\n    rp->ip6h->s_ip6_plen = htons(fragmentable_len + unfragmentable_len);\n    /* if we have no unfragmentable part, so no ext hdrs before the frag\n     * header, we need to update the ipv6 headers next header field. This\n     * points to the frag header, and we will make it point to the layer\n     * directly after the frag header. */\n    if (unfragmentable_len == 0)\n        rp->ip6h->s_ip6_nxt = next_hdr;\n    SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) +\n            unfragmentable_len + fragmentable_len);\n\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\ndone:\n    return rp;\n\nerror_remove_tracker:\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\n    if (rp != NULL)\n        PacketFreeOrRelease(rp);\n    return NULL;\n}\n\n/**\n * Insert a new IPv4/IPv6 fragment into a tracker.\n *\n * \\todo Allocate packet buffers from a pool.\n */\nstatic Packet *\nDefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p, PacketQueue *pq)\n{\n    Packet *r = NULL;\n    int ltrim = 0;\n\n    uint8_t more_frags;\n    uint16_t frag_offset;\n\n    /* IPv4 header length - IPv4 only. */\n    uint16_t hlen = 0;\n\n    /* This is the offset of the start of the data in the packet that\n     * falls after the IP header. */\n    uint16_t data_offset;\n\n    /* The length of the (fragmented) data.  This is the length of the\n     * data that falls after the IP header. */\n    uint16_t data_len;\n\n    /* Where the fragment ends. */\n    uint16_t frag_end;\n\n    /* Offset in the packet to the IPv6 header. */\n    uint16_t ip_hdr_offset;\n\n    /* Offset in the packet to the IPv6 frag header. IPv6 only. */\n    uint16_t frag_hdr_offset = 0;\n\n    /* Address family */\n    int af = tracker->af;\n\n    /* settings for updating a payload when an ip6 fragment with\n     * unfragmentable exthdrs are encountered. */\n    int ip6_nh_set_offset = 0;\n    uint8_t ip6_nh_set_value = 0;\n\n#ifdef DEBUG\n    uint64_t pcap_cnt = p->pcap_cnt;\n#endif\n\n    if (tracker->af == AF_INET) {\n        more_frags = IPV4_GET_MF(p);\n        frag_offset = IPV4_GET_IPOFFSET(p) << 3;\n        hlen = IPV4_GET_HLEN(p);\n        data_offset = (uint8_t *)p->ip4h + hlen - GET_PKT_DATA(p);\n        data_len = IPV4_GET_IPLEN(p) - hlen;\n        frag_end = frag_offset + data_len;\n        ip_hdr_offset = (uint8_t *)p->ip4h - GET_PKT_DATA(p);\n\n        /* Ignore fragment if the end of packet extends past the\n         * maximum size of a packet. */\n        if (IPV4_HEADER_LEN + frag_offset + data_len > IPV4_MAXPACKET_LEN) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE);\n            return NULL;\n        }\n    }\n    else if (tracker->af == AF_INET6) {\n        more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);\n        frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);\n        data_offset = p->ip6eh.fh_data_offset;\n        data_len = p->ip6eh.fh_data_len;\n        frag_end = frag_offset + data_len;\n        ip_hdr_offset = (uint8_t *)p->ip6h - GET_PKT_DATA(p);\n        frag_hdr_offset = p->ip6eh.fh_header_offset;\n\n        SCLogDebug(\"mf %s frag_offset %u data_offset %u, data_len %u, \"\n                \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",\n                more_frags ? \"true\" : \"false\", frag_offset, data_offset,\n                data_len, frag_end, ip_hdr_offset, frag_hdr_offset);\n\n        /* handle unfragmentable exthdrs */\n        if (ip_hdr_offset + IPV6_HEADER_LEN < frag_hdr_offset) {\n            SCLogDebug(\"we have exthdrs before fraghdr %u bytes\",\n                    (uint32_t)(frag_hdr_offset - (ip_hdr_offset + IPV6_HEADER_LEN)));\n\n            /* get the offset of the 'next' field in exthdr before the FH,\n             * relative to the buffer start */\n\n            /* store offset and FH 'next' value for updating frag buffer below */\n            ip6_nh_set_offset = p->ip6eh.fh_prev_hdr_offset;\n            ip6_nh_set_value = IPV6_EXTHDR_GET_FH_NH(p);\n            SCLogDebug(\"offset %d, value %u\", ip6_nh_set_offset, ip6_nh_set_value);\n        }\n\n        /* Ignore fragment if the end of packet extends past the\n         * maximum size of a packet. */\n        if (frag_offset + data_len > IPV6_MAXPACKET) {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_PKT_TOO_LARGE);\n            return NULL;\n        }\n    }\n    else {\n        /* Abort - should not happen. */\n        SCLogWarning(SC_ERR_INVALID_ARGUMENT, \"Invalid address family, aborting.\");\n        return NULL;\n    }\n\n    /* Update timeout. */\n    tracker->timeout.tv_sec = p->ts.tv_sec + tracker->host_timeout;\n    tracker->timeout.tv_usec = p->ts.tv_usec;\n\n    Frag *prev = NULL, *next;\n    int overlap = 0;\n    if (!TAILQ_EMPTY(&tracker->frags)) {\n        TAILQ_FOREACH(prev, &tracker->frags, next) {\n            ltrim = 0;\n            next = TAILQ_NEXT(prev, next);\n\n            switch (tracker->policy) {\n            case DEFRAG_POLICY_BSD:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((next != NULL) && (frag_end > next->offset)) {\n                        next->ltrim = frag_end - next->offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_LINUX:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset > prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((next != NULL) && (frag_end > next->offset)) {\n                        next->ltrim = frag_end - next->offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_WINDOWS:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end > prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_SOLARIS:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_FIRST:\n                if ((frag_offset >= prev->offset) &&\n                    (frag_end <= prev->offset + prev->data_len)) {\n                    overlap++;\n                    goto done;\n                }\n                if (frag_offset < prev->offset) {\n                    goto insert;\n                }\n                if (frag_offset < prev->offset + prev->data_len) {\n                    ltrim = prev->offset + prev->data_len - frag_offset;\n                    overlap++;\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_LAST:\n                if (frag_offset <= prev->offset) {\n                    if (frag_end > prev->offset) {\n                        prev->ltrim = frag_end - prev->offset;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n\ninsert:\n    if (data_len - ltrim <= 0) {\n        /* Full packet has been trimmed due to the overlap policy. Overlap\n         * already set. */\n        goto done;\n    }\n\n    /* Allocate fragment and insert. */\n    SCMutexLock(&defrag_context->frag_pool_lock);\n    Frag *new = PoolGet(defrag_context->frag_pool);\n    SCMutexUnlock(&defrag_context->frag_pool_lock);\n    if (new == NULL) {\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);\n        } else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);\n        }\n        goto done;\n    }\n    new->pkt = SCMalloc(GET_PKT_LEN(p));\n    if (new->pkt == NULL) {\n        SCMutexLock(&defrag_context->frag_pool_lock);\n        PoolReturn(defrag_context->frag_pool, new);\n        SCMutexUnlock(&defrag_context->frag_pool_lock);\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);\n        } else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);\n        }\n        goto done;\n    }\n    memcpy(new->pkt, GET_PKT_DATA(p) + ltrim, GET_PKT_LEN(p) - ltrim);\n    new->len = GET_PKT_LEN(p) - ltrim;\n    /* in case of unfragmentable exthdrs, update the 'next hdr' field\n     * in the raw buffer so the reassembled packet will point to the\n     * correct next header after stripping the frag header */\n    if (ip6_nh_set_offset > 0 && frag_offset == 0 && ltrim == 0) {\n        if (new->len > ip6_nh_set_offset) {\n            SCLogDebug(\"updating frag to have 'correct' nh value: %u -> %u\",\n                    new->pkt[ip6_nh_set_offset], ip6_nh_set_value);\n            new->pkt[ip6_nh_set_offset] = ip6_nh_set_value;\n        }\n    }\n\n    new->hlen = hlen;\n    new->offset = frag_offset + ltrim;\n    new->data_offset = data_offset;\n    new->data_len = data_len - ltrim;\n    new->ip_hdr_offset = ip_hdr_offset;\n    new->frag_hdr_offset = frag_hdr_offset;\n    new->more_frags = more_frags;\n#ifdef DEBUG\n    new->pcap_cnt = pcap_cnt;\n#endif\n\n    Frag *frag;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (new->offset < frag->offset)\n            break;\n    }\n    if (frag == NULL) {\n        TAILQ_INSERT_TAIL(&tracker->frags, new, next);\n    }\n    else {\n        TAILQ_INSERT_BEFORE(frag, new, next);\n    }\n\n    if (!more_frags) {\n        tracker->seen_last = 1;\n    }\n\n    if (tracker->seen_last) {\n        if (tracker->af == AF_INET) {\n            r = Defrag4Reassemble(tv, tracker, p);\n            if (r != NULL && tv != NULL && dtv != NULL) {\n                StatsIncr(tv, dtv->counter_defrag_ipv4_reassembled);\n                if (pq && DecodeIPV4(tv, dtv, r, (void *)r->ip4h,\n                               IPV4_GET_IPLEN(r), pq) != TM_ECODE_OK) {\n\n                    UNSET_TUNNEL_PKT(r);\n                    r->root = NULL;\n                    TmqhOutputPacketpool(tv, r);\n                    r = NULL;\n                } else {\n                    PacketDefragPktSetupParent(p);\n                }\n            }\n        }\n        else if (tracker->af == AF_INET6) {\n            r = Defrag6Reassemble(tv, tracker, p);\n            if (r != NULL && tv != NULL && dtv != NULL) {\n                StatsIncr(tv, dtv->counter_defrag_ipv6_reassembled);\n                if (pq && DecodeIPV6(tv, dtv, r, (uint8_t *)r->ip6h,\n                               IPV6_GET_PLEN(r) + IPV6_HEADER_LEN,\n                               pq) != TM_ECODE_OK) {\n\n                    UNSET_TUNNEL_PKT(r);\n                    r->root = NULL;\n                    TmqhOutputPacketpool(tv, r);\n                    r = NULL;\n                } else {\n                    PacketDefragPktSetupParent(p);\n                }\n            }\n        }\n    }\n\n\ndone:\n    if (overlap) {\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_OVERLAP);\n        }\n        else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_OVERLAP);\n        }\n    }\n    return r;\n}\n\n/**\n * \\brief Get the defrag policy based on the destination address of\n * the packet.\n *\n * \\param p The packet used to get the destination address.\n *\n * \\retval The defrag policy to use.\n */\nuint8_t\nDefragGetOsPolicy(Packet *p)\n{\n    int policy = -1;\n\n    if (PKT_IS_IPV4(p)) {\n        policy = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));\n    }\n    else if (PKT_IS_IPV6(p)) {\n        policy = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));\n    }\n\n    if (policy == -1) {\n        return default_policy;\n    }\n\n    /* Map the OS policies returned from the configured host info to\n     * defrag specific policies. */\n    switch (policy) {\n        /* BSD. */\n    case OS_POLICY_BSD:\n    case OS_POLICY_HPUX10:\n    case OS_POLICY_IRIX:\n        return DEFRAG_POLICY_BSD;\n\n        /* BSD-Right. */\n    case OS_POLICY_BSD_RIGHT:\n        return DEFRAG_POLICY_BSD_RIGHT;\n\n        /* Linux. */\n    case OS_POLICY_OLD_LINUX:\n    case OS_POLICY_LINUX:\n        return DEFRAG_POLICY_LINUX;\n\n        /* First. */\n    case OS_POLICY_OLD_SOLARIS:\n    case OS_POLICY_HPUX11:\n    case OS_POLICY_MACOS:\n    case OS_POLICY_FIRST:\n        return DEFRAG_POLICY_FIRST;\n\n        /* Solaris. */\n    case OS_POLICY_SOLARIS:\n        return DEFRAG_POLICY_SOLARIS;\n\n        /* Windows. */\n    case OS_POLICY_WINDOWS:\n    case OS_POLICY_VISTA:\n    case OS_POLICY_WINDOWS2K3:\n        return DEFRAG_POLICY_WINDOWS;\n\n        /* Last. */\n    case OS_POLICY_LAST:\n        return DEFRAG_POLICY_LAST;\n\n    default:\n        return default_policy;\n    }\n}\n\n/** \\internal\n *\n *  \\retval NULL or a *LOCKED* tracker */\nstatic DefragTracker *\nDefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)\n{\n    return DefragGetTrackerFromHash(p);\n}\n\n/**\n * \\brief Entry point for IPv4 and IPv6 fragments.\n *\n * \\param tv ThreadVars for the calling decoder.\n * \\param p The packet fragment.\n *\n * \\retval A new Packet resembling the re-assembled packet if the most\n *     recent fragment allowed the packet to be re-assembled, otherwise\n *     NULL is returned.\n */\nPacket *\nDefrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, PacketQueue *pq)\n{\n    uint16_t frag_offset;\n    uint8_t more_frags;\n    DefragTracker *tracker;\n    int af;\n\n    if (PKT_IS_IPV4(p)) {\n        af = AF_INET;\n        more_frags = IPV4_GET_MF(p);\n        frag_offset = IPV4_GET_IPOFFSET(p);\n    }\n    else if (PKT_IS_IPV6(p)) {\n        af = AF_INET6;\n        frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);\n        more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);\n    }\n    else {\n        return NULL;\n    }\n\n    if (frag_offset == 0 && more_frags == 0) {\n        return NULL;\n    }\n\n    if (tv != NULL && dtv != NULL) {\n        if (af == AF_INET) {\n            StatsIncr(tv, dtv->counter_defrag_ipv4_fragments);\n        }\n        else if (af == AF_INET6) {\n            StatsIncr(tv, dtv->counter_defrag_ipv6_fragments);\n        }\n    }\n\n    /* return a locked tracker or NULL */\n    tracker = DefragGetTracker(tv, dtv, p);\n    if (tracker == NULL)\n        return NULL;\n\n    Packet *rp = DefragInsertFrag(tv, dtv, tracker, p, pq);\n    DefragTrackerRelease(tracker);\n\n    return rp;\n}\n\nvoid\nDefragInit(void)\n{\n    intmax_t tracker_pool_size;\n    if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size)) {\n        tracker_pool_size = DEFAULT_DEFRAG_HASH_SIZE;\n    }\n\n    /* Load the defrag-per-host lookup. */\n    DefragPolicyLoadFromConfig();\n\n    /* Allocate the DefragContext. */\n    defrag_context = DefragContextNew();\n    if (defrag_context == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC,\n            \"Failed to allocate memory for the Defrag module.\");\n        exit(EXIT_FAILURE);\n    }\n\n    DefragSetDefaultTimeout(defrag_context->timeout);\n    DefragInitConfig(FALSE);\n}\n\nvoid DefragDestroy(void)\n{\n    DefragHashShutdown();\n    DefragContextDestroy(defrag_context);\n    defrag_context = NULL;\n    DefragTreeDestroy();\n}\n\n#ifdef UNITTESTS\n#define IP_MF 0x2000\n\n/**\n * Allocate a test packet.  Nothing to fancy, just a simple IP packet\n * with some payload of no particular protocol.\n */\nstatic Packet *\nBuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n    int content_len)\n{\n    Packet *p = NULL;\n    int hlen = 20;\n    int ttl = 64;\n    uint8_t *pcontent;\n    IPV4Hdr ip4h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n    //p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n    ip4h.ip_verhl = 4 << 4;\n    ip4h.ip_verhl |= hlen >> 2;\n    ip4h.ip_len = htons(hlen + content_len);\n    ip4h.ip_id = htons(id);\n    ip4h.ip_off = htons(off);\n    if (mf)\n        ip4h.ip_off = htons(IP_MF | off);\n    else\n        ip4h.ip_off = htons(off);\n    ip4h.ip_ttl = ttl;\n    ip4h.ip_proto = IPPROTO_ICMP;\n\n    ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n    ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));\n    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n    SET_IPV4_SRC_ADDR(p, &p->src);\n    SET_IPV4_DST_ADDR(p, &p->dst);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, hlen, pcontent, content_len);\n    SET_PKT_LEN(p, hlen + content_len);\n    SCFree(pcontent);\n\n    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);\n\n    /* Self test. */\n    if (IPV4_GET_VER(p) != 4)\n        goto error;\n    if (IPV4_GET_HLEN(p) != hlen)\n        goto error;\n    if (IPV4_GET_IPLEN(p) != hlen + content_len)\n        goto error;\n    if (IPV4_GET_IPID(p) != id)\n        goto error;\n    if (IPV4_GET_IPOFFSET(p) != off)\n        goto error;\n    if (IPV4_GET_MF(p) != mf)\n        goto error;\n    if (IPV4_GET_IPTTL(p) != ttl)\n        goto error;\n    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n        goto error;\n\n    return p;\nerror:\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}\n\nvoid DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                          uint16_t hdrextlen, uint16_t plen,\n                          uint16_t prev_hdrextlen);\n\nstatic Packet *\nIPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n    int content_len)\n{\n    Packet *p = NULL;\n    uint8_t *pcontent;\n    IPV6Hdr ip6h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n\n    ip6h.s_ip6_nxt = 44;\n    ip6h.s_ip6_hlim = 2;\n\n    /* Source and dest address - very bogus addresses. */\n    ip6h.s_ip6_src[0] = 0x01010101;\n    ip6h.s_ip6_src[1] = 0x01010101;\n    ip6h.s_ip6_src[2] = 0x01010101;\n    ip6h.s_ip6_src[3] = 0x01010101;\n    ip6h.s_ip6_dst[0] = 0x02020202;\n    ip6h.s_ip6_dst[1] = 0x02020202;\n    ip6h.s_ip6_dst[2] = 0x02020202;\n    ip6h.s_ip6_dst[3] = 0x02020202;\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));\n\n    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);\n    IPV6_SET_RAW_VER(p->ip6h, 6);\n    /* Fragmentation header. */\n    IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n    fh->ip6fh_nxt = IPPROTO_ICMP;\n    fh->ip6fh_ident = htonl(id);\n    fh->ip6fh_offlg = htons((off << 3) | mf);\n\n    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);\n    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);\n    SCFree(pcontent);\n\n    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);\n\n    SET_IPV6_SRC_ADDR(p, &p->src);\n    SET_IPV6_DST_ADDR(p, &p->dst);\n\n    /* Self test. */\n    if (IPV6_GET_VER(p) != 6)\n        goto error;\n    if (IPV6_GET_NH(p) != 44)\n        goto error;\n    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)\n        goto error;\n\n    return p;\nerror:\n    fprintf(stderr, \"Error building test packet.\\n\");\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}\n\n/**\n * Test the simplest possible re-assembly scenario.  All packet in\n * order and no overlaps.\n */\nstatic int\nDefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL) {\n        goto end;\n    }\n\n    if (IPV4_GET_HLEN(reassembled) != 20) {\n        goto end;\n    }\n    if (IPV4_GET_IPLEN(reassembled) != 39) {\n        goto end;\n    }\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A') {\n            goto end;\n        }\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B') {\n            goto end;\n        }\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Simple fragmented packet in reverse order.\n */\nstatic int\nDefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV4_GET_HLEN(reassembled) != 20)\n        goto end;\n    if (IPV4_GET_IPLEN(reassembled) != 39)\n        goto end;\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Test the simplest possible re-assembly scenario.  All packet in\n * order and no overlaps.\n */\nstatic int\nIPV6DefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 19)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nIPV6DefragReverseSimpleTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n{\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    /*\n     * Build the packets.\n     */\n\n    int id = 1;\n    Packet *packets[17];\n    memset(packets, 0x00, sizeof(packets));\n\n    /*\n     * Original fragments.\n     */\n\n    /* A*24 at 0. */\n    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n\n    /* B*15 at 32. */\n    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n\n    /* C*24 at 48. */\n    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n\n    /* D*8 at 80. */\n    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n\n    /* E*16 at 104. */\n    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n\n    /* F*24 at 120. */\n    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n\n    /* G*16 at 144. */\n    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n\n    /* H*16 at 160. */\n    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n\n    /* I*8 at 176. */\n    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n\n    /*\n     * Overlapping subsequent fragments.\n     */\n\n    /* J*32 at 8. */\n    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n\n    /* K*24 at 48. */\n    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n\n    /* L*24 at 72. */\n    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n\n    /* M*24 at 96. */\n    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n\n    /* N*8 at 128. */\n    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n\n    /* O*8 at 152. */\n    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n\n    /* P*8 at 160. */\n    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n\n    /* Q*16 at 176. */\n    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n\n    default_policy = policy;\n\n    /* Send all but the last. */\n    for (i = 0; i < 9; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {\n            goto end;\n        }\n    }\n    int overlap = 0;\n    for (; i < 16; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {\n            overlap++;\n        }\n    }\n    if (!overlap) {\n        goto end;\n    }\n\n    /* And now the last one. */\n    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);\n    if (reassembled == NULL) {\n        goto end;\n    }\n\n    if (IPV4_GET_HLEN(reassembled) != 20) {\n        goto end;\n    }\n    if (IPV4_GET_IPLEN(reassembled) != 20 + 192) {\n        goto end;\n    }\n\n    if (memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0) {\n        goto end;\n    }\n    SCFree(reassembled);\n\n    /* Make sure all frags were returned back to the pool. */\n    if (defrag_context->frag_pool->outstanding != 0) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    for (i = 0; i < 17; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nIPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n{\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    /*\n     * Build the packets.\n     */\n\n    int id = 1;\n    Packet *packets[17];\n    memset(packets, 0x00, sizeof(packets));\n\n    /*\n     * Original fragments.\n     */\n\n    /* A*24 at 0. */\n    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n\n    /* B*15 at 32. */\n    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n\n    /* C*24 at 48. */\n    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n\n    /* D*8 at 80. */\n    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n\n    /* E*16 at 104. */\n    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n\n    /* F*24 at 120. */\n    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n\n    /* G*16 at 144. */\n    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n\n    /* H*16 at 160. */\n    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n\n    /* I*8 at 176. */\n    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n\n    /*\n     * Overlapping subsequent fragments.\n     */\n\n    /* J*32 at 8. */\n    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n\n    /* K*24 at 48. */\n    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n\n    /* L*24 at 72. */\n    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n\n    /* M*24 at 96. */\n    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n\n    /* N*8 at 128. */\n    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n\n    /* O*8 at 152. */\n    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n\n    /* P*8 at 160. */\n    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n\n    /* Q*16 at 176. */\n    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n\n    default_policy = policy;\n\n    /* Send all but the last. */\n    for (i = 0; i < 9; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            goto end;\n        }\n    }\n    int overlap = 0;\n    for (; i < 16; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            overlap++;\n        }\n    }\n    if (!overlap)\n        goto end;\n\n    /* And now the last one. */\n    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);\n    if (reassembled == NULL)\n        goto end;\n    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 192)\n        goto end;\n\n    SCFree(reassembled);\n\n    /* Make sure all frags were returned to the pool. */\n    if (defrag_context->frag_pool->outstanding != 0) {\n        printf(\"defrag_context->frag_pool->outstanding %u: \", defrag_context->frag_pool->outstanding);\n        goto end;\n    }\n\n    ret = 1;\n\nend:\n    for (i = 0; i < 17; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragSturgesNovakBsdTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakBsdTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakLinuxTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakLinuxTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakWindowsTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakWindowsTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakSolarisTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakSolarisTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakFirstTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"DDDDDDDD\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakFirstTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"DDDDDDDD\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakLastTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"NNNNNNNN\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"OOOOOOOO\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakLastTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"NNNNNNNN\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"OOOOOOOO\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragTimeoutTest(void)\n{\n    int i;\n    int ret = 0;\n\n    /* Setup a small numberr of trackers. */\n    if (ConfSet(\"defrag.trackers\", \"16\") != 1) {\n        printf(\"ConfSet failed: \");\n        goto end;\n    }\n\n    DefragInit();\n\n    /* Load in 16 packets. */\n    for (i = 0; i < 16; i++) {\n        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n        if (p == NULL)\n            goto end;\n\n        Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n        SCFree(p);\n\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n    }\n\n    /* Build a new packet but push the timestamp out by our timeout.\n     * This should force our previous fragments to be timed out. */\n    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n    if (p == NULL)\n        goto end;\n\n    p->ts.tv_sec += (defrag_context->timeout + 1);\n    Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n    if (tp != NULL) {\n        SCFree(tp);\n        goto end;\n    }\n\n    DefragTracker *tracker = DefragLookupTrackerFromHash(p);\n    if (tracker == NULL)\n        goto end;\n\n    if (tracker->id != 99)\n        goto end;\n\n    SCFree(p);\n\n    ret = 1;\nend:\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * QA found that if you send a packet where more frags is 0, offset is\n * > 0 and there is no data in the packet that the re-assembler will\n * fail.  The fix was simple, but this unit test is just to make sure\n * its not introduced.\n */\nstatic int\nDefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* This packet has an offset > 0, more frags set to 0 and no data. */\n    p = BuildTestPacket(id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should\n     * have been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Test that fragments in different VLANs that would otherwise be\n * re-assembled, are not re-assembled.  Just use simple in-order\n * fragments.\n */\nstatic int\nDefragVlanTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    /* With no VLAN IDs set, packets should re-assemble. */\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    /* With mismatched VLANs, packets should not re-assemble. */\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    /* Pass. */\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}\n\n/**\n * Like DefragVlanTest, but for QinQ, testing the second level VLAN ID.\n */\nstatic int\nDefragVlanQinQTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    /* With no VLAN IDs set, packets should re-assemble. */\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    /* With mismatched VLANs, packets should not re-assemble. */\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 1;\n    p1->vlan_id[1] = 1;\n    p2->vlan_id[1] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    /* Pass. */\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}\n\nstatic int DefragTrackerReuseTest(void)\n{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {\n        goto end;\n    }\n    if (tracker1->remove) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Get a tracker again, it should be the same one. */\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 != tracker1) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Now mark the tracker for removal. It should not be returned\n     * when we get a tracker for a packet that may have the same\n     * attributes. */\n    tracker1->remove = 1;\n\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 == tracker1) {\n        goto end;\n    }\n    if (tracker2->remove) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * IPV4: Test the case where you have a packet fragmented in 3 parts\n * and send like:\n * - Offset: 2; MF: 1\n * - Offset: 0; MF: 1\n * - Offset: 1; MF: 0\n *\n * Only the fragments with offset 0 and 1 should be reassembled.\n */\nstatic int DefragMfIpv4Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* Expected IP length is 20 + 8 + 8 = 36 as only 2 of the\n     * fragments should be in the re-assembled packet. */\n    if (IPV4_GET_IPLEN(p) != 36) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}\n\n/**\n * IPV6: Test the case where you have a packet fragmented in 3 parts\n * and send like:\n * - Offset: 2; MF: 1\n * - Offset: 0; MF: 1\n * - Offset: 1; MF: 0\n *\n * Only the fragments with offset 0 and 1 should be reassembled.\n */\nstatic int DefragMfIpv6Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* For IPv6 the expected length is just the length of the payload\n     * of 2 fragments, so 16. */\n    if (IPV6_GET_PLEN(p) != 16) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}\n\n#endif /* UNITTESTS */\n\nvoid\nDefragRegisterTests(void)\n{\n#ifdef UNITTESTS\n    UtRegisterTest(\"DefragInOrderSimpleTest\", DefragInOrderSimpleTest);\n    UtRegisterTest(\"DefragReverseSimpleTest\", DefragReverseSimpleTest);\n    UtRegisterTest(\"DefragSturgesNovakBsdTest\", DefragSturgesNovakBsdTest);\n    UtRegisterTest(\"DefragSturgesNovakLinuxTest\", DefragSturgesNovakLinuxTest);\n    UtRegisterTest(\"DefragSturgesNovakWindowsTest\",\n                   DefragSturgesNovakWindowsTest);\n    UtRegisterTest(\"DefragSturgesNovakSolarisTest\",\n                   DefragSturgesNovakSolarisTest);\n    UtRegisterTest(\"DefragSturgesNovakFirstTest\", DefragSturgesNovakFirstTest);\n    UtRegisterTest(\"DefragSturgesNovakLastTest\", DefragSturgesNovakLastTest);\n\n    UtRegisterTest(\"DefragIPv4NoDataTest\", DefragIPv4NoDataTest);\n    UtRegisterTest(\"DefragIPv4TooLargeTest\", DefragIPv4TooLargeTest);\n\n    UtRegisterTest(\"IPV6DefragInOrderSimpleTest\", IPV6DefragInOrderSimpleTest);\n    UtRegisterTest(\"IPV6DefragReverseSimpleTest\", IPV6DefragReverseSimpleTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakBsdTest\",\n                   IPV6DefragSturgesNovakBsdTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakLinuxTest\",\n                   IPV6DefragSturgesNovakLinuxTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakWindowsTest\",\n                   IPV6DefragSturgesNovakWindowsTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakSolarisTest\",\n                   IPV6DefragSturgesNovakSolarisTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakFirstTest\",\n                   IPV6DefragSturgesNovakFirstTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakLastTest\",\n                   IPV6DefragSturgesNovakLastTest);\n\n    UtRegisterTest(\"DefragVlanTest\", DefragVlanTest);\n    UtRegisterTest(\"DefragVlanQinQTest\", DefragVlanQinQTest);\n    UtRegisterTest(\"DefragTrackerReuseTest\", DefragTrackerReuseTest);\n    UtRegisterTest(\"DefragTimeoutTest\", DefragTimeoutTest);\n    UtRegisterTest(\"DefragMfIpv4Test\", DefragMfIpv4Test);\n    UtRegisterTest(\"DefragMfIpv6Test\", DefragMfIpv6Test);\n#endif /* UNITTESTS */\n}\n\n", "/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Endace Technology Limited, Jason Ish <jason.ish@endace.com>\n */\n\n#ifndef __DEFRAG_H__\n#define __DEFRAG_H__\n\n#include \"util-pool.h\"\n\n/**\n * A context for an instance of a fragmentation re-assembler, in case\n * we ever need more than one.\n */\ntypedef struct DefragContext_ {\n    Pool *frag_pool; /**< Pool of fragments. */\n    SCMutex frag_pool_lock;\n\n    time_t timeout; /**< Default timeout. */\n} DefragContext;\n\n/**\n * Storage for an individual fragment.\n */\ntypedef struct Frag_ {\n    uint16_t offset;            /**< The offset of this fragment, already\n                                 *   multiplied by 8. */\n\n    uint16_t len;               /**< The length of this fragment. */\n\n    uint8_t hlen;               /**< The length of this fragments IP header. */\n\n    uint8_t more_frags:4;       /**< More frags? */\n    uint8_t skip:4;             /**< Skip this fragment during re-assembly. */\n\n    uint16_t ip_hdr_offset;     /**< Offset in the packet where the IP\n                                 * header starts. */\n    uint16_t frag_hdr_offset;   /**< Offset in the packet where the frag\n                                 * header starts. */\n\n    uint16_t data_offset;       /**< Offset to the packet data. */\n    uint16_t data_len;          /**< Length of data. */\n\n    uint16_t ltrim;             /**< Number of leading bytes to trim when\n                                 * re-assembling the packet. */\n\n    uint8_t *pkt;               /**< The actual packet. */\n\n#ifdef DEBUG\n    uint64_t pcap_cnt;          /**< pcap_cnt of original packet */\n#endif\n\n    TAILQ_ENTRY(Frag_) next;    /**< Pointer to next fragment for tailq. */\n} Frag;\n\n/**\n * A defragmentation tracker.  Used to track fragments that make up a\n * single packet.\n */\ntypedef struct DefragTracker_ {\n    SCMutex lock; /**< Mutex for locking list operations on\n                           * this tracker. */\n\n    uint16_t vlan_id[2]; /**< VLAN ID tracker applies to. */\n\n    uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                  * for IPv4. */\n\n    uint8_t policy; /**< Reassembly policy this tracker will use. */\n\n    uint8_t af; /**< Address family for this tracker, AF_INET or\n                 * AF_INET6. */\n\n    uint8_t seen_last; /**< Has this tracker seen the last fragment? */\n\n    uint8_t remove; /**< remove */\n\n    Address src_addr; /**< Source address for this tracker. */\n    Address dst_addr; /**< Destination address for this tracker. */\n\n    struct timeval timeout; /**< When this tracker will timeout. */\n    uint32_t host_timeout;  /**< Host timeout, statically assigned from the yaml */\n\n    /** use cnt, reference counter */\n    SC_ATOMIC_DECLARE(unsigned int, use_cnt);\n\n    TAILQ_HEAD(frag_tailq, Frag_) frags; /**< Head of list of fragments. */\n\n    /** hash pointers, protected by hash row mutex/spin */\n    struct DefragTracker_ *hnext;\n    struct DefragTracker_ *hprev;\n\n    /** list pointers, protected by tracker-queue mutex/spin */\n    struct DefragTracker_ *lnext;\n    struct DefragTracker_ *lprev;\n} DefragTracker;\n\nvoid DefragInit(void);\nvoid DefragDestroy(void);\nvoid DefragReload(void); /**< use only in unittests */\n\nuint8_t DefragGetOsPolicy(Packet *);\nvoid DefragTrackerFreeFrags(DefragTracker *);\nPacket *Defrag(ThreadVars *, DecodeThreadVars *, Packet *, PacketQueue *);\nvoid DefragRegisterTests(void);\n\n#endif /* __DEFRAG_H__ */\n"], "fixing_code": ["/* Copyright (C) 2007-2012 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n#include \"suricata-common.h\"\n#include \"conf.h\"\n#include \"defrag-hash.h\"\n#include \"defrag-queue.h\"\n#include \"defrag-config.h\"\n#include \"util-random.h\"\n#include \"util-byte.h\"\n#include \"util-misc.h\"\n#include \"util-hash-lookup3.h\"\n\nstatic DefragTracker *DefragTrackerGetUsedDefragTracker(void);\n\n/** queue with spare tracker */\nstatic DefragTrackerQueue defragtracker_spare_q;\n\nuint32_t DefragTrackerSpareQueueGetSize(void)\n{\n    return DefragTrackerQueueLen(&defragtracker_spare_q);\n}\n\nvoid DefragTrackerMoveToSpare(DefragTracker *h)\n{\n    DefragTrackerEnqueue(&defragtracker_spare_q, h);\n    (void) SC_ATOMIC_SUB(defragtracker_counter, 1);\n}\n\nDefragTracker *DefragTrackerAlloc(void)\n{\n    if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n        return NULL;\n    }\n\n    (void) SC_ATOMIC_ADD(defrag_memuse, sizeof(DefragTracker));\n\n    DefragTracker *dt = SCMalloc(sizeof(DefragTracker));\n    if (unlikely(dt == NULL))\n        goto error;\n\n    memset(dt, 0x00, sizeof(DefragTracker));\n\n    SCMutexInit(&dt->lock, NULL);\n    SC_ATOMIC_INIT(dt->use_cnt);\n    return dt;\n\nerror:\n    return NULL;\n}\n\nvoid DefragTrackerFree(DefragTracker *dt)\n{\n    if (dt != NULL) {\n        DefragTrackerClearMemory(dt);\n\n        SCMutexDestroy(&dt->lock);\n        SCFree(dt);\n        (void) SC_ATOMIC_SUB(defrag_memuse, sizeof(DefragTracker));\n    }\n}\n\n#define DefragTrackerIncrUsecnt(dt) \\\n    SC_ATOMIC_ADD((dt)->use_cnt, 1)\n#define DefragTrackerDecrUsecnt(dt) \\\n    SC_ATOMIC_SUB((dt)->use_cnt, 1)\n\nstatic void DefragTrackerInit(DefragTracker *dt, Packet *p)\n{\n    /* copy address */\n    COPY_ADDRESS(&p->src, &dt->src_addr);\n    COPY_ADDRESS(&p->dst, &dt->dst_addr);\n\n    if (PKT_IS_IPV4(p)) {\n        dt->id = (int32_t)IPV4_GET_IPID(p);\n        dt->af = AF_INET;\n    } else {\n        dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n        dt->af = AF_INET6;\n    }\n    dt->proto = IP_GET_IPPROTO(p);\n    dt->vlan_id[0] = p->vlan_id[0];\n    dt->vlan_id[1] = p->vlan_id[1];\n    dt->policy = DefragGetOsPolicy(p);\n    dt->host_timeout = DefragPolicyGetHostTimeout(p);\n    dt->remove = 0;\n    dt->seen_last = 0;\n\n    TAILQ_INIT(&dt->frags);\n    (void) DefragTrackerIncrUsecnt(dt);\n}\n\nvoid DefragTrackerRelease(DefragTracker *t)\n{\n    (void) DefragTrackerDecrUsecnt(t);\n    SCMutexUnlock(&t->lock);\n}\n\nvoid DefragTrackerClearMemory(DefragTracker *dt)\n{\n    DefragTrackerFreeFrags(dt);\n    SC_ATOMIC_DESTROY(dt->use_cnt);\n}\n\n#define DEFRAG_DEFAULT_HASHSIZE 4096\n#define DEFRAG_DEFAULT_MEMCAP 16777216\n#define DEFRAG_DEFAULT_PREALLOC 1000\n\n/** \\brief initialize the configuration\n *  \\warning Not thread safe */\nvoid DefragInitConfig(char quiet)\n{\n    SCLogDebug(\"initializing defrag engine...\");\n\n    memset(&defrag_config,  0, sizeof(defrag_config));\n    //SC_ATOMIC_INIT(flow_flags);\n    SC_ATOMIC_INIT(defragtracker_counter);\n    SC_ATOMIC_INIT(defrag_memuse);\n    SC_ATOMIC_INIT(defragtracker_prune_idx);\n    DefragTrackerQueueInit(&defragtracker_spare_q);\n\n#ifndef AFLFUZZ_NO_RANDOM\n    unsigned int seed = RandomTimePreseed();\n    /* set defaults */\n    defrag_config.hash_rand   = (int)(DEFRAG_DEFAULT_HASHSIZE * (rand_r(&seed) / RAND_MAX + 1.0));\n#endif\n    defrag_config.hash_size   = DEFRAG_DEFAULT_HASHSIZE;\n    defrag_config.memcap      = DEFRAG_DEFAULT_MEMCAP;\n    defrag_config.prealloc    = DEFRAG_DEFAULT_PREALLOC;\n\n    /* Check if we have memcap and hash_size defined at config */\n    char *conf_val;\n    uint32_t configval = 0;\n\n    /** set config values for memcap, prealloc and hash_size */\n    if ((ConfGet(\"defrag.memcap\", &conf_val)) == 1)\n    {\n        if (ParseSizeStringU64(conf_val, &defrag_config.memcap) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing defrag.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       conf_val);\n            exit(EXIT_FAILURE);\n        }\n    }\n    if ((ConfGet(\"defrag.hash-size\", &conf_val)) == 1)\n    {\n        if (ByteExtractStringUint32(&configval, 10, strlen(conf_val),\n                                    conf_val) > 0) {\n            defrag_config.hash_size = configval;\n        } else {\n            WarnInvalidConfEntry(\"defrag.hash-size\", \"%\"PRIu32, defrag_config.hash_size);\n        }\n    }\n\n\n    if ((ConfGet(\"defrag.trackers\", &conf_val)) == 1)\n    {\n        if (ByteExtractStringUint32(&configval, 10, strlen(conf_val),\n                                    conf_val) > 0) {\n            defrag_config.prealloc = configval;\n        } else {\n            WarnInvalidConfEntry(\"defrag.trackers\", \"%\"PRIu32, defrag_config.prealloc);\n        }\n    }\n    SCLogDebug(\"DefragTracker config from suricata.yaml: memcap: %\"PRIu64\", hash-size: \"\n               \"%\"PRIu32\", prealloc: %\"PRIu32, defrag_config.memcap,\n               defrag_config.hash_size, defrag_config.prealloc);\n\n    /* alloc hash memory */\n    uint64_t hash_size = defrag_config.hash_size * sizeof(DefragTrackerHashRow);\n    if (!(DEFRAG_CHECK_MEMCAP(hash_size))) {\n        SCLogError(SC_ERR_DEFRAG_INIT, \"allocating defrag hash failed: \"\n                \"max defrag memcap is smaller than projected hash size. \"\n                \"Memcap: %\"PRIu64\", Hash table size %\"PRIu64\". Calculate \"\n                \"total hash size by multiplying \\\"defrag.hash-size\\\" with %\"PRIuMAX\", \"\n                \"which is the hash bucket size.\", defrag_config.memcap, hash_size,\n                (uintmax_t)sizeof(DefragTrackerHashRow));\n        exit(EXIT_FAILURE);\n    }\n    defragtracker_hash = SCCalloc(defrag_config.hash_size, sizeof(DefragTrackerHashRow));\n    if (unlikely(defragtracker_hash == NULL)) {\n        SCLogError(SC_ERR_FATAL, \"Fatal error encountered in DefragTrackerInitConfig. Exiting...\");\n        exit(EXIT_FAILURE);\n    }\n    memset(defragtracker_hash, 0, defrag_config.hash_size * sizeof(DefragTrackerHashRow));\n\n    uint32_t i = 0;\n    for (i = 0; i < defrag_config.hash_size; i++) {\n        DRLOCK_INIT(&defragtracker_hash[i]);\n    }\n    (void) SC_ATOMIC_ADD(defrag_memuse, (defrag_config.hash_size * sizeof(DefragTrackerHashRow)));\n\n    if (quiet == FALSE) {\n        SCLogConfig(\"allocated %llu bytes of memory for the defrag hash... \"\n                  \"%\" PRIu32 \" buckets of size %\" PRIuMAX \"\",\n                  SC_ATOMIC_GET(defrag_memuse), defrag_config.hash_size,\n                  (uintmax_t)sizeof(DefragTrackerHashRow));\n    }\n\n    if ((ConfGet(\"defrag.prealloc\", &conf_val)) == 1)\n    {\n        if (ConfValIsTrue(conf_val)) {\n            /* pre allocate defrag trackers */\n            for (i = 0; i < defrag_config.prealloc; i++) {\n                if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n                    SCLogError(SC_ERR_DEFRAG_INIT, \"preallocating defrag trackers failed: \"\n                            \"max defrag memcap reached. Memcap %\"PRIu64\", \"\n                            \"Memuse %\"PRIu64\".\", defrag_config.memcap,\n                            ((uint64_t)SC_ATOMIC_GET(defrag_memuse) + (uint64_t)sizeof(DefragTracker)));\n                    exit(EXIT_FAILURE);\n                }\n\n                DefragTracker *h = DefragTrackerAlloc();\n                if (h == NULL) {\n                    SCLogError(SC_ERR_DEFRAG_INIT, \"preallocating defrag failed: %s\", strerror(errno));\n                    exit(EXIT_FAILURE);\n                }\n                DefragTrackerEnqueue(&defragtracker_spare_q,h);\n            }\n            if (quiet == FALSE) {\n                SCLogConfig(\"preallocated %\" PRIu32 \" defrag trackers of size %\" PRIuMAX \"\",\n                        defragtracker_spare_q.len, (uintmax_t)sizeof(DefragTracker));\n            }\n        }\n    }\n\n    if (quiet == FALSE) {\n        SCLogConfig(\"defrag memory usage: %llu bytes, maximum: %\"PRIu64,\n                SC_ATOMIC_GET(defrag_memuse), defrag_config.memcap);\n    }\n\n    return;\n}\n\n/** \\brief print some defrag stats\n *  \\warning Not thread safe */\nstatic void DefragTrackerPrintStats (void)\n{\n}\n\n/** \\brief shutdown the flow engine\n *  \\warning Not thread safe */\nvoid DefragHashShutdown(void)\n{\n    DefragTracker *dt;\n    uint32_t u;\n\n    DefragTrackerPrintStats();\n\n    /* free spare queue */\n    while((dt = DefragTrackerDequeue(&defragtracker_spare_q))) {\n        BUG_ON(SC_ATOMIC_GET(dt->use_cnt) > 0);\n        DefragTrackerFree(dt);\n    }\n\n    /* clear and free the hash */\n    if (defragtracker_hash != NULL) {\n        for (u = 0; u < defrag_config.hash_size; u++) {\n            dt = defragtracker_hash[u].head;\n            while (dt) {\n                DefragTracker *n = dt->hnext;\n                DefragTrackerClearMemory(dt);\n                DefragTrackerFree(dt);\n                dt = n;\n            }\n\n            DRLOCK_DESTROY(&defragtracker_hash[u]);\n        }\n        SCFree(defragtracker_hash);\n        defragtracker_hash = NULL;\n    }\n    (void) SC_ATOMIC_SUB(defrag_memuse, defrag_config.hash_size * sizeof(DefragTrackerHashRow));\n    DefragTrackerQueueDestroy(&defragtracker_spare_q);\n\n    SC_ATOMIC_DESTROY(defragtracker_prune_idx);\n    SC_ATOMIC_DESTROY(defrag_memuse);\n    SC_ATOMIC_DESTROY(defragtracker_counter);\n    //SC_ATOMIC_DESTROY(flow_flags);\n    return;\n}\n\n/** \\brief compare two raw ipv6 addrs\n *\n *  \\note we don't care about the real ipv6 ip's, this is just\n *        to consistently fill the DefragHashKey6 struct, without all\n *        the ntohl calls.\n *\n *  \\warning do not use elsewhere unless you know what you're doing.\n *           detect-engine-address-ipv6.c's AddressIPv6GtU32 is likely\n *           what you are looking for.\n */\nstatic inline int DefragHashRawAddressIPv6GtU32(uint32_t *a, uint32_t *b)\n{\n    int i;\n\n    for (i = 0; i < 4; i++) {\n        if (a[i] > b[i])\n            return 1;\n        if (a[i] < b[i])\n            break;\n    }\n\n    return 0;\n}\n\ntypedef struct DefragHashKey4_ {\n    union {\n        struct {\n            uint32_t src, dst;\n            uint32_t id;\n            uint16_t vlan_id[2];\n        };\n        uint32_t u32[4];\n    };\n} DefragHashKey4;\n\ntypedef struct DefragHashKey6_ {\n    union {\n        struct {\n            uint32_t src[4], dst[4];\n            uint32_t id;\n            uint16_t vlan_id[2];\n        };\n        uint32_t u32[10];\n    };\n} DefragHashKey6;\n\n/* calculate the hash key for this packet\n *\n * we're using:\n *  hash_rand -- set at init time\n *  source address\n *  destination address\n *  id\n *  vlan_id\n */\nstatic inline uint32_t DefragHashGetKey(Packet *p)\n{\n    uint32_t key;\n\n    if (p->ip4h != NULL) {\n        DefragHashKey4 dhk;\n        if (p->src.addr_data32[0] > p->dst.addr_data32[0]) {\n            dhk.src = p->src.addr_data32[0];\n            dhk.dst = p->dst.addr_data32[0];\n        } else {\n            dhk.src = p->dst.addr_data32[0];\n            dhk.dst = p->src.addr_data32[0];\n        }\n        dhk.id = (uint32_t)IPV4_GET_IPID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 4, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else if (p->ip6h != NULL) {\n        DefragHashKey6 dhk;\n        if (DefragHashRawAddressIPv6GtU32(p->src.addr_data32, p->dst.addr_data32)) {\n            dhk.src[0] = p->src.addr_data32[0];\n            dhk.src[1] = p->src.addr_data32[1];\n            dhk.src[2] = p->src.addr_data32[2];\n            dhk.src[3] = p->src.addr_data32[3];\n            dhk.dst[0] = p->dst.addr_data32[0];\n            dhk.dst[1] = p->dst.addr_data32[1];\n            dhk.dst[2] = p->dst.addr_data32[2];\n            dhk.dst[3] = p->dst.addr_data32[3];\n        } else {\n            dhk.src[0] = p->dst.addr_data32[0];\n            dhk.src[1] = p->dst.addr_data32[1];\n            dhk.src[2] = p->dst.addr_data32[2];\n            dhk.src[3] = p->dst.addr_data32[3];\n            dhk.dst[0] = p->src.addr_data32[0];\n            dhk.dst[1] = p->src.addr_data32[1];\n            dhk.dst[2] = p->src.addr_data32[2];\n            dhk.dst[3] = p->src.addr_data32[3];\n        }\n        dhk.id = IPV6_EXTHDR_GET_FH_ID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 10, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else\n        key = 0;\n\n    return key;\n}\n\n/* Since two or more trackers can have the same hash key, we need to compare\n * the tracker with the current tracker key. */\n#define CMP_DEFRAGTRACKER(d1,d2,id) \\\n    (((CMP_ADDR(&(d1)->src_addr, &(d2)->src) && \\\n       CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n      (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n       CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n     (d1)->id == (id) && \\\n     (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n     (d1)->vlan_id[1] == (d2)->vlan_id[1])\n\nstatic inline int DefragTrackerCompare(DefragTracker *t, Packet *p)\n{\n    uint32_t id;\n    if (PKT_IS_IPV4(p)) {\n        id = (uint32_t)IPV4_GET_IPID(p);\n    } else {\n        id = IPV6_EXTHDR_GET_FH_ID(p);\n    }\n\n    return CMP_DEFRAGTRACKER(t, p, id);\n}\n\n/**\n *  \\brief Get a new defrag tracker\n *\n *  Get a new defrag tracker. We're checking memcap first and will try to make room\n *  if the memcap is reached.\n *\n *  \\retval dt *LOCKED* tracker on succes, NULL on error.\n */\nstatic DefragTracker *DefragTrackerGetNew(Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get a tracker from the spare queue */\n    dt = DefragTrackerDequeue(&defragtracker_spare_q);\n    if (dt == NULL) {\n        /* If we reached the max memcap, we get a used tracker */\n        if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n            /* declare state of emergency */\n            //if (!(SC_ATOMIC_GET(defragtracker_flags) & DEFRAG_EMERGENCY)) {\n            //    SC_ATOMIC_OR(defragtracker_flags, DEFRAG_EMERGENCY);\n\n                /* under high load, waking up the flow mgr each time leads\n                 * to high cpu usage. Flows are not timed out much faster if\n                 * we check a 1000 times a second. */\n            //    FlowWakeupFlowManagerThread();\n            //}\n\n            dt = DefragTrackerGetUsedDefragTracker();\n            if (dt == NULL) {\n                return NULL;\n            }\n\n            /* freed a tracker, but it's unlocked */\n        } else {\n            /* now see if we can alloc a new tracker */\n            dt = DefragTrackerAlloc();\n            if (dt == NULL) {\n                return NULL;\n            }\n\n            /* tracker is initialized but *unlocked* */\n        }\n    } else {\n        /* tracker has been recycled before it went into the spare queue */\n\n        /* tracker is initialized (recylced) but *unlocked* */\n    }\n\n    (void) SC_ATOMIC_ADD(defragtracker_counter, 1);\n    SCMutexLock(&dt->lock);\n    return dt;\n}\n\n/* DefragGetTrackerFromHash\n *\n * Hash retrieval function for trackers. Looks up the hash bucket containing the\n * tracker pointer. Then compares the packet with the found tracker to see if it is\n * the tracker we need. If it isn't, walk the list until the right tracker is found.\n *\n * returns a *LOCKED* tracker or NULL\n */\nDefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get the key to our bucket */\n    uint32_t key = DefragHashGetKey(p);\n    /* get our hash bucket and lock it */\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n\n    /* see if the bucket already has a tracker */\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n\n        /* tracker is locked */\n        hb->head = dt;\n        hb->tail = dt;\n\n        /* got one, now lock, initialize and return */\n        DefragTrackerInit(dt,p);\n\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n\n    /* ok, we have a tracker in the bucket. Let's find out if it is our tracker */\n    dt = hb->head;\n\n    /* see if this is the tracker we are looking for */\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; /* previous tracker */\n\n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n\n                /* tracker is locked */\n\n                dt->hprev = pdt;\n\n                /* initialize and return */\n                DefragTrackerInit(dt,p);\n\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n\n            if (DefragTrackerCompare(dt, p) != 0) {\n                /* we found our tracker, lets put it on top of the\n                 * hash list -- this rewards active trackers */\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n\n                /* found our tracker, lock & return */\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n\n    /* lock & return */\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}\n\n/** \\brief look up a tracker in the hash\n *\n *  \\param a address to look up\n *\n *  \\retval h *LOCKED* tracker or NULL\n */\nDefragTracker *DefragLookupTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n\n    /* get the key to our bucket */\n    uint32_t key = DefragHashGetKey(p);\n    /* get our hash bucket and lock it */\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n\n    /* see if the bucket already has a tracker */\n    if (hb->head == NULL) {\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n\n    /* ok, we have a tracker in the bucket. Let's find out if it is our tracker */\n    dt = hb->head;\n\n    /* see if this is the tracker we are looking for */\n    if (DefragTrackerCompare(dt, p) == 0) {\n        while (dt) {\n            dt = dt->hnext;\n\n            if (dt == NULL) {\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n\n            if (DefragTrackerCompare(dt, p) != 0) {\n                /* we found our tracker, lets put it on top of the\n                 * hash list -- this rewards active tracker */\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n\n                /* found our tracker, lock & return */\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n\n    /* lock & return */\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}\n\n/** \\internal\n *  \\brief Get a tracker from the hash directly.\n *\n *  Called in conditions where the spare queue is empty and memcap is reached.\n *\n *  Walks the hash until a tracker can be freed. \"defragtracker_prune_idx\" atomic int makes\n *  sure we don't start at the top each time since that would clear the top of\n *  the hash leading to longer and longer search times under high pressure (observed).\n *\n *  \\retval dt tracker or NULL\n */\nstatic DefragTracker *DefragTrackerGetUsedDefragTracker(void)\n{\n    uint32_t idx = SC_ATOMIC_GET(defragtracker_prune_idx) % defrag_config.hash_size;\n    uint32_t cnt = defrag_config.hash_size;\n\n    while (cnt--) {\n        if (++idx >= defrag_config.hash_size)\n            idx = 0;\n\n        DefragTrackerHashRow *hb = &defragtracker_hash[idx];\n\n        if (DRLOCK_TRYLOCK(hb) != 0)\n            continue;\n\n        DefragTracker *dt = hb->tail;\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            continue;\n        }\n\n        if (SCMutexTrylock(&dt->lock) != 0) {\n            DRLOCK_UNLOCK(hb);\n            continue;\n        }\n\n        /** never prune a tracker that is used by a packets\n         *  we are currently processing in one of the threads */\n        if (SC_ATOMIC_GET(dt->use_cnt) > 0) {\n            DRLOCK_UNLOCK(hb);\n            SCMutexUnlock(&dt->lock);\n            continue;\n        }\n\n        /* remove from the hash */\n        if (dt->hprev != NULL)\n            dt->hprev->hnext = dt->hnext;\n        if (dt->hnext != NULL)\n            dt->hnext->hprev = dt->hprev;\n        if (hb->head == dt)\n            hb->head = dt->hnext;\n        if (hb->tail == dt)\n            hb->tail = dt->hprev;\n\n        dt->hnext = NULL;\n        dt->hprev = NULL;\n        DRLOCK_UNLOCK(hb);\n\n        DefragTrackerClearMemory(dt);\n\n        SCMutexUnlock(&dt->lock);\n\n        (void) SC_ATOMIC_ADD(defragtracker_prune_idx, (defrag_config.hash_size - cnt));\n        return dt;\n    }\n\n    return NULL;\n}\n\n\n", "/* Copyright (C) 2007-2012 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Endace Technology Limited, Jason Ish <jason.ish@endace.com>\n *\n * Defragmentation module.\n * References:\n *   - RFC 815\n *   - OpenBSD PF's IP normalizaton (pf_norm.c)\n *\n * \\todo pool for frag packet storage\n * \\todo policy bsd-right\n * \\todo profile hash function\n * \\todo log anomalies\n */\n\n#include \"suricata-common.h\"\n\n#include \"queue.h\"\n\n#include \"suricata.h\"\n#include \"threads.h\"\n#include \"conf.h\"\n#include \"decode-ipv6.h\"\n#include \"util-hashlist.h\"\n#include \"util-pool.h\"\n#include \"util-time.h\"\n#include \"util-print.h\"\n#include \"util-debug.h\"\n#include \"util-fix_checksum.h\"\n#include \"util-random.h\"\n#include \"stream-tcp-private.h\"\n#include \"stream-tcp-reassemble.h\"\n#include \"util-host-os-info.h\"\n\n#include \"defrag.h\"\n#include \"defrag-hash.h\"\n#include \"defrag-queue.h\"\n#include \"defrag-config.h\"\n\n#include \"tmqh-packetpool.h\"\n#include \"decode.h\"\n\n#ifdef UNITTESTS\n#include \"util-unittest.h\"\n#endif\n\n#define DEFAULT_DEFRAG_HASH_SIZE 0xffff\n#define DEFAULT_DEFRAG_POOL_SIZE 0xffff\n\n/**\n * Default timeout (in seconds) before a defragmentation tracker will\n * be released.\n */\n#define TIMEOUT_DEFAULT 60\n\n/**\n * Maximum allowed timeout, 24 hours.\n */\n#define TIMEOUT_MAX (60 * 60 * 24)\n\n/**\n * Minimum allowed timeout, 1 second.\n */\n#define TIMEOUT_MIN 1\n\n/** Fragment reassembly policies. */\nenum defrag_policies {\n    DEFRAG_POLICY_FIRST = 1,\n    DEFRAG_POLICY_LAST,\n    DEFRAG_POLICY_BSD,\n    DEFRAG_POLICY_BSD_RIGHT,\n    DEFRAG_POLICY_LINUX,\n    DEFRAG_POLICY_WINDOWS,\n    DEFRAG_POLICY_SOLARIS,\n\n    DEFRAG_POLICY_DEFAULT = DEFRAG_POLICY_BSD,\n};\n\nstatic int default_policy = DEFRAG_POLICY_BSD;\n\n/** The global DefragContext so all threads operate from the same\n * context. */\nstatic DefragContext *defrag_context;\n\n/**\n * Utility/debugging function to dump the frags associated with a\n * tracker.  Only enable when unit tests are enabled.\n */\n#if 0\n#ifdef UNITTESTS\nstatic void\nDumpFrags(DefragTracker *tracker)\n{\n    Frag *frag;\n\n    printf(\"Dumping frags for packet: ID=%d\\n\", tracker->id);\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        printf(\"-> Frag: frag_offset=%d, frag_len=%d, data_len=%d, ltrim=%d, skip=%d\\n\", frag->offset, frag->len, frag->data_len, frag->ltrim, frag->skip);\n        PrintRawDataFp(stdout, frag->pkt, frag->len);\n    }\n}\n#endif /* UNITTESTS */\n#endif\n\n/**\n * \\brief Reset a frag for reuse in a pool.\n */\nstatic void\nDefragFragReset(Frag *frag)\n{\n    if (frag->pkt != NULL)\n        SCFree(frag->pkt);\n    memset(frag, 0, sizeof(*frag));\n}\n\n/**\n * \\brief Allocate a new frag for use in a pool.\n */\nstatic int\nDefragFragInit(void *data, void *initdata)\n{\n    Frag *frag = data;\n\n    memset(frag, 0, sizeof(*frag));\n    return 1;\n}\n\n/**\n * \\brief Free all frags associated with a tracker.\n */\nvoid\nDefragTrackerFreeFrags(DefragTracker *tracker)\n{\n    Frag *frag;\n\n    /* Lock the frag pool as we'll be return items to it. */\n    SCMutexLock(&defrag_context->frag_pool_lock);\n\n    while ((frag = TAILQ_FIRST(&tracker->frags)) != NULL) {\n        TAILQ_REMOVE(&tracker->frags, frag, next);\n\n        /* Don't SCFree the frag, just give it back to its pool. */\n        DefragFragReset(frag);\n        PoolReturn(defrag_context->frag_pool, frag);\n    }\n\n    SCMutexUnlock(&defrag_context->frag_pool_lock);\n}\n\n/**\n * \\brief Create a new DefragContext.\n *\n * \\retval On success a return an initialized DefragContext, otherwise\n *     NULL will be returned.\n */\nstatic DefragContext *\nDefragContextNew(void)\n{\n    DefragContext *dc;\n\n    dc = SCCalloc(1, sizeof(*dc));\n    if (unlikely(dc == NULL))\n        return NULL;\n\n    /* Initialize the pool of trackers. */\n    intmax_t tracker_pool_size;\n    if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size) || tracker_pool_size == 0) {\n        tracker_pool_size = DEFAULT_DEFRAG_HASH_SIZE;\n    }\n\n    /* Initialize the pool of frags. */\n    intmax_t frag_pool_size;\n    if (!ConfGetInt(\"defrag.max-frags\", &frag_pool_size) || frag_pool_size == 0) {\n        frag_pool_size = DEFAULT_DEFRAG_POOL_SIZE;\n    }\n    intmax_t frag_pool_prealloc = frag_pool_size / 2;\n    dc->frag_pool = PoolInit(frag_pool_size, frag_pool_prealloc,\n        sizeof(Frag),\n        NULL, DefragFragInit, dc, NULL, NULL);\n    if (dc->frag_pool == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC,\n            \"Defrag: Failed to initialize fragment pool.\");\n        exit(EXIT_FAILURE);\n    }\n    if (SCMutexInit(&dc->frag_pool_lock, NULL) != 0) {\n        SCLogError(SC_ERR_MUTEX,\n            \"Defrag: Failed to initialize frag pool mutex.\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Set the default timeout. */\n    intmax_t timeout;\n    if (!ConfGetInt(\"defrag.timeout\", &timeout)) {\n        dc->timeout = TIMEOUT_DEFAULT;\n    }\n    else {\n        if (timeout < TIMEOUT_MIN) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT,\n                \"defrag: Timeout less than minimum allowed value.\");\n            exit(EXIT_FAILURE);\n        }\n        else if (timeout > TIMEOUT_MAX) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT,\n                \"defrag: Tiemout greater than maximum allowed value.\");\n            exit(EXIT_FAILURE);\n        }\n        dc->timeout = timeout;\n    }\n\n    SCLogDebug(\"Defrag Initialized:\");\n    SCLogDebug(\"\\tTimeout: %\"PRIuMAX, (uintmax_t)dc->timeout);\n    SCLogDebug(\"\\tMaximum defrag trackers: %\"PRIuMAX, tracker_pool_size);\n    SCLogDebug(\"\\tPreallocated defrag trackers: %\"PRIuMAX, tracker_pool_size);\n    SCLogDebug(\"\\tMaximum fragments: %\"PRIuMAX, (uintmax_t)frag_pool_size);\n    SCLogDebug(\"\\tPreallocated fragments: %\"PRIuMAX, (uintmax_t)frag_pool_prealloc);\n\n    return dc;\n}\n\nstatic void\nDefragContextDestroy(DefragContext *dc)\n{\n    if (dc == NULL)\n        return;\n\n    PoolFree(dc->frag_pool);\n    SCFree(dc);\n}\n\n/**\n * Attempt to re-assemble a packet.\n *\n * \\param tracker The defragmentation tracker to reassemble from.\n */\nstatic Packet *\nDefrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)\n{\n    Packet *rp = NULL;\n\n    /* Should not be here unless we have seen the last fragment. */\n    if (!tracker->seen_last)\n        return NULL;\n\n    /* Check that we have all the data. Relies on the fact that\n     * fragments are inserted if frag_offset order. */\n    Frag *frag;\n    int len = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n\n        if (frag == TAILQ_FIRST(&tracker->frags)) {\n            if (frag->offset != 0) {\n                goto done;\n            }\n            len = frag->data_len;\n        }\n        else {\n            if (frag->offset > len) {\n                /* This fragment starts after the end of the previous\n                 * fragment.  We have a hole. */\n                goto done;\n            }\n            else {\n                len += frag->data_len;\n            }\n        }\n    }\n\n    /* Allocate a Packet for the reassembled packet.  On failure we\n     * SCFree all the resources held by this tracker. */\n    rp = PacketDefragPktSetup(p, NULL, 0, IPV4_GET_IPPROTO(p));\n    if (rp == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"\n                   \"fragmentation re-assembly, dumping fragments.\");\n        goto error_remove_tracker;\n    }\n    PKT_SET_SRC(rp, PKT_SRC_DEFRAG);\n    rp->flags |= PKT_REBUILT_FRAGMENT;\n    rp->recursion_level = p->recursion_level;\n\n    int fragmentable_offset = 0;\n    int fragmentable_len = 0;\n    int hlen = 0;\n    int ip_hdr_offset = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,\n                frag, frag->data_len, frag->offset, frag->pcap_cnt);\n\n        if (frag->skip)\n            continue;\n        if (frag->data_len - frag->ltrim <= 0)\n            continue;\n        if (frag->offset == 0) {\n\n            if (PacketCopyData(rp, frag->pkt, frag->len) == -1)\n                goto error_remove_tracker;\n\n            hlen = frag->hlen;\n            ip_hdr_offset = frag->ip_hdr_offset;\n\n            /* This is the start of the fragmentable portion of the\n             * first packet.  All fragment offsets are relative to\n             * this. */\n            fragmentable_offset = frag->ip_hdr_offset + frag->hlen;\n            fragmentable_len = frag->data_len;\n        }\n        else {\n            int pkt_end = fragmentable_offset + frag->offset + frag->data_len;\n            if (pkt_end > (int)MAX_PAYLOAD_SIZE) {\n                SCLogWarning(SC_ERR_REASSEMBLY, \"Failed re-assemble \"\n                        \"fragmented packet, exceeds size of packet buffer.\");\n                goto error_remove_tracker;\n            }\n            if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,\n                frag->pkt + frag->data_offset + frag->ltrim,\n                frag->data_len - frag->ltrim) == -1) {\n                goto error_remove_tracker;\n            }\n            if (frag->offset + frag->data_len > fragmentable_len)\n                fragmentable_len = frag->offset + frag->data_len;\n        }\n\n        if (!frag->more_frags) {\n            break;\n        }\n    }\n\n    SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",\n            ip_hdr_offset, hlen, fragmentable_len);\n\n    rp->ip4h = (IPV4Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);\n    int old = rp->ip4h->ip_len + rp->ip4h->ip_off;\n    rp->ip4h->ip_len = htons(fragmentable_len + hlen);\n    rp->ip4h->ip_off = 0;\n    rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum,\n        old, rp->ip4h->ip_len + rp->ip4h->ip_off);\n    SET_PKT_LEN(rp, ip_hdr_offset + hlen + fragmentable_len);\n\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\ndone:\n    return rp;\n\nerror_remove_tracker:\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\n    if (rp != NULL)\n        PacketFreeOrRelease(rp);\n    return NULL;\n}\n\n/**\n * Attempt to re-assemble a packet.\n *\n * \\param tracker The defragmentation tracker to reassemble from.\n */\nstatic Packet *\nDefrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)\n{\n    Packet *rp = NULL;\n\n    /* Should not be here unless we have seen the last fragment. */\n    if (!tracker->seen_last)\n        return NULL;\n\n    /* Check that we have all the data. Relies on the fact that\n     * fragments are inserted if frag_offset order. */\n    Frag *frag;\n    int len = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n\n        if (frag == TAILQ_FIRST(&tracker->frags)) {\n            if (frag->offset != 0) {\n                goto done;\n            }\n            len = frag->data_len;\n        }\n        else {\n            if (frag->offset > len) {\n                /* This fragment starts after the end of the previous\n                 * fragment.  We have a hole. */\n                goto done;\n            }\n            else {\n                len += frag->data_len;\n            }\n        }\n    }\n\n    /* Allocate a Packet for the reassembled packet.  On failure we\n     * SCFree all the resources held by this tracker. */\n    rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h,\n            IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);\n    if (rp == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"\n                \"fragmentation re-assembly, dumping fragments.\");\n        goto error_remove_tracker;\n    }\n    PKT_SET_SRC(rp, PKT_SRC_DEFRAG);\n\n    int unfragmentable_len = 0;\n    int fragmentable_offset = 0;\n    int fragmentable_len = 0;\n    int ip_hdr_offset = 0;\n    uint8_t next_hdr = 0;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (frag->skip)\n            continue;\n        if (frag->data_len - frag->ltrim <= 0)\n            continue;\n        if (frag->offset == 0) {\n            IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt +\n                frag->frag_hdr_offset);\n            next_hdr = frag_hdr->ip6fh_nxt;\n\n            /* This is the first packet, we use this packets link and\n             * IPv6 headers. We also copy in its data, but remove the\n             * fragmentation header. */\n            if (PacketCopyData(rp, frag->pkt, frag->frag_hdr_offset) == -1)\n                goto error_remove_tracker;\n            if (PacketCopyDataOffset(rp, frag->frag_hdr_offset,\n                frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),\n                frag->data_len) == -1)\n                goto error_remove_tracker;\n            ip_hdr_offset = frag->ip_hdr_offset;\n\n            /* This is the start of the fragmentable portion of the\n             * first packet.  All fragment offsets are relative to\n             * this. */\n            fragmentable_offset = frag->frag_hdr_offset;\n            fragmentable_len = frag->data_len;\n\n            /* unfragmentable part is the part between the ipv6 header\n             * and the frag header. */\n            unfragmentable_len = (fragmentable_offset - ip_hdr_offset) - IPV6_HEADER_LEN;\n            if (unfragmentable_len >= fragmentable_offset)\n                goto error_remove_tracker;\n        }\n        else {\n            if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,\n                frag->pkt + frag->data_offset + frag->ltrim,\n                frag->data_len - frag->ltrim) == -1)\n                goto error_remove_tracker;\n            if (frag->offset + frag->data_len > fragmentable_len)\n                fragmentable_len = frag->offset + frag->data_len;\n        }\n\n        if (!frag->more_frags) {\n            break;\n        }\n    }\n\n    rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);\n    rp->ip6h->s_ip6_plen = htons(fragmentable_len + unfragmentable_len);\n    /* if we have no unfragmentable part, so no ext hdrs before the frag\n     * header, we need to update the ipv6 headers next header field. This\n     * points to the frag header, and we will make it point to the layer\n     * directly after the frag header. */\n    if (unfragmentable_len == 0)\n        rp->ip6h->s_ip6_nxt = next_hdr;\n    SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) +\n            unfragmentable_len + fragmentable_len);\n\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\ndone:\n    return rp;\n\nerror_remove_tracker:\n    tracker->remove = 1;\n    DefragTrackerFreeFrags(tracker);\n    if (rp != NULL)\n        PacketFreeOrRelease(rp);\n    return NULL;\n}\n\n/**\n * Insert a new IPv4/IPv6 fragment into a tracker.\n *\n * \\todo Allocate packet buffers from a pool.\n */\nstatic Packet *\nDefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p, PacketQueue *pq)\n{\n    Packet *r = NULL;\n    int ltrim = 0;\n\n    uint8_t more_frags;\n    uint16_t frag_offset;\n\n    /* IPv4 header length - IPv4 only. */\n    uint16_t hlen = 0;\n\n    /* This is the offset of the start of the data in the packet that\n     * falls after the IP header. */\n    uint16_t data_offset;\n\n    /* The length of the (fragmented) data.  This is the length of the\n     * data that falls after the IP header. */\n    uint16_t data_len;\n\n    /* Where the fragment ends. */\n    uint16_t frag_end;\n\n    /* Offset in the packet to the IPv6 header. */\n    uint16_t ip_hdr_offset;\n\n    /* Offset in the packet to the IPv6 frag header. IPv6 only. */\n    uint16_t frag_hdr_offset = 0;\n\n    /* Address family */\n    int af = tracker->af;\n\n    /* settings for updating a payload when an ip6 fragment with\n     * unfragmentable exthdrs are encountered. */\n    int ip6_nh_set_offset = 0;\n    uint8_t ip6_nh_set_value = 0;\n\n#ifdef DEBUG\n    uint64_t pcap_cnt = p->pcap_cnt;\n#endif\n\n    if (tracker->af == AF_INET) {\n        more_frags = IPV4_GET_MF(p);\n        frag_offset = IPV4_GET_IPOFFSET(p) << 3;\n        hlen = IPV4_GET_HLEN(p);\n        data_offset = (uint8_t *)p->ip4h + hlen - GET_PKT_DATA(p);\n        data_len = IPV4_GET_IPLEN(p) - hlen;\n        frag_end = frag_offset + data_len;\n        ip_hdr_offset = (uint8_t *)p->ip4h - GET_PKT_DATA(p);\n\n        /* Ignore fragment if the end of packet extends past the\n         * maximum size of a packet. */\n        if (IPV4_HEADER_LEN + frag_offset + data_len > IPV4_MAXPACKET_LEN) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE);\n            return NULL;\n        }\n    }\n    else if (tracker->af == AF_INET6) {\n        more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);\n        frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);\n        data_offset = p->ip6eh.fh_data_offset;\n        data_len = p->ip6eh.fh_data_len;\n        frag_end = frag_offset + data_len;\n        ip_hdr_offset = (uint8_t *)p->ip6h - GET_PKT_DATA(p);\n        frag_hdr_offset = p->ip6eh.fh_header_offset;\n\n        SCLogDebug(\"mf %s frag_offset %u data_offset %u, data_len %u, \"\n                \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",\n                more_frags ? \"true\" : \"false\", frag_offset, data_offset,\n                data_len, frag_end, ip_hdr_offset, frag_hdr_offset);\n\n        /* handle unfragmentable exthdrs */\n        if (ip_hdr_offset + IPV6_HEADER_LEN < frag_hdr_offset) {\n            SCLogDebug(\"we have exthdrs before fraghdr %u bytes\",\n                    (uint32_t)(frag_hdr_offset - (ip_hdr_offset + IPV6_HEADER_LEN)));\n\n            /* get the offset of the 'next' field in exthdr before the FH,\n             * relative to the buffer start */\n\n            /* store offset and FH 'next' value for updating frag buffer below */\n            ip6_nh_set_offset = p->ip6eh.fh_prev_hdr_offset;\n            ip6_nh_set_value = IPV6_EXTHDR_GET_FH_NH(p);\n            SCLogDebug(\"offset %d, value %u\", ip6_nh_set_offset, ip6_nh_set_value);\n        }\n\n        /* Ignore fragment if the end of packet extends past the\n         * maximum size of a packet. */\n        if (frag_offset + data_len > IPV6_MAXPACKET) {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_PKT_TOO_LARGE);\n            return NULL;\n        }\n    }\n    else {\n        /* Abort - should not happen. */\n        SCLogWarning(SC_ERR_INVALID_ARGUMENT, \"Invalid address family, aborting.\");\n        return NULL;\n    }\n\n    /* Update timeout. */\n    tracker->timeout.tv_sec = p->ts.tv_sec + tracker->host_timeout;\n    tracker->timeout.tv_usec = p->ts.tv_usec;\n\n    Frag *prev = NULL, *next;\n    int overlap = 0;\n    if (!TAILQ_EMPTY(&tracker->frags)) {\n        TAILQ_FOREACH(prev, &tracker->frags, next) {\n            ltrim = 0;\n            next = TAILQ_NEXT(prev, next);\n\n            switch (tracker->policy) {\n            case DEFRAG_POLICY_BSD:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((next != NULL) && (frag_end > next->offset)) {\n                        next->ltrim = frag_end - next->offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_LINUX:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset > prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((next != NULL) && (frag_end > next->offset)) {\n                        next->ltrim = frag_end - next->offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_WINDOWS:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end > prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_SOLARIS:\n                if (frag_offset < prev->offset + prev->data_len) {\n                    if (frag_offset >= prev->offset) {\n                        ltrim = prev->offset + prev->data_len - frag_offset;\n                        overlap++;\n                    }\n                    if ((frag_offset < prev->offset) &&\n                        (frag_end >= prev->offset + prev->data_len)) {\n                        prev->skip = 1;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_FIRST:\n                if ((frag_offset >= prev->offset) &&\n                    (frag_end <= prev->offset + prev->data_len)) {\n                    overlap++;\n                    goto done;\n                }\n                if (frag_offset < prev->offset) {\n                    goto insert;\n                }\n                if (frag_offset < prev->offset + prev->data_len) {\n                    ltrim = prev->offset + prev->data_len - frag_offset;\n                    overlap++;\n                    goto insert;\n                }\n                break;\n            case DEFRAG_POLICY_LAST:\n                if (frag_offset <= prev->offset) {\n                    if (frag_end > prev->offset) {\n                        prev->ltrim = frag_end - prev->offset;\n                        overlap++;\n                    }\n                    goto insert;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n\ninsert:\n    if (data_len - ltrim <= 0) {\n        /* Full packet has been trimmed due to the overlap policy. Overlap\n         * already set. */\n        goto done;\n    }\n\n    /* Allocate fragment and insert. */\n    SCMutexLock(&defrag_context->frag_pool_lock);\n    Frag *new = PoolGet(defrag_context->frag_pool);\n    SCMutexUnlock(&defrag_context->frag_pool_lock);\n    if (new == NULL) {\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);\n        } else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);\n        }\n        goto done;\n    }\n    new->pkt = SCMalloc(GET_PKT_LEN(p));\n    if (new->pkt == NULL) {\n        SCMutexLock(&defrag_context->frag_pool_lock);\n        PoolReturn(defrag_context->frag_pool, new);\n        SCMutexUnlock(&defrag_context->frag_pool_lock);\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);\n        } else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);\n        }\n        goto done;\n    }\n    memcpy(new->pkt, GET_PKT_DATA(p) + ltrim, GET_PKT_LEN(p) - ltrim);\n    new->len = GET_PKT_LEN(p) - ltrim;\n    /* in case of unfragmentable exthdrs, update the 'next hdr' field\n     * in the raw buffer so the reassembled packet will point to the\n     * correct next header after stripping the frag header */\n    if (ip6_nh_set_offset > 0 && frag_offset == 0 && ltrim == 0) {\n        if (new->len > ip6_nh_set_offset) {\n            SCLogDebug(\"updating frag to have 'correct' nh value: %u -> %u\",\n                    new->pkt[ip6_nh_set_offset], ip6_nh_set_value);\n            new->pkt[ip6_nh_set_offset] = ip6_nh_set_value;\n        }\n    }\n\n    new->hlen = hlen;\n    new->offset = frag_offset + ltrim;\n    new->data_offset = data_offset;\n    new->data_len = data_len - ltrim;\n    new->ip_hdr_offset = ip_hdr_offset;\n    new->frag_hdr_offset = frag_hdr_offset;\n    new->more_frags = more_frags;\n#ifdef DEBUG\n    new->pcap_cnt = pcap_cnt;\n#endif\n\n    Frag *frag;\n    TAILQ_FOREACH(frag, &tracker->frags, next) {\n        if (new->offset < frag->offset)\n            break;\n    }\n    if (frag == NULL) {\n        TAILQ_INSERT_TAIL(&tracker->frags, new, next);\n    }\n    else {\n        TAILQ_INSERT_BEFORE(frag, new, next);\n    }\n\n    if (!more_frags) {\n        tracker->seen_last = 1;\n    }\n\n    if (tracker->seen_last) {\n        if (tracker->af == AF_INET) {\n            r = Defrag4Reassemble(tv, tracker, p);\n            if (r != NULL && tv != NULL && dtv != NULL) {\n                StatsIncr(tv, dtv->counter_defrag_ipv4_reassembled);\n                if (pq && DecodeIPV4(tv, dtv, r, (void *)r->ip4h,\n                               IPV4_GET_IPLEN(r), pq) != TM_ECODE_OK) {\n\n                    UNSET_TUNNEL_PKT(r);\n                    r->root = NULL;\n                    TmqhOutputPacketpool(tv, r);\n                    r = NULL;\n                } else {\n                    PacketDefragPktSetupParent(p);\n                }\n            }\n        }\n        else if (tracker->af == AF_INET6) {\n            r = Defrag6Reassemble(tv, tracker, p);\n            if (r != NULL && tv != NULL && dtv != NULL) {\n                StatsIncr(tv, dtv->counter_defrag_ipv6_reassembled);\n                if (pq && DecodeIPV6(tv, dtv, r, (uint8_t *)r->ip6h,\n                               IPV6_GET_PLEN(r) + IPV6_HEADER_LEN,\n                               pq) != TM_ECODE_OK) {\n\n                    UNSET_TUNNEL_PKT(r);\n                    r->root = NULL;\n                    TmqhOutputPacketpool(tv, r);\n                    r = NULL;\n                } else {\n                    PacketDefragPktSetupParent(p);\n                }\n            }\n        }\n    }\n\n\ndone:\n    if (overlap) {\n        if (af == AF_INET) {\n            ENGINE_SET_EVENT(p, IPV4_FRAG_OVERLAP);\n        }\n        else {\n            ENGINE_SET_EVENT(p, IPV6_FRAG_OVERLAP);\n        }\n    }\n    return r;\n}\n\n/**\n * \\brief Get the defrag policy based on the destination address of\n * the packet.\n *\n * \\param p The packet used to get the destination address.\n *\n * \\retval The defrag policy to use.\n */\nuint8_t\nDefragGetOsPolicy(Packet *p)\n{\n    int policy = -1;\n\n    if (PKT_IS_IPV4(p)) {\n        policy = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));\n    }\n    else if (PKT_IS_IPV6(p)) {\n        policy = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));\n    }\n\n    if (policy == -1) {\n        return default_policy;\n    }\n\n    /* Map the OS policies returned from the configured host info to\n     * defrag specific policies. */\n    switch (policy) {\n        /* BSD. */\n    case OS_POLICY_BSD:\n    case OS_POLICY_HPUX10:\n    case OS_POLICY_IRIX:\n        return DEFRAG_POLICY_BSD;\n\n        /* BSD-Right. */\n    case OS_POLICY_BSD_RIGHT:\n        return DEFRAG_POLICY_BSD_RIGHT;\n\n        /* Linux. */\n    case OS_POLICY_OLD_LINUX:\n    case OS_POLICY_LINUX:\n        return DEFRAG_POLICY_LINUX;\n\n        /* First. */\n    case OS_POLICY_OLD_SOLARIS:\n    case OS_POLICY_HPUX11:\n    case OS_POLICY_MACOS:\n    case OS_POLICY_FIRST:\n        return DEFRAG_POLICY_FIRST;\n\n        /* Solaris. */\n    case OS_POLICY_SOLARIS:\n        return DEFRAG_POLICY_SOLARIS;\n\n        /* Windows. */\n    case OS_POLICY_WINDOWS:\n    case OS_POLICY_VISTA:\n    case OS_POLICY_WINDOWS2K3:\n        return DEFRAG_POLICY_WINDOWS;\n\n        /* Last. */\n    case OS_POLICY_LAST:\n        return DEFRAG_POLICY_LAST;\n\n    default:\n        return default_policy;\n    }\n}\n\n/** \\internal\n *\n *  \\retval NULL or a *LOCKED* tracker */\nstatic DefragTracker *\nDefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)\n{\n    return DefragGetTrackerFromHash(p);\n}\n\n/**\n * \\brief Entry point for IPv4 and IPv6 fragments.\n *\n * \\param tv ThreadVars for the calling decoder.\n * \\param p The packet fragment.\n *\n * \\retval A new Packet resembling the re-assembled packet if the most\n *     recent fragment allowed the packet to be re-assembled, otherwise\n *     NULL is returned.\n */\nPacket *\nDefrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, PacketQueue *pq)\n{\n    uint16_t frag_offset;\n    uint8_t more_frags;\n    DefragTracker *tracker;\n    int af;\n\n    if (PKT_IS_IPV4(p)) {\n        af = AF_INET;\n        more_frags = IPV4_GET_MF(p);\n        frag_offset = IPV4_GET_IPOFFSET(p);\n    }\n    else if (PKT_IS_IPV6(p)) {\n        af = AF_INET6;\n        frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);\n        more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);\n    }\n    else {\n        return NULL;\n    }\n\n    if (frag_offset == 0 && more_frags == 0) {\n        return NULL;\n    }\n\n    if (tv != NULL && dtv != NULL) {\n        if (af == AF_INET) {\n            StatsIncr(tv, dtv->counter_defrag_ipv4_fragments);\n        }\n        else if (af == AF_INET6) {\n            StatsIncr(tv, dtv->counter_defrag_ipv6_fragments);\n        }\n    }\n\n    /* return a locked tracker or NULL */\n    tracker = DefragGetTracker(tv, dtv, p);\n    if (tracker == NULL)\n        return NULL;\n\n    Packet *rp = DefragInsertFrag(tv, dtv, tracker, p, pq);\n    DefragTrackerRelease(tracker);\n\n    return rp;\n}\n\nvoid\nDefragInit(void)\n{\n    intmax_t tracker_pool_size;\n    if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size)) {\n        tracker_pool_size = DEFAULT_DEFRAG_HASH_SIZE;\n    }\n\n    /* Load the defrag-per-host lookup. */\n    DefragPolicyLoadFromConfig();\n\n    /* Allocate the DefragContext. */\n    defrag_context = DefragContextNew();\n    if (defrag_context == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC,\n            \"Failed to allocate memory for the Defrag module.\");\n        exit(EXIT_FAILURE);\n    }\n\n    DefragSetDefaultTimeout(defrag_context->timeout);\n    DefragInitConfig(FALSE);\n}\n\nvoid DefragDestroy(void)\n{\n    DefragHashShutdown();\n    DefragContextDestroy(defrag_context);\n    defrag_context = NULL;\n    DefragTreeDestroy();\n}\n\n#ifdef UNITTESTS\n#define IP_MF 0x2000\n\n/**\n * Allocate a test packet.  Nothing to fancy, just a simple IP packet\n * with some payload of no particular protocol.\n */\nstatic Packet *\nBuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n    const char content, int content_len)\n{\n    Packet *p = NULL;\n    int hlen = 20;\n    int ttl = 64;\n    uint8_t *pcontent;\n    IPV4Hdr ip4h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n    //p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n    ip4h.ip_verhl = 4 << 4;\n    ip4h.ip_verhl |= hlen >> 2;\n    ip4h.ip_len = htons(hlen + content_len);\n    ip4h.ip_id = htons(id);\n    ip4h.ip_off = htons(off);\n    if (mf)\n        ip4h.ip_off = htons(IP_MF | off);\n    else\n        ip4h.ip_off = htons(off);\n    ip4h.ip_ttl = ttl;\n    ip4h.ip_proto = proto;\n\n    ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n    ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));\n    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n    SET_IPV4_SRC_ADDR(p, &p->src);\n    SET_IPV4_DST_ADDR(p, &p->dst);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, hlen, pcontent, content_len);\n    SET_PKT_LEN(p, hlen + content_len);\n    SCFree(pcontent);\n\n    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);\n\n    /* Self test. */\n    if (IPV4_GET_VER(p) != 4)\n        goto error;\n    if (IPV4_GET_HLEN(p) != hlen)\n        goto error;\n    if (IPV4_GET_IPLEN(p) != hlen + content_len)\n        goto error;\n    if (IPV4_GET_IPID(p) != id)\n        goto error;\n    if (IPV4_GET_IPOFFSET(p) != off)\n        goto error;\n    if (IPV4_GET_MF(p) != mf)\n        goto error;\n    if (IPV4_GET_IPTTL(p) != ttl)\n        goto error;\n    if (IPV4_GET_IPPROTO(p) != proto)\n        goto error;\n\n    return p;\nerror:\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}\n\nvoid DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                          uint16_t hdrextlen, uint16_t plen,\n                          uint16_t prev_hdrextlen);\n\nstatic Packet *\nIPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n    const char content, int content_len)\n{\n    Packet *p = NULL;\n    uint8_t *pcontent;\n    IPV6Hdr ip6h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n\n    ip6h.s_ip6_nxt = 44;\n    ip6h.s_ip6_hlim = 2;\n\n    /* Source and dest address - very bogus addresses. */\n    ip6h.s_ip6_src[0] = 0x01010101;\n    ip6h.s_ip6_src[1] = 0x01010101;\n    ip6h.s_ip6_src[2] = 0x01010101;\n    ip6h.s_ip6_src[3] = 0x01010101;\n    ip6h.s_ip6_dst[0] = 0x02020202;\n    ip6h.s_ip6_dst[1] = 0x02020202;\n    ip6h.s_ip6_dst[2] = 0x02020202;\n    ip6h.s_ip6_dst[3] = 0x02020202;\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));\n\n    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);\n    IPV6_SET_RAW_VER(p->ip6h, 6);\n    /* Fragmentation header. */\n    IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n    fh->ip6fh_nxt = proto;\n    fh->ip6fh_ident = htonl(id);\n    fh->ip6fh_offlg = htons((off << 3) | mf);\n\n    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);\n    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);\n    SCFree(pcontent);\n\n    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);\n\n    SET_IPV6_SRC_ADDR(p, &p->src);\n    SET_IPV6_DST_ADDR(p, &p->dst);\n\n    /* Self test. */\n    if (IPV6_GET_VER(p) != 6)\n        goto error;\n    if (IPV6_GET_NH(p) != 44)\n        goto error;\n    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)\n        goto error;\n\n    return p;\nerror:\n    fprintf(stderr, \"Error building test packet.\\n\");\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}\n\n/**\n * Test the simplest possible re-assembly scenario.  All packet in\n * order and no overlaps.\n */\nstatic int\nDefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL) {\n        goto end;\n    }\n\n    if (IPV4_GET_HLEN(reassembled) != 20) {\n        goto end;\n    }\n    if (IPV4_GET_IPLEN(reassembled) != 39) {\n        goto end;\n    }\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A') {\n            goto end;\n        }\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B') {\n            goto end;\n        }\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Simple fragmented packet in reverse order.\n */\nstatic int\nDefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV4_GET_HLEN(reassembled) != 20)\n        goto end;\n    if (IPV4_GET_IPLEN(reassembled) != 39)\n        goto end;\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Test the simplest possible re-assembly scenario.  All packet in\n * order and no overlaps.\n */\nstatic int\nIPV6DefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 19)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nIPV6DefragReverseSimpleTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n{\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    /*\n     * Build the packets.\n     */\n\n    int id = 1;\n    Packet *packets[17];\n    memset(packets, 0x00, sizeof(packets));\n\n    /*\n     * Original fragments.\n     */\n\n    /* A*24 at 0. */\n    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n\n    /* B*15 at 32. */\n    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n\n    /* C*24 at 48. */\n    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n\n    /* D*8 at 80. */\n    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n\n    /* E*16 at 104. */\n    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n\n    /* F*24 at 120. */\n    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n\n    /* G*16 at 144. */\n    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n\n    /* H*16 at 160. */\n    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n\n    /* I*8 at 176. */\n    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n\n    /*\n     * Overlapping subsequent fragments.\n     */\n\n    /* J*32 at 8. */\n    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n\n    /* K*24 at 48. */\n    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n\n    /* L*24 at 72. */\n    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n\n    /* M*24 at 96. */\n    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n\n    /* N*8 at 128. */\n    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n\n    /* O*8 at 152. */\n    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n\n    /* P*8 at 160. */\n    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n\n    /* Q*16 at 176. */\n    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n\n    default_policy = policy;\n\n    /* Send all but the last. */\n    for (i = 0; i < 9; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {\n            goto end;\n        }\n    }\n    int overlap = 0;\n    for (; i < 16; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {\n            overlap++;\n        }\n    }\n    if (!overlap) {\n        goto end;\n    }\n\n    /* And now the last one. */\n    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);\n    if (reassembled == NULL) {\n        goto end;\n    }\n\n    if (IPV4_GET_HLEN(reassembled) != 20) {\n        goto end;\n    }\n    if (IPV4_GET_IPLEN(reassembled) != 20 + 192) {\n        goto end;\n    }\n\n    if (memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0) {\n        goto end;\n    }\n    SCFree(reassembled);\n\n    /* Make sure all frags were returned back to the pool. */\n    if (defrag_context->frag_pool->outstanding != 0) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    for (i = 0; i < 17; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nIPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n{\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    /*\n     * Build the packets.\n     */\n\n    int id = 1;\n    Packet *packets[17];\n    memset(packets, 0x00, sizeof(packets));\n\n    /*\n     * Original fragments.\n     */\n\n    /* A*24 at 0. */\n    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n\n    /* B*15 at 32. */\n    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n\n    /* C*24 at 48. */\n    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n\n    /* D*8 at 80. */\n    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n\n    /* E*16 at 104. */\n    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n\n    /* F*24 at 120. */\n    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n\n    /* G*16 at 144. */\n    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n\n    /* H*16 at 160. */\n    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n\n    /* I*8 at 176. */\n    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n\n    /*\n     * Overlapping subsequent fragments.\n     */\n\n    /* J*32 at 8. */\n    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n\n    /* K*24 at 48. */\n    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n\n    /* L*24 at 72. */\n    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n\n    /* M*24 at 96. */\n    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n\n    /* N*8 at 128. */\n    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n\n    /* O*8 at 152. */\n    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n\n    /* P*8 at 160. */\n    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n\n    /* Q*16 at 176. */\n    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n\n    default_policy = policy;\n\n    /* Send all but the last. */\n    for (i = 0; i < 9; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            goto end;\n        }\n    }\n    int overlap = 0;\n    for (; i < 16; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            overlap++;\n        }\n    }\n    if (!overlap)\n        goto end;\n\n    /* And now the last one. */\n    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);\n    if (reassembled == NULL)\n        goto end;\n    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 192)\n        goto end;\n\n    SCFree(reassembled);\n\n    /* Make sure all frags were returned to the pool. */\n    if (defrag_context->frag_pool->outstanding != 0) {\n        printf(\"defrag_context->frag_pool->outstanding %u: \", defrag_context->frag_pool->outstanding);\n        goto end;\n    }\n\n    ret = 1;\n\nend:\n    for (i = 0; i < 17; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragSturgesNovakBsdTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakBsdTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakLinuxTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakLinuxTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakWindowsTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakWindowsTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakSolarisTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakSolarisTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakFirstTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"DDDDDDDD\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakFirstTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"BBBBBBBB\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"CCCCCCCC\"\n        \"LLLLLLLL\"\n        \"DDDDDDDD\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"EEEEEEEE\"\n        \"EEEEEEEE\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"GGGGGGGG\"\n        \"HHHHHHHH\"\n        \"HHHHHHHH\"\n        \"IIIIIIII\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragSturgesNovakLastTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"NNNNNNNN\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"OOOOOOOO\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected, sizeof(expected));\n}\n\nstatic int\nIPV6DefragSturgesNovakLastTest(void)\n{\n    /* Expected data. */\n    u_char expected[] = {\n        \"AAAAAAAA\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"JJJJJJJJ\"\n        \"BBBBBBBB\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"KKKKKKKK\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"LLLLLLLL\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"MMMMMMMM\"\n        \"FFFFFFFF\"\n        \"NNNNNNNN\"\n        \"FFFFFFFF\"\n        \"GGGGGGGG\"\n        \"OOOOOOOO\"\n        \"PPPPPPPP\"\n        \"HHHHHHHH\"\n        \"QQQQQQQQ\"\n        \"QQQQQQQQ\"\n    };\n\n    return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,\n        sizeof(expected));\n}\n\nstatic int\nDefragTimeoutTest(void)\n{\n    int i;\n    int ret = 0;\n\n    /* Setup a small numberr of trackers. */\n    if (ConfSet(\"defrag.trackers\", \"16\") != 1) {\n        printf(\"ConfSet failed: \");\n        goto end;\n    }\n\n    DefragInit();\n\n    /* Load in 16 packets. */\n    for (i = 0; i < 16; i++) {\n        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n        if (p == NULL)\n            goto end;\n\n        Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n        SCFree(p);\n\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n    }\n\n    /* Build a new packet but push the timestamp out by our timeout.\n     * This should force our previous fragments to be timed out. */\n    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n    if (p == NULL)\n        goto end;\n\n    p->ts.tv_sec += (defrag_context->timeout + 1);\n    Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n    if (tp != NULL) {\n        SCFree(tp);\n        goto end;\n    }\n\n    DefragTracker *tracker = DefragLookupTrackerFromHash(p);\n    if (tracker == NULL)\n        goto end;\n\n    if (tracker->id != 99)\n        goto end;\n\n    SCFree(p);\n\n    ret = 1;\nend:\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * QA found that if you send a packet where more frags is 0, offset is\n * > 0 and there is no data in the packet that the re-assembler will\n * fail.  The fix was simple, but this unit test is just to make sure\n * its not introduced.\n */\nstatic int\nDefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* This packet has an offset > 0, more frags set to 0 and no data. */\n    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should\n     * have been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}\n\nstatic int\nDefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * Test that fragments in different VLANs that would otherwise be\n * re-assembled, are not re-assembled.  Just use simple in-order\n * fragments.\n */\nstatic int\nDefragVlanTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    /* With no VLAN IDs set, packets should re-assemble. */\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    /* With mismatched VLANs, packets should not re-assemble. */\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    /* Pass. */\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}\n\n/**\n * Like DefragVlanTest, but for QinQ, testing the second level VLAN ID.\n */\nstatic int\nDefragVlanQinQTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    /* With no VLAN IDs set, packets should re-assemble. */\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    /* With mismatched VLANs, packets should not re-assemble. */\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 1;\n    p1->vlan_id[1] = 1;\n    p2->vlan_id[1] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    /* Pass. */\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}\n\nstatic int DefragTrackerReuseTest(void)\n{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {\n        goto end;\n    }\n    if (tracker1->remove) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Get a tracker again, it should be the same one. */\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 != tracker1) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    /* Now mark the tracker for removal. It should not be returned\n     * when we get a tracker for a packet that may have the same\n     * attributes. */\n    tracker1->remove = 1;\n\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 == tracker1) {\n        goto end;\n    }\n    if (tracker2->remove) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    DefragDestroy();\n    return ret;\n}\n\n/**\n * IPV4: Test the case where you have a packet fragmented in 3 parts\n * and send like:\n * - Offset: 2; MF: 1\n * - Offset: 0; MF: 1\n * - Offset: 1; MF: 0\n *\n * Only the fragments with offset 0 and 1 should be reassembled.\n */\nstatic int DefragMfIpv4Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* Expected IP length is 20 + 8 + 8 = 36 as only 2 of the\n     * fragments should be in the re-assembled packet. */\n    if (IPV4_GET_IPLEN(p) != 36) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}\n\n/**\n * IPV6: Test the case where you have a packet fragmented in 3 parts\n * and send like:\n * - Offset: 2; MF: 1\n * - Offset: 0; MF: 1\n * - Offset: 1; MF: 0\n *\n * Only the fragments with offset 0 and 1 should be reassembled.\n */\nstatic int DefragMfIpv6Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* For IPv6 the expected length is just the length of the payload\n     * of 2 fragments, so 16. */\n    if (IPV6_GET_PLEN(p) != 16) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}\n\n/**\n * \\brief Test that fragments that match other than the proto don't\n * actually get matched.\n */\nstatic int DefragTestBadProto(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    int id = 12;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n    FAIL_IF_NULL(p1);\n    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n    FAIL_IF_NULL(p2);\n    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n    FAIL_IF_NULL(p3);\n\n    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n\n    DefragDestroy();\n    PASS;\n}\n\n#endif /* UNITTESTS */\n\nvoid\nDefragRegisterTests(void)\n{\n#ifdef UNITTESTS\n    UtRegisterTest(\"DefragInOrderSimpleTest\", DefragInOrderSimpleTest);\n    UtRegisterTest(\"DefragReverseSimpleTest\", DefragReverseSimpleTest);\n    UtRegisterTest(\"DefragSturgesNovakBsdTest\", DefragSturgesNovakBsdTest);\n    UtRegisterTest(\"DefragSturgesNovakLinuxTest\", DefragSturgesNovakLinuxTest);\n    UtRegisterTest(\"DefragSturgesNovakWindowsTest\",\n                   DefragSturgesNovakWindowsTest);\n    UtRegisterTest(\"DefragSturgesNovakSolarisTest\",\n                   DefragSturgesNovakSolarisTest);\n    UtRegisterTest(\"DefragSturgesNovakFirstTest\", DefragSturgesNovakFirstTest);\n    UtRegisterTest(\"DefragSturgesNovakLastTest\", DefragSturgesNovakLastTest);\n\n    UtRegisterTest(\"DefragIPv4NoDataTest\", DefragIPv4NoDataTest);\n    UtRegisterTest(\"DefragIPv4TooLargeTest\", DefragIPv4TooLargeTest);\n\n    UtRegisterTest(\"IPV6DefragInOrderSimpleTest\", IPV6DefragInOrderSimpleTest);\n    UtRegisterTest(\"IPV6DefragReverseSimpleTest\", IPV6DefragReverseSimpleTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakBsdTest\",\n                   IPV6DefragSturgesNovakBsdTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakLinuxTest\",\n                   IPV6DefragSturgesNovakLinuxTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakWindowsTest\",\n                   IPV6DefragSturgesNovakWindowsTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakSolarisTest\",\n                   IPV6DefragSturgesNovakSolarisTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakFirstTest\",\n                   IPV6DefragSturgesNovakFirstTest);\n    UtRegisterTest(\"IPV6DefragSturgesNovakLastTest\",\n                   IPV6DefragSturgesNovakLastTest);\n\n    UtRegisterTest(\"DefragVlanTest\", DefragVlanTest);\n    UtRegisterTest(\"DefragVlanQinQTest\", DefragVlanQinQTest);\n    UtRegisterTest(\"DefragTrackerReuseTest\", DefragTrackerReuseTest);\n    UtRegisterTest(\"DefragTimeoutTest\", DefragTimeoutTest);\n    UtRegisterTest(\"DefragMfIpv4Test\", DefragMfIpv4Test);\n    UtRegisterTest(\"DefragMfIpv6Test\", DefragMfIpv6Test);\n    UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);\n#endif /* UNITTESTS */\n}\n\n", "/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Endace Technology Limited, Jason Ish <jason.ish@endace.com>\n */\n\n#ifndef __DEFRAG_H__\n#define __DEFRAG_H__\n\n#include \"util-pool.h\"\n\n/**\n * A context for an instance of a fragmentation re-assembler, in case\n * we ever need more than one.\n */\ntypedef struct DefragContext_ {\n    Pool *frag_pool; /**< Pool of fragments. */\n    SCMutex frag_pool_lock;\n\n    time_t timeout; /**< Default timeout. */\n} DefragContext;\n\n/**\n * Storage for an individual fragment.\n */\ntypedef struct Frag_ {\n    uint16_t offset;            /**< The offset of this fragment, already\n                                 *   multiplied by 8. */\n\n    uint16_t len;               /**< The length of this fragment. */\n\n    uint8_t hlen;               /**< The length of this fragments IP header. */\n\n    uint8_t more_frags:4;       /**< More frags? */\n    uint8_t skip:4;             /**< Skip this fragment during re-assembly. */\n\n    uint16_t ip_hdr_offset;     /**< Offset in the packet where the IP\n                                 * header starts. */\n    uint16_t frag_hdr_offset;   /**< Offset in the packet where the frag\n                                 * header starts. */\n\n    uint16_t data_offset;       /**< Offset to the packet data. */\n    uint16_t data_len;          /**< Length of data. */\n\n    uint16_t ltrim;             /**< Number of leading bytes to trim when\n                                 * re-assembling the packet. */\n\n    uint8_t *pkt;               /**< The actual packet. */\n\n#ifdef DEBUG\n    uint64_t pcap_cnt;          /**< pcap_cnt of original packet */\n#endif\n\n    TAILQ_ENTRY(Frag_) next;    /**< Pointer to next fragment for tailq. */\n} Frag;\n\n/**\n * A defragmentation tracker.  Used to track fragments that make up a\n * single packet.\n */\ntypedef struct DefragTracker_ {\n    SCMutex lock; /**< Mutex for locking list operations on\n                           * this tracker. */\n\n    uint16_t vlan_id[2]; /**< VLAN ID tracker applies to. */\n\n    uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                  * for IPv4. */\n\n    uint8_t proto; /**< IP protocol for this tracker. */\n\n    uint8_t policy; /**< Reassembly policy this tracker will use. */\n\n    uint8_t af; /**< Address family for this tracker, AF_INET or\n                 * AF_INET6. */\n\n    uint8_t seen_last; /**< Has this tracker seen the last fragment? */\n\n    uint8_t remove; /**< remove */\n\n    Address src_addr; /**< Source address for this tracker. */\n    Address dst_addr; /**< Destination address for this tracker. */\n\n    struct timeval timeout; /**< When this tracker will timeout. */\n    uint32_t host_timeout;  /**< Host timeout, statically assigned from the yaml */\n\n    /** use cnt, reference counter */\n    SC_ATOMIC_DECLARE(unsigned int, use_cnt);\n\n    TAILQ_HEAD(frag_tailq, Frag_) frags; /**< Head of list of fragments. */\n\n    /** hash pointers, protected by hash row mutex/spin */\n    struct DefragTracker_ *hnext;\n    struct DefragTracker_ *hprev;\n\n    /** list pointers, protected by tracker-queue mutex/spin */\n    struct DefragTracker_ *lnext;\n    struct DefragTracker_ *lprev;\n} DefragTracker;\n\nvoid DefragInit(void);\nvoid DefragDestroy(void);\nvoid DefragReload(void); /**< use only in unittests */\n\nuint8_t DefragGetOsPolicy(Packet *);\nvoid DefragTrackerFreeFrags(DefragTracker *);\nPacket *Defrag(ThreadVars *, DecodeThreadVars *, Packet *, PacketQueue *);\nvoid DefragRegisterTests(void);\n\n#endif /* __DEFRAG_H__ */\n"], "filenames": ["src/defrag-hash.c", "src/defrag.c", "src/defrag.h"], "buggy_code_start_loc": [94, 999, 86], "buggy_code_end_loc": [408, 2585, 86], "fixing_code_start_loc": [95, 999, 87], "fixing_code_end_loc": [411, 2620, 89], "type": "CWE-358", "message": "Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.", "other": {"cve": {"id": "CVE-2017-7177", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-18T20:59:00.173", "lastModified": "2018-12-05T11:29:01.343", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching."}, {"lang": "es", "value": "Suricata en versiones anteriores a 3.2.1 tiene un problema de evasi\u00f3n de desfragmentaci\u00f3n IPv4 provocado por la falta de una comprobaci\u00f3n para el protocolo IP durante la coincidencia de fragmentos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-358"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openinfosecfoundation:suricata:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "0544C003-683A-455F-B07A-6374901D983C"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97047", "source": "cve@mitre.org"}, {"url": "https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00000.html", "source": "cve@mitre.org"}, {"url": "https://redmine.openinfosecfoundation.org/issues/2019", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8"}}