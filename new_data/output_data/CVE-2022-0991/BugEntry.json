{"buggy_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2022 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handle session data of Admidio and is connected to database table adm_sessions\n *\n * This class should be used together with the PHP session handling. If you\n * create a PHP session than you should also create this session object. The\n * class will create a recordset in adm_sessions which stores the PHP session id.\n * With this class it should be easy to add other objects to the session and read\n * them out if you need them elsewhere.\n *\n * **Code examples**\n * ```\n * // add a new object to the session\n * $organization = new Organization($gDb, $organizationId);\n * $session = new Session($gDb, $sessionId);\n * $session->addObject('organization', $organization, true);\n *\n * // read object out of session\n * if($session->hasObject('organization'))\n * {\n *     $organization =& $session->getObject('organization');\n * }\n * ```\n */\nclass Session extends TableAccess\n{\n    /**\n     * @var array<string,mixed> Array with all objects of this session object.\n     */\n    protected $mObjectArray = array();\n    /**\n     * @var AutoLogin|null Object of table auto login that will handle an auto login\n     */\n    protected $mAutoLogin;\n    /**\n     * @var string\n     */\n    protected $cookieAutoLoginId;\n    /**\n     * @var string a 30 character long CSRF token\n     */\n    protected $csrfToken = '';\n\n    /**\n     * Constructor that will create an object of a recordset of the table adm_sessions.\n     * If the id is set than the specific session will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $cookiePrefix The prefix that is used for cookies\n     */\n    public function __construct(Database $database, $cookiePrefix = '')\n    {\n        parent::__construct($database, TBL_SESSIONS, 'ses');\n\n        // determine session id\n        if (array_key_exists(COOKIE_PREFIX . '_SESSION_ID', $_COOKIE)) {\n            $sessionId = $_COOKIE[COOKIE_PREFIX . '_SESSION_ID'];\n        } else {\n            $sessionId = session_id();\n        }\n\n        $this->cookieAutoLoginId = $cookiePrefix . '_AUTO_LOGIN_ID';\n\n        if (is_int($sessionId)) {\n            $this->readDataById($sessionId);\n        } else {\n            $this->readDataByColumns(array('ses_session_id' => $sessionId));\n\n            if ($this->newRecord) {\n                // if PHP session id was commited then store them in that field\n                $this->setValue('ses_session_id', $sessionId);\n                $this->setValue('ses_timestamp', DATETIME_NOW);\n            }\n        }\n\n        // check for a valid auto login\n        $this->refreshAutoLogin();\n    }\n\n    /**\n     * Adds an object to the object array of this class. Objects in this array\n     * will be stored in the session and could be read with the method **getObject**.\n     * @param string $objectName Internal unique name of the object.\n     * @param object $object     The object that should be stored in this class.\n     * @return bool Return false if object isn't type object or objectName already exists\n     */\n    public function addObject(string $objectName, &$object): bool\n    {\n        if (is_object($object) && !array_key_exists($objectName, $this->mObjectArray)) {\n            $this->mObjectArray[$objectName] = &$object;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * clear user data\n     */\n    protected function clearUserData()\n    {\n        global $gCurrentUser;\n\n        if (isset($gCurrentUser) && $gCurrentUser instanceof User) {\n            $gCurrentUser->clear();\n        }\n        $this->setValue('ses_usr_id', '');\n    }\n\n    /**\n     * Returns a CSRF token from the session. If no CSRF token exists a new one will be\n     * generated and stored within the session. The next call of the method will than\n     * return the existing token. The CSRF token has 30 characters. A new token could\n     * be forced by the paramter **$newToken**\n     * @param bool $newToken If set to true, always a new token will be generated.\n     * @return string Returns the CSRF token\n     */\n    public function getCsrfToken(bool $newToken = false): string\n    {\n        if ($this->csrfToken === '' || $newToken) {\n            $this->csrfToken = SecurityUtils::getRandomString(30);\n        }\n\n        return $this->csrfToken;\n    }\n\n    /**\n     * Returns a reference of an object that is stored in the session.\n     * This is necessary because the old database connection is not longer valid.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return object|false Returns the reference to the object or false if the object was not found.\n     */\n    public function &getObject(string $objectName)\n    {\n        if (!array_key_exists($objectName, $this->mObjectArray)) {\n            // use parameter because we return a reference so only value will return an error\n            $returnValue = false;\n            return $returnValue;\n        }\n\n        // return reference of object\n        return $this->mObjectArray[$objectName];\n    }\n\n    /**\n     * Return the organization id of this session. If AutoLogin is enabled then the\n     * organization may not be the organization of the config.php because the\n     * user had set the AutoLogin to a different organization.\n     * @return int Returns the organization id of this session\n     */\n    public function getOrganizationId(): int\n    {\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            return (int) $this->mAutoLogin->getValue('atl_org_id');\n        }\n\n        return (int) $this->getValue('ses_org_id');\n    }\n\n    /**\n     * Checks if the object with this name exists in the object array of this class.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return bool Returns **true** if the object exits otherwise **false**\n     */\n    public function hasObject(string $objectName): bool\n    {\n        return array_key_exists($objectName, $this->mObjectArray);\n    }\n\n    /**\n     * Initialize the array with all objects except the gNavigation object. If the session got an refresh\n     * the existing navigation should still be stored in the refreshed sesssion.\n     */\n    public function initializeObjects()\n    {\n        foreach($this->mObjectArray as $key => $element) {\n            if($key !== 'gNavigation') {\n                unset($this->mObjectArray[$key]);\n            }\n        }\n    }\n\n    /**\n     * Check if the current session has a valid user login. Therefore the user id must be stored\n     * within the session and the timestamps must be valid\n     * @param int $userId The user id must be stored in this session and will be checked if valid.\n     * @return bool Returns **true** if the user has a valid session login otherwise **false**;\n     */\n    public function isValidLogin(int $userId): bool\n    {\n        global $gSettingsManager;\n\n        if ($userId > 0) {\n            if ((int) $this->getValue('ses_usr_id') === $userId) {\n                // session has a user assigned -> check if login is still valid\n                $timeGap = time() - strtotime($this->getValue('ses_timestamp', 'Y-m-d H:i:s'));\n\n                // Check how long the user was inactive. If time range is to long -> logout\n                // if user has auto login than session is also valid\n                if ($this->mAutoLogin instanceof AutoLogin || $timeGap < $gSettingsManager->getInt('logout_minutes') * 60) {\n                    return true;\n                }\n            }\n\n            // user was inactive -> clear user data and remove him from session\n            // something is wrong -> clear user data\n            $this->clearUserData();\n        }\n\n        return false;\n    }\n\n    /**\n     * The current user should be removed from the session and auto login.\n     * Also the auto login cookie should be removed.\n     */\n    public function logout()\n    {\n        $this->db->startTransaction();\n\n        // remove user from current session\n        $this->setValue('ses_usr_id', '');\n        $this->save();\n\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            // remove auto login cookie from users browser by setting expired timestamp to 0\n            self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'));\n\n            // delete auto login and remove all data\n            $this->mAutoLogin->delete();\n            $this->mAutoLogin = null;\n        }\n\n        $this->db->endTransaction();\n    }\n\n    /**\n     * Reload auto login data from database table adm_auto_login. if cookie PREFIX_AUTO_LOGIN_ID\n     * is set then there could be an auto login the auto login must be done here because after\n     * that the corresponding organization must be set.\n     */\n    public function refreshAutoLogin()\n    {\n        if (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            // restore user from auto login session\n            $this->mAutoLogin = new AutoLogin($this->db, $_COOKIE[$this->cookieAutoLoginId]);\n\n            // valid AutoLogin found\n            if ($this->mAutoLogin->getValue('atl_id') > 0) {\n                $autoLoginId = $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id'));\n                $this->mAutoLogin->setValue('atl_auto_login_id', $autoLoginId);\n                $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n                $this->mAutoLogin->save();\n\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n\n                // save cookie for autologin\n                $currDateTime = new \\DateTime();\n                $oneYearDateInterval = new \\DateInterval('P1Y');\n                $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n                $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n                self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n            } else {\n                // an invalid AutoLogin should made the current AutoLogin unusable\n                $this->mAutoLogin = null;\n                self::setCookie($this->cookieAutoLoginId, $_COOKIE[$this->cookieAutoLoginId]);\n\n                // now count invalid auto login for this user and delete all auto login of this users if number of wrong logins > 3\n                $autoLoginParts = explode(':', $_COOKIE[$this->cookieAutoLoginId]);\n                $userId = $autoLoginParts[0];\n\n                if ($userId > 0) {\n                    $sql = 'UPDATE '.TBL_AUTO_LOGIN.'\n                               SET atl_number_invalid = atl_number_invalid + 1\n                             WHERE atl_usr_id = ? -- $userId';\n                    $this->db->queryPrepared($sql, array($userId));\n\n                    $sql = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                             WHERE atl_usr_id = ? -- $userId\n                               AND atl_number_invalid > 3 ';\n                    $this->db->queryPrepared($sql, array($userId));\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload session data from database table adm_sessions. If IP address check is activated than check if the IP\n     * address has changed. Refresh AutoLogin with new auto_login_id.\n     */\n    public function refresh()\n    {\n        // read session data from database to update the renew flag\n        $this->readDataById((int) $this->getValue('ses_id'));\n\n        // check if current connection has same ip address as of session initialization\n        // if config parameter $gCheckIpAddress = 0 then don't check ip address\n        $sesIpAddress = $this->getValue('ses_ip_address');\n        if (isset($GLOBALS['gCheckIpAddress']) && $GLOBALS['gCheckIpAddress'] && $sesIpAddress !== '' && $sesIpAddress !== $_SERVER['REMOTE_ADDR']) {\n            $GLOBALS['gLogger']->warning('Admidio stored session ip address: ' . $sesIpAddress . ' :: Remote ip address: ' . $_SERVER['REMOTE_ADDR']);\n            $GLOBALS['gLogger']->warning('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n\n            exit('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n        }\n\n        // session in database could be deleted if user was some time inactive and another user\n        // clears the table. Therefor we must reset the user id\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            if ((int) $this->getValue('ses_usr_id') === 0) {\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n            }\n        } elseif (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            $this->refreshAutoLogin();\n        }\n    }\n\n    /**\n     * This method will replace the current session ID with a new one, and keep the current session information.\n     * The new session id will be stored in the database.\n     */\n    public function regenerateId()\n    {\n        session_regenerate_id();\n\n        $this->setValue('ses_session_id', session_id());\n        $this->save();\n    }\n\n    /**\n     * This method will reload all stored objects of all active sessions. The session will be\n     * reloaded if the user will open a new page.\n     */\n    public function reloadAllSessions()\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true ';\n        $this->db->queryPrepared($sql);\n    }\n\n    /**\n     * This method will reload the session of a specific user. All stored objects of the session will be initialized\n     * and reloaded if the user opens a new page.\n     * @param int $userId Id of the user whose session should be relaoded.\n     */\n    public function reload(int $userId)\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true\n                 WHERE ses_usr_id = ?  -- $userId';\n        $this->db->queryPrepared($sql, array($userId));\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update\n     * the changed columns. If the table has columns for creator or editor than these column\n     * with their timestamp will be updated.\n     * For new records the organization, timestamp, begin date and ip address will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true): bool\n    {\n        if ($this->newRecord) {\n            // Insert\n            $this->setValue('ses_org_id', $GLOBALS['gCurrentOrgId']);\n            $this->setValue('ses_begin', DATETIME_NOW);\n            // remove the last part of the IP because of privacy (GDPR)\n            $ip = preg_replace(array('/\\.\\d+$/', '/[\\da-f]*:[\\da-f]*$/'), array('.XXX', 'XXXX:XXXX'), $_SERVER['REMOTE_ADDR']);\n            $this->setValue('ses_ip_address', $ip);\n        }\n\n        // Insert & Update\n        $this->setValue('ses_timestamp', DATETIME_NOW);\n\n        return parent::save($updateFingerPrint);\n    }\n\n    /**\n     * Save all data that is necessary for an auto login. Therefore an AutoLogin object\n     * will be created with an auto_login_id and this id will be stored in a cookie\n     * in the browser of the current user.\n     */\n    public function setAutoLogin()\n    {\n        // create object and set current session data to AutoLogin\n        $this->mAutoLogin = new AutoLogin($this->db);\n        $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n        $this->mAutoLogin->setValue('atl_org_id', (int) $this->getValue('ses_org_id'));\n        $this->mAutoLogin->setValue('atl_usr_id', (int) $this->getValue('ses_usr_id'));\n\n        // set new auto_login_id and save data\n        $this->mAutoLogin->setValue('atl_auto_login_id', $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id')));\n        $this->mAutoLogin->save();\n\n        // save cookie for autologin\n        $currDateTime = new \\DateTime();\n        $oneYearDateInterval = new \\DateInterval('P1Y');\n        $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n        $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n        self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n    }\n\n    /**\n     * @param string $name     Name of the cookie.\n     * @param string $value    Value of the cookie. If value is \"empty string\" or \"false\",\n     *                         the cookie will be set as deleted (Expire is set to 1 year in the past).\n     * @param int $expire   The Unix-Timestamp (Seconds) of the Date/Time when the cookie should expire.\n     *                         With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path     Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain   Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure   If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly If \"true\" cookie is accessible only via HTTP.\n     *                         Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @return bool Returns \"true\" if the cookie is successfully set.\n     */\n    public static function setCookie(\n        string $name,\n        string $value = '',\n        int $expire = 0,\n        string $path = '',\n        string $domain = '',\n        bool $secure = null,\n        bool $httpOnly = true\n    ): bool {\n        global $gLogger, $gSetCookieForDomain;\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n        if ($domain === '') {\n            $domain = DOMAIN;\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        $gLogger->info('Set Cookie!', array('name' => $name, 'value' => $value, 'expire' => $expire, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax'));\n\n        if (PHP_VERSION_ID < 70300) {\n            return setcookie($name, $value, $expire, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            return setcookie($name, $value, array(\n                'expires'  => $expire,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n    }\n\n    /**\n     * @param string $cookiePrefix The prefix name of the Cookie.\n     * @param int $limit        The Lifetime (Seconds) of the cookie when it should expire.\n     *                             With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path         Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain       Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure       If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly     If \"true\" cookie is accessible only via HTTP.\n     *                             Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @throws \\RuntimeException\n     */\n    public static function start(string $cookiePrefix, int $limit = 0, string $path = '', string $domain = '', bool $secure = null, bool $httpOnly = true)\n    {\n        global $gLogger, $gSetCookieForDomain;\n\n        if (headers_sent()) {\n            $message = 'HTTP-Headers already sent!';\n            $gLogger->alert($message);\n\n            throw new \\RuntimeException($message);\n        }\n\n        $sessionName = $cookiePrefix . '_SESSION_ID';\n\n        // Set the cookie name\n        session_name($sessionName);\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n\n        if ($domain === '') {\n            $domain = DOMAIN;\n\n            // TODO: Test if this is necessary\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        if (PHP_VERSION_ID < 70300) {\n            session_set_cookie_params($limit, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            session_set_cookie_params(array(\n                'lifetime' => $limit,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $gLogger->notice('Session is already started!', array('sessionId' => session_id()));\n        }\n\n        // Start session\n        session_start();\n\n        $gLogger->info('Session Started!', array('name' => $sessionName, 'limit' => $limit, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax', 'sessionId' => session_id()));\n    }\n\n    /**\n     * Deletes all sessions in table admSessions that are inactive since **$maxInactiveTime** minutes..\n     * @param int $maxInactiveMinutes Time in Minutes after that a session will be deleted.\n     */\n    public function tableCleanup(int $maxInactiveMinutes = 30)\n    {\n        $now = new \\DateTime();\n        $minutesBack = new \\DateInterval('PT' . $maxInactiveMinutes . 'M');\n        $timestamp = $now->sub($minutesBack)->format('Y-m-d H:i:s');\n\n        $sql = 'DELETE FROM '.TBL_SESSIONS.'\n                 WHERE ses_timestamp < ? -- $timestamp\n                   AND ses_session_id <> ? -- $this->getValue(\\'ses_session_id\\')';\n        $this->db->queryPrepared($sql, array($timestamp, $this->getValue('ses_session_id')));\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * Class handle role rights, cards and other things of users\n *\n * @copyright 2004-2022 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handles all the user data and the rights. This is used for the current login user and for other users of the database.\n */\nclass User extends TableAccess\n{\n    public const MAX_INVALID_LOGINS = 3;\n\n    /**\n     * @var bool\n     */\n    protected $administrator;\n    /**\n     * @var ProfileFields object with current user field structure\n     */\n    protected $mProfileFieldsData;\n    /**\n     * @var array<string,bool> Array with all roles rights and the status of the current user e.g. array('rol_assign_roles' => false, 'rol_approve_users' => true ...)\n     */\n    protected $rolesRights = array();\n    /**\n     * @var array<int,bool> Array with all roles and a flag if the user could view this role e.g. array('role_id_1' => '1', 'role_id_2' => '0' ...)\n     */\n    protected $listViewRights = array();\n    /**\n     * @var array<int,bool> Array with all roles and a flag if the user could write a mail to this role e.g. array('role_id_1' => '1', 'role_id_2' => '0' ...)\n     */\n    protected $listMailRights = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned\n     */\n    protected $rolesMembership = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned and is leader (key = role_id; value = rol_leader_rights)\n     */\n    protected $rolesMembershipLeader = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned and is not a leader of the role\n     */\n    protected $rolesMembershipNoLeader = array();\n    /**\n     * @var int the organization for which the rights are read, could be changed with method **setOrganization**\n     */\n    protected $organizationId;\n    /**\n     * @var bool Flag if the user has the right to assign at least one role\n     */\n    protected $assignRoles;\n    /**\n     * @var array<int,bool> Array with all user ids where the current user is allowed to edit the profile.\n     */\n    protected $usersEditAllowed = array();\n    /**\n     * @var array<int,array<string,int|bool>> Array with all users to whom the current user has a relationship\n     */\n    protected $relationships = array();\n    /**\n     * @var bool Flag if relationships for this user were checked\n     */\n    protected $relationshipsChecked = false;\n\n    /**\n     * Constructor that will create an object of a recordset of the users table.\n     * If the id is set than this recordset will be loaded.\n     * @param Database      $database   Object of the class Database. This should be the default global object **$gDb**.\n     * @param ProfileFields $userFields An object of the ProfileFields class with the profile field structure\n     *                                  of the current organization. This could be the default object **$gProfileFields**.\n     * @param int           $userId     The id of the user who should be loaded. If id isn't set than an empty\n     *                                  object with no specific user is created.\n     */\n    public function __construct(Database $database, ProfileFields $userFields = null, $userId = 0)\n    {\n        if ($userFields !== null) {\n            $this->mProfileFieldsData = clone $userFields; // create explicit a copy of the object (param is in PHP5 a reference)\n        }\n\n        $this->organizationId = $GLOBALS['gCurrentOrgId'];\n\n        parent::__construct($database, TBL_USERS, 'usr', $userId);\n    }\n\n    /**\n     * Checks if the current user is allowed to edit a profile field of the user of the parameter.\n     * @param User   $user            User object of the user that should be checked if the current user can view his profile field.\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should be checked.\n     * @return bool Return true if the current user is allowed to view this profile field of **$user**.\n     */\n    public function allowedEditProfileField(self $user, $fieldNameIntern)\n    {\n        return $this->hasRightEditProfile($user) && $user->mProfileFieldsData->isEditable($fieldNameIntern, $this->hasRightEditProfile($user));\n    }\n\n    /**\n     * Checks if the current user is allowed to view a profile field of the user of the parameter.\n     * It will check if the current user could view the profile field category. Within the own profile\n     * you can view profile fields of hidden categories. We will also check if the current user\n     * could edit the **$user** profile so the current user could also view hidden fields.\n     * @param User   $user            User object of the user that should be checked if the current user can view his profile field.\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should be checked.\n     * @return bool Return true if the current user is allowed to view this profile field of **$user**.\n     */\n    public function allowedViewProfileField(self $user, $fieldNameIntern)\n    {\n        return $user->mProfileFieldsData->isVisible($fieldNameIntern, $this->hasRightEditProfile($user));\n    }\n\n    /**\n     * Assign the user to all roles that have set the flag **rol_default_registration**.\n     * These flag should be set if you want that every new user should get this role.\n     */\n    public function assignDefaultRoles()\n    {\n        global $gMessage, $gL10n;\n\n        $this->db->startTransaction();\n\n        // every user will get the default roles for registration, if the current user has the right to assign roles\n        // than the roles assignment dialog will be shown\n        $sql = 'SELECT rol_id\n                  FROM '.TBL_ROLES.'\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE rol_default_registration = 1\n                   AND cat_org_id = ? -- $this->organizationId';\n        $defaultRolesStatement = $this->db->queryPrepared($sql, array($this->organizationId));\n\n        if ($defaultRolesStatement->rowCount() === 0) {\n            $gMessage->show($gL10n->get('PRO_NO_DEFAULT_ROLE'));\n            // => EXIT\n        }\n\n        while ($rolId = $defaultRolesStatement->fetchColumn()) {\n            // starts a membership for role from now\n            $this->setRoleMembership($rolId);\n        }\n\n        $this->db->endTransaction();\n    }\n\n    /**\n     * @param string $mode      'set' or 'edit'\n     * @param int $id           Id of the role for which the membership should be set,\n     *                          or id of the current membership that should be edited.\n     * @param string $startDate New start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   New end date of the membership. Default will be **31.12.9999**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully added/edited.\n     */\n    private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n    {\n        if ($startDate === '' || $endDate === '') {\n            return false;\n        }\n\n        $usrId = (int) $this->getValue('usr_id');\n\n        $minStartDate = $startDate;\n        $maxEndDate   = $endDate;\n\n        if ($mode === 'set') {\n            // subtract 1 day from start date so that we find memberships that ends yesterday\n            // these memberships can be continued with new date\n            $oneDayOffset = new \\DateInterval('P1D');\n\n            $startDate = \\DateTime::createFromFormat('Y-m-d', $startDate)->sub($oneDayOffset)->format('Y-m-d');\n            // add 1 to max date because we subtract one day if a membership ends\n            if ($endDate !== DATE_MAX) {\n                $endDate = \\DateTime::createFromFormat('Y-m-d', $endDate)->add($oneDayOffset)->format('Y-m-d');\n            }\n        }\n\n        $this->db->startTransaction();\n\n        // search for membership with same role and user and overlapping dates\n        if ($mode === 'set') {\n            $member = new TableMembers($this->db);\n\n            $sql = 'SELECT *\n                      FROM '.TBL_MEMBERS.'\n                     WHERE mem_rol_id = ? -- $id\n                       AND mem_usr_id = ? -- $usrId\n                       AND mem_begin <= ? -- $endDate\n                       AND mem_end   >= ? -- $startDate\n                  ORDER BY mem_begin ASC';\n            $queryParams = array(\n                $id,\n                $usrId,\n                $endDate,\n                $startDate\n            );\n        } else {\n            $member = new TableMembers($this->db, $id);\n\n            $sql = 'SELECT *\n                      FROM '.TBL_MEMBERS.'\n                     WHERE mem_id    <> ? -- $id\n                       AND mem_rol_id = ? -- $member->getValue(\\'mem_rol_id\\')\n                       AND mem_usr_id = ? -- $usrId\n                       AND mem_begin <= ? -- $endDate\n                       AND mem_end   >= ? -- $startDate\n                  ORDER BY mem_begin ASC';\n            $queryParams = array(\n                $id,\n                $member->getValue('mem_rol_id'),\n                $usrId,\n                $endDate,\n                $startDate\n            );\n        }\n        $membershipStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($membershipStatement->rowCount() === 1) {\n            // one record found than update this record\n            $row = $membershipStatement->fetch();\n            if (($mode === 'set') && ($row['mem_id'] > 0)) {\n                $member = new TableMembers($this->db, $row['mem_id']);\n            }\n            $member->setArray($row);\n\n            // save new start date if an earlier date exists\n            if (strcmp($minStartDate, $member->getValue('mem_begin', 'Y-m-d')) > 0) {\n                $minStartDate = $member->getValue('mem_begin', 'Y-m-d');\n            }\n\n            if ($mode === 'set') {\n                // save new end date if an later date exists\n                // but only if end date is greater than the begin date otherwise the membership should be deleted\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0\n                &&  strcmp($member->getValue('mem_begin', 'Y-m-d'), $maxEndDate) < 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n            } else {\n                // save new end date if an later date exists\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n            }\n        } elseif ($membershipStatement->rowCount() > 1) {\n            // several records found then read min and max date and delete all records\n            while ($row = $membershipStatement->fetch()) {\n                $member->clear();\n                $member->setArray($row);\n\n                // save new start date if an earlier date exists\n                if (strcmp($minStartDate, $member->getValue('mem_begin', 'Y-m-d')) > 0) {\n                    $minStartDate = $member->getValue('mem_begin', 'Y-m-d');\n                }\n\n                // save new end date if an later date exists\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n\n                // delete existing entry because a new overlapping entry will be created\n                $member->delete();\n            }\n            $member->clear();\n        }\n\n        if (strcmp($minStartDate, $maxEndDate) > 0) {\n            // if start date is greater than end date than delete membership\n            if ($member->getValue('mem_id') > 0) {\n                $member->delete();\n            }\n            $returnStatus = true;\n        } else {\n            // save membership to database\n            if ($mode === 'set') {\n                $member->setValue('mem_rol_id', $id);\n                $member->setValue('mem_usr_id', $usrId);\n            }\n            $member->setValue('mem_begin', $minStartDate);\n            $member->setValue('mem_end', $maxEndDate);\n\n            if ($leader !== null) {\n                $member->setValue('mem_leader', $leader);\n            }\n            $returnStatus = $member->save();\n        }\n\n        $this->db->endTransaction();\n        $this->renewRoleData();\n\n        return $returnStatus;\n    }\n\n    /**\n     * Method reads all relationships of the user and will store them in an array. Also the\n     * relationship property if the user can edit the profile of the other user will be stored\n     * for later checks within this class.\n     * @return bool Return true if relationships could be checked.\n     */\n    private function checkRelationshipsRights()\n    {\n        global $gSettingsManager;\n\n        if ((int) $this->getValue('usr_id') === 0 || !$gSettingsManager->getBool('members_enable_user_relations')) {\n            return false;\n        }\n\n        if (!$this->relationshipsChecked && count($this->relationships) === 0) {\n            // read all relations of the current user\n            $sql = 'SELECT urt_id, urt_edit_user, ure_usr_id2\n                      FROM '.TBL_USER_RELATIONS.'\n                INNER JOIN '.TBL_USER_RELATION_TYPES.'\n                        ON urt_id = ure_urt_id\n                     WHERE ure_usr_id1  = ? -- $this->getValue(\\'usr_id\\') ';\n            $queryParams = array((int) $this->getValue('usr_id'));\n            $relationsStatement = $this->db->queryPrepared($sql, $queryParams);\n\n            while ($row = $relationsStatement->fetch()) {\n                $this->relationships[] = array(\n                    'relation_type' => (int) $row['urt_id'],\n                    'user_id'       => (int) $row['ure_usr_id2'],\n                    'edit_user'     => (bool) $row['urt_edit_user']\n                );\n            }\n\n            $this->relationshipsChecked = true;\n        }\n\n        return true;\n    }\n\n    /**\n     * The method reads all roles where this user has a valid membership and checks the rights of\n     * those roles. It stores all rights that the user get at last through one role in an array.\n     * In addition the method checks which roles lists the user could see in an separate array.\n     * Also an array with all roles where the user has the right to write an email will be stored.\n     * The method considered the role leader rights of each role if this is set and the current\n     * user is a leader in a role.\n     * @param string $right The database column name of the right that should be checked. If this param\n     *                      is not set then only the arrays are filled.\n     * @return bool Return true if a special right should be checked and the user has this right.\n     */\n    public function checkRolesRight($right = null)\n    {\n        if ((int) $this->getValue('usr_id') === 0) {\n            return false;\n        }\n\n        if (count($this->rolesRights) === 0) {\n            $this->assignRoles = false;\n            $tmpRolesRights = array(\n                'rol_all_lists_view'     => false,\n                'rol_announcements'      => false,\n                'rol_approve_users'      => false,\n                'rol_assign_roles'       => false,\n                'rol_dates'              => false,\n                'rol_documents_files'    => false,\n                'rol_edit_user'          => false,\n                'rol_guestbook'          => false,\n                'rol_guestbook_comments' => false,\n                'rol_mail_to_all'        => false,\n                'rol_photo'              => false,\n                'rol_profile'            => false,\n                'rol_weblinks'           => false\n            );\n\n            // read all roles of the organization and join the membership if user is member of that role\n            $sql = 'SELECT *\n                      FROM '.TBL_ROLES.'\n                INNER JOIN '.TBL_CATEGORIES.'\n                        ON cat_id = rol_cat_id\n                 LEFT JOIN '.TBL_MEMBERS.'\n                        ON mem_rol_id = rol_id\n                       AND mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                       AND mem_begin <= ? -- DATE_NOW\n                       AND mem_end    > ? -- DATE_NOW\n                     WHERE rol_valid  = true\n                       AND (  cat_org_id = ? -- $this->organizationId\n                           OR cat_org_id IS NULL )';\n            $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n            $rolesStatement = $this->db->queryPrepared($sql, $queryParams);\n\n            while ($row = $rolesStatement->fetch()) {\n                $rolId = (int) $row['rol_id'];\n                $memLeader = (bool) $row['mem_leader'];\n\n                if ($row['mem_usr_id'] > 0) {\n                    // Sql selects all roles. Only consider roles where user is a member.\n                    if ($memLeader) {\n                        $rolLeaderRights = (int) $row['rol_leader_rights'];\n\n                        // if user is leader in this role than add role id and leader rights to array\n                        $this->rolesMembershipLeader[$rolId] = $rolLeaderRights;\n\n                        // if role leader could assign new members then remember this setting\n                        // roles for confirmation of dates should be ignored\n                        if ($row['cat_name_intern'] !== 'EVENTS'\n                        && ($rolLeaderRights === ROLE_LEADER_MEMBERS_ASSIGN || $rolLeaderRights === ROLE_LEADER_MEMBERS_ASSIGN_EDIT)) {\n                            $this->assignRoles = true;\n                        }\n                    } else {\n                        $this->rolesMembershipNoLeader[] = $rolId;\n                    }\n\n                    // add role to membership array\n                    $this->rolesMembership[] = $rolId;\n\n                    // Rechte der Rollen in das Array uebertragen,\n                    // falls diese noch nicht durch andere Rollen gesetzt wurden\n                    foreach ($tmpRolesRights as $key => &$value) {\n                        if (!$value && $row[$key] == '1') {\n                            $value = true;\n                        }\n                    }\n                    unset($value);\n\n                    // set flag assignRoles of user can manage roles\n                    if ((int) $row['rol_assign_roles'] === 1) {\n                        $this->assignRoles = true;\n                    }\n\n                    // set administrator flag\n                    if ((int) $row['rol_administrator'] === 1) {\n                        $this->administrator = true;\n                    }\n                }\n\n                // Listenansichtseinstellung merken\n                // Leiter duerfen die Rolle sehen\n                if ($row['mem_usr_id'] > 0 && ($row['rol_this_list_view'] > 0 || $memLeader)) {\n                    // Mitgliedschaft bei der Rolle und diese nicht gesperrt, dann anschauen\n                    $this->listViewRights[$rolId] = true;\n                } elseif ((int) $row['rol_this_list_view'] === 2) {\n                    // andere Rollen anschauen, wenn jeder sie sehen darf\n                    $this->listViewRights[$rolId] = true;\n                } else {\n                    $this->listViewRights[$rolId] = false;\n                }\n\n                // Mailrechte setzen\n                // Leiter duerfen der Rolle Mails schreiben\n                if ($row['mem_usr_id'] > 0 && ($row['rol_mail_this_role'] > 0 || $memLeader)) {\n                    // Mitgliedschaft bei der Rolle und diese nicht gesperrt, dann anschauen\n                    $this->listMailRights[$rolId] = true;\n                } elseif ($row['rol_mail_this_role'] >= 2) {\n                    // andere Rollen anschauen, wenn jeder sie sehen darf\n                    $this->listMailRights[$rolId] = true;\n                } else {\n                    $this->listMailRights[$rolId] = false;\n                }\n            }\n            $this->rolesRights = $tmpRolesRights;\n\n            // ist das Recht 'alle Listen einsehen' gesetzt, dann dies auch im Array bei allen Rollen setzen\n            if ($this->rolesRights['rol_all_lists_view']) {\n                $this->listViewRights = array_fill_keys(array_keys($this->listViewRights), true);\n            }\n\n            // ist das Recht 'allen Rollen EMails schreiben' gesetzt, dann dies auch im Array bei allen Rollen setzen\n            if ($this->rolesRights['rol_mail_to_all']) {\n                $this->listMailRights = array_fill_keys(array_keys($this->listMailRights), true);\n            }\n        }\n\n        return $right === null || $this->rolesRights[$right];\n    }\n\n    /**\n     * Check if a valid password is set for the user and return true if the correct password\n     * was set. Optional the current session could be updated to a valid login session.\n     * @param string $password             The password for the current user. This should not be encoded.\n     * @param bool   $setAutoLogin         If set to true then this login will be stored in AutoLogin table\n     *                                     and the user doesn't need to login another time with this browser.\n     *                                     To use this functionality **$updateSessionCookies** must be set to true.\n     * @param bool   $updateSessionCookies The current session will be updated to a valid login.\n     *                                     If set to false then the login is only valid for the current script.\n     * @param bool   $updateHash           If set to true the code will check if the current password hash uses\n     *                                     the best hashing algorithm. If not the password will be rehashed with\n     *                                     the new algorithm. If set to false the password will not be rehashed.\n     * @param bool   $isAdministrator      If set to true check if user is admin of organization.\n     * @throws AdmException in case of errors. exception->text contains a string with the reason why the login failed.\n     *                     Possible reasons: SYS_LOGIN_MAX_INVALID_LOGIN\n     *                                       SYS_LOGIN_NOT_ACTIVATED\n     *                                       SYS_LOGIN_USER_NO_MEMBER_IN_ORGANISATION\n     *                                       SYS_LOGIN_USER_NO_ADMINISTRATOR\n     *                                       SYS_LOGIN_USERNAME_PASSWORD_INCORRECT\n     * @return true Return true if login was successful\n     */\n    public function checkLogin($password, $setAutoLogin = false, $updateSessionCookies = true, $updateHash = true, $isAdministrator = false)\n    {\n        global $gLogger, $gSettingsManager, $gCurrentSession, $installedDbVersion, $gL10n;\n\n        if ($this->hasMaxInvalidLogins()) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_MAX_INVALID_LOGIN'));\n        }\n\n        if (!PasswordUtils::verify($password, $this->getValue('usr_password'))) {\n            $incorrectLoginMessage = $this->handleIncorrectPasswordLogin();\n\n            throw new AdmException($gL10n->get($incorrectLoginMessage));\n        }\n\n        if (!$this->getValue('usr_valid')) {\n            $gLogger->warning('AUTHENTICATION: User is not activated!', array('username' => $this->getValue('usr_login_name')));\n\n            throw new AdmException($gL10n->get('SYS_LOGIN_NOT_ACTIVATED'));\n        }\n\n        $orgLongname = $this->getOrgLongname();\n\n        if (!$this->isMemberOfOrganization($orgLongname)) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_USER_NO_MEMBER_IN_ORGANISATION', array($orgLongname)));\n        }\n\n        if ($isAdministrator && version_compare($installedDbVersion, '2.4', '>=') && !$this->isAdminOfOrganization($orgLongname)) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_USER_NO_ADMINISTRATOR', array($orgLongname)));\n        }\n\n        if ($updateHash) {\n            $this->rehashIfNecessary($password);\n        }\n\n        if ($updateSessionCookies) {\n            $gCurrentSession->setValue('ses_usr_id', (int) $this->getValue('usr_id'));\n            $gCurrentSession->save();\n        }\n\n        // should the user stayed logged in automatically, than the cookie would expire in one year\n        if ($setAutoLogin && $gSettingsManager->getBool('enable_auto_login')) {\n            $gCurrentSession->setAutoLogin();\n        } else {\n            $this->setValue('usr_last_session_id', null);\n        }\n\n        if ($updateSessionCookies) {\n            // set cookie for session id\n            $gCurrentSession->regenerateId();\n            Session::setCookie(COOKIE_PREFIX . '_SESSION_ID', $gCurrentSession->getValue('ses_session_id'));\n\n            // count logins and update login dates\n            $this->saveChangesWithoutRights();\n            $this->updateLoginData();\n        }\n\n        return true;\n    }\n\n    /**\n     * Additional to the parent method the user profile fields and all\n     * user rights and role memberships will be initialized\n     * @return void\n     */\n    public function clear()\n    {\n        parent::clear();\n\n        // new user should be valid (except registration)\n        $this->setValue('usr_valid', 1);\n        $this->columnsValueChanged = false;\n\n        if ($this->mProfileFieldsData instanceof ProfileFields) {\n            // data of all profile fields will be deleted, the internal structure will not be destroyed\n            $this->mProfileFieldsData->clearUserData();\n        }\n\n        $this->administrator = false;\n        $this->relationshipsChecked = false;\n\n        // initialize rights arrays\n        $this->usersEditAllowed = array();\n        $this->renewRoleData();\n    }\n\n    /**\n     * Deletes the selected user of the table and all the many references in other tables.\n     * After that the class will be initialize.\n     * @return bool **true** if no error occurred\n     */\n    public function delete()\n    {\n        global $gChangeNotification;\n\n        $usrId = $this->getValue('usr_id');\n\n        if (is_object($gChangeNotification)) {\n            // Register all non-empty fields for the notification\n            $gChangeNotification->logUserDeletion($usrId, $this);\n        }\n\n        // first delete send messages from the user\n        $sql = 'SELECT msg_id FROM ' . TBL_MESSAGES . ' WHERE msg_usr_id_sender = ? -- $usrId';\n        $messagesStatement = $this->db->queryPrepared($sql, array($usrId));\n\n        while ($row = $messagesStatement->fetch()) {\n            $message = new TableMessage($this->db, $row['msg_id']);\n            $message->delete();\n        }\n\n        // now delete every database entry where the user id is used\n        $sqlQueries = array();\n\n        $sqlQueries[] = 'UPDATE '.TBL_ANNOUNCEMENTS.'\n                            SET ann_usr_id_create = NULL\n                          WHERE ann_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ANNOUNCEMENTS.'\n                            SET ann_usr_id_change = NULL\n                          WHERE ann_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_DATES.'\n                            SET dat_usr_id_create = NULL\n                          WHERE dat_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_DATES.'\n                            SET dat_usr_id_change = NULL\n                          WHERE dat_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_FOLDERS.'\n                            SET fol_usr_id = NULL\n                          WHERE fol_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_FILES.'\n                            SET fil_usr_id = NULL\n                          WHERE fil_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_GUESTBOOK.'\n                            SET gbo_usr_id_create = NULL\n                          WHERE gbo_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_GUESTBOOK.'\n                            SET gbo_usr_id_change = NULL\n                          WHERE gbo_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LINKS.'\n                            SET lnk_usr_id_create = NULL\n                          WHERE lnk_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LINKS.'\n                            SET lnk_usr_id_change = NULL\n                          WHERE lnk_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LISTS.'\n                            SET lst_usr_id = NULL\n                          WHERE lst_global = true\n                            AND lst_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_PHOTOS.'\n                            SET pho_usr_id_create = NULL\n                          WHERE pho_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_PHOTOS.'\n                            SET pho_usr_id_change = NULL\n                          WHERE pho_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLES.'\n                            SET rol_usr_id_create = NULL\n                          WHERE rol_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLES.'\n                            SET rol_usr_id_change = NULL\n                          WHERE rol_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLE_DEPENDENCIES.'\n                            SET rld_usr_id = NULL\n                          WHERE rld_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USER_LOG.'\n                            SET usl_usr_id_create = NULL\n                          WHERE usl_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USERS.'\n                            SET usr_usr_id_create = NULL\n                          WHERE usr_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USERS.'\n                            SET usr_usr_id_change = NULL\n                          WHERE usr_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_LIST_COLUMNS.'\n                          WHERE lsc_lst_id IN (SELECT lst_id\n                                                 FROM '.TBL_LISTS.'\n                                                WHERE lst_usr_id = '.$usrId.'\n                                                  AND lst_global = false)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_LISTS.'\n                          WHERE lst_global = false\n                            AND lst_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_GUESTBOOK_COMMENTS.'\n                          WHERE gbc_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MEMBERS.'\n                          WHERE mem_usr_id = '.$usrId;\n\n        // MySQL couldn't create delete statement with same table in subquery.\n        // Therefore we fill a temporary table with all ids that should be deleted and reference on this table\n        $sqlQueries[] = 'DELETE FROM '.TBL_IDS.'\n                          WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'];\n\n        $sqlQueries[] = 'INSERT INTO '.TBL_IDS.'\n                                (ids_usr_id, ids_reference_id)\n                         SELECT '.$GLOBALS['gCurrentUserId'].', msc_msg_id\n                           FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE msc_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE msc_msg_id IN (SELECT ids_reference_id\n                                                 FROM '.TBL_IDS.'\n                                                WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_RECIPIENTS.'\n                          WHERE msr_msg_id IN (SELECT ids_reference_id\n                                                 FROM '.TBL_IDS.'\n                                                WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES.'\n                          WHERE msg_id IN (SELECT ids_reference_id\n                                             FROM '.TBL_IDS.'\n                                            WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_IDS.'\n                          WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'];\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_RECIPIENTS.'\n                          WHERE msr_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE NOT EXISTS (SELECT 1 FROM ' . TBL_MESSAGES_RECIPIENTS . '\n                                            WHERE msr_msg_id = msc_msg_id)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES.'\n                          WHERE NOT EXISTS (SELECT 1 FROM ' . TBL_MESSAGES_RECIPIENTS . '\n                                            WHERE msr_msg_id = msg_id)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_REGISTRATIONS.'\n                          WHERE reg_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                          WHERE atl_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_SESSIONS.'\n                          WHERE ses_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_USER_LOG.'\n                          WHERE usl_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_USER_DATA.'\n                          WHERE usd_usr_id = '.$usrId;\n\n        $this->db->startTransaction();\n\n        foreach ($sqlQueries as $sqlQuery) {\n            $this->db->query($sqlQuery); // TODO add more params\n        }\n\n        $returnValue = parent::delete();\n\n        $this->db->endTransaction();\n\n        return $returnValue;\n    }\n\n    /**\n     * delete all user data of profile fields; user record will not be deleted\n     * @return void\n     */\n    public function deleteUserFieldData()\n    {\n        $this->mProfileFieldsData->deleteUserData();\n    }\n\n    /**\n     * Edit an existing role membership of the current user. If the new date range contains\n     * a future or past membership of the same role then the two memberships will be merged.\n     * In opposite to setRoleMembership this method is useful to end a membership earlier.\n     * @param int    $memberId  Id of the current membership that should be edited.\n     * @param string $startDate New start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   New end date of the membership. Default will be **DATE_MAX**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully edited.\n     */\n    public function editRoleMembership($memberId, $startDate = DATE_NOW, $endDate = DATE_MAX, $leader = null)\n    {\n        return $this->changeRoleMembership('edit', $memberId, $startDate, $endDate, $leader);\n    }\n\n    /**\n     * Creates an array with all categories of one type where the user has the right to edit them\n     * @param string $categoryType The type of the category that should be checked e.g. ANN, USF or DAT\n     * @return array<int,int> Array with categories ids where user has the right to edit them\n     */\n    public function getAllEditableCategories($categoryType)\n    {\n        $queryParams = array($categoryType, $this->organizationId);\n\n        if (($categoryType === 'ANN' && $this->editAnnouncements())\n        || ($categoryType === 'DAT' && $this->editDates())\n        || ($categoryType === 'LNK' && $this->editWeblinksRight())\n        || ($categoryType === 'USF' && $this->editUsers())\n        || ($categoryType === 'ROL' && $this->assignRoles())) {\n            $condition = '';\n        } else {\n            $rolIdParams = array_merge(array(0), $this->getRoleMemberships());\n            $queryParams = array_merge($queryParams, $rolIdParams);\n            $condition = '\n                AND ( EXISTS (SELECT 1\n                                  FROM ' . TBL_ROLES_RIGHTS . '\n                            INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                    ON rrd_ror_id = ror_id\n                                 WHERE ror_name_intern = \\'category_edit\\'\n                                   AND rrd_object_id   = cat_id\n                                   AND rrd_rol_id IN ('.Database::getQmForValues($rolIdParams).') )\n                    )';\n        }\n\n        $sql = 'SELECT cat_id\n                  FROM ' . TBL_CATEGORIES . '\n                 WHERE cat_type = ? -- $categoryType\n                   AND (  cat_org_id IS NULL\n                       OR cat_org_id = ? ) -- $this->organizationId\n                       ' . $condition;\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        $arrEditableCategories = array();\n        while ($catId = $pdoStatement->fetchColumn()) {\n            $arrEditableCategories[] = (int) $catId;\n        }\n\n        return $arrEditableCategories;\n    }\n\n    /**\n     * @param array<int,bool> $rightsList\n     * @return array<int,int>\n     */\n    private function getAllRolesWithRight(array $rightsList)\n    {\n        $this->checkRolesRight();\n\n        $visibleRoles = array();\n\n        foreach ($rightsList as $roleId => $hasRight) {\n            if ($hasRight) {\n                $visibleRoles[] = $roleId;\n            }\n        }\n\n        return $visibleRoles;\n    }\n\n    /**\n     * Creates an array with all roles where the user has the right to mail them\n     * @return array<int,int> Array with role ids where user has the right to mail them\n     */\n    public function getAllMailRoles()\n    {\n        return $this->getAllRolesWithRight($this->listMailRights);\n    }\n\n    /**\n     * Creates an array with all categories of one type where the user has the right to view them\n     * @param string $categoryType The type of the category that should be checked e.g. ANN, USF or DAT\n     * @return array<int,int> Array with categories ids where user has the right to view them\n     */\n    public function getAllVisibleCategories($categoryType)\n    {\n        $queryParams = array($categoryType, $this->organizationId);\n\n        if (($categoryType === 'ANN' && $this->editAnnouncements())\n        || ($categoryType === 'DAT' && $this->editDates())\n        || ($categoryType === 'LNK' && $this->editWeblinksRight())\n        || ($categoryType === 'USF' && $this->editUsers())\n        || ($categoryType === 'ROL' && $this->assignRoles())) {\n            $condition = '';\n        } else {\n            $rolIdParams = array_merge(array(0), $this->getRoleMemberships());\n            $queryParams = array_merge($queryParams, $rolIdParams);\n            $condition = '\n                AND ( EXISTS (SELECT 1\n                                FROM ' . TBL_ROLES_RIGHTS . '\n                          INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                  ON rrd_ror_id = ror_id\n                               WHERE ror_name_intern = \\'category_view\\'\n                                 AND rrd_object_id   = cat_id\n                                 AND rrd_rol_id IN ('.Database::getQmForValues($rolIdParams).') )\n                      OR NOT EXISTS (SELECT 1\n                                       FROM ' . TBL_ROLES_RIGHTS . '\n                                 INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                         ON rrd_ror_id = ror_id\n                                      WHERE ror_name_intern = \\'category_view\\'\n                                        AND rrd_object_id   = cat_id )\n                    )';\n        }\n\n        $sql = 'SELECT cat_id\n                  FROM ' . TBL_CATEGORIES . '\n                 WHERE cat_type = ? -- $categoryType\n                   AND (  cat_org_id IS NULL\n                       OR cat_org_id = ? ) -- $this->organizationId\n                       ' . $condition;\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        $arrVisibleCategories = array();\n        while ($catId = $pdoStatement->fetchColumn()) {\n            $arrVisibleCategories[] = (int) $catId;\n        }\n\n        return $arrVisibleCategories;\n    }\n\n    /**\n     * Creates an array with all roles where the user has the right to view them\n     * @return array<int,int> Array with role ids where user has the right to view them\n     */\n    public function getAllVisibleRoles()\n    {\n        return $this->getAllRolesWithRight($this->listViewRights);\n    }\n\n\n    /**\n     * Returns the id of the organization this user object has been assigned.\n     * This is in the default case the default organization of the config file.\n     * @return int Returns the id of the organization this user object has been assigned\n     */\n    public function getOrganization()\n    {\n        return $this->organizationId;\n    }\n\n    /**\n     * Gets the longname of this organization.\n     * @return string Returns the longname of the organization.\n     */\n    private function getOrgLongname()\n    {\n        $sql = 'SELECT org_longname\n                  FROM '.TBL_ORGANIZATIONS.'\n                 WHERE org_id = ?';\n        $orgStatement = $this->db->queryPrepared($sql, array($this->organizationId));\n\n        return $orgStatement->fetchColumn();\n    }\n\n    /**\n     * Returns data from the user to improve dictionary attack check\n     * @return array<int,string>\n     */\n    public function getPasswordUserData()\n    {\n        $userData = array(\n            // Names\n            $this->getValue('FIRST_NAME'),\n            $this->getValue('LAST_NAME'),\n            $this->getValue('usr_login_name'),\n            // Birthday\n            $this->getValue('BIRTHDAY', 'Y'), // YYYY\n            $this->getValue('BIRTHDAY', 'md'), // MMDD\n            $this->getValue('BIRTHDAY', 'dm'), // DDMM\n            // Email\n            $this->getValue('EMAIL'),\n            // Address\n            $this->getValue('STREET'),\n            $this->getValue('CITY'),\n            $this->getValue('POSTCODE'),\n            $this->getValue('COUNTRY')\n        );\n\n        if (!function_exists('filterEmptyStrings')) {\n            /**\n             * @param string $value\n             * @return bool\n             */\n            function filterEmptyStrings($value)\n            {\n                return $value !== '';\n            }\n        }\n\n        return array_filter($userData, 'filterEmptyStrings');\n    }\n\n    /**\n     * Returns an array with all role ids where the user is a member.\n     * @return array<int,int> Returns an array with all role ids where the user is a member.\n     */\n    public function getRoleMemberships()\n    {\n        $this->checkRolesRight();\n\n        return $this->rolesMembership;\n    }\n\n    /**\n     * Returns an array with all role ids where the user is a member and not a leader of the role.\n     * @return array<int,int> Returns an array with all role ids where the user is a member and not a leader of the role.\n     */\n    public function getRoleMembershipsNoLeader()\n    {\n        $this->checkRolesRight();\n\n        return $this->rolesMembershipNoLeader;\n    }\n\n    /**\n     * Get the value of a column of the database table if the column has the praefix **usr_**\n     * otherwise the value of the profile field of the table adm_user_data will be returned.\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read or the internal unique profile field name\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return mixed Returns the value of the database column or the value of adm_user_fields\n     *               If the value was manipulated before with **setValue** than the manipulated value is returned.\n     *\n     * **Code example**\n     * ```\n     * // reads data of adm_users column\n     * $loginname = $gCurrentUser->getValue('usr_login_name');\n     * // reads data of adm_user_fields\n     * $email = $gCurrentUser->getValue('EMAIL');\n     * ```\n     */\n    public function getValue($columnName, $format = '')\n    {\n        global $gSettingsManager;\n\n        if (!str_starts_with($columnName, 'usr_')) {\n            return $this->mProfileFieldsData->getValue($columnName, $format);\n        }\n\n        if ($columnName === 'usr_photo' && (int) $gSettingsManager->get('profile_photo_storage') === 0) {\n            $file = ADMIDIO_PATH . FOLDER_DATA . '/user_profile_photos/' . (int) $this->getValue('usr_id') . '.jpg';\n            if (is_file($file)) {\n                return file_get_contents($file);\n            }\n        }\n\n        return parent::getValue($columnName, $format);\n    }\n\n    /**\n     * Creates a vcard with all data of this user object\n     * (Windows XP address book can't process utf8, so vcard output is iso-8859-1)\n     * @return string Returns the vcard as a string\n     */\n    public function getVCard()\n    {\n        global $gSettingsManager, $gCurrentUser;\n\n        $vCard = array(\n            'BEGIN:VCARD',\n            'VERSION:2.1'\n        );\n\n        if ($gCurrentUser->allowedViewProfileField($this, 'FIRST_NAME')) {\n            $vCard[] = 'N;CHARSET=ISO-8859-1:' .\n                utf8_decode($this->getValue('LAST_NAME', 'database')) . ';' .\n                utf8_decode($this->getValue('FIRST_NAME', 'database')) . ';;;';\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'LAST_NAME')) {\n            $vCard[] = 'FN;CHARSET=ISO-8859-1:' .\n                utf8_decode($this->getValue('FIRST_NAME')) . ' ' .\n                utf8_decode($this->getValue('LAST_NAME'));\n        }\n        if ($this->getValue('usr_login_name') !== '') {\n            $vCard[] = 'NICKNAME;CHARSET=ISO-8859-1:' . utf8_decode($this->getValue('usr_login_name'));\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'PHONE')) {\n            $vCard[] = 'TEL;HOME;VOICE:' . $this->getValue('PHONE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'MOBILE')) {\n            $vCard[] = 'TEL;CELL;VOICE:' . $this->getValue('MOBILE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'FAX')) {\n            $vCard[] = 'TEL;HOME;FAX:' . $this->getValue('FAX');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'STREET')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'CITY')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'POSTCODE')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'COUNTRY')) {\n            $vCard[] = 'ADR;CHARSET=ISO-8859-1;HOME:;;' .\n                utf8_decode($this->getValue('STREET', 'database')) . ';' .\n                utf8_decode($this->getValue('CITY', 'database')) . ';;' .\n                utf8_decode($this->getValue('POSTCODE', 'database')) . ';' .\n                utf8_decode($this->getValue('COUNTRY', 'database'));\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'WEBSITE')) {\n            $vCard[] = 'URL;HOME:' . $this->getValue('WEBSITE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'BIRTHDAY')) {\n            $vCard[] = 'BDAY:' . $this->getValue('BIRTHDAY', 'Ymd');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'EMAIL')) {\n            $vCard[] = 'EMAIL;PREF;INTERNET:' . $this->getValue('EMAIL');\n        }\n        $file = ADMIDIO_PATH . FOLDER_DATA . '/user_profile_photos/' . (int) $this->getValue('usr_id') . '.jpg';\n        if ((int) $gSettingsManager->get('profile_photo_storage') === 1 && is_file($file)) {\n            $imgHandle = fopen($file, 'rb');\n            if ($imgHandle !== false) {\n                $base64Image = base64_encode(fread($imgHandle, filesize($file)));\n                fclose($imgHandle);\n\n                $vCard[] = 'PHOTO;ENCODING=BASE64;TYPE=JPEG:' . $base64Image;\n            }\n        }\n        if ((int) $gSettingsManager->get('profile_photo_storage') === 0 && $this->getValue('usr_photo') !== '') {\n            $vCard[] = 'PHOTO;ENCODING=BASE64;TYPE=JPEG:' . base64_encode($this->getValue('usr_photo'));\n        }\n        // Geschlecht ist nicht in vCard 2.1 enthalten, wird hier fuer das Windows-Adressbuch uebergeben\n        if ($gCurrentUser->allowedViewProfileField($this, 'GENDER') && $this->getValue('GENDER') > 0) {\n            if ((int) $this->getValue('GENDER') === 1) {\n                $xGender = 'Male';\n                $xWabGender = 2;\n            } else {\n                $xGender = 'Female';\n                $xWabGender = 1;\n            }\n\n            $vCard[] = 'X-GENDER:' . $xGender;\n            $vCard[] = 'X-WAB-GENDER:' . $xWabGender;\n        }\n        if ($this->getValue('usr_timestamp_change') !== '') {\n            $vCard[] = 'REV:' . $this->getValue('usr_timestamp_change', 'Ymd\\This');\n        }\n\n        $vCard[] = 'END:VCARD';\n\n        return implode(\"\\r\\n\", $vCard) . \"\\r\\n\";\n    }\n\n    /**\n     * Returns true if a column of user table or profile fields has changed\n     * @return bool Returns true if a column of user table or profile fields has changed\n     */\n    public function hasColumnsValueChanged()\n    {\n        return parent::hasColumnsValueChanged() || $this->mProfileFieldsData->hasColumnsValueChanged();\n    }\n\n    /**\n     * Check if the user has deposited an email. Therefore at least one profile field from type EMAIL\n     * must have a value.\n     * @return bool Return true if the user has deposited an email.\n     */\n    public function hasEmail()\n    {\n        if ($this->getValue('EMAIL') !== '') {\n            return true;\n        }\n\n        foreach ($this->mProfileFieldsData->getProfileFields() as $profileField) {// => $profileFieldConfig)\n            if ($profileField->getValue('usf_type') === 'EMAIL'\n            && $this->mProfileFieldsData->getValue($profileField->getValue('usf_name_intern')) !== '') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the maximum of invalid logins is reached.\n     * @return bool Returns true if the maximum of invalid logins is reached.\n     */\n    private function hasMaxInvalidLogins()\n    {\n        global $gLogger;\n\n        // if within 15 minutes 3 wrong login took place -> block user account for 15 minutes\n        $now = new \\DateTime();\n        $minutesOffset = new \\DateInterval('PT15M');\n        $minutesBefore = $now->sub($minutesOffset);\n        $dateInvalid = \\DateTime::createFromFormat('Y-m-d H:i:s', $this->getValue('usr_date_invalid', 'Y-m-d H:i:s'));\n\n        if ($this->getValue('usr_number_invalid') < self::MAX_INVALID_LOGINS || $minutesBefore->getTimestamp() > $dateInvalid->getTimestamp()) {\n            return false;\n        }\n\n        $loggingObject = array(\n            'username'      => $this->getValue('usr_login_name'),\n            'numberInvalid' => (int) $this->getValue('usr_number_invalid'),\n            'dateInvalid'   => $this->getValue('usr_date_invalid', 'Y-m-d H:i:s')\n        );\n        $gLogger->warning('AUTHENTICATION: Maximum number of invalid logins!', $loggingObject);\n\n        $this->clear();\n\n        return true;\n    }\n\n    /**\n     * Checks if the current user is allowed to edit the profile of the user of the parameter.\n     * If will check if user can generally edit all users or if he is a group leader and can edit users\n     * of a special role where **$user** is a member or if it's the own profile and he could edit this.\n     * @param User  $user            User object of the user that should be checked if the current user can edit his profile.\n     * @param bool  $checkOwnProfile If set to **false** than this method don't check the role right to edit the own profile.\n     * @return bool Return **true** if the current user is allowed to edit the profile of the user from **$user**.\n     */\n    public function hasRightEditProfile(self $user, $checkOwnProfile = true)\n    {\n        if (!$user instanceof self) {\n            return false;\n        }\n\n        $usrId  = (int) $this->getValue('usr_id');\n        $userId = (int) $user->getValue('usr_id');\n\n        // edit own profile ?\n        if ($usrId > 0 && $usrId === $userId && $checkOwnProfile && $this->checkRolesRight('rol_profile')) {\n            return true;\n        }\n\n        // first check if user is in cache\n        if (array_key_exists($userId, $this->usersEditAllowed)) {\n            return $this->usersEditAllowed[$userId];\n        }\n\n        $returnValue = false;\n\n        if ($this->editUsers()) {\n            $returnValue = true;\n        } else {\n            if (count($this->rolesMembershipLeader) > 0) {\n                // leaders are not allowed to edit profiles of other leaders but to edit their own profile\n                if ($usrId === $userId) {\n                    // check if current user is a group leader of a role where $user is only a member\n                    $rolesMembership = $user->getRoleMemberships();\n                } else {\n                    // check if current user is a group leader of a role where $user is only a member and not a leader\n                    $rolesMembership = $user->getRoleMembershipsNoLeader();\n                }\n\n                foreach ($this->rolesMembershipLeader as $roleId => $leaderRights) {\n                    // is group leader of role and has the right to edit users ?\n                    if ($leaderRights > 1 && in_array($roleId, $rolesMembership, true)) {\n                        $returnValue = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // check if user has a relationship to current user and is allowed to edit him\n        if (!$returnValue && $this->checkRelationshipsRights()) {\n            foreach ($this->relationships as $relationshipUser) {\n                if ($relationshipUser['user_id'] === $userId && $relationshipUser['edit_user']) {\n                    $returnValue = true;\n                    break;\n                }\n            }\n        }\n\n        // add result into cache\n        $this->usersEditAllowed[$userId] = $returnValue;\n\n        return $returnValue;\n    }\n\n    /**\n     * @param array<int,bool> $rightsList\n     * @param string          $rightName\n     * @param int             $roleId\n     * @return bool\n     */\n    private function hasRightRole(array $rightsList, $rightName, $roleId)\n    {\n        // if user has right to view all lists then he could also view this role\n        if ($this->checkRolesRight($rightName)) {\n            return true;\n        }\n\n        // check if user has the right to view this role\n        return array_key_exists($roleId, $rightsList) && $rightsList[$roleId];\n    }\n\n    /**\n     * Checks if the current user has the right to send an email to the role.\n     * @param int $roleId Id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to send an email to the role.\n     */\n    public function hasRightSendMailToRole($roleId)\n    {\n        return $this->hasRightRole($this->listMailRights, 'rol_mail_to_all', $roleId);\n    }\n\n    /**\n     * Checks the necessary rights if this user could view former roles members. Therefore\n     * the user must also have the right to view the role. So you must also check this right.\n     * @param int $roleId Id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to view former roles members\n     */\n    public function hasRightViewFormerRolesMembers($roleId)\n    {\n        global $gSettingsManager;\n\n        if ((int) $gSettingsManager->get('groups_roles_show_former_members') !== 1\n        && ($this->checkRolesRight('rol_assign_roles')\n        || ($this->isLeaderOfRole($roleId) && in_array($this->rolesMembershipLeader[$roleId], array(1, 3), true)))) {\n            return true;\n        } elseif ((int) $gSettingsManager->get('groups_roles_show_former_members') !== 2\n        && ($this->checkRolesRight('rol_edit_user')\n        || ($this->isLeaderOfRole($roleId) && in_array($this->rolesMembershipLeader[$roleId], array(2, 3), true)))) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the current user is allowed to view the profile of the user of the parameter.\n     * If will check if user has edit rights with method editProfile or if the user is a member\n     * of a role where the current user has the right to view profiles.\n     * @param User $user User object of the user that should be checked if the current user can view his profile.\n     * @return bool Return **true** if the current user is allowed to view the profile of the user from **$user**.\n     */\n    public function hasRightViewProfile(self $user)\n    {\n        global $gValidLogin;\n\n        // if user is allowed to edit the profile then he can also view it\n        if ($this->hasRightEditProfile($user)) {\n            return true;\n        }\n\n        // every user is allowed to view his own profile\n        if ((int) $user->getValue('usr_id') === (int) $this->getValue('usr_id') && (int) $this->getValue('usr_id') > 0) {\n            return true;\n        }\n\n        // Benutzer, die alle Listen einsehen duerfen, koennen auch alle Profile sehen\n        if ($this->checkRolesRight('rol_all_lists_view')) {\n            return true;\n        }\n\n        $sql = 'SELECT rol_id, rol_this_list_view\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE rol_valid  = true\n                   AND mem_usr_id = ? -- $user->getValue(\\'usr_id\\')\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND (  cat_org_id = ? -- $this->organizationId\n                       OR cat_org_id IS NULL ) ';\n        $queryParams = array((int) $user->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $listViewStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($listViewStatement->rowCount() > 0) {\n            while ($row = $listViewStatement->fetch()) {\n                $rolId = (int) $row['rol_id'];\n                $rolThisListView = (int) $row['rol_this_list_view'];\n\n                if ($gValidLogin && $rolThisListView === 2) {\n                    // alle angemeldeten Benutzer duerfen Rollenlisten/-profile sehen\n                    return true;\n                }\n\n                if ($rolThisListView === 1 && array_key_exists($rolId, $this->listViewRights) && $this->listViewRights[$rolId]) {\n                    // nur Rollenmitglieder duerfen Rollenlisten/-profile sehen\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if the user of this object has the right to view the role that is set in the parameter.\n     * @param int $roleId The id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to view the role otherwise **false**.\n     */\n    public function hasRightViewRole($roleId)\n    {\n        return $this->hasRightRole($this->listViewRights, 'rol_all_lists_view', $roleId);\n    }\n\n    /**\n     * Handles the incorrect given login password.\n     * @return string Return string with the reason why the login failed.\n     */\n    private function handleIncorrectPasswordLogin()\n    {\n        global $gLogger;\n\n        // log invalid logins\n        if ($this->getValue('usr_number_invalid') >= self::MAX_INVALID_LOGINS) {\n            $this->setValue('usr_number_invalid', 1);\n        } else {\n            $this->setValue('usr_number_invalid', $this->getValue('usr_number_invalid') + 1);\n        }\n\n        $this->setValue('usr_date_invalid', DATETIME_NOW);\n        $this->saveChangesWithoutRights();\n        $this->save(false); // don't update timestamp // TODO Exception handling\n\n        $loggingObject = array(\n            'username'      => $this->getValue('usr_login_name'),\n            'numberInvalid' => (int) $this->getValue('usr_number_invalid'),\n            'dateInvalid'   => $this->getValue('usr_date_invalid', 'Y-m-d H:i:s')\n        );\n\n        if ($this->getValue('usr_number_invalid') >= self::MAX_INVALID_LOGINS) {\n            $this->clear();\n\n            $gLogger->warning('AUTHENTICATION: Maximum number of invalid logins!', $loggingObject);\n\n            return 'SYS_LOGIN_MAX_INVALID_LOGIN';\n        }\n\n        $this->clear();\n\n        $gLogger->warning('AUTHENTICATION: Incorrect username/password!', $loggingObject);\n\n        return 'SYS_LOGIN_USERNAME_PASSWORD_INCORRECT';\n    }\n\n    /**\n     * Checks if the user is assigned to the role **Administrator**\n     * @return bool Returns **true** if the user is a member of the role **Administrator**\n     */\n    public function isAdministrator()\n    {\n        $this->checkRolesRight();\n\n        return $this->administrator;\n    }\n\n    /**\n     * Checks if this user is an admin of this organization.\n     * @param string $orgLongname The longname of this organization.\n     * @return bool Return true if user is admin of this organization.\n     */\n    private function isAdminOfOrganization($orgLongname)\n    {\n        global $gLogger, $installedDbVersion;\n\n        // Deprecated: Fallback for updates from v3.0 and v3.1\n        if (version_compare($installedDbVersion, '3.2', '>=')) {\n            $administratorColumn = 'rol_administrator';\n        } else {\n            $administratorColumn = 'rol_webmaster';\n        }\n\n        // Check if user is currently member of a role of an organisation\n        $sql = 'SELECT mem_usr_id\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                   AND rol_valid  = true\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND cat_org_id = ? -- $this->organizationId\n                   AND '.$administratorColumn.' = true ';\n        $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($pdoStatement->rowCount() > 0) {\n            return true;\n        }\n\n        $loggingObject = array(\n            'username'     => $this->getValue('usr_login_name'),\n            'organisation' => $orgLongname\n        );\n\n        $gLogger->warning('AUTHENTICATION: User is no administrator!', $loggingObject);\n\n        return false;\n    }\n\n    /**\n     * check if user is leader of a role\n     * @param int $roleId\n     * @return bool\n     */\n    public function isLeaderOfRole($roleId)\n    {\n        return array_key_exists($roleId, $this->rolesMembershipLeader);\n    }\n\n    /**\n     * Checks if this user is a member of this organization.\n     * @param string $orgLongname The longname of this organization.\n     * @return bool Return true if user is member of this organization.\n     */\n    private function isMemberOfOrganization($orgLongname)\n    {\n        global $gLogger;\n\n        // Check if user is currently member of a role of an organisation\n        $sql = 'SELECT mem_usr_id\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                   AND rol_valid  = true\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND cat_org_id = ? -- $this->organizationId';\n        $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($pdoStatement->rowCount() > 0) {\n            return true;\n        }\n\n        $loggingObject = array(\n            'username'     => $this->getValue('usr_login_name'),\n            'organisation' => $orgLongname\n        );\n\n        $gLogger->warning('AUTHENTICATION: User is not member in this organisation!', $loggingObject);\n\n        return false;\n    }\n\n    /**\n     * check if user is member of a role\n     * @param int $roleId\n     * @return bool\n     */\n    public function isMemberOfRole($roleId)\n    {\n        return in_array($roleId, $this->rolesMembership, true);\n    }\n\n    /**\n     * If this method is called than all further calls of method **setValue** will not check the values.\n     * The values will be stored in database without any inspections!\n     * @return void\n     */\n    public function noValueCheck()\n    {\n        $this->mProfileFieldsData->noValueCheck();\n    }\n\n    /**\n     * Reads a user record out of the table adm_users in database selected by the unique user id.\n     * Also all profile fields of the object **mProfileFieldsData** will be read.\n     * @param int $userId Unique id of the user that should be read\n     * @return bool Returns **true** if one record is found\n     */\n    public function readDataById($userId)\n    {\n        if (parent::readDataById($userId)) {\n            // read data of all user fields from current user\n            $this->mProfileFieldsData->readUserData($userId, $this->organizationId);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the unique uuid column in the table.\n     * The name of the column must have the syntax table_prefix, underscore and uuid. E.g. usr_uuid.\n     * Per default all columns of the default table will be read and stored in the object.\n     * Not every Admidio table has a uuid. Please check the database structure before you use this method.\n     * @param int $uuid Unique uuid that should be searched.\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readData\n     * @see TableAccess#readDataByColumns\n     */\n    public function readDataByUuid($uuid)\n    {\n        if (parent::readDataByUuid($uuid)) {\n            // read data of all user fields from current user\n            $this->mProfileFieldsData->readUserData($this->getValue('usr_id'), $this->organizationId);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rehashes the password of the user if necessary.\n     * @param string $password The password for the current user. This should not be encoded.\n     * @return bool Returns true if password was rehashed.\n     */\n    private function rehashIfNecessary($password)\n    {\n        global $gLogger;\n\n        if (!PasswordUtils::needsRehash($this->getValue('usr_password'))) {\n            return false;\n        }\n\n        $this->saveChangesWithoutRights();\n        $this->setPassword($password);\n        $this->save(); // TODO Exception handling\n\n        $gLogger->info('AUTHENTICATION: Password rehashed!', array('username' => $this->getValue('usr_login_name')));\n\n        return true;\n    }\n\n    /**\n     * Initialize all rights and role membership arrays so that all rights and\n     * role memberships will be read from database if another method needs them\n     * @return void\n     */\n    public function renewRoleData()\n    {\n        // initialize rights arrays\n        $this->rolesRights     = array();\n        $this->listViewRights  = array();\n        $this->listMailRights  = array();\n        $this->rolesMembership = array();\n        $this->rolesMembershipLeader   = array();\n        $this->rolesMembershipNoLeader = array();\n    }\n\n    /**\n     * Reset the count of invalid logins. After that it's possible for the user to try another login.\n     */\n    public function resetInvalidLogins()\n    {\n        $this->setValue('usr_date_invalid', null);\n        $this->setValue('usr_number_invalid', 0);\n        $this->save(false); // Zeitstempel nicht aktualisieren // TODO Exception handling\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's a new\n     * record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * First save recordset and then save all user fields. After that the session of this got a renew for the user object.\n     * If the user doesn't have the right to save data of this user than an exception will be thrown.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset\n     *                                if table has columns like **usr_id_create** or **usr_id_changed**\n     * @throws AdmException\n     * @return bool\n     */\n    public function save($updateFingerPrint = true)\n    {\n        global $gCurrentSession, $gCurrentUser, $gChangeNotification;\n\n        $usrId = $this->getValue('usr_id');\n\n        // if current user is not new and is not allowed to edit this user\n        // and saveChangesWithoutRights isn't true than throw exception\n        if (!$this->saveChangesWithoutRights && $usrId > 0 && !$gCurrentUser->hasRightEditProfile($this)) {\n            throw new AdmException('The profile data of user ' . $this->getValue('FIRST_NAME') . ' '\n                . $this->getValue('LAST_NAME') . ' could not be saved because you don\\'t have the right to do this.');\n        }\n\n        $this->db->startTransaction();\n\n        // if new user then set create id and the uuid\n        $updateCreateUserId = false;\n        if ($usrId === 0) {\n            if ($GLOBALS['gCurrentUserId'] === 0) {\n                $updateCreateUserId = true;\n                $updateFingerPrint  = false;\n            }\n        }\n\n        // if value of a field changed then update timestamp of user object\n        if ($this->mProfileFieldsData instanceof ProfileFields && $this->mProfileFieldsData->hasColumnsValueChanged()) {\n            $this->columnsValueChanged = true;\n        }\n\n        $newRecord = $this->newRecord;\n\n        $returnValue = parent::save($updateFingerPrint);\n        $usrId = (int) $this->getValue('usr_id'); // if a new user was created get the new id\n\n        // if this was an registration then set this user id to create user id\n        if ($updateCreateUserId) {\n            $this->setValue('usr_timestamp_create', DATETIME_NOW);\n            $this->setValue('usr_usr_id_create', $usrId);\n            $returnValue = $returnValue && parent::save($updateFingerPrint);\n        }\n\n        if ($this->mProfileFieldsData instanceof ProfileFields) {\n            // save data of all user fields\n            $this->mProfileFieldsData->saveUserData($usrId);\n        }\n\n        if ($this->columnsValueChanged && $gCurrentSession instanceof Session) {\n            // now set reload the session of the user,\n            // because he has new data and maybe new rights\n            $gCurrentSession->reload($usrId);\n        }\n        // The record is a new record, which was just stored to the database\n        // for the first time => record it as a user creation now\n        if ($newRecord && is_object($gChangeNotification)) {\n            // Register all non-empty fields for the notification\n            $gChangeNotification->logUserCreation($usrId, $this);\n        }\n\n        $this->db->endTransaction();\n\n        return $returnValue;\n    }\n\n    /**\n     * Set the id of the organization which should be used in this user object.\n     * The organization is used to read the rights of the user. If **setOrganization** isn't called\n     * than the default organization **gCurrentOrganization** is set for the current user object.\n     * @param int $organizationId Id of the organization\n     * @return void\n     */\n    public function setOrganization($organizationId)\n    {\n        $this->organizationId = $organizationId;\n        $this->rolesRights    = array();\n    }\n\n    /**\n     * Set a new value for a password column of the database table.\n     * The value is only saved in the object. You must call the method **save** to store the new value to the database\n     * @param string $newPassword   The new value that should be stored in the database field\n     * @param bool   $doHashing     Should the password get hashed before inserted. Default is true\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     */\n    public function setPassword($newPassword, $doHashing = true)\n    {\n        global $gSettingsManager, $gPasswordHashAlgorithm, $gChangeNotification;\n\n        if (!$doHashing) {\n            if (is_object($gChangeNotification)) {\n                $gChangeNotification->logUserChange(\n                    (int) $this->getValue('usr_id'),\n                    'usr_password',\n                    $this->getValue('usr_password'),\n                    $newPassword,\n                    $this\n                );\n            }\n            return parent::setValue('usr_password', $newPassword, false);\n        }\n\n        // get the saved cost value that fits your server performance best and rehash your password\n        $options = array('cost' => 10);\n        if (isset($gSettingsManager) && $gSettingsManager->has('system_hashing_cost')) {\n            $options['cost'] = $gSettingsManager->getInt('system_hashing_cost');\n        }\n\n        $newPasswordHash = PasswordUtils::hash($newPassword, $gPasswordHashAlgorithm, $options);\n\n        if ($newPasswordHash === false) {\n            return false;\n        }\n\n        if (is_object($gChangeNotification)) {\n            $gChangeNotification->logUserChange(\n                (int) $this->getValue('usr_id'),\n                'usr_password',\n                $this->getValue('usr_password'),\n                $newPasswordHash,\n                $this\n            );\n        }\n        return parent::setValue('usr_password', $newPasswordHash, false);\n    }\n\n    /**\n     * Create a new membership to a role for the current user. If the date range contains\n     * a future or past membership of the same role then the two memberships will be merged.\n     * In opposite to setRoleMembership this method can't be used to end a membership earlier!\n     * @param int    $roleId    Id of the role for which the membership should be set.\n     * @param string $startDate Start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   End date of the membership. Default will be **31.12.9999**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully added.\n     */\n    public function setRoleMembership($roleId, $startDate = DATE_NOW, $endDate = DATE_MAX, $leader = null)\n    {\n        return $this->changeRoleMembership('set', $roleId, $startDate, $endDate, $leader);\n    }\n\n    /**\n     * Set a new value for a column of the database table if the column has the prefix **usr_**\n     * otherwise the value of the profile field of the table adm_user_data will set.\n     * If the user log is activated than the change of the value will be logged in **adm_user_log**.\n     * The value is only saved in the object. You must call the method **save** to store the new value to the database\n     * @param string $columnName The name of the database column whose value should get a new value or the\n     *                           internal unique profile field name\n     * @param mixed  $newValue   The new value that should be stored in the database field\n     * @param bool   $checkValue The value will be checked if it's valid. If set to **false** than the value will\n     *                           not be checked.\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     *\n     * **Code example**\n     * ```\n     * // set data of adm_users column\n     * $gCurrentUser->getValue('usr_login_name', 'Admidio');\n     * // reads data of adm_user_fields\n     * $gCurrentUser->getValue('EMAIL', 'administrator@admidio.org');\n     * ```\n     */\n    public function setValue($columnName, $newValue, $checkValue = true)\n    {\n        global $gSettingsManager, $gChangeNotification;\n\n        // users data from adm_users table\n        if (str_starts_with($columnName, 'usr_')) {\n            // don't change user password; use $user->setPassword()\n            if ($columnName === 'usr_password') {\n                return false;\n            }\n\n            // username should not contain special characters\n            if ($checkValue && $columnName === 'usr_login_name' && $newValue !== '' && !StringUtils::strValidCharacters($newValue, 'noSpecialChar')) {\n                return false;\n            }\n\n            // only update if value has changed\n            if ($this->getValue($columnName, 'database') == $newValue) {\n                return true;\n            }\n\n            // For new records, do not immediately queue all changes for notification,\n            // as the record might never be saved to the database (e.g. when\n            // doing a check for an existing user)! => For new records,\n            // log the changes only when $this->save is called!\n            if (!$this->newRecord && is_object($gChangeNotification)) {\n                $gChangeNotification->logUserChange(\n                    $this->getValue('usr_id'),\n                    $columnName,\n                    $this->getValue($columnName),\n                    $newValue,\n                    $this\n                );\n            }\n\n            return parent::setValue($columnName, $newValue, $checkValue);\n        }\n\n        // user data from adm_user_fields table (human-readable text representation and raw database value)\n        $oldFieldValue = $this->mProfileFieldsData->getValue($columnName);\n        $oldFieldValue_db = $this->mProfileFieldsData->getValue($columnName, 'database');\n        $newValue = (string) $newValue;\n\n        // format of date will be local but database hase stored Y-m-d format must be changed for compare\n        if ($this->mProfileFieldsData->getProperty($columnName, 'usf_type') === 'DATE') {\n            $date = \\DateTime::createFromFormat($gSettingsManager->getString('system_date'), $newValue);\n\n            if ($date !== false) {\n                $newValue = $date->format('Y-m-d');\n            }\n        }\n\n        // only update if value has changed\n        if ($oldFieldValue_db === $newValue) {\n            return true;\n        }\n\n        $returnCode = false;\n\n        // Disabled fields can only be edited by users with the right \"edit_users\" except on registration.\n        // Here is no need to check hidden fields because we check on save() method that only users who\n        // can edit the profile are allowed to save and change data.\n        if (($this->getValue('usr_id') === 0 && $GLOBALS['gCurrentUserId'] === 0)\n        ||  (int) $this->mProfileFieldsData->getProperty($columnName, 'usf_disabled') === 0\n        || ((int) $this->mProfileFieldsData->getProperty($columnName, 'usf_disabled') === 1\n            && $GLOBALS['gCurrentUser']->hasRightEditProfile($this, false))\n        || $this->saveChangesWithoutRights === true) {\n            $returnCode = $this->mProfileFieldsData->setValue($columnName, $newValue);\n        }\n\n        // Nicht alle Aenderungen werden geloggt. Ausnahmen:\n        // Felder, die mit usr_ beginnen (special case above)\n        // Felder, die sich nicht ge\u00e4ndert haben (check above)\n        // Wenn usr_id ist 0 (der User neu angelegt wird; Das wird bereits dokumentiert) (check in logProfileChange)\n\n        if ($returnCode && !$this->newRecord && is_object($gChangeNotification)) {\n            $gChangeNotification->logProfileChange(\n                $this->getValue('usr_id'),\n                $this->mProfileFieldsData->getProperty($columnName, 'usf_id'),\n                $columnName, // TODO: is $columnName the internal name or the human-readable?\n                // Old and new values in human-readable version:\n                $oldFieldValue,\n                $this->mProfileFieldsData->getValue($columnName),\n                // Old and new values in raw dtabase:\n                $oldFieldValue_db,\n                $newValue,\n                $this\n            );\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * set value for column usd_value of field\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should get a new value.\n     * @param mixed  $fieldValue\n     * @return bool\n     */\n    public function setProfileFieldsValue($fieldNameIntern, $fieldValue)\n    {\n        return $this->mProfileFieldsData->setValue($fieldNameIntern, $fieldValue);\n    }\n\n    /**\n     * Update login data for this user. These are timestamps of last login and reset count\n     * and timestamp of invalid logins.\n     * @return void\n     */\n    public function updateLoginData()\n    {\n        $this->saveChangesWithoutRights();\n        $this->setValue('usr_last_login', $this->getValue('usr_actual_login', 'Y-m-d H:i:s'));\n        $this->setValue('usr_number_login', (int) $this->getValue('usr_number_login') + 1);\n        $this->setValue('usr_actual_login', DATETIME_NOW);\n        $this->save(false); // Zeitstempel nicht aktualisieren // TODO Exception handling\n\n        $this->resetInvalidLogins();\n    }\n\n    /**\n     * Funktion prueft, ob der angemeldete User Ankuendigungen anlegen und bearbeiten darf\n     * @return bool\n     */\n    public function editAnnouncements()\n    {\n        return $this->checkRolesRight('rol_announcements');\n    }\n\n    /**\n     * Funktion prueft, ob der angemeldete User Registrierungen bearbeiten und zuordnen darf\n     * @return bool\n     */\n    public function approveUsers()\n    {\n        return $this->checkRolesRight('rol_approve_users');\n    }\n\n    /**\n     * Checks if the user has the right to assign members to at least one role.\n     * @return bool Return **true** if the user can assign members to at least one role.\n     */\n    public function assignRoles()\n    {\n        $this->checkRolesRight();\n\n        return $this->assignRoles;\n    }\n\n    /**\n     * Method checks if the current user is allowed to manage roles and therefore has\n     * admin access to the groups and roles module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function manageRoles()\n    {\n        return $this->checkRolesRight('rol_assign_roles');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the event module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editDates()\n    {\n        return $this->checkRolesRight('rol_dates');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the documents and files module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function adminDocumentsFiles()\n    {\n        return $this->checkRolesRight('rol_documents_files');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate other user profiles and therefore\n     * has access to the user management module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editUsers()\n    {\n        return $this->checkRolesRight('rol_edit_user');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the guestbook module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editGuestbookRight()\n    {\n        return $this->checkRolesRight('rol_guestbook');\n    }\n\n    /**\n     * Method checks if the current user is allowed to comment guestbook entries.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function commentGuestbookRight()\n    {\n        return $this->checkRolesRight('rol_guestbook_comments');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the photos module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editPhotoRight()\n    {\n        return $this->checkRolesRight('rol_photo');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the weblinks module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editWeblinksRight()\n    {\n        return $this->checkRolesRight('rol_weblinks');\n    }\n\n    /**\n     * Return the (internal) representation of this user's profile fields\n     * @return array All profile fields of the user\n     */\n    public function getProfileFieldsData()\n    {\n        return $this->mProfileFieldsData;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2022 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handle session data of Admidio and is connected to database table adm_sessions\n *\n * This class should be used together with the PHP session handling. If you\n * create a PHP session than you should also create this session object. The\n * class will create a recordset in adm_sessions which stores the PHP session id.\n * With this class it should be easy to add other objects to the session and read\n * them out if you need them elsewhere.\n *\n * **Code examples**\n * ```\n * // add a new object to the session\n * $organization = new Organization($gDb, $organizationId);\n * $session = new Session($gDb, $sessionId);\n * $session->addObject('organization', $organization, true);\n *\n * // read object out of session\n * if($session->hasObject('organization'))\n * {\n *     $organization =& $session->getObject('organization');\n * }\n * ```\n */\nclass Session extends TableAccess\n{\n    /**\n     * @var array<string,mixed> Array with all objects of this session object.\n     */\n    protected $mObjectArray = array();\n    /**\n     * @var AutoLogin|null Object of table auto login that will handle an auto login\n     */\n    protected $mAutoLogin;\n    /**\n     * @var string\n     */\n    protected $cookieAutoLoginId;\n    /**\n     * @var string a 30 character long CSRF token\n     */\n    protected $csrfToken = '';\n\n    /**\n     * Constructor that will create an object of a recordset of the table adm_sessions.\n     * If the id is set than the specific session will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $cookiePrefix The prefix that is used for cookies\n     */\n    public function __construct(Database $database, $cookiePrefix = '')\n    {\n        parent::__construct($database, TBL_SESSIONS, 'ses');\n\n        // determine session id\n        if (array_key_exists(COOKIE_PREFIX . '_SESSION_ID', $_COOKIE)) {\n            $sessionId = $_COOKIE[COOKIE_PREFIX . '_SESSION_ID'];\n        } else {\n            $sessionId = session_id();\n        }\n\n        $this->cookieAutoLoginId = $cookiePrefix . '_AUTO_LOGIN_ID';\n\n        if (is_int($sessionId)) {\n            $this->readDataById($sessionId);\n        } else {\n            $this->readDataByColumns(array('ses_session_id' => $sessionId));\n\n            if ($this->newRecord) {\n                // if PHP session id was committed then store them in that field\n                $this->setValue('ses_session_id', $sessionId);\n                $this->setValue('ses_timestamp', DATETIME_NOW);\n            }\n        }\n\n        // check for a valid auto login\n        $this->refreshAutoLogin();\n    }\n\n    /**\n     * Adds an object to the object array of this class. Objects in this array\n     * will be stored in the session and could be read with the method **getObject**.\n     * @param string $objectName Internal unique name of the object.\n     * @param object $object     The object that should be stored in this class.\n     * @return bool Return false if object isn't type object or objectName already exists\n     */\n    public function addObject(string $objectName, &$object): bool\n    {\n        if (is_object($object) && !array_key_exists($objectName, $this->mObjectArray)) {\n            $this->mObjectArray[$objectName] = &$object;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * clear user data\n     */\n    protected function clearUserData()\n    {\n        global $gCurrentUser;\n\n        if (isset($gCurrentUser) && $gCurrentUser instanceof User) {\n            $gCurrentUser->clear();\n        }\n        $this->setValue('ses_usr_id', '');\n    }\n\n    /**\n     * Returns a CSRF token from the session. If no CSRF token exists a new one will be\n     * generated and stored within the session. The next call of the method will than\n     * return the existing token. The CSRF token has 30 characters. A new token could\n     * be forced by the parameter **$newToken**\n     * @param bool $newToken If set to true, always a new token will be generated.\n     * @return string Returns the CSRF token\n     * @throws AdmException\n     * @throws AdmException\n     */\n    public function getCsrfToken(bool $newToken = false): string\n    {\n        if ($this->csrfToken === '' || $newToken) {\n            $this->csrfToken = SecurityUtils::getRandomString(30);\n        }\n\n        return $this->csrfToken;\n    }\n\n    /**\n     * Returns a reference of an object that is stored in the session.\n     * This is necessary because the old database connection is not valid anymore.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return object|false Returns the reference to the object or false if the object was not found.\n     */\n    public function &getObject(string $objectName)\n    {\n        if (!array_key_exists($objectName, $this->mObjectArray)) {\n            // use parameter because we return a reference so only value will return an error\n            $returnValue = false;\n            return $returnValue;\n        }\n\n        // return reference of object\n        return $this->mObjectArray[$objectName];\n    }\n\n    /**\n     * Return the organization id of this session. If AutoLogin is enabled then the\n     * organization may not be the organization of the config.php because the\n     * user had set the AutoLogin to a different organization.\n     * @return int Returns the organization id of this session\n     */\n    public function getOrganizationId(): int\n    {\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            return (int) $this->mAutoLogin->getValue('atl_org_id');\n        }\n\n        return (int) $this->getValue('ses_org_id');\n    }\n\n    /**\n     * Checks if the object with this name exists in the object array of this class.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return bool Returns **true** if the object exits otherwise **false**\n     */\n    public function hasObject(string $objectName): bool\n    {\n        return array_key_exists($objectName, $this->mObjectArray);\n    }\n\n    /**\n     * Initialize the array with all objects except the gNavigation object. If the session got a refresh\n     * the existing navigation should still be stored in the refreshed session.\n     */\n    public function initializeObjects()\n    {\n        foreach($this->mObjectArray as $key => $element) {\n            if($key !== 'gNavigation') {\n                unset($this->mObjectArray[$key]);\n            }\n        }\n    }\n\n    /**\n     * Check if the current session has a valid user login. Therefore the user id must be stored\n     * within the session and the timestamps must be valid\n     * @param int $userId The user id must be stored in this session and will be checked if valid.\n     * @return bool Returns **true** if the user has a valid session login otherwise **false**;\n     */\n    public function isValidLogin(int $userId): bool\n    {\n        global $gSettingsManager;\n\n        if ($userId > 0) {\n            if ((int) $this->getValue('ses_usr_id') === $userId) {\n                // session has a user assigned -> check if login is still valid\n                $timeGap = time() - strtotime($this->getValue('ses_timestamp', 'Y-m-d H:i:s'));\n\n                // Check how long the user was inactive. If time range is too long -> logout\n                // if user has auto login than session is also valid\n                if ($this->mAutoLogin instanceof AutoLogin || $timeGap < $gSettingsManager->getInt('logout_minutes') * 60) {\n                    return true;\n                }\n            }\n\n            // user was inactive -> clear user data and remove him from session\n            // something is wrong -> clear user data\n            $this->clearUserData();\n        }\n\n        return false;\n    }\n\n    /**\n     * The current user should be removed from the session and auto login.\n     * Also the auto login cookie should be removed.\n     */\n    public function logout()\n    {\n        $this->db->startTransaction();\n\n        // remove user from current session\n        $this->setValue('ses_usr_id', '');\n        $this->save();\n\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            // remove auto login cookie from users browser by setting expired timestamp to 0\n            self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'));\n\n            // delete auto login and remove all data\n            $this->mAutoLogin->delete();\n            $this->mAutoLogin = null;\n        }\n\n        $this->db->endTransaction();\n    }\n\n    /**\n     * Reload auto login data from database table adm_auto_login. if cookie PREFIX_AUTO_LOGIN_ID\n     * is set then there could be an auto login the auto login must be done here because after\n     * that the corresponding organization must be set.\n     */\n    public function refreshAutoLogin()\n    {\n        if (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            // restore user from auto login session\n            $this->mAutoLogin = new AutoLogin($this->db, $_COOKIE[$this->cookieAutoLoginId]);\n\n            // valid AutoLogin found\n            if ($this->mAutoLogin->getValue('atl_id') > 0) {\n                $autoLoginId = $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id'));\n                $this->mAutoLogin->setValue('atl_auto_login_id', $autoLoginId);\n                $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n                $this->mAutoLogin->save();\n\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n\n                // save cookie for autologin\n                $currDateTime = new DateTime();\n                $oneYearDateInterval = new DateInterval('P1Y');\n                $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n                $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n                self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n            } else {\n                // an invalid AutoLogin should made the current AutoLogin unusable\n                $this->mAutoLogin = null;\n                self::setCookie($this->cookieAutoLoginId, $_COOKIE[$this->cookieAutoLoginId]);\n\n                // now count invalid auto login for this user and delete all auto login of this users if number of wrong logins > 3\n                $autoLoginParts = explode(':', $_COOKIE[$this->cookieAutoLoginId]);\n                $userId = $autoLoginParts[0];\n\n                if ($userId > 0) {\n                    $sql = 'UPDATE '.TBL_AUTO_LOGIN.'\n                               SET atl_number_invalid = atl_number_invalid + 1\n                             WHERE atl_usr_id = ? -- $userId';\n                    $this->db->queryPrepared($sql, array($userId));\n\n                    $sql = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                             WHERE atl_usr_id = ? -- $userId\n                               AND atl_number_invalid > 3 ';\n                    $this->db->queryPrepared($sql, array($userId));\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload session data from database table adm_sessions. If IP address check is activated than check if the IP\n     * address has changed. Refresh AutoLogin with new auto_login_id.\n     */\n    public function refresh()\n    {\n        // read session data from database to update the reload flag\n        if(!$this->readDataById((int) $this->getValue('ses_id'))) {\n            // if session was not found than destroy session object\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n        }\n\n        // check if current connection has same ip address as of session initialization\n        // if config parameter $gCheckIpAddress = 0 then don't check ip address\n        $sesIpAddress = $this->getValue('ses_ip_address');\n        if (isset($GLOBALS['gCheckIpAddress']) && $GLOBALS['gCheckIpAddress'] && $sesIpAddress !== '' && $sesIpAddress !== $_SERVER['REMOTE_ADDR']) {\n            $GLOBALS['gLogger']->warning('Admidio stored session ip address: ' . $sesIpAddress . ' :: Remote ip address: ' . $_SERVER['REMOTE_ADDR']);\n            $GLOBALS['gLogger']->warning('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n\n            exit('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n        }\n\n        // session in database could be deleted if user was some time inactive and another user\n        // clears the table. Therefor we must reset the user id\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            if ((int) $this->getValue('ses_usr_id') === 0) {\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n            }\n        } elseif (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            $this->refreshAutoLogin();\n        }\n    }\n\n    /**\n     * This method will replace the current session ID with a new one, and keep the current session information.\n     * The new session id will be stored in the database.\n     */\n    public function regenerateId()\n    {\n        session_regenerate_id();\n\n        $this->setValue('ses_session_id', session_id());\n        $this->save();\n    }\n\n    /**\n     * This method will reload all stored objects of all active sessions. The session will be\n     * reloaded if the user will open a new page.\n     */\n    public function reloadAllSessions()\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true ';\n        $this->db->queryPrepared($sql);\n    }\n\n    /**\n     * This method will reload the session of a specific user. All stored objects of the session will be initialized\n     * and reloaded if the user opens a new page.\n     * @param int $userId Id of the user whose session should be relaoded.\n     */\n    public function reload(int $userId)\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true\n                 WHERE ses_usr_id = ?  -- $userId';\n        $this->db->queryPrepared($sql, array($userId));\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update\n     * the changed columns. If the table has columns for creator or editor than these column\n     * with their timestamp will be updated.\n     * For new records the organization, timestamp, begin date and ip address will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true): bool\n    {\n        global $gCurrentOrgId;\n\n        if ($this->newRecord) {\n            // Insert\n            $this->setValue('ses_org_id', $gCurrentOrgId);\n            $this->setValue('ses_begin', DATETIME_NOW);\n            // remove the last part of the IP because of privacy (GDPR)\n            $ip = preg_replace(array('/\\.\\d+$/', '/[\\da-f]*:[\\da-f]*$/'), array('.XXX', 'XXXX:XXXX'), $_SERVER['REMOTE_ADDR']);\n            $this->setValue('ses_ip_address', $ip);\n        }\n\n        // Insert & Update\n        $this->setValue('ses_timestamp', DATETIME_NOW);\n\n        return parent::save($updateFingerPrint);\n    }\n\n    /**\n     * Save all data that is necessary for an auto login. Therefore an AutoLogin object\n     * will be created with an auto_login_id and this id will be stored in a cookie\n     * in the browser of the current user.\n     */\n    public function setAutoLogin()\n    {\n        // create object and set current session data to AutoLogin\n        $this->mAutoLogin = new AutoLogin($this->db);\n        $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n        $this->mAutoLogin->setValue('atl_org_id', (int) $this->getValue('ses_org_id'));\n        $this->mAutoLogin->setValue('atl_usr_id', (int) $this->getValue('ses_usr_id'));\n\n        // set new auto_login_id and save data\n        $this->mAutoLogin->setValue('atl_auto_login_id', $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id')));\n        $this->mAutoLogin->save();\n\n        // save cookie for autologin\n        $currDateTime = new DateTime();\n        $oneYearDateInterval = new DateInterval('P1Y');\n        $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n        $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n        self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n    }\n\n    /**\n     * @param string $name     Name of the cookie.\n     * @param string $value    Value of the cookie. If value is \"empty string\" or \"false\",\n     *                         the cookie will be set as deleted (Expire is set to 1 year in the past).\n     * @param int $expire   The Unix-Timestamp (Seconds) of the Date/Time when the cookie should expire.\n     *                         With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path     Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain   Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure   If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly If \"true\" cookie is accessible only via HTTP.\n     *                         Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @return bool Returns \"true\" if the cookie is successfully set.\n     */\n    public static function setCookie(\n        string $name,\n        string $value = '',\n        int $expire = 0,\n        string $path = '',\n        string $domain = '',\n        bool $secure = null,\n        bool $httpOnly = true\n    ): bool {\n        global $gLogger, $gSetCookieForDomain;\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n        if ($domain === '') {\n            $domain = DOMAIN;\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        $gLogger->info('Set Cookie!', array('name' => $name, 'value' => $value, 'expire' => $expire, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax'));\n\n        if (PHP_VERSION_ID < 70300) {\n            return setcookie($name, $value, $expire, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            return setcookie($name, $value, array(\n                'expires'  => $expire,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n    }\n\n    /**\n     * @param string $cookiePrefix The prefix name of the Cookie.\n     * @param int $limit        The Lifetime (Seconds) of the cookie when it should expire.\n     *                             With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path         Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain       Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure       If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly     If \"true\" cookie is accessible only via HTTP.\n     *                             Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @throws RuntimeException\n     */\n    public static function start(string $cookiePrefix, int $limit = 0, string $path = '', string $domain = '', bool $secure = null, bool $httpOnly = true)\n    {\n        global $gLogger, $gSetCookieForDomain;\n\n        if (headers_sent()) {\n            $message = 'HTTP-Headers already sent!';\n            $gLogger->alert($message);\n\n            throw new RuntimeException($message);\n        }\n\n        $sessionName = $cookiePrefix . '_SESSION_ID';\n\n        // Set the cookie name\n        session_name($sessionName);\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n\n        if ($domain === '') {\n            $domain = DOMAIN;\n\n            // TODO: Test if this is necessary\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        if (PHP_VERSION_ID < 70300) {\n            session_set_cookie_params($limit, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            session_set_cookie_params(array(\n                'lifetime' => $limit,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $gLogger->notice('Session is already started!', array('sessionId' => session_id()));\n        }\n\n        // Start session\n        session_start();\n\n        $gLogger->info('Session Started!', array('name' => $sessionName, 'limit' => $limit, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax', 'sessionId' => session_id()));\n    }\n\n    /**\n     * Deletes all sessions in table admSessions that are inactive since **$maxInactiveTime** minutes..\n     * @param int $maxInactiveMinutes Time in Minutes after that a session will be deleted.\n     * @throws Exception\n     * @throws Exception\n     */\n    public function tableCleanup(int $maxInactiveMinutes = 30)\n    {\n        $now = new DateTime();\n        $minutesBack = new DateInterval('PT' . $maxInactiveMinutes . 'M');\n        $timestamp = $now->sub($minutesBack)->format('Y-m-d H:i:s');\n\n        $sql = 'DELETE FROM '.TBL_SESSIONS.'\n                 WHERE ses_timestamp < ? -- $timestamp\n                   AND ses_session_id <> ? -- $this->getValue(\\'ses_session_id\\')';\n        $this->db->queryPrepared($sql, array($timestamp, $this->getValue('ses_session_id')));\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * Class handle role rights, cards and other things of users\n *\n * @copyright 2004-2022 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handles all the user data and the rights. This is used for the current login user and for other users of the database.\n */\nclass User extends TableAccess\n{\n    public const MAX_INVALID_LOGINS = 3;\n\n    /**\n     * @var bool\n     */\n    protected $administrator;\n    /**\n     * @var ProfileFields object with current user field structure\n     */\n    protected $mProfileFieldsData;\n    /**\n     * @var array<string,bool> Array with all roles rights and the status of the current user e.g. array('rol_assign_roles' => false, 'rol_approve_users' => true ...)\n     */\n    protected $rolesRights = array();\n    /**\n     * @var array<int,bool> Array with all roles and a flag if the user could view this role e.g. array('role_id_1' => '1', 'role_id_2' => '0' ...)\n     */\n    protected $listViewRights = array();\n    /**\n     * @var array<int,bool> Array with all roles and a flag if the user could write a mail to this role e.g. array('role_id_1' => '1', 'role_id_2' => '0' ...)\n     */\n    protected $listMailRights = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned\n     */\n    protected $rolesMembership = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned and is leader (key = role_id; value = rol_leader_rights)\n     */\n    protected $rolesMembershipLeader = array();\n    /**\n     * @var array<int,int> Array with all roles who the user is assigned and is not a leader of the role\n     */\n    protected $rolesMembershipNoLeader = array();\n    /**\n     * @var int the organization for which the rights are read, could be changed with method **setOrganization**\n     */\n    protected $organizationId;\n    /**\n     * @var bool Flag if the user has the right to assign at least one role\n     */\n    protected $assignRoles;\n    /**\n     * @var array<int,bool> Array with all user ids where the current user is allowed to edit the profile.\n     */\n    protected $usersEditAllowed = array();\n    /**\n     * @var array<int,array<string,int|bool>> Array with all users to whom the current user has a relationship\n     */\n    protected $relationships = array();\n    /**\n     * @var bool Flag if relationships for this user were checked\n     */\n    protected $relationshipsChecked = false;\n\n    /**\n     * Constructor that will create an object of a recordset of the users table.\n     * If the id is set than this recordset will be loaded.\n     * @param Database      $database   Object of the class Database. This should be the default global object **$gDb**.\n     * @param ProfileFields $userFields An object of the ProfileFields class with the profile field structure\n     *                                  of the current organization. This could be the default object **$gProfileFields**.\n     * @param int           $userId     The id of the user who should be loaded. If id isn't set than an empty\n     *                                  object with no specific user is created.\n     */\n    public function __construct(Database $database, ProfileFields $userFields = null, $userId = 0)\n    {\n        if ($userFields !== null) {\n            $this->mProfileFieldsData = clone $userFields; // create explicit a copy of the object (param is in PHP5 a reference)\n        }\n\n        $this->organizationId = $GLOBALS['gCurrentOrgId'];\n\n        parent::__construct($database, TBL_USERS, 'usr', $userId);\n    }\n\n    /**\n     * Checks if the current user is allowed to edit a profile field of the user of the parameter.\n     * @param User   $user            User object of the user that should be checked if the current user can view his profile field.\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should be checked.\n     * @return bool Return true if the current user is allowed to view this profile field of **$user**.\n     */\n    public function allowedEditProfileField(self $user, $fieldNameIntern)\n    {\n        return $this->hasRightEditProfile($user) && $user->mProfileFieldsData->isEditable($fieldNameIntern, $this->hasRightEditProfile($user));\n    }\n\n    /**\n     * Checks if the current user is allowed to view a profile field of the user of the parameter.\n     * It will check if the current user could view the profile field category. Within the own profile\n     * you can view profile fields of hidden categories. We will also check if the current user\n     * could edit the **$user** profile so the current user could also view hidden fields.\n     * @param User   $user            User object of the user that should be checked if the current user can view his profile field.\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should be checked.\n     * @return bool Return true if the current user is allowed to view this profile field of **$user**.\n     */\n    public function allowedViewProfileField(self $user, string $fieldNameIntern)\n    {\n        return $user->mProfileFieldsData->isVisible($fieldNameIntern, $this->hasRightEditProfile($user));\n    }\n\n    /**\n     * Assign the user to all roles that have set the flag **rol_default_registration**.\n     * These flag should be set if you want that every new user should get this role.\n     */\n    public function assignDefaultRoles()\n    {\n        global $gMessage, $gL10n;\n\n        $this->db->startTransaction();\n\n        // every user will get the default roles for registration, if the current user has the right to assign roles\n        // than the role assignment dialog will be shown\n        $sql = 'SELECT rol_id\n                  FROM '.TBL_ROLES.'\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE rol_default_registration = 1\n                   AND cat_org_id = ? -- $this->organizationId';\n        $defaultRolesStatement = $this->db->queryPrepared($sql, array($this->organizationId));\n\n        if ($defaultRolesStatement->rowCount() === 0) {\n            $gMessage->show($gL10n->get('PRO_NO_DEFAULT_ROLE'));\n            // => EXIT\n        }\n\n        while ($rolId = $defaultRolesStatement->fetchColumn()) {\n            // starts a membership for role from now\n            $this->setRoleMembership($rolId);\n        }\n\n        $this->db->endTransaction();\n    }\n\n    /**\n     * @param string $mode      'set' or 'edit'\n     * @param int $id           ID of the role for which the membership should be set,\n     *                          or id of the current membership that should be edited.\n     * @param string $startDate New start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   New end date of the membership. Default will be **31.12.9999**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully added/edited.\n     */\n    private function changeRoleMembership($mode, $id, $startDate, $endDate, $leader)\n    {\n        if ($startDate === '' || $endDate === '') {\n            return false;\n        }\n\n        $usrId = (int) $this->getValue('usr_id');\n\n        $minStartDate = $startDate;\n        $maxEndDate   = $endDate;\n\n        if ($mode === 'set') {\n            // subtract 1 day from start date so that we find memberships that end yesterday\n            // these memberships can be continued with new date\n            $oneDayOffset = new \\DateInterval('P1D');\n\n            $startDate = \\DateTime::createFromFormat('Y-m-d', $startDate)->sub($oneDayOffset)->format('Y-m-d');\n            // add 1 to max date because we subtract one day if a membership ends\n            if ($endDate !== DATE_MAX) {\n                $endDate = \\DateTime::createFromFormat('Y-m-d', $endDate)->add($oneDayOffset)->format('Y-m-d');\n            }\n        }\n\n        $this->db->startTransaction();\n\n        // search for membership with same role and user and overlapping dates\n        if ($mode === 'set') {\n            $member = new TableMembers($this->db);\n\n            $sql = 'SELECT *\n                      FROM '.TBL_MEMBERS.'\n                     WHERE mem_rol_id = ? -- $id\n                       AND mem_usr_id = ? -- $usrId\n                       AND mem_begin <= ? -- $endDate\n                       AND mem_end   >= ? -- $startDate\n                  ORDER BY mem_begin';\n            $queryParams = array(\n                $id,\n                $usrId,\n                $endDate,\n                $startDate\n            );\n        } else {\n            $member = new TableMembers($this->db, $id);\n\n            $sql = 'SELECT *\n                      FROM '.TBL_MEMBERS.'\n                     WHERE mem_id    <> ? -- $id\n                       AND mem_rol_id = ? -- $member->getValue(\\'mem_rol_id\\')\n                       AND mem_usr_id = ? -- $usrId\n                       AND mem_begin <= ? -- $endDate\n                       AND mem_end   >= ? -- $startDate\n                  ORDER BY mem_begin';\n            $queryParams = array(\n                $id,\n                $member->getValue('mem_rol_id'),\n                $usrId,\n                $endDate,\n                $startDate\n            );\n        }\n        $membershipStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($membershipStatement->rowCount() === 1) {\n            // one record found than update this record\n            $row = $membershipStatement->fetch();\n            if (($mode === 'set') && ($row['mem_id'] > 0)) {\n                $member = new TableMembers($this->db, $row['mem_id']);\n            }\n            $member->setArray($row);\n\n            // save new start date if an earlier date exists\n            if (strcmp($minStartDate, $member->getValue('mem_begin', 'Y-m-d')) > 0) {\n                $minStartDate = $member->getValue('mem_begin', 'Y-m-d');\n            }\n\n            if ($mode === 'set') {\n                // save new end date if a later date exists\n                // but only if end date is greater than the beginn date otherwise the membership should be deleted\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0\n                &&  strcmp($member->getValue('mem_begin', 'Y-m-d'), $maxEndDate) < 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n            } else {\n                // save new end date if a later date exists\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n            }\n        } elseif ($membershipStatement->rowCount() > 1) {\n            // several records found then read min and max date and delete all records\n            while ($row = $membershipStatement->fetch()) {\n                $member->clear();\n                $member->setArray($row);\n\n                // save new start date if an earlier date exists\n                if (strcmp($minStartDate, $member->getValue('mem_begin', 'Y-m-d')) > 0) {\n                    $minStartDate = $member->getValue('mem_begin', 'Y-m-d');\n                }\n\n                // save new end date if a later date exists\n                if (strcmp($member->getValue('mem_end', 'Y-m-d'), $maxEndDate) > 0) {\n                    $maxEndDate = $member->getValue('mem_end', 'Y-m-d');\n                }\n\n                // delete existing entry because a new overlapping entry will be created\n                $member->delete();\n            }\n            $member->clear();\n        }\n\n        if (strcmp($minStartDate, $maxEndDate) > 0) {\n            // if start date is greater than end date than delete membership\n            if ($member->getValue('mem_id') > 0) {\n                $member->delete();\n            }\n            $returnStatus = true;\n        } else {\n            // save membership to database\n            if ($mode === 'set') {\n                $member->setValue('mem_rol_id', $id);\n                $member->setValue('mem_usr_id', $usrId);\n            }\n            $member->setValue('mem_begin', $minStartDate);\n            $member->setValue('mem_end', $maxEndDate);\n\n            if ($leader !== null) {\n                $member->setValue('mem_leader', $leader);\n            }\n            $returnStatus = $member->save();\n        }\n\n        $this->db->endTransaction();\n        $this->renewRoleData();\n\n        return $returnStatus;\n    }\n\n    /**\n     * Method reads all relationships of the user and will store them in an array. The\n     * relationship property if the user can edit the profile of the other user will be stored\n     * for later checks within this class.\n     * @return bool Return true if relationships could be checked.\n     */\n    private function checkRelationshipsRights()\n    {\n        global $gSettingsManager;\n\n        if ((int) $this->getValue('usr_id') === 0 || !$gSettingsManager->getBool('members_enable_user_relations')) {\n            return false;\n        }\n\n        if (!$this->relationshipsChecked && count($this->relationships) === 0) {\n            // read all relations of the current user\n            $sql = 'SELECT urt_id, urt_edit_user, ure_usr_id2\n                      FROM '.TBL_USER_RELATIONS.'\n                INNER JOIN '.TBL_USER_RELATION_TYPES.'\n                        ON urt_id = ure_urt_id\n                     WHERE ure_usr_id1  = ? -- $this->getValue(\\'usr_id\\') ';\n            $queryParams = array((int) $this->getValue('usr_id'));\n            $relationsStatement = $this->db->queryPrepared($sql, $queryParams);\n\n            while ($row = $relationsStatement->fetch()) {\n                $this->relationships[] = array(\n                    'relation_type' => (int) $row['urt_id'],\n                    'user_id'       => (int) $row['ure_usr_id2'],\n                    'edit_user'     => (bool) $row['urt_edit_user']\n                );\n            }\n\n            $this->relationshipsChecked = true;\n        }\n\n        return true;\n    }\n\n    /**\n     * The method reads all roles where this user has a valid membership and checks the rights of\n     * those roles. It stores all rights that the user get at last through one role in an array.\n     * The method checks which role lists the user could see in a separate array.\n     * An array with all roles where the user has the right to write an email will be stored.\n     * The method considered the role leader rights of each role if this is set and the current\n     * user is a leader in a role.\n     * @param string $right The database column name of the right that should be checked. If this param\n     *                      is not set then only the arrays are filled.\n     * @return bool Return true if a special right should be checked and the user has this right.\n     */\n    public function checkRolesRight($right = null)\n    {\n        if ((int) $this->getValue('usr_id') === 0) {\n            return false;\n        }\n\n        if (count($this->rolesRights) === 0) {\n            $this->assignRoles = false;\n            $tmpRolesRights = array(\n                'rol_all_lists_view'     => false,\n                'rol_announcements'      => false,\n                'rol_approve_users'      => false,\n                'rol_assign_roles'       => false,\n                'rol_dates'              => false,\n                'rol_documents_files'    => false,\n                'rol_edit_user'          => false,\n                'rol_guestbook'          => false,\n                'rol_guestbook_comments' => false,\n                'rol_mail_to_all'        => false,\n                'rol_photo'              => false,\n                'rol_profile'            => false,\n                'rol_weblinks'           => false\n            );\n\n            // read all roles of the organization and join the membership if user is member of that role\n            $sql = 'SELECT *\n                      FROM '.TBL_ROLES.'\n                INNER JOIN '.TBL_CATEGORIES.'\n                        ON cat_id = rol_cat_id\n                 LEFT JOIN '.TBL_MEMBERS.'\n                        ON mem_rol_id = rol_id\n                       AND mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                       AND mem_begin <= ? -- DATE_NOW\n                       AND mem_end    > ? -- DATE_NOW\n                     WHERE rol_valid  = true\n                       AND (  cat_org_id = ? -- $this->organizationId\n                           OR cat_org_id IS NULL )';\n            $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n            $rolesStatement = $this->db->queryPrepared($sql, $queryParams);\n\n            while ($row = $rolesStatement->fetch()) {\n                $rolId = (int) $row['rol_id'];\n                $memLeader = (bool) $row['mem_leader'];\n\n                if ($row['mem_usr_id'] > 0) {\n                    // Sql selects all roles. Only consider roles where user is a member.\n                    if ($memLeader) {\n                        $rolLeaderRights = (int) $row['rol_leader_rights'];\n\n                        // if user is leader in this role than add role id and leader rights to array\n                        $this->rolesMembershipLeader[$rolId] = $rolLeaderRights;\n\n                        // if role leader could assign new members then remember this setting\n                        // roles for confirmation of dates should be ignored\n                        if ($row['cat_name_intern'] !== 'EVENTS'\n                        && ($rolLeaderRights === ROLE_LEADER_MEMBERS_ASSIGN || $rolLeaderRights === ROLE_LEADER_MEMBERS_ASSIGN_EDIT)) {\n                            $this->assignRoles = true;\n                        }\n                    } else {\n                        $this->rolesMembershipNoLeader[] = $rolId;\n                    }\n\n                    // add role to membership array\n                    $this->rolesMembership[] = $rolId;\n\n                    // Transfer the rights of the roles into the array, if these have not yet been set by other roles\n                    foreach ($tmpRolesRights as $key => &$value) {\n                        if (!$value && $row[$key] == '1') {\n                            $value = true;\n                        }\n                    }\n                    unset($value);\n\n                    // set flag assignRoles of user can manage roles\n                    if ((int) $row['rol_assign_roles'] === 1) {\n                        $this->assignRoles = true;\n                    }\n\n                    // set administrator flag\n                    if ((int) $row['rol_administrator'] === 1) {\n                        $this->administrator = true;\n                    }\n                }\n\n                // Remember list view setting\n                // leaders are allowed to see the role\n                if ($row['mem_usr_id'] > 0 && ($row['rol_this_list_view'] > 0 || $memLeader)) {\n                    // Membership to the role and this is not locked, then look at it\n                    $this->listViewRights[$rolId] = true;\n                } elseif ((int) $row['rol_this_list_view'] === 2) {\n                    // look at other roles when everyone is allowed to see them\n                    $this->listViewRights[$rolId] = true;\n                } else {\n                    $this->listViewRights[$rolId] = false;\n                }\n\n                // Set mail permissions\n                // Leaders are allowed to write mails to the role\n                if ($row['mem_usr_id'] > 0 && ($row['rol_mail_this_role'] > 0 || $memLeader)) {\n                    // Membership to the role and this is not locked, then look at it\n                    $this->listMailRights[$rolId] = true;\n                } elseif ($row['rol_mail_this_role'] >= 2) {\n                    // look at other roles when everyone is allowed to see them\n                    $this->listMailRights[$rolId] = true;\n                } else {\n                    $this->listMailRights[$rolId] = false;\n                }\n            }\n            $this->rolesRights = $tmpRolesRights;\n\n            // if the right 'view all lists' is set, then set this also in the array for all roles\n            if ($this->rolesRights['rol_all_lists_view']) {\n                $this->listViewRights = array_fill_keys(array_keys($this->listViewRights), true);\n            }\n\n            // if the right 'write emails to all roles' is set, then set this also in the array for all roles\n            if ($this->rolesRights['rol_mail_to_all']) {\n                $this->listMailRights = array_fill_keys(array_keys($this->listMailRights), true);\n            }\n        }\n\n        return $right === null || $this->rolesRights[$right];\n    }\n\n    /**\n     * Check if a valid password is set for the user and return true if the correct password\n     * was set. Optional the current session could be updated to a valid login session.\n     * @param string $password             The password for the current user. This should not be encoded.\n     * @param bool   $setAutoLogin         If set to true then this login will be stored in AutoLogin table\n     *                                     and the user doesn't need to login another time with this browser.\n     *                                     To use this functionality **$updateSessionCookies** must be set to true.\n     * @param bool   $updateSessionCookies The current session will be updated to a valid login.\n     *                                     If set to false then the login is only valid for the current script.\n     * @param bool   $updateHash           If set to true the code will check if the current password hash uses\n     *                                     the best hashing algorithm. If not the password will be rehashed with\n     *                                     the new algorithm. If set to false the password will not be rehashed.\n     * @param bool   $isAdministrator      If set to true check if user is admin of organization.\n     * @throws AdmException in case of errors. exception->text contains a string with the reason why the login failed.\n     *                     Possible reasons: SYS_LOGIN_MAX_INVALID_LOGIN\n     *                                       SYS_LOGIN_NOT_ACTIVATED\n     *                                       SYS_LOGIN_USER_NO_MEMBER_IN_ORGANISATION\n     *                                       SYS_LOGIN_USER_NO_ADMINISTRATOR\n     *                                       SYS_LOGIN_USERNAME_PASSWORD_INCORRECT\n     * @return true Return true if login was successful\n     */\n    public function checkLogin($password, $setAutoLogin = false, $updateSessionCookies = true, $updateHash = true, $isAdministrator = false)\n    {\n        global $gLogger, $gSettingsManager, $gCurrentSession, $installedDbVersion, $gL10n;\n\n        if ($this->hasMaxInvalidLogins()) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_MAX_INVALID_LOGIN'));\n        }\n\n        if (!PasswordUtils::verify($password, $this->getValue('usr_password'))) {\n            $incorrectLoginMessage = $this->handleIncorrectPasswordLogin();\n\n            throw new AdmException($gL10n->get($incorrectLoginMessage));\n        }\n\n        if (!$this->getValue('usr_valid')) {\n            $gLogger->warning('AUTHENTICATION: User is not activated!', array('username' => $this->getValue('usr_login_name')));\n\n            throw new AdmException($gL10n->get('SYS_LOGIN_NOT_ACTIVATED'));\n        }\n\n        $orgLongname = $this->getOrgLongname();\n\n        if (!$this->isMemberOfOrganization($orgLongname)) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_USER_NO_MEMBER_IN_ORGANISATION', array($orgLongname)));\n        }\n\n        if ($isAdministrator && version_compare($installedDbVersion, '2.4', '>=') && !$this->isAdminOfOrganization($orgLongname)) {\n            throw new AdmException($gL10n->get('SYS_LOGIN_USER_NO_ADMINISTRATOR', array($orgLongname)));\n        }\n\n        if ($updateHash) {\n            $this->rehashIfNecessary($password);\n        }\n\n        if ($updateSessionCookies) {\n            $gCurrentSession->setValue('ses_usr_id', (int) $this->getValue('usr_id'));\n            $gCurrentSession->save();\n        }\n\n        // should the user stayed logged in automatically, than the cookie would expire in one year\n        if ($setAutoLogin && $gSettingsManager->getBool('enable_auto_login')) {\n            $gCurrentSession->setAutoLogin();\n        } else {\n            $this->setValue('usr_last_session_id', null);\n        }\n\n        if ($updateSessionCookies) {\n            // set cookie for session id\n            $gCurrentSession->regenerateId();\n            Session::setCookie(COOKIE_PREFIX . '_SESSION_ID', $gCurrentSession->getValue('ses_session_id'));\n\n            // count logins and update login dates\n            $this->saveChangesWithoutRights();\n            $this->updateLoginData();\n        }\n\n        return true;\n    }\n\n    /**\n     * Additional to the parent method the user profile fields and all\n     * user rights and role memberships will be initialized\n     * @return void\n     */\n    public function clear()\n    {\n        parent::clear();\n\n        // new user should be valid (except registration)\n        $this->setValue('usr_valid', 1);\n        $this->columnsValueChanged = false;\n\n        if ($this->mProfileFieldsData instanceof ProfileFields) {\n            // data of all profile fields will be deleted, the internal structure will not be destroyed\n            $this->mProfileFieldsData->clearUserData();\n        }\n\n        $this->administrator = false;\n        $this->relationshipsChecked = false;\n\n        // initialize rights arrays\n        $this->usersEditAllowed = array();\n        $this->renewRoleData();\n    }\n\n    /**\n     * Deletes the selected user of the table and all the many references in other tables.\n     * After that the class will be initialize.\n     * @return bool **true** if no error occurred\n     */\n    public function delete()\n    {\n        global $gChangeNotification;\n\n        $usrId = $this->getValue('usr_id');\n\n        if (is_object($gChangeNotification)) {\n            // Register all non-empty fields for the notification\n            $gChangeNotification->logUserDeletion($usrId, $this);\n        }\n\n        // first delete send messages from the user\n        $sql = 'SELECT msg_id FROM ' . TBL_MESSAGES . ' WHERE msg_usr_id_sender = ? -- $usrId';\n        $messagesStatement = $this->db->queryPrepared($sql, array($usrId));\n\n        while ($row = $messagesStatement->fetch()) {\n            $message = new TableMessage($this->db, $row['msg_id']);\n            $message->delete();\n        }\n\n        // now delete every database entry where the user id is used\n        $sqlQueries = array();\n\n        $sqlQueries[] = 'UPDATE '.TBL_ANNOUNCEMENTS.'\n                            SET ann_usr_id_create = NULL\n                          WHERE ann_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ANNOUNCEMENTS.'\n                            SET ann_usr_id_change = NULL\n                          WHERE ann_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_DATES.'\n                            SET dat_usr_id_create = NULL\n                          WHERE dat_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_DATES.'\n                            SET dat_usr_id_change = NULL\n                          WHERE dat_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_FOLDERS.'\n                            SET fol_usr_id = NULL\n                          WHERE fol_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_FILES.'\n                            SET fil_usr_id = NULL\n                          WHERE fil_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_GUESTBOOK.'\n                            SET gbo_usr_id_create = NULL\n                          WHERE gbo_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_GUESTBOOK.'\n                            SET gbo_usr_id_change = NULL\n                          WHERE gbo_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LINKS.'\n                            SET lnk_usr_id_create = NULL\n                          WHERE lnk_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LINKS.'\n                            SET lnk_usr_id_change = NULL\n                          WHERE lnk_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_LISTS.'\n                            SET lst_usr_id = NULL\n                          WHERE lst_global = true\n                            AND lst_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_PHOTOS.'\n                            SET pho_usr_id_create = NULL\n                          WHERE pho_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_PHOTOS.'\n                            SET pho_usr_id_change = NULL\n                          WHERE pho_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLES.'\n                            SET rol_usr_id_create = NULL\n                          WHERE rol_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLES.'\n                            SET rol_usr_id_change = NULL\n                          WHERE rol_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_ROLE_DEPENDENCIES.'\n                            SET rld_usr_id = NULL\n                          WHERE rld_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USER_LOG.'\n                            SET usl_usr_id_create = NULL\n                          WHERE usl_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USERS.'\n                            SET usr_usr_id_create = NULL\n                          WHERE usr_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'UPDATE '.TBL_USERS.'\n                            SET usr_usr_id_change = NULL\n                          WHERE usr_usr_id_change = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_LIST_COLUMNS.'\n                          WHERE lsc_lst_id IN (SELECT lst_id\n                                                 FROM '.TBL_LISTS.'\n                                                WHERE lst_usr_id = '.$usrId.'\n                                                  AND lst_global = false)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_LISTS.'\n                          WHERE lst_global = false\n                            AND lst_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_GUESTBOOK_COMMENTS.'\n                          WHERE gbc_usr_id_create = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MEMBERS.'\n                          WHERE mem_usr_id = '.$usrId;\n\n        // MySQL couldn't create delete statement with same table in subquery.\n        // Therefore we fill a temporary table with all ids that should be deleted and reference on this table\n        $sqlQueries[] = 'DELETE FROM '.TBL_IDS.'\n                          WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'];\n\n        $sqlQueries[] = 'INSERT INTO '.TBL_IDS.'\n                                (ids_usr_id, ids_reference_id)\n                         SELECT '.$GLOBALS['gCurrentUserId'].', msc_msg_id\n                           FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE msc_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE msc_msg_id IN (SELECT ids_reference_id\n                                                 FROM '.TBL_IDS.'\n                                                WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_RECIPIENTS.'\n                          WHERE msr_msg_id IN (SELECT ids_reference_id\n                                                 FROM '.TBL_IDS.'\n                                                WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES.'\n                          WHERE msg_id IN (SELECT ids_reference_id\n                                             FROM '.TBL_IDS.'\n                                            WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'].')';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_IDS.'\n                          WHERE ids_usr_id = '.$GLOBALS['gCurrentUserId'];\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_RECIPIENTS.'\n                          WHERE msr_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES_CONTENT.'\n                          WHERE NOT EXISTS (SELECT 1 FROM ' . TBL_MESSAGES_RECIPIENTS . '\n                                            WHERE msr_msg_id = msc_msg_id)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_MESSAGES.'\n                          WHERE NOT EXISTS (SELECT 1 FROM ' . TBL_MESSAGES_RECIPIENTS . '\n                                            WHERE msr_msg_id = msg_id)';\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_REGISTRATIONS.'\n                          WHERE reg_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                          WHERE atl_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_SESSIONS.'\n                          WHERE ses_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_USER_LOG.'\n                          WHERE usl_usr_id = '.$usrId;\n\n        $sqlQueries[] = 'DELETE FROM '.TBL_USER_DATA.'\n                          WHERE usd_usr_id = '.$usrId;\n\n        $this->db->startTransaction();\n\n        foreach ($sqlQueries as $sqlQuery) {\n            $this->db->query($sqlQuery); // TODO add more params\n        }\n\n        $returnValue = parent::delete();\n\n        $this->db->endTransaction();\n\n        return $returnValue;\n    }\n\n    /**\n     * delete all user data of profile fields; user record will not be deleted\n     * @return void\n     */\n    public function deleteUserFieldData()\n    {\n        $this->mProfileFieldsData->deleteUserData();\n    }\n\n    /**\n     * Edit an existing role membership of the current user. If the new date range contains\n     * a future or past membership of the same role then the two memberships will be merged.\n     * In opposite to setRoleMembership this method is useful to end a membership earlier.\n     * @param int    $memberId  Id of the current membership that should be edited.\n     * @param string $startDate New start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   New end date of the membership. Default will be **DATE_MAX**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully edited.\n     */\n    public function editRoleMembership($memberId, $startDate = DATE_NOW, $endDate = DATE_MAX, $leader = null)\n    {\n        return $this->changeRoleMembership('edit', $memberId, $startDate, $endDate, $leader);\n    }\n\n    /**\n     * Creates an array with all categories of one type where the user has the right to edit them\n     * @param string $categoryType The type of the category that should be checked e.g. ANN, USF or DAT\n     * @return array<int,int> Array with categories ids where user has the right to edit them\n     */\n    public function getAllEditableCategories($categoryType)\n    {\n        $queryParams = array($categoryType, $this->organizationId);\n\n        if (($categoryType === 'ANN' && $this->editAnnouncements())\n        || ($categoryType === 'DAT' && $this->editDates())\n        || ($categoryType === 'LNK' && $this->editWeblinksRight())\n        || ($categoryType === 'USF' && $this->editUsers())\n        || ($categoryType === 'ROL' && $this->assignRoles())) {\n            $condition = '';\n        } else {\n            $rolIdParams = array_merge(array(0), $this->getRoleMemberships());\n            $queryParams = array_merge($queryParams, $rolIdParams);\n            $condition = '\n                AND ( EXISTS (SELECT 1\n                                  FROM ' . TBL_ROLES_RIGHTS . '\n                            INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                    ON rrd_ror_id = ror_id\n                                 WHERE ror_name_intern = \\'category_edit\\'\n                                   AND rrd_object_id   = cat_id\n                                   AND rrd_rol_id IN ('.Database::getQmForValues($rolIdParams).') )\n                    )';\n        }\n\n        $sql = 'SELECT cat_id\n                  FROM ' . TBL_CATEGORIES . '\n                 WHERE cat_type = ? -- $categoryType\n                   AND (  cat_org_id IS NULL\n                       OR cat_org_id = ? ) -- $this->organizationId\n                       ' . $condition;\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        $arrEditableCategories = array();\n        while ($catId = $pdoStatement->fetchColumn()) {\n            $arrEditableCategories[] = (int) $catId;\n        }\n\n        return $arrEditableCategories;\n    }\n\n    /**\n     * @param array<int,bool> $rightsList\n     * @return array<int,int>\n     */\n    private function getAllRolesWithRight(array $rightsList)\n    {\n        $this->checkRolesRight();\n\n        $visibleRoles = array();\n\n        foreach ($rightsList as $roleId => $hasRight) {\n            if ($hasRight) {\n                $visibleRoles[] = $roleId;\n            }\n        }\n\n        return $visibleRoles;\n    }\n\n    /**\n     * Creates an array with all roles where the user has the right to mail them\n     * @return array<int,int> Array with role ids where user has the right to mail them\n     */\n    public function getAllMailRoles()\n    {\n        return $this->getAllRolesWithRight($this->listMailRights);\n    }\n\n    /**\n     * Creates an array with all categories of one type where the user has the right to view them\n     * @param string $categoryType The type of the category that should be checked e.g. ANN, USF or DAT\n     * @return array<int,int> Array with categories ids where user has the right to view them\n     */\n    public function getAllVisibleCategories($categoryType)\n    {\n        $queryParams = array($categoryType, $this->organizationId);\n\n        if (($categoryType === 'ANN' && $this->editAnnouncements())\n        || ($categoryType === 'DAT' && $this->editDates())\n        || ($categoryType === 'LNK' && $this->editWeblinksRight())\n        || ($categoryType === 'USF' && $this->editUsers())\n        || ($categoryType === 'ROL' && $this->assignRoles())) {\n            $condition = '';\n        } else {\n            $rolIdParams = array_merge(array(0), $this->getRoleMemberships());\n            $queryParams = array_merge($queryParams, $rolIdParams);\n            $condition = '\n                AND ( EXISTS (SELECT 1\n                                FROM ' . TBL_ROLES_RIGHTS . '\n                          INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                  ON rrd_ror_id = ror_id\n                               WHERE ror_name_intern = \\'category_view\\'\n                                 AND rrd_object_id   = cat_id\n                                 AND rrd_rol_id IN ('.Database::getQmForValues($rolIdParams).') )\n                      OR NOT EXISTS (SELECT 1\n                                       FROM ' . TBL_ROLES_RIGHTS . '\n                                 INNER JOIN ' . TBL_ROLES_RIGHTS_DATA . '\n                                         ON rrd_ror_id = ror_id\n                                      WHERE ror_name_intern = \\'category_view\\'\n                                        AND rrd_object_id   = cat_id )\n                    )';\n        }\n\n        $sql = 'SELECT cat_id\n                  FROM ' . TBL_CATEGORIES . '\n                 WHERE cat_type = ? -- $categoryType\n                   AND (  cat_org_id IS NULL\n                       OR cat_org_id = ? ) -- $this->organizationId\n                       ' . $condition;\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        $arrVisibleCategories = array();\n        while ($catId = $pdoStatement->fetchColumn()) {\n            $arrVisibleCategories[] = (int) $catId;\n        }\n\n        return $arrVisibleCategories;\n    }\n\n    /**\n     * Creates an array with all roles where the user has the right to view them\n     * @return array<int,int> Array with role ids where user has the right to view them\n     */\n    public function getAllVisibleRoles()\n    {\n        return $this->getAllRolesWithRight($this->listViewRights);\n    }\n\n\n    /**\n     * Returns the id of the organization this user object has been assigned.\n     * This is in the default case the default organization of the config file.\n     * @return int Returns the id of the organization this user object has been assigned\n     */\n    public function getOrganization()\n    {\n        return $this->organizationId;\n    }\n\n    /**\n     * Gets the longname of this organization.\n     * @return string Returns the longname of the organization.\n     */\n    private function getOrgLongname()\n    {\n        $sql = 'SELECT org_longname\n                  FROM '.TBL_ORGANIZATIONS.'\n                 WHERE org_id = ?';\n        $orgStatement = $this->db->queryPrepared($sql, array($this->organizationId));\n\n        return $orgStatement->fetchColumn();\n    }\n\n    /**\n     * Returns data from the user to improve dictionary attack check\n     * @return array<int,string>\n     */\n    public function getPasswordUserData()\n    {\n        $userData = array(\n            // Names\n            $this->getValue('FIRST_NAME'),\n            $this->getValue('LAST_NAME'),\n            $this->getValue('usr_login_name'),\n            // Birthday\n            $this->getValue('BIRTHDAY', 'Y'), // YYYY\n            $this->getValue('BIRTHDAY', 'md'), // MMDD\n            $this->getValue('BIRTHDAY', 'dm'), // DDMM\n            // Email\n            $this->getValue('EMAIL'),\n            // Address\n            $this->getValue('STREET'),\n            $this->getValue('CITY'),\n            $this->getValue('POSTCODE'),\n            $this->getValue('COUNTRY')\n        );\n\n        if (!function_exists('filterEmptyStrings')) {\n            /**\n             * @param string $value\n             * @return bool\n             */\n            function filterEmptyStrings($value)\n            {\n                return $value !== '';\n            }\n        }\n\n        return array_filter($userData, 'filterEmptyStrings');\n    }\n\n    /**\n     * Returns an array with all role ids where the user is a member.\n     * @return array<int,int> Returns an array with all role ids where the user is a member.\n     */\n    public function getRoleMemberships()\n    {\n        $this->checkRolesRight();\n\n        return $this->rolesMembership;\n    }\n\n    /**\n     * Returns an array with all role ids where the user is a member and not a leader of the role.\n     * @return array<int,int> Returns an array with all role ids where the user is a member and not a leader of the role.\n     */\n    public function getRoleMembershipsNoLeader()\n    {\n        $this->checkRolesRight();\n\n        return $this->rolesMembershipNoLeader;\n    }\n\n    /**\n     * Get the value of a column of the database table if the column has the praefix **usr_**\n     * otherwise the value of the profile field of the table adm_user_data will be returned.\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read or the internal unique profile field name\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return mixed Returns the value of the database column or the value of adm_user_fields\n     *               If the value was manipulated before with **setValue** than the manipulated value is returned.\n     *\n     * **Code example**\n     * ```\n     * // reads data of adm_users column\n     * $loginname = $gCurrentUser->getValue('usr_login_name');\n     * // reads data of adm_user_fields\n     * $email = $gCurrentUser->getValue('EMAIL');\n     * ```\n     */\n    public function getValue($columnName, $format = '')\n    {\n        global $gSettingsManager;\n\n        if (!str_starts_with($columnName, 'usr_')) {\n            return $this->mProfileFieldsData->getValue($columnName, $format);\n        }\n\n        if ($columnName === 'usr_photo' && (int) $gSettingsManager->get('profile_photo_storage') === 0) {\n            $file = ADMIDIO_PATH . FOLDER_DATA . '/user_profile_photos/' . (int) $this->getValue('usr_id') . '.jpg';\n            if (is_file($file)) {\n                return file_get_contents($file);\n            }\n        }\n\n        return parent::getValue($columnName, $format);\n    }\n\n    /**\n     * Creates a vcard with all data of this user object\n     * (Windows XP address book can't process utf8, so vcard output is iso-8859-1)\n     * @return string Returns the vcard as a string\n     */\n    public function getVCard()\n    {\n        global $gSettingsManager, $gCurrentUser;\n\n        $vCard = array(\n            'BEGIN:VCARD',\n            'VERSION:2.1'\n        );\n\n        if ($gCurrentUser->allowedViewProfileField($this, 'FIRST_NAME')) {\n            $vCard[] = 'N;CHARSET=ISO-8859-1:' .\n                utf8_decode($this->getValue('LAST_NAME', 'database')) . ';' .\n                utf8_decode($this->getValue('FIRST_NAME', 'database')) . ';;;';\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'LAST_NAME')) {\n            $vCard[] = 'FN;CHARSET=ISO-8859-1:' .\n                utf8_decode($this->getValue('FIRST_NAME')) . ' ' .\n                utf8_decode($this->getValue('LAST_NAME'));\n        }\n        if ($this->getValue('usr_login_name') !== '') {\n            $vCard[] = 'NICKNAME;CHARSET=ISO-8859-1:' . utf8_decode($this->getValue('usr_login_name'));\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'PHONE')) {\n            $vCard[] = 'TEL;HOME;VOICE:' . $this->getValue('PHONE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'MOBILE')) {\n            $vCard[] = 'TEL;CELL;VOICE:' . $this->getValue('MOBILE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'FAX')) {\n            $vCard[] = 'TEL;HOME;FAX:' . $this->getValue('FAX');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'STREET')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'CITY')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'POSTCODE')\n        &&  $gCurrentUser->allowedViewProfileField($this, 'COUNTRY')) {\n            $vCard[] = 'ADR;CHARSET=ISO-8859-1;HOME:;;' .\n                utf8_decode($this->getValue('STREET', 'database')) . ';' .\n                utf8_decode($this->getValue('CITY', 'database')) . ';;' .\n                utf8_decode($this->getValue('POSTCODE', 'database')) . ';' .\n                utf8_decode($this->getValue('COUNTRY', 'database'));\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'WEBSITE')) {\n            $vCard[] = 'URL;HOME:' . $this->getValue('WEBSITE');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'BIRTHDAY')) {\n            $vCard[] = 'BDAY:' . $this->getValue('BIRTHDAY', 'Ymd');\n        }\n        if ($gCurrentUser->allowedViewProfileField($this, 'EMAIL')) {\n            $vCard[] = 'EMAIL;PREF;INTERNET:' . $this->getValue('EMAIL');\n        }\n        $file = ADMIDIO_PATH . FOLDER_DATA . '/user_profile_photos/' . (int) $this->getValue('usr_id') . '.jpg';\n        if ((int) $gSettingsManager->get('profile_photo_storage') === 1 && is_file($file)) {\n            $imgHandle = fopen($file, 'rb');\n            if ($imgHandle !== false) {\n                $base64Image = base64_encode(fread($imgHandle, filesize($file)));\n                fclose($imgHandle);\n\n                $vCard[] = 'PHOTO;ENCODING=BASE64;TYPE=JPEG:' . $base64Image;\n            }\n        }\n        if ((int) $gSettingsManager->get('profile_photo_storage') === 0 && $this->getValue('usr_photo') !== '') {\n            $vCard[] = 'PHOTO;ENCODING=BASE64;TYPE=JPEG:' . base64_encode($this->getValue('usr_photo'));\n        }\n        // Geschlecht ist nicht in vCard 2.1 enthalten, wird hier fuer das Windows-Adressbuch uebergeben\n        if ($gCurrentUser->allowedViewProfileField($this, 'GENDER') && $this->getValue('GENDER') > 0) {\n            if ((int) $this->getValue('GENDER') === 1) {\n                $xGender = 'Male';\n                $xWabGender = 2;\n            } else {\n                $xGender = 'Female';\n                $xWabGender = 1;\n            }\n\n            $vCard[] = 'X-GENDER:' . $xGender;\n            $vCard[] = 'X-WAB-GENDER:' . $xWabGender;\n        }\n        if ($this->getValue('usr_timestamp_change') !== '') {\n            $vCard[] = 'REV:' . $this->getValue('usr_timestamp_change', 'Ymd\\This');\n        }\n\n        $vCard[] = 'END:VCARD';\n\n        return implode(\"\\r\\n\", $vCard) . \"\\r\\n\";\n    }\n\n    /**\n     * Returns true if a column of user table or profile fields has changed\n     * @return bool Returns true if a column of user table or profile fields has changed\n     */\n    public function hasColumnsValueChanged()\n    {\n        return parent::hasColumnsValueChanged() || $this->mProfileFieldsData->hasColumnsValueChanged();\n    }\n\n    /**\n     * Check if the user has deposited an email. Therefore at least one profile field from type EMAIL\n     * must have a value.\n     * @return bool Return true if the user has deposited an email.\n     */\n    public function hasEmail()\n    {\n        if ($this->getValue('EMAIL') !== '') {\n            return true;\n        }\n\n        foreach ($this->mProfileFieldsData->getProfileFields() as $profileField) {// => $profileFieldConfig)\n            if ($profileField->getValue('usf_type') === 'EMAIL'\n            && $this->mProfileFieldsData->getValue($profileField->getValue('usf_name_intern')) !== '') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the maximum of invalid logins is reached.\n     * @return bool Returns true if the maximum of invalid logins is reached.\n     */\n    private function hasMaxInvalidLogins()\n    {\n        global $gLogger;\n\n        // if within 15 minutes 3 wrong login took place -> block user account for 15 minutes\n        $now = new \\DateTime();\n        $minutesOffset = new \\DateInterval('PT15M');\n        $minutesBefore = $now->sub($minutesOffset);\n        $dateInvalid = \\DateTime::createFromFormat('Y-m-d H:i:s', $this->getValue('usr_date_invalid', 'Y-m-d H:i:s'));\n\n        if ($this->getValue('usr_number_invalid') < self::MAX_INVALID_LOGINS || $minutesBefore->getTimestamp() > $dateInvalid->getTimestamp()) {\n            return false;\n        }\n\n        $loggingObject = array(\n            'username'      => $this->getValue('usr_login_name'),\n            'numberInvalid' => (int) $this->getValue('usr_number_invalid'),\n            'dateInvalid'   => $this->getValue('usr_date_invalid', 'Y-m-d H:i:s')\n        );\n        $gLogger->warning('AUTHENTICATION: Maximum number of invalid logins!', $loggingObject);\n\n        $this->clear();\n\n        return true;\n    }\n\n    /**\n     * Checks if the current user is allowed to edit the profile of the user of the parameter.\n     * If will check if user can generally edit all users or if he is a group leader and can edit users\n     * of a special role where **$user** is a member or if it's the own profile and he could edit this.\n     * @param User  $user            User object of the user that should be checked if the current user can edit his profile.\n     * @param bool  $checkOwnProfile If set to **false** than this method don't check the role right to edit the own profile.\n     * @return bool Return **true** if the current user is allowed to edit the profile of the user from **$user**.\n     */\n    public function hasRightEditProfile(self $user, $checkOwnProfile = true)\n    {\n        if (!$user instanceof self) {\n            return false;\n        }\n\n        $usrId  = (int) $this->getValue('usr_id');\n        $userId = (int) $user->getValue('usr_id');\n\n        // edit own profile ?\n        if ($usrId > 0 && $usrId === $userId && $checkOwnProfile && $this->checkRolesRight('rol_profile')) {\n            return true;\n        }\n\n        // first check if user is in cache\n        if (array_key_exists($userId, $this->usersEditAllowed)) {\n            return $this->usersEditAllowed[$userId];\n        }\n\n        $returnValue = false;\n\n        if ($this->editUsers()) {\n            $returnValue = true;\n        } else {\n            if (count($this->rolesMembershipLeader) > 0) {\n                // leaders are not allowed to edit profiles of other leaders but to edit their own profile\n                if ($usrId === $userId) {\n                    // check if current user is a group leader of a role where $user is only a member\n                    $rolesMembership = $user->getRoleMemberships();\n                } else {\n                    // check if current user is a group leader of a role where $user is only a member and not a leader\n                    $rolesMembership = $user->getRoleMembershipsNoLeader();\n                }\n\n                foreach ($this->rolesMembershipLeader as $roleId => $leaderRights) {\n                    // is group leader of role and has the right to edit users ?\n                    if ($leaderRights > 1 && in_array($roleId, $rolesMembership, true)) {\n                        $returnValue = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // check if user has a relationship to current user and is allowed to edit him\n        if (!$returnValue && $this->checkRelationshipsRights()) {\n            foreach ($this->relationships as $relationshipUser) {\n                if ($relationshipUser['user_id'] === $userId && $relationshipUser['edit_user']) {\n                    $returnValue = true;\n                    break;\n                }\n            }\n        }\n\n        // add result into cache\n        $this->usersEditAllowed[$userId] = $returnValue;\n\n        return $returnValue;\n    }\n\n    /**\n     * @param array<int,bool> $rightsList\n     * @param string          $rightName\n     * @param int             $roleId\n     * @return bool\n     */\n    private function hasRightRole(array $rightsList, $rightName, $roleId)\n    {\n        // if user has right to view all lists then he could also view this role\n        if ($this->checkRolesRight($rightName)) {\n            return true;\n        }\n\n        // check if user has the right to view this role\n        return array_key_exists($roleId, $rightsList) && $rightsList[$roleId];\n    }\n\n    /**\n     * Checks if the current user has the right to send an email to the role.\n     * @param int $roleId Id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to send an email to the role.\n     */\n    public function hasRightSendMailToRole($roleId)\n    {\n        return $this->hasRightRole($this->listMailRights, 'rol_mail_to_all', $roleId);\n    }\n\n    /**\n     * Checks the necessary rights if this user could view former roles members. Therefore\n     * the user must also have the right to view the role. So you must also check this right.\n     * @param int $roleId Id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to view former roles members\n     */\n    public function hasRightViewFormerRolesMembers($roleId)\n    {\n        global $gSettingsManager;\n\n        if ((int) $gSettingsManager->get('groups_roles_show_former_members') !== 1\n        && ($this->checkRolesRight('rol_assign_roles')\n        || ($this->isLeaderOfRole($roleId) && in_array($this->rolesMembershipLeader[$roleId], array(1, 3), true)))) {\n            return true;\n        } elseif ((int) $gSettingsManager->get('groups_roles_show_former_members') !== 2\n        && ($this->checkRolesRight('rol_edit_user')\n        || ($this->isLeaderOfRole($roleId) && in_array($this->rolesMembershipLeader[$roleId], array(2, 3), true)))) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the current user is allowed to view the profile of the user of the parameter.\n     * If will check if user has edit rights with method editProfile or if the user is a member\n     * of a role where the current user has the right to view profiles.\n     * @param User $user User object of the user that should be checked if the current user can view his profile.\n     * @return bool Return **true** if the current user is allowed to view the profile of the user from **$user**.\n     */\n    public function hasRightViewProfile(self $user)\n    {\n        global $gValidLogin;\n\n        // if user is allowed to edit the profile then he can also view it\n        if ($this->hasRightEditProfile($user)) {\n            return true;\n        }\n\n        // every user is allowed to view his own profile\n        if ((int) $user->getValue('usr_id') === (int) $this->getValue('usr_id') && (int) $this->getValue('usr_id') > 0) {\n            return true;\n        }\n\n        // Benutzer, die alle Listen einsehen duerfen, koennen auch alle Profile sehen\n        if ($this->checkRolesRight('rol_all_lists_view')) {\n            return true;\n        }\n\n        $sql = 'SELECT rol_id, rol_this_list_view\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE rol_valid  = true\n                   AND mem_usr_id = ? -- $user->getValue(\\'usr_id\\')\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND (  cat_org_id = ? -- $this->organizationId\n                       OR cat_org_id IS NULL ) ';\n        $queryParams = array((int) $user->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $listViewStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($listViewStatement->rowCount() > 0) {\n            while ($row = $listViewStatement->fetch()) {\n                $rolId = (int) $row['rol_id'];\n                $rolThisListView = (int) $row['rol_this_list_view'];\n\n                if ($gValidLogin && $rolThisListView === 2) {\n                    // alle angemeldeten Benutzer duerfen Rollenlisten/-profile sehen\n                    return true;\n                }\n\n                if ($rolThisListView === 1 && array_key_exists($rolId, $this->listViewRights) && $this->listViewRights[$rolId]) {\n                    // nur Rollenmitglieder duerfen Rollenlisten/-profile sehen\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if the user of this object has the right to view the role that is set in the parameter.\n     * @param int $roleId The id of the role that should be checked.\n     * @return bool Return **true** if the user has the right to view the role otherwise **false**.\n     */\n    public function hasRightViewRole($roleId)\n    {\n        return $this->hasRightRole($this->listViewRights, 'rol_all_lists_view', $roleId);\n    }\n\n    /**\n     * Handles the incorrect given login password.\n     * @return string Return string with the reason why the login failed.\n     */\n    private function handleIncorrectPasswordLogin()\n    {\n        global $gLogger;\n\n        // log invalid logins\n        if ($this->getValue('usr_number_invalid') >= self::MAX_INVALID_LOGINS) {\n            $this->setValue('usr_number_invalid', 1);\n        } else {\n            $this->setValue('usr_number_invalid', $this->getValue('usr_number_invalid') + 1);\n        }\n\n        $this->setValue('usr_date_invalid', DATETIME_NOW);\n        $this->saveChangesWithoutRights();\n        $this->save(false); // don't update timestamp // TODO Exception handling\n\n        $loggingObject = array(\n            'username'      => $this->getValue('usr_login_name'),\n            'numberInvalid' => (int) $this->getValue('usr_number_invalid'),\n            'dateInvalid'   => $this->getValue('usr_date_invalid', 'Y-m-d H:i:s')\n        );\n\n        if ($this->getValue('usr_number_invalid') >= self::MAX_INVALID_LOGINS) {\n            $this->clear();\n\n            $gLogger->warning('AUTHENTICATION: Maximum number of invalid logins!', $loggingObject);\n\n            return 'SYS_LOGIN_MAX_INVALID_LOGIN';\n        }\n\n        $this->clear();\n\n        $gLogger->warning('AUTHENTICATION: Incorrect username/password!', $loggingObject);\n\n        return 'SYS_LOGIN_USERNAME_PASSWORD_INCORRECT';\n    }\n\n    /**\n     * Deletes all other sessions of the current user except the current session. Also all auto logins of the user\n     * will be removed. This method is useful if the user changed his password or if unusual activities within\n     * the user account are noticed.\n     * @return bool Returns true if all things could be done. Otherwise false is returned.\n     */\n    public function invalidateAllOtherLogins()\n    {\n        global $gCurrentUserId, $gCurrentSession;\n\n        // remove all sessions of the current user except the current session\n        $sql = 'DELETE FROM ' . TBL_SESSIONS . '\n                 WHERE ses_usr_id = ? -- $gCurrentUserId\n                   AND ses_id    <> ? -- $gCurrentSession->getValue(\\'ses_id\\') ';\n        $queryParams = array($gCurrentUserId, $gCurrentSession->getValue('ses_id'));\n        $this->db->queryPrepared($sql, $queryParams);\n\n        // remove all auto logins of the current user\n        $sql = 'DELETE FROM ' . TBL_AUTO_LOGIN . '\n                 WHERE atl_usr_id = ? -- $gCurrentUserId ';\n        $queryParams = array($gCurrentUserId);\n        $this->db->queryPrepared($sql, $queryParams);\n\n        return true;\n    }\n\n    /**\n     * Checks if the user is assigned to the role **Administrator**\n     * @return bool Returns **true** if the user is a member of the role **Administrator**\n     */\n    public function isAdministrator()\n    {\n        $this->checkRolesRight();\n\n        return $this->administrator;\n    }\n\n    /**\n     * Checks if this user is an admin of this organization.\n     * @param string $orgLongname The longname of this organization.\n     * @return bool Return true if user is admin of this organization.\n     */\n    private function isAdminOfOrganization($orgLongname)\n    {\n        global $gLogger, $installedDbVersion;\n\n        // Deprecated: Fallback for updates from v3.0 and v3.1\n        if (version_compare($installedDbVersion, '3.2', '>=')) {\n            $administratorColumn = 'rol_administrator';\n        } else {\n            $administratorColumn = 'rol_webmaster';\n        }\n\n        // Check if user is currently member of a role of an organisation\n        $sql = 'SELECT mem_usr_id\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                   AND rol_valid  = true\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND cat_org_id = ? -- $this->organizationId\n                   AND '.$administratorColumn.' = true ';\n        $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($pdoStatement->rowCount() > 0) {\n            return true;\n        }\n\n        $loggingObject = array(\n            'username'     => $this->getValue('usr_login_name'),\n            'organisation' => $orgLongname\n        );\n\n        $gLogger->warning('AUTHENTICATION: User is no administrator!', $loggingObject);\n\n        return false;\n    }\n\n    /**\n     * check if user is leader of a role\n     * @param int $roleId\n     * @return bool\n     */\n    public function isLeaderOfRole($roleId)\n    {\n        return array_key_exists($roleId, $this->rolesMembershipLeader);\n    }\n\n    /**\n     * Checks if this user is a member of this organization.\n     * @param string $orgLongname The longname of this organization.\n     * @return bool Return true if user is member of this organization.\n     */\n    private function isMemberOfOrganization($orgLongname)\n    {\n        global $gLogger;\n\n        // Check if user is currently member of a role of an organisation\n        $sql = 'SELECT mem_usr_id\n                  FROM '.TBL_MEMBERS.'\n            INNER JOIN '.TBL_ROLES.'\n                    ON rol_id = mem_rol_id\n            INNER JOIN '.TBL_CATEGORIES.'\n                    ON cat_id = rol_cat_id\n                 WHERE mem_usr_id = ? -- $this->getValue(\\'usr_id\\')\n                   AND rol_valid  = true\n                   AND mem_begin <= ? -- DATE_NOW\n                   AND mem_end    > ? -- DATE_NOW\n                   AND cat_org_id = ? -- $this->organizationId';\n        $queryParams = array((int) $this->getValue('usr_id'), DATE_NOW, DATE_NOW, $this->organizationId);\n        $pdoStatement = $this->db->queryPrepared($sql, $queryParams);\n\n        if ($pdoStatement->rowCount() > 0) {\n            return true;\n        }\n\n        $loggingObject = array(\n            'username'     => $this->getValue('usr_login_name'),\n            'organisation' => $orgLongname\n        );\n\n        $gLogger->warning('AUTHENTICATION: User is not member in this organisation!', $loggingObject);\n\n        return false;\n    }\n\n    /**\n     * check if user is member of a role\n     * @param int $roleId\n     * @return bool\n     */\n    public function isMemberOfRole($roleId)\n    {\n        return in_array($roleId, $this->rolesMembership, true);\n    }\n\n    /**\n     * If this method is called than all further calls of method **setValue** will not check the values.\n     * The values will be stored in database without any inspections!\n     * @return void\n     */\n    public function noValueCheck()\n    {\n        $this->mProfileFieldsData->noValueCheck();\n    }\n\n    /**\n     * Reads a user record out of the table adm_users in database selected by the unique user id.\n     * Also all profile fields of the object **mProfileFieldsData** will be read.\n     * @param int $userId Unique id of the user that should be read\n     * @return bool Returns **true** if one record is found\n     */\n    public function readDataById($userId)\n    {\n        if (parent::readDataById($userId)) {\n            // read data of all user fields from current user\n            $this->mProfileFieldsData->readUserData($userId, $this->organizationId);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads a record out of the table in database selected by the unique uuid column in the table.\n     * The name of the column must have the syntax table_prefix, underscore and uuid. E.g. usr_uuid.\n     * Per default all columns of the default table will be read and stored in the object.\n     * Not every Admidio table has a uuid. Please check the database structure before you use this method.\n     * @param int $uuid Unique uuid that should be searched.\n     * @return bool Returns **true** if one record is found\n     * @see TableAccess#readData\n     * @see TableAccess#readDataByColumns\n     */\n    public function readDataByUuid($uuid)\n    {\n        if (parent::readDataByUuid($uuid)) {\n            // read data of all user fields from current user\n            $this->mProfileFieldsData->readUserData($this->getValue('usr_id'), $this->organizationId);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rehashes the password of the user if necessary.\n     * @param string $password The password for the current user. This should not be encoded.\n     * @return bool Returns true if password was rehashed.\n     */\n    private function rehashIfNecessary($password)\n    {\n        global $gLogger;\n\n        if (!PasswordUtils::needsRehash($this->getValue('usr_password'))) {\n            return false;\n        }\n\n        $this->saveChangesWithoutRights();\n        $this->setPassword($password);\n        $this->save(); // TODO Exception handling\n\n        $gLogger->info('AUTHENTICATION: Password rehashed!', array('username' => $this->getValue('usr_login_name')));\n\n        return true;\n    }\n\n    /**\n     * Initialize all rights and role membership arrays so that all rights and\n     * role memberships will be read from database if another method needs them\n     * @return void\n     */\n    public function renewRoleData()\n    {\n        // initialize rights arrays\n        $this->rolesRights     = array();\n        $this->listViewRights  = array();\n        $this->listMailRights  = array();\n        $this->rolesMembership = array();\n        $this->rolesMembershipLeader   = array();\n        $this->rolesMembershipNoLeader = array();\n    }\n\n    /**\n     * Reset the count of invalid logins. After that it's possible for the user to try another login.\n     */\n    public function resetInvalidLogins()\n    {\n        $this->setValue('usr_date_invalid', null);\n        $this->setValue('usr_number_invalid', 0);\n        $this->save(false); // Zeitstempel nicht aktualisieren // TODO Exception handling\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's a new\n     * record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * First save recordset and then save all user fields. After that the session of this got a renew for the user object.\n     * If the user doesn't have the right to save data of this user than an exception will be thrown.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset\n     *                                if table has columns like **usr_id_create** or **usr_id_changed**\n     * @throws AdmException\n     * @return bool\n     */\n    public function save($updateFingerPrint = true)\n    {\n        global $gCurrentSession, $gCurrentUser, $gChangeNotification;\n\n        $usrId = $this->getValue('usr_id');\n\n        // if current user is not new and is not allowed to edit this user\n        // and saveChangesWithoutRights isn't true than throw exception\n        if (!$this->saveChangesWithoutRights && $usrId > 0 && !$gCurrentUser->hasRightEditProfile($this)) {\n            throw new AdmException('The profile data of user ' . $this->getValue('FIRST_NAME') . ' '\n                . $this->getValue('LAST_NAME') . ' could not be saved because you don\\'t have the right to do this.');\n        }\n\n        $this->db->startTransaction();\n\n        // if new user then set create id and the uuid\n        $updateCreateUserId = false;\n        if ($usrId === 0) {\n            if ($GLOBALS['gCurrentUserId'] === 0) {\n                $updateCreateUserId = true;\n                $updateFingerPrint  = false;\n            }\n        }\n\n        // if value of a field changed then update timestamp of user object\n        if ($this->mProfileFieldsData instanceof ProfileFields && $this->mProfileFieldsData->hasColumnsValueChanged()) {\n            $this->columnsValueChanged = true;\n        }\n\n        $newRecord = $this->newRecord;\n\n        $returnValue = parent::save($updateFingerPrint);\n        $usrId = (int) $this->getValue('usr_id'); // if a new user was created get the new id\n\n        // if this was an registration then set this user id to create user id\n        if ($updateCreateUserId) {\n            $this->setValue('usr_timestamp_create', DATETIME_NOW);\n            $this->setValue('usr_usr_id_create', $usrId);\n            $returnValue = $returnValue && parent::save($updateFingerPrint);\n        }\n\n        if ($this->mProfileFieldsData instanceof ProfileFields) {\n            // save data of all user fields\n            $this->mProfileFieldsData->saveUserData($usrId);\n        }\n\n        if ($this->columnsValueChanged && $gCurrentSession instanceof Session) {\n            // now set reload the session of the user,\n            // because he has new data and maybe new rights\n            $gCurrentSession->reload($usrId);\n        }\n        // The record is a new record, which was just stored to the database\n        // for the first time => record it as a user creation now\n        if ($newRecord && is_object($gChangeNotification)) {\n            // Register all non-empty fields for the notification\n            $gChangeNotification->logUserCreation($usrId, $this);\n        }\n\n        $this->db->endTransaction();\n\n        return $returnValue;\n    }\n\n    /**\n     * Set the id of the organization which should be used in this user object.\n     * The organization is used to read the rights of the user. If **setOrganization** isn't called\n     * than the default organization **gCurrentOrganization** is set for the current user object.\n     * @param int $organizationId Id of the organization\n     * @return void\n     */\n    public function setOrganization($organizationId)\n    {\n        $this->organizationId = $organizationId;\n        $this->rolesRights    = array();\n    }\n\n    /**\n     * Set a new value for a password column of the database table.\n     * The value is only saved in the object. You must call the method **save** to store the new value to the database\n     * @param string $newPassword   The new value that should be stored in the database field\n     * @param bool   $doHashing     Should the password get hashed before inserted. Default is true\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     */\n    public function setPassword($newPassword, $doHashing = true)\n    {\n        global $gSettingsManager, $gPasswordHashAlgorithm, $gChangeNotification;\n\n        if (!$doHashing) {\n            if (is_object($gChangeNotification)) {\n                $gChangeNotification->logUserChange(\n                    (int) $this->getValue('usr_id'),\n                    'usr_password',\n                    $this->getValue('usr_password'),\n                    $newPassword,\n                    $this\n                );\n            }\n            return parent::setValue('usr_password', $newPassword, false);\n        }\n\n        // get the saved cost value that fits your server performance best and rehash your password\n        $options = array('cost' => 10);\n        if (isset($gSettingsManager) && $gSettingsManager->has('system_hashing_cost')) {\n            $options['cost'] = $gSettingsManager->getInt('system_hashing_cost');\n        }\n\n        $newPasswordHash = PasswordUtils::hash($newPassword, $gPasswordHashAlgorithm, $options);\n\n        if ($newPasswordHash === false) {\n            return false;\n        }\n\n        if (is_object($gChangeNotification)) {\n            $gChangeNotification->logUserChange(\n                (int) $this->getValue('usr_id'),\n                'usr_password',\n                $this->getValue('usr_password'),\n                $newPasswordHash,\n                $this\n            );\n        }\n        if(parent::setValue('usr_password', $newPasswordHash, false)) {\n            // for security reasons remove all sessions and auto login of the user\n            return $this->invalidateAllOtherLogins();\n        }\n\n        return false;\n    }\n\n    /**\n     * Create a new membership to a role for the current user. If the date range contains\n     * a future or past membership of the same role then the two memberships will be merged.\n     * In opposite to setRoleMembership this method can't be used to end a membership earlier!\n     * @param int    $roleId    Id of the role for which the membership should be set.\n     * @param string $startDate Start date of the membership. Default will be **DATE_NOW**.\n     * @param string $endDate   End date of the membership. Default will be **31.12.9999**\n     * @param bool   $leader    If set to **1** then the member will be leader of the role and\n     *                          might get more rights for this role.\n     * @return bool Return **true** if the membership was successfully added.\n     */\n    public function setRoleMembership($roleId, $startDate = DATE_NOW, $endDate = DATE_MAX, $leader = null)\n    {\n        return $this->changeRoleMembership('set', $roleId, $startDate, $endDate, $leader);\n    }\n\n    /**\n     * Set a new value for a column of the database table if the column has the prefix **usr_**\n     * otherwise the value of the profile field of the table adm_user_data will set.\n     * If the user log is activated than the change of the value will be logged in **adm_user_log**.\n     * The value is only saved in the object. You must call the method **save** to store the new value to the database\n     * @param string $columnName The name of the database column whose value should get a new value or the\n     *                           internal unique profile field name\n     * @param mixed  $newValue   The new value that should be stored in the database field\n     * @param bool   $checkValue The value will be checked if it's valid. If set to **false** than the value will\n     *                           not be checked.\n     * @return bool Returns **true** if the value is stored in the current object and **false** if a check failed\n     *\n     * **Code example**\n     * ```\n     * // set data of adm_users column\n     * $gCurrentUser->getValue('usr_login_name', 'Admidio');\n     * // reads data of adm_user_fields\n     * $gCurrentUser->getValue('EMAIL', 'administrator@admidio.org');\n     * ```\n     */\n    public function setValue($columnName, $newValue, $checkValue = true)\n    {\n        global $gSettingsManager, $gChangeNotification;\n\n        // users data from adm_users table\n        if (str_starts_with($columnName, 'usr_')) {\n            // don't change user password; use $user->setPassword()\n            if ($columnName === 'usr_password') {\n                return false;\n            }\n\n            // username should not contain special characters\n            if ($checkValue && $columnName === 'usr_login_name' && $newValue !== '' && !StringUtils::strValidCharacters($newValue, 'noSpecialChar')) {\n                return false;\n            }\n\n            // only update if value has changed\n            if ($this->getValue($columnName, 'database') == $newValue) {\n                return true;\n            }\n\n            // For new records, do not immediately queue all changes for notification,\n            // as the record might never be saved to the database (e.g. when\n            // doing a check for an existing user)! => For new records,\n            // log the changes only when $this->save is called!\n            if (!$this->newRecord && is_object($gChangeNotification)) {\n                $gChangeNotification->logUserChange(\n                    $this->getValue('usr_id'),\n                    $columnName,\n                    $this->getValue($columnName),\n                    $newValue,\n                    $this\n                );\n            }\n\n            return parent::setValue($columnName, $newValue, $checkValue);\n        }\n\n        // user data from adm_user_fields table (human-readable text representation and raw database value)\n        $oldFieldValue = $this->mProfileFieldsData->getValue($columnName);\n        $oldFieldValue_db = $this->mProfileFieldsData->getValue($columnName, 'database');\n        $newValue = (string) $newValue;\n\n        // format of date will be local but database hase stored Y-m-d format must be changed for compare\n        if ($this->mProfileFieldsData->getProperty($columnName, 'usf_type') === 'DATE') {\n            $date = \\DateTime::createFromFormat($gSettingsManager->getString('system_date'), $newValue);\n\n            if ($date !== false) {\n                $newValue = $date->format('Y-m-d');\n            }\n        }\n\n        // only update if value has changed\n        if ($oldFieldValue_db === $newValue) {\n            return true;\n        }\n\n        $returnCode = false;\n\n        // Disabled fields can only be edited by users with the right \"edit_users\" except on registration.\n        // Here is no need to check hidden fields because we check on save() method that only users who\n        // can edit the profile are allowed to save and change data.\n        if (($this->getValue('usr_id') === 0 && $GLOBALS['gCurrentUserId'] === 0)\n        ||  (int) $this->mProfileFieldsData->getProperty($columnName, 'usf_disabled') === 0\n        || ((int) $this->mProfileFieldsData->getProperty($columnName, 'usf_disabled') === 1\n            && $GLOBALS['gCurrentUser']->hasRightEditProfile($this, false))\n        || $this->saveChangesWithoutRights === true) {\n            $returnCode = $this->mProfileFieldsData->setValue($columnName, $newValue);\n        }\n\n        // Nicht alle Aenderungen werden geloggt. Ausnahmen:\n        // Felder, die mit usr_ beginnen (special case above)\n        // Felder, die sich nicht ge\u00e4ndert haben (check above)\n        // Wenn usr_id ist 0 (der User neu angelegt wird; Das wird bereits dokumentiert) (check in logProfileChange)\n\n        if ($returnCode && !$this->newRecord && is_object($gChangeNotification)) {\n            $gChangeNotification->logProfileChange(\n                $this->getValue('usr_id'),\n                $this->mProfileFieldsData->getProperty($columnName, 'usf_id'),\n                $columnName, // TODO: is $columnName the internal name or the human-readable?\n                // Old and new values in human-readable version:\n                $oldFieldValue,\n                $this->mProfileFieldsData->getValue($columnName),\n                // Old and new values in raw dtabase:\n                $oldFieldValue_db,\n                $newValue,\n                $this\n            );\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * set value for column usd_value of field\n     * @param string $fieldNameIntern Expects the **usf_name_intern** of the field that should get a new value.\n     * @param mixed  $fieldValue\n     * @return bool\n     */\n    public function setProfileFieldsValue($fieldNameIntern, $fieldValue)\n    {\n        return $this->mProfileFieldsData->setValue($fieldNameIntern, $fieldValue);\n    }\n\n    /**\n     * Update login data for this user. These are timestamps of last login and reset count\n     * and timestamp of invalid logins.\n     * @return void\n     */\n    public function updateLoginData()\n    {\n        $this->saveChangesWithoutRights();\n        $this->setValue('usr_last_login', $this->getValue('usr_actual_login', 'Y-m-d H:i:s'));\n        $this->setValue('usr_number_login', (int) $this->getValue('usr_number_login') + 1);\n        $this->setValue('usr_actual_login', DATETIME_NOW);\n        $this->save(false); // Zeitstempel nicht aktualisieren // TODO Exception handling\n\n        $this->resetInvalidLogins();\n    }\n\n    /**\n     * Funktion prueft, ob der angemeldete User Ankuendigungen anlegen und bearbeiten darf\n     * @return bool\n     */\n    public function editAnnouncements()\n    {\n        return $this->checkRolesRight('rol_announcements');\n    }\n\n    /**\n     * Funktion prueft, ob der angemeldete User Registrierungen bearbeiten und zuordnen darf\n     * @return bool\n     */\n    public function approveUsers()\n    {\n        return $this->checkRolesRight('rol_approve_users');\n    }\n\n    /**\n     * Checks if the user has the right to assign members to at least one role.\n     * @return bool Return **true** if the user can assign members to at least one role.\n     */\n    public function assignRoles()\n    {\n        $this->checkRolesRight();\n\n        return $this->assignRoles;\n    }\n\n    /**\n     * Method checks if the current user is allowed to manage roles and therefore has\n     * admin access to the groups and roles module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function manageRoles()\n    {\n        return $this->checkRolesRight('rol_assign_roles');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the event module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editDates()\n    {\n        return $this->checkRolesRight('rol_dates');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the documents and files module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function adminDocumentsFiles()\n    {\n        return $this->checkRolesRight('rol_documents_files');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate other user profiles and therefore\n     * has access to the user management module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editUsers()\n    {\n        return $this->checkRolesRight('rol_edit_user');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the guestbook module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editGuestbookRight()\n    {\n        return $this->checkRolesRight('rol_guestbook');\n    }\n\n    /**\n     * Method checks if the current user is allowed to comment guestbook entries.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function commentGuestbookRight()\n    {\n        return $this->checkRolesRight('rol_guestbook_comments');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the photos module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editPhotoRight()\n    {\n        return $this->checkRolesRight('rol_photo');\n    }\n\n    /**\n     * Method checks if the current user is allowed to administrate the weblinks module.\n     * @return bool Return true if the user is admin of the module otherwise false\n     */\n    public function editWeblinksRight()\n    {\n        return $this->checkRolesRight('rol_weblinks');\n    }\n\n    /**\n     * Return the (internal) representation of this user's profile fields\n     * @return object<ProfileFields> All profile fields of the user\n     */\n    public function getProfileFieldsData()\n    {\n        return $this->mProfileFieldsData;\n    }\n}\n"], "filenames": ["adm_program/system/classes/Session.php", "adm_program/system/classes/User.php"], "buggy_code_start_loc": [77, 112], "buggy_code_end_loc": [551, 2033], "fixing_code_start_loc": [77, 112], "fixing_code_end_loc": [562, 2063], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository admidio/admidio prior to 4.1.9.", "other": {"cve": {"id": "CVE-2022-0991", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-19T08:15:06.937", "lastModified": "2022-03-28T18:54:03.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository admidio/admidio prior to 4.1.9."}, {"lang": "es", "value": "Una Expiraci\u00f3n de Sesi\u00f3n Insuficiente en el repositorio de GitHub admidio/admidio versiones anteriores a 4.1.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:admidio:admidio:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.9", "matchCriteriaId": "7187CE9B-F7C4-4360-8C3F-CA05A90F1418"}]}]}], "references": [{"url": "https://github.com/admidio/admidio/commit/e84e472ebe517e2ff5795c46dc10b5f49dc4d46a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1c406a4e-15d0-4920-8495-731c48473ba4", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/admidio/admidio/commit/e84e472ebe517e2ff5795c46dc10b5f49dc4d46a"}}