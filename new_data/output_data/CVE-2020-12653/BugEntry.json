{"buggy_code": ["/*\n * Marvell Wireless LAN device driver: scan ioctl and command handling\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"11n.h\"\n#include \"cfg80211.h\"\n\n/* The maximum number of channels the firmware can scan per command */\n#define MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN   14\n\n#define MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD\t4\n\n/* Memory needed to store a max sized Channel List TLV for a firmware scan */\n#define CHAN_TLV_MAX_SIZE  (sizeof(struct mwifiex_ie_types_header)         \\\n\t\t\t\t+ (MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN     \\\n\t\t\t\t*sizeof(struct mwifiex_chan_scan_param_set)))\n\n/* Memory needed to store supported rate */\n#define RATE_TLV_MAX_SIZE   (sizeof(struct mwifiex_ie_types_rates_param_set) \\\n\t\t\t\t+ HOSTCMD_SUPPORTED_RATES)\n\n/* Memory needed to store a max number/size WildCard SSID TLV for a firmware\n\tscan */\n#define WILDCARD_SSID_TLV_MAX_SIZE  \\\n\t(MWIFIEX_MAX_SSID_LIST_LENGTH *\t\t\t\t\t\\\n\t\t(sizeof(struct mwifiex_ie_types_wildcard_ssid_params)\t\\\n\t\t\t+ IEEE80211_MAX_SSID_LEN))\n\n/* Maximum memory needed for a mwifiex_scan_cmd_config with all TLVs at max */\n#define MAX_SCAN_CFG_ALLOC (sizeof(struct mwifiex_scan_cmd_config)        \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_num_probes)   \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_htcap)       \\\n\t\t\t\t+ CHAN_TLV_MAX_SIZE                 \\\n\t\t\t\t+ RATE_TLV_MAX_SIZE                 \\\n\t\t\t\t+ WILDCARD_SSID_TLV_MAX_SIZE)\n\n\nunion mwifiex_scan_cmd_config_tlv {\n\t/* Scan configuration (variable length) */\n\tstruct mwifiex_scan_cmd_config config;\n\t/* Max allocated block */\n\tu8 config_alloc_buf[MAX_SCAN_CFG_ALLOC];\n};\n\nenum cipher_suite {\n\tCIPHER_SUITE_TKIP,\n\tCIPHER_SUITE_CCMP,\n\tCIPHER_SUITE_MAX\n};\nstatic u8 mwifiex_wpa_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x50, 0xf2, 0x02 },\t/* TKIP */\n\t{ 0x00, 0x50, 0xf2, 0x04 },\t/* AES  */\n};\nstatic u8 mwifiex_rsn_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x0f, 0xac, 0x02 },\t/* TKIP */\n\t{ 0x00, 0x0f, 0xac, 0x04 },\t/* AES  */\n};\n\nstatic void\n_dbg_security_flags(int log_level, const char *func, const char *desc,\n\t\t    struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\t_mwifiex_dbg(priv->adapter, log_level,\n\t\t     \"info: %s: %s:\\twpa_ie=%#x wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s\\tEncMode=%#x privacy=%#x\\n\",\n\t\t     func, desc,\n\t\t     bss_desc->bcn_wpa_ie ?\n\t\t     bss_desc->bcn_wpa_ie->vend_hdr.element_id : 0,\n\t\t     bss_desc->bcn_rsn_ie ?\n\t\t     bss_desc->bcn_rsn_ie->ieee_hdr.element_id : 0,\n\t\t     priv->sec_info.wep_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa2_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.encryption_mode,\n\t\t     bss_desc->privacy);\n}\n#define dbg_security_flags(mask, desc, priv, bss_desc) \\\n\t_dbg_security_flags(MWIFIEX_DBG_##mask, desc, __func__, priv, bss_desc)\n\nstatic bool\nhas_ieee_hdr(struct ieee_types_generic *ie, u8 key)\n{\n\treturn (ie && ie->ieee_hdr.element_id == key);\n}\n\nstatic bool\nhas_vendor_hdr(struct ieee_types_vendor_specific *ie, u8 key)\n{\n\treturn (ie && ie->vend_hdr.element_id == key);\n}\n\n/*\n * This function parses a given IE for a given OUI.\n *\n * This is used to parse a WPA/RSN IE to find if it has\n * a given oui in PTK.\n */\nstatic u8\nmwifiex_search_oui_in_ie(struct ie_body *iebody, u8 *oui)\n{\n\tu8 count;\n\n\tcount = iebody->ptk_cnt[0];\n\n\t/* There could be multiple OUIs for PTK hence\n\t   1) Take the length.\n\t   2) Check all the OUIs for AES.\n\t   3) If one of them is AES then pass success. */\n\twhile (count) {\n\t\tif (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))\n\t\t\treturn MWIFIEX_OUI_PRESENT;\n\n\t\t--count;\n\t\tif (count)\n\t\t\tiebody = (struct ie_body *) ((u8 *) iebody +\n\t\t\t\t\t\tsizeof(iebody->ptk_body));\n\t}\n\n\tpr_debug(\"info: %s: OUI is not found in PTK\\n\", __func__);\n\treturn MWIFIEX_OUI_NOT_PRESENT;\n}\n\n/*\n * This function checks if a given OUI is present in a RSN IE.\n *\n * The function first checks if a RSN IE is present or not in the\n * BSS descriptor. It tries to locate the OUI only if such an IE is\n * present.\n */\nstatic u8\nmwifiex_is_rsn_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\tiebody = (struct ie_body *)\n\t\t\t (((u8 *) bss_desc->bcn_rsn_ie->data) +\n\t\t\t  RSN_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_rsn_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n/*\n * This function checks if a given OUI is present in a WPA IE.\n *\n * The function first checks if a WPA IE is present or not in the\n * BSS descriptor. It tries to locate the OUI only if such an IE is\n * present.\n */\nstatic u8\nmwifiex_is_wpa_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)) {\n\t\tiebody = (struct ie_body *)((u8 *)bss_desc->bcn_wpa_ie->data +\n\t\t\t\t\t    WPA_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_wpa_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n/*\n * This function compares two SSIDs and checks if they match.\n */\ns32\nmwifiex_ssid_cmp(struct cfg80211_ssid *ssid1, struct cfg80211_ssid *ssid2)\n{\n\tif (!ssid1 || !ssid2 || (ssid1->ssid_len != ssid2->ssid_len))\n\t\treturn -1;\n\treturn memcmp(ssid1->ssid, ssid2->ssid, ssid1->ssid_len);\n}\n\n/*\n * This function checks if wapi is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wapi(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wapi_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_wapi_ie, WLAN_EID_BSS_AC_ACCESS_DELAY))\n\t\treturn true;\n\treturn false;\n}\n\n/*\n * This function checks if driver is configured with no security mode and\n * scanned network is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_no_sec(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && !bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if static WEP is enabled in driver and scanned network\n * is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_static_wep(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if wpa is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wpa(struct mwifiex_private *priv,\n\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)\n\t   /*\n\t    * Privacy bit may NOT be set in some APs like\n\t    * LinkSys WRT54G && bss_desc->privacy\n\t    */\n\t ) {\n\t\tdbg_security_flags(INFO, \"WPA\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if wpa2 is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wpa2(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    priv->sec_info.wpa2_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\t/*\n\t\t * Privacy bit may NOT be set in some APs like\n\t\t * LinkSys WRT54G && bss_desc->privacy\n\t\t */\n\t\tdbg_security_flags(INFO, \"WAP2\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if adhoc AES is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_adhoc_aes(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if dynamic WEP is enabled in driver and scanned network\n * is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_dynamic_wep(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\tdbg_security_flags(INFO, \"dynamic\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if a scanned network is compatible with the driver\n * settings.\n *\n *   WEP     WPA    WPA2   ad-hoc encrypt                  Network\n * enabled enabled enabled  AES    mode   Privacy WPA WPA2 Compatible\n *    0       0       0      0     NONE      0     0   0   yes No security\n *    0       1       0      0      x        1x    1   x   yes WPA (disable\n *                                                         HT if no AES)\n *    0       0       1      0      x        1x    x   1   yes WPA2 (disable\n *                                                         HT if no AES)\n *    0       0       0      1     NONE      1     0   0   yes Ad-hoc AES\n *    1       0       0      0     NONE      1     0   0   yes Static WEP\n *                                                         (disable HT)\n *    0       0       0      0    !=NONE     1     0   0   yes Dynamic WEP\n *\n * Compatibility is not matched while roaming, except for mode.\n */\nstatic s32\nmwifiex_is_network_compatible(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_bssdescriptor *bss_desc, u32 mode)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tbss_desc->disable_11n = false;\n\n\t/* Don't check for compatibility if roaming */\n\tif (priv->media_connected &&\n\t    (priv->bss_mode == NL80211_IFTYPE_STATION) &&\n\t    (bss_desc->bss_mode == NL80211_IFTYPE_STATION))\n\t\treturn 0;\n\n\tif (priv->wps.session_enable) {\n\t\tmwifiex_dbg(adapter, IOCTL,\n\t\t\t    \"info: return success directly in WPS period\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->chan_sw_ie_present) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Don't connect to AP with WLAN_EID_CHANNEL_SWITCH\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_bss_wapi(priv, bss_desc)) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: return success for WAPI AP\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->bss_mode == mode) {\n\t\tif (mwifiex_is_bss_no_sec(priv, bss_desc)) {\n\t\t\t/* No security */\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_static_wep(priv, bss_desc)) {\n\t\t\t/* Static WEP enabled */\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Disable 11n in WEP mode.\\n\");\n\t\t\tbss_desc->disable_11n = true;\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa(priv, bss_desc)) {\n\t\t\t/* WPA enabled */\n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_wpa_oui_present(bss_desc,\n\t\t\t\t\t\t\t CIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_wpa_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa2(priv, bss_desc)) {\n\t\t\t/* WPA2 enabled */\n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_rsn_oui_present(bss_desc,\n\t\t\t\t\t\t\tCIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_rsn_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_adhoc_aes(priv, bss_desc)) {\n\t\t\t/* Ad-hoc AES enabled */\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_dynamic_wep(priv, bss_desc)) {\n\t\t\t/* Dynamic WEP enabled */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Security doesn't match */\n\t\tdbg_security_flags(ERROR, \"failed\", priv, bss_desc);\n\t\treturn -1;\n\t}\n\n\t/* Mode doesn't match */\n\treturn -1;\n}\n\n/*\n * This function creates a channel list for the driver to scan, based\n * on region/band information.\n *\n * This routine is used for any scan that is not provided with a\n * specific channel list to scan.\n */\nstatic int\nmwifiex_scan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t const struct mwifiex_user_scan_cfg\n\t\t\t\t\t\t\t*user_scan_in,\n\t\t\t\t struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t\t*scan_chan_list,\n\t\t\t\t u8 filtered_scan)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS) ; band++) {\n\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (user_scan_in &&\n\t\t\t    user_scan_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16) user_scan_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if ((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t\t (ch->flags & IEEE80211_CHAN_RADAR))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->active_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32) ch->hw_value;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (filtered_scan &&\n\t\t\t    !((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t      (ch->flags & IEEE80211_CHAN_RADAR)))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(adapter->specific_scan_time);\n\n\t\t\tchan_idx++;\n\t\t}\n\n\t}\n\treturn chan_idx;\n}\n\n/* This function creates a channel list tlv for bgscan config, based\n * on region/band information.\n */\nstatic int\nmwifiex_bgscan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t   const struct mwifiex_bg_scan_cfg\n\t\t\t\t\t\t*bgscan_cfg_in,\n\t\t\t\t   struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t*scan_chan_list)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS); band++) {\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (bgscan_cfg_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->\n\t\t\t\t\t\t    specific_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32)ch->hw_value;\n\t\t\tchan_idx++;\n\t\t}\n\t}\n\treturn chan_idx;\n}\n\n/* This function appends rate TLV to scan config command. */\nstatic int\nmwifiex_append_rate_tlv(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\tu8 radio)\n{\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES], *tlv_pos;\n\tu32 rates_size;\n\n\tmemset(rates, 0, sizeof(rates));\n\n\ttlv_pos = (u8 *)scan_cfg_out->tlv_buf + scan_cfg_out->tlv_buf_len;\n\n\tif (priv->scan_request)\n\t\trates_size = mwifiex_get_rates_from_cfg80211(priv, rates,\n\t\t\t\t\t\t\t     radio);\n\telse\n\t\trates_size = mwifiex_get_supported_rates(priv, rates);\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"info: SCAN_CMD: Rates size = %d\\n\",\n\t\trates_size);\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *)tlv_pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tscan_cfg_out->tlv_buf_len += sizeof(rates_tlv->header) + rates_size;\n\n\treturn rates_size;\n}\n\n/*\n * This function constructs and sends multiple scan config commands to\n * the firmware.\n *\n * Previous routines in the code flow have created a scan command configuration\n * with any requested TLVs.  This function splits the channel TLV into maximum\n * channels supported per scan lists and sends the portion of the channel TLV,\n * along with the other TLVs, to the firmware.\n */\nstatic int\nmwifiex_scan_channel_list(struct mwifiex_private *priv,\n\t\t\t  u32 max_chan_per_scan, u8 filtered_scan,\n\t\t\t  struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\t  struct mwifiex_ie_types_chan_list_param_set\n\t\t\t  *chan_tlv_out,\n\t\t\t  struct mwifiex_chan_scan_param_set *scan_chan_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct mwifiex_chan_scan_param_set *tmp_chan_list;\n\tstruct mwifiex_chan_scan_param_set *start_chan;\n\tu32 tlv_idx, rates_size, cmd_no;\n\tu32 total_scan_time;\n\tu32 done_early;\n\tu8 radio_type;\n\n\tif (!scan_cfg_out || !chan_tlv_out || !scan_chan_list) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"info: Scan: Null detect: %p, %p, %p\\n\",\n\t\t\t    scan_cfg_out, chan_tlv_out, scan_chan_list);\n\t\treturn -1;\n\t}\n\n\t/* Check csa channel expiry before preparing scan list */\n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tchan_tlv_out->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t/* Set the temp channel struct pointer to the start of the desired\n\t   list */\n\ttmp_chan_list = scan_chan_list;\n\n\t/* Loop through the desired channel list, sending a new firmware scan\n\t   commands for each max_chan_per_scan channels (or for 1,6,11\n\t   individually if configured accordingly) */\n\twhile (tmp_chan_list->chan_number) {\n\n\t\ttlv_idx = 0;\n\t\ttotal_scan_time = 0;\n\t\tradio_type = 0;\n\t\tchan_tlv_out->header.len = 0;\n\t\tstart_chan = tmp_chan_list;\n\t\tdone_early = false;\n\n\t\t/*\n\t\t * Construct the Channel TLV for the scan command.  Continue to\n\t\t * insert channel TLVs until:\n\t\t *   - the tlv_idx hits the maximum configured per scan command\n\t\t *   - the next channel to insert is 0 (end of desired channel\n\t\t *     list)\n\t\t *   - done_early is set (controlling individual scanning of\n\t\t *     1,6,11)\n\t\t */\n\t\twhile (tlv_idx < max_chan_per_scan &&\n\t\t       tmp_chan_list->chan_number && !done_early) {\n\n\t\t\tif (tmp_chan_list->chan_number == priv->csa_chan) {\n\t\t\t\ttmp_chan_list++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tradio_type = tmp_chan_list->radio_type;\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: Scan: Chan(%3d), Radio(%d),\\t\"\n\t\t\t\t    \"Mode(%d, %d), Dur(%d)\\n\",\n\t\t\t\t    tmp_chan_list->chan_number,\n\t\t\t\t    tmp_chan_list->radio_type,\n\t\t\t\t    tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_PASSIVE_SCAN,\n\t\t\t\t    (tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_DISABLE_CHAN_FILT) >> 1,\n\t\t\t\t    le16_to_cpu(tmp_chan_list->max_scan_time));\n\n\t\t\t/* Copy the current channel TLV to the command being\n\t\t\t   prepared */\n\t\t\tmemcpy(chan_tlv_out->chan_scan_param + tlv_idx,\n\t\t\t       tmp_chan_list,\n\t\t\t       sizeof(chan_tlv_out->chan_scan_param));\n\n\t\t\t/* Increment the TLV header length by the size\n\t\t\t   appended */\n\t\t\tle16_unaligned_add_cpu(&chan_tlv_out->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t\tchan_tlv_out->chan_scan_param));\n\n\t\t\t/*\n\t\t\t * The tlv buffer length is set to the number of bytes\n\t\t\t * of the between the channel tlv pointer and the start\n\t\t\t * of the tlv buffer.  This compensates for any TLVs\n\t\t\t * that were appended before the channel list.\n\t\t\t */\n\t\t\tscan_cfg_out->tlv_buf_len = (u32) ((u8 *) chan_tlv_out -\n\t\t\t\t\t\t\tscan_cfg_out->tlv_buf);\n\n\t\t\t/* Add the size of the channel tlv header and the data\n\t\t\t   length */\n\t\t\tscan_cfg_out->tlv_buf_len +=\n\t\t\t\t(sizeof(chan_tlv_out->header)\n\t\t\t\t + le16_to_cpu(chan_tlv_out->header.len));\n\n\t\t\t/* Increment the index to the channel tlv we are\n\t\t\t   constructing */\n\t\t\ttlv_idx++;\n\n\t\t\t/* Count the total scan time per command */\n\t\t\ttotal_scan_time +=\n\t\t\t\tle16_to_cpu(tmp_chan_list->max_scan_time);\n\n\t\t\tdone_early = false;\n\n\t\t\t/* Stop the loop if the *current* channel is in the\n\t\t\t   1,6,11 set and we are not filtering on a BSSID\n\t\t\t   or SSID. */\n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\n\t\t\t/* Increment the tmp pointer to the next channel to\n\t\t\t   be scanned */\n\t\t\ttmp_chan_list++;\n\n\t\t\t/* Stop the loop if the *next* channel is in the 1,6,11\n\t\t\t   set.  This will cause it to be the only channel\n\t\t\t   scanned on the next interation */\n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\t\t}\n\n\t\t/* The total scan time should be less than scan command timeout\n\t\t   value */\n\t\tif (total_scan_time > MWIFIEX_MAX_TOTAL_SCAN_TIME) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"total scan time %dms\\t\"\n\t\t\t\t    \"is over limit (%dms), scan skipped\\n\",\n\t\t\t\t    total_scan_time,\n\t\t\t\t    MWIFIEX_MAX_TOTAL_SCAN_TIME);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trates_size = mwifiex_append_rate_tlv(priv, scan_cfg_out,\n\t\t\t\t\t\t     radio_type);\n\n\t\tpriv->adapter->scan_channels = start_chan;\n\n\t\t/* Send the scan command to the firmware with the specified\n\t\t   cfg */\n\t\tif (priv->adapter->ext_scan)\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN_EXT;\n\t\telse\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN;\n\n\t\tret = mwifiex_send_cmd(priv, cmd_no, HostCmd_ACT_GEN_SET,\n\t\t\t\t       0, scan_cfg_out, false);\n\n\t\t/* rate IE is updated per scan command but same starting\n\t\t * pointer is used each time so that rate IE from earlier\n\t\t * scan_cfg_out->buf is overwritten with new one.\n\t\t */\n\t\tscan_cfg_out->tlv_buf_len -=\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + rates_size;\n\n\t\tif (ret) {\n\t\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * This function constructs a scan command configuration structure to use\n * in scan commands.\n *\n * Application layer or other functions can invoke network scanning\n * with a scan configuration supplied in a user scan configuration structure.\n * This structure is used as the basis of one or many scan command configuration\n * commands that are sent to the command processing module and eventually to the\n * firmware.\n *\n * This function creates a scan command configuration structure  based on the\n * following user supplied parameters (if present):\n *      - SSID filter\n *      - BSSID filter\n *      - Number of Probes to be sent\n *      - Channel list\n *\n * If the SSID or BSSID filter is not present, the filter is disabled/cleared.\n * If the number of probes is not set, adapter default setting is used.\n */\nstatic void\nmwifiex_config_scan(struct mwifiex_private *priv,\n\t\t    const struct mwifiex_user_scan_cfg *user_scan_in,\n\t\t    struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t    struct mwifiex_ie_types_chan_list_param_set **chan_list_out,\n\t\t    struct mwifiex_chan_scan_param_set *scan_chan_list,\n\t\t    u8 *max_chan_per_scan, u8 *filtered_scan,\n\t\t    u8 *scan_current_only)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_scan_chan_gap *chan_gap_tlv;\n\tstruct mwifiex_ie_types_random_mac *random_mac_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_bssid_list *bssid_tlv;\n\tu8 *tlv_pos;\n\tu32 num_probes;\n\tu32 ssid_len;\n\tu32 chan_idx;\n\tu32 scan_type;\n\tu16 scan_dur;\n\tu8 channel;\n\tu8 radio_type;\n\tint i;\n\tu8 ssid_filter;\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_bss_mode *bss_mode;\n\tconst u8 zero_mac[6] = {0, 0, 0, 0, 0, 0};\n\n\t/* The tlv_buf_len is calculated for each scan command.  The TLVs added\n\t   in this routine will be preserved since the routine that sends the\n\t   command will append channelTLVs at *chan_list_out.  The difference\n\t   between the *chan_list_out and the tlv_buf start will be used to\n\t   calculate the size of anything we add in this routine. */\n\tscan_cfg_out->tlv_buf_len = 0;\n\n\t/* Running tlv pointer.  Assigned to chan_list_out at end of function\n\t   so later routines know where channels can be added to the command\n\t   buf */\n\ttlv_pos = scan_cfg_out->tlv_buf;\n\n\t/* Initialize the scan as un-filtered; the flag is later set to TRUE\n\t   below if a SSID or BSSID filter is sent in the command */\n\t*filtered_scan = false;\n\n\t/* Initialize the scan as not being only on the current channel.  If\n\t   the channel list is customized, only contains one channel, and is\n\t   the active channel, this is set true and data flow is not halted. */\n\t*scan_current_only = false;\n\n\tif (user_scan_in) {\n\t\tu8 tmpaddr[ETH_ALEN];\n\n\t\t/* Default the ssid_filter flag to TRUE, set false under\n\t\t   certain wildcard conditions and qualified by the existence\n\t\t   of an SSID list before marking the scan as filtered */\n\t\tssid_filter = true;\n\n\t\t/* Set the BSS type scan filter, use Adapter setting if\n\t\t   unset */\n\t\tscan_cfg_out->bss_mode =\n\t\t\t(u8)(user_scan_in->bss_mode ?: adapter->scan_mode);\n\n\t\t/* Set the number of probes to send, use Adapter setting\n\t\t   if unset */\n\t\tnum_probes = user_scan_in->num_probes ?: adapter->scan_probes;\n\n\t\t/*\n\t\t * Set the BSSID filter to the incoming configuration,\n\t\t * if non-zero.  If not set, it will remain disabled\n\t\t * (all zeros).\n\t\t */\n\t\tmemcpy(scan_cfg_out->specific_bssid,\n\t\t       user_scan_in->specific_bssid,\n\t\t       sizeof(scan_cfg_out->specific_bssid));\n\n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\n\t\tif (adapter->ext_scan &&\n\t\t    !is_zero_ether_addr(tmpaddr)) {\n\t\t\tbssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_bssid_list *)tlv_pos;\n\t\t\tbssid_tlv->header.type = cpu_to_le16(TLV_TYPE_BSSID);\n\t\t\tbssid_tlv->header.len = cpu_to_le16(ETH_ALEN);\n\t\t\tmemcpy(bssid_tlv->bssid, user_scan_in->specific_bssid,\n\t\t\t       ETH_ALEN);\n\t\t\ttlv_pos += sizeof(struct mwifiex_ie_types_bssid_list);\n\t\t}\n\n\t\tfor (i = 0; i < user_scan_in->num_ssids; i++) {\n\t\t\tssid_len = user_scan_in->ssid_list[i].ssid_len;\n\n\t\t\twildcard_ssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)\n\t\t\t\ttlv_pos;\n\t\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16) (ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t\t/*\n\t\t\t * max_ssid_length = 0 tells firmware to perform\n\t\t\t * specific scan for the SSID filled, whereas\n\t\t\t * max_ssid_length = IEEE80211_MAX_SSID_LEN is for\n\t\t\t * wildcard scan.\n\t\t\t */\n\t\t\tif (ssid_len)\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\t\telse\n\t\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\t\tif (!memcmp(user_scan_in->ssid_list[i].ssid,\n\t\t\t\t    \"DIRECT-\", 7))\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0xfe;\n\n\t\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t\t       user_scan_in->ssid_list[i].ssid, ssid_len);\n\n\t\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: ssid[%d]: %s, %d\\n\",\n\t\t\t\t    i, wildcard_ssid_tlv->ssid,\n\t\t\t\t    wildcard_ssid_tlv->max_ssid_length);\n\n\t\t\t/* Empty wildcard ssid with a maxlen will match many or\n\t\t\t   potentially all SSIDs (maxlen == 32), therefore do\n\t\t\t   not treat the scan as\n\t\t\t   filtered. */\n\t\t\tif (!ssid_len && wildcard_ssid_tlv->max_ssid_length)\n\t\t\t\tssid_filter = false;\n\t\t}\n\n\t\t/*\n\t\t *  The default number of channels sent in the command is low to\n\t\t *  ensure the response buffer from the firmware does not\n\t\t *  truncate scan results.  That is not an issue with an SSID\n\t\t *  or BSSID filter applied to the scan results in the firmware.\n\t\t */\n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\t\tif ((i && ssid_filter) ||\n\t\t    !is_zero_ether_addr(tmpaddr))\n\t\t\t*filtered_scan = true;\n\n\t\tif (user_scan_in->scan_chan_gap) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: channel gap = %d\\n\",\n\t\t\t\t    user_scan_in->scan_chan_gap);\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\n\t\t\tchan_gap_tlv = (void *)tlv_pos;\n\t\t\tchan_gap_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_SCAN_CHANNEL_GAP);\n\t\t\tchan_gap_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(chan_gap_tlv->chan_gap));\n\t\t\tchan_gap_tlv->chan_gap =\n\t\t\t\t     cpu_to_le16((user_scan_in->scan_chan_gap));\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_scan_chan_gap);\n\t\t}\n\n\t\tif (!ether_addr_equal(user_scan_in->random_mac, zero_mac)) {\n\t\t\trandom_mac_tlv = (void *)tlv_pos;\n\t\t\trandom_mac_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_RANDOM_MAC);\n\t\t\trandom_mac_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(random_mac_tlv->mac));\n\t\t\tether_addr_copy(random_mac_tlv->mac,\n\t\t\t\t\tuser_scan_in->random_mac);\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_random_mac);\n\t\t}\n\t} else {\n\t\tscan_cfg_out->bss_mode = (u8) adapter->scan_mode;\n\t\tnum_probes = adapter->scan_probes;\n\t}\n\n\t/*\n\t *  If a specific BSSID or SSID is used, the number of channels in the\n\t *  scan command will be increased to the absolute maximum.\n\t */\n\tif (*filtered_scan) {\n\t\t*max_chan_per_scan = MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\t} else {\n\t\tif (!priv->media_connected)\n\t\t\t*max_chan_per_scan = MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD;\n\t\telse\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_DEF_CHANNELS_PER_SCAN_CMD / 2;\n\t}\n\n\tif (adapter->ext_scan) {\n\t\tbss_mode = (struct mwifiex_ie_types_bss_mode *)tlv_pos;\n\t\tbss_mode->header.type = cpu_to_le16(TLV_TYPE_BSS_MODE);\n\t\tbss_mode->header.len = cpu_to_le16(sizeof(bss_mode->bss_mode));\n\t\tbss_mode->bss_mode = scan_cfg_out->bss_mode;\n\t\ttlv_pos += sizeof(bss_mode->header) +\n\t\t\t   le16_to_cpu(bss_mode->header.len);\n\t}\n\n\t/* If the input config or adapter has the number of Probes set,\n\t   add tlv */\n\tif (num_probes) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: scan: num_probes = %d\\n\",\n\t\t\t    num_probes);\n\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *) tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16) num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN)) {\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) tlv_pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type =\n\t\t\tmwifiex_band_to_radio_type(priv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\t\ttlv_pos += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_SCAN, &tlv_pos);\n\n\t/*\n\t * Set the output for the channel TLV to the address in the tlv buffer\n\t *   past any TLVs that were added in this function (SSID, num_probes).\n\t *   Channel TLVs will be added past this for each scan command,\n\t *   preserving the TLVs that were previously added.\n\t */\n\t*chan_list_out =\n\t\t(struct mwifiex_ie_types_chan_list_param_set *) tlv_pos;\n\n\tif (user_scan_in && user_scan_in->chan_list[0].chan_number) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Using supplied channel list\\n\");\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_USER_SCAN_CHAN_MAX &&\n\t\t     user_scan_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\n\t\t\tchannel = user_scan_in->chan_list[chan_idx].chan_number;\n\t\t\tscan_chan_list[chan_idx].chan_number = channel;\n\n\t\t\tradio_type =\n\t\t\t\tuser_scan_in->chan_list[chan_idx].radio_type;\n\t\t\tscan_chan_list[chan_idx].radio_type = radio_type;\n\n\t\t\tscan_type = user_scan_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (user_scan_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16) user_scan_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\t\tscan_dur = adapter->passive_scan_time;\n\t\t\t\telse if (*filtered_scan)\n\t\t\t\t\tscan_dur = adapter->specific_scan_time;\n\t\t\t\telse\n\t\t\t\t\tscan_dur = adapter->active_scan_time;\n\t\t\t}\n\n\t\t\tscan_chan_list[chan_idx].min_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t}\n\n\t\t/* Check if we are only scanning the current channel */\n\t\tif ((chan_idx == 1) &&\n\t\t    (user_scan_in->chan_list[0].chan_number ==\n\t\t     priv->curr_bss_params.bss_descriptor.channel)) {\n\t\t\t*scan_current_only = true;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Scan: Scanning current channel only\\n\");\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Creating full region channel list\\n\");\n\t\tmwifiex_scan_create_channel_list(priv, user_scan_in,\n\t\t\t\t\t\t scan_chan_list,\n\t\t\t\t\t\t *filtered_scan);\n\t}\n\n}\n\n/*\n * This function inspects the scan response buffer for pointers to\n * expected TLVs.\n *\n * TLVs can be included at the end of the scan response BSS information.\n *\n * Data in the buffer is parsed pointers to TLVs that can potentially\n * be passed back in the response.\n */\nstatic void\nmwifiex_ret_802_11_scan_get_tlv_ptrs(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_ie_types_data *tlv,\n\t\t\t\t     u32 tlv_buf_size, u32 req_tlv_type,\n\t\t\t\t     struct mwifiex_ie_types_data **tlv_data)\n{\n\tstruct mwifiex_ie_types_data *current_tlv;\n\tu32 tlv_buf_left;\n\tu32 tlv_type;\n\tu32 tlv_len;\n\n\tcurrent_tlv = tlv;\n\ttlv_buf_left = tlv_buf_size;\n\t*tlv_data = NULL;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: tlv_buf_size = %d\\n\",\n\t\t    tlv_buf_size);\n\n\twhile (tlv_buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\n\t\ttlv_type = le16_to_cpu(current_tlv->header.type);\n\t\ttlv_len = le16_to_cpu(current_tlv->header.len);\n\n\t\tif (sizeof(tlv->header) + tlv_len > tlv_buf_left) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SCAN_RESP: TLV buffer corrupt\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req_tlv_type == tlv_type) {\n\t\t\tswitch (tlv_type) {\n\t\t\tcase TLV_TYPE_TSFTIMESTAMP:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: TSF\\t\"\n\t\t\t\t\t    \"timestamp TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tcase TLV_TYPE_CHANNELBANDLIST:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: channel\\t\"\n\t\t\t\t\t    \"band list TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SCAN_RESP: unhandled TLV = %d\\n\",\n\t\t\t\t\t    tlv_type);\n\t\t\t\t/* Give up, this seems corrupted */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (*tlv_data)\n\t\t\tbreak;\n\n\n\t\ttlv_buf_left -= (sizeof(tlv->header) + tlv_len);\n\t\tcurrent_tlv =\n\t\t\t(struct mwifiex_ie_types_data *) (current_tlv->data +\n\t\t\t\t\t\t\t  tlv_len);\n\n\t}\t\t\t/* while */\n}\n\n/*\n * This function parses provided beacon buffer and updates\n * respective fields in bss descriptor structure.\n */\nint mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_bssdescriptor *bss_entry)\n{\n\tint ret = 0;\n\tu8 element_id;\n\tstruct ieee_types_fh_param_set *fh_param_set;\n\tstruct ieee_types_ds_param_set *ds_param_set;\n\tstruct ieee_types_cf_param_set *cf_param_set;\n\tstruct ieee_types_ibss_param_set *ibss_param_set;\n\tu8 *current_ptr;\n\tu8 *rate;\n\tu8 element_len;\n\tu16 total_ie_len;\n\tu8 bytes_to_copy;\n\tu8 rate_size;\n\tu8 found_data_rate_ie;\n\tu32 bytes_left;\n\tstruct ieee_types_vendor_specific *vendor_ie;\n\tconst u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };\n\tconst u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };\n\n\tfound_data_rate_ie = false;\n\trate_size = 0;\n\tcurrent_ptr = bss_entry->beacon_buf;\n\tbytes_left = bss_entry->beacon_buf_size;\n\n\t/* Process variable IE */\n\twhile (bytes_left >= 2) {\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\ttotal_ie_len = element_len + sizeof(struct ieee_types_header);\n\n\t\tif (bytes_left < total_ie_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"err: InterpretIE: in processing\\t\"\n\t\t\t\t    \"IE, bytes left < IE length\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tif (element_len > IEEE80211_MAX_SSID_LEN)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->ssid.ssid_len = element_len;\n\t\t\tmemcpy(bss_entry->ssid.ssid, (current_ptr + 2),\n\t\t\t       element_len);\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: ssid: %-32s\\n\",\n\t\t\t\t    bss_entry->ssid.ssid);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\t\tif (element_len > MWIFIEX_SUPPORTED_RATES)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(bss_entry->data_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\tmemcpy(bss_entry->supported_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\trate_size = element_len;\n\t\t\tfound_data_rate_ie = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*fh_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tfh_param_set =\n\t\t\t\t(struct ieee_types_fh_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->phy_param_set.fh_param_set,\n\t\t\t       fh_param_set,\n\t\t\t       sizeof(struct ieee_types_fh_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ds_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tds_param_set =\n\t\t\t\t(struct ieee_types_ds_param_set *) current_ptr;\n\n\t\t\tbss_entry->channel = ds_param_set->current_chan;\n\n\t\t\tmemcpy(&bss_entry->phy_param_set.ds_param_set,\n\t\t\t       ds_param_set,\n\t\t\t       sizeof(struct ieee_types_ds_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*cf_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tcf_param_set =\n\t\t\t\t(struct ieee_types_cf_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.cf_param_set,\n\t\t\t       cf_param_set,\n\t\t\t       sizeof(struct ieee_types_cf_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ibss_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tibss_param_set =\n\t\t\t\t(struct ieee_types_ibss_param_set *)\n\t\t\t\tcurrent_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.ibss_param_set,\n\t\t\t       ibss_param_set,\n\t\t\t       sizeof(struct ieee_types_ibss_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->erp_flags = *(current_ptr + 2);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->local_constraint = *(current_ptr + 2);\n\t\t\tbss_entry->sensed_11h = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\t\tbss_entry->chan_sw_ie_present = true;\n\t\t\t/* fall through */\n\t\tcase WLAN_EID_PWR_CAPABILITY:\n\t\tcase WLAN_EID_TPC_REPORT:\n\t\tcase WLAN_EID_QUIET:\n\t\t\tbss_entry->sensed_11h = true;\n\t\t    break;\n\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\t/*\n\t\t\t * Only process extended supported rate\n\t\t\t * if data rate is already found.\n\t\t\t * Data rate IE should come before\n\t\t\t * extended supported rate IE\n\t\t\t */\n\t\t\tif (found_data_rate_ie) {\n\t\t\t\tif ((element_len + rate_size) >\n\t\t\t\t    MWIFIEX_SUPPORTED_RATES)\n\t\t\t\t\tbytes_to_copy =\n\t\t\t\t\t\t(MWIFIEX_SUPPORTED_RATES -\n\t\t\t\t\t\t rate_size);\n\t\t\t\telse\n\t\t\t\t\tbytes_to_copy = element_len;\n\n\t\t\t\trate = (u8 *) bss_entry->data_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\n\t\t\t\trate = (u8 *) bss_entry->supported_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tvendor_ie = (struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\n\t\t\t/* 802.11 requires at least 3-byte OUI. */\n\t\t\tif (element_len < sizeof(vendor_ie->vend_hdr.oui.oui))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Not long enough for a match? Skip it. */\n\t\t\tif (element_len < sizeof(wpa_oui))\n\t\t\t\tbreak;\n\n\t\t\tif (!memcmp(&vendor_ie->vend_hdr.oui, wpa_oui,\n\t\t\t\t    sizeof(wpa_oui))) {\n\t\t\t\tbss_entry->bcn_wpa_ie =\n\t\t\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\t\t\t\tbss_entry->wpa_offset = (u16)\n\t\t\t\t\t(current_ptr - bss_entry->beacon_buf);\n\t\t\t} else if (!memcmp(&vendor_ie->vend_hdr.oui, wmm_oui,\n\t\t\t\t    sizeof(wmm_oui))) {\n\t\t\t\tif (total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_parameter) ||\n\t\t\t\t    total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_info))\n\t\t\t\t\t/*\n\t\t\t\t\t * Only accept and copy the WMM IE if\n\t\t\t\t\t * it matches the size expected for the\n\t\t\t\t\t * WMM Info IE or the WMM Parameter IE.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy((u8 *) &bss_entry->wmm_ie,\n\t\t\t\t\t       current_ptr, total_ie_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tbss_entry->bcn_rsn_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->rsn_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_AC_ACCESS_DELAY:\n\t\t\tbss_entry->bcn_wapi_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->wapi_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tbss_entry->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t\t\t(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_cap_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\t\tbss_entry->bcn_ht_oper =\n\t\t\t\t(struct ieee80211_ht_operation *)(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_info_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tbss_entry->disable_11ac = false;\n\t\t\tbss_entry->bcn_vht_cap =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_cap_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_cap -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbss_entry->bcn_vht_oper =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_info_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_oper -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_COEX_2040:\n\t\t\tbss_entry->bcn_bss_co_2040 = current_ptr;\n\t\t\tbss_entry->bss_co_2040_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tbss_entry->bcn_ext_cap = current_ptr;\n\t\t\tbss_entry->ext_cap_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_OPMODE_NOTIF:\n\t\t\tbss_entry->oper_mode = (void *)current_ptr;\n\t\t\tbss_entry->oper_mode_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->oper_mode -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += total_ie_len;\n\t\tbytes_left -= total_ie_len;\n\n\t}\t/* while (bytes_left > 2) */\n\treturn ret;\n}\n\n/*\n * This function converts radio type scan parameter to a band configuration\n * to be used in join command.\n */\nstatic u8\nmwifiex_radio_type_to_band(u8 radio_type)\n{\n\tswitch (radio_type) {\n\tcase HostCmd_SCAN_RADIO_TYPE_A:\n\t\treturn BAND_A;\n\tcase HostCmd_SCAN_RADIO_TYPE_BG:\n\tdefault:\n\t\treturn BAND_G;\n\t}\n}\n\n/*\n * This is an internal function used to start a scan based on an input\n * configuration.\n *\n * This uses the input user scan configuration information when provided in\n * order to send the appropriate scan commands to firmware to populate or\n * update the internal driver scan table.\n */\nint mwifiex_scan_networks(struct mwifiex_private *priv,\n\t\t\t  const struct mwifiex_user_scan_cfg *user_scan_in)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tunion mwifiex_scan_cmd_config_tlv *scan_cfg_out;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_out;\n\tstruct mwifiex_chan_scan_param_set *scan_chan_list;\n\tu8 filtered_scan;\n\tu8 scan_current_chan_only;\n\tu8 max_chan_per_scan;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags) ||\n\t    test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Ignore scan. Card removed or firmware in bad state\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\tadapter->scan_processing = true;\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\tscan_cfg_out = kzalloc(sizeof(union mwifiex_scan_cmd_config_tlv),\n\t\t\t       GFP_KERNEL);\n\tif (!scan_cfg_out) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tscan_chan_list = kcalloc(MWIFIEX_USER_SCAN_CHAN_MAX,\n\t\t\t\t sizeof(struct mwifiex_chan_scan_param_set),\n\t\t\t\t GFP_KERNEL);\n\tif (!scan_chan_list) {\n\t\tkfree(scan_cfg_out);\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmwifiex_config_scan(priv, user_scan_in, &scan_cfg_out->config,\n\t\t\t    &chan_list_out, scan_chan_list, &max_chan_per_scan,\n\t\t\t    &filtered_scan, &scan_current_chan_only);\n\n\tret = mwifiex_scan_channel_list(priv, max_chan_per_scan, filtered_scan,\n\t\t\t\t\t&scan_cfg_out->config, chan_list_out,\n\t\t\t\t\tscan_chan_list);\n\n\t/* Get scan command from scan_pending_q and put to cmd_pending_q */\n\tif (!ret) {\n\t\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\t\tif (!list_empty(&adapter->scan_pending_q)) {\n\t\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\t\tlist_del(&cmd_node->list);\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\n\t\t\t/* Perform internal scan synchronously */\n\t\t\tif (!priv->scan_request) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"wait internal scan\\n\");\n\t\t\t\tmwifiex_wait_queue_complete(adapter, cmd_node);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t}\n\t}\n\n\tkfree(scan_cfg_out);\n\tkfree(scan_chan_list);\ndone:\n\tif (ret) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t}\n\treturn ret;\n}\n\n/*\n * This function prepares a scan command to be sent to the firmware.\n *\n * This uses the scan command configuration sent to the command processing\n * module in command preparation stage to configure a scan command structure\n * to send to firmware.\n *\n * The fixed fields specifying the BSS type and BSSID filters as well as a\n * variable number/length of TLVs are sent in the command to firmware.\n *\n * Preparation also includes -\n *      - Setting command ID, and proper size\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_scan(struct host_cmd_ds_command *cmd,\n\t\t\t    struct mwifiex_scan_cmd_config *scan_cfg)\n{\n\tstruct host_cmd_ds_802_11_scan *scan_cmd = &cmd->params.scan;\n\n\t/* Set fixed field variables in scan command */\n\tscan_cmd->bss_mode = scan_cfg->bss_mode;\n\tmemcpy(scan_cmd->bssid, scan_cfg->specific_bssid,\n\t       sizeof(scan_cmd->bssid));\n\tmemcpy(scan_cmd->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN);\n\n\t/* Size is equal to the sizeof(fixed portions) + the TLV len + header */\n\tcmd->size = cpu_to_le16((u16) (sizeof(scan_cmd->bss_mode)\n\t\t\t\t\t  + sizeof(scan_cmd->bssid)\n\t\t\t\t\t  + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n/*\n * This function checks compatibility of requested network with current\n * driver settings.\n */\nint mwifiex_check_network_compatibility(struct mwifiex_private *priv,\n\t\t\t\t\tstruct mwifiex_bssdescriptor *bss_desc)\n{\n\tint ret = -1;\n\n\tif (!bss_desc)\n\t\treturn -1;\n\n\tif ((mwifiex_get_cfp(priv, (u8) bss_desc->bss_band,\n\t\t\t     (u16) bss_desc->channel, 0))) {\n\t\tswitch (priv->bss_mode) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tret = mwifiex_is_network_compatible(priv, bss_desc,\n\t\t\t\t\t\t\t    priv->bss_mode);\n\t\t\tif (ret)\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Incompatible network settings\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function checks if SSID string contains all zeroes or length is zero */\nstatic bool mwifiex_is_hidden_ssid(struct cfg80211_ssid *ssid)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ssid->ssid_len; idx++) {\n\t\tif (ssid->ssid[idx])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This function checks if any hidden SSID found in passive scan channels\n * and save those channels for specific SSID active scan\n */\nstatic int mwifiex_save_hidden_ssid_channels(struct mwifiex_private *priv,\n\t\t\t\t\t     struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\tint chid;\n\n\t/* Allocate and fill new bss descriptor */\n\tbss_desc = kzalloc(sizeof(*bss_desc), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tif (mwifiex_is_hidden_ssid(&bss_desc->ssid)) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"found hidden SSID\\n\");\n\t\tfor (chid = 0 ; chid < MWIFIEX_USER_SCAN_CHAN_MAX; chid++) {\n\t\t\tif (priv->hidden_chan[chid].chan_number ==\n\t\t\t    bss->channel->hw_value)\n\t\t\t\tbreak;\n\n\t\t\tif (!priv->hidden_chan[chid].chan_number) {\n\t\t\t\tpriv->hidden_chan[chid].chan_number =\n\t\t\t\t\tbss->channel->hw_value;\n\t\t\t\tpriv->hidden_chan[chid].radio_type =\n\t\t\t\t\tbss->channel->band;\n\t\t\t\tpriv->hidden_chan[chid].scan_type =\n\t\t\t\t\tMWIFIEX_SCAN_TYPE_ACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\t/* beacon_ie buffer was allocated in function\n\t * mwifiex_fill_new_bss_desc(). Free it now.\n\t */\n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int mwifiex_update_curr_bss_params(struct mwifiex_private *priv,\n\t\t\t\t\t  struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\n\t/* Allocate and fill new bss descriptor */\n\tbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tspin_lock_bh(&priv->curr_bcn_buf_lock);\n\t/* Make a copy of current BSSID descriptor */\n\tmemcpy(&priv->curr_bss_params.bss_descriptor, bss_desc,\n\t       sizeof(priv->curr_bss_params.bss_descriptor));\n\n\t/* The contents of beacon_ie will be copied to its own buffer\n\t * in mwifiex_save_curr_bcn()\n\t */\n\tmwifiex_save_curr_bcn(priv);\n\tspin_unlock_bh(&priv->curr_bcn_buf_lock);\n\ndone:\n\t/* beacon_ie buffer was allocated in function\n\t * mwifiex_fill_new_bss_desc(). Free it now.\n\t */\n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int\nmwifiex_parse_single_response_buf(struct mwifiex_private *priv, u8 **bss_info,\n\t\t\t\t  u32 *bytes_left, u64 fw_tsf, u8 *radio_type,\n\t\t\t\t  bool ext_scan, s32 rssi_val)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_chan_freq_power *cfp;\n\tstruct cfg80211_bss *bss;\n\tu8 bssid[ETH_ALEN];\n\ts32 rssi;\n\tconst u8 *ie_buf;\n\tsize_t ie_len;\n\tu16 channel = 0;\n\tu16 beacon_size = 0;\n\tu32 curr_bcn_bytes;\n\tu32 freq;\n\tu16 beacon_period;\n\tu16 cap_info_bitmap;\n\tu8 *current_ptr;\n\tu64 timestamp;\n\tstruct mwifiex_fixed_bcn_param *bcn_param;\n\tstruct mwifiex_bss_priv *bss_priv;\n\n\tif (*bytes_left >= sizeof(beacon_size)) {\n\t\t/* Extract & convert beacon size from command buffer */\n\t\tbeacon_size = get_unaligned_le16((*bss_info));\n\t\t*bytes_left -= sizeof(beacon_size);\n\t\t*bss_info += sizeof(beacon_size);\n\t}\n\n\tif (!beacon_size || beacon_size > *bytes_left) {\n\t\t*bss_info += *bytes_left;\n\t\t*bytes_left = 0;\n\t\treturn -EFAULT;\n\t}\n\n\t/* Initialize the current working beacon pointer for this BSS\n\t * iteration\n\t */\n\tcurrent_ptr = *bss_info;\n\n\t/* Advance the return beacon pointer past the current beacon */\n\t*bss_info += beacon_size;\n\t*bytes_left -= beacon_size;\n\n\tcurr_bcn_bytes = beacon_size;\n\n\t/* First 5 fields are bssid, RSSI(for legacy scan only),\n\t * time stamp, beacon interval, and capability information\n\t */\n\tif (curr_bcn_bytes < ETH_ALEN + sizeof(u8) +\n\t    sizeof(struct mwifiex_fixed_bcn_param)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"InterpretIE: not enough bytes left\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(bssid, current_ptr, ETH_ALEN);\n\tcurrent_ptr += ETH_ALEN;\n\tcurr_bcn_bytes -= ETH_ALEN;\n\n\tif (!ext_scan) {\n\t\trssi = (s32) *current_ptr;\n\t\trssi = (-rssi) * 100;\t\t/* Convert dBm to mBm */\n\t\tcurrent_ptr += sizeof(u8);\n\t\tcurr_bcn_bytes -= sizeof(u8);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t} else {\n\t\trssi = rssi_val;\n\t}\n\n\tbcn_param = (struct mwifiex_fixed_bcn_param *)current_ptr;\n\tcurrent_ptr += sizeof(*bcn_param);\n\tcurr_bcn_bytes -= sizeof(*bcn_param);\n\n\ttimestamp = le64_to_cpu(bcn_param->timestamp);\n\tbeacon_period = le16_to_cpu(bcn_param->beacon_period);\n\n\tcap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: capabilities=0x%X\\n\",\n\t\t    cap_info_bitmap);\n\n\t/* Rest of the current buffer are IE's */\n\tie_buf = current_ptr;\n\tie_len = curr_bcn_bytes;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: IELength for this AP = %d\\n\",\n\t\t    curr_bcn_bytes);\n\n\twhile (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {\n\t\tu8 element_id, element_len;\n\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\tif (curr_bcn_bytes < element_len +\n\t\t\t\tsizeof(struct ieee_types_header)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: bytes left < IE length\\n\", __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (element_id == WLAN_EID_DS_PARAMS) {\n\t\t\tchannel = *(current_ptr +\n\t\t\t\t    sizeof(struct ieee_types_header));\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += element_len + sizeof(struct ieee_types_header);\n\t\tcurr_bcn_bytes -= element_len +\n\t\t\t\t\tsizeof(struct ieee_types_header);\n\t}\n\n\tif (channel) {\n\t\tstruct ieee80211_channel *chan;\n\t\tu8 band;\n\n\t\t/* Skip entry if on csa closed channel */\n\t\tif (channel == priv->csa_chan) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"Dropping entry on csa closed channel\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tband = BAND_G;\n\t\tif (radio_type)\n\t\t\tband = mwifiex_radio_type_to_band(*radio_type &\n\t\t\t\t\t\t\t  (BIT(0) | BIT(1)));\n\n\t\tcfp = mwifiex_get_cfp(priv, band, channel, 0);\n\n\t\tfreq = cfp ? cfp->freq : 0;\n\n\t\tchan = ieee80211_get_channel(priv->wdev.wiphy, freq);\n\n\t\tif (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\tbss = cfg80211_inform_bss(priv->wdev.wiphy,\n\t\t\t\t\t    chan, CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t    bssid, timestamp,\n\t\t\t\t\t    cap_info_bitmap, beacon_period,\n\t\t\t\t\t    ie_buf, ie_len, rssi, GFP_KERNEL);\n\t\t\tif (bss) {\n\t\t\t\tbss_priv = (struct mwifiex_bss_priv *)bss->priv;\n\t\t\t\tbss_priv->band = band;\n\t\t\t\tbss_priv->fw_tsf = fw_tsf;\n\t\t\t\tif (priv->media_connected &&\n\t\t\t\t    !memcmp(bssid, priv->curr_bss_params.\n\t\t\t\t\t    bss_descriptor.mac_address,\n\t\t\t\t\t    ETH_ALEN))\n\t\t\t\t\tmwifiex_update_curr_bss_params(priv,\n\t\t\t\t\t\t\t\t       bss);\n\n\t\t\t\tif ((chan->flags & IEEE80211_CHAN_RADAR) ||\n\t\t\t\t    (chan->flags & IEEE80211_CHAN_NO_IR)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"radar or passive channel %d\\n\",\n\t\t\t\t\t\t    channel);\n\t\t\t\t\tmwifiex_save_hidden_ssid_channels(priv,\n\t\t\t\t\t\t\t\t\t  bss);\n\t\t\t\t}\n\n\t\t\t\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, WARN, \"missing BSS channel IE\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_complete_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tadapter->survey_idx = 0;\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tadapter->cmd_wait_q.status = 0;\n\t\tif (!priv->scan_request) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"complete internal scan\\n\");\n\t\t\tmwifiex_complete_cmd(adapter, adapter->curr_cmd);\n\t\t}\n\t}\n}\n\n/* This function checks if any hidden SSID found in passive scan channels\n * and do specific SSID active scan for those channels\n */\nstatic int\nmwifiex_active_scan_req_for_passive_chan(struct mwifiex_private *priv)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 id = 0;\n\tstruct mwifiex_user_scan_cfg  *user_scan_cfg;\n\n\tif (adapter->active_scan_triggered || !priv->scan_request ||\n\t    priv->scan_aborting) {\n\t\tadapter->active_scan_triggered = false;\n\t\treturn 0;\n\t}\n\n\tif (!priv->hidden_chan[0].chan_number) {\n\t\tmwifiex_dbg(adapter, INFO, \"No BSS with hidden SSID found on DFS channels\\n\");\n\t\treturn 0;\n\t}\n\tuser_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);\n\n\tif (!user_scan_cfg)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < MWIFIEX_USER_SCAN_CHAN_MAX; id++) {\n\t\tif (!priv->hidden_chan[id].chan_number)\n\t\t\tbreak;\n\t\tmemcpy(&user_scan_cfg->chan_list[id],\n\t\t       &priv->hidden_chan[id],\n\t\t       sizeof(struct mwifiex_user_scan_chan));\n\t}\n\n\tadapter->active_scan_triggered = true;\n\tif (priv->scan_request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tether_addr_copy(user_scan_cfg->random_mac,\n\t\t\t\tpriv->scan_request->mac_addr);\n\tuser_scan_cfg->num_ssids = priv->scan_request->n_ssids;\n\tuser_scan_cfg->ssid_list = priv->scan_request->ssids;\n\n\tret = mwifiex_scan_networks(priv, user_scan_cfg);\n\tkfree(user_scan_cfg);\n\n\tmemset(&priv->hidden_chan, 0, sizeof(priv->hidden_chan));\n\n\tif (ret) {\n\t\tdev_err(priv->adapter->dev, \"scan failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nstatic void mwifiex_check_next_scan_command(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tmwifiex_active_scan_req_for_passive_chan(priv);\n\n\t\tif (!adapter->ext_scan)\n\t\t\tmwifiex_complete_scan(priv);\n\n\t\tif (priv->scan_request) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: notifying scan done\\n\");\n\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\tpriv->scan_request = NULL;\n\t\t\tpriv->scan_aborting = false;\n\t\t} else {\n\t\t\tpriv->scan_aborting = false;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t}\n\t} else if ((priv->scan_aborting && !priv->scan_request) ||\n\t\t   priv->scan_block) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tif (!adapter->active_scan_triggered) {\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t} else {\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Get scan command from scan_pending_q and put to\n\t\t * cmd_pending_q\n\t\t */\n\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\tlist_del(&cmd_node->list);\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t}\n\n\treturn;\n}\n\nvoid mwifiex_cancel_scan(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\tif (adapter->scan_processing) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (!priv)\n\t\t\t\tcontinue;\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * This function handles the command response of scan.\n *\n * The response buffer for the scan command has the following\n * memory layout:\n *\n *      .-------------------------------------------------------------.\n *      |  Header (4 * sizeof(t_u16)):  Standard command response hdr |\n *      .-------------------------------------------------------------.\n *      |  BufSize (t_u16) : sizeof the BSS Description data          |\n *      .-------------------------------------------------------------.\n *      |  NumOfSet (t_u8) : Number of BSS Descs returned             |\n *      .-------------------------------------------------------------.\n *      |  BSSDescription data (variable, size given in BufSize)      |\n *      .-------------------------------------------------------------.\n *      |  TLV data (variable, size calculated using Header->Size,    |\n *      |            BufSize and sizeof the fixed fields above)       |\n *      .-------------------------------------------------------------.\n */\nint mwifiex_ret_802_11_scan(struct mwifiex_private *priv,\n\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_rsp *scan_rsp;\n\tstruct mwifiex_ie_types_data *tlv_data;\n\tstruct mwifiex_ie_types_tsf_timestamp *tsf_tlv;\n\tu8 *bss_info;\n\tu32 scan_resp_size;\n\tu32 bytes_left;\n\tu32 idx;\n\tu32 tlv_buf_size;\n\tstruct mwifiex_ie_types_chan_band_list_param_set *chan_band_tlv;\n\tstruct chan_band_param_set *chan_band;\n\tu8 is_bgscan_resp;\n\t__le64 fw_tsf = 0;\n\tu8 *radio_type;\n\tstruct cfg80211_wowlan_nd_match *pmatch;\n\tstruct cfg80211_sched_scan_request *nd_config = NULL;\n\n\tis_bgscan_resp = (le16_to_cpu(resp->command)\n\t\t\t  == HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tif (is_bgscan_resp)\n\t\tscan_rsp = &resp->params.bg_scan_query_resp.scan_resp;\n\telse\n\t\tscan_rsp = &resp->params.scan_resp;\n\n\n\tif (scan_rsp->number_of_sets > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SCAN_RESP: too many AP returned (%d)\\n\",\n\t\t\t    scan_rsp->number_of_sets);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\t/* Check csa channel expiry before parsing scan response */\n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tbytes_left = le16_to_cpu(scan_rsp->bss_descript_size);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: bss_descript_size %d\\n\",\n\t\t    bytes_left);\n\n\tscan_resp_size = le16_to_cpu(resp->size);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: returned %d APs before parsing\\n\",\n\t\t    scan_rsp->number_of_sets);\n\n\tbss_info = scan_rsp->bss_desc_and_tlv_buffer;\n\n\t/*\n\t * The size of the TLV buffer is equal to the entire command response\n\t *   size (scan_resp_size) minus the fixed fields (sizeof()'s), the\n\t *   BSS Descriptions (bss_descript_size as bytesLef) and the command\n\t *   response header (S_DS_GEN)\n\t */\n\ttlv_buf_size = scan_resp_size - (bytes_left\n\t\t\t\t\t + sizeof(scan_rsp->bss_descript_size)\n\t\t\t\t\t + sizeof(scan_rsp->number_of_sets)\n\t\t\t\t\t + S_DS_GEN);\n\n\ttlv_data = (struct mwifiex_ie_types_data *) (scan_rsp->\n\t\t\t\t\t\t bss_desc_and_tlv_buffer +\n\t\t\t\t\t\t bytes_left);\n\n\t/* Search the TLV buffer space in the scan response for any valid\n\t   TLVs */\n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_TSFTIMESTAMP,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &tsf_tlv);\n\n\t/* Search the TLV buffer space in the scan response for any valid\n\t   TLVs */\n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_CHANNELBANDLIST,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &chan_band_tlv);\n\n#ifdef CONFIG_PM\n\tif (priv->wdev.wiphy->wowlan_config)\n\t\tnd_config = priv->wdev.wiphy->wowlan_config->nd_config;\n#endif\n\n\tif (nd_config) {\n\t\tadapter->nd_info =\n\t\t\tkzalloc(sizeof(struct cfg80211_wowlan_nd_match) +\n\t\t\t\tsizeof(struct cfg80211_wowlan_nd_match *) *\n\t\t\t\tscan_rsp->number_of_sets, GFP_ATOMIC);\n\n\t\tif (adapter->nd_info)\n\t\t\tadapter->nd_info->n_matches = scan_rsp->number_of_sets;\n\t}\n\n\tfor (idx = 0; idx < scan_rsp->number_of_sets && bytes_left; idx++) {\n\t\t/*\n\t\t * If the TSF TLV was appended to the scan results, save this\n\t\t * entry's TSF value in the fw_tsf field. It is the firmware's\n\t\t * TSF value at the time the beacon or probe response was\n\t\t * received.\n\t\t */\n\t\tif (tsf_tlv)\n\t\t\tmemcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],\n\t\t\t       sizeof(fw_tsf));\n\n\t\tif (chan_band_tlv) {\n\t\t\tchan_band = &chan_band_tlv->chan_band_param[idx];\n\t\t\tradio_type = &chan_band->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\n\t\tif (chan_band_tlv && adapter->nd_info) {\n\t\t\tadapter->nd_info->matches[idx] =\n\t\t\t\tkzalloc(sizeof(*pmatch) + sizeof(u32),\n\t\t\t\t\tGFP_ATOMIC);\n\n\t\t\tpmatch = adapter->nd_info->matches[idx];\n\n\t\t\tif (pmatch) {\n\t\t\t\tpmatch->n_channels = 1;\n\t\t\t\tpmatch->channels[0] = chan_band->chan_number;\n\t\t\t}\n\t\t}\n\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left,\n\t\t\t\t\t\t\tle64_to_cpu(fw_tsf),\n\t\t\t\t\t\t\tradio_type, false, 0);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tmwifiex_check_next_scan_command(priv);\n\treturn ret;\n}\n\n/*\n * This function prepares an extended scan command to be sent to the firmware\n *\n * This uses the scan command configuration sent to the command processing\n * module in command preparation stage to configure a extended scan command\n * structure to send to firmware.\n */\nint mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tvoid *data_buf)\n{\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan = &cmd->params.ext_scan;\n\tstruct mwifiex_scan_cmd_config *scan_cfg = data_buf;\n\n\tmemcpy(ext_scan->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN_EXT);\n\n\t/* Size is equal to the sizeof(fixed portions) + the TLV len + header */\n\tcmd->size = cpu_to_le16((u16)(sizeof(ext_scan->reserved)\n\t\t\t\t      + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n/* This function prepares an background scan config command to be sent\n * to the firmware\n */\nint mwifiex_cmd_802_11_bg_scan_config(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd,\n\t\t\t\t      void *data_buf)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_config *bgscan_config =\n\t\t\t\t\t&cmd->params.bg_scan_config;\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg_in = data_buf;\n\tu8 *tlv_pos = bgscan_config->tlv;\n\tu8 num_probes;\n\tu32 ssid_len, chan_idx, scan_type, scan_dur, chan_num;\n\tint i;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_repeat_count *repeat_count_tlv;\n\tstruct mwifiex_ie_types_min_rssi_threshold *rssi_threshold_tlv;\n\tstruct mwifiex_ie_types_bgscan_start_later *start_later_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_tlv;\n\tstruct mwifiex_chan_scan_param_set *temp_chan;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);\n\tcmd->size = cpu_to_le16(sizeof(*bgscan_config) + S_DS_GEN);\n\n\tbgscan_config->action = cpu_to_le16(bgscan_cfg_in->action);\n\tbgscan_config->enable = bgscan_cfg_in->enable;\n\tbgscan_config->bss_type = bgscan_cfg_in->bss_type;\n\tbgscan_config->scan_interval =\n\t\tcpu_to_le32(bgscan_cfg_in->scan_interval);\n\tbgscan_config->report_condition =\n\t\tcpu_to_le32(bgscan_cfg_in->report_condition);\n\n\t/*  stop sched scan  */\n\tif (!bgscan_config->enable)\n\t\treturn 0;\n\n\tbgscan_config->chan_per_scan = bgscan_cfg_in->chan_per_scan;\n\n\tnum_probes = (bgscan_cfg_in->num_probes ? bgscan_cfg_in->\n\t\t      num_probes : priv->adapter->scan_probes);\n\n\tif (num_probes) {\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *)tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16)num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->repeat_count) {\n\t\trepeat_count_tlv =\n\t\t\t(struct mwifiex_ie_types_repeat_count *)tlv_pos;\n\t\trepeat_count_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_REPEAT_COUNT);\n\t\trepeat_count_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(repeat_count_tlv->repeat_count));\n\t\trepeat_count_tlv->repeat_count =\n\t\t\tcpu_to_le16(bgscan_cfg_in->repeat_count);\n\n\t\ttlv_pos += sizeof(repeat_count_tlv->header) +\n\t\t\tle16_to_cpu(repeat_count_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->rssi_threshold) {\n\t\trssi_threshold_tlv =\n\t\t\t(struct mwifiex_ie_types_min_rssi_threshold *)tlv_pos;\n\t\trssi_threshold_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_RSSI_LOW);\n\t\trssi_threshold_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(rssi_threshold_tlv->rssi_threshold));\n\t\trssi_threshold_tlv->rssi_threshold =\n\t\t\tcpu_to_le16(bgscan_cfg_in->rssi_threshold);\n\n\t\ttlv_pos += sizeof(rssi_threshold_tlv->header) +\n\t\t\tle16_to_cpu(rssi_threshold_tlv->header.len);\n\t}\n\n\tfor (i = 0; i < bgscan_cfg_in->num_ssids; i++) {\n\t\tssid_len = bgscan_cfg_in->ssid_list[i].ssid.ssid_len;\n\n\t\twildcard_ssid_tlv =\n\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)tlv_pos;\n\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16)(ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t/* max_ssid_length = 0 tells firmware to perform\n\t\t * specific scan for the SSID filled, whereas\n\t\t * max_ssid_length = IEEE80211_MAX_SSID_LEN is for\n\t\t * wildcard scan.\n\t\t */\n\t\tif (ssid_len)\n\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\telse\n\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t       bgscan_cfg_in->ssid_list[i].ssid.ssid, ssid_len);\n\n\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\t}\n\n\tchan_list_tlv = (struct mwifiex_ie_types_chan_list_param_set *)tlv_pos;\n\n\tif (bgscan_cfg_in->chan_list[0].chan_number) {\n\t\tdev_dbg(priv->adapter->dev, \"info: bgscan: Using supplied channel list\\n\");\n\n\t\tchan_list_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_BG_SCAN_CHAN_MAX &&\n\t\t     bgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\t\t\ttemp_chan = chan_list_tlv->chan_scan_param + chan_idx;\n\n\t\t\t/* Increment the TLV header length by size appended */\n\t\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t       chan_list_tlv->chan_scan_param));\n\n\t\t\ttemp_chan->chan_number =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t\ttemp_chan->radio_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].radio_type;\n\n\t\t\tscan_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tif (bgscan_cfg_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tscan_dur = (scan_type ==\n\t\t\t\t\t    MWIFIEX_SCAN_TYPE_PASSIVE) ?\n\t\t\t\t\t    priv->adapter->passive_scan_time :\n\t\t\t\t\t    priv->adapter->specific_scan_time;\n\t\t\t}\n\n\t\t\ttemp_chan->min_scan_time = cpu_to_le16(scan_dur);\n\t\t\ttemp_chan->max_scan_time = cpu_to_le16(scan_dur);\n\t\t}\n\t} else {\n\t\tdev_dbg(priv->adapter->dev,\n\t\t\t\"info: bgscan: Creating full region channel list\\n\");\n\t\tchan_num =\n\t\t\tmwifiex_bgscan_create_channel_list(priv, bgscan_cfg_in,\n\t\t\t\t\t\t\t   chan_list_tlv->\n\t\t\t\t\t\t\t   chan_scan_param);\n\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t       chan_num *\n\t\t\t     sizeof(chan_list_tlv->chan_scan_param[0]));\n\t}\n\n\ttlv_pos += (sizeof(chan_list_tlv->header)\n\t\t\t+ le16_to_cpu(chan_list_tlv->header.len));\n\n\tif (bgscan_cfg_in->start_later) {\n\t\tstart_later_tlv =\n\t\t\t(struct mwifiex_ie_types_bgscan_start_later *)tlv_pos;\n\t\tstart_later_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_BGSCAN_START_LATER);\n\t\tstart_later_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(start_later_tlv->start_later));\n\t\tstart_later_tlv->start_later =\n\t\t\tcpu_to_le16(bgscan_cfg_in->start_later);\n\n\t\ttlv_pos += sizeof(start_later_tlv->header) +\n\t\t\tle16_to_cpu(start_later_tlv->header.len);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_BGSCAN, &tlv_pos);\n\n\tle16_unaligned_add_cpu(&cmd->size, tlv_pos - bgscan_config->tlv);\n\n\treturn 0;\n}\n\nint mwifiex_stop_bg_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg;\n\n\tif (!priv->sched_scanning) {\n\t\tdev_dbg(priv->adapter->dev, \"bgscan already stopped!\\n\");\n\t\treturn 0;\n\t}\n\n\tbgscan_cfg = kzalloc(sizeof(*bgscan_cfg), GFP_KERNEL);\n\tif (!bgscan_cfg)\n\t\treturn -ENOMEM;\n\n\tbgscan_cfg->bss_type = MWIFIEX_BSS_MODE_INFRA;\n\tbgscan_cfg->action = MWIFIEX_BGSCAN_ACT_SET;\n\tbgscan_cfg->enable = false;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, bgscan_cfg, true)) {\n\t\tkfree(bgscan_cfg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(bgscan_cfg);\n\tpriv->sched_scanning = false;\n\n\treturn 0;\n}\n\nstatic void\nmwifiex_update_chan_statistics(struct mwifiex_private *priv,\n\t\t\t       struct mwifiex_ietypes_chanstats *tlv_stat)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 i, num_chan;\n\tstruct mwifiex_fw_chan_stats *fw_chan_stats;\n\tstruct mwifiex_chan_stats chan_stats;\n\n\tfw_chan_stats = (void *)((u8 *)tlv_stat +\n\t\t\t      sizeof(struct mwifiex_ie_types_header));\n\tnum_chan = le16_to_cpu(tlv_stat->header.len) /\n\t\t\t\t\t      sizeof(struct mwifiex_chan_stats);\n\n\tfor (i = 0 ; i < num_chan; i++) {\n\t\tif (adapter->survey_idx >= adapter->num_in_chan_stats) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"FW reported too many channel results (max %d)\\n\",\n\t\t\t\t    adapter->num_in_chan_stats);\n\t\t\treturn;\n\t\t}\n\t\tchan_stats.chan_num = fw_chan_stats->chan_num;\n\t\tchan_stats.bandcfg = fw_chan_stats->bandcfg;\n\t\tchan_stats.flags = fw_chan_stats->flags;\n\t\tchan_stats.noise = fw_chan_stats->noise;\n\t\tchan_stats.total_bss = le16_to_cpu(fw_chan_stats->total_bss);\n\t\tchan_stats.cca_scan_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_scan_dur);\n\t\tchan_stats.cca_busy_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_busy_dur);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"chan=%d, noise=%d, total_network=%d scan_duration=%d, busy_duration=%d\\n\",\n\t\t\t    chan_stats.chan_num,\n\t\t\t    chan_stats.noise,\n\t\t\t    chan_stats.total_bss,\n\t\t\t    chan_stats.cca_scan_dur,\n\t\t\t    chan_stats.cca_busy_dur);\n\t\tmemcpy(&adapter->chan_stats[adapter->survey_idx++], &chan_stats,\n\t\t       sizeof(struct mwifiex_chan_stats));\n\t\tfw_chan_stats++;\n\t}\n}\n\n/* This function handles the command response of extended scan */\nint mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan_resp;\n\tstruct mwifiex_ie_types_header *tlv;\n\tstruct mwifiex_ietypes_chanstats *tlv_stat;\n\tu16 buf_left, type, len;\n\n\tstruct host_cmd_ds_command *cmd_ptr;\n\tstruct cmd_ctrl_node *cmd_node;\n\tbool complete_scan = false;\n\n\tmwifiex_dbg(adapter, INFO, \"info: EXT scan returns successfully\\n\");\n\n\text_scan_resp = &resp->params.ext_scan;\n\n\ttlv = (void *)ext_scan_resp->tlv_buffer;\n\tbuf_left = le16_to_cpu(resp->size) - (sizeof(*ext_scan_resp) + S_DS_GEN\n\t\t\t\t\t      - 1);\n\n\twhile (buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\t\ttype = le16_to_cpu(tlv->type);\n\t\tlen = le16_to_cpu(tlv->len);\n\n\t\tif (buf_left < (sizeof(struct mwifiex_ie_types_header) + len)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"error processing scan response TLVs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase TLV_TYPE_CHANNEL_STATS:\n\t\t\ttlv_stat = (void *)tlv;\n\t\t\tmwifiex_update_chan_statistics(priv, tlv_stat);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_left -= len + sizeof(struct mwifiex_ie_types_header);\n\t\ttlv = (void *)((u8 *)tlv + len +\n\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\t}\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tcomplete_scan = true;\n\t\tlist_for_each_entry(cmd_node, &adapter->cmd_pending_q, list) {\n\t\t\tcmd_ptr = (void *)cmd_node->cmd_skb->data;\n\t\t\tif (le16_to_cpu(cmd_ptr->command) ==\n\t\t\t    HostCmd_CMD_802_11_SCAN_EXT) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"Scan pending in command pending list\");\n\t\t\t\tcomplete_scan = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\tif (complete_scan)\n\t\tmwifiex_complete_scan(priv);\n\n\treturn 0;\n}\n\n/* This function This function handles the event extended scan report. It\n * parses extended scan results and informs to cfg80211 stack.\n */\nint mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,\n\t\t\t\t\t void *buf)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 *bss_info;\n\tu32 bytes_left, bytes_left_for_tlv, idx;\n\tu16 type, len;\n\tstruct mwifiex_ie_types_data *tlv;\n\tstruct mwifiex_ie_types_bss_scan_rsp *scan_rsp_tlv;\n\tstruct mwifiex_ie_types_bss_scan_info *scan_info_tlv;\n\tu8 *radio_type;\n\tu64 fw_tsf = 0;\n\ts32 rssi = 0;\n\tstruct mwifiex_event_scan_result *event_scan = buf;\n\tu8 num_of_set = event_scan->num_of_set;\n\tu8 *scan_resp = buf + sizeof(struct mwifiex_event_scan_result);\n\tu16 scan_resp_size = le16_to_cpu(event_scan->buf_size);\n\n\tif (num_of_set > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EXT_SCAN: Invalid number of AP returned (%d)!!\\n\",\n\t\t\t    num_of_set);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\tbytes_left = scan_resp_size;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"EXT_SCAN: size %d, returned %d APs...\",\n\t\t    scan_resp_size, num_of_set);\n\tmwifiex_dbg_dump(adapter, CMD_D, \"EXT_SCAN buffer:\", buf,\n\t\t\t scan_resp_size +\n\t\t\t sizeof(struct mwifiex_event_scan_result));\n\n\ttlv = (struct mwifiex_ie_types_data *)scan_resp;\n\n\tfor (idx = 0; idx < num_of_set && bytes_left; idx++) {\n\t\ttype = le16_to_cpu(tlv->header.type);\n\t\tlen = le16_to_cpu(tlv->header.len);\n\t\tif (bytes_left < sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"EXT_SCAN: Error bytes left < TLV length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tscan_rsp_tlv = NULL;\n\t\tscan_info_tlv = NULL;\n\t\tbytes_left_for_tlv = bytes_left;\n\n\t\t/* BSS response TLV with beacon or probe response buffer\n\t\t * at the initial position of each descriptor\n\t\t */\n\t\tif (type != TLV_TYPE_BSS_SCAN_RSP)\n\t\t\tbreak;\n\n\t\tbss_info = (u8 *)tlv;\n\t\tscan_rsp_tlv = (struct mwifiex_ie_types_bss_scan_rsp *)tlv;\n\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\n\t\twhile (bytes_left_for_tlv >=\n\t\t       sizeof(struct mwifiex_ie_types_header) &&\n\t\t       le16_to_cpu(tlv->header.type) != TLV_TYPE_BSS_SCAN_RSP) {\n\t\t\ttype = le16_to_cpu(tlv->header.type);\n\t\t\tlen = le16_to_cpu(tlv->header.len);\n\t\t\tif (bytes_left_for_tlv <\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"EXT_SCAN: Error in processing TLV,\\t\"\n\t\t\t\t\t    \"bytes left < TLV length\\n\");\n\t\t\t\tscan_rsp_tlv = NULL;\n\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (type) {\n\t\t\tcase TLV_TYPE_BSS_SCAN_INFO:\n\t\t\t\tscan_info_tlv =\n\t\t\t\t  (struct mwifiex_ie_types_bss_scan_info *)tlv;\n\t\t\t\tif (len !=\n\t\t\t\t sizeof(struct mwifiex_ie_types_bss_scan_info) -\n\t\t\t\t sizeof(struct mwifiex_ie_types_header)) {\n\t\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\t\tbytes_left -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t}\n\n\t\tif (!scan_rsp_tlv)\n\t\t\tbreak;\n\n\t\t/* Advance pointer to the beacon buffer length and\n\t\t * update the bytes count so that the function\n\t\t * wlan_interpret_bss_desc_with_ie() can handle the\n\t\t * scan buffer withut any change\n\t\t */\n\t\tbss_info += sizeof(u16);\n\t\tbytes_left -= sizeof(u16);\n\n\t\tif (scan_info_tlv) {\n\t\t\trssi = (s32)(s16)(le16_to_cpu(scan_info_tlv->rssi));\n\t\t\trssi *= 100;           /* Convert dBm to mBm */\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t\t\tfw_tsf = le64_to_cpu(scan_info_tlv->tsf);\n\t\t\tradio_type = &scan_info_tlv->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left, fw_tsf,\n\t\t\t\t\t\t\tradio_type, true, rssi);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tif (!event_scan->more_event)\n\t\tmwifiex_check_next_scan_command(priv);\n\n\treturn ret;\n}\n\n/*\n * This function prepares command for background scan query.\n *\n * Preparation includes -\n *      - Setting command ID and proper size\n *      - Setting background scan flush parameter\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_bg_scan_query(struct host_cmd_ds_command *cmd)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_query *bg_query =\n\t\t&cmd->params.bg_scan_query;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_bg_scan_query)\n\t\t\t\t+ S_DS_GEN);\n\n\tbg_query->flush = 1;\n\n\treturn 0;\n}\n\n/*\n * This function inserts scan command node to the scan pending queue.\n */\nvoid\nmwifiex_queue_scan_cmd(struct mwifiex_private *priv,\n\t\t       struct cmd_ctrl_node *cmd_node)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tcmd_node->wait_q_enabled = true;\n\tcmd_node->condition = &adapter->scan_wait_q_woken;\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tlist_add_tail(&cmd_node->list, &adapter->scan_pending_q);\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n}\n\n/*\n * This function sends a scan command for all available channels to the\n * firmware, filtered on a specific SSID.\n */\nstatic int mwifiex_scan_specific_ssid(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_ssid *req_ssid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct mwifiex_user_scan_cfg *scan_cfg;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tscan_cfg = kzalloc(sizeof(struct mwifiex_user_scan_cfg), GFP_KERNEL);\n\tif (!scan_cfg)\n\t\treturn -ENOMEM;\n\n\tscan_cfg->ssid_list = req_ssid;\n\tscan_cfg->num_ssids = 1;\n\n\tret = mwifiex_scan_networks(priv, scan_cfg);\n\n\tkfree(scan_cfg);\n\treturn ret;\n}\n\n/*\n * Sends IOCTL request to start a scan.\n *\n * This function allocates the IOCTL request buffer, fills it\n * with requisite parameters and calls the IOCTL handler.\n *\n * Scan command can be issued for both normal scan and specific SSID\n * scan, depending upon whether an SSID is provided or not.\n */\nint mwifiex_request_scan(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_ssid *req_ssid)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&priv->async_mutex)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: acquire semaphore fail\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tpriv->adapter->scan_wait_q_woken = false;\n\n\tif (req_ssid && req_ssid->ssid_len != 0)\n\t\t/* Specific SSID scan */\n\t\tret = mwifiex_scan_specific_ssid(priv, req_ssid);\n\telse\n\t\t/* Normal scan */\n\t\tret = mwifiex_scan_networks(priv, NULL);\n\n\tmutex_unlock(&priv->async_mutex);\n\n\treturn ret;\n}\n\n/*\n * This function appends the vendor specific IE TLV to a buffer.\n */\nint\nmwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * Traverse through the saved vendor specific IE array and append\n\t * the selected(scan/assoc/adhoc) IE as TLV to the command\n\t */\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}\n\n/*\n * This function saves a beacon buffer of the current BSS descriptor.\n *\n * The current beacon buffer is saved so that it can be restored in the\n * following cases that makes the beacon buffer not to contain the current\n * ssid's beacon buffer.\n *      - The current ssid was not found somehow in the last scan.\n *      - The current ssid was the last entry of the scan table and overloaded.\n */\nvoid\nmwifiex_save_curr_bcn(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bssdescriptor *curr_bss =\n\t\t&priv->curr_bss_params.bss_descriptor;\n\n\tif (!curr_bss->beacon_buf_size)\n\t\treturn;\n\n\t/* allocate beacon buffer at 1st time; or if it's size has changed */\n\tif (!priv->curr_bcn_buf ||\n\t    priv->curr_bcn_size != curr_bss->beacon_buf_size) {\n\t\tpriv->curr_bcn_size = curr_bss->beacon_buf_size;\n\n\t\tkfree(priv->curr_bcn_buf);\n\t\tpriv->curr_bcn_buf = kmalloc(curr_bss->beacon_buf_size,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!priv->curr_bcn_buf)\n\t\t\treturn;\n\t}\n\n\tmemcpy(priv->curr_bcn_buf, curr_bss->beacon_buf,\n\t       curr_bss->beacon_buf_size);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: current beacon saved %d\\n\",\n\t\t    priv->curr_bcn_size);\n\n\tcurr_bss->beacon_buf = priv->curr_bcn_buf;\n\n\t/* adjust the pointers in the current BSS descriptor */\n\tif (curr_bss->bcn_wpa_ie)\n\t\tcurr_bss->bcn_wpa_ie =\n\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->wpa_offset);\n\n\tif (curr_bss->bcn_rsn_ie)\n\t\tcurr_bss->bcn_rsn_ie = (struct ieee_types_generic *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->rsn_offset);\n\n\tif (curr_bss->bcn_ht_cap)\n\t\tcurr_bss->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_cap_offset);\n\n\tif (curr_bss->bcn_ht_oper)\n\t\tcurr_bss->bcn_ht_oper = (struct ieee80211_ht_operation *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_info_offset);\n\n\tif (curr_bss->bcn_vht_cap)\n\t\tcurr_bss->bcn_vht_cap = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t curr_bss->vht_cap_offset);\n\n\tif (curr_bss->bcn_vht_oper)\n\t\tcurr_bss->bcn_vht_oper = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t  curr_bss->vht_info_offset);\n\n\tif (curr_bss->bcn_bss_co_2040)\n\t\tcurr_bss->bcn_bss_co_2040 =\n\t\t\t(curr_bss->beacon_buf + curr_bss->bss_co_2040_offset);\n\n\tif (curr_bss->bcn_ext_cap)\n\t\tcurr_bss->bcn_ext_cap = curr_bss->beacon_buf +\n\t\t\tcurr_bss->ext_cap_offset;\n\n\tif (curr_bss->oper_mode)\n\t\tcurr_bss->oper_mode = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t       curr_bss->oper_mode_offset);\n}\n\n/*\n * This function frees the current BSS descriptor beacon buffer.\n */\nvoid\nmwifiex_free_curr_bcn(struct mwifiex_private *priv)\n{\n\tkfree(priv->curr_bcn_buf);\n\tpriv->curr_bcn_buf = NULL;\n}\n"], "fixing_code": ["/*\n * Marvell Wireless LAN device driver: scan ioctl and command handling\n *\n * Copyright (C) 2011-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"11n.h\"\n#include \"cfg80211.h\"\n\n/* The maximum number of channels the firmware can scan per command */\n#define MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN   14\n\n#define MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD\t4\n\n/* Memory needed to store a max sized Channel List TLV for a firmware scan */\n#define CHAN_TLV_MAX_SIZE  (sizeof(struct mwifiex_ie_types_header)         \\\n\t\t\t\t+ (MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN     \\\n\t\t\t\t*sizeof(struct mwifiex_chan_scan_param_set)))\n\n/* Memory needed to store supported rate */\n#define RATE_TLV_MAX_SIZE   (sizeof(struct mwifiex_ie_types_rates_param_set) \\\n\t\t\t\t+ HOSTCMD_SUPPORTED_RATES)\n\n/* Memory needed to store a max number/size WildCard SSID TLV for a firmware\n\tscan */\n#define WILDCARD_SSID_TLV_MAX_SIZE  \\\n\t(MWIFIEX_MAX_SSID_LIST_LENGTH *\t\t\t\t\t\\\n\t\t(sizeof(struct mwifiex_ie_types_wildcard_ssid_params)\t\\\n\t\t\t+ IEEE80211_MAX_SSID_LEN))\n\n/* Maximum memory needed for a mwifiex_scan_cmd_config with all TLVs at max */\n#define MAX_SCAN_CFG_ALLOC (sizeof(struct mwifiex_scan_cmd_config)        \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_num_probes)   \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_htcap)       \\\n\t\t\t\t+ CHAN_TLV_MAX_SIZE                 \\\n\t\t\t\t+ RATE_TLV_MAX_SIZE                 \\\n\t\t\t\t+ WILDCARD_SSID_TLV_MAX_SIZE)\n\n\nunion mwifiex_scan_cmd_config_tlv {\n\t/* Scan configuration (variable length) */\n\tstruct mwifiex_scan_cmd_config config;\n\t/* Max allocated block */\n\tu8 config_alloc_buf[MAX_SCAN_CFG_ALLOC];\n};\n\nenum cipher_suite {\n\tCIPHER_SUITE_TKIP,\n\tCIPHER_SUITE_CCMP,\n\tCIPHER_SUITE_MAX\n};\nstatic u8 mwifiex_wpa_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x50, 0xf2, 0x02 },\t/* TKIP */\n\t{ 0x00, 0x50, 0xf2, 0x04 },\t/* AES  */\n};\nstatic u8 mwifiex_rsn_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x0f, 0xac, 0x02 },\t/* TKIP */\n\t{ 0x00, 0x0f, 0xac, 0x04 },\t/* AES  */\n};\n\nstatic void\n_dbg_security_flags(int log_level, const char *func, const char *desc,\n\t\t    struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\t_mwifiex_dbg(priv->adapter, log_level,\n\t\t     \"info: %s: %s:\\twpa_ie=%#x wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s\\tEncMode=%#x privacy=%#x\\n\",\n\t\t     func, desc,\n\t\t     bss_desc->bcn_wpa_ie ?\n\t\t     bss_desc->bcn_wpa_ie->vend_hdr.element_id : 0,\n\t\t     bss_desc->bcn_rsn_ie ?\n\t\t     bss_desc->bcn_rsn_ie->ieee_hdr.element_id : 0,\n\t\t     priv->sec_info.wep_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa2_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.encryption_mode,\n\t\t     bss_desc->privacy);\n}\n#define dbg_security_flags(mask, desc, priv, bss_desc) \\\n\t_dbg_security_flags(MWIFIEX_DBG_##mask, desc, __func__, priv, bss_desc)\n\nstatic bool\nhas_ieee_hdr(struct ieee_types_generic *ie, u8 key)\n{\n\treturn (ie && ie->ieee_hdr.element_id == key);\n}\n\nstatic bool\nhas_vendor_hdr(struct ieee_types_vendor_specific *ie, u8 key)\n{\n\treturn (ie && ie->vend_hdr.element_id == key);\n}\n\n/*\n * This function parses a given IE for a given OUI.\n *\n * This is used to parse a WPA/RSN IE to find if it has\n * a given oui in PTK.\n */\nstatic u8\nmwifiex_search_oui_in_ie(struct ie_body *iebody, u8 *oui)\n{\n\tu8 count;\n\n\tcount = iebody->ptk_cnt[0];\n\n\t/* There could be multiple OUIs for PTK hence\n\t   1) Take the length.\n\t   2) Check all the OUIs for AES.\n\t   3) If one of them is AES then pass success. */\n\twhile (count) {\n\t\tif (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))\n\t\t\treturn MWIFIEX_OUI_PRESENT;\n\n\t\t--count;\n\t\tif (count)\n\t\t\tiebody = (struct ie_body *) ((u8 *) iebody +\n\t\t\t\t\t\tsizeof(iebody->ptk_body));\n\t}\n\n\tpr_debug(\"info: %s: OUI is not found in PTK\\n\", __func__);\n\treturn MWIFIEX_OUI_NOT_PRESENT;\n}\n\n/*\n * This function checks if a given OUI is present in a RSN IE.\n *\n * The function first checks if a RSN IE is present or not in the\n * BSS descriptor. It tries to locate the OUI only if such an IE is\n * present.\n */\nstatic u8\nmwifiex_is_rsn_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\tiebody = (struct ie_body *)\n\t\t\t (((u8 *) bss_desc->bcn_rsn_ie->data) +\n\t\t\t  RSN_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_rsn_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n/*\n * This function checks if a given OUI is present in a WPA IE.\n *\n * The function first checks if a WPA IE is present or not in the\n * BSS descriptor. It tries to locate the OUI only if such an IE is\n * present.\n */\nstatic u8\nmwifiex_is_wpa_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)) {\n\t\tiebody = (struct ie_body *)((u8 *)bss_desc->bcn_wpa_ie->data +\n\t\t\t\t\t    WPA_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_wpa_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n/*\n * This function compares two SSIDs and checks if they match.\n */\ns32\nmwifiex_ssid_cmp(struct cfg80211_ssid *ssid1, struct cfg80211_ssid *ssid2)\n{\n\tif (!ssid1 || !ssid2 || (ssid1->ssid_len != ssid2->ssid_len))\n\t\treturn -1;\n\treturn memcmp(ssid1->ssid, ssid2->ssid, ssid1->ssid_len);\n}\n\n/*\n * This function checks if wapi is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wapi(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wapi_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_wapi_ie, WLAN_EID_BSS_AC_ACCESS_DELAY))\n\t\treturn true;\n\treturn false;\n}\n\n/*\n * This function checks if driver is configured with no security mode and\n * scanned network is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_no_sec(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && !bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if static WEP is enabled in driver and scanned network\n * is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_static_wep(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if wpa is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wpa(struct mwifiex_private *priv,\n\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)\n\t   /*\n\t    * Privacy bit may NOT be set in some APs like\n\t    * LinkSys WRT54G && bss_desc->privacy\n\t    */\n\t ) {\n\t\tdbg_security_flags(INFO, \"WPA\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if wpa2 is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_wpa2(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    priv->sec_info.wpa2_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\t/*\n\t\t * Privacy bit may NOT be set in some APs like\n\t\t * LinkSys WRT54G && bss_desc->privacy\n\t\t */\n\t\tdbg_security_flags(INFO, \"WAP2\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if adhoc AES is enabled in driver and scanned network is\n * compatible with it.\n */\nstatic bool\nmwifiex_is_bss_adhoc_aes(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if dynamic WEP is enabled in driver and scanned network\n * is compatible with it.\n */\nstatic bool\nmwifiex_is_bss_dynamic_wep(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\tdbg_security_flags(INFO, \"dynamic\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * This function checks if a scanned network is compatible with the driver\n * settings.\n *\n *   WEP     WPA    WPA2   ad-hoc encrypt                  Network\n * enabled enabled enabled  AES    mode   Privacy WPA WPA2 Compatible\n *    0       0       0      0     NONE      0     0   0   yes No security\n *    0       1       0      0      x        1x    1   x   yes WPA (disable\n *                                                         HT if no AES)\n *    0       0       1      0      x        1x    x   1   yes WPA2 (disable\n *                                                         HT if no AES)\n *    0       0       0      1     NONE      1     0   0   yes Ad-hoc AES\n *    1       0       0      0     NONE      1     0   0   yes Static WEP\n *                                                         (disable HT)\n *    0       0       0      0    !=NONE     1     0   0   yes Dynamic WEP\n *\n * Compatibility is not matched while roaming, except for mode.\n */\nstatic s32\nmwifiex_is_network_compatible(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_bssdescriptor *bss_desc, u32 mode)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tbss_desc->disable_11n = false;\n\n\t/* Don't check for compatibility if roaming */\n\tif (priv->media_connected &&\n\t    (priv->bss_mode == NL80211_IFTYPE_STATION) &&\n\t    (bss_desc->bss_mode == NL80211_IFTYPE_STATION))\n\t\treturn 0;\n\n\tif (priv->wps.session_enable) {\n\t\tmwifiex_dbg(adapter, IOCTL,\n\t\t\t    \"info: return success directly in WPS period\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->chan_sw_ie_present) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Don't connect to AP with WLAN_EID_CHANNEL_SWITCH\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_bss_wapi(priv, bss_desc)) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: return success for WAPI AP\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->bss_mode == mode) {\n\t\tif (mwifiex_is_bss_no_sec(priv, bss_desc)) {\n\t\t\t/* No security */\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_static_wep(priv, bss_desc)) {\n\t\t\t/* Static WEP enabled */\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Disable 11n in WEP mode.\\n\");\n\t\t\tbss_desc->disable_11n = true;\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa(priv, bss_desc)) {\n\t\t\t/* WPA enabled */\n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_wpa_oui_present(bss_desc,\n\t\t\t\t\t\t\t CIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_wpa_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa2(priv, bss_desc)) {\n\t\t\t/* WPA2 enabled */\n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_rsn_oui_present(bss_desc,\n\t\t\t\t\t\t\tCIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_rsn_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_adhoc_aes(priv, bss_desc)) {\n\t\t\t/* Ad-hoc AES enabled */\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_dynamic_wep(priv, bss_desc)) {\n\t\t\t/* Dynamic WEP enabled */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Security doesn't match */\n\t\tdbg_security_flags(ERROR, \"failed\", priv, bss_desc);\n\t\treturn -1;\n\t}\n\n\t/* Mode doesn't match */\n\treturn -1;\n}\n\n/*\n * This function creates a channel list for the driver to scan, based\n * on region/band information.\n *\n * This routine is used for any scan that is not provided with a\n * specific channel list to scan.\n */\nstatic int\nmwifiex_scan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t const struct mwifiex_user_scan_cfg\n\t\t\t\t\t\t\t*user_scan_in,\n\t\t\t\t struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t\t*scan_chan_list,\n\t\t\t\t u8 filtered_scan)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS) ; band++) {\n\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (user_scan_in &&\n\t\t\t    user_scan_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16) user_scan_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if ((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t\t (ch->flags & IEEE80211_CHAN_RADAR))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->active_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32) ch->hw_value;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (filtered_scan &&\n\t\t\t    !((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t      (ch->flags & IEEE80211_CHAN_RADAR)))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(adapter->specific_scan_time);\n\n\t\t\tchan_idx++;\n\t\t}\n\n\t}\n\treturn chan_idx;\n}\n\n/* This function creates a channel list tlv for bgscan config, based\n * on region/band information.\n */\nstatic int\nmwifiex_bgscan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t   const struct mwifiex_bg_scan_cfg\n\t\t\t\t\t\t*bgscan_cfg_in,\n\t\t\t\t   struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t*scan_chan_list)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS); band++) {\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (bgscan_cfg_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->\n\t\t\t\t\t\t    specific_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32)ch->hw_value;\n\t\t\tchan_idx++;\n\t\t}\n\t}\n\treturn chan_idx;\n}\n\n/* This function appends rate TLV to scan config command. */\nstatic int\nmwifiex_append_rate_tlv(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\tu8 radio)\n{\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES], *tlv_pos;\n\tu32 rates_size;\n\n\tmemset(rates, 0, sizeof(rates));\n\n\ttlv_pos = (u8 *)scan_cfg_out->tlv_buf + scan_cfg_out->tlv_buf_len;\n\n\tif (priv->scan_request)\n\t\trates_size = mwifiex_get_rates_from_cfg80211(priv, rates,\n\t\t\t\t\t\t\t     radio);\n\telse\n\t\trates_size = mwifiex_get_supported_rates(priv, rates);\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"info: SCAN_CMD: Rates size = %d\\n\",\n\t\trates_size);\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *)tlv_pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tscan_cfg_out->tlv_buf_len += sizeof(rates_tlv->header) + rates_size;\n\n\treturn rates_size;\n}\n\n/*\n * This function constructs and sends multiple scan config commands to\n * the firmware.\n *\n * Previous routines in the code flow have created a scan command configuration\n * with any requested TLVs.  This function splits the channel TLV into maximum\n * channels supported per scan lists and sends the portion of the channel TLV,\n * along with the other TLVs, to the firmware.\n */\nstatic int\nmwifiex_scan_channel_list(struct mwifiex_private *priv,\n\t\t\t  u32 max_chan_per_scan, u8 filtered_scan,\n\t\t\t  struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\t  struct mwifiex_ie_types_chan_list_param_set\n\t\t\t  *chan_tlv_out,\n\t\t\t  struct mwifiex_chan_scan_param_set *scan_chan_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct mwifiex_chan_scan_param_set *tmp_chan_list;\n\tstruct mwifiex_chan_scan_param_set *start_chan;\n\tu32 tlv_idx, rates_size, cmd_no;\n\tu32 total_scan_time;\n\tu32 done_early;\n\tu8 radio_type;\n\n\tif (!scan_cfg_out || !chan_tlv_out || !scan_chan_list) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"info: Scan: Null detect: %p, %p, %p\\n\",\n\t\t\t    scan_cfg_out, chan_tlv_out, scan_chan_list);\n\t\treturn -1;\n\t}\n\n\t/* Check csa channel expiry before preparing scan list */\n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tchan_tlv_out->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t/* Set the temp channel struct pointer to the start of the desired\n\t   list */\n\ttmp_chan_list = scan_chan_list;\n\n\t/* Loop through the desired channel list, sending a new firmware scan\n\t   commands for each max_chan_per_scan channels (or for 1,6,11\n\t   individually if configured accordingly) */\n\twhile (tmp_chan_list->chan_number) {\n\n\t\ttlv_idx = 0;\n\t\ttotal_scan_time = 0;\n\t\tradio_type = 0;\n\t\tchan_tlv_out->header.len = 0;\n\t\tstart_chan = tmp_chan_list;\n\t\tdone_early = false;\n\n\t\t/*\n\t\t * Construct the Channel TLV for the scan command.  Continue to\n\t\t * insert channel TLVs until:\n\t\t *   - the tlv_idx hits the maximum configured per scan command\n\t\t *   - the next channel to insert is 0 (end of desired channel\n\t\t *     list)\n\t\t *   - done_early is set (controlling individual scanning of\n\t\t *     1,6,11)\n\t\t */\n\t\twhile (tlv_idx < max_chan_per_scan &&\n\t\t       tmp_chan_list->chan_number && !done_early) {\n\n\t\t\tif (tmp_chan_list->chan_number == priv->csa_chan) {\n\t\t\t\ttmp_chan_list++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tradio_type = tmp_chan_list->radio_type;\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: Scan: Chan(%3d), Radio(%d),\\t\"\n\t\t\t\t    \"Mode(%d, %d), Dur(%d)\\n\",\n\t\t\t\t    tmp_chan_list->chan_number,\n\t\t\t\t    tmp_chan_list->radio_type,\n\t\t\t\t    tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_PASSIVE_SCAN,\n\t\t\t\t    (tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_DISABLE_CHAN_FILT) >> 1,\n\t\t\t\t    le16_to_cpu(tmp_chan_list->max_scan_time));\n\n\t\t\t/* Copy the current channel TLV to the command being\n\t\t\t   prepared */\n\t\t\tmemcpy(chan_tlv_out->chan_scan_param + tlv_idx,\n\t\t\t       tmp_chan_list,\n\t\t\t       sizeof(chan_tlv_out->chan_scan_param));\n\n\t\t\t/* Increment the TLV header length by the size\n\t\t\t   appended */\n\t\t\tle16_unaligned_add_cpu(&chan_tlv_out->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t\tchan_tlv_out->chan_scan_param));\n\n\t\t\t/*\n\t\t\t * The tlv buffer length is set to the number of bytes\n\t\t\t * of the between the channel tlv pointer and the start\n\t\t\t * of the tlv buffer.  This compensates for any TLVs\n\t\t\t * that were appended before the channel list.\n\t\t\t */\n\t\t\tscan_cfg_out->tlv_buf_len = (u32) ((u8 *) chan_tlv_out -\n\t\t\t\t\t\t\tscan_cfg_out->tlv_buf);\n\n\t\t\t/* Add the size of the channel tlv header and the data\n\t\t\t   length */\n\t\t\tscan_cfg_out->tlv_buf_len +=\n\t\t\t\t(sizeof(chan_tlv_out->header)\n\t\t\t\t + le16_to_cpu(chan_tlv_out->header.len));\n\n\t\t\t/* Increment the index to the channel tlv we are\n\t\t\t   constructing */\n\t\t\ttlv_idx++;\n\n\t\t\t/* Count the total scan time per command */\n\t\t\ttotal_scan_time +=\n\t\t\t\tle16_to_cpu(tmp_chan_list->max_scan_time);\n\n\t\t\tdone_early = false;\n\n\t\t\t/* Stop the loop if the *current* channel is in the\n\t\t\t   1,6,11 set and we are not filtering on a BSSID\n\t\t\t   or SSID. */\n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\n\t\t\t/* Increment the tmp pointer to the next channel to\n\t\t\t   be scanned */\n\t\t\ttmp_chan_list++;\n\n\t\t\t/* Stop the loop if the *next* channel is in the 1,6,11\n\t\t\t   set.  This will cause it to be the only channel\n\t\t\t   scanned on the next interation */\n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\t\t}\n\n\t\t/* The total scan time should be less than scan command timeout\n\t\t   value */\n\t\tif (total_scan_time > MWIFIEX_MAX_TOTAL_SCAN_TIME) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"total scan time %dms\\t\"\n\t\t\t\t    \"is over limit (%dms), scan skipped\\n\",\n\t\t\t\t    total_scan_time,\n\t\t\t\t    MWIFIEX_MAX_TOTAL_SCAN_TIME);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trates_size = mwifiex_append_rate_tlv(priv, scan_cfg_out,\n\t\t\t\t\t\t     radio_type);\n\n\t\tpriv->adapter->scan_channels = start_chan;\n\n\t\t/* Send the scan command to the firmware with the specified\n\t\t   cfg */\n\t\tif (priv->adapter->ext_scan)\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN_EXT;\n\t\telse\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN;\n\n\t\tret = mwifiex_send_cmd(priv, cmd_no, HostCmd_ACT_GEN_SET,\n\t\t\t\t       0, scan_cfg_out, false);\n\n\t\t/* rate IE is updated per scan command but same starting\n\t\t * pointer is used each time so that rate IE from earlier\n\t\t * scan_cfg_out->buf is overwritten with new one.\n\t\t */\n\t\tscan_cfg_out->tlv_buf_len -=\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + rates_size;\n\n\t\tif (ret) {\n\t\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * This function constructs a scan command configuration structure to use\n * in scan commands.\n *\n * Application layer or other functions can invoke network scanning\n * with a scan configuration supplied in a user scan configuration structure.\n * This structure is used as the basis of one or many scan command configuration\n * commands that are sent to the command processing module and eventually to the\n * firmware.\n *\n * This function creates a scan command configuration structure  based on the\n * following user supplied parameters (if present):\n *      - SSID filter\n *      - BSSID filter\n *      - Number of Probes to be sent\n *      - Channel list\n *\n * If the SSID or BSSID filter is not present, the filter is disabled/cleared.\n * If the number of probes is not set, adapter default setting is used.\n */\nstatic void\nmwifiex_config_scan(struct mwifiex_private *priv,\n\t\t    const struct mwifiex_user_scan_cfg *user_scan_in,\n\t\t    struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t    struct mwifiex_ie_types_chan_list_param_set **chan_list_out,\n\t\t    struct mwifiex_chan_scan_param_set *scan_chan_list,\n\t\t    u8 *max_chan_per_scan, u8 *filtered_scan,\n\t\t    u8 *scan_current_only)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_scan_chan_gap *chan_gap_tlv;\n\tstruct mwifiex_ie_types_random_mac *random_mac_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_bssid_list *bssid_tlv;\n\tu8 *tlv_pos;\n\tu32 num_probes;\n\tu32 ssid_len;\n\tu32 chan_idx;\n\tu32 scan_type;\n\tu16 scan_dur;\n\tu8 channel;\n\tu8 radio_type;\n\tint i;\n\tu8 ssid_filter;\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_bss_mode *bss_mode;\n\tconst u8 zero_mac[6] = {0, 0, 0, 0, 0, 0};\n\n\t/* The tlv_buf_len is calculated for each scan command.  The TLVs added\n\t   in this routine will be preserved since the routine that sends the\n\t   command will append channelTLVs at *chan_list_out.  The difference\n\t   between the *chan_list_out and the tlv_buf start will be used to\n\t   calculate the size of anything we add in this routine. */\n\tscan_cfg_out->tlv_buf_len = 0;\n\n\t/* Running tlv pointer.  Assigned to chan_list_out at end of function\n\t   so later routines know where channels can be added to the command\n\t   buf */\n\ttlv_pos = scan_cfg_out->tlv_buf;\n\n\t/* Initialize the scan as un-filtered; the flag is later set to TRUE\n\t   below if a SSID or BSSID filter is sent in the command */\n\t*filtered_scan = false;\n\n\t/* Initialize the scan as not being only on the current channel.  If\n\t   the channel list is customized, only contains one channel, and is\n\t   the active channel, this is set true and data flow is not halted. */\n\t*scan_current_only = false;\n\n\tif (user_scan_in) {\n\t\tu8 tmpaddr[ETH_ALEN];\n\n\t\t/* Default the ssid_filter flag to TRUE, set false under\n\t\t   certain wildcard conditions and qualified by the existence\n\t\t   of an SSID list before marking the scan as filtered */\n\t\tssid_filter = true;\n\n\t\t/* Set the BSS type scan filter, use Adapter setting if\n\t\t   unset */\n\t\tscan_cfg_out->bss_mode =\n\t\t\t(u8)(user_scan_in->bss_mode ?: adapter->scan_mode);\n\n\t\t/* Set the number of probes to send, use Adapter setting\n\t\t   if unset */\n\t\tnum_probes = user_scan_in->num_probes ?: adapter->scan_probes;\n\n\t\t/*\n\t\t * Set the BSSID filter to the incoming configuration,\n\t\t * if non-zero.  If not set, it will remain disabled\n\t\t * (all zeros).\n\t\t */\n\t\tmemcpy(scan_cfg_out->specific_bssid,\n\t\t       user_scan_in->specific_bssid,\n\t\t       sizeof(scan_cfg_out->specific_bssid));\n\n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\n\t\tif (adapter->ext_scan &&\n\t\t    !is_zero_ether_addr(tmpaddr)) {\n\t\t\tbssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_bssid_list *)tlv_pos;\n\t\t\tbssid_tlv->header.type = cpu_to_le16(TLV_TYPE_BSSID);\n\t\t\tbssid_tlv->header.len = cpu_to_le16(ETH_ALEN);\n\t\t\tmemcpy(bssid_tlv->bssid, user_scan_in->specific_bssid,\n\t\t\t       ETH_ALEN);\n\t\t\ttlv_pos += sizeof(struct mwifiex_ie_types_bssid_list);\n\t\t}\n\n\t\tfor (i = 0; i < user_scan_in->num_ssids; i++) {\n\t\t\tssid_len = user_scan_in->ssid_list[i].ssid_len;\n\n\t\t\twildcard_ssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)\n\t\t\t\ttlv_pos;\n\t\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16) (ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t\t/*\n\t\t\t * max_ssid_length = 0 tells firmware to perform\n\t\t\t * specific scan for the SSID filled, whereas\n\t\t\t * max_ssid_length = IEEE80211_MAX_SSID_LEN is for\n\t\t\t * wildcard scan.\n\t\t\t */\n\t\t\tif (ssid_len)\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\t\telse\n\t\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\t\tif (!memcmp(user_scan_in->ssid_list[i].ssid,\n\t\t\t\t    \"DIRECT-\", 7))\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0xfe;\n\n\t\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t\t       user_scan_in->ssid_list[i].ssid, ssid_len);\n\n\t\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: ssid[%d]: %s, %d\\n\",\n\t\t\t\t    i, wildcard_ssid_tlv->ssid,\n\t\t\t\t    wildcard_ssid_tlv->max_ssid_length);\n\n\t\t\t/* Empty wildcard ssid with a maxlen will match many or\n\t\t\t   potentially all SSIDs (maxlen == 32), therefore do\n\t\t\t   not treat the scan as\n\t\t\t   filtered. */\n\t\t\tif (!ssid_len && wildcard_ssid_tlv->max_ssid_length)\n\t\t\t\tssid_filter = false;\n\t\t}\n\n\t\t/*\n\t\t *  The default number of channels sent in the command is low to\n\t\t *  ensure the response buffer from the firmware does not\n\t\t *  truncate scan results.  That is not an issue with an SSID\n\t\t *  or BSSID filter applied to the scan results in the firmware.\n\t\t */\n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\t\tif ((i && ssid_filter) ||\n\t\t    !is_zero_ether_addr(tmpaddr))\n\t\t\t*filtered_scan = true;\n\n\t\tif (user_scan_in->scan_chan_gap) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: channel gap = %d\\n\",\n\t\t\t\t    user_scan_in->scan_chan_gap);\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\n\t\t\tchan_gap_tlv = (void *)tlv_pos;\n\t\t\tchan_gap_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_SCAN_CHANNEL_GAP);\n\t\t\tchan_gap_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(chan_gap_tlv->chan_gap));\n\t\t\tchan_gap_tlv->chan_gap =\n\t\t\t\t     cpu_to_le16((user_scan_in->scan_chan_gap));\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_scan_chan_gap);\n\t\t}\n\n\t\tif (!ether_addr_equal(user_scan_in->random_mac, zero_mac)) {\n\t\t\trandom_mac_tlv = (void *)tlv_pos;\n\t\t\trandom_mac_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_RANDOM_MAC);\n\t\t\trandom_mac_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(random_mac_tlv->mac));\n\t\t\tether_addr_copy(random_mac_tlv->mac,\n\t\t\t\t\tuser_scan_in->random_mac);\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_random_mac);\n\t\t}\n\t} else {\n\t\tscan_cfg_out->bss_mode = (u8) adapter->scan_mode;\n\t\tnum_probes = adapter->scan_probes;\n\t}\n\n\t/*\n\t *  If a specific BSSID or SSID is used, the number of channels in the\n\t *  scan command will be increased to the absolute maximum.\n\t */\n\tif (*filtered_scan) {\n\t\t*max_chan_per_scan = MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\t} else {\n\t\tif (!priv->media_connected)\n\t\t\t*max_chan_per_scan = MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD;\n\t\telse\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_DEF_CHANNELS_PER_SCAN_CMD / 2;\n\t}\n\n\tif (adapter->ext_scan) {\n\t\tbss_mode = (struct mwifiex_ie_types_bss_mode *)tlv_pos;\n\t\tbss_mode->header.type = cpu_to_le16(TLV_TYPE_BSS_MODE);\n\t\tbss_mode->header.len = cpu_to_le16(sizeof(bss_mode->bss_mode));\n\t\tbss_mode->bss_mode = scan_cfg_out->bss_mode;\n\t\ttlv_pos += sizeof(bss_mode->header) +\n\t\t\t   le16_to_cpu(bss_mode->header.len);\n\t}\n\n\t/* If the input config or adapter has the number of Probes set,\n\t   add tlv */\n\tif (num_probes) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: scan: num_probes = %d\\n\",\n\t\t\t    num_probes);\n\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *) tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16) num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN)) {\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) tlv_pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type =\n\t\t\tmwifiex_band_to_radio_type(priv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\t\ttlv_pos += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_SCAN, &tlv_pos);\n\n\t/*\n\t * Set the output for the channel TLV to the address in the tlv buffer\n\t *   past any TLVs that were added in this function (SSID, num_probes).\n\t *   Channel TLVs will be added past this for each scan command,\n\t *   preserving the TLVs that were previously added.\n\t */\n\t*chan_list_out =\n\t\t(struct mwifiex_ie_types_chan_list_param_set *) tlv_pos;\n\n\tif (user_scan_in && user_scan_in->chan_list[0].chan_number) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Using supplied channel list\\n\");\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_USER_SCAN_CHAN_MAX &&\n\t\t     user_scan_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\n\t\t\tchannel = user_scan_in->chan_list[chan_idx].chan_number;\n\t\t\tscan_chan_list[chan_idx].chan_number = channel;\n\n\t\t\tradio_type =\n\t\t\t\tuser_scan_in->chan_list[chan_idx].radio_type;\n\t\t\tscan_chan_list[chan_idx].radio_type = radio_type;\n\n\t\t\tscan_type = user_scan_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (user_scan_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16) user_scan_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\t\tscan_dur = adapter->passive_scan_time;\n\t\t\t\telse if (*filtered_scan)\n\t\t\t\t\tscan_dur = adapter->specific_scan_time;\n\t\t\t\telse\n\t\t\t\t\tscan_dur = adapter->active_scan_time;\n\t\t\t}\n\n\t\t\tscan_chan_list[chan_idx].min_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t}\n\n\t\t/* Check if we are only scanning the current channel */\n\t\tif ((chan_idx == 1) &&\n\t\t    (user_scan_in->chan_list[0].chan_number ==\n\t\t     priv->curr_bss_params.bss_descriptor.channel)) {\n\t\t\t*scan_current_only = true;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Scan: Scanning current channel only\\n\");\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Creating full region channel list\\n\");\n\t\tmwifiex_scan_create_channel_list(priv, user_scan_in,\n\t\t\t\t\t\t scan_chan_list,\n\t\t\t\t\t\t *filtered_scan);\n\t}\n\n}\n\n/*\n * This function inspects the scan response buffer for pointers to\n * expected TLVs.\n *\n * TLVs can be included at the end of the scan response BSS information.\n *\n * Data in the buffer is parsed pointers to TLVs that can potentially\n * be passed back in the response.\n */\nstatic void\nmwifiex_ret_802_11_scan_get_tlv_ptrs(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_ie_types_data *tlv,\n\t\t\t\t     u32 tlv_buf_size, u32 req_tlv_type,\n\t\t\t\t     struct mwifiex_ie_types_data **tlv_data)\n{\n\tstruct mwifiex_ie_types_data *current_tlv;\n\tu32 tlv_buf_left;\n\tu32 tlv_type;\n\tu32 tlv_len;\n\n\tcurrent_tlv = tlv;\n\ttlv_buf_left = tlv_buf_size;\n\t*tlv_data = NULL;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: tlv_buf_size = %d\\n\",\n\t\t    tlv_buf_size);\n\n\twhile (tlv_buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\n\t\ttlv_type = le16_to_cpu(current_tlv->header.type);\n\t\ttlv_len = le16_to_cpu(current_tlv->header.len);\n\n\t\tif (sizeof(tlv->header) + tlv_len > tlv_buf_left) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SCAN_RESP: TLV buffer corrupt\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req_tlv_type == tlv_type) {\n\t\t\tswitch (tlv_type) {\n\t\t\tcase TLV_TYPE_TSFTIMESTAMP:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: TSF\\t\"\n\t\t\t\t\t    \"timestamp TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tcase TLV_TYPE_CHANNELBANDLIST:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: channel\\t\"\n\t\t\t\t\t    \"band list TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SCAN_RESP: unhandled TLV = %d\\n\",\n\t\t\t\t\t    tlv_type);\n\t\t\t\t/* Give up, this seems corrupted */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (*tlv_data)\n\t\t\tbreak;\n\n\n\t\ttlv_buf_left -= (sizeof(tlv->header) + tlv_len);\n\t\tcurrent_tlv =\n\t\t\t(struct mwifiex_ie_types_data *) (current_tlv->data +\n\t\t\t\t\t\t\t  tlv_len);\n\n\t}\t\t\t/* while */\n}\n\n/*\n * This function parses provided beacon buffer and updates\n * respective fields in bss descriptor structure.\n */\nint mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_bssdescriptor *bss_entry)\n{\n\tint ret = 0;\n\tu8 element_id;\n\tstruct ieee_types_fh_param_set *fh_param_set;\n\tstruct ieee_types_ds_param_set *ds_param_set;\n\tstruct ieee_types_cf_param_set *cf_param_set;\n\tstruct ieee_types_ibss_param_set *ibss_param_set;\n\tu8 *current_ptr;\n\tu8 *rate;\n\tu8 element_len;\n\tu16 total_ie_len;\n\tu8 bytes_to_copy;\n\tu8 rate_size;\n\tu8 found_data_rate_ie;\n\tu32 bytes_left;\n\tstruct ieee_types_vendor_specific *vendor_ie;\n\tconst u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };\n\tconst u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };\n\n\tfound_data_rate_ie = false;\n\trate_size = 0;\n\tcurrent_ptr = bss_entry->beacon_buf;\n\tbytes_left = bss_entry->beacon_buf_size;\n\n\t/* Process variable IE */\n\twhile (bytes_left >= 2) {\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\ttotal_ie_len = element_len + sizeof(struct ieee_types_header);\n\n\t\tif (bytes_left < total_ie_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"err: InterpretIE: in processing\\t\"\n\t\t\t\t    \"IE, bytes left < IE length\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tif (element_len > IEEE80211_MAX_SSID_LEN)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->ssid.ssid_len = element_len;\n\t\t\tmemcpy(bss_entry->ssid.ssid, (current_ptr + 2),\n\t\t\t       element_len);\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: ssid: %-32s\\n\",\n\t\t\t\t    bss_entry->ssid.ssid);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\t\tif (element_len > MWIFIEX_SUPPORTED_RATES)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(bss_entry->data_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\tmemcpy(bss_entry->supported_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\trate_size = element_len;\n\t\t\tfound_data_rate_ie = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*fh_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tfh_param_set =\n\t\t\t\t(struct ieee_types_fh_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->phy_param_set.fh_param_set,\n\t\t\t       fh_param_set,\n\t\t\t       sizeof(struct ieee_types_fh_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ds_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tds_param_set =\n\t\t\t\t(struct ieee_types_ds_param_set *) current_ptr;\n\n\t\t\tbss_entry->channel = ds_param_set->current_chan;\n\n\t\t\tmemcpy(&bss_entry->phy_param_set.ds_param_set,\n\t\t\t       ds_param_set,\n\t\t\t       sizeof(struct ieee_types_ds_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*cf_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tcf_param_set =\n\t\t\t\t(struct ieee_types_cf_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.cf_param_set,\n\t\t\t       cf_param_set,\n\t\t\t       sizeof(struct ieee_types_cf_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ibss_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tibss_param_set =\n\t\t\t\t(struct ieee_types_ibss_param_set *)\n\t\t\t\tcurrent_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.ibss_param_set,\n\t\t\t       ibss_param_set,\n\t\t\t       sizeof(struct ieee_types_ibss_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->erp_flags = *(current_ptr + 2);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->local_constraint = *(current_ptr + 2);\n\t\t\tbss_entry->sensed_11h = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\t\tbss_entry->chan_sw_ie_present = true;\n\t\t\t/* fall through */\n\t\tcase WLAN_EID_PWR_CAPABILITY:\n\t\tcase WLAN_EID_TPC_REPORT:\n\t\tcase WLAN_EID_QUIET:\n\t\t\tbss_entry->sensed_11h = true;\n\t\t    break;\n\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\t/*\n\t\t\t * Only process extended supported rate\n\t\t\t * if data rate is already found.\n\t\t\t * Data rate IE should come before\n\t\t\t * extended supported rate IE\n\t\t\t */\n\t\t\tif (found_data_rate_ie) {\n\t\t\t\tif ((element_len + rate_size) >\n\t\t\t\t    MWIFIEX_SUPPORTED_RATES)\n\t\t\t\t\tbytes_to_copy =\n\t\t\t\t\t\t(MWIFIEX_SUPPORTED_RATES -\n\t\t\t\t\t\t rate_size);\n\t\t\t\telse\n\t\t\t\t\tbytes_to_copy = element_len;\n\n\t\t\t\trate = (u8 *) bss_entry->data_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\n\t\t\t\trate = (u8 *) bss_entry->supported_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tvendor_ie = (struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\n\t\t\t/* 802.11 requires at least 3-byte OUI. */\n\t\t\tif (element_len < sizeof(vendor_ie->vend_hdr.oui.oui))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Not long enough for a match? Skip it. */\n\t\t\tif (element_len < sizeof(wpa_oui))\n\t\t\t\tbreak;\n\n\t\t\tif (!memcmp(&vendor_ie->vend_hdr.oui, wpa_oui,\n\t\t\t\t    sizeof(wpa_oui))) {\n\t\t\t\tbss_entry->bcn_wpa_ie =\n\t\t\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\t\t\t\tbss_entry->wpa_offset = (u16)\n\t\t\t\t\t(current_ptr - bss_entry->beacon_buf);\n\t\t\t} else if (!memcmp(&vendor_ie->vend_hdr.oui, wmm_oui,\n\t\t\t\t    sizeof(wmm_oui))) {\n\t\t\t\tif (total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_parameter) ||\n\t\t\t\t    total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_info))\n\t\t\t\t\t/*\n\t\t\t\t\t * Only accept and copy the WMM IE if\n\t\t\t\t\t * it matches the size expected for the\n\t\t\t\t\t * WMM Info IE or the WMM Parameter IE.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy((u8 *) &bss_entry->wmm_ie,\n\t\t\t\t\t       current_ptr, total_ie_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tbss_entry->bcn_rsn_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->rsn_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_AC_ACCESS_DELAY:\n\t\t\tbss_entry->bcn_wapi_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->wapi_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tbss_entry->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t\t\t(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_cap_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\t\tbss_entry->bcn_ht_oper =\n\t\t\t\t(struct ieee80211_ht_operation *)(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_info_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tbss_entry->disable_11ac = false;\n\t\t\tbss_entry->bcn_vht_cap =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_cap_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_cap -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbss_entry->bcn_vht_oper =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_info_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_oper -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_COEX_2040:\n\t\t\tbss_entry->bcn_bss_co_2040 = current_ptr;\n\t\t\tbss_entry->bss_co_2040_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tbss_entry->bcn_ext_cap = current_ptr;\n\t\t\tbss_entry->ext_cap_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_OPMODE_NOTIF:\n\t\t\tbss_entry->oper_mode = (void *)current_ptr;\n\t\t\tbss_entry->oper_mode_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->oper_mode -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += total_ie_len;\n\t\tbytes_left -= total_ie_len;\n\n\t}\t/* while (bytes_left > 2) */\n\treturn ret;\n}\n\n/*\n * This function converts radio type scan parameter to a band configuration\n * to be used in join command.\n */\nstatic u8\nmwifiex_radio_type_to_band(u8 radio_type)\n{\n\tswitch (radio_type) {\n\tcase HostCmd_SCAN_RADIO_TYPE_A:\n\t\treturn BAND_A;\n\tcase HostCmd_SCAN_RADIO_TYPE_BG:\n\tdefault:\n\t\treturn BAND_G;\n\t}\n}\n\n/*\n * This is an internal function used to start a scan based on an input\n * configuration.\n *\n * This uses the input user scan configuration information when provided in\n * order to send the appropriate scan commands to firmware to populate or\n * update the internal driver scan table.\n */\nint mwifiex_scan_networks(struct mwifiex_private *priv,\n\t\t\t  const struct mwifiex_user_scan_cfg *user_scan_in)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tunion mwifiex_scan_cmd_config_tlv *scan_cfg_out;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_out;\n\tstruct mwifiex_chan_scan_param_set *scan_chan_list;\n\tu8 filtered_scan;\n\tu8 scan_current_chan_only;\n\tu8 max_chan_per_scan;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags) ||\n\t    test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Ignore scan. Card removed or firmware in bad state\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\tadapter->scan_processing = true;\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\tscan_cfg_out = kzalloc(sizeof(union mwifiex_scan_cmd_config_tlv),\n\t\t\t       GFP_KERNEL);\n\tif (!scan_cfg_out) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tscan_chan_list = kcalloc(MWIFIEX_USER_SCAN_CHAN_MAX,\n\t\t\t\t sizeof(struct mwifiex_chan_scan_param_set),\n\t\t\t\t GFP_KERNEL);\n\tif (!scan_chan_list) {\n\t\tkfree(scan_cfg_out);\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmwifiex_config_scan(priv, user_scan_in, &scan_cfg_out->config,\n\t\t\t    &chan_list_out, scan_chan_list, &max_chan_per_scan,\n\t\t\t    &filtered_scan, &scan_current_chan_only);\n\n\tret = mwifiex_scan_channel_list(priv, max_chan_per_scan, filtered_scan,\n\t\t\t\t\t&scan_cfg_out->config, chan_list_out,\n\t\t\t\t\tscan_chan_list);\n\n\t/* Get scan command from scan_pending_q and put to cmd_pending_q */\n\tif (!ret) {\n\t\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\t\tif (!list_empty(&adapter->scan_pending_q)) {\n\t\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\t\tlist_del(&cmd_node->list);\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\n\t\t\t/* Perform internal scan synchronously */\n\t\t\tif (!priv->scan_request) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"wait internal scan\\n\");\n\t\t\t\tmwifiex_wait_queue_complete(adapter, cmd_node);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t}\n\t}\n\n\tkfree(scan_cfg_out);\n\tkfree(scan_chan_list);\ndone:\n\tif (ret) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t}\n\treturn ret;\n}\n\n/*\n * This function prepares a scan command to be sent to the firmware.\n *\n * This uses the scan command configuration sent to the command processing\n * module in command preparation stage to configure a scan command structure\n * to send to firmware.\n *\n * The fixed fields specifying the BSS type and BSSID filters as well as a\n * variable number/length of TLVs are sent in the command to firmware.\n *\n * Preparation also includes -\n *      - Setting command ID, and proper size\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_scan(struct host_cmd_ds_command *cmd,\n\t\t\t    struct mwifiex_scan_cmd_config *scan_cfg)\n{\n\tstruct host_cmd_ds_802_11_scan *scan_cmd = &cmd->params.scan;\n\n\t/* Set fixed field variables in scan command */\n\tscan_cmd->bss_mode = scan_cfg->bss_mode;\n\tmemcpy(scan_cmd->bssid, scan_cfg->specific_bssid,\n\t       sizeof(scan_cmd->bssid));\n\tmemcpy(scan_cmd->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN);\n\n\t/* Size is equal to the sizeof(fixed portions) + the TLV len + header */\n\tcmd->size = cpu_to_le16((u16) (sizeof(scan_cmd->bss_mode)\n\t\t\t\t\t  + sizeof(scan_cmd->bssid)\n\t\t\t\t\t  + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n/*\n * This function checks compatibility of requested network with current\n * driver settings.\n */\nint mwifiex_check_network_compatibility(struct mwifiex_private *priv,\n\t\t\t\t\tstruct mwifiex_bssdescriptor *bss_desc)\n{\n\tint ret = -1;\n\n\tif (!bss_desc)\n\t\treturn -1;\n\n\tif ((mwifiex_get_cfp(priv, (u8) bss_desc->bss_band,\n\t\t\t     (u16) bss_desc->channel, 0))) {\n\t\tswitch (priv->bss_mode) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tret = mwifiex_is_network_compatible(priv, bss_desc,\n\t\t\t\t\t\t\t    priv->bss_mode);\n\t\t\tif (ret)\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Incompatible network settings\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function checks if SSID string contains all zeroes or length is zero */\nstatic bool mwifiex_is_hidden_ssid(struct cfg80211_ssid *ssid)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ssid->ssid_len; idx++) {\n\t\tif (ssid->ssid[idx])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This function checks if any hidden SSID found in passive scan channels\n * and save those channels for specific SSID active scan\n */\nstatic int mwifiex_save_hidden_ssid_channels(struct mwifiex_private *priv,\n\t\t\t\t\t     struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\tint chid;\n\n\t/* Allocate and fill new bss descriptor */\n\tbss_desc = kzalloc(sizeof(*bss_desc), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tif (mwifiex_is_hidden_ssid(&bss_desc->ssid)) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"found hidden SSID\\n\");\n\t\tfor (chid = 0 ; chid < MWIFIEX_USER_SCAN_CHAN_MAX; chid++) {\n\t\t\tif (priv->hidden_chan[chid].chan_number ==\n\t\t\t    bss->channel->hw_value)\n\t\t\t\tbreak;\n\n\t\t\tif (!priv->hidden_chan[chid].chan_number) {\n\t\t\t\tpriv->hidden_chan[chid].chan_number =\n\t\t\t\t\tbss->channel->hw_value;\n\t\t\t\tpriv->hidden_chan[chid].radio_type =\n\t\t\t\t\tbss->channel->band;\n\t\t\t\tpriv->hidden_chan[chid].scan_type =\n\t\t\t\t\tMWIFIEX_SCAN_TYPE_ACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\t/* beacon_ie buffer was allocated in function\n\t * mwifiex_fill_new_bss_desc(). Free it now.\n\t */\n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int mwifiex_update_curr_bss_params(struct mwifiex_private *priv,\n\t\t\t\t\t  struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\n\t/* Allocate and fill new bss descriptor */\n\tbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tspin_lock_bh(&priv->curr_bcn_buf_lock);\n\t/* Make a copy of current BSSID descriptor */\n\tmemcpy(&priv->curr_bss_params.bss_descriptor, bss_desc,\n\t       sizeof(priv->curr_bss_params.bss_descriptor));\n\n\t/* The contents of beacon_ie will be copied to its own buffer\n\t * in mwifiex_save_curr_bcn()\n\t */\n\tmwifiex_save_curr_bcn(priv);\n\tspin_unlock_bh(&priv->curr_bcn_buf_lock);\n\ndone:\n\t/* beacon_ie buffer was allocated in function\n\t * mwifiex_fill_new_bss_desc(). Free it now.\n\t */\n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int\nmwifiex_parse_single_response_buf(struct mwifiex_private *priv, u8 **bss_info,\n\t\t\t\t  u32 *bytes_left, u64 fw_tsf, u8 *radio_type,\n\t\t\t\t  bool ext_scan, s32 rssi_val)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_chan_freq_power *cfp;\n\tstruct cfg80211_bss *bss;\n\tu8 bssid[ETH_ALEN];\n\ts32 rssi;\n\tconst u8 *ie_buf;\n\tsize_t ie_len;\n\tu16 channel = 0;\n\tu16 beacon_size = 0;\n\tu32 curr_bcn_bytes;\n\tu32 freq;\n\tu16 beacon_period;\n\tu16 cap_info_bitmap;\n\tu8 *current_ptr;\n\tu64 timestamp;\n\tstruct mwifiex_fixed_bcn_param *bcn_param;\n\tstruct mwifiex_bss_priv *bss_priv;\n\n\tif (*bytes_left >= sizeof(beacon_size)) {\n\t\t/* Extract & convert beacon size from command buffer */\n\t\tbeacon_size = get_unaligned_le16((*bss_info));\n\t\t*bytes_left -= sizeof(beacon_size);\n\t\t*bss_info += sizeof(beacon_size);\n\t}\n\n\tif (!beacon_size || beacon_size > *bytes_left) {\n\t\t*bss_info += *bytes_left;\n\t\t*bytes_left = 0;\n\t\treturn -EFAULT;\n\t}\n\n\t/* Initialize the current working beacon pointer for this BSS\n\t * iteration\n\t */\n\tcurrent_ptr = *bss_info;\n\n\t/* Advance the return beacon pointer past the current beacon */\n\t*bss_info += beacon_size;\n\t*bytes_left -= beacon_size;\n\n\tcurr_bcn_bytes = beacon_size;\n\n\t/* First 5 fields are bssid, RSSI(for legacy scan only),\n\t * time stamp, beacon interval, and capability information\n\t */\n\tif (curr_bcn_bytes < ETH_ALEN + sizeof(u8) +\n\t    sizeof(struct mwifiex_fixed_bcn_param)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"InterpretIE: not enough bytes left\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(bssid, current_ptr, ETH_ALEN);\n\tcurrent_ptr += ETH_ALEN;\n\tcurr_bcn_bytes -= ETH_ALEN;\n\n\tif (!ext_scan) {\n\t\trssi = (s32) *current_ptr;\n\t\trssi = (-rssi) * 100;\t\t/* Convert dBm to mBm */\n\t\tcurrent_ptr += sizeof(u8);\n\t\tcurr_bcn_bytes -= sizeof(u8);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t} else {\n\t\trssi = rssi_val;\n\t}\n\n\tbcn_param = (struct mwifiex_fixed_bcn_param *)current_ptr;\n\tcurrent_ptr += sizeof(*bcn_param);\n\tcurr_bcn_bytes -= sizeof(*bcn_param);\n\n\ttimestamp = le64_to_cpu(bcn_param->timestamp);\n\tbeacon_period = le16_to_cpu(bcn_param->beacon_period);\n\n\tcap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: capabilities=0x%X\\n\",\n\t\t    cap_info_bitmap);\n\n\t/* Rest of the current buffer are IE's */\n\tie_buf = current_ptr;\n\tie_len = curr_bcn_bytes;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: IELength for this AP = %d\\n\",\n\t\t    curr_bcn_bytes);\n\n\twhile (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {\n\t\tu8 element_id, element_len;\n\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\tif (curr_bcn_bytes < element_len +\n\t\t\t\tsizeof(struct ieee_types_header)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: bytes left < IE length\\n\", __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (element_id == WLAN_EID_DS_PARAMS) {\n\t\t\tchannel = *(current_ptr +\n\t\t\t\t    sizeof(struct ieee_types_header));\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += element_len + sizeof(struct ieee_types_header);\n\t\tcurr_bcn_bytes -= element_len +\n\t\t\t\t\tsizeof(struct ieee_types_header);\n\t}\n\n\tif (channel) {\n\t\tstruct ieee80211_channel *chan;\n\t\tu8 band;\n\n\t\t/* Skip entry if on csa closed channel */\n\t\tif (channel == priv->csa_chan) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"Dropping entry on csa closed channel\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tband = BAND_G;\n\t\tif (radio_type)\n\t\t\tband = mwifiex_radio_type_to_band(*radio_type &\n\t\t\t\t\t\t\t  (BIT(0) | BIT(1)));\n\n\t\tcfp = mwifiex_get_cfp(priv, band, channel, 0);\n\n\t\tfreq = cfp ? cfp->freq : 0;\n\n\t\tchan = ieee80211_get_channel(priv->wdev.wiphy, freq);\n\n\t\tif (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\tbss = cfg80211_inform_bss(priv->wdev.wiphy,\n\t\t\t\t\t    chan, CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t    bssid, timestamp,\n\t\t\t\t\t    cap_info_bitmap, beacon_period,\n\t\t\t\t\t    ie_buf, ie_len, rssi, GFP_KERNEL);\n\t\t\tif (bss) {\n\t\t\t\tbss_priv = (struct mwifiex_bss_priv *)bss->priv;\n\t\t\t\tbss_priv->band = band;\n\t\t\t\tbss_priv->fw_tsf = fw_tsf;\n\t\t\t\tif (priv->media_connected &&\n\t\t\t\t    !memcmp(bssid, priv->curr_bss_params.\n\t\t\t\t\t    bss_descriptor.mac_address,\n\t\t\t\t\t    ETH_ALEN))\n\t\t\t\t\tmwifiex_update_curr_bss_params(priv,\n\t\t\t\t\t\t\t\t       bss);\n\n\t\t\t\tif ((chan->flags & IEEE80211_CHAN_RADAR) ||\n\t\t\t\t    (chan->flags & IEEE80211_CHAN_NO_IR)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"radar or passive channel %d\\n\",\n\t\t\t\t\t\t    channel);\n\t\t\t\t\tmwifiex_save_hidden_ssid_channels(priv,\n\t\t\t\t\t\t\t\t\t  bss);\n\t\t\t\t}\n\n\t\t\t\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, WARN, \"missing BSS channel IE\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_complete_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tadapter->survey_idx = 0;\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tadapter->cmd_wait_q.status = 0;\n\t\tif (!priv->scan_request) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"complete internal scan\\n\");\n\t\t\tmwifiex_complete_cmd(adapter, adapter->curr_cmd);\n\t\t}\n\t}\n}\n\n/* This function checks if any hidden SSID found in passive scan channels\n * and do specific SSID active scan for those channels\n */\nstatic int\nmwifiex_active_scan_req_for_passive_chan(struct mwifiex_private *priv)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 id = 0;\n\tstruct mwifiex_user_scan_cfg  *user_scan_cfg;\n\n\tif (adapter->active_scan_triggered || !priv->scan_request ||\n\t    priv->scan_aborting) {\n\t\tadapter->active_scan_triggered = false;\n\t\treturn 0;\n\t}\n\n\tif (!priv->hidden_chan[0].chan_number) {\n\t\tmwifiex_dbg(adapter, INFO, \"No BSS with hidden SSID found on DFS channels\\n\");\n\t\treturn 0;\n\t}\n\tuser_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);\n\n\tif (!user_scan_cfg)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < MWIFIEX_USER_SCAN_CHAN_MAX; id++) {\n\t\tif (!priv->hidden_chan[id].chan_number)\n\t\t\tbreak;\n\t\tmemcpy(&user_scan_cfg->chan_list[id],\n\t\t       &priv->hidden_chan[id],\n\t\t       sizeof(struct mwifiex_user_scan_chan));\n\t}\n\n\tadapter->active_scan_triggered = true;\n\tif (priv->scan_request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tether_addr_copy(user_scan_cfg->random_mac,\n\t\t\t\tpriv->scan_request->mac_addr);\n\tuser_scan_cfg->num_ssids = priv->scan_request->n_ssids;\n\tuser_scan_cfg->ssid_list = priv->scan_request->ssids;\n\n\tret = mwifiex_scan_networks(priv, user_scan_cfg);\n\tkfree(user_scan_cfg);\n\n\tmemset(&priv->hidden_chan, 0, sizeof(priv->hidden_chan));\n\n\tif (ret) {\n\t\tdev_err(priv->adapter->dev, \"scan failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nstatic void mwifiex_check_next_scan_command(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tmwifiex_active_scan_req_for_passive_chan(priv);\n\n\t\tif (!adapter->ext_scan)\n\t\t\tmwifiex_complete_scan(priv);\n\n\t\tif (priv->scan_request) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: notifying scan done\\n\");\n\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\tpriv->scan_request = NULL;\n\t\t\tpriv->scan_aborting = false;\n\t\t} else {\n\t\t\tpriv->scan_aborting = false;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t}\n\t} else if ((priv->scan_aborting && !priv->scan_request) ||\n\t\t   priv->scan_block) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tif (!adapter->active_scan_triggered) {\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t} else {\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Get scan command from scan_pending_q and put to\n\t\t * cmd_pending_q\n\t\t */\n\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\tlist_del(&cmd_node->list);\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t}\n\n\treturn;\n}\n\nvoid mwifiex_cancel_scan(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\tif (adapter->scan_processing) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (!priv)\n\t\t\t\tcontinue;\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * This function handles the command response of scan.\n *\n * The response buffer for the scan command has the following\n * memory layout:\n *\n *      .-------------------------------------------------------------.\n *      |  Header (4 * sizeof(t_u16)):  Standard command response hdr |\n *      .-------------------------------------------------------------.\n *      |  BufSize (t_u16) : sizeof the BSS Description data          |\n *      .-------------------------------------------------------------.\n *      |  NumOfSet (t_u8) : Number of BSS Descs returned             |\n *      .-------------------------------------------------------------.\n *      |  BSSDescription data (variable, size given in BufSize)      |\n *      .-------------------------------------------------------------.\n *      |  TLV data (variable, size calculated using Header->Size,    |\n *      |            BufSize and sizeof the fixed fields above)       |\n *      .-------------------------------------------------------------.\n */\nint mwifiex_ret_802_11_scan(struct mwifiex_private *priv,\n\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_rsp *scan_rsp;\n\tstruct mwifiex_ie_types_data *tlv_data;\n\tstruct mwifiex_ie_types_tsf_timestamp *tsf_tlv;\n\tu8 *bss_info;\n\tu32 scan_resp_size;\n\tu32 bytes_left;\n\tu32 idx;\n\tu32 tlv_buf_size;\n\tstruct mwifiex_ie_types_chan_band_list_param_set *chan_band_tlv;\n\tstruct chan_band_param_set *chan_band;\n\tu8 is_bgscan_resp;\n\t__le64 fw_tsf = 0;\n\tu8 *radio_type;\n\tstruct cfg80211_wowlan_nd_match *pmatch;\n\tstruct cfg80211_sched_scan_request *nd_config = NULL;\n\n\tis_bgscan_resp = (le16_to_cpu(resp->command)\n\t\t\t  == HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tif (is_bgscan_resp)\n\t\tscan_rsp = &resp->params.bg_scan_query_resp.scan_resp;\n\telse\n\t\tscan_rsp = &resp->params.scan_resp;\n\n\n\tif (scan_rsp->number_of_sets > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SCAN_RESP: too many AP returned (%d)\\n\",\n\t\t\t    scan_rsp->number_of_sets);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\t/* Check csa channel expiry before parsing scan response */\n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tbytes_left = le16_to_cpu(scan_rsp->bss_descript_size);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: bss_descript_size %d\\n\",\n\t\t    bytes_left);\n\n\tscan_resp_size = le16_to_cpu(resp->size);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: returned %d APs before parsing\\n\",\n\t\t    scan_rsp->number_of_sets);\n\n\tbss_info = scan_rsp->bss_desc_and_tlv_buffer;\n\n\t/*\n\t * The size of the TLV buffer is equal to the entire command response\n\t *   size (scan_resp_size) minus the fixed fields (sizeof()'s), the\n\t *   BSS Descriptions (bss_descript_size as bytesLef) and the command\n\t *   response header (S_DS_GEN)\n\t */\n\ttlv_buf_size = scan_resp_size - (bytes_left\n\t\t\t\t\t + sizeof(scan_rsp->bss_descript_size)\n\t\t\t\t\t + sizeof(scan_rsp->number_of_sets)\n\t\t\t\t\t + S_DS_GEN);\n\n\ttlv_data = (struct mwifiex_ie_types_data *) (scan_rsp->\n\t\t\t\t\t\t bss_desc_and_tlv_buffer +\n\t\t\t\t\t\t bytes_left);\n\n\t/* Search the TLV buffer space in the scan response for any valid\n\t   TLVs */\n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_TSFTIMESTAMP,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &tsf_tlv);\n\n\t/* Search the TLV buffer space in the scan response for any valid\n\t   TLVs */\n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_CHANNELBANDLIST,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &chan_band_tlv);\n\n#ifdef CONFIG_PM\n\tif (priv->wdev.wiphy->wowlan_config)\n\t\tnd_config = priv->wdev.wiphy->wowlan_config->nd_config;\n#endif\n\n\tif (nd_config) {\n\t\tadapter->nd_info =\n\t\t\tkzalloc(sizeof(struct cfg80211_wowlan_nd_match) +\n\t\t\t\tsizeof(struct cfg80211_wowlan_nd_match *) *\n\t\t\t\tscan_rsp->number_of_sets, GFP_ATOMIC);\n\n\t\tif (adapter->nd_info)\n\t\t\tadapter->nd_info->n_matches = scan_rsp->number_of_sets;\n\t}\n\n\tfor (idx = 0; idx < scan_rsp->number_of_sets && bytes_left; idx++) {\n\t\t/*\n\t\t * If the TSF TLV was appended to the scan results, save this\n\t\t * entry's TSF value in the fw_tsf field. It is the firmware's\n\t\t * TSF value at the time the beacon or probe response was\n\t\t * received.\n\t\t */\n\t\tif (tsf_tlv)\n\t\t\tmemcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],\n\t\t\t       sizeof(fw_tsf));\n\n\t\tif (chan_band_tlv) {\n\t\t\tchan_band = &chan_band_tlv->chan_band_param[idx];\n\t\t\tradio_type = &chan_band->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\n\t\tif (chan_band_tlv && adapter->nd_info) {\n\t\t\tadapter->nd_info->matches[idx] =\n\t\t\t\tkzalloc(sizeof(*pmatch) + sizeof(u32),\n\t\t\t\t\tGFP_ATOMIC);\n\n\t\t\tpmatch = adapter->nd_info->matches[idx];\n\n\t\t\tif (pmatch) {\n\t\t\t\tpmatch->n_channels = 1;\n\t\t\t\tpmatch->channels[0] = chan_band->chan_number;\n\t\t\t}\n\t\t}\n\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left,\n\t\t\t\t\t\t\tle64_to_cpu(fw_tsf),\n\t\t\t\t\t\t\tradio_type, false, 0);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tmwifiex_check_next_scan_command(priv);\n\treturn ret;\n}\n\n/*\n * This function prepares an extended scan command to be sent to the firmware\n *\n * This uses the scan command configuration sent to the command processing\n * module in command preparation stage to configure a extended scan command\n * structure to send to firmware.\n */\nint mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tvoid *data_buf)\n{\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan = &cmd->params.ext_scan;\n\tstruct mwifiex_scan_cmd_config *scan_cfg = data_buf;\n\n\tmemcpy(ext_scan->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN_EXT);\n\n\t/* Size is equal to the sizeof(fixed portions) + the TLV len + header */\n\tcmd->size = cpu_to_le16((u16)(sizeof(ext_scan->reserved)\n\t\t\t\t      + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n/* This function prepares an background scan config command to be sent\n * to the firmware\n */\nint mwifiex_cmd_802_11_bg_scan_config(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd,\n\t\t\t\t      void *data_buf)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_config *bgscan_config =\n\t\t\t\t\t&cmd->params.bg_scan_config;\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg_in = data_buf;\n\tu8 *tlv_pos = bgscan_config->tlv;\n\tu8 num_probes;\n\tu32 ssid_len, chan_idx, scan_type, scan_dur, chan_num;\n\tint i;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_repeat_count *repeat_count_tlv;\n\tstruct mwifiex_ie_types_min_rssi_threshold *rssi_threshold_tlv;\n\tstruct mwifiex_ie_types_bgscan_start_later *start_later_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_tlv;\n\tstruct mwifiex_chan_scan_param_set *temp_chan;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);\n\tcmd->size = cpu_to_le16(sizeof(*bgscan_config) + S_DS_GEN);\n\n\tbgscan_config->action = cpu_to_le16(bgscan_cfg_in->action);\n\tbgscan_config->enable = bgscan_cfg_in->enable;\n\tbgscan_config->bss_type = bgscan_cfg_in->bss_type;\n\tbgscan_config->scan_interval =\n\t\tcpu_to_le32(bgscan_cfg_in->scan_interval);\n\tbgscan_config->report_condition =\n\t\tcpu_to_le32(bgscan_cfg_in->report_condition);\n\n\t/*  stop sched scan  */\n\tif (!bgscan_config->enable)\n\t\treturn 0;\n\n\tbgscan_config->chan_per_scan = bgscan_cfg_in->chan_per_scan;\n\n\tnum_probes = (bgscan_cfg_in->num_probes ? bgscan_cfg_in->\n\t\t      num_probes : priv->adapter->scan_probes);\n\n\tif (num_probes) {\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *)tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16)num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->repeat_count) {\n\t\trepeat_count_tlv =\n\t\t\t(struct mwifiex_ie_types_repeat_count *)tlv_pos;\n\t\trepeat_count_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_REPEAT_COUNT);\n\t\trepeat_count_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(repeat_count_tlv->repeat_count));\n\t\trepeat_count_tlv->repeat_count =\n\t\t\tcpu_to_le16(bgscan_cfg_in->repeat_count);\n\n\t\ttlv_pos += sizeof(repeat_count_tlv->header) +\n\t\t\tle16_to_cpu(repeat_count_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->rssi_threshold) {\n\t\trssi_threshold_tlv =\n\t\t\t(struct mwifiex_ie_types_min_rssi_threshold *)tlv_pos;\n\t\trssi_threshold_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_RSSI_LOW);\n\t\trssi_threshold_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(rssi_threshold_tlv->rssi_threshold));\n\t\trssi_threshold_tlv->rssi_threshold =\n\t\t\tcpu_to_le16(bgscan_cfg_in->rssi_threshold);\n\n\t\ttlv_pos += sizeof(rssi_threshold_tlv->header) +\n\t\t\tle16_to_cpu(rssi_threshold_tlv->header.len);\n\t}\n\n\tfor (i = 0; i < bgscan_cfg_in->num_ssids; i++) {\n\t\tssid_len = bgscan_cfg_in->ssid_list[i].ssid.ssid_len;\n\n\t\twildcard_ssid_tlv =\n\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)tlv_pos;\n\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16)(ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t/* max_ssid_length = 0 tells firmware to perform\n\t\t * specific scan for the SSID filled, whereas\n\t\t * max_ssid_length = IEEE80211_MAX_SSID_LEN is for\n\t\t * wildcard scan.\n\t\t */\n\t\tif (ssid_len)\n\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\telse\n\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t       bgscan_cfg_in->ssid_list[i].ssid.ssid, ssid_len);\n\n\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\t}\n\n\tchan_list_tlv = (struct mwifiex_ie_types_chan_list_param_set *)tlv_pos;\n\n\tif (bgscan_cfg_in->chan_list[0].chan_number) {\n\t\tdev_dbg(priv->adapter->dev, \"info: bgscan: Using supplied channel list\\n\");\n\n\t\tchan_list_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_BG_SCAN_CHAN_MAX &&\n\t\t     bgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\t\t\ttemp_chan = chan_list_tlv->chan_scan_param + chan_idx;\n\n\t\t\t/* Increment the TLV header length by size appended */\n\t\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t       chan_list_tlv->chan_scan_param));\n\n\t\t\ttemp_chan->chan_number =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t\ttemp_chan->radio_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].radio_type;\n\n\t\t\tscan_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tif (bgscan_cfg_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tscan_dur = (scan_type ==\n\t\t\t\t\t    MWIFIEX_SCAN_TYPE_PASSIVE) ?\n\t\t\t\t\t    priv->adapter->passive_scan_time :\n\t\t\t\t\t    priv->adapter->specific_scan_time;\n\t\t\t}\n\n\t\t\ttemp_chan->min_scan_time = cpu_to_le16(scan_dur);\n\t\t\ttemp_chan->max_scan_time = cpu_to_le16(scan_dur);\n\t\t}\n\t} else {\n\t\tdev_dbg(priv->adapter->dev,\n\t\t\t\"info: bgscan: Creating full region channel list\\n\");\n\t\tchan_num =\n\t\t\tmwifiex_bgscan_create_channel_list(priv, bgscan_cfg_in,\n\t\t\t\t\t\t\t   chan_list_tlv->\n\t\t\t\t\t\t\t   chan_scan_param);\n\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t       chan_num *\n\t\t\t     sizeof(chan_list_tlv->chan_scan_param[0]));\n\t}\n\n\ttlv_pos += (sizeof(chan_list_tlv->header)\n\t\t\t+ le16_to_cpu(chan_list_tlv->header.len));\n\n\tif (bgscan_cfg_in->start_later) {\n\t\tstart_later_tlv =\n\t\t\t(struct mwifiex_ie_types_bgscan_start_later *)tlv_pos;\n\t\tstart_later_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_BGSCAN_START_LATER);\n\t\tstart_later_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(start_later_tlv->start_later));\n\t\tstart_later_tlv->start_later =\n\t\t\tcpu_to_le16(bgscan_cfg_in->start_later);\n\n\t\ttlv_pos += sizeof(start_later_tlv->header) +\n\t\t\tle16_to_cpu(start_later_tlv->header.len);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_BGSCAN, &tlv_pos);\n\n\tle16_unaligned_add_cpu(&cmd->size, tlv_pos - bgscan_config->tlv);\n\n\treturn 0;\n}\n\nint mwifiex_stop_bg_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg;\n\n\tif (!priv->sched_scanning) {\n\t\tdev_dbg(priv->adapter->dev, \"bgscan already stopped!\\n\");\n\t\treturn 0;\n\t}\n\n\tbgscan_cfg = kzalloc(sizeof(*bgscan_cfg), GFP_KERNEL);\n\tif (!bgscan_cfg)\n\t\treturn -ENOMEM;\n\n\tbgscan_cfg->bss_type = MWIFIEX_BSS_MODE_INFRA;\n\tbgscan_cfg->action = MWIFIEX_BGSCAN_ACT_SET;\n\tbgscan_cfg->enable = false;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, bgscan_cfg, true)) {\n\t\tkfree(bgscan_cfg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(bgscan_cfg);\n\tpriv->sched_scanning = false;\n\n\treturn 0;\n}\n\nstatic void\nmwifiex_update_chan_statistics(struct mwifiex_private *priv,\n\t\t\t       struct mwifiex_ietypes_chanstats *tlv_stat)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 i, num_chan;\n\tstruct mwifiex_fw_chan_stats *fw_chan_stats;\n\tstruct mwifiex_chan_stats chan_stats;\n\n\tfw_chan_stats = (void *)((u8 *)tlv_stat +\n\t\t\t      sizeof(struct mwifiex_ie_types_header));\n\tnum_chan = le16_to_cpu(tlv_stat->header.len) /\n\t\t\t\t\t      sizeof(struct mwifiex_chan_stats);\n\n\tfor (i = 0 ; i < num_chan; i++) {\n\t\tif (adapter->survey_idx >= adapter->num_in_chan_stats) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"FW reported too many channel results (max %d)\\n\",\n\t\t\t\t    adapter->num_in_chan_stats);\n\t\t\treturn;\n\t\t}\n\t\tchan_stats.chan_num = fw_chan_stats->chan_num;\n\t\tchan_stats.bandcfg = fw_chan_stats->bandcfg;\n\t\tchan_stats.flags = fw_chan_stats->flags;\n\t\tchan_stats.noise = fw_chan_stats->noise;\n\t\tchan_stats.total_bss = le16_to_cpu(fw_chan_stats->total_bss);\n\t\tchan_stats.cca_scan_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_scan_dur);\n\t\tchan_stats.cca_busy_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_busy_dur);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"chan=%d, noise=%d, total_network=%d scan_duration=%d, busy_duration=%d\\n\",\n\t\t\t    chan_stats.chan_num,\n\t\t\t    chan_stats.noise,\n\t\t\t    chan_stats.total_bss,\n\t\t\t    chan_stats.cca_scan_dur,\n\t\t\t    chan_stats.cca_busy_dur);\n\t\tmemcpy(&adapter->chan_stats[adapter->survey_idx++], &chan_stats,\n\t\t       sizeof(struct mwifiex_chan_stats));\n\t\tfw_chan_stats++;\n\t}\n}\n\n/* This function handles the command response of extended scan */\nint mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan_resp;\n\tstruct mwifiex_ie_types_header *tlv;\n\tstruct mwifiex_ietypes_chanstats *tlv_stat;\n\tu16 buf_left, type, len;\n\n\tstruct host_cmd_ds_command *cmd_ptr;\n\tstruct cmd_ctrl_node *cmd_node;\n\tbool complete_scan = false;\n\n\tmwifiex_dbg(adapter, INFO, \"info: EXT scan returns successfully\\n\");\n\n\text_scan_resp = &resp->params.ext_scan;\n\n\ttlv = (void *)ext_scan_resp->tlv_buffer;\n\tbuf_left = le16_to_cpu(resp->size) - (sizeof(*ext_scan_resp) + S_DS_GEN\n\t\t\t\t\t      - 1);\n\n\twhile (buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\t\ttype = le16_to_cpu(tlv->type);\n\t\tlen = le16_to_cpu(tlv->len);\n\n\t\tif (buf_left < (sizeof(struct mwifiex_ie_types_header) + len)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"error processing scan response TLVs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase TLV_TYPE_CHANNEL_STATS:\n\t\t\ttlv_stat = (void *)tlv;\n\t\t\tmwifiex_update_chan_statistics(priv, tlv_stat);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_left -= len + sizeof(struct mwifiex_ie_types_header);\n\t\ttlv = (void *)((u8 *)tlv + len +\n\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\t}\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tcomplete_scan = true;\n\t\tlist_for_each_entry(cmd_node, &adapter->cmd_pending_q, list) {\n\t\t\tcmd_ptr = (void *)cmd_node->cmd_skb->data;\n\t\t\tif (le16_to_cpu(cmd_ptr->command) ==\n\t\t\t    HostCmd_CMD_802_11_SCAN_EXT) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"Scan pending in command pending list\");\n\t\t\t\tcomplete_scan = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\tif (complete_scan)\n\t\tmwifiex_complete_scan(priv);\n\n\treturn 0;\n}\n\n/* This function This function handles the event extended scan report. It\n * parses extended scan results and informs to cfg80211 stack.\n */\nint mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,\n\t\t\t\t\t void *buf)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 *bss_info;\n\tu32 bytes_left, bytes_left_for_tlv, idx;\n\tu16 type, len;\n\tstruct mwifiex_ie_types_data *tlv;\n\tstruct mwifiex_ie_types_bss_scan_rsp *scan_rsp_tlv;\n\tstruct mwifiex_ie_types_bss_scan_info *scan_info_tlv;\n\tu8 *radio_type;\n\tu64 fw_tsf = 0;\n\ts32 rssi = 0;\n\tstruct mwifiex_event_scan_result *event_scan = buf;\n\tu8 num_of_set = event_scan->num_of_set;\n\tu8 *scan_resp = buf + sizeof(struct mwifiex_event_scan_result);\n\tu16 scan_resp_size = le16_to_cpu(event_scan->buf_size);\n\n\tif (num_of_set > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EXT_SCAN: Invalid number of AP returned (%d)!!\\n\",\n\t\t\t    num_of_set);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\tbytes_left = scan_resp_size;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"EXT_SCAN: size %d, returned %d APs...\",\n\t\t    scan_resp_size, num_of_set);\n\tmwifiex_dbg_dump(adapter, CMD_D, \"EXT_SCAN buffer:\", buf,\n\t\t\t scan_resp_size +\n\t\t\t sizeof(struct mwifiex_event_scan_result));\n\n\ttlv = (struct mwifiex_ie_types_data *)scan_resp;\n\n\tfor (idx = 0; idx < num_of_set && bytes_left; idx++) {\n\t\ttype = le16_to_cpu(tlv->header.type);\n\t\tlen = le16_to_cpu(tlv->header.len);\n\t\tif (bytes_left < sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"EXT_SCAN: Error bytes left < TLV length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tscan_rsp_tlv = NULL;\n\t\tscan_info_tlv = NULL;\n\t\tbytes_left_for_tlv = bytes_left;\n\n\t\t/* BSS response TLV with beacon or probe response buffer\n\t\t * at the initial position of each descriptor\n\t\t */\n\t\tif (type != TLV_TYPE_BSS_SCAN_RSP)\n\t\t\tbreak;\n\n\t\tbss_info = (u8 *)tlv;\n\t\tscan_rsp_tlv = (struct mwifiex_ie_types_bss_scan_rsp *)tlv;\n\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\n\t\twhile (bytes_left_for_tlv >=\n\t\t       sizeof(struct mwifiex_ie_types_header) &&\n\t\t       le16_to_cpu(tlv->header.type) != TLV_TYPE_BSS_SCAN_RSP) {\n\t\t\ttype = le16_to_cpu(tlv->header.type);\n\t\t\tlen = le16_to_cpu(tlv->header.len);\n\t\t\tif (bytes_left_for_tlv <\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"EXT_SCAN: Error in processing TLV,\\t\"\n\t\t\t\t\t    \"bytes left < TLV length\\n\");\n\t\t\t\tscan_rsp_tlv = NULL;\n\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (type) {\n\t\t\tcase TLV_TYPE_BSS_SCAN_INFO:\n\t\t\t\tscan_info_tlv =\n\t\t\t\t  (struct mwifiex_ie_types_bss_scan_info *)tlv;\n\t\t\t\tif (len !=\n\t\t\t\t sizeof(struct mwifiex_ie_types_bss_scan_info) -\n\t\t\t\t sizeof(struct mwifiex_ie_types_header)) {\n\t\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\t\tbytes_left -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t}\n\n\t\tif (!scan_rsp_tlv)\n\t\t\tbreak;\n\n\t\t/* Advance pointer to the beacon buffer length and\n\t\t * update the bytes count so that the function\n\t\t * wlan_interpret_bss_desc_with_ie() can handle the\n\t\t * scan buffer withut any change\n\t\t */\n\t\tbss_info += sizeof(u16);\n\t\tbytes_left -= sizeof(u16);\n\n\t\tif (scan_info_tlv) {\n\t\t\trssi = (s32)(s16)(le16_to_cpu(scan_info_tlv->rssi));\n\t\t\trssi *= 100;           /* Convert dBm to mBm */\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t\t\tfw_tsf = le64_to_cpu(scan_info_tlv->tsf);\n\t\t\tradio_type = &scan_info_tlv->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left, fw_tsf,\n\t\t\t\t\t\t\tradio_type, true, rssi);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tif (!event_scan->more_event)\n\t\tmwifiex_check_next_scan_command(priv);\n\n\treturn ret;\n}\n\n/*\n * This function prepares command for background scan query.\n *\n * Preparation includes -\n *      - Setting command ID and proper size\n *      - Setting background scan flush parameter\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_bg_scan_query(struct host_cmd_ds_command *cmd)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_query *bg_query =\n\t\t&cmd->params.bg_scan_query;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_bg_scan_query)\n\t\t\t\t+ S_DS_GEN);\n\n\tbg_query->flush = 1;\n\n\treturn 0;\n}\n\n/*\n * This function inserts scan command node to the scan pending queue.\n */\nvoid\nmwifiex_queue_scan_cmd(struct mwifiex_private *priv,\n\t\t       struct cmd_ctrl_node *cmd_node)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tcmd_node->wait_q_enabled = true;\n\tcmd_node->condition = &adapter->scan_wait_q_woken;\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tlist_add_tail(&cmd_node->list, &adapter->scan_pending_q);\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n}\n\n/*\n * This function sends a scan command for all available channels to the\n * firmware, filtered on a specific SSID.\n */\nstatic int mwifiex_scan_specific_ssid(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_ssid *req_ssid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct mwifiex_user_scan_cfg *scan_cfg;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tscan_cfg = kzalloc(sizeof(struct mwifiex_user_scan_cfg), GFP_KERNEL);\n\tif (!scan_cfg)\n\t\treturn -ENOMEM;\n\n\tscan_cfg->ssid_list = req_ssid;\n\tscan_cfg->num_ssids = 1;\n\n\tret = mwifiex_scan_networks(priv, scan_cfg);\n\n\tkfree(scan_cfg);\n\treturn ret;\n}\n\n/*\n * Sends IOCTL request to start a scan.\n *\n * This function allocates the IOCTL request buffer, fills it\n * with requisite parameters and calls the IOCTL handler.\n *\n * Scan command can be issued for both normal scan and specific SSID\n * scan, depending upon whether an SSID is provided or not.\n */\nint mwifiex_request_scan(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_ssid *req_ssid)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&priv->async_mutex)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: acquire semaphore fail\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tpriv->adapter->scan_wait_q_woken = false;\n\n\tif (req_ssid && req_ssid->ssid_len != 0)\n\t\t/* Specific SSID scan */\n\t\tret = mwifiex_scan_specific_ssid(priv, req_ssid);\n\telse\n\t\t/* Normal scan */\n\t\tret = mwifiex_scan_networks(priv, NULL);\n\n\tmutex_unlock(&priv->async_mutex);\n\n\treturn ret;\n}\n\n/*\n * This function appends the vendor specific IE TLV to a buffer.\n */\nint\nmwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * Traverse through the saved vendor specific IE array and append\n\t * the selected(scan/assoc/adhoc) IE as TLV to the command\n\t */\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}\n\n/*\n * This function saves a beacon buffer of the current BSS descriptor.\n *\n * The current beacon buffer is saved so that it can be restored in the\n * following cases that makes the beacon buffer not to contain the current\n * ssid's beacon buffer.\n *      - The current ssid was not found somehow in the last scan.\n *      - The current ssid was the last entry of the scan table and overloaded.\n */\nvoid\nmwifiex_save_curr_bcn(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bssdescriptor *curr_bss =\n\t\t&priv->curr_bss_params.bss_descriptor;\n\n\tif (!curr_bss->beacon_buf_size)\n\t\treturn;\n\n\t/* allocate beacon buffer at 1st time; or if it's size has changed */\n\tif (!priv->curr_bcn_buf ||\n\t    priv->curr_bcn_size != curr_bss->beacon_buf_size) {\n\t\tpriv->curr_bcn_size = curr_bss->beacon_buf_size;\n\n\t\tkfree(priv->curr_bcn_buf);\n\t\tpriv->curr_bcn_buf = kmalloc(curr_bss->beacon_buf_size,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!priv->curr_bcn_buf)\n\t\t\treturn;\n\t}\n\n\tmemcpy(priv->curr_bcn_buf, curr_bss->beacon_buf,\n\t       curr_bss->beacon_buf_size);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: current beacon saved %d\\n\",\n\t\t    priv->curr_bcn_size);\n\n\tcurr_bss->beacon_buf = priv->curr_bcn_buf;\n\n\t/* adjust the pointers in the current BSS descriptor */\n\tif (curr_bss->bcn_wpa_ie)\n\t\tcurr_bss->bcn_wpa_ie =\n\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->wpa_offset);\n\n\tif (curr_bss->bcn_rsn_ie)\n\t\tcurr_bss->bcn_rsn_ie = (struct ieee_types_generic *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->rsn_offset);\n\n\tif (curr_bss->bcn_ht_cap)\n\t\tcurr_bss->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_cap_offset);\n\n\tif (curr_bss->bcn_ht_oper)\n\t\tcurr_bss->bcn_ht_oper = (struct ieee80211_ht_operation *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_info_offset);\n\n\tif (curr_bss->bcn_vht_cap)\n\t\tcurr_bss->bcn_vht_cap = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t curr_bss->vht_cap_offset);\n\n\tif (curr_bss->bcn_vht_oper)\n\t\tcurr_bss->bcn_vht_oper = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t  curr_bss->vht_info_offset);\n\n\tif (curr_bss->bcn_bss_co_2040)\n\t\tcurr_bss->bcn_bss_co_2040 =\n\t\t\t(curr_bss->beacon_buf + curr_bss->bss_co_2040_offset);\n\n\tif (curr_bss->bcn_ext_cap)\n\t\tcurr_bss->bcn_ext_cap = curr_bss->beacon_buf +\n\t\t\tcurr_bss->ext_cap_offset;\n\n\tif (curr_bss->oper_mode)\n\t\tcurr_bss->oper_mode = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t       curr_bss->oper_mode_offset);\n}\n\n/*\n * This function frees the current BSS descriptor beacon buffer.\n */\nvoid\nmwifiex_free_curr_bcn(struct mwifiex_private *priv)\n{\n\tkfree(priv->curr_bcn_buf);\n\tpriv->curr_bcn_buf = NULL;\n}\n"], "filenames": ["drivers/net/wireless/marvell/mwifiex/scan.c"], "buggy_code_start_loc": [2886], "buggy_code_end_loc": [2886], "fixing_code_start_loc": [2887], "fixing_code_end_loc": [2894], "type": "CWE-787", "message": "An issue was found in Linux kernel before 5.5.4. The mwifiex_cmd_append_vsie_tlv() function in drivers/net/wireless/marvell/mwifiex/scan.c allows local users to gain privileges or cause a denial of service because of an incorrect memcpy and buffer overflow, aka CID-b70261a288ea.", "other": {"cve": {"id": "CVE-2020-12653", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-05T06:15:11.043", "lastModified": "2022-04-26T17:37:33.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was found in Linux kernel before 5.5.4. The mwifiex_cmd_append_vsie_tlv() function in drivers/net/wireless/marvell/mwifiex/scan.c allows local users to gain privileges or cause a denial of service because of an incorrect memcpy and buffer overflow, aka CID-b70261a288ea."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.5.4. La funci\u00f3n mwifiex_cmd_append_vsie_tlv() en el archivo drivers/net/wireless/marvell/mwifiex/scan.c permite a usuarios locales alcanzar privilegios o causar una denegaci\u00f3n de servicio debido a una memcpy incorrecta y al desbordamiento del b\u00fafer, tambi\u00e9n se conoce como CID-b70261a288ea."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.4", "matchCriteriaId": "25611CC0-E1DB-4D7B-82DF-D16CB8355844"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FDD92BFA-9117-4E6E-A13F-ED064B4B7284"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "4B7DA42F-5D64-4967-A2D4-6210FE507841"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89612649-BACF-4FAC-9BA4-324724FD93A6"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610c:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3D9B255-C1AF-42D1-BF9B-13642FBDC080"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h615c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "5921A877-18BF-43FE-915C-D226E140ACFC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h615c:-:*:*:*:*:*:*:*", "matchCriteriaId": "7296A1F2-D315-4FD5-8A73-65C480C855BE"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/05/08/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.5.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200608-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d"}}