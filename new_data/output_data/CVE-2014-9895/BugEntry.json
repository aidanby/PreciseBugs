{"buggy_code": ["/*\n * Media device\n *\n * Copyright (C) 2010 Nokia Corporation\n *\n * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\n *\t     Sakari Ailus <sakari.ailus@iki.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/ioctl.h>\n#include <linux/media.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/media-devnode.h>\n#include <media/media-entity.h>\n\n/* -----------------------------------------------------------------------------\n * Userspace API\n */\n\nstatic int media_device_open(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_close(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_get_info(struct media_device *dev,\n\t\t\t\t struct media_device_info __user *__info)\n{\n\tstruct media_device_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tstrlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver));\n\tstrlcpy(info.model, dev->model, sizeof(info.model));\n\tstrlcpy(info.serial, dev->serial, sizeof(info.serial));\n\tstrlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info));\n\n\tinfo.media_version = MEDIA_API_VERSION;\n\tinfo.hw_revision = dev->hw_revision;\n\tinfo.driver_version = dev->driver_version;\n\n\tif (copy_to_user(__info, &info, sizeof(*__info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\n{\n\tstruct media_entity *entity;\n\tint next = id & MEDIA_ENT_ID_FLAG_NEXT;\n\n\tid &= ~MEDIA_ENT_ID_FLAG_NEXT;\n\n\tspin_lock(&mdev->lock);\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif ((entity->id == id && !next) ||\n\t\t    (entity->id > id && next)) {\n\t\t\tspin_unlock(&mdev->lock);\n\t\t\treturn entity;\n\t\t}\n\t}\n\n\tspin_unlock(&mdev->lock);\n\n\treturn NULL;\n}\n\nstatic long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = kpad->entity->id;\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}\n\nstatic long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t/* Ignore backlinks. */\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long media_device_enum_links(struct media_device *mdev,\n\t\t\t\t    struct media_links_enum __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tint rval;\n\n\tif (copy_from_user(&links, ulinks, sizeof(links)))\n\t\treturn -EFAULT;\n\n\trval = __media_device_enum_links(mdev, &links);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (copy_to_user(ulinks, &links, sizeof(*ulinks)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long media_device_setup_link(struct media_device *mdev,\n\t\t\t\t    struct media_link_desc __user *_ulink)\n{\n\tstruct media_link *link = NULL;\n\tstruct media_link_desc ulink;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tint ret;\n\n\tif (copy_from_user(&ulink, _ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\t/* Find the source and sink entities and link.\n\t */\n\tsource = find_entity(mdev, ulink.source.entity);\n\tsink = find_entity(mdev, ulink.sink.entity);\n\n\tif (source == NULL || sink == NULL)\n\t\treturn -EINVAL;\n\n\tif (ulink.source.index >= source->num_pads ||\n\t    ulink.sink.index >= sink->num_pads)\n\t\treturn -EINVAL;\n\n\tlink = media_entity_find_link(&source->pads[ulink.source.index],\n\t\t\t\t      &sink->pads[ulink.sink.index]);\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\t/* Setup the link on both entities. */\n\tret = __media_entity_setup_link(link, ulink.flags);\n\n\tif (copy_to_user(_ulink, &ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\t\tret = media_device_get_info(dev,\n\t\t\t\t(struct media_device_info __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\t\tret = media_device_enum_entities(dev,\n\t\t\t\t(struct media_entity_desc __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_LINKS:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links(dev,\n\t\t\t\t(struct media_links_enum __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_setup_link(dev,\n\t\t\t\t(struct media_link_desc __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct media_links_enum32 {\n\t__u32 entity;\n\tcompat_uptr_t pads; /* struct media_pad_desc * */\n\tcompat_uptr_t links; /* struct media_link_desc * */\n\t__u32 reserved[4];\n};\n\nstatic long media_device_enum_links32(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum32 __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tcompat_uptr_t pads_ptr, links_ptr;\n\n\tmemset(&links, 0, sizeof(links));\n\n\tif (get_user(links.entity, &ulinks->entity)\n\t    || get_user(pads_ptr, &ulinks->pads)\n\t    || get_user(links_ptr, &ulinks->links))\n\t\treturn -EFAULT;\n\n\tlinks.pads = compat_ptr(pads_ptr);\n\tlinks.links = compat_ptr(links_ptr);\n\n\treturn __media_device_enum_links(mdev, &links);\n}\n\n#define MEDIA_IOC_ENUM_LINKS32\t\t_IOWR('|', 0x02, struct media_links_enum32)\n\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\treturn media_device_ioctl(filp, cmd, arg);\n\n\tcase MEDIA_IOC_ENUM_LINKS32:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links32(dev,\n\t\t\t\t(struct media_links_enum32 __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_COMPAT */\n\nstatic const struct media_file_operations media_device_fops = {\n\t.owner = THIS_MODULE,\n\t.open = media_device_open,\n\t.ioctl = media_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_device_compat_ioctl,\n#endif /* CONFIG_COMPAT */\n\t.release = media_device_close,\n};\n\n/* -----------------------------------------------------------------------------\n * sysfs\n */\n\nstatic ssize_t show_model(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct media_device *mdev = to_media_device(to_media_devnode(cd));\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(mdev->model), mdev->model);\n}\n\nstatic DEVICE_ATTR(model, S_IRUGO, show_model, NULL);\n\n/* -----------------------------------------------------------------------------\n * Registration/unregistration\n */\n\nstatic void media_device_release(struct media_devnode *mdev)\n{\n}\n\n/**\n * media_device_register - register a media device\n * @mdev:\tThe media device\n *\n * The caller is responsible for initializing the media device before\n * registration. The following fields must be set:\n *\n * - dev must point to the parent device\n * - model must be filled with the device model name\n */\nint __must_check media_device_register(struct media_device *mdev)\n{\n\tint ret;\n\n\tif (WARN_ON(mdev->dev == NULL || mdev->model[0] == 0))\n\t\treturn -EINVAL;\n\n\tmdev->entity_id = 1;\n\tINIT_LIST_HEAD(&mdev->entities);\n\tspin_lock_init(&mdev->lock);\n\tmutex_init(&mdev->graph_mutex);\n\n\t/* Register the device node. */\n\tmdev->devnode.fops = &media_device_fops;\n\tmdev->devnode.parent = mdev->dev;\n\tmdev->devnode.release = media_device_release;\n\tret = media_devnode_register(&mdev->devnode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&mdev->devnode.dev, &dev_attr_model);\n\tif (ret < 0) {\n\t\tmedia_devnode_unregister(&mdev->devnode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register);\n\n/**\n * media_device_unregister - unregister a media device\n * @mdev:\tThe media device\n *\n */\nvoid media_device_unregister(struct media_device *mdev)\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *next;\n\n\tlist_for_each_entry_safe(entity, next, &mdev->entities, list)\n\t\tmedia_device_unregister_entity(entity);\n\n\tdevice_remove_file(&mdev->devnode.dev, &dev_attr_model);\n\tmedia_devnode_unregister(&mdev->devnode);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister);\n\n/**\n * media_device_register_entity - Register an entity with a media device\n * @mdev:\tThe media device\n * @entity:\tThe entity\n */\nint __must_check media_device_register_entity(struct media_device *mdev,\n\t\t\t\t\t      struct media_entity *entity)\n{\n\t/* Warn if we apparently re-register an entity */\n\tWARN_ON(entity->parent != NULL);\n\tentity->parent = mdev;\n\n\tspin_lock(&mdev->lock);\n\tif (entity->id == 0)\n\t\tentity->id = mdev->entity_id++;\n\telse\n\t\tmdev->entity_id = max(entity->id + 1, mdev->entity_id);\n\tlist_add_tail(&entity->list, &mdev->entities);\n\tspin_unlock(&mdev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity);\n\n/**\n * media_device_unregister_entity - Unregister an entity\n * @entity:\tThe entity\n *\n * If the entity has never been registered this function will return\n * immediately.\n */\nvoid media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->parent;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tspin_lock(&mdev->lock);\n\tlist_del(&entity->list);\n\tspin_unlock(&mdev->lock);\n\tentity->parent = NULL;\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity);\n"], "fixing_code": ["/*\n * Media device\n *\n * Copyright (C) 2010 Nokia Corporation\n *\n * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\n *\t     Sakari Ailus <sakari.ailus@iki.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/ioctl.h>\n#include <linux/media.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/media-devnode.h>\n#include <media/media-entity.h>\n\n/* -----------------------------------------------------------------------------\n * Userspace API\n */\n\nstatic int media_device_open(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_close(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_get_info(struct media_device *dev,\n\t\t\t\t struct media_device_info __user *__info)\n{\n\tstruct media_device_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tstrlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver));\n\tstrlcpy(info.model, dev->model, sizeof(info.model));\n\tstrlcpy(info.serial, dev->serial, sizeof(info.serial));\n\tstrlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info));\n\n\tinfo.media_version = MEDIA_API_VERSION;\n\tinfo.hw_revision = dev->hw_revision;\n\tinfo.driver_version = dev->driver_version;\n\n\tif (copy_to_user(__info, &info, sizeof(*__info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\n{\n\tstruct media_entity *entity;\n\tint next = id & MEDIA_ENT_ID_FLAG_NEXT;\n\n\tid &= ~MEDIA_ENT_ID_FLAG_NEXT;\n\n\tspin_lock(&mdev->lock);\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif ((entity->id == id && !next) ||\n\t\t    (entity->id > id && next)) {\n\t\t\tspin_unlock(&mdev->lock);\n\t\t\treturn entity;\n\t\t}\n\t}\n\n\tspin_unlock(&mdev->lock);\n\n\treturn NULL;\n}\n\nstatic long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = kpad->entity->id;\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}\n\nstatic long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t/* Ignore backlinks. */\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long media_device_enum_links(struct media_device *mdev,\n\t\t\t\t    struct media_links_enum __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tint rval;\n\n\tif (copy_from_user(&links, ulinks, sizeof(links)))\n\t\treturn -EFAULT;\n\n\trval = __media_device_enum_links(mdev, &links);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (copy_to_user(ulinks, &links, sizeof(*ulinks)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long media_device_setup_link(struct media_device *mdev,\n\t\t\t\t    struct media_link_desc __user *_ulink)\n{\n\tstruct media_link *link = NULL;\n\tstruct media_link_desc ulink;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tint ret;\n\n\tif (copy_from_user(&ulink, _ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\t/* Find the source and sink entities and link.\n\t */\n\tsource = find_entity(mdev, ulink.source.entity);\n\tsink = find_entity(mdev, ulink.sink.entity);\n\n\tif (source == NULL || sink == NULL)\n\t\treturn -EINVAL;\n\n\tif (ulink.source.index >= source->num_pads ||\n\t    ulink.sink.index >= sink->num_pads)\n\t\treturn -EINVAL;\n\n\tlink = media_entity_find_link(&source->pads[ulink.source.index],\n\t\t\t\t      &sink->pads[ulink.sink.index]);\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\t/* Setup the link on both entities. */\n\tret = __media_entity_setup_link(link, ulink.flags);\n\n\tif (copy_to_user(_ulink, &ulink, sizeof(ulink)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\t\tret = media_device_get_info(dev,\n\t\t\t\t(struct media_device_info __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\t\tret = media_device_enum_entities(dev,\n\t\t\t\t(struct media_entity_desc __user *)arg);\n\t\tbreak;\n\n\tcase MEDIA_IOC_ENUM_LINKS:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links(dev,\n\t\t\t\t(struct media_links_enum __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_setup_link(dev,\n\t\t\t\t(struct media_link_desc __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct media_links_enum32 {\n\t__u32 entity;\n\tcompat_uptr_t pads; /* struct media_pad_desc * */\n\tcompat_uptr_t links; /* struct media_link_desc * */\n\t__u32 reserved[4];\n};\n\nstatic long media_device_enum_links32(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum32 __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tcompat_uptr_t pads_ptr, links_ptr;\n\n\tmemset(&links, 0, sizeof(links));\n\n\tif (get_user(links.entity, &ulinks->entity)\n\t    || get_user(pads_ptr, &ulinks->pads)\n\t    || get_user(links_ptr, &ulinks->links))\n\t\treturn -EFAULT;\n\n\tlinks.pads = compat_ptr(pads_ptr);\n\tlinks.links = compat_ptr(links_ptr);\n\n\treturn __media_device_enum_links(mdev, &links);\n}\n\n#define MEDIA_IOC_ENUM_LINKS32\t\t_IOWR('|', 0x02, struct media_links_enum32)\n\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = to_media_device(devnode);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_DEVICE_INFO:\n\tcase MEDIA_IOC_ENUM_ENTITIES:\n\tcase MEDIA_IOC_SETUP_LINK:\n\t\treturn media_device_ioctl(filp, cmd, arg);\n\n\tcase MEDIA_IOC_ENUM_LINKS32:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links32(dev,\n\t\t\t\t(struct media_links_enum32 __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_COMPAT */\n\nstatic const struct media_file_operations media_device_fops = {\n\t.owner = THIS_MODULE,\n\t.open = media_device_open,\n\t.ioctl = media_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_device_compat_ioctl,\n#endif /* CONFIG_COMPAT */\n\t.release = media_device_close,\n};\n\n/* -----------------------------------------------------------------------------\n * sysfs\n */\n\nstatic ssize_t show_model(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct media_device *mdev = to_media_device(to_media_devnode(cd));\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(mdev->model), mdev->model);\n}\n\nstatic DEVICE_ATTR(model, S_IRUGO, show_model, NULL);\n\n/* -----------------------------------------------------------------------------\n * Registration/unregistration\n */\n\nstatic void media_device_release(struct media_devnode *mdev)\n{\n}\n\n/**\n * media_device_register - register a media device\n * @mdev:\tThe media device\n *\n * The caller is responsible for initializing the media device before\n * registration. The following fields must be set:\n *\n * - dev must point to the parent device\n * - model must be filled with the device model name\n */\nint __must_check media_device_register(struct media_device *mdev)\n{\n\tint ret;\n\n\tif (WARN_ON(mdev->dev == NULL || mdev->model[0] == 0))\n\t\treturn -EINVAL;\n\n\tmdev->entity_id = 1;\n\tINIT_LIST_HEAD(&mdev->entities);\n\tspin_lock_init(&mdev->lock);\n\tmutex_init(&mdev->graph_mutex);\n\n\t/* Register the device node. */\n\tmdev->devnode.fops = &media_device_fops;\n\tmdev->devnode.parent = mdev->dev;\n\tmdev->devnode.release = media_device_release;\n\tret = media_devnode_register(&mdev->devnode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&mdev->devnode.dev, &dev_attr_model);\n\tif (ret < 0) {\n\t\tmedia_devnode_unregister(&mdev->devnode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register);\n\n/**\n * media_device_unregister - unregister a media device\n * @mdev:\tThe media device\n *\n */\nvoid media_device_unregister(struct media_device *mdev)\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *next;\n\n\tlist_for_each_entry_safe(entity, next, &mdev->entities, list)\n\t\tmedia_device_unregister_entity(entity);\n\n\tdevice_remove_file(&mdev->devnode.dev, &dev_attr_model);\n\tmedia_devnode_unregister(&mdev->devnode);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister);\n\n/**\n * media_device_register_entity - Register an entity with a media device\n * @mdev:\tThe media device\n * @entity:\tThe entity\n */\nint __must_check media_device_register_entity(struct media_device *mdev,\n\t\t\t\t\t      struct media_entity *entity)\n{\n\t/* Warn if we apparently re-register an entity */\n\tWARN_ON(entity->parent != NULL);\n\tentity->parent = mdev;\n\n\tspin_lock(&mdev->lock);\n\tif (entity->id == 0)\n\t\tentity->id = mdev->entity_id++;\n\telse\n\t\tmdev->entity_id = max(entity->id + 1, mdev->entity_id);\n\tlist_add_tail(&entity->list, &mdev->entities);\n\tspin_unlock(&mdev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity);\n\n/**\n * media_device_unregister_entity - Unregister an entity\n * @entity:\tThe entity\n *\n * If the entity has never been registered this function will return\n * immediately.\n */\nvoid media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->parent;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tspin_lock(&mdev->lock);\n\tlist_del(&entity->list);\n\tspin_unlock(&mdev->lock);\n\tentity->parent = NULL;\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity);\n"], "filenames": ["drivers/media/media-device.c"], "buggy_code_start_loc": [144], "buggy_code_end_loc": [161], "fixing_code_start_loc": [145], "fixing_code_end_loc": [165], "type": "CWE-200", "message": "drivers/media/media-device.c in the Linux kernel before 3.11, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize certain data structures, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28750150 and Qualcomm internal bug CR570757, a different vulnerability than CVE-2014-1739.", "other": {"cve": {"id": "CVE-2014-9895", "sourceIdentifier": "security@android.com", "published": "2016-08-06T10:59:39.373", "lastModified": "2016-11-28T19:15:37.923", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "drivers/media/media-device.c in the Linux kernel before 3.11, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize certain data structures, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28750150 and Qualcomm internal bug CR570757, a different vulnerability than CVE-2014-1739."}, {"lang": "es", "value": "drivers/media/media-device.c en el kernel de Linux en versiones anteriores a 3.11, como se usa en Android en versiones anteriores a 2016-08-05 en dispositivos Nexus 5 y 7 (2013), no incializa adecuadamente ciertas estructuras de datos, lo que permite a usuarios locales obtener informaci\u00f3n sensible a trav\u00e9s de una aplicaci\u00f3n manipulada, tambi\u00e9n conocido como error interno de Android 28750150 y error interno de Qualcomm CR570757, una vulnerabilidad diferente a CVE-2014-1739."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.0.1", "matchCriteriaId": "2567A6D5-BBA1-47B2-B1C3-EFABE9408FA9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.10.102", "matchCriteriaId": "091768B7-383B-4580-B7D3-3BEBDD10D063"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c88e739b1fad662240e99ecbd0bdaac871717987", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://source.android.com/security/bulletin/2016-08-01.html", "source": "security@android.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/92222", "source": "security@android.com"}, {"url": "https://github.com/torvalds/linux/commit/c88e739b1fad662240e99ecbd0bdaac871717987", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://source.codeaurora.org/quic/la/kernel/msm/commit/?id=cc4b26575602e492efd986e9a6ffc4278cee53b5", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c88e739b1fad662240e99ecbd0bdaac871717987"}}