{"buggy_code": ["/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\n\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.config.AuthConfigFactory;\nimport javax.security.auth.message.config.AuthConfigProvider;\nimport javax.security.auth.message.config.ClientAuthConfig;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory-factory for {@link ServerAuthConfig} instances, which are by themselves factories\n * for {@link ServerAuthContext} instances, which are delegates for the actual {@link ServerAuthModule} (SAM) that we're after.\n * \n * @author Arjan Tijms\n */\npublic class DefaultAuthConfigProvider implements AuthConfigProvider {\n\n    private static final String CALLBACK_HANDLER_PROPERTY_NAME = \"authconfigprovider.client.callbackhandler\";\n\n    private Map<String, String> providerProperties;\n    private ServerAuthModule serverAuthModule;\n\n    public DefaultAuthConfigProvider(ServerAuthModule serverAuthModule) {\n        this.serverAuthModule = serverAuthModule;\n    }\n\n    /**\n     * Constructor with signature and implementation that's required by API.\n     * \n     * @param properties provider properties\n     * @param factory the auth config factory\n     */\n    public DefaultAuthConfigProvider(Map<String, String> properties, AuthConfigFactory factory) {\n        this.providerProperties = properties;\n\n        // API requires self registration if factory is provided. Not clear\n        // where the \"layer\" (2nd parameter)\n        // and especially \"appContext\" (3rd parameter) values have to come from\n        // at this place.\n        if (factory != null) {\n            // If this method ever gets called, it may throw a SecurityException.\n            // Don't bother with a PrivilegedAction as we don't expect to ever be\n            // constructed this way.\n            factory.registerConfigProvider(this, null, null, \"Auto registration\");\n        }\n    }\n\n    /**\n     * The actual factory method that creates the factory used to eventually obtain the delegate for a SAM.\n     */\n    @Override\n    public ServerAuthConfig getServerAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return new DefaultServerAuthConfig(layer, appContext, handler == null ? createDefaultCallbackHandler() : handler,\n            providerProperties, serverAuthModule);\n    }\n\n    @Override\n    public ClientAuthConfig getClientAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return null;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    /**\n     * Creates a default callback handler via the system property \"authconfigprovider.client.callbackhandler\", as seemingly\n     * required by the API (API uses wording \"may\" create default handler). TODO: Isn't\n     * \"authconfigprovider.client.callbackhandler\" JBoss specific?\n     * \n     * @return\n     * @throws AuthException\n     */\n    private CallbackHandler createDefaultCallbackHandler() throws AuthException {\n        String callBackClassName = System.getProperty(CALLBACK_HANDLER_PROPERTY_NAME);\n\n        if (callBackClassName == null) {\n            throw new AuthException(\"No default handler set via system property: \" + CALLBACK_HANDLER_PROPERTY_NAME);\n        }\n\n        try {\n            return (CallbackHandler) Thread.currentThread().getContextClassLoader().loadClass(callBackClassName).newInstance();\n        } catch (Exception e) {\n            throw new AuthException(e.getMessage());\n        }\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory for {@link ServerAuthContext} instances, which are delegates for the actual\n * {@link ServerAuthModule} (SAM) that we're after.\n * \n * @author Arjan Tijms\n */\npublic class DefaultServerAuthConfig implements ServerAuthConfig {\n\n    private String layer;\n    private String appContext;\n    private CallbackHandler handler;\n    private Map<String, String> providerProperties;\n    private ServerAuthModule serverAuthModule;\n\n    public DefaultServerAuthConfig(String layer, String appContext, CallbackHandler handler,\n        Map<String, String> providerProperties, ServerAuthModule serverAuthModule) {\n        this.layer = layer;\n        this.appContext = appContext;\n        this.handler = handler;\n        this.providerProperties = providerProperties;\n        this.serverAuthModule = serverAuthModule;\n    }\n\n    @Override\n    public ServerAuthContext getAuthContext(String authContextID, Subject serviceSubject,\n        @SuppressWarnings(\"rawtypes\") Map properties) throws AuthException {\n        return new DefaultServerAuthContext(handler, serverAuthModule);\n    }\n\n    // ### The methods below mostly just return what has been passed into the\n    // constructor.\n    // ### In practice they don't seem to be called\n\n    @Override\n    public String getMessageLayer() {\n        return layer;\n    }\n\n    /**\n     * It's not entirely clear what the difference is between the \"application context identifier\" (appContext) and the\n     * \"authentication context identifier\" (authContext). In early iterations of the specification, authContext was called\n     * \"operation\" and instead of the MessageInfo it was obtained by something called an \"authParam\".\n     */\n    @Override\n    public String getAuthContextID(MessageInfo messageInfo) {\n        return appContext;\n    }\n\n    @Override\n    public String getAppContext() {\n        return appContext;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    @Override\n    public boolean isProtected() {\n        return false;\n    }\n\n    public Map<String, String> getProviderProperties() {\n        return providerProperties;\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Collections;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.AuthStatus;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.ServerAuth;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * The Server Authentication Context is an extra (required) indirection between the Application Server and the actual Server\n * Authentication Module (SAM). This can be used to encapsulate any number of SAMs and either select one at run-time, invoke\n * them all in order, etc.\n * <p>\n * Since this simple example only has a single SAM, we delegate directly to that one. Note that this {@link ServerAuthContext}\n * and the {@link ServerAuthModule} (SAM) share a common base interface: {@link ServerAuth}.\n * \n * @author Arjan Tijms\n */\npublic class DefaultServerAuthContext implements ServerAuthContext {\n\n    private final ServerAuthModule serverAuthModule;\n\n    public DefaultServerAuthContext(CallbackHandler handler, ServerAuthModule serverAuthModule) throws AuthException {\n        this.serverAuthModule = serverAuthModule;\n        serverAuthModule.initialize(null, null, handler, Collections.<String, String> emptyMap());\n    }\n\n    @Override\n    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject, Subject serviceSubject)\n        throws AuthException {\n        return serverAuthModule.validateRequest(messageInfo, clientSubject, serviceSubject);\n    }\n\n    @Override\n    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject) throws AuthException {\n        return serverAuthModule.secureResponse(messageInfo, serviceSubject);\n    }\n\n    @Override\n    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {\n        serverAuthModule.cleanSubject(messageInfo, subject);\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.glassfish.soteria.Utils.isEmpty;\n\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.Principal;\nimport java.security.PrivilegedAction;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.security.enterprise.AuthenticationStatus;\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.message.AuthStatus;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.callback.CallerPrincipalCallback;\nimport javax.security.auth.message.callback.GroupPrincipalCallback;\nimport javax.security.auth.message.config.AuthConfigFactory;\nimport javax.security.auth.message.module.ServerAuthModule;\nimport javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * A set of utility methods for using the JASPIC API\n * \n * @author Arjan Tijms\n *\n */\npublic final class Jaspic {\n\t\n\tpublic static final String IS_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.authentication\";\n\tpublic static final String IS_AUTHENTICATION_FROM_FILTER = \"org.glassfish.soteria.security.message.request.authenticationFromFilter\";\n\tpublic static final String IS_SECURE_RESPONSE = \"org.glassfish.soteria.security.message.request.secureResponse\";\n\tpublic static final String IS_REFRESH = \"org.glassfish.soteria.security.message.request.isRefresh\";\n\tpublic static final String DID_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.didAuthentication\";\n\t\n\tpublic static final String AUTH_PARAMS = \"org.glassfish.soteria.security.message.request.authParams\";\n\t\n\tpublic static final String LOGGEDIN_USERNAME = \"org.glassfish.soteria.security.message.loggedin.username\";\n\tpublic static final String LOGGEDIN_ROLES = \"org.glassfish.soteria.security.message.loggedin.roles\";\n\tpublic static final String LAST_AUTH_STATUS = \"org.glassfish.soteria.security.message.authStatus\";\n\t\n\tpublic static final String CONTEXT_REGISTRATION_ID = \"org.glassfish.soteria.security.message.registrationId\";\n\t\n\t// Key in the MessageInfo Map that when present AND set to true indicated a protected resource is being accessed.\n\t// When the resource is not protected, GlassFish omits the key altogether. WebSphere does insert the key and sets\n\t// it to false.\n\tprivate static final String IS_MANDATORY = \"javax.security.auth.message.MessagePolicy.isMandatory\";\n\tprivate static final String REGISTER_SESSION = \"javax.servlet.http.registerSession\";\n\n\tprivate Jaspic() {}\n\t\n\tpublic static boolean authenticate(HttpServletRequest request, HttpServletResponse response, AuthenticationParameters authParameters) {\n\t\ttry {\n\t\t    // JASPIC 1.1 does not have any way to distinguish between a\n\t\t    // SAM called at start of a request or following request#authenticate.\n\t\t    // See https://java.net/jira/browse/JASPIC_SPEC-5\n\t\t    \n\t\t    // We now add this as a request attribute instead, but should better\n\t\t    // be the MessageInfo map\n\t\t\trequest.setAttribute(IS_AUTHENTICATION, true);\n\t\t\tif (authParameters != null) {\n\t\t\t\trequest.setAttribute(AUTH_PARAMS, authParameters);\n\t\t\t}\n\t\t\treturn request.authenticate(response);\n\t\t} catch (ServletException | IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t} finally {\n\t\t\trequest.removeAttribute(IS_AUTHENTICATION);\n\t\t\tif (authParameters != null) {\n\t\t\t\trequest.removeAttribute(AUTH_PARAMS);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static AuthenticationParameters getAuthParameters(HttpServletRequest request) {\n\t\tAuthenticationParameters authParameters = (AuthenticationParameters) request.getAttribute(AUTH_PARAMS);\n\t\tif (authParameters == null) {\n\t\t\tauthParameters = new AuthenticationParameters();\n\t\t}\n\t\t\n\t\treturn authParameters;\n\t}\n\t\n\tpublic static void logout(HttpServletRequest request, HttpServletResponse response) {\n\t\ttry {\n\t\t\trequest.logout();\n\t\t\t// Need to invalidate the session to really logout - request.logout only logs the user out for the *current request*\n\t\t\t// This is nearly always unwanted. Although the SAM's cleanSubject method can clear any session data too if needed,\n\t\t\t// invalidating the session is pretty much the safest way.\n\t\t\trequest.getSession().invalidate();\n\t\t} catch (ServletException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t}\n\n\tpublic static void cleanSubject(Subject subject) {\n\t    if (subject != null) {\n\t        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n\t            public Void run() {\n\t                subject.getPrincipals().clear();\n\t                return null;\n\t            }\n\t        });\n\t    }\n\t}\n\n\tpublic static boolean isRegisterSession(MessageInfo messageInfo) {\n\t\treturn Boolean.valueOf((String)messageInfo.getMap().get(REGISTER_SESSION));\n\t}\n\t\n\tpublic static boolean isProtectedResource(MessageInfo messageInfo) {\n\t\treturn Boolean.valueOf((String) messageInfo.getMap().get(IS_MANDATORY));\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void setRegisterSession(MessageInfo messageInfo, String username, Set<String> roles) {\n\t\tmessageInfo.getMap().put(\"javax.servlet.http.registerSession\", TRUE.toString());\n\t\t\n\t\tHttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();\n\t\trequest.setAttribute(LOGGEDIN_USERNAME, username);\n\t\t// TODO: check for existing roles and add\n\t\trequest.setAttribute(LOGGEDIN_ROLES, roles);\n\t}\n\t\n\tpublic static boolean isAuthenticationRequest(HttpServletRequest request) {\n\t\treturn TRUE.equals(request.getAttribute(IS_AUTHENTICATION));\n\t}\n\n    public static void notifyContainerAboutLogin(Subject clientSubject, CallbackHandler handler, Principal callerPrincipal, Set<String> groups) {\n        handleCallbacks(clientSubject, handler, new CallerPrincipalCallback(clientSubject, callerPrincipal), groups);\n    }\n\n    public static void notifyContainerAboutLogin(Subject clientSubject, CallbackHandler handler, String callerPrincipalName, Set<String> groups) {\n        handleCallbacks(clientSubject, handler, new CallerPrincipalCallback(clientSubject, callerPrincipalName), groups);\n    }\n\n\tprivate static void handleCallbacks(Subject clientSubject, CallbackHandler handler, CallerPrincipalCallback callerPrincipalCallback, Set<String> groups) {\n\t    if (clientSubject == null) {\n\t        throw new IllegalArgumentException(\"Null clientSubject!\");\n\t    }\n\t    if (handler == null) {\n\t        throw new IllegalArgumentException(\"Null callback handler!\");\n\t    }\n\t    try {\n\t        if (groups == null || isEmpty(groups) ||\n\t                (callerPrincipalCallback.getPrincipal() == null && callerPrincipalCallback.getName() == null)) {\n\t            // don't handle groups if null/empty or if caller is null\n\t            handler.handle(new Callback[] {\n\t                    callerPrincipalCallback });\n\t        } else {\n\t            handler.handle(new Callback[] {\n\t                    callerPrincipalCallback,\n\t                    new GroupPrincipalCallback(clientSubject, groups.toArray(new String[groups.size()])) });\n\t        }\n\t    } catch (IOException | UnsupportedCallbackException e) {\n\t        // Should not happen\n\t        throw new IllegalStateException(e);\n\t    }\n\t}\n\n\tpublic static void setLastAuthenticationStatus(HttpServletRequest request, AuthenticationStatus status) {\n        request.setAttribute(LAST_AUTH_STATUS, status);\n    }\n\n\tpublic static AuthenticationStatus getLastAuthenticationStatus(HttpServletRequest request) {\n\t\treturn (AuthenticationStatus) request.getAttribute(LAST_AUTH_STATUS);\n\t}\n\n\tpublic static AuthStatus fromAuthenticationStatus(AuthenticationStatus authenticationStatus) {\n\t    switch (authenticationStatus) {\n\t        case NOT_DONE: case SUCCESS:\n\t            return AuthStatus.SUCCESS;\n\t        case SEND_FAILURE:\n\t            return AuthStatus.SEND_FAILURE;\n\t        case SEND_CONTINUE:\n\t            return AuthStatus.SEND_CONTINUE;\n\t        default:\n\t            throw new IllegalStateException(\"Unhandled status:\" + authenticationStatus.name());\n\t    }\n\t}\n\t\n\t/**\n\t * Should be called when the callback handler is used with the intention that an actual\n\t * user is going to be authenticated (as opposed to using the handler for the \"do nothing\" protocol\n\t * which uses the unauthenticated identity).\n\t * \n\t * @param request The involved HTTP servlet request.\n\t * \n\t */\n\tpublic static void setDidAuthentication(HttpServletRequest request) {\n\t\trequest.setAttribute(DID_AUTHENTICATION, TRUE);\n\t}\n\t\n\t/**\n\t * Gets the app context ID from the servlet context.\n\t * \n\t * <p>\n\t * The app context ID is the ID that JASPIC associates with the given application.\n\t * In this case that given application is the web application corresponding to the\n\t * ServletContext.\n\t * \n\t * @param context the servlet context for which to obtain the JASPIC app context ID\n\t * @return the app context ID for the web application corresponding to the given context\n\t */\n\tpublic static String getAppContextID(ServletContext context) {\n\t\treturn context.getVirtualServerName() + \" \" + context.getContextPath();\n\t}\n\t\n\t/**\n\t * Registers a server auth module as the one and only module for the application corresponding to\n\t * the given servlet context.\n\t * \n\t * <p>\n\t * This will override any other modules that have already been registered, either via proprietary\n\t * means or using the standard API.\n\t * \n\t * @param serverAuthModule the server auth module to be registered\n\t * @param servletContext the context of the app for which the module is registered\n\t * @return A String identifier assigned by an underlying factory corresponding to an underlying factory-factory-factory registration\n\t */\n\tpublic static String registerServerAuthModule(ServerAuthModule serverAuthModule, ServletContext servletContext) {\n\t\t\n\t    // Register the factory-factory-factory for the SAM\n\t    String registrationId = AccessController.doPrivileged(new PrivilegedAction<String>() {\n\t        public String run() {\n\t            return AuthConfigFactory.getFactory().registerConfigProvider(\n\t                    new DefaultAuthConfigProvider(serverAuthModule),\n\t                    \"HttpServlet\", \n\t                    getAppContextID(servletContext), \n\t                    \"Default single SAM authentication config provider\");\n\t        }\n\t    });\n\t\t\n\t\t// Remember the registration ID returned by the factory, so we can unregister the JASPIC module when the web module\n\t\t// is undeployed. JASPIC being the low level API that it is won't do this automatically.\n\t\tservletContext.setAttribute(CONTEXT_REGISTRATION_ID, registrationId);\n\t\t\n\t\treturn registrationId;\n\t}\n\t\n\t/**\n\t * Deregisters the server auth module (and encompassing wrappers/factories) that was previously registered via a call\n\t * to registerServerAuthModule.\n\t * \n\t * @param servletContext the context of the app for which the module is deregistered\n\t */\n\tpublic static void deregisterServerAuthModule(ServletContext servletContext) {\n\t\tString registrationId = (String) servletContext.getAttribute(CONTEXT_REGISTRATION_ID);\n\t\tif (!isEmpty(registrationId)) {\n\t\t\tAccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n\t\t\t    public Boolean run() {\n\t\t\t        return AuthConfigFactory.getFactory().removeRegistration(registrationId);\n\t\t\t    }\n\t\t\t});\n\t\t}\n\t}\n\t\n\t\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.servlet;\n\nimport static java.util.logging.Level.FINEST;\nimport static java.util.logging.Level.INFO;\nimport static org.glassfish.soteria.Utils.isEmpty;\nimport static org.glassfish.soteria.mechanisms.jaspic.Jaspic.deregisterServerAuthModule;\nimport static org.glassfish.soteria.mechanisms.jaspic.Jaspic.registerServerAuthModule;\n\nimport java.util.Set;\nimport java.util.logging.Logger;\n\nimport javax.enterprise.inject.spi.CDI;\nimport javax.servlet.ServletContainerInitializer;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.ServletException;\n\nimport org.glassfish.soteria.cdi.CdiExtension;\nimport org.glassfish.soteria.cdi.spi.CDIPerRequestInitializer;\nimport org.glassfish.soteria.cdi.spi.impl.LibertyCDIPerRequestInitializer;\nimport org.glassfish.soteria.mechanisms.jaspic.HttpBridgeServerAuthModule;\nimport org.glassfish.soteria.mechanisms.jaspic.Jaspic;\n\n/**\n * If an HttpAuthenticationMechanism implementation has been found on the classpath, this \n * initializer installs a bridge SAM that delegates the validateRequest, secureResponse and\n * cleanSubject methods from the SAM to the HttpAuthenticationMechanism.\n * \n * <p>\n * The bridge SAM uses <code>CDI.current()</code> to obtain the HttpAuthenticationMechanism, therefore\n * fully enabling CDI in the implementation of that interface.\n * \n * @author Arjan Tijms\n *\n */\npublic class SamRegistrationInstaller implements ServletContainerInitializer, ServletContextListener {\n    \n    private static final Logger logger =  Logger.getLogger(SamRegistrationInstaller.class.getName());\n\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n\n        // Obtain a reference to the CdiExtension that was used to see if\n        // there's an enabled bean\n        \n        CDI<Object> cdi;\n        try {\n            cdi = CDI.current();\n            \n            if (logger.isLoggable(INFO)) {\n                String version = getClass().getPackage().getImplementationVersion();\n                logger.log(INFO, \"Initializing Soteria {0} for context ''{1}''\", new Object[]{version, ctx.getContextPath()});\n            }\n            \n        } catch (IllegalStateException e) {\n            // On GlassFish 4.1.1/Payara 4.1.1.161 CDI is not initialized (org.jboss.weld.Container#initialize is not called), \n            // and calling CDI.current() will throw an exception. It's no use to continue then.\n            // TODO: Do we need to find out *why* the default module does not have CDI initialized?\n            logger.log(FINEST, \"CDI not available for app context id: \" + Jaspic.getAppContextID(ctx), e);\n            \n            return;\n        }\n        \n        CdiExtension cdiExtension = cdi.select(CdiExtension.class).get();\n\n        if (cdiExtension.isHttpAuthenticationMechanismFound()) {\n\n            // A SAM must be registered at this point, since the programmatically added\n            // Listener is for some reason restricted (not allow) from calling\n            // getVirtualServerName. At this point we're still allowed to call this.\n            \n            // TODO: Ask the Servlet EG to address this? Is there any ground for this restriction???\n            \n            CDIPerRequestInitializer cdiPerRequestInitializer = null;\n            \n            if (!isEmpty(System.getProperty(\"wlp.server.name\"))) {\n                // Hardcode server check for now. TODO: design/implement proper service loader/SPI for this\n                cdiPerRequestInitializer = new LibertyCDIPerRequestInitializer();\n                logger.log(INFO, \"Running on Liberty - installing CDI request scope activator\");\n            }\n            \n            registerServerAuthModule(new HttpBridgeServerAuthModule(cdiPerRequestInitializer), ctx);\n          \n            // Add a listener so we can process the context destroyed event, which is needed\n            // to de-register the SAM correctly.\n            ctx.addListener(this);\n        }\n\n    }\n    \n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n       // noop\n    }\n    \n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        deregisterServerAuthModule(sce.getServletContext());\n    }\n    \n}\n"], "fixing_code": ["/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.config.AuthConfigFactory;\nimport javax.security.auth.message.config.AuthConfigProvider;\nimport javax.security.auth.message.config.ClientAuthConfig;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory-factory for {@link ServerAuthConfig} instances, which are by themselves factories\n * for {@link ServerAuthContext} instances, which are delegates for the actual {@link ServerAuthModule} (SAM) that we're after.\n *\n * @author Arjan Tijms\n */\npublic class DefaultAuthConfigProvider implements AuthConfigProvider {\n\n    private static final String CALLBACK_HANDLER_PROPERTY_NAME = \"authconfigprovider.client.callbackhandler\";\n\n    private Map<String, String> providerProperties;\n    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n\n    public DefaultAuthConfigProvider(Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n    }\n\n    /**\n     * Constructor with signature and implementation that's required by API.\n     *\n     * @param properties provider properties\n     * @param factory the auth config factory\n     */\n    public DefaultAuthConfigProvider(Map<String, String> properties, AuthConfigFactory factory) {\n        this.providerProperties = properties;\n\n        // API requires self registration if factory is provided. Not clear\n        // where the \"layer\" (2nd parameter)\n        // and especially \"appContext\" (3rd parameter) values have to come from\n        // at this place.\n        if (factory != null) {\n            // If this method ever gets called, it may throw a SecurityException.\n            // Don't bother with a PrivilegedAction as we don't expect to ever be\n            // constructed this way.\n            factory.registerConfigProvider(this, null, null, \"Auto registration\");\n        }\n    }\n\n    /**\n     * The actual factory method that creates the factory used to eventually obtain the delegate for a SAM.\n     */\n    @Override\n    public ServerAuthConfig getServerAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return new DefaultServerAuthConfig(layer, appContext, handler == null ? createDefaultCallbackHandler() : handler,\n            providerProperties, serverAuthModuleSupplier);\n    }\n\n    @Override\n    public ClientAuthConfig getClientAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return null;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    /**\n     * Creates a default callback handler via the system property \"authconfigprovider.client.callbackhandler\", as seemingly\n     * required by the API (API uses wording \"may\" create default handler). TODO: Isn't\n     * \"authconfigprovider.client.callbackhandler\" JBoss specific?\n     *\n     * @return\n     * @throws AuthException\n     */\n    private CallbackHandler createDefaultCallbackHandler() throws AuthException {\n        String callBackClassName = System.getProperty(CALLBACK_HANDLER_PROPERTY_NAME);\n\n        if (callBackClassName == null) {\n            throw new AuthException(\"No default handler set via system property: \" + CALLBACK_HANDLER_PROPERTY_NAME);\n        }\n\n        try {\n            return (CallbackHandler) Thread.currentThread().getContextClassLoader().loadClass(callBackClassName).newInstance();\n        } catch (Exception e) {\n            throw new AuthException(e.getMessage());\n        }\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory for {@link ServerAuthContext} instances, which are delegates for the actual\n * {@link ServerAuthModule} (SAM) that we're after.\n *\n * @author Arjan Tijms\n */\npublic class DefaultServerAuthConfig implements ServerAuthConfig {\n\n    private String layer;\n    private String appContext;\n    private CallbackHandler handler;\n    private Map<String, String> providerProperties;\n    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n\n    public DefaultServerAuthConfig(String layer, String appContext, CallbackHandler handler,\n        Map<String, String> providerProperties, Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n        this.layer = layer;\n        this.appContext = appContext;\n        this.handler = handler;\n        this.providerProperties = providerProperties;\n        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n    }\n\n    @Override\n    public ServerAuthContext getAuthContext(String authContextID, Subject serviceSubject,\n        @SuppressWarnings(\"rawtypes\") Map properties) throws AuthException {\n        return new DefaultServerAuthContext(handler, serverAuthModuleSupplier);\n    }\n\n    // ### The methods below mostly just return what has been passed into the\n    // constructor.\n    // ### In practice they don't seem to be called\n\n    @Override\n    public String getMessageLayer() {\n        return layer;\n    }\n\n    /**\n     * It's not entirely clear what the difference is between the \"application context identifier\" (appContext) and the\n     * \"authentication context identifier\" (authContext). In early iterations of the specification, authContext was called\n     * \"operation\" and instead of the MessageInfo it was obtained by something called an \"authParam\".\n     */\n    @Override\n    public String getAuthContextID(MessageInfo messageInfo) {\n        return appContext;\n    }\n\n    @Override\n    public String getAppContext() {\n        return appContext;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    @Override\n    public boolean isProtected() {\n        return false;\n    }\n\n    public Map<String, String> getProviderProperties() {\n        return providerProperties;\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Collections;\nimport java.util.function.Supplier;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.AuthStatus;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.ServerAuth;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * The Server Authentication Context is an extra (required) indirection between the Application Server and the actual Server\n * Authentication Module (SAM). This can be used to encapsulate any number of SAMs and either select one at run-time, invoke\n * them all in order, etc.\n * <p>\n * Since this simple example only has a single SAM, we delegate directly to that one. Note that this {@link ServerAuthContext}\n * and the {@link ServerAuthModule} (SAM) share a common base interface: {@link ServerAuth}.\n *\n * @author Arjan Tijms\n */\npublic class DefaultServerAuthContext implements ServerAuthContext {\n\n    private final ServerAuthModule serverAuthModule;\n\n    public DefaultServerAuthContext(CallbackHandler handler, Supplier<ServerAuthModule> serverAuthModuleSupplier) throws AuthException {\n        this.serverAuthModule = serverAuthModuleSupplier.get();\n        serverAuthModule.initialize(null, null, handler, Collections.<String, String> emptyMap());\n    }\n\n    @Override\n    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject, Subject serviceSubject)\n        throws AuthException {\n        return serverAuthModule.validateRequest(messageInfo, clientSubject, serviceSubject);\n    }\n\n    @Override\n    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject) throws AuthException {\n        return serverAuthModule.secureResponse(messageInfo, serviceSubject);\n    }\n\n    @Override\n    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {\n        serverAuthModule.cleanSubject(messageInfo, subject);\n    }\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.glassfish.soteria.Utils.isEmpty;\n\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.Principal;\nimport java.security.PrivilegedAction;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport javax.security.enterprise.AuthenticationStatus;\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.message.AuthStatus;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.callback.CallerPrincipalCallback;\nimport javax.security.auth.message.callback.GroupPrincipalCallback;\nimport javax.security.auth.message.config.AuthConfigFactory;\nimport javax.security.auth.message.module.ServerAuthModule;\nimport javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.glassfish.soteria.cdi.spi.CDIPerRequestInitializer;\n\n/**\n * A set of utility methods for using the JASPIC API\n *\n * @author Arjan Tijms\n *\n */\npublic final class Jaspic {\n\n\tpublic static final String IS_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.authentication\";\n\tpublic static final String IS_AUTHENTICATION_FROM_FILTER = \"org.glassfish.soteria.security.message.request.authenticationFromFilter\";\n\tpublic static final String IS_SECURE_RESPONSE = \"org.glassfish.soteria.security.message.request.secureResponse\";\n\tpublic static final String IS_REFRESH = \"org.glassfish.soteria.security.message.request.isRefresh\";\n\tpublic static final String DID_AUTHENTICATION = \"org.glassfish.soteria.security.message.request.didAuthentication\";\n\n\tpublic static final String AUTH_PARAMS = \"org.glassfish.soteria.security.message.request.authParams\";\n\n\tpublic static final String LOGGEDIN_USERNAME = \"org.glassfish.soteria.security.message.loggedin.username\";\n\tpublic static final String LOGGEDIN_ROLES = \"org.glassfish.soteria.security.message.loggedin.roles\";\n\tpublic static final String LAST_AUTH_STATUS = \"org.glassfish.soteria.security.message.authStatus\";\n\n\tpublic static final String CONTEXT_REGISTRATION_ID = \"org.glassfish.soteria.security.message.registrationId\";\n\n\t// Key in the MessageInfo Map that when present AND set to true indicated a protected resource is being accessed.\n\t// When the resource is not protected, GlassFish omits the key altogether. WebSphere does insert the key and sets\n\t// it to false.\n\tprivate static final String IS_MANDATORY = \"javax.security.auth.message.MessagePolicy.isMandatory\";\n\tprivate static final String REGISTER_SESSION = \"javax.servlet.http.registerSession\";\n\n\tprivate Jaspic() {}\n\n\tpublic static boolean authenticate(HttpServletRequest request, HttpServletResponse response, AuthenticationParameters authParameters) {\n\t\ttry {\n\t\t    // JASPIC 1.1 does not have any way to distinguish between a\n\t\t    // SAM called at start of a request or following request#authenticate.\n\t\t    // See https://java.net/jira/browse/JASPIC_SPEC-5\n\n\t\t    // We now add this as a request attribute instead, but should better\n\t\t    // be the MessageInfo map\n\t\t\trequest.setAttribute(IS_AUTHENTICATION, true);\n\t\t\tif (authParameters != null) {\n\t\t\t\trequest.setAttribute(AUTH_PARAMS, authParameters);\n\t\t\t}\n\t\t\treturn request.authenticate(response);\n\t\t} catch (ServletException | IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t} finally {\n\t\t\trequest.removeAttribute(IS_AUTHENTICATION);\n\t\t\tif (authParameters != null) {\n\t\t\t\trequest.removeAttribute(AUTH_PARAMS);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static AuthenticationParameters getAuthParameters(HttpServletRequest request) {\n\t\tAuthenticationParameters authParameters = (AuthenticationParameters) request.getAttribute(AUTH_PARAMS);\n\t\tif (authParameters == null) {\n\t\t\tauthParameters = new AuthenticationParameters();\n\t\t}\n\n\t\treturn authParameters;\n\t}\n\n\tpublic static void logout(HttpServletRequest request, HttpServletResponse response) {\n\t\ttry {\n\t\t\trequest.logout();\n\t\t\t// Need to invalidate the session to really logout - request.logout only logs the user out for the *current request*\n\t\t\t// This is nearly always unwanted. Although the SAM's cleanSubject method can clear any session data too if needed,\n\t\t\t// invalidating the session is pretty much the safest way.\n\t\t\trequest.getSession().invalidate();\n\t\t} catch (ServletException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t}\n\n\tpublic static void cleanSubject(Subject subject) {\n\t    if (subject != null) {\n\t        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n\t            public Void run() {\n\t                subject.getPrincipals().clear();\n\t                return null;\n\t            }\n\t        });\n\t    }\n\t}\n\n\tpublic static boolean isRegisterSession(MessageInfo messageInfo) {\n\t\treturn Boolean.valueOf((String)messageInfo.getMap().get(REGISTER_SESSION));\n\t}\n\n\tpublic static boolean isProtectedResource(MessageInfo messageInfo) {\n\t\treturn Boolean.valueOf((String) messageInfo.getMap().get(IS_MANDATORY));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void setRegisterSession(MessageInfo messageInfo, String username, Set<String> roles) {\n\t\tmessageInfo.getMap().put(\"javax.servlet.http.registerSession\", TRUE.toString());\n\n\t\tHttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();\n\t\trequest.setAttribute(LOGGEDIN_USERNAME, username);\n\t\t// TODO: check for existing roles and add\n\t\trequest.setAttribute(LOGGEDIN_ROLES, roles);\n\t}\n\n\tpublic static boolean isAuthenticationRequest(HttpServletRequest request) {\n\t\treturn TRUE.equals(request.getAttribute(IS_AUTHENTICATION));\n\t}\n\n    public static void notifyContainerAboutLogin(Subject clientSubject, CallbackHandler handler, Principal callerPrincipal, Set<String> groups) {\n        handleCallbacks(clientSubject, handler, new CallerPrincipalCallback(clientSubject, callerPrincipal), groups);\n    }\n\n    public static void notifyContainerAboutLogin(Subject clientSubject, CallbackHandler handler, String callerPrincipalName, Set<String> groups) {\n        handleCallbacks(clientSubject, handler, new CallerPrincipalCallback(clientSubject, callerPrincipalName), groups);\n    }\n\n\tprivate static void handleCallbacks(Subject clientSubject, CallbackHandler handler, CallerPrincipalCallback callerPrincipalCallback, Set<String> groups) {\n\t    if (clientSubject == null) {\n\t        throw new IllegalArgumentException(\"Null clientSubject!\");\n\t    }\n\t    if (handler == null) {\n\t        throw new IllegalArgumentException(\"Null callback handler!\");\n\t    }\n\t    try {\n\t        if (groups == null || isEmpty(groups) ||\n\t                (callerPrincipalCallback.getPrincipal() == null && callerPrincipalCallback.getName() == null)) {\n\t            // don't handle groups if null/empty or if caller is null\n\t            handler.handle(new Callback[] {\n\t                    callerPrincipalCallback });\n\t        } else {\n\t            handler.handle(new Callback[] {\n\t                    callerPrincipalCallback,\n\t                    new GroupPrincipalCallback(clientSubject, groups.toArray(new String[groups.size()])) });\n\t        }\n\t    } catch (IOException | UnsupportedCallbackException e) {\n\t        // Should not happen\n\t        throw new IllegalStateException(e);\n\t    }\n\t}\n\n\tpublic static void setLastAuthenticationStatus(HttpServletRequest request, AuthenticationStatus status) {\n        request.setAttribute(LAST_AUTH_STATUS, status);\n    }\n\n\tpublic static AuthenticationStatus getLastAuthenticationStatus(HttpServletRequest request) {\n\t\treturn (AuthenticationStatus) request.getAttribute(LAST_AUTH_STATUS);\n\t}\n\n\tpublic static AuthStatus fromAuthenticationStatus(AuthenticationStatus authenticationStatus) {\n\t    switch (authenticationStatus) {\n\t        case NOT_DONE: case SUCCESS:\n\t            return AuthStatus.SUCCESS;\n\t        case SEND_FAILURE:\n\t            return AuthStatus.SEND_FAILURE;\n\t        case SEND_CONTINUE:\n\t            return AuthStatus.SEND_CONTINUE;\n\t        default:\n\t            throw new IllegalStateException(\"Unhandled status:\" + authenticationStatus.name());\n\t    }\n\t}\n\n\t/**\n\t * Should be called when the callback handler is used with the intention that an actual\n\t * user is going to be authenticated (as opposed to using the handler for the \"do nothing\" protocol\n\t * which uses the unauthenticated identity).\n\t *\n\t * @param request The involved HTTP servlet request.\n\t *\n\t */\n\tpublic static void setDidAuthentication(HttpServletRequest request) {\n\t\trequest.setAttribute(DID_AUTHENTICATION, TRUE);\n\t}\n\n\t/**\n\t * Gets the app context ID from the servlet context.\n\t *\n\t * <p>\n\t * The app context ID is the ID that JASPIC associates with the given application.\n\t * In this case that given application is the web application corresponding to the\n\t * ServletContext.\n\t *\n\t * @param context the servlet context for which to obtain the JASPIC app context ID\n\t * @return the app context ID for the web application corresponding to the given context\n\t */\n\tpublic static String getAppContextID(ServletContext context) {\n\t\treturn context.getVirtualServerName() + \" \" + context.getContextPath();\n\t}\n\n\t/**\n\t * Registers a server auth module as the one and only module for the application corresponding to\n\t * the given servlet context.\n\t *\n\t * <p>\n\t * This will override any other modules that have already been registered, either via proprietary\n\t * means or using the standard API.\n\t *\n\t * @param cdiPerRequestInitializer A {@link CDIPerRequestInitializer} to pass to the {@link ServerAuthModule}\n\t * @param servletContext the context of the app for which the module is registered\n\t * @return A String identifier assigned by an underlying factory corresponding to an underlying factory-factory-factory registration\n\t */\n\tpublic static String registerServerAuthModule(CDIPerRequestInitializer cdiPerRequestInitializer, ServletContext servletContext) {\n\n\t    // Register the factory-factory-factory for the SAM\n\t    String registrationId = AccessController.doPrivileged(new PrivilegedAction<String>() {\n\t        public String run() {\n\t            return AuthConfigFactory.getFactory().registerConfigProvider(\n\t                    new DefaultAuthConfigProvider(() -> new HttpBridgeServerAuthModule(cdiPerRequestInitializer)),\n\t                    \"HttpServlet\",\n\t                    getAppContextID(servletContext),\n\t                    \"Default single SAM authentication config provider\");\n\t        }\n\t    });\n\n\t\t// Remember the registration ID returned by the factory, so we can unregister the JASPIC module when the web module\n\t\t// is undeployed. JASPIC being the low level API that it is won't do this automatically.\n\t\tservletContext.setAttribute(CONTEXT_REGISTRATION_ID, registrationId);\n\n\t\treturn registrationId;\n\t}\n\n\t/**\n\t * Deregisters the server auth module (and encompassing wrappers/factories) that was previously registered via a call\n\t * to registerServerAuthModule.\n\t *\n\t * @param servletContext the context of the app for which the module is deregistered\n\t */\n\tpublic static void deregisterServerAuthModule(ServletContext servletContext) {\n\t\tString registrationId = (String) servletContext.getAttribute(CONTEXT_REGISTRATION_ID);\n\t\tif (!isEmpty(registrationId)) {\n\t\t\tAccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n\t\t\t    public Boolean run() {\n\t\t\t        return AuthConfigFactory.getFactory().removeRegistration(registrationId);\n\t\t\t    }\n\t\t\t});\n\t\t}\n\t}\n\n\n}\n", "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.servlet;\n\nimport static java.util.logging.Level.FINEST;\nimport static java.util.logging.Level.INFO;\nimport static org.glassfish.soteria.Utils.isEmpty;\nimport static org.glassfish.soteria.mechanisms.jaspic.Jaspic.deregisterServerAuthModule;\nimport static org.glassfish.soteria.mechanisms.jaspic.Jaspic.registerServerAuthModule;\n\nimport java.util.Set;\nimport java.util.logging.Logger;\n\nimport javax.enterprise.inject.spi.CDI;\nimport javax.servlet.ServletContainerInitializer;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.ServletException;\n\nimport org.glassfish.soteria.cdi.CdiExtension;\nimport org.glassfish.soteria.cdi.spi.CDIPerRequestInitializer;\nimport org.glassfish.soteria.cdi.spi.impl.LibertyCDIPerRequestInitializer;\nimport org.glassfish.soteria.mechanisms.jaspic.HttpBridgeServerAuthModule;\nimport org.glassfish.soteria.mechanisms.jaspic.Jaspic;\n\n/**\n * If an HttpAuthenticationMechanism implementation has been found on the classpath, this\n * initializer installs a bridge SAM that delegates the validateRequest, secureResponse and\n * cleanSubject methods from the SAM to the HttpAuthenticationMechanism.\n *\n * <p>\n * The bridge SAM uses <code>CDI.current()</code> to obtain the HttpAuthenticationMechanism, therefore\n * fully enabling CDI in the implementation of that interface.\n *\n * @author Arjan Tijms\n *\n */\npublic class SamRegistrationInstaller implements ServletContainerInitializer, ServletContextListener {\n\n    private static final Logger logger =  Logger.getLogger(SamRegistrationInstaller.class.getName());\n\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n\n        // Obtain a reference to the CdiExtension that was used to see if\n        // there's an enabled bean\n\n        CDI<Object> cdi;\n        try {\n            cdi = CDI.current();\n\n            if (logger.isLoggable(INFO)) {\n                String version = getClass().getPackage().getImplementationVersion();\n                logger.log(INFO, \"Initializing Soteria {0} for context ''{1}''\", new Object[]{version, ctx.getContextPath()});\n            }\n\n        } catch (IllegalStateException e) {\n            // On GlassFish 4.1.1/Payara 4.1.1.161 CDI is not initialized (org.jboss.weld.Container#initialize is not called),\n            // and calling CDI.current() will throw an exception. It's no use to continue then.\n            // TODO: Do we need to find out *why* the default module does not have CDI initialized?\n            logger.log(FINEST, \"CDI not available for app context id: \" + Jaspic.getAppContextID(ctx), e);\n\n            return;\n        }\n\n        CdiExtension cdiExtension = cdi.select(CdiExtension.class).get();\n\n        if (cdiExtension.isHttpAuthenticationMechanismFound()) {\n\n            // A SAM must be registered at this point, since the programmatically added\n            // Listener is for some reason restricted (not allow) from calling\n            // getVirtualServerName. At this point we're still allowed to call this.\n\n            // TODO: Ask the Servlet EG to address this? Is there any ground for this restriction???\n\n            CDIPerRequestInitializer cdiPerRequestInitializer = null;\n\n            if (!isEmpty(System.getProperty(\"wlp.server.name\"))) {\n                // Hardcode server check for now. TODO: design/implement proper service loader/SPI for this\n                cdiPerRequestInitializer = new LibertyCDIPerRequestInitializer();\n                logger.log(INFO, \"Running on Liberty - installing CDI request scope activator\");\n            }\n\n            registerServerAuthModule(cdiPerRequestInitializer, ctx);\n\n            // Add a listener so we can process the context destroyed event, which is needed\n            // to de-register the SAM correctly.\n            ctx.addListener(this);\n        }\n\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n       // noop\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        deregisterServerAuthModule(sce.getServletContext());\n    }\n\n}\n"], "filenames": ["impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultAuthConfigProvider.java", "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultServerAuthConfig.java", "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/DefaultServerAuthContext.java", "impl/src/main/java/org/glassfish/soteria/mechanisms/jaspic/Jaspic.java", "impl/src/main/java/org/glassfish/soteria/servlet/SamRegistrationInstaller.java"], "buggy_code_start_loc": [19, 19, 19, 27, 42], "buggy_code_end_loc": [93, 56, 46, 283, 118], "fixing_code_start_loc": [20, 20, 20, 28, 42], "fixing_code_end_loc": [94, 57, 47, 286, 118], "type": "CWE-20", "message": "A flaw was found in Soteria before 1.0.1, in a way that multiple requests occurring concurrently causing security identity corruption across concurrent threads when using EE Security with WildFly Elytron which can lead to the possibility of being handled using the identity from another request.", "other": {"cve": {"id": "CVE-2020-1732", "sourceIdentifier": "secalert@redhat.com", "published": "2020-05-04T17:15:12.357", "lastModified": "2020-05-08T17:28:01.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in Soteria before 1.0.1, in a way that multiple requests occurring concurrently causing security identity corruption across concurrent threads when using EE Security with WildFly Elytron which can lead to the possibility of being handled using the identity from another request."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en Soteria versiones anteriores a la versi\u00f3n 1.0.1, en un modo en el que m\u00faltiples peticiones pueden ocurrir  simult\u00e1neamente causan una corrupci\u00f3n de identidad de seguridad por medio de subprocesos (hilos) concurrentes cuando se usa EE Security con WildFly Elytron, lo que puede conllevar a una posibilidad de que se maneje usando la identidad de otra petici\u00f3n ."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.5}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:soteria:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "4045E651-4CE2-463E-90EC-62ED2B5E488F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "72A54BDA-311C-413B-8E4D-388AD65A170A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform_continuous_delivery:-:*:*:*:*:*:*:*", "matchCriteriaId": "BEFE06C8-4BF0-4EC0-A848-BF16CFCCDA57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_application_runtimes:-:*:*:*:*:*:*:*", "matchCriteriaId": "A33441B3-B301-426C-A976-08CE5FE72EFB"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-1732", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/wildfly-security/soteria/commit/c2479f8c39d7d661341fdcaff7f5e97c5eea1a54", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wildfly-security/soteria/commit/c2479f8c39d7d661341fdcaff7f5e97c5eea1a54"}}