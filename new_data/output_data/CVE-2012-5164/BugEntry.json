{"buggy_code": ["<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the autocomplete-action, it will output a list of searches that start with a certain string.\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxAutocomplete extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\t// call parent, this will probably add some general CSS/JS or other required files\n\t\tparent::execute();\n\n\t\t// get parameters\n\t\t$term = SpoonFilter::getPostValue('term', null, '');\n\t\t$limit = (int) FrontendModel::getModuleSetting('search', 'autocomplete_num_items', 10);\n\n\t\t// validate\n\t\tif($term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\n\t\t// get matches\n\t\t$matches = FrontendSearchModel::getStartsWith($term, FRONTEND_LANGUAGE, $limit);\n\n\t\t// get search url\n\t\t$url = FrontendNavigation::getURLForBlock('search');\n\n\t\t// loop items and set search url\n\t\tforeach($matches as &$match) $match['url'] = $url . '?form=search&q=' . $match['term'];\n\n\t\t// output\n\t\t$this->output(self::OK, $matches);\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the autosuggest-action, it will output a list of results for a certain search\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxAutosuggest extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Name of the cachefile\n\t *\n\t * @var\tstring\n\t */\n\tprivate $cacheFile;\n\n\t/**\n\t * The items\n\t *\n\t * @var\tarray\n\t */\n\tprivate $items;\n\n\t/**\n\t * Limit of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $limit;\n\n\t/**\n\t * Offset of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $offset;\n\n\t/**\n\t * The pagination array\n\t * It will hold all needed parameters, some of them need initialization.\n\t *\n\t * @var\tarray\n\t */\n\tprotected $pagination = array('limit' => 20, 'offset' => 0, 'requested_page' => 1, 'num_items' => null, 'num_pages' => null);\n\n\t/**\n\t * The requested page\n\t *\n\t * @var\tint\n\t */\n\tprivate $requestedPage;\n\n\t/**\n\t * The search term\n\t *\n\t * @var string\n\t */\n\tprivate $term = '';\n\n\t/**\n\t * Display\n\t */\n\tprivate function display()\n\t{\n\t\t// set variables\n\t\t$this->requestedPage = 1;\n\t\t$this->limit = (int) FrontendModel::getModuleSetting('search', 'autosuggest_num_items', 10);\n\t\t$this->offset = ($this->requestedPage * $this->limit) - $this->limit;\n\t\t$this->cacheFile = FRONTEND_CACHE_PATH . '/' . $this->getModule() . '/' . FRONTEND_LANGUAGE . '_' . md5($this->term) . '_' . $this->offset . '_' . $this->limit . '.php';\n\n\t\t// load the cached data\n\t\tif(!$this->getCachedData())\n\t\t{\n\t\t\t// ... or load the real data\n\t\t\t$this->getRealData();\n\t\t}\n\n\t\t// parse\n\t\t$this->parse();\n\t}\n\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\t\t$this->validateForm();\n\t\t$this->display();\n\t}\n\n\t/**\n\t * Load the cached data\n\t *\n\t * @return bool\n\t */\n\tprivate function getCachedData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return false;\n\n\t\t// debug mode = no cache\n\t\tif(SPOON_DEBUG) return false;\n\n\t\t// check if cachefile exists\n\t\tif(!SpoonFile::exists($this->cacheFile)) return false;\n\n\t\t// get cachefile modification time\n\t\t$cacheInfo = @filemtime($this->cacheFile);\n\n\t\t// check if cache file is recent enough (1 hour)\n\t\tif(!$cacheInfo || $cacheInfo < strtotime('-1 hour')) return false;\n\n\t\t// include cache file\n\t\trequire_once $this->cacheFile;\n\n\t\t// set info\n\t\t$this->pagination = $pagination;\n\t\t$this->items = $items;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Load the data\n\t */\n\tprivate function getRealData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// set url\n\t\t$this->pagination['url'] = FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term;\n\t\t$this->pagination['limit'] = FrontendModel::getModuleSetting('search', 'overview_num_items', 20);\n\n\t\t// populate calculated fields in pagination\n\t\t$this->pagination['requested_page'] = $this->requestedPage;\n\t\t$this->pagination['offset'] = ($this->pagination['requested_page'] * $this->pagination['limit']) - $this->pagination['limit'];\n\n\t\t// get items\n\t\t$this->items = FrontendSearchModel::search($this->term, $this->pagination['limit'], $this->pagination['offset']);\n\n\t\t// populate count fields in pagination\n\t\t// this is done after actual search because some items might be activated/deactivated (getTotal only does rough checking)\n\t\t$this->pagination['num_items'] = FrontendSearchModel::getTotal($this->term);\n\t\t$this->pagination['num_pages'] = (int) ceil($this->pagination['num_items'] / $this->pagination['limit']);\n\n\t\t// num pages is always equal to at least 1\n\t\tif($this->pagination['num_pages'] == 0) $this->pagination['num_pages'] = 1;\n\n\t\t// redirect if the request page doesn't exist\n\t\tif($this->requestedPage > $this->pagination['num_pages'] || $this->requestedPage < 1) $this->redirect(FrontendNavigation::getURL(404));\n\n\t\t// debug mode = no cache\n\t\tif(!SPOON_DEBUG)\n\t\t{\n\t\t\t// set cache content\n\t\t\tSpoonFile::setContent($this->cacheFile, \"<?php\\n\" . '$pagination = ' . var_export($this->pagination, true) . \";\\n\" . '$items = ' . var_export($this->items, true) . \";\\n?>\");\n\t\t}\n\t}\n\n\tpublic function parse()\n\t{\n\t\t// more matches to be found than?\n\t\tif($this->pagination['num_items'] > count($this->items))\n\t\t{\n\t\t\t// remove last result (to add this reference)\n\t\t\tarray_pop($this->items);\n\n\t\t\t// add reference to full search results page\n\t\t\t$this->items[] = array(\n\t\t\t\t'title' => FL::lbl('More'),\n\t\t\t\t'text' => FL::msg('MoreResults'),\n\t\t\t\t'full_url' => FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term\n\t\t\t);\n\t\t}\n\n\t\t// format data\n\t\tforeach($this->items as &$item)\n\t\t{\n\t\t\t// full url is set?\n\t\t\tif(!isset($item['full_url'])) continue;\n\n\t\t\t// build utm array\n\t\t\t$utm['utm_source'] = SpoonFilter::urlise(FrontendModel::getModuleSetting('core', 'site_title_' . FRONTEND_LANGUAGE, SITE_DEFAULT_TITLE));\n\t\t\t$utm['utm_medium'] = 'fork-search';\n\t\t\t$utm['utm_term'] = $this->term;\n\n\t\t\t// get parameters in url already\n\t\t\tif(strpos($item['full_url'], '?') !== false) $glue = '&';\n\t\t\telse $glue = '?';\n\n\t\t\t// add utm to url\n\t\t\t$item['full_url'] .= $glue . http_build_query($utm, '', '&');\n\n\t\t\t// format description\n\t\t\t$item['text'] = !empty($item['text']) ? (mb_strlen($item['text']) > $this->length ? mb_substr(strip_tags($item['text']), 0, $this->length, SPOON_CHARSET) . '\u2026' : $item['text']) : '';\n\t\t}\n\n\t\t// output\n\t\t$this->output(self::OK, $this->items);\n\t}\n\n\t/**\n\t * Validate the form\n\t */\n\tprivate function validateForm()\n\t{\n\t\t// set values\n\t\t$this->term = SpoonFilter::getPostValue('term', null, '');\n\t\t$this->length = (int) SpoonFilter::getPostValue('length', null, 50);\n\n\t\t// validate\n\t\tif($this->term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the livesuggest-action, it will output a list of results for a certain search\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxLivesuggest extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Name of the cachefile\n\t *\n\t * @var\tstring\n\t */\n\tprivate $cacheFile;\n\n\t/**\n\t * The items\n\t *\n\t * @var\tarray\n\t */\n\tprivate $items;\n\n\t/**\n\t * Limit of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $limit;\n\n\t/**\n\t * Offset of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $offset;\n\n\t/**\n\t * The pagination array\n\t * It will hold all needed parameters, some of them need initialization.\n\t *\n\t * @var\tarray\n\t */\n\tprotected $pagination = array('limit' => 20, 'offset' => 0, 'requested_page' => 1, 'num_items' => null, 'num_pages' => null);\n\n\t/**\n\t * The requested page\n\t *\n\t * @var\tint\n\t */\n\tprivate $requestedPage;\n\n\t/**\n\t * The search term\n\t *\n\t * @var string\n\t */\n\tprivate $term = '';\n\n\t/**\n\t * Display\n\t */\n\tprivate function display()\n\t{\n\t\t// set variables\n\t\t$this->requestedPage = 1;\n\t\t$this->limit = (int) FrontendModel::getModuleSetting('search', 'overview_num_items', 20);\n\t\t$this->offset = ($this->requestedPage * $this->limit) - $this->limit;\n\t\t$this->cacheFile = FRONTEND_CACHE_PATH . '/' . $this->getModule() . '/' . FRONTEND_LANGUAGE . '_' . md5($this->term) . '_' . $this->offset . '_' . $this->limit . '.php';\n\n\t\t// load the cached data\n\t\tif(!$this->getCachedData())\n\t\t{\n\t\t\t// ... or load the real data\n\t\t\t$this->getRealData();\n\t\t}\n\n\t\t// parse\n\t\t$this->parse();\n\n\t\t// output\n\t\t$this->output(self::OK, $this->tpl->getContent(FRONTEND_PATH . '/modules/search/layout/templates/results.tpl', false, true));\n\t}\n\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\t\t$this->loadTemplate();\n\t\t$this->validateForm();\n\t\t$this->display();\n\t}\n\n\t/**\n\t * Load the cached data\n\t * @todo\trefactor me\n\t *\n\t * @return bool\n\t */\n\tprivate function getCachedData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return false;\n\n\t\t// debug mode = no cache\n\t\tif(SPOON_DEBUG) return false;\n\n\t\t// check if cachefile exists\n\t\tif(!SpoonFile::exists($this->cacheFile)) return false;\n\n\t\t// get cachefile modification time\n\t\t$cacheInfo = @filemtime($this->cacheFile);\n\n\t\t// check if cache file is recent enough (1 hour)\n\t\tif(!$cacheInfo || $cacheInfo < strtotime('-1 hour')) return false;\n\n\t\t// include cache file\n\t\trequire_once $this->cacheFile;\n\n\t\t// set info\n\t\t$this->pagination = $pagination;\n\t\t$this->items = $items;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Load the data\n\t */\n\tprivate function getRealData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// set url\n\t\t$this->pagination['url'] = FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term;\n\n\t\t// populate calculated fields in pagination\n\t\t$this->pagination['limit'] = $this->limit;\n\t\t$this->pagination['offset'] = $this->offset;\n\t\t$this->pagination['requested_page'] = $this->requestedPage;\n\n\t\t// get items\n\t\t$this->items = FrontendSearchModel::search($this->term, $this->pagination['limit'], $this->pagination['offset']);\n\n\t\t// populate count fields in pagination\n\t\t// this is done after actual search because some items might be activated/deactivated (getTotal only does rough checking)\n\t\t$this->pagination['num_items'] = FrontendSearchModel::getTotal($this->term);\n\t\t$this->pagination['num_pages'] = (int) ceil($this->pagination['num_items'] / $this->pagination['limit']);\n\n\t\t// num pages is always equal to at least 1\n\t\tif($this->pagination['num_pages'] == 0) $this->pagination['num_pages'] = 1;\n\n\t\t// redirect if the request page doesn't exist\n\t\tif($this->requestedPage > $this->pagination['num_pages'] || $this->requestedPage < 1) $this->redirect(FrontendNavigation::getURL(404));\n\n\t\t// debug mode = no cache\n\t\tif(!SPOON_DEBUG)\n\t\t{\n\t\t\t// set cache content\n\t\t\tSpoonFile::setContent($this->cacheFile, \"<?php\\n\" . '$pagination = ' . var_export($this->pagination, true) . \";\\n\" . '$items = ' . var_export($this->items, true) . \";\\n?>\");\n\t\t}\n\t}\n\n\t/**\n\t * Load the template\n\t */\n\tprotected function loadTemplate()\n\t{\n\t\t// create template\n\t\t$this->tpl = new FrontendTemplate(false);\n\t}\n\n\t/**\n\t * Parse the data into the template\n\t */\n\tprivate function parse()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// loop items\n\t\tforeach($this->items as &$item)\n\t\t{\n\t\t\t// full url is set?\n\t\t\tif(!isset($item['full_url'])) continue;\n\n\t\t\t// build utm array\n\t\t\t$utm['utm_source'] = SpoonFilter::urlise(FrontendModel::getModuleSetting('core', 'site_title_' . FRONTEND_LANGUAGE, SITE_DEFAULT_TITLE));\n\t\t\t$utm['utm_medium'] = 'fork-search';\n\t\t\t$utm['utm_term'] = $this->term;\n\n\t\t\t// get parameters in url already\n\t\t\tif(strpos($item['full_url'], '?') !== false) $glue = '&amp;';\n\t\t\telse $glue = '?';\n\n\t\t\t// add utm to url\n\t\t\t$item['full_url'] .= $glue . http_build_query($utm, '', '&amp;');\n\t\t}\n\n\t\t// assign articles\n\t\t$this->tpl->assign('searchResults', $this->items);\n\t\t$this->tpl->assign('searchTerm', $this->term);\n\n\t\t// parse the pagination\n\t\t$this->parsePagination();\n\t}\n\n\t/**\n\t * Parse pagination\n\t */\n\tprotected function parsePagination()\n\t{\n\t\t// init var\n\t\t$pagination = null;\n\t\t$showFirstPages = false;\n\t\t$showLastPages = false;\n\t\t$useQuestionMark = true;\n\n\t\t// validate pagination array\n\t\tif(!isset($this->pagination['limit'])) throw new FrontendException('no limit in the pagination-property.');\n\t\tif(!isset($this->pagination['offset'])) throw new FrontendException('no offset in the pagination-property.');\n\t\tif(!isset($this->pagination['requested_page'])) throw new FrontendException('no requested_page available in the pagination-property.');\n\t\tif(!isset($this->pagination['num_items'])) throw new FrontendException('no num_items available in the pagination-property.');\n\t\tif(!isset($this->pagination['num_pages'])) throw new FrontendException('no num_pages available in the pagination-property.');\n\t\tif(!isset($this->pagination['url'])) throw new FrontendException('no URL available in the pagination-property.');\n\n\t\t// should we use a questionmark or an ampersand\n\t\tif(mb_strpos($this->pagination['url'], '?') > 0) $useQuestionMark = false;\n\n\t\t// no pagination needed\n\t\tif($this->pagination['num_pages'] < 1) return;\n\n\t\t// populate count fields\n\t\t$pagination['num_pages'] = $this->pagination['num_pages'];\n\t\t$pagination['current_page'] = $this->pagination['requested_page'];\n\n\t\t// as long as we are below page 5 we should show all pages starting from 1\n\t\tif($this->pagination['requested_page'] < 6)\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = 1;\n\t\t\t$pagesEnd = ($this->pagination['num_pages'] >= 6) ? 6 : $this->pagination['num_pages'];\n\n\t\t\t// show last pages\n\t\t\tif($this->pagination['num_pages'] > 5) $showLastPages = true;\n\t\t}\n\n\t\t// as long as we are 5 pages from the end we should show all pages till the end\n\t\telseif($this->pagination['requested_page'] >= ($this->pagination['num_pages'] - 4))\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = ($this->pagination['num_pages'] - 5);\n\t\t\t$pagesEnd = $this->pagination['num_pages'];\n\n\t\t\t// show first pages\n\t\t\tif($this->pagination['num_pages'] > 5) $showFirstPages = true;\n\t\t}\n\n\t\t// page 7\n\t\telse\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = $this->pagination['requested_page'] - 2;\n\t\t\t$pagesEnd = $this->pagination['requested_page'] + 2;\n\t\t\t$showFirstPages = true;\n\t\t\t$showLastPages = true;\n\t\t}\n\n\t\t// show previous\n\t\tif($this->pagination['requested_page'] > 1)\n\t\t{\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . ($this->pagination['requested_page'] - 1);\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . ($this->pagination['requested_page'] - 1);\n\n\t\t\t// set\n\t\t\t$pagination['show_previous'] = true;\n\t\t\t$pagination['previous_url'] = $URL;\n\t\t}\n\n\t\t// show first pages?\n\t\tif($showFirstPages)\n\t\t{\n\t\t\t// init var\n\t\t\t$pagesFirstStart = 1;\n\t\t\t$pagesFirstEnd = 1;\n\n\t\t\t// loop pages\n\t\t\tfor($i = $pagesFirstStart; $i <= $pagesFirstEnd; $i++)\n\t\t\t{\n\t\t\t\t// build URL\n\t\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t\t// add\n\t\t\t\t$pagination['first'][] = array('url' => $URL, 'label' => $i);\n\t\t\t}\n\t\t}\n\n\t\t// build array\n\t\tfor($i = $pagesStart; $i <= $pagesEnd; $i++)\n\t\t{\n\t\t\t// init var\n\t\t\t$current = ($i == $this->pagination['requested_page']);\n\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t// add\n\t\t\t$pagination['pages'][] = array('url' => $URL, 'label' => $i, 'current' => $current);\n\t\t}\n\n\t\t// show last pages?\n\t\tif($showLastPages)\n\t\t{\n\t\t\t// init var\n\t\t\t$pagesLastStart = $this->pagination['num_pages'];\n\t\t\t$pagesLastEnd = $this->pagination['num_pages'];\n\n\t\t\t// loop pages\n\t\t\tfor($i = $pagesLastStart; $i <= $pagesLastEnd; $i++)\n\t\t\t{\n\t\t\t\t// build URL\n\t\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t\t// add\n\t\t\t\t$pagination['last'][] = array('url' => $URL, 'label' => $i);\n\t\t\t}\n\t\t}\n\n\t\t// show next\n\t\tif($this->pagination['requested_page'] < $this->pagination['num_pages'])\n\t\t{\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . ($this->pagination['requested_page'] + 1);\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . ($this->pagination['requested_page'] + 1);\n\n\t\t\t// set\n\t\t\t$pagination['show_next'] = true;\n\t\t\t$pagination['next_url'] = $URL;\n\t\t}\n\n\t\t// multiple pages\n\t\t$pagination['multiple_pages'] = ($pagination['num_pages'] == 1) ? false : true;\n\n\t\t// assign pagination\n\t\t$this->tpl->assign('pagination', $pagination);\n\t}\n\n\t/**\n\t * Validate the form\n\t */\n\tprivate function validateForm()\n\t{\n\t\t// set search term\n\t\t$this->term = SpoonFilter::getPostValue('term', null, '');\n\n\t\t// validate\n\t\tif($this->term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the save-action, it will save the searched term in the statistics\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxSave extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\n\t\t// get parameters\n\t\t$term = SpoonFilter::getPostValue('term', null, '');\n\n\t\t// validate\n\t\tif($term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\n\t\t// previous search result\n\t\t$previousTerm = SpoonSession::exists('searchTerm') ? SpoonSession::get('searchTerm') : '';\n\t\tSpoonSession::set('searchTerm', '');\n\n\t\t// save this term?\n\t\tif($previousTerm != $term)\n\t\t{\n\t\t\t// format data\n\t\t\t$this->statistics = array();\n\t\t\t$this->statistics['term'] = $term;\n\t\t\t$this->statistics['language'] = FRONTEND_LANGUAGE;\n\t\t\t$this->statistics['time'] = FrontendModel::getUTCDate();\n\t\t\t$this->statistics['data'] = serialize(array('server' => $_SERVER));\n\t\t\t$this->statistics['num_results'] = FrontendSearchModel::getTotal($term);\n\n\t\t\t// save data\n\t\t\tFrontendSearchModel::save($this->statistics);\n\t\t}\n\n\t\t// save current search term in cookie\n\t\tSpoonSession::set('searchTerm', $term);\n\n\t\t// output\n\t\t$this->output(self::OK);\n\t}\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the autocomplete-action, it will output a list of searches that start with a certain string.\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxAutocomplete extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\t// call parent, this will probably add some general CSS/JS or other required files\n\t\tparent::execute();\n\n\t\t// get parameters\n\t\t$searchTerm = SpoonFilter::getPostValue('term', null, '');\n\t\t$term = (SPOON_CHARSET == 'utf-8') ? SpoonFilter::htmlspecialchars($searchTerm) : SpoonFilter::htmlentities($searchTerm);\n\t\t$limit = (int) FrontendModel::getModuleSetting('search', 'autocomplete_num_items', 10);\n\n\t\t// validate\n\t\tif($term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\n\t\t// get matches\n\t\t$matches = FrontendSearchModel::getStartsWith($term, FRONTEND_LANGUAGE, $limit);\n\n\t\t// get search url\n\t\t$url = FrontendNavigation::getURLForBlock('search');\n\n\t\t// loop items and set search url\n\t\tforeach($matches as &$match) $match['url'] = $url . '?form=search&q=' . $match['term'];\n\n\t\t// output\n\t\t$this->output(self::OK, $matches);\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the autosuggest-action, it will output a list of results for a certain search\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxAutosuggest extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Name of the cachefile\n\t *\n\t * @var\tstring\n\t */\n\tprivate $cacheFile;\n\n\t/**\n\t * The items\n\t *\n\t * @var\tarray\n\t */\n\tprivate $items;\n\n\t/**\n\t * Limit of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $limit;\n\n\t/**\n\t * Offset of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $offset;\n\n\t/**\n\t * The pagination array\n\t * It will hold all needed parameters, some of them need initialization.\n\t *\n\t * @var\tarray\n\t */\n\tprotected $pagination = array('limit' => 20, 'offset' => 0, 'requested_page' => 1, 'num_items' => null, 'num_pages' => null);\n\n\t/**\n\t * The requested page\n\t *\n\t * @var\tint\n\t */\n\tprivate $requestedPage;\n\n\t/**\n\t * The search term\n\t *\n\t * @var string\n\t */\n\tprivate $term = '';\n\n\t/**\n\t * Display\n\t */\n\tprivate function display()\n\t{\n\t\t// set variables\n\t\t$this->requestedPage = 1;\n\t\t$this->limit = (int) FrontendModel::getModuleSetting('search', 'autosuggest_num_items', 10);\n\t\t$this->offset = ($this->requestedPage * $this->limit) - $this->limit;\n\t\t$this->cacheFile = FRONTEND_CACHE_PATH . '/' . $this->getModule() . '/' . FRONTEND_LANGUAGE . '_' . md5($this->term) . '_' . $this->offset . '_' . $this->limit . '.php';\n\n\t\t// load the cached data\n\t\tif(!$this->getCachedData())\n\t\t{\n\t\t\t// ... or load the real data\n\t\t\t$this->getRealData();\n\t\t}\n\n\t\t// parse\n\t\t$this->parse();\n\t}\n\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\t\t$this->validateForm();\n\t\t$this->display();\n\t}\n\n\t/**\n\t * Load the cached data\n\t *\n\t * @return bool\n\t */\n\tprivate function getCachedData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return false;\n\n\t\t// debug mode = no cache\n\t\tif(SPOON_DEBUG) return false;\n\n\t\t// check if cachefile exists\n\t\tif(!SpoonFile::exists($this->cacheFile)) return false;\n\n\t\t// get cachefile modification time\n\t\t$cacheInfo = @filemtime($this->cacheFile);\n\n\t\t// check if cache file is recent enough (1 hour)\n\t\tif(!$cacheInfo || $cacheInfo < strtotime('-1 hour')) return false;\n\n\t\t// include cache file\n\t\trequire_once $this->cacheFile;\n\n\t\t// set info\n\t\t$this->pagination = $pagination;\n\t\t$this->items = $items;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Load the data\n\t */\n\tprivate function getRealData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// set url\n\t\t$this->pagination['url'] = FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term;\n\t\t$this->pagination['limit'] = FrontendModel::getModuleSetting('search', 'overview_num_items', 20);\n\n\t\t// populate calculated fields in pagination\n\t\t$this->pagination['requested_page'] = $this->requestedPage;\n\t\t$this->pagination['offset'] = ($this->pagination['requested_page'] * $this->pagination['limit']) - $this->pagination['limit'];\n\n\t\t// get items\n\t\t$this->items = FrontendSearchModel::search($this->term, $this->pagination['limit'], $this->pagination['offset']);\n\n\t\t// populate count fields in pagination\n\t\t// this is done after actual search because some items might be activated/deactivated (getTotal only does rough checking)\n\t\t$this->pagination['num_items'] = FrontendSearchModel::getTotal($this->term);\n\t\t$this->pagination['num_pages'] = (int) ceil($this->pagination['num_items'] / $this->pagination['limit']);\n\n\t\t// num pages is always equal to at least 1\n\t\tif($this->pagination['num_pages'] == 0) $this->pagination['num_pages'] = 1;\n\n\t\t// redirect if the request page doesn't exist\n\t\tif($this->requestedPage > $this->pagination['num_pages'] || $this->requestedPage < 1) $this->redirect(FrontendNavigation::getURL(404));\n\n\t\t// debug mode = no cache\n\t\tif(!SPOON_DEBUG)\n\t\t{\n\t\t\t// set cache content\n\t\t\tSpoonFile::setContent($this->cacheFile, \"<?php\\n\" . '$pagination = ' . var_export($this->pagination, true) . \";\\n\" . '$items = ' . var_export($this->items, true) . \";\\n?>\");\n\t\t}\n\t}\n\n\tpublic function parse()\n\t{\n\t\t// more matches to be found than?\n\t\tif($this->pagination['num_items'] > count($this->items))\n\t\t{\n\t\t\t// remove last result (to add this reference)\n\t\t\tarray_pop($this->items);\n\n\t\t\t// add reference to full search results page\n\t\t\t$this->items[] = array(\n\t\t\t\t'title' => FL::lbl('More'),\n\t\t\t\t'text' => FL::msg('MoreResults'),\n\t\t\t\t'full_url' => FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term\n\t\t\t);\n\t\t}\n\n\t\t// format data\n\t\tforeach($this->items as &$item)\n\t\t{\n\t\t\t// full url is set?\n\t\t\tif(!isset($item['full_url'])) continue;\n\n\t\t\t// build utm array\n\t\t\t$utm['utm_source'] = SpoonFilter::urlise(FrontendModel::getModuleSetting('core', 'site_title_' . FRONTEND_LANGUAGE, SITE_DEFAULT_TITLE));\n\t\t\t$utm['utm_medium'] = 'fork-search';\n\t\t\t$utm['utm_term'] = $this->term;\n\n\t\t\t// get parameters in url already\n\t\t\tif(strpos($item['full_url'], '?') !== false) $glue = '&';\n\t\t\telse $glue = '?';\n\n\t\t\t// add utm to url\n\t\t\t$item['full_url'] .= $glue . http_build_query($utm, '', '&');\n\n\t\t\t// format description\n\t\t\t$item['text'] = !empty($item['text']) ? (mb_strlen($item['text']) > $this->length ? mb_substr(strip_tags($item['text']), 0, $this->length, SPOON_CHARSET) . '\u2026' : $item['text']) : '';\n\t\t}\n\n\t\t// output\n\t\t$this->output(self::OK, $this->items);\n\t}\n\n\t/**\n\t * Validate the form\n\t */\n\tprivate function validateForm()\n\t{\n\t\t// set values\n\t\t$searchTerm = SpoonFilter::getPostValue('term', null, '');\n\t\t$this->term = (SPOON_CHARSET == 'utf-8') ? SpoonFilter::htmlspecialchars($searchTerm) : SpoonFilter::htmlentities($searchTerm);\n\t\t$this->length = (int) SpoonFilter::getPostValue('length', null, 50);\n\n\t\t// validate\n\t\tif($this->term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the livesuggest-action, it will output a list of results for a certain search\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxLivesuggest extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Name of the cachefile\n\t *\n\t * @var\tstring\n\t */\n\tprivate $cacheFile;\n\n\t/**\n\t * The items\n\t *\n\t * @var\tarray\n\t */\n\tprivate $items;\n\n\t/**\n\t * Limit of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $limit;\n\n\t/**\n\t * Offset of data to fetch\n\t *\n\t * @var\tint\n\t */\n\tprivate $offset;\n\n\t/**\n\t * The pagination array\n\t * It will hold all needed parameters, some of them need initialization.\n\t *\n\t * @var\tarray\n\t */\n\tprotected $pagination = array('limit' => 20, 'offset' => 0, 'requested_page' => 1, 'num_items' => null, 'num_pages' => null);\n\n\t/**\n\t * The requested page\n\t *\n\t * @var\tint\n\t */\n\tprivate $requestedPage;\n\n\t/**\n\t * The search term\n\t *\n\t * @var string\n\t */\n\tprivate $term = '';\n\n\t/**\n\t * Display\n\t */\n\tprivate function display()\n\t{\n\t\t// set variables\n\t\t$this->requestedPage = 1;\n\t\t$this->limit = (int) FrontendModel::getModuleSetting('search', 'overview_num_items', 20);\n\t\t$this->offset = ($this->requestedPage * $this->limit) - $this->limit;\n\t\t$this->cacheFile = FRONTEND_CACHE_PATH . '/' . $this->getModule() . '/' . FRONTEND_LANGUAGE . '_' . md5($this->term) . '_' . $this->offset . '_' . $this->limit . '.php';\n\n\t\t// load the cached data\n\t\tif(!$this->getCachedData())\n\t\t{\n\t\t\t// ... or load the real data\n\t\t\t$this->getRealData();\n\t\t}\n\n\t\t// parse\n\t\t$this->parse();\n\n\t\t// output\n\t\t$this->output(self::OK, $this->tpl->getContent(FRONTEND_PATH . '/modules/search/layout/templates/results.tpl', false, true));\n\t}\n\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\t\t$this->loadTemplate();\n\t\t$this->validateForm();\n\t\t$this->display();\n\t}\n\n\t/**\n\t * Load the cached data\n\t * @todo\trefactor me\n\t *\n\t * @return bool\n\t */\n\tprivate function getCachedData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return false;\n\n\t\t// debug mode = no cache\n\t\tif(SPOON_DEBUG) return false;\n\n\t\t// check if cachefile exists\n\t\tif(!SpoonFile::exists($this->cacheFile)) return false;\n\n\t\t// get cachefile modification time\n\t\t$cacheInfo = @filemtime($this->cacheFile);\n\n\t\t// check if cache file is recent enough (1 hour)\n\t\tif(!$cacheInfo || $cacheInfo < strtotime('-1 hour')) return false;\n\n\t\t// include cache file\n\t\trequire_once $this->cacheFile;\n\n\t\t// set info\n\t\t$this->pagination = $pagination;\n\t\t$this->items = $items;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Load the data\n\t */\n\tprivate function getRealData()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// set url\n\t\t$this->pagination['url'] = FrontendNavigation::getURLForBlock('search') . '?form=search&q=' . $this->term;\n\n\t\t// populate calculated fields in pagination\n\t\t$this->pagination['limit'] = $this->limit;\n\t\t$this->pagination['offset'] = $this->offset;\n\t\t$this->pagination['requested_page'] = $this->requestedPage;\n\n\t\t// get items\n\t\t$this->items = FrontendSearchModel::search($this->term, $this->pagination['limit'], $this->pagination['offset']);\n\n\t\t// populate count fields in pagination\n\t\t// this is done after actual search because some items might be activated/deactivated (getTotal only does rough checking)\n\t\t$this->pagination['num_items'] = FrontendSearchModel::getTotal($this->term);\n\t\t$this->pagination['num_pages'] = (int) ceil($this->pagination['num_items'] / $this->pagination['limit']);\n\n\t\t// num pages is always equal to at least 1\n\t\tif($this->pagination['num_pages'] == 0) $this->pagination['num_pages'] = 1;\n\n\t\t// redirect if the request page doesn't exist\n\t\tif($this->requestedPage > $this->pagination['num_pages'] || $this->requestedPage < 1) $this->redirect(FrontendNavigation::getURL(404));\n\n\t\t// debug mode = no cache\n\t\tif(!SPOON_DEBUG)\n\t\t{\n\t\t\t// set cache content\n\t\t\tSpoonFile::setContent($this->cacheFile, \"<?php\\n\" . '$pagination = ' . var_export($this->pagination, true) . \";\\n\" . '$items = ' . var_export($this->items, true) . \";\\n?>\");\n\t\t}\n\t}\n\n\t/**\n\t * Load the template\n\t */\n\tprotected function loadTemplate()\n\t{\n\t\t// create template\n\t\t$this->tpl = new FrontendTemplate(false);\n\t}\n\n\t/**\n\t * Parse the data into the template\n\t */\n\tprivate function parse()\n\t{\n\t\t// no search term = no search\n\t\tif(!$this->term) return;\n\n\t\t// loop items\n\t\tforeach($this->items as &$item)\n\t\t{\n\t\t\t// full url is set?\n\t\t\tif(!isset($item['full_url'])) continue;\n\n\t\t\t// build utm array\n\t\t\t$utm['utm_source'] = SpoonFilter::urlise(FrontendModel::getModuleSetting('core', 'site_title_' . FRONTEND_LANGUAGE, SITE_DEFAULT_TITLE));\n\t\t\t$utm['utm_medium'] = 'fork-search';\n\t\t\t$utm['utm_term'] = $this->term;\n\n\t\t\t// get parameters in url already\n\t\t\tif(strpos($item['full_url'], '?') !== false) $glue = '&amp;';\n\t\t\telse $glue = '?';\n\n\t\t\t// add utm to url\n\t\t\t$item['full_url'] .= $glue . http_build_query($utm, '', '&amp;');\n\t\t}\n\n\t\t// assign articles\n\t\t$this->tpl->assign('searchResults', $this->items);\n\t\t$this->tpl->assign('searchTerm', $this->term);\n\n\t\t// parse the pagination\n\t\t$this->parsePagination();\n\t}\n\n\t/**\n\t * Parse pagination\n\t */\n\tprotected function parsePagination()\n\t{\n\t\t// init var\n\t\t$pagination = null;\n\t\t$showFirstPages = false;\n\t\t$showLastPages = false;\n\t\t$useQuestionMark = true;\n\n\t\t// validate pagination array\n\t\tif(!isset($this->pagination['limit'])) throw new FrontendException('no limit in the pagination-property.');\n\t\tif(!isset($this->pagination['offset'])) throw new FrontendException('no offset in the pagination-property.');\n\t\tif(!isset($this->pagination['requested_page'])) throw new FrontendException('no requested_page available in the pagination-property.');\n\t\tif(!isset($this->pagination['num_items'])) throw new FrontendException('no num_items available in the pagination-property.');\n\t\tif(!isset($this->pagination['num_pages'])) throw new FrontendException('no num_pages available in the pagination-property.');\n\t\tif(!isset($this->pagination['url'])) throw new FrontendException('no URL available in the pagination-property.');\n\n\t\t// should we use a questionmark or an ampersand\n\t\tif(mb_strpos($this->pagination['url'], '?') > 0) $useQuestionMark = false;\n\n\t\t// no pagination needed\n\t\tif($this->pagination['num_pages'] < 1) return;\n\n\t\t// populate count fields\n\t\t$pagination['num_pages'] = $this->pagination['num_pages'];\n\t\t$pagination['current_page'] = $this->pagination['requested_page'];\n\n\t\t// as long as we are below page 5 we should show all pages starting from 1\n\t\tif($this->pagination['requested_page'] < 6)\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = 1;\n\t\t\t$pagesEnd = ($this->pagination['num_pages'] >= 6) ? 6 : $this->pagination['num_pages'];\n\n\t\t\t// show last pages\n\t\t\tif($this->pagination['num_pages'] > 5) $showLastPages = true;\n\t\t}\n\n\t\t// as long as we are 5 pages from the end we should show all pages till the end\n\t\telseif($this->pagination['requested_page'] >= ($this->pagination['num_pages'] - 4))\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = ($this->pagination['num_pages'] - 5);\n\t\t\t$pagesEnd = $this->pagination['num_pages'];\n\n\t\t\t// show first pages\n\t\t\tif($this->pagination['num_pages'] > 5) $showFirstPages = true;\n\t\t}\n\n\t\t// page 7\n\t\telse\n\t\t{\n\t\t\t// init vars\n\t\t\t$pagesStart = $this->pagination['requested_page'] - 2;\n\t\t\t$pagesEnd = $this->pagination['requested_page'] + 2;\n\t\t\t$showFirstPages = true;\n\t\t\t$showLastPages = true;\n\t\t}\n\n\t\t// show previous\n\t\tif($this->pagination['requested_page'] > 1)\n\t\t{\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . ($this->pagination['requested_page'] - 1);\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . ($this->pagination['requested_page'] - 1);\n\n\t\t\t// set\n\t\t\t$pagination['show_previous'] = true;\n\t\t\t$pagination['previous_url'] = $URL;\n\t\t}\n\n\t\t// show first pages?\n\t\tif($showFirstPages)\n\t\t{\n\t\t\t// init var\n\t\t\t$pagesFirstStart = 1;\n\t\t\t$pagesFirstEnd = 1;\n\n\t\t\t// loop pages\n\t\t\tfor($i = $pagesFirstStart; $i <= $pagesFirstEnd; $i++)\n\t\t\t{\n\t\t\t\t// build URL\n\t\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t\t// add\n\t\t\t\t$pagination['first'][] = array('url' => $URL, 'label' => $i);\n\t\t\t}\n\t\t}\n\n\t\t// build array\n\t\tfor($i = $pagesStart; $i <= $pagesEnd; $i++)\n\t\t{\n\t\t\t// init var\n\t\t\t$current = ($i == $this->pagination['requested_page']);\n\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t// add\n\t\t\t$pagination['pages'][] = array('url' => $URL, 'label' => $i, 'current' => $current);\n\t\t}\n\n\t\t// show last pages?\n\t\tif($showLastPages)\n\t\t{\n\t\t\t// init var\n\t\t\t$pagesLastStart = $this->pagination['num_pages'];\n\t\t\t$pagesLastEnd = $this->pagination['num_pages'];\n\n\t\t\t// loop pages\n\t\t\tfor($i = $pagesLastStart; $i <= $pagesLastEnd; $i++)\n\t\t\t{\n\t\t\t\t// build URL\n\t\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . $i;\n\t\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . $i;\n\n\t\t\t\t// add\n\t\t\t\t$pagination['last'][] = array('url' => $URL, 'label' => $i);\n\t\t\t}\n\t\t}\n\n\t\t// show next\n\t\tif($this->pagination['requested_page'] < $this->pagination['num_pages'])\n\t\t{\n\t\t\t// build URL\n\t\t\tif($useQuestionMark) $URL = $this->pagination['url'] . '?page=' . ($this->pagination['requested_page'] + 1);\n\t\t\telse $URL = $this->pagination['url'] . '&amp;page=' . ($this->pagination['requested_page'] + 1);\n\n\t\t\t// set\n\t\t\t$pagination['show_next'] = true;\n\t\t\t$pagination['next_url'] = $URL;\n\t\t}\n\n\t\t// multiple pages\n\t\t$pagination['multiple_pages'] = ($pagination['num_pages'] == 1) ? false : true;\n\n\t\t// assign pagination\n\t\t$this->tpl->assign('pagination', $pagination);\n\t}\n\n\t/**\n\t * Validate the form\n\t */\n\tprivate function validateForm()\n\t{\n\t\t// set search term\n\t\t$searchTerm = SpoonFilter::getPostValue('term', null, '');\n\t\t$this->term = (SPOON_CHARSET == 'utf-8') ? SpoonFilter::htmlspecialchars($searchTerm) : SpoonFilter::htmlentities($searchTerm);\n\n\t\t// validate\n\t\tif($this->term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\t}\n}\n", "<?php\n\n/*\n * This file is part of Fork CMS.\n *\n * For the full copyright and license information, please view the license\n * file that was distributed with this source code.\n */\n\n/**\n * This is the save-action, it will save the searched term in the statistics\n *\n * @author Matthias Mullie <matthias@mullie.eu>\n */\nclass FrontendSearchAjaxSave extends FrontendBaseAJAXAction\n{\n\t/**\n\t * Execute the action\n\t */\n\tpublic function execute()\n\t{\n\t\tparent::execute();\n\n\t\t// get parameters\n\t\t$searchTerm = SpoonFilter::getPostValue('term', null, '');\n\t\t$term = (SPOON_CHARSET == 'utf-8') ? SpoonFilter::htmlspecialchars($searchTerm) : SpoonFilter::htmlentities($searchTerm);\n\n\t\t// validate\n\t\tif($term == '') $this->output(self::BAD_REQUEST, null, 'term-parameter is missing.');\n\n\t\t// previous search result\n\t\t$previousTerm = SpoonSession::exists('searchTerm') ? SpoonSession::get('searchTerm') : '';\n\t\tSpoonSession::set('searchTerm', '');\n\n\t\t// save this term?\n\t\tif($previousTerm != $term)\n\t\t{\n\t\t\t// format data\n\t\t\t$this->statistics = array();\n\t\t\t$this->statistics['term'] = $term;\n\t\t\t$this->statistics['language'] = FRONTEND_LANGUAGE;\n\t\t\t$this->statistics['time'] = FrontendModel::getUTCDate();\n\t\t\t$this->statistics['data'] = serialize(array('server' => $_SERVER));\n\t\t\t$this->statistics['num_results'] = FrontendSearchModel::getTotal($term);\n\n\t\t\t// save data\n\t\t\tFrontendSearchModel::save($this->statistics);\n\t\t}\n\n\t\t// save current search term in cookie\n\t\tSpoonSession::set('searchTerm', $term);\n\n\t\t// output\n\t\t$this->output(self::OK);\n\t}\n}\n"], "filenames": ["frontend/modules/search/ajax/autocomplete.php", "frontend/modules/search/ajax/autosuggest.php", "frontend/modules/search/ajax/livesuggest.php", "frontend/modules/search/ajax/save.php"], "buggy_code_start_loc": [26, 217, 368, 25], "buggy_code_end_loc": [27, 218, 369, 26], "fixing_code_start_loc": [26, 217, 368, 25], "fixing_code_end_loc": [28, 219, 370, 27], "type": "CWE-79", "message": "Multiple cross-site scripting (XSS) vulnerabilities in Fork CMS before 3.2.7 allow remote attackers to inject arbitrary web script or HTML via the term parameter to (1) autocomplete.php, (2) search/ajax/autosuggest.php, (3) livesuggest.php, or (4) save.php in frontend/modules/search/ajax.", "other": {"cve": {"id": "CVE-2012-5164", "sourceIdentifier": "cve@mitre.org", "published": "2012-09-26T00:55:01.253", "lastModified": "2017-08-29T01:32:31.977", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple cross-site scripting (XSS) vulnerabilities in Fork CMS before 3.2.7 allow remote attackers to inject arbitrary web script or HTML via the term parameter to (1) autocomplete.php, (2) search/ajax/autosuggest.php, (3) livesuggest.php, or (4) save.php in frontend/modules/search/ajax."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de ejecuci\u00f3n de secuencias de comandos en sitios cruzados (XSS) en Fork CMS antes de v3.2.7, permite a atacantes remotos inyectar secuencias de comandos web o HTML a trav\u00e9s del par\u00e1metro term en (1) autocomplete.php, (2) search/ajax/autosuggest.php, (3) livesuggest.php, o (4) save.php en frontend/modules/search/ajax."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.6", "matchCriteriaId": "991AA820-6999-41A5-9BBC-AAB8549FA093"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "04865811-D4B6-48F5-B6F8-CFBD94982042"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "1552D83A-FF47-4E4F-8443-0AE5E15AB610"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "7D4185C5-72A7-4F24-9E89-414B4DE0C794"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "5D4496EC-0341-467C-933D-83C99984F848"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "B3353A5A-85B7-48C3-A323-39CFE6C063B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "CA075476-C327-41B0-B8F9-B82B4B1FDD3A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "92D83C75-86E8-469D-8AC2-B65ABB794B0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "20431B98-AF44-4629-BCA2-D50E7DBE15F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "16B58D49-E05B-40C9-B623-F763E2C56621"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "D01B0E6B-42A2-418E-8655-142482446E4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "483398DC-3F20-4197-94B0-691DE60E33BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "44BB4F2D-A5CA-4101-89F1-25224A595D95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "F53B800E-ADB0-4222-87F2-0F2FD731447F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "098D6120-E54D-4FF8-9D8A-FA3D22AAB821"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "EE0E9C09-00F9-4843-B7B7-BBDD6AC4A7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A7E17327-D85F-4676-8D78-3BD800220FD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "86E5FF4D-09BF-4F69-B4F0-3407E92AB024"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "7B9A1683-6E5D-4542-AC00-C7E200EDA3BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "01DB78DA-56F0-465E-B7BE-BA19FC6A062C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "9227B38E-8363-4515-B698-3408968D9856"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "671A43F3-E9EB-405C-A770-A6C86F7A3BB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "87512DA7-0F13-4642-929D-AA73599D5A77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.12:*:*:*:*:*:*:*", "matchCriteriaId": "6B6DD3CA-3548-4347-A607-8D0C8D47DD97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:2.6.13:*:*:*:*:*:*:*", "matchCriteriaId": "38E0C06A-B2A7-41A8-96F5-4F8B72D11BAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "B5A29A25-D710-4038-BAF6-E94D42BD4505"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "A5D03DB0-4371-4867-B93B-4649932132F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "F0575A8C-EE3B-45C7-B023-79FA8A9484F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "CCF9AA18-A518-4377-B44B-C11531EB4DB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "BBF37511-B776-4BF4-95D4-23E6564F3482"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "01617BA1-36BC-4A29-9C50-9205B2A4FC3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "8C6F4126-98AD-48A6-BE9D-112A24AB9CB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "6600EE62-8DF9-4B23-AFA5-A46050B2395B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "9FB676F0-C59F-4E1B-BD13-6379B7989B7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "C1B632F4-F60E-4D6E-AC4E-C3D4C97DC3A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "502BCE30-1C75-4ECF-B13F-52BD11655FC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "2603FC89-C95A-4AB0-A113-E2C0C3B8C156"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "8F92CCA1-C40C-477B-A584-DB122B2FEC98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "6B5340B4-46C5-4237-9323-FE0A69A9772B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "4481E484-0B63-4E6C-9EFE-B7F6ED80DAFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "23B9738D-A6BD-4D66-938C-05176D0A3DB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "09F544A7-D7C6-47A1-B633-42A36B3F9CBC"}]}]}], "references": [{"url": "http://www.fork-cms.com/blog/detail/fork-cms-3-2-7-released", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/78957", "source": "cve@mitre.org"}, {"url": "https://github.com/forkcms/forkcms/commit/03e8f5b53f193a87116b3875eec39769d5c07114", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/forkcms/forkcms/commit/641e27bf1e9a7e320d6856399a7c274934bb351e", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/forkcms/forkcms/pull/247", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/forkcms/forkcms/commit/641e27bf1e9a7e320d6856399a7c274934bb351e"}}