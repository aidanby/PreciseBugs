{"buggy_code": ["// Load modules\n\nvar Fs = require('fs');\nvar Path = require('path');\nvar Boom = require('boom');\nvar Hoek = require('hoek');\nvar Items = require('items');\nvar Joi = require('joi');\nvar File = require('./file');\n\n\n// Declare internals\n\nvar internals = {};\n\n\ninternals.schema = Joi.object({\n    path: Joi.alternatives(Joi.string(), Joi.array().includes(Joi.string()), Joi.func()).required(),\n    index: Joi.boolean(),\n    listing: Joi.boolean(),\n    showHidden: Joi.boolean(),\n    redirectToSlash: Joi.boolean(),\n    lookupCompressed: Joi.boolean(),\n    defaultExtension: Joi.string().alphanum()\n});\n\n\nexports.handler = function (route, options) {\n\n    Joi.assert(options, internals.schema, 'Invalid directory handler options (' + route.path + ')');\n    Hoek.assert(route.path[route.path.length - 1] === '}', 'The route path must end with a parameter:', route.path);\n\n    var settings = Hoek.clone(options);                                // options can be reused\n\n    // Normalize static string path\n\n    if (typeof settings.path === 'string') {\n        settings.path = [settings.path];\n    }\n\n    var normalize = function (paths) {\n\n        var normalized = [];\n        for (var i = 0, il = paths.length; i < il; ++i) {\n            var path = paths[i];\n            if (path[path.length - 1] !== Path.sep) {\n                path += Path.sep;\n            }\n\n            if (!Hoek.isAbsolutePath(path)) {\n                path = Path.join(route.files.relativeTo, path);\n            }\n\n            normalized.push(path);\n        }\n\n        return normalized;\n    };\n\n    var normalized = (Array.isArray(settings.path) ? normalize(settings.path) : []);            // Array or function\n\n    // Declare handler\n\n    var handler = function (request, reply) {\n\n        var paths = normalized;\n        if (typeof settings.path === 'function') {\n            var result = settings.path.call(null, request);\n            if (result instanceof Error) {\n                return reply(result);\n            }\n\n            if (Array.isArray(result)) {\n                paths = normalize(result);\n            }\n            else if (typeof result === 'string') {\n                paths = normalize([result]);\n            }\n            else {\n                return reply(Boom.badImplementation('Invalid path function'));\n            }\n        }\n\n        // Append parameter\n\n        var selection = null;\n        var lastParam = request._paramsArray[request._paramsArray.length - 1];\n        if (lastParam) {\n            if (lastParam.indexOf('..') !== -1) {\n                return reply(Boom.forbidden());\n            }\n\n            selection = lastParam;\n        }\n\n        if (selection &&\n            !settings.showHidden &&\n            internals.isFileHidden(selection)) {\n\n            return reply(Boom.notFound());\n        }\n\n        // Generate response\n\n        var resource = request.path;\n        var hasTrailingSlash = (resource[resource.length - 1] === '/');\n\n        Items.serial(paths, function (path, next) {\n\n            path = Path.join(path, selection || '');\n\n            File.load(path, request, { lookupCompressed: settings.lookupCompressed }, function (response) {\n\n                // File loaded successfully\n\n                if (!response.isBoom) {\n                    return reply(response);\n                }\n\n                // Not found\n\n                var err = response;\n                if (err.output.statusCode === 404) {\n                    if (!settings.defaultExtension) {\n                        return next();\n                    }\n\n                    if (hasTrailingSlash) {\n                        path = path.slice(0, -1);\n                    }\n\n                    return File.load(path + '.' + settings.defaultExtension, request, { lookupCompressed: settings.lookupCompressed }, function (extResponse) {\n\n                        if (!extResponse.isBoom) {\n                            return reply(extResponse);\n                        }\n\n                        return next();\n                    });\n                }\n\n                // Directory\n\n                var index = (settings.index !== false);                         // Defaults to true\n                if (!index &&\n                    !settings.listing) {\n\n                    return reply(Boom.forbidden());\n                }\n\n                if (settings.redirectToSlash !== false &&                       // Defaults to true\n                    !request.server.settings.router.stripTrailingSlash &&\n                    !hasTrailingSlash) {\n\n                    return reply.redirect(resource + '/');\n                }\n\n                if (!index) {\n                    return internals.generateListing(path, resource, selection, hasTrailingSlash, settings, request, reply);\n                }\n\n                var indexFile = Path.join(path, 'index.html');\n                File.load(indexFile, request, { lookupCompressed: settings.lookupCompressed }, function (indexResponse) {\n\n                    // File loaded successfully\n\n                    if (!indexResponse.isBoom) {\n                        return reply(indexResponse);\n                    }\n\n                    // Directory\n\n                    var err = indexResponse;\n                    if (err.output.statusCode !== 404) {\n                        return reply(Boom.badImplementation('index.html is a directory'));\n                    }\n\n                    // Not found\n\n                    if (!settings.listing) {\n                        return reply(Boom.forbidden());\n                    }\n\n                    return internals.generateListing(path, resource, selection, hasTrailingSlash, settings, request, reply);\n                });\n            });\n        },\n        function (/* err */) {\n\n            return reply(Boom.notFound());\n        });\n    };\n\n    return handler;\n};\n\n\ninternals.generateListing = function (path, resource, selection, hasTrailingSlash, settings, request, reply) {\n\n    Fs.readdir(path, function (err, files) {\n\n        if (err) {\n            return reply(Boom.internal('Error accessing directory', err));\n        }\n\n        resource = decodeURIComponent(resource);\n        var display = Hoek.escapeHtml(resource);\n        var html = '<html><head><title>' + display + '</title></head><body><h1>Directory: ' + display + '</h1><ul>';\n\n        if (selection) {\n            var parent = resource.substring(0, resource.lastIndexOf('/', resource.length - (hasTrailingSlash ? 2 : 1))) + '/';\n            html += '<li><a href=\"' + internals.pathEncode(parent) + '\">Parent Directory</a></li>';\n        }\n\n        for (var i = 0, il = files.length; i < il; ++i) {\n            if (settings.showHidden ||\n                !internals.isFileHidden(files[i])) {\n\n                html += '<li><a href=\"' + internals.pathEncode(resource + (selection && !hasTrailingSlash ? '/' : '') + files[i]) + '\">' + Hoek.escapeHtml(files[i]) + '</a></li>';\n            }\n        }\n\n        html += '</ul></body></html>';\n\n        return reply(request.generateResponse(html));\n    });\n};\n\n\ninternals.isFileHidden = function (path) {\n\n    return /^\\./.test(Path.basename(path));\n};\n\n\ninternals.pathEncode = function (path) {\n\n    return encodeURIComponent(path).replace(/%2F/g, '/').replace(/%5C/g, '\\\\');\n};\n", "{\n  \"name\": \"inert\",\n  \"description\": \"Static file and directory handlers for hapi.js\",\n  \"version\": \"1.1.0\",\n  \"repository\": \"git://github.com/hapijs/inert\",\n  \"main\": \"index\",\n  \"keywords\": [\n    \"file\",\n    \"directory\",\n    \"handler\",\n    \"hapi\"\n  ],\n  \"engines\": {\n    \"node\": \">=0.10.32\"\n  },\n  \"dependencies\": {\n    \"boom\": \"2.x.x\",\n    \"hoek\": \"2.x.x\",\n    \"items\": \"1.x.x\",\n    \"joi\": \"^4.7.x\",\n    \"mimos\": \"1.x.x\",\n    \"lru-cache\": \"2.5.x\"\n  },\n  \"devDependencies\": {\n    \"hapi\": \"7.x.x\",\n    \"lab\": \"4.x.x\"\n  },\n  \"scripts\": {\n    \"test\": \"make test-cov\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"BSD\",\n      \"url\": \"http://github.com/hapijs/inert/raw/master/LICENSE\"\n    }\n  ]\n}\n", "// Load modules\n\nvar Fs = require('fs');\nvar Path = require('path');\nvar Boom = require('boom');\nvar Hapi = require('hapi');\nvar Inert = require('..');\nvar Lab = require('lab');\n\n\n// Declare internals\n\nvar internals = {};\n\n\n// Test shortcuts\n\nvar lab = exports.lab = Lab.script();\nvar describe = lab.describe;\nvar it = lab.it;\nvar expect = Lab.expect;\n\n\ndescribe('handler()', function () {\n\n    var count = 0;\n    var provisionServer = function (options, name) {\n\n        var server = new Hapi.Server(name || 'domain' + (++count).toString(), options);\n        server.handler('directoryTest', Inert.directory.handler);\n        return server;\n    };\n\n    it('returns a 403 when no index exists and listing is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: '.' } } });      // Use '.' to test path normalization\n\n        server.inject('/directory/', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a 403 when requesting a path containing \\'..\\'', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/..', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a 404 when requesting an unknown file within a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/xyz', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from the directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/directory.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('hapi');\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from multi directory setup', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/multiple/{path*}', handler: { directoryTest: { path: ['./', '../'], listing: true } } });\n\n        server.inject('/multiple/package.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('name\": \"inert\"');\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from multi directory function response', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/multiple/{path*}', handler: { directoryTest: { path: function () { return ['./', '../']; }, listing: true } } });\n\n        server.inject('/multiple/package.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('name\": \"inert\"');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a child directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/directory/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('test');\n            done();\n        });\n    });\n\n    it('returns the correct listing links when viewing top level path', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/file.js\"');\n            done();\n        });\n    });\n\n    it('does not contain any double / when viewing sub path listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.not.contain('//');\n            done();\n        });\n    });\n\n    it('has the correct link to sub folders when inside of a sub folder listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/subsubdir\"');\n            done();\n        });\n    });\n\n    it('has the correct link to a sub folder with spaces when inside of a sub folder listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/sub%20subdir%3D\"');\n            done();\n        });\n    });\n\n    it('has the correct link to a file when inside of a listing of a sub folder that is inside a subfolder with spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/sub%20subdir%3D/subsubsubdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/sub%20subdir%3D/subsubsubdir/test.txt\"');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a directory with spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/directory/directory/subdir/sub%20subdir%3D/test%24.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.equal('{\"test\":\"test\"}');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a directory that its parent directory has spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/directory/directory/subdir/sub%20subdir%3D/subsubsubdir/test.txt', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.equal('test');\n            done();\n        });\n    });\n\n    it('returns a 403 when index and listing are disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryx/{path*}', handler: { directoryTest: { path: '../', index: false } } });\n\n        server.inject('/directoryx/', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a list of files when listing is enabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        server.inject('/directorylist/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('package.json');\n            done();\n        });\n    });\n\n    it('returns a list of files for subdirectory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        server.inject('/directorylist/test/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('directory.js');\n            done();\n        });\n    });\n\n    it('returns a list of files when listing is enabled and index disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylistx/{path*}', handler: { directoryTest: { path: '../', listing: true, index: false } } });\n\n        server.inject('/directorylistx/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('package.json');\n            done();\n        });\n    });\n\n    it('returns the index when found', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryIndex/{path*}', handler: { directoryTest: { path: './directory/' } } });\n\n        server.inject('/directoryIndex/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('<p>test</p>');\n            done();\n        });\n    });\n\n    it('returns the index when found in hidden folder', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './directory/.dot' } } });\n\n        server.inject('/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('<p>test</p>');\n\n            server.inject('/', function (res) {\n\n                expect(res.statusCode).to.equal(200);\n                expect(res.payload).to.contain('<p>test</p>');\n                done();\n            });\n        });\n    });\n\n    it('returns listing when found in hidden folder', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './directory/.dot', index: false, listing: true } } });\n\n        server.inject('/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('index.html');\n            done();\n        });\n    });\n\n    it('returns a 500 when index.html is a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, debug: false });\n        server.route({ method: 'GET', path: '/directoryIndex/{path*}', handler: { directoryTest: { path: './directory/' } } });\n\n        server.inject('/directoryIndex/invalid/', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns the correct file when using a fn directory handler', function (done) {\n\n        var directoryFn = function (request) {\n\n            return '../lib';\n        };\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryfn/{path?}', handler: { directoryTest: { path: directoryFn } } });\n\n        server.inject('/directoryfn/index.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('export');\n            done();\n        });\n    });\n\n    it('returns listing with hidden files when hidden files should be shown', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showhidden/{path*}', handler: { directoryTest: { path: './', showHidden: true, listing: true } } });\n\n        server.inject('/showhidden/', function (res) {\n\n            expect(res.payload).to.contain('.hidden');\n            done();\n        });\n    });\n\n    it('returns listing without hidden files when hidden files should not be shown', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './', listing: true } } });\n\n        server.inject('/noshowhidden/', function (res) {\n\n            expect(res.payload).to.not.contain('.hidden');\n            expect(res.payload).to.contain('directory.js');\n            done();\n        });\n    });\n\n    it('returns a 404 response when requesting a hidden file when showHidden is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './', listing: true } } });\n\n        server.inject('/noshowhidden/.hidden', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('returns a file when requesting a hidden file when showHidden is enabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showhidden/{path*}', handler: { directoryTest: { path: './', showHidden: true, listing: true } } });\n\n        server.inject('/showhidden/.hidden', function (res) {\n\n            expect(res.payload).to.contain('Ssssh!\\n');\n            done();\n        });\n    });\n\n    it('redirects to the same path with / appended if asking for a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(302);\n            expect(res.headers.location).to.equal('http://example.com/redirect/directory/subdir/');\n            done();\n        });\n    });\n\n    it('does not redirect to the same path with / appended redirectToSlash disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true, redirectToSlash: false } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.result).to.contain('<html>');\n            done();\n        });\n    });\n\n    it('does not redirect to the same path with / appended when server stripTrailingSlash is true', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, router: { stripTrailingSlash: true } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.result).to.contain('<html>');\n            done();\n        });\n    });\n\n    it('ignores unused path params', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{ignore}/4/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/crap/4/file.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('hapi');\n            done();\n        });\n    });\n\n    it('returns error when failing to prepare file response due to bad state', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, debug: false });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.ext('onRequest', function (request, reply) {\n\n            reply.state('bad', {});\n            reply();\n        });\n\n        server.inject('/directory/file.js', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns error when listing fails due to directory read error', { parallel: false }, function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        var orig = Fs.readdir;\n        Fs.readdir = function (path, callback) { Fs.readdir = orig; callback(new Error('Simulated Directory Error')); };\n        server.inject('/directorylist/', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('appends default extension', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/index', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('appends default extension when resource ends with /', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/index/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('appends default extension and fails to find file', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/none', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('does not append default extension when directory exists', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory', function (res) {\n\n            expect(res.statusCode).to.equal(302);\n            done();\n        });\n    });\n\n    it('resolves windows path name from pack using root path', { skip: process.platform !== 'win32' }, function (done) {\n\n        // Note: This uses a root path of where the test file lives (to simulate requiring a pack), which is why the\n        //       directory handler path is ./directory instead of ./test/directory like the other test below\n\n        var pack = {\n            name: 'directory test',\n            version: '1.0',\n            path: __dirname,\n            register: function (plugin, options, next) {\n\n                plugin.route({ method: 'GET', path: '/test/{path*}', config: { handler: { directoryTest: { path: './directory', index: false, listing: false } } } });\n                return next();\n            }\n        };\n\n        var server = provisionServer();\n        server.pack.register(pack, {}, function () { });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves windows path name from pack using relative path', { skip: process.platform !== 'win32' }, function (done) {\n\n        // Note: This simulates a pack which is not \"required\", and therefore doesn't have a path set. This will use\n        //       the process' root directory then, so the directory handler needs to specify the path relative to that\n\n        var pack = {\n            name: 'directory test',\n            version: '1.0',\n            register: function (plugin, options, next) {\n\n                plugin.route({ method: 'GET', path: '/test/{path*}', config: { handler: { directoryTest: { path: './test/directory', index: false, listing: false } } } });\n                return next();\n            }\n        };\n\n        var server = provisionServer();\n        server.pack.register(pack, {}, function () { });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves root pathnames on windows', { skip: process.platform !== 'win32' }, function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: Path.join(__dirname, 'directory') } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves relative pathnames on windows', { skip: process.platform !== 'win32' }, function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: './test/directory' } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('returns error when path function returns error', function (done) {\n\n        var path = function () {\n\n            return Boom.badRequest('Really?!');\n        };\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: path } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(400);\n            expect(res.result.message).to.equal('Really?!');\n            done();\n        });\n    });\n\n    it('returns error when path function returns invalid response', function (done) {\n\n        var path = function () {\n\n            return 5;\n        };\n\n        var server = provisionServer({ debug: false });\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: path } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns a gzipped file using precompressed file', function (done) {\n\n        var content = Fs.readFileSync('./test/file/image.png.gz');\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/{p*}', handler: { directoryTest: { path: './test/file', lookupCompressed: true } } });\n\n        server.inject({ url: '/image.png', headers: { 'accept-encoding': 'gzip' } }, function (res) {\n\n            expect(res.headers['content-type']).to.equal('image/png');\n            expect(res.headers['content-encoding']).to.equal('gzip');\n            expect(res.headers['content-length']).to.equal(content.length);\n            expect(res.payload.length).to.equal(content.length);\n            done();\n        });\n    });\n});\n"], "fixing_code": ["// Load modules\n\nvar Fs = require('fs');\nvar Path = require('path');\nvar Boom = require('boom');\nvar Hoek = require('hoek');\nvar Items = require('items');\nvar Joi = require('joi');\nvar File = require('./file');\n\n\n// Declare internals\n\nvar internals = {};\n\n\ninternals.schema = Joi.object({\n    path: Joi.alternatives(Joi.string(), Joi.array().includes(Joi.string()), Joi.func()).required(),\n    index: Joi.boolean(),\n    listing: Joi.boolean(),\n    showHidden: Joi.boolean(),\n    redirectToSlash: Joi.boolean(),\n    lookupCompressed: Joi.boolean(),\n    defaultExtension: Joi.string().alphanum()\n});\n\n\nexports.handler = function (route, options) {\n\n    Joi.assert(options, internals.schema, 'Invalid directory handler options (' + route.path + ')');\n    Hoek.assert(route.path[route.path.length - 1] === '}', 'The route path must end with a parameter:', route.path);\n\n    var settings = Hoek.clone(options);                                // options can be reused\n\n    // Normalize static string path\n\n    if (typeof settings.path === 'string') {\n        settings.path = [settings.path];\n    }\n\n    var normalize = function (paths) {\n\n        var normalized = [];\n        for (var i = 0, il = paths.length; i < il; ++i) {\n            var path = paths[i];\n            if (path[path.length - 1] !== Path.sep) {\n                path += Path.sep;\n            }\n\n            if (!Hoek.isAbsolutePath(path)) {\n                path = Path.join(route.files.relativeTo, path);\n            }\n\n            normalized.push(path);\n        }\n\n        return normalized;\n    };\n\n    var normalized = (Array.isArray(settings.path) ? normalize(settings.path) : []);            // Array or function\n\n    // Declare handler\n\n    var handler = function (request, reply) {\n\n        var paths = normalized;\n        if (typeof settings.path === 'function') {\n            var result = settings.path.call(null, request);\n            if (result instanceof Error) {\n                return reply(result);\n            }\n\n            if (Array.isArray(result)) {\n                paths = normalize(result);\n            }\n            else if (typeof result === 'string') {\n                paths = normalize([result]);\n            }\n            else {\n                return reply(Boom.badImplementation('Invalid path function'));\n            }\n        }\n\n        // Append parameter\n\n        var selection = null;\n        var lastParam = request._paramsArray[request._paramsArray.length - 1];\n        if (lastParam) {\n            if (lastParam.indexOf('..') !== -1) {\n                return reply(Boom.forbidden());\n            }\n\n            selection = lastParam;\n        }\n\n        if (selection &&\n            !settings.showHidden &&\n            internals.isFileHidden(selection)) {\n\n            return reply(Boom.notFound());\n        }\n\n        // Generate response\n\n        var resource = request.path;\n        var hasTrailingSlash = (resource[resource.length - 1] === '/');\n\n        Items.serial(paths, function (path, next) {\n\n            path = Path.join(path, selection || '');\n\n            File.load(path, request, { lookupCompressed: settings.lookupCompressed }, function (response) {\n\n                // File loaded successfully\n\n                if (!response.isBoom) {\n                    return reply(response);\n                }\n\n                // Not found\n\n                var err = response;\n                if (err.output.statusCode === 404) {\n                    if (!settings.defaultExtension) {\n                        return next();\n                    }\n\n                    if (hasTrailingSlash) {\n                        path = path.slice(0, -1);\n                    }\n\n                    return File.load(path + '.' + settings.defaultExtension, request, { lookupCompressed: settings.lookupCompressed }, function (extResponse) {\n\n                        if (!extResponse.isBoom) {\n                            return reply(extResponse);\n                        }\n\n                        return next();\n                    });\n                }\n\n                // Directory\n\n                var index = (settings.index !== false);                         // Defaults to true\n                if (!index &&\n                    !settings.listing) {\n\n                    return reply(Boom.forbidden());\n                }\n\n                if (settings.redirectToSlash !== false &&                       // Defaults to true\n                    !request.server.settings.router.stripTrailingSlash &&\n                    !hasTrailingSlash) {\n\n                    return reply.redirect(resource + '/');\n                }\n\n                if (!index) {\n                    return internals.generateListing(path, resource, selection, hasTrailingSlash, settings, request, reply);\n                }\n\n                var indexFile = Path.join(path, 'index.html');\n                File.load(indexFile, request, { lookupCompressed: settings.lookupCompressed }, function (indexResponse) {\n\n                    // File loaded successfully\n\n                    if (!indexResponse.isBoom) {\n                        return reply(indexResponse);\n                    }\n\n                    // Directory\n\n                    var err = indexResponse;\n                    if (err.output.statusCode !== 404) {\n                        return reply(Boom.badImplementation('index.html is a directory'));\n                    }\n\n                    // Not found\n\n                    if (!settings.listing) {\n                        return reply(Boom.forbidden());\n                    }\n\n                    return internals.generateListing(path, resource, selection, hasTrailingSlash, settings, request, reply);\n                });\n            });\n        },\n        function (/* err */) {\n\n            return reply(Boom.notFound());\n        });\n    };\n\n    return handler;\n};\n\n\ninternals.generateListing = function (path, resource, selection, hasTrailingSlash, settings, request, reply) {\n\n    Fs.readdir(path, function (err, files) {\n\n        if (err) {\n            return reply(Boom.internal('Error accessing directory', err));\n        }\n\n        resource = decodeURIComponent(resource);\n        var display = Hoek.escapeHtml(resource);\n        var html = '<html><head><title>' + display + '</title></head><body><h1>Directory: ' + display + '</h1><ul>';\n\n        if (selection) {\n            var parent = resource.substring(0, resource.lastIndexOf('/', resource.length - (hasTrailingSlash ? 2 : 1))) + '/';\n            html += '<li><a href=\"' + internals.pathEncode(parent) + '\">Parent Directory</a></li>';\n        }\n\n        for (var i = 0, il = files.length; i < il; ++i) {\n            if (settings.showHidden ||\n                !internals.isFileHidden(files[i])) {\n\n                html += '<li><a href=\"' + internals.pathEncode(resource + (selection && !hasTrailingSlash ? '/' : '') + files[i]) + '\">' + Hoek.escapeHtml(files[i]) + '</a></li>';\n            }\n        }\n\n        html += '</ul></body></html>';\n\n        return reply(request.generateResponse(html));\n    });\n};\n\n\ninternals.isFileHidden = function (path) {\n\n    return /(^|[\\\\\\/])\\.([^\\\\\\/]|[\\\\\\/]?$)/.test(path);           // Starts with a '.' or contains '/.' or '\\.', and not followed by a '/' or '\\' or end\n};\n\n\ninternals.pathEncode = function (path) {\n\n    return encodeURIComponent(path).replace(/%2F/g, '/').replace(/%5C/g, '\\\\');\n};\n", "{\n  \"name\": \"inert\",\n  \"description\": \"Static file and directory handlers for hapi.js\",\n  \"version\": \"1.1.1\",\n  \"repository\": \"git://github.com/hapijs/inert\",\n  \"main\": \"index\",\n  \"keywords\": [\n    \"file\",\n    \"directory\",\n    \"handler\",\n    \"hapi\"\n  ],\n  \"engines\": {\n    \"node\": \">=0.10.32\"\n  },\n  \"dependencies\": {\n    \"boom\": \"2.x.x\",\n    \"hoek\": \"2.x.x\",\n    \"items\": \"1.x.x\",\n    \"joi\": \"^4.7.x\",\n    \"mimos\": \"1.x.x\",\n    \"lru-cache\": \"2.5.x\"\n  },\n  \"devDependencies\": {\n    \"hapi\": \"7.x.x\",\n    \"lab\": \"4.x.x\"\n  },\n  \"scripts\": {\n    \"test\": \"make test-cov\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"BSD\",\n      \"url\": \"http://github.com/hapijs/inert/raw/master/LICENSE\"\n    }\n  ]\n}\n", "// Load modules\n\nvar Fs = require('fs');\nvar Path = require('path');\nvar Boom = require('boom');\nvar Hapi = require('hapi');\nvar Inert = require('..');\nvar Lab = require('lab');\n\n\n// Declare internals\n\nvar internals = {};\n\n\n// Test shortcuts\n\nvar lab = exports.lab = Lab.script();\nvar describe = lab.describe;\nvar it = lab.it;\nvar expect = Lab.expect;\n\n\ndescribe('handler()', function () {\n\n    var count = 0;\n    var provisionServer = function (options, name) {\n\n        var server = new Hapi.Server(name || 'domain' + (++count).toString(), options);\n        server.handler('directoryTest', Inert.directory.handler);\n        return server;\n    };\n\n    it('returns a 403 when no index exists and listing is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: '.' } } });      // Use '.' to test path normalization\n\n        server.inject('/directory/', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a 403 when requesting a path containing \\'..\\'', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/..', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a 404 when requesting an unknown file within a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/xyz', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from the directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/directory.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('hapi');\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from multi directory setup', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/multiple/{path*}', handler: { directoryTest: { path: ['./', '../'], listing: true } } });\n\n        server.inject('/multiple/package.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('name\": \"inert\"');\n            done();\n        });\n    });\n\n    it('returns a file when requesting a file from multi directory function response', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/multiple/{path*}', handler: { directoryTest: { path: function () { return ['./', '../']; }, listing: true } } });\n\n        server.inject('/multiple/package.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('name\": \"inert\"');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a child directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/directory/directory/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('test');\n            done();\n        });\n    });\n\n    it('returns the correct listing links when viewing top level path', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/file.js\"');\n            done();\n        });\n    });\n\n    it('does not contain any double / when viewing sub path listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.not.contain('//');\n            done();\n        });\n    });\n\n    it('has the correct link to sub folders when inside of a sub folder listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/subsubdir\"');\n            done();\n        });\n    });\n\n    it('has the correct link to a sub folder with spaces when inside of a sub folder listing', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/sub%20subdir%3D\"');\n            done();\n        });\n    });\n\n    it('has the correct link to a file when inside of a listing of a sub folder that is inside a subfolder with spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showindex/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/showindex/directory/subdir/sub%20subdir%3D/subsubsubdir/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('href=\"/showindex/directory/subdir/sub%20subdir%3D/subsubsubdir/test.txt\"');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a directory with spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/directory/directory/subdir/sub%20subdir%3D/test%24.json', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.equal('{\"test\":\"test\"}');\n            done();\n        });\n    });\n\n    it('returns the correct file when requesting a file from a directory that its parent directory has spaces', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('/directory/directory/subdir/sub%20subdir%3D/subsubsubdir/test.txt', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.equal('test');\n            done();\n        });\n    });\n\n    it('returns a 403 when index and listing are disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryx/{path*}', handler: { directoryTest: { path: '../', index: false } } });\n\n        server.inject('/directoryx/', function (res) {\n\n            expect(res.statusCode).to.equal(403);\n            done();\n        });\n    });\n\n    it('returns a list of files when listing is enabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        server.inject('/directorylist/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('package.json');\n            done();\n        });\n    });\n\n    it('returns a list of files for subdirectory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        server.inject('/directorylist/test/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('directory.js');\n            done();\n        });\n    });\n\n    it('returns a list of files when listing is enabled and index disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylistx/{path*}', handler: { directoryTest: { path: '../', listing: true, index: false } } });\n\n        server.inject('/directorylistx/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('package.json');\n            done();\n        });\n    });\n\n    it('returns the index when found', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryIndex/{path*}', handler: { directoryTest: { path: './directory/' } } });\n\n        server.inject('/directoryIndex/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('<p>test</p>');\n            done();\n        });\n    });\n\n    it('returns the index when served from a hidden folder', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './directory/.dot' } } });\n\n        server.inject('/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('<p>test</p>');\n\n            server.inject('/', function (res) {\n\n                expect(res.statusCode).to.equal(200);\n                expect(res.payload).to.contain('<p>test</p>');\n                done();\n            });\n        });\n    });\n\n    it('returns listing when served from a hidden folder', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{path*}', handler: { directoryTest: { path: './directory/.dot', index: false, listing: true } } });\n\n        server.inject('/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('index.html');\n            done();\n        });\n    });\n\n    it('returns a 500 when index.html is a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, debug: false });\n        server.route({ method: 'GET', path: '/directoryIndex/{path*}', handler: { directoryTest: { path: './directory/' } } });\n\n        server.inject('/directoryIndex/invalid/', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns the correct file when using a fn directory handler', function (done) {\n\n        var directoryFn = function (request) {\n\n            return '../lib';\n        };\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directoryfn/{path?}', handler: { directoryTest: { path: directoryFn } } });\n\n        server.inject('/directoryfn/index.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('export');\n            done();\n        });\n    });\n\n    it('returns listing with hidden files when hidden files should be shown', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showhidden/{path*}', handler: { directoryTest: { path: './', showHidden: true, listing: true } } });\n\n        server.inject('/showhidden/', function (res) {\n\n            expect(res.payload).to.contain('.hidden');\n            done();\n        });\n    });\n\n    it('returns listing without hidden files when hidden files should not be shown', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './', listing: true } } });\n\n        server.inject('/noshowhidden/', function (res) {\n\n            expect(res.payload).to.not.contain('.hidden');\n            expect(res.payload).to.contain('directory.js');\n            done();\n        });\n    });\n\n    it('returns a 404 response when requesting a hidden file when showHidden is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './', listing: true } } });\n\n        server.inject('/noshowhidden/.hidden', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('returns a 404 response when requesting a file in a hidden directory when showHidden is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './directory', listing: true } } });\n\n        server.inject('/noshowhidden/.dot/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n\n            server.inject('/noshowhidden/.dot/', function (res) {\n\n                expect(res.statusCode).to.equal(404);\n                done();\n            });\n        });\n    });\n\n    it('returns a 404 response when requesting a hidden directory listing when showHidden is disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './directory', listing: true, index: false } } });\n\n        server.inject('/noshowhidden/.dot/', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('returns a file when requesting a hidden file when showHidden is enabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/showhidden/{path*}', handler: { directoryTest: { path: './', showHidden: true, listing: true } } });\n\n        server.inject('/showhidden/.hidden', function (res) {\n\n            expect(res.payload).to.contain('Ssssh!\\n');\n            done();\n        });\n    });\n\n    it('returns a a file when requesting a file in a hidden directory when showHidden is enabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/noshowhidden/{path*}', handler: { directoryTest: { path: './directory', showHidden: true, listing: true } } });\n\n        server.inject('/noshowhidden/.dot/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('test');\n\n            server.inject('/noshowhidden/.dot/', function (res) {\n\n                expect(res.statusCode).to.equal(200);\n                expect(res.payload).to.contain('test');\n                done();\n            });\n        });\n    });\n\n    it('redirects to the same path with / appended if asking for a directory', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(302);\n            expect(res.headers.location).to.equal('http://example.com/redirect/directory/subdir/');\n            done();\n        });\n    });\n\n    it('does not redirect to the same path with / appended redirectToSlash disabled', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true, redirectToSlash: false } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.result).to.contain('<html>');\n            done();\n        });\n    });\n\n    it('does not redirect to the same path with / appended when server stripTrailingSlash is true', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, router: { stripTrailingSlash: true } });\n        server.route({ method: 'GET', path: '/redirect/{path*}', handler: { directoryTest: { path: './', index: true, listing: true } } });\n\n        server.inject('http://example.com/redirect/directory/subdir', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.result).to.contain('<html>');\n            done();\n        });\n    });\n\n    it('ignores unused path params', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/{ignore}/4/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.inject('/crap/4/file.js', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            expect(res.payload).to.contain('hapi');\n            done();\n        });\n    });\n\n    it('returns error when failing to prepare file response due to bad state', function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname }, debug: false });\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: './' } } });\n\n        server.ext('onRequest', function (request, reply) {\n\n            reply.state('bad', {});\n            reply();\n        });\n\n        server.inject('/directory/file.js', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns error when listing fails due to directory read error', { parallel: false }, function (done) {\n\n        var server = provisionServer({ files: { relativeTo: __dirname } });\n        server.route({ method: 'GET', path: '/directorylist/{path*}', handler: { directoryTest: { path: '../', listing: true } } });\n\n        var orig = Fs.readdir;\n        Fs.readdir = function (path, callback) { Fs.readdir = orig; callback(new Error('Simulated Directory Error')); };\n        server.inject('/directorylist/', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('appends default extension', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/index', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('appends default extension when resource ends with /', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/index/', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('appends default extension and fails to find file', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory/none', function (res) {\n\n            expect(res.statusCode).to.equal(404);\n            done();\n        });\n    });\n\n    it('does not append default extension when directory exists', function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/directory/{path*}', handler: { directoryTest: { path: __dirname, defaultExtension: 'html' } } });\n\n        server.inject('/directory/directory', function (res) {\n\n            expect(res.statusCode).to.equal(302);\n            done();\n        });\n    });\n\n    it('resolves windows path name from pack using root path', { skip: process.platform !== 'win32' }, function (done) {\n\n        // Note: This uses a root path of where the test file lives (to simulate requiring a pack), which is why the\n        //       directory handler path is ./directory instead of ./test/directory like the other test below\n\n        var pack = {\n            name: 'directory test',\n            version: '1.0',\n            path: __dirname,\n            register: function (plugin, options, next) {\n\n                plugin.route({ method: 'GET', path: '/test/{path*}', config: { handler: { directoryTest: { path: './directory', index: false, listing: false } } } });\n                return next();\n            }\n        };\n\n        var server = provisionServer();\n        server.pack.register(pack, {}, function () { });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves windows path name from pack using relative path', { skip: process.platform !== 'win32' }, function (done) {\n\n        // Note: This simulates a pack which is not \"required\", and therefore doesn't have a path set. This will use\n        //       the process' root directory then, so the directory handler needs to specify the path relative to that\n\n        var pack = {\n            name: 'directory test',\n            version: '1.0',\n            register: function (plugin, options, next) {\n\n                plugin.route({ method: 'GET', path: '/test/{path*}', config: { handler: { directoryTest: { path: './test/directory', index: false, listing: false } } } });\n                return next();\n            }\n        };\n\n        var server = provisionServer();\n        server.pack.register(pack, {}, function () { });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves root pathnames on windows', { skip: process.platform !== 'win32' }, function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: Path.join(__dirname, 'directory') } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('resolves relative pathnames on windows', { skip: process.platform !== 'win32' }, function (done) {\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: './test/directory' } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(200);\n            done();\n        });\n    });\n\n    it('returns error when path function returns error', function (done) {\n\n        var path = function () {\n\n            return Boom.badRequest('Really?!');\n        };\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: path } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(400);\n            expect(res.result.message).to.equal('Really?!');\n            done();\n        });\n    });\n\n    it('returns error when path function returns invalid response', function (done) {\n\n        var path = function () {\n\n            return 5;\n        };\n\n        var server = provisionServer({ debug: false });\n        server.route({ method: 'GET', path: '/test/{path*}', handler: { directoryTest: { path: path } } });\n\n        server.inject('/test/index.html', function (res) {\n\n            expect(res.statusCode).to.equal(500);\n            done();\n        });\n    });\n\n    it('returns a gzipped file using precompressed file', function (done) {\n\n        var content = Fs.readFileSync('./test/file/image.png.gz');\n\n        var server = provisionServer();\n        server.route({ method: 'GET', path: '/{p*}', handler: { directoryTest: { path: './test/file', lookupCompressed: true } } });\n\n        server.inject({ url: '/image.png', headers: { 'accept-encoding': 'gzip' } }, function (res) {\n\n            expect(res.headers['content-type']).to.equal('image/png');\n            expect(res.headers['content-encoding']).to.equal('gzip');\n            expect(res.headers['content-length']).to.equal(content.length);\n            expect(res.payload.length).to.equal(content.length);\n            done();\n        });\n    });\n});\n"], "filenames": ["lib/directory.js", "package.json", "test/directory.js"], "buggy_code_start_loc": [232, 4, 277], "buggy_code_end_loc": [233, 5, 384], "fixing_code_start_loc": [232, 4, 277], "fixing_code_end_loc": [233, 5, 433], "type": "CWE-22", "message": "The inert directory handler in inert node module before 1.1.1 always allows files in hidden directories to be served, even when `showHidden` is false.", "other": {"cve": {"id": "CVE-2014-10068", "sourceIdentifier": "support@hackerone.com", "published": "2018-05-29T20:29:00.283", "lastModified": "2019-10-09T23:09:44.570", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The inert directory handler in inert node module before 1.1.1 always allows files in hidden directories to be served, even when `showHidden` is false."}, {"lang": "es", "value": "El manipulador de directorios inert en el m\u00f3dulo inert node en versiones anteriores a la 1.1.1 siempre permite que se sirvan archivos en directorios ocultos, incluso cuando \"showHidden\" es falso."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hapi:inert:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "DF3C7056-B098-40EB-99DA-DBE63EF67C5A"}]}]}], "references": [{"url": "https://github.com/hapijs/inert/commit/e8f99f94da4cb08e8032eda984761c3f111e3e82", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hapijs/inert/pull/15", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/14", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hapijs/inert/commit/e8f99f94da4cb08e8032eda984761c3f111e3e82"}}