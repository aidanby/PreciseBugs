{"buggy_code": ["# frozen_string_literal: true\n\nclass TopicsController < ApplicationController\n  requires_login only: %i[\n                   timings\n                   destroy_timings\n                   update\n                   update_shared_draft\n                   destroy\n                   recover\n                   status\n                   invite\n                   mute\n                   unmute\n                   set_notifications\n                   move_posts\n                   merge_topic\n                   clear_pin\n                   re_pin\n                   status_update\n                   timer\n                   bulk\n                   reset_new\n                   change_post_owners\n                   change_timestamps\n                   archive_message\n                   move_to_inbox\n                   convert_topic\n                   bookmark\n                   publish\n                   reset_bump_date\n                   set_slow_mode\n                 ]\n\n  before_action :consider_user_for_promotion, only: :show\n\n  skip_before_action :check_xhr, only: %i[show feed]\n\n  def id_for_slug\n    topic = Topic.find_by_slug(params[:slug])\n    guardian.ensure_can_see!(topic)\n    raise Discourse::NotFound unless topic\n    render json: { slug: topic.slug, topic_id: topic.id, url: topic.url }\n  end\n\n  def show_by_external_id\n    topic = Topic.find_by(external_id: params[:external_id])\n    raise Discourse::NotFound unless topic\n    guardian.ensure_can_see!(topic)\n    redirect_to_correct_topic(topic, params[:post_number])\n  end\n\n  def show\n    flash[\"referer\"] ||= request.referer[0..255] if request.referer\n\n    # We'd like to migrate the wordpress feed to another url. This keeps up backwards compatibility with\n    # existing installs.\n    return wordpress if params[:best].present?\n\n    # work around people somehow sending in arrays,\n    # arrays are not supported\n    params[:page] = begin\n      params[:page].to_i\n    rescue StandardError\n      1\n    end\n\n    opts =\n      params.slice(\n        :username_filters,\n        :filter,\n        :page,\n        :post_number,\n        :show_deleted,\n        :replies_to_post_number,\n        :filter_upwards_post_id,\n        :filter_top_level_replies,\n      )\n    username_filters = opts[:username_filters]\n\n    opts[:print] = true if params[:print] == \"true\"\n    opts[:username_filters] = username_filters.split(\",\") if username_filters.is_a?(String)\n\n    # Special case: a slug with a number in front should look by slug first before looking\n    # up that particular number\n    if params[:id] && params[:id] =~ /\\A\\d+[^\\d\\\\]+\\z/\n      topic = Topic.find_by_slug(params[:id])\n      return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n    end\n\n    if opts[:print]\n      raise Discourse::InvalidAccess if SiteSetting.max_prints_per_hour_per_user.zero?\n      begin\n        unless @guardian.is_admin?\n          RateLimiter.new(\n            current_user,\n            \"print-topic-per-hour\",\n            SiteSetting.max_prints_per_hour_per_user,\n            1.hour,\n          ).performed!\n        end\n      rescue RateLimiter::LimitExceeded\n        return render_json_error I18n.t(\"rate_limiter.slow_down\")\n      end\n    end\n\n    begin\n      @topic_view = TopicView.new(params[:id] || params[:topic_id], current_user, opts)\n    rescue Discourse::NotFound => ex\n      if params[:id]\n        topic = Topic.find_by_slug(params[:id])\n        return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n      end\n\n      raise ex\n    rescue Discourse::NotLoggedIn => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    rescue Discourse::InvalidAccess => ex\n      # If the user can't see the topic, clean up notifications for it.\n      Notification.remove_for(current_user.id, params[:topic_id]) if current_user\n\n      deleted =\n        guardian.can_see_topic?(ex.obj, false) ||\n          (!guardian.can_see_topic?(ex.obj) && ex.obj&.access_topic_via_group && ex.obj.deleted_at)\n\n      if SiteSetting.detailed_404\n        if deleted\n          raise Discourse::NotFound.new(\n                  \"deleted topic\",\n                  custom_message: \"deleted_topic\",\n                  status: 410,\n                  check_permalinks: true,\n                  original_path: ex.obj.relative_url,\n                )\n        elsif !guardian.can_see_topic?(ex.obj) && group = ex.obj&.access_topic_via_group\n          raise Discourse::InvalidAccess.new(\n                  \"not in group\",\n                  ex.obj,\n                  custom_message: \"not_in_group.title_topic\",\n                  custom_message_params: {\n                    group: group.name,\n                  },\n                  group: group,\n                )\n        end\n\n        raise ex\n      else\n        raise Discourse::NotFound.new(\n                nil,\n                check_permalinks: deleted,\n                original_path: ex.obj.relative_url,\n              )\n      end\n    end\n\n    page = params[:page]\n    if (page < 0) || ((page - 1) * @topic_view.chunk_size >= @topic_view.topic.highest_post_number)\n      raise Discourse::NotFound\n    end\n\n    discourse_expires_in 1.minute\n\n    if slugs_do_not_match || (!request.format.json? && params[:slug].nil?)\n      redirect_to_correct_topic(@topic_view.topic, opts[:post_number])\n      return\n    end\n\n    track_visit_to_topic\n\n    if should_track_visit_to_topic?\n      @topic_view.draft = Draft.get(current_user, @topic_view.draft_key, @topic_view.draft_sequence)\n    end\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex\" unless @topic_view.topic.visible\n\n    canonical_url UrlHelper.absolute_without_cdn(@topic_view.canonical_path)\n\n    # provide hint to crawlers only for now\n    # we would like to give them a bit more signal about age of data\n    if use_crawler_layout?\n      if last_modified = @topic_view.posts&.map { |p| p.updated_at }&.max&.httpdate\n        response.headers[\"Last-Modified\"] = last_modified\n      end\n    end\n\n    perform_show_response\n  end\n\n  def publish\n    params.permit(:id, :destination_category_id)\n\n    topic = Topic.find(params[:id])\n    category = Category.find(params[:destination_category_id])\n\n    raise Discourse::InvalidParameters if category.id == SiteSetting.shared_drafts_category.to_i\n\n    guardian.ensure_can_publish_topic!(topic, category)\n    topic = TopicPublisher.new(topic, current_user, category.id).publish!\n\n    render_serialized(topic.reload, BasicTopicSerializer)\n  end\n\n  def wordpress\n    params.require(:best)\n    params.require(:topic_id)\n    params.permit(\n      :min_trust_level,\n      :min_score,\n      :min_replies,\n      :bypass_trust_level_score,\n      :only_moderator_liked,\n    )\n\n    opts = {\n      best: params[:best].to_i,\n      min_trust_level: params[:min_trust_level] ? params[:min_trust_level].to_i : 1,\n      min_score: params[:min_score].to_i,\n      min_replies: params[:min_replies].to_i,\n      bypass_trust_level_score: params[:bypass_trust_level_score].to_i, # safe cause 0 means ignore\n      only_moderator_liked: params[:only_moderator_liked].to_s == \"true\",\n      exclude_hidden: true,\n    }\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, opts)\n    discourse_expires_in 1.minute\n\n    wordpress_serializer =\n      TopicViewWordpressSerializer.new(@topic_view, scope: guardian, root: false)\n    render_json_dump(wordpress_serializer)\n  end\n\n  def post_ids\n    params.require(:topic_id)\n    params.permit(:post_number, :username_filters, :filter)\n\n    options = {\n      filter_post_number: params[:post_number],\n      filter: params[:filter],\n      skip_limit: true,\n      asc: true,\n      skip_custom_fields: true,\n    }\n\n    fetch_topic_view(options)\n    render_json_dump(post_ids: @topic_view.posts.pluck(:id))\n  end\n\n  def posts\n    params.require(:topic_id)\n    params.permit(:post_ids, :post_number, :username_filters, :filter, :include_suggested)\n\n    include_suggested = params[:include_suggested] == \"true\"\n\n    options = {\n      filter_post_number: params[:post_number],\n      post_ids: params[:post_ids],\n      asc: ActiveRecord::Type::Boolean.new.deserialize(params[:asc]),\n      filter: params[:filter],\n      include_suggested: include_suggested,\n      include_related: include_suggested,\n    }\n\n    fetch_topic_view(options)\n\n    render_json_dump(\n      TopicViewPostsSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw],\n      ),\n    )\n  end\n\n  def excerpts\n    params.require(:topic_id)\n    params.require(:post_ids)\n\n    unless Array === params[:post_ids]\n      render_json_error(\"Expecting post_ids to contain a list of posts ids\")\n      return\n    end\n    post_ids = params[:post_ids].map(&:to_i)\n\n    if post_ids.length > 100\n      render_json_error(\"Requested a chunk that is too big\")\n      return\n    end\n\n    @topic = Topic.with_deleted.where(id: params[:topic_id]).first\n    guardian.ensure_can_see!(@topic)\n\n    @posts =\n      Post\n        .where(hidden: false, deleted_at: nil, topic_id: @topic.id)\n        .where(\"posts.id in (?)\", post_ids)\n        .joins(\"LEFT JOIN users u on u.id = posts.user_id\")\n        .pluck(:id, :cooked, :username, :action_code, :created_at)\n        .map do |post_id, cooked, username, action_code, created_at|\n          attrs = {\n            post_id: post_id,\n            username: username,\n            excerpt: PrettyText.excerpt(cooked, 800, keep_emoji_images: true),\n          }\n\n          if action_code\n            attrs[:action_code] = action_code\n            attrs[:created_at] = created_at\n          end\n\n          attrs\n        end\n\n    render json: @posts.to_json\n  end\n\n  def destroy_timings\n    topic_id = params[:topic_id].to_i\n\n    if params[:last].to_s == \"1\"\n      PostTiming.destroy_last_for(current_user, topic_id: topic_id)\n    else\n      PostTiming.destroy_for(current_user.id, [topic_id])\n    end\n\n    last_notification =\n      Notification\n        .where(user_id: current_user.id, topic_id: topic_id)\n        .order(created_at: :desc)\n        .limit(1)\n        .first\n\n    last_notification.update!(read: false) if last_notification\n\n    render body: nil\n  end\n\n  def update_shared_draft\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_edit!(topic)\n\n    category = Category.where(id: params[:category_id].to_i).first\n    guardian.ensure_can_publish_topic!(topic, category)\n\n    row_count = SharedDraft.where(topic_id: topic.id).update_all(category_id: category.id)\n    SharedDraft.create(topic_id: topic.id, category_id: category.id) if row_count == 0\n\n    render json: success_json\n  end\n\n  def update\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit!(topic)\n\n    if params[:category_id] && (params[:category_id].to_i != topic.category_id.to_i)\n      if topic.shared_draft\n        topic.shared_draft.update(category_id: params[:category_id])\n        params.delete(:category_id)\n      else\n        category = Category.find_by(id: params[:category_id])\n\n        if category || (params[:category_id].to_i == 0)\n          guardian.ensure_can_move_topic_to_category!(category)\n        else\n          return render_json_error(I18n.t(\"category.errors.not_found\"))\n        end\n\n        if category &&\n             topic_tags = (params[:tags] || topic.tags.pluck(:name)).reject { |c| c.empty? }\n          if topic_tags.present?\n            allowed_tags =\n              DiscourseTagging.filter_allowed_tags(guardian, category: category).map(&:name)\n\n            invalid_tags = topic_tags - allowed_tags\n\n            # Do not raise an error on a topic's hidden tags when not modifying tags\n            if params[:tags].blank?\n              invalid_tags.each do |tag_name|\n                if DiscourseTagging.hidden_tag_names.include?(tag_name)\n                  invalid_tags.delete(tag_name)\n                end\n              end\n            end\n\n            invalid_tags = Tag.where_name(invalid_tags).pluck(:name)\n\n            if !invalid_tags.empty?\n              if (invalid_tags & DiscourseTagging.hidden_tag_names).present?\n                return render_json_error(I18n.t(\"category.errors.disallowed_tags_generic\"))\n              else\n                return(\n                  render_json_error(\n                    I18n.t(\"category.errors.disallowed_topic_tags\", tags: invalid_tags.join(\", \")),\n                  )\n                )\n              end\n            end\n          end\n        end\n      end\n    end\n\n    changes = {}\n\n    PostRevisor.tracked_topic_fields.each_key { |f| changes[f] = params[f] if params.has_key?(f) }\n\n    changes.delete(:title) if topic.title == changes[:title]\n    changes.delete(:category_id) if topic.category_id.to_i == changes[:category_id].to_i\n\n    if Tag.include_tags?\n      topic_tags = topic.tags.map(&:name).sort\n      changes.delete(:tags) if changes[:tags]&.sort == topic_tags\n    end\n\n    success = true\n\n    if changes.length > 0\n      bypass_bump = should_bypass_bump?(changes)\n\n      first_post = topic.ordered_posts.first\n      success =\n        PostRevisor.new(first_post, topic).revise!(\n          current_user,\n          changes,\n          validate_post: false,\n          bypass_bump: bypass_bump,\n          keep_existing_draft: params[:keep_existing_draft].to_s == \"true\",\n        )\n\n      topic.errors.add(:base, :unable_to_update) if !success && topic.errors.blank?\n    end\n\n    # this is used to return the title to the client as it may have been changed by \"TextCleaner\"\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def update_tags\n    params.require(:tags)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit_tags!(topic)\n\n    success =\n      PostRevisor.new(topic.first_post, topic).revise!(\n        current_user,\n        { tags: params[:tags] },\n        validate_post: false,\n      )\n\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def feature_stats\n    params.require(:category_id)\n    category_id = params[:category_id].to_i\n\n    visible_topics = Topic.listable_topics.visible\n\n    render json: {\n             pinned_in_category_count:\n               visible_topics\n                 .where(category_id: category_id)\n                 .where(pinned_globally: false)\n                 .where.not(pinned_at: nil)\n                 .count,\n             pinned_globally_count:\n               visible_topics.where(pinned_globally: true).where.not(pinned_at: nil).count,\n             banner_count: Topic.listable_topics.where(archetype: Archetype.banner).count,\n           }\n  end\n\n  def status\n    params.require(:status)\n    params.require(:enabled)\n    params.permit(:until)\n\n    status = params[:status]\n    topic_id = params[:topic_id].to_i\n    enabled = params[:enabled] == \"true\"\n\n    check_for_status_presence(:status, status)\n    @topic =\n      if params[:category_id]\n        Topic.find_by(id: topic_id, category_id: params[:category_id].to_i)\n      else\n        Topic.find_by(id: topic_id)\n      end\n\n    case status\n    when \"closed\"\n      guardian.ensure_can_close_topic!(@topic)\n    when \"archived\"\n      guardian.ensure_can_archive_topic!(@topic)\n    when \"visible\"\n      guardian.ensure_can_toggle_topic_visibility!(@topic)\n    when \"pinned\"\n      guardian.ensure_can_pin_unpin_topic!(@topic)\n    else\n      guardian.ensure_can_moderate!(@topic)\n    end\n\n    params[:until] === \"\" ? params[:until] = nil : params[:until]\n\n    @topic.update_status(status, enabled, current_user, until: params[:until])\n\n    render json:\n             success_json.merge!(\n               topic_status_update:\n                 TopicTimerSerializer.new(TopicTimer.find_by(topic: @topic), root: false),\n             )\n  end\n\n  def mute\n    toggle_mute\n  end\n\n  def unmute\n    toggle_mute\n  end\n\n  def timer\n    params.permit(:time, :based_on_last_post, :category_id)\n    params.require(:status_type)\n\n    status_type =\n      begin\n        TopicTimer.types.fetch(params[:status_type].to_sym)\n      rescue StandardError\n        invalid_param(:status_type)\n      end\n    based_on_last_post = params[:based_on_last_post]\n    params.require(:duration_minutes) if based_on_last_post\n\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_moderate!(topic)\n\n    guardian.ensure_can_delete!(topic) if TopicTimer.destructive_types.values.include?(status_type)\n\n    options = { by_user: current_user, based_on_last_post: based_on_last_post }\n\n    options.merge!(category_id: params[:category_id]) if !params[:category_id].blank?\n    if params[:duration_minutes].present?\n      options.merge!(duration_minutes: params[:duration_minutes].to_i)\n    end\n    options.merge!(duration: params[:duration].to_i) if params[:duration].present?\n\n    begin\n      topic_timer = topic.set_or_create_timer(status_type, params[:time], **options)\n    rescue ActiveRecord::RecordInvalid => e\n      return render_json_error(e.message)\n    end\n\n    if topic.save\n      render json:\n               success_json.merge!(\n                 execute_at: topic_timer&.execute_at,\n                 duration_minutes: topic_timer&.duration_minutes,\n                 based_on_last_post: topic_timer&.based_on_last_post,\n                 closed: topic.closed,\n                 category_id: topic_timer&.category_id,\n               )\n    else\n      render_json_error(topic)\n    end\n  end\n\n  def make_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.make_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.remove_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_bookmarks\n    topic = Topic.find(params[:topic_id].to_i)\n    BookmarkManager.new(current_user).destroy_for_topic(topic)\n    render body: nil\n  end\n\n  def archive_message\n    toggle_archive_message(true)\n  end\n\n  def move_to_inbox\n    toggle_archive_message(false)\n  end\n\n  def toggle_archive_message(archive)\n    topic = Topic.find(params[:id].to_i)\n\n    group_id = nil\n\n    group_ids = current_user.groups.pluck(:id)\n    if group_ids.present?\n      allowed_groups =\n        topic.allowed_groups.where(\"topic_allowed_groups.group_id IN (?)\", group_ids).pluck(:id)\n\n      allowed_groups.each do |id|\n        if archive\n          GroupArchivedMessage.archive!(id, topic, acting_user_id: current_user.id)\n\n          group_id = id\n        else\n          GroupArchivedMessage.move_to_inbox!(id, topic, acting_user_id: current_user.id)\n        end\n      end\n    end\n\n    if topic.allowed_users.include?(current_user)\n      if archive\n        UserArchivedMessage.archive!(current_user.id, topic)\n      else\n        UserArchivedMessage.move_to_inbox!(current_user.id, topic)\n      end\n    end\n\n    if group_id\n      name = Group.find_by(id: group_id).try(:name)\n      render_json_dump(group_name: name)\n    else\n      render body: nil\n    end\n  end\n\n  def bookmark\n    topic = Topic.find(params[:topic_id].to_i)\n\n    bookmark_manager = BookmarkManager.new(current_user)\n    bookmark_manager.create_for(bookmarkable_id: topic.id, bookmarkable_type: \"Topic\")\n\n    return render_json_error(bookmark_manager, status: 400) if bookmark_manager.errors.any?\n\n    render body: nil\n  end\n\n  def destroy\n    topic = Topic.with_deleted.find_by(id: params[:id])\n    force_destroy = ActiveModel::Type::Boolean.new.cast(params[:force_destroy])\n\n    if force_destroy\n      if !topic\n        raise Discourse::InvalidAccess\n      elsif !guardian.can_permanently_delete?(topic)\n        return render_json_error topic.cannot_permanently_delete_reason(current_user), status: 403\n      end\n    else\n      guardian.ensure_can_delete!(topic)\n    end\n\n    PostDestroyer.new(\n      current_user,\n      topic.ordered_posts.with_deleted.first,\n      context: params[:context],\n      force_destroy: force_destroy,\n    ).destroy\n\n    render body: nil\n  rescue Discourse::InvalidAccess\n    render_json_error I18n.t(\"delete_topic_failed\")\n  end\n\n  def recover\n    topic = Topic.where(id: params[:topic_id]).with_deleted.first\n    guardian.ensure_can_recover_topic!(topic)\n\n    first_post = topic.posts.with_deleted.order(:post_number).first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).recover\n\n    render body: nil\n  end\n\n  def excerpt\n    render body: nil\n  end\n\n  def remove_allowed_user\n    params.require(:username)\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound unless topic\n    user = User.find_by(username: params[:username])\n    raise Discourse::NotFound unless user\n\n    guardian.ensure_can_remove_allowed_users!(topic, user)\n\n    if topic.remove_allowed_user(current_user, user)\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def remove_allowed_group\n    params.require(:name)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_remove_allowed_users!(topic)\n\n    if topic.remove_allowed_group(current_user, params[:name])\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite_group\n    group = Group.find_by(name: params[:group])\n    raise Discourse::NotFound if !group\n\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound if !topic\n\n    if !pm_has_slots?(topic)\n      return(\n        render_json_error(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      )\n    end\n\n    if topic.private_message?\n      guardian.ensure_can_invite_group_to_private_message!(group, topic)\n      topic.invite_group(current_user, group)\n      render_json_dump BasicGroupSerializer.new(group, scope: guardian, root: \"group\")\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound if !topic\n\n    return render_json_error(I18n.t(\"topic_invite.not_pm\")) if !topic.private_message?\n\n    if !pm_has_slots?(topic)\n      return(\n        render_json_error(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      )\n    end\n\n    guardian.ensure_can_invite_to!(topic)\n\n    username_or_email = params[:user] ? fetch_username : fetch_email\n    group_ids =\n      Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names]).pluck(\n        :id,\n      )\n\n    begin\n      if topic.invite(current_user, username_or_email, group_ids, params[:custom_message])\n        if user = User.find_by_username_or_email(username_or_email)\n          render_json_dump BasicUserSerializer.new(user, scope: guardian, root: \"user\")\n        else\n          render json: success_json\n        end\n      else\n        json = failed_json\n\n        unless topic.private_message?\n          group_names =\n            topic\n              .category\n              .visible_group_names(current_user)\n              .where(automatic: false)\n              .pluck(:name)\n              .join(\", \")\n\n          if group_names.present?\n            json.merge!(errors: [I18n.t(\"topic_invite.failed_to_invite\", group_names: group_names)])\n          end\n        end\n\n        render json: json, status: 422\n      end\n    rescue Topic::UserExists, Topic::NotAllowed => e\n      render json: { errors: [e.message] }, status: 422\n    end\n  end\n\n  def set_notifications\n    topic = Topic.find(params[:topic_id].to_i)\n    TopicUser.change(current_user, topic.id, notification_level: params[:notification_level].to_i)\n    render json: success_json\n  end\n\n  def merge_topic\n    topic_id = params.require(:topic_id)\n    destination_topic_id = params.require(:destination_topic_id)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    destination_topic = Topic.find_by(id: destination_topic_id)\n    guardian.ensure_can_create_post_on_topic!(destination_topic)\n\n    args = {}\n    args[:destination_topic_id] = destination_topic_id.to_i\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? &&\n        params[:archetype] == \"private_message\"\n    end\n\n    destination_topic = topic.move_posts(current_user, topic.posts.pluck(:id), args)\n    render_topic_changes(destination_topic)\n  end\n\n  def move_posts\n    post_ids = params.require(:post_ids)\n    topic_id = params.require(:topic_id)\n    params.permit(:category_id)\n    params.permit(:tags)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.with_deleted.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    if params[:title].present?\n      # when creating a new topic, ensure the 1st post is a regular post\n      if Post.where(topic: topic, id: post_ids).order(:post_number).pick(:post_type) !=\n           Post.types[:regular]\n        return(\n          render_json_error(\n            \"When moving posts to a new topic, the first post must be a regular post.\",\n          )\n        )\n      end\n\n      if params[:category_id].present?\n        guardian.ensure_can_create_topic_on_category!(params[:category_id])\n      end\n    end\n\n    destination_topic = move_posts_to_destination(topic)\n    render_topic_changes(destination_topic)\n  rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved => ex\n    render_json_error(ex)\n  end\n\n  def change_post_owners\n    params.require(:post_ids)\n    params.require(:topic_id)\n    params.require(:username)\n\n    guardian.ensure_can_change_post_owner!\n\n    begin\n      PostOwnerChanger.new(\n        post_ids: params[:post_ids].to_a,\n        topic_id: params[:topic_id].to_i,\n        new_owner: User.find_by(username: params[:username]),\n        acting_user: current_user,\n      ).change_owner!\n      render json: success_json\n    rescue ArgumentError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def change_timestamps\n    topic_id = params.require(:topic_id).to_i\n    timestamp = params.require(:timestamp).to_f\n\n    guardian.ensure_can_change_post_timestamps!\n\n    topic = Topic.with_deleted.find(topic_id)\n    previous_timestamp = topic.first_post.created_at\n\n    begin\n      TopicTimestampChanger.new(topic: topic, timestamp: timestamp).change!\n\n      StaffActionLogger.new(current_user).log_topic_timestamps_changed(\n        topic,\n        Time.zone.at(timestamp),\n        previous_timestamp,\n      )\n\n      render json: success_json\n    rescue ActiveRecord::RecordInvalid, TopicTimestampChanger::InvalidTimestampError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def clear_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.clear_pin_for(current_user)\n    render body: nil\n  end\n\n  def re_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.re_pin_for(current_user)\n    render body: nil\n  end\n\n  def timings\n    allowed_params = topic_params\n\n    topic_id = allowed_params[:topic_id].to_i\n    topic_time = allowed_params[:topic_time].to_i\n    timings = allowed_params[:timings].to_h || {}\n\n    # ensure we capture current user for the block\n    user = current_user\n\n    hijack do\n      PostTiming.process_timings(\n        user,\n        topic_id,\n        topic_time,\n        timings.map { |post_number, t| [post_number.to_i, t.to_i] },\n        mobile: view_context.mobile_view?,\n      )\n      render body: nil\n    end\n  end\n\n  def feed\n    raise Discourse::NotFound if !Post.exists?(topic_id: params[:topic_id])\n\n    begin\n      @topic_view = TopicView.new(params[:topic_id])\n    rescue Discourse::NotLoggedIn\n      raise Discourse::NotFound\n    rescue Discourse::InvalidAccess => ex\n      deleted =\n        guardian.can_see_topic?(ex.obj, false) ||\n          (!guardian.can_see_topic?(ex.obj) && ex.obj&.access_topic_via_group && ex.obj.deleted_at)\n\n      raise Discourse::NotFound.new(\n              nil,\n              check_permalinks: deleted,\n              original_path: ex.obj.relative_url,\n            )\n    end\n\n    discourse_expires_in 1.minute\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex, nofollow\"\n    render \"topics/show\", formats: [:rss]\n  end\n\n  def bulk\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n    elsif params[:filter] == \"unread\"\n      topic_ids = bulk_unread_topic_ids\n    else\n      raise ActionController::ParameterMissing.new(:topic_ids)\n    end\n\n    operation =\n      params\n        .require(:operation)\n        .permit(\n          :type,\n          :group,\n          :category_id,\n          :notification_level_id,\n          *DiscoursePluginRegistry.permitted_bulk_action_parameters,\n          tags: [],\n        )\n        .to_h\n        .symbolize_keys\n\n    raise ActionController::ParameterMissing.new(:operation_type) if operation[:type].blank?\n    operator = TopicsBulkAction.new(current_user, topic_ids, operation, group: operation[:group])\n    changed_topic_ids = operator.perform!\n    render_json_dump topic_ids: changed_topic_ids\n  end\n\n  def private_message_reset_new\n    topic_query = TopicQuery.new(current_user, limit: false)\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n\n      topic_scope =\n        topic_query.private_messages_for(current_user, :all).where(\n          \"topics.id IN (?)\",\n          params[:topic_ids].map(&:to_i),\n        )\n    else\n      params.require(:inbox)\n      inbox = params[:inbox].to_s\n      filter = private_message_filter(topic_query, inbox)\n      topic_scope = topic_query.filter_private_message_new(current_user, filter)\n    end\n\n    topic_ids =\n      TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n\n    render json: success_json.merge(topic_ids: topic_ids)\n  end\n\n  def reset_new\n    topic_scope =\n      if params[:category_id].present?\n        category_ids = [params[:category_id]]\n        if params[:include_subcategories] == \"true\"\n          category_ids =\n            category_ids.concat(Category.where(parent_category_id: params[:category_id]).pluck(:id))\n        end\n\n        scope = Topic.where(category_id: category_ids)\n        scope = scope.joins(:tags).where(tags: { name: params[:tag_id] }) if params[:tag_id]\n        scope\n      elsif params[:tag_id].present?\n        Topic.joins(:tags).where(tags: { name: params[:tag_id] })\n      else\n        new_results = TopicQuery.new(current_user).new_results(limit: false)\n        if params[:tracked].to_s == \"true\"\n          TopicQuery.tracked_filter(new_results, current_user.id)\n        else\n          current_user.user_stat.update_column(:new_since, Time.zone.now)\n          new_results\n        end\n      end\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n      topic_scope = topic_scope.where(id: topic_ids)\n    end\n\n    dismissed_topic_ids =\n      TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n    TopicTrackingState.publish_dismiss_new(current_user.id, topic_ids: dismissed_topic_ids)\n\n    render body: nil\n  end\n\n  def convert_topic\n    params.require(:id)\n    params.require(:type)\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_convert_topic!(topic)\n\n    if params[:type] == \"public\"\n      converted_topic =\n        topic.convert_to_public_topic(current_user, category_id: params[:category_id])\n    else\n      converted_topic = topic.convert_to_private_message(current_user)\n    end\n    render_topic_changes(converted_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def reset_bump_date\n    params.require(:id)\n    guardian.ensure_can_update_bumped_at!\n\n    topic = Topic.find_by(id: params[:id])\n    raise Discourse::NotFound.new unless topic\n\n    topic.reset_bumped_at\n    render body: nil\n  end\n\n  def set_slow_mode\n    topic = Topic.find(params[:topic_id])\n    slow_mode_type = TopicTimer.types[:clear_slow_mode]\n    timer = TopicTimer.find_by(topic: topic, status_type: slow_mode_type)\n\n    guardian.ensure_can_moderate!(topic)\n    topic.update!(slow_mode_seconds: params[:seconds])\n    enabled = params[:seconds].to_i > 0\n\n    time = enabled && params[:enabled_until].present? ? params[:enabled_until] : nil\n\n    topic.set_or_create_timer(slow_mode_type, time, by_user: timer&.user)\n\n    head :ok\n  end\n\n  private\n\n  def topic_params\n    params.permit(:topic_id, :topic_time, timings: {})\n  end\n\n  def fetch_topic_view(options)\n    if (username_filters = params[:username_filters]).present?\n      options[:username_filters] = username_filters.split(\",\")\n    end\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, options)\n  end\n\n  def toggle_mute\n    @topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(@topic)\n\n    @topic.toggle_mute(current_user)\n    render body: nil\n  end\n\n  def consider_user_for_promotion\n    Promotion.new(current_user).review if current_user.present?\n  end\n\n  def should_bypass_bump?(changes)\n    (changes[:category_id].present? && SiteSetting.disable_category_edit_notifications) ||\n      (changes[:tags].present? && SiteSetting.disable_tags_edit_notifications)\n  end\n\n  def slugs_do_not_match\n    if SiteSetting.slug_generation_method != \"encoded\"\n      params[:slug] && @topic_view.topic.slug != params[:slug]\n    else\n      params[:slug] && CGI.unescape(@topic_view.topic.slug) != params[:slug]\n    end\n  end\n\n  def redirect_to_correct_topic(topic, post_number = nil)\n    begin\n      guardian.ensure_can_see!(topic)\n    rescue Discourse::InvalidAccess => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    end\n\n    opts = params.slice(:page, :print, :filter_top_level_replies)\n    opts.delete(:page) if params[:page] == 0\n\n    url = topic.relative_url\n    url << \"/#{post_number}\" if post_number.to_i > 0\n    url << \".json\" if request.format.json?\n\n    opts.each do |k, v|\n      s = url.include?(\"?\") ? \"&\" : \"?\"\n      url << \"#{s}#{k}=#{v}\"\n    end\n\n    redirect_to url, status: 301\n  end\n\n  def track_visit_to_topic\n    topic_id = @topic_view.topic.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n    track_visit = should_track_visit_to_topic?\n\n    if !request.format.json?\n      hash = {\n        referer: request.referer || flash[:referer],\n        host: request.host,\n        current_user: current_user,\n        topic_id: @topic_view.topic.id,\n        post_number: @topic_view.current_post_number,\n        username: request[\"u\"],\n        ip_address: request.remote_ip,\n      }\n      # defer this way so we do not capture the whole controller\n      # in the closure\n      TopicsController.defer_add_incoming_link(hash)\n    end\n\n    TopicsController.defer_track_visit(topic_id, ip, user_id, track_visit)\n  end\n\n  def self.defer_track_visit(topic_id, ip, user_id, track_visit)\n    Scheduler::Defer.later \"Track Visit\" do\n      TopicViewItem.add(topic_id, ip, user_id)\n      TopicUser.track_visit!(topic_id, user_id) if track_visit\n    end\n  end\n\n  def self.defer_add_incoming_link(hash)\n    Scheduler::Defer.later \"Track Link\" do\n      IncomingLink.add(hash)\n    end\n  end\n\n  def should_track_visit_to_topic?\n    !!((!request.format.json? || params[:track_visit]) && current_user)\n  end\n\n  def perform_show_response\n    if request.head?\n      head :ok\n      return\n    end\n\n    topic_view_serializer =\n      TopicViewSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw],\n        exclude_suggested_and_related:\n          !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id] ||\n            !!params[:filter_top_level_replies],\n      )\n\n    respond_to do |format|\n      format.html do\n        @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags : []\n        @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || []\n        @description_meta =\n          @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary\n        store_preloaded(\"topic_#{@topic_view.topic.id}\", MultiJson.dump(topic_view_serializer))\n        render :show\n      end\n\n      format.json { render_json_dump(topic_view_serializer) }\n    end\n  end\n\n  def render_topic_changes(dest_topic)\n    if dest_topic.present?\n      render json: { success: true, url: dest_topic.relative_url }\n    else\n      render json: { success: false }\n    end\n  end\n\n  def move_posts_to_destination(topic)\n    args = {}\n    args[:title] = params[:title] if params[:title].present?\n    args[:destination_topic_id] = params[:destination_topic_id].to_i if params[\n      :destination_topic_id\n    ].present?\n    args[:tags] = params[:tags] if params[:tags].present?\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? &&\n        params[:archetype] == \"private_message\"\n    else\n      args[:category_id] = params[:category_id].to_i if params[:category_id].present?\n    end\n\n    topic.move_posts(current_user, post_ids_including_replies, args)\n  end\n\n  def check_for_status_presence(key, attr)\n    invalid_param(key) unless %w[pinned pinned_globally visible closed archived].include?(attr)\n  end\n\n  def invalid_param(key)\n    raise Discourse::InvalidParameters.new(key.to_sym)\n  end\n\n  def fetch_username\n    params.require(:user)\n    params[:user]\n  end\n\n  def fetch_email\n    params.require(:email)\n    params[:email]\n  end\n\n  def pm_has_slots?(pm)\n    guardian.is_staff? || !pm.reached_recipients_limit?\n  end\n\n  def bulk_unread_topic_ids\n    topic_query = TopicQuery.new(current_user)\n\n    if inbox = params[:private_message_inbox]\n      filter = private_message_filter(topic_query, inbox)\n      topic_query.options[:limit] = false\n      topics = topic_query.filter_private_messages_unread(current_user, filter)\n    else\n      topics =\n        TopicQuery.unread_filter(\n          topic_query.joined_topic_user,\n          whisperer: guardian.is_whisperer?,\n        ).listable_topics\n      topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == \"true\"\n\n      if params[:category_id]\n        if params[:include_subcategories]\n          topics = topics.where(<<~SQL, category_id: params[:category_id])\n            category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR\n            category_id = :category_id\n          SQL\n        else\n          topics = topics.where(\"category_id = ?\", params[:category_id])\n        end\n      end\n\n      if params[:tag_name].present?\n        topics = topics.joins(:tags).where(\"tags.name\": params[:tag_name])\n      end\n    end\n\n    topics.pluck(:id)\n  end\n\n  def private_message_filter(topic_query, inbox)\n    case inbox\n    when \"group\"\n      group_name = params[:group_name]\n      group = Group.find_by(\"lower(name) = ?\", group_name)\n      raise Discourse::NotFound if !group\n      raise Discourse::NotFound if !guardian.can_see_group_messages?(group)\n      topic_query.options[:group_name] = group_name\n      :group\n    when \"user\"\n      :user\n    else\n      :all\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass Tag < ActiveRecord::Base\n  include Searchable\n  include HasDestroyedWebHook\n\n  self.ignored_columns = [\n    \"topic_count\", # TODO(tgxworld): Remove on 1 July 2023\n  ]\n\n  RESERVED_TAGS = [\n    \"none\",\n    \"constructor\", # prevents issues with javascript's constructor of objects\n  ]\n\n  validates :name, presence: true, uniqueness: { case_sensitive: false }\n\n  validate :target_tag_validator,\n           if: Proc.new { |t| t.new_record? || t.will_save_change_to_target_tag_id? }\n  validate :name_validator\n  validates :description, length: { maximum: 280 }\n\n  scope :where_name,\n        ->(name) {\n          name = Array(name).map(&:downcase)\n          where(\"lower(tags.name) IN (?)\", name)\n        }\n\n  # tags that have never been used and don't belong to a tag group\n  scope :unused,\n        -> {\n          where(staff_topic_count: 0, pm_topic_count: 0).joins(\n            \"LEFT JOIN tag_group_memberships tgm ON tags.id = tgm.tag_id\",\n          ).where(\"tgm.tag_id IS NULL\")\n        }\n\n  scope :used_tags_in_regular_topics,\n        ->(guardian) { where(\"tags.#{Tag.topic_count_column(guardian)} > 0\") }\n\n  scope :base_tags, -> { where(target_tag_id: nil) }\n\n  has_many :tag_users, dependent: :destroy # notification settings\n\n  has_many :topic_tags, dependent: :destroy\n  has_many :topics, through: :topic_tags\n\n  has_many :category_tag_stats, dependent: :destroy\n  has_many :category_tags, dependent: :destroy\n  has_many :categories, through: :category_tags\n\n  has_many :tag_group_memberships, dependent: :destroy\n  has_many :tag_groups, through: :tag_group_memberships\n\n  belongs_to :target_tag, class_name: \"Tag\", optional: true\n  has_many :synonyms, class_name: \"Tag\", foreign_key: \"target_tag_id\", dependent: :destroy\n  has_many :sidebar_section_links, as: :linkable, dependent: :delete_all\n\n  after_save :index_search\n  after_save :update_synonym_associations\n\n  after_commit :trigger_tag_created_event, on: :create\n  after_commit :trigger_tag_updated_event, on: :update\n  after_commit :trigger_tag_destroyed_event, on: :destroy\n\n  def self.ensure_consistency!\n    update_topic_counts\n  end\n\n  def self.update_topic_counts\n    DB.exec <<~SQL\n      UPDATE tags t\n         SET staff_topic_count = x.topic_count\n        FROM (\n             SELECT COUNT(topics.id) AS topic_count, tags.id AS tag_id\n               FROM tags\n          LEFT JOIN topic_tags ON tags.id = topic_tags.tag_id\n          LEFT JOIN topics ON topics.id = topic_tags.topic_id\n                          AND topics.deleted_at IS NULL\n                          AND topics.archetype != 'private_message'\n           GROUP BY tags.id\n        ) x\n       WHERE x.tag_id = t.id\n         AND x.topic_count <> t.staff_topic_count\n    SQL\n\n    DB.exec <<~SQL\n      UPDATE tags t\n      SET public_topic_count = x.topic_count\n      FROM (\n        WITH tags_with_public_topics AS (\n          SELECT\n            COUNT(topics.id) AS topic_count,\n            tags.id AS tag_id\n          FROM tags\n          INNER JOIN topic_tags ON tags.id = topic_tags.tag_id\n          INNER JOIN topics ON topics.id = topic_tags.topic_id AND topics.deleted_at IS NULL AND topics.archetype != 'private_message'\n          INNER JOIN categories ON categories.id = topics.category_id AND NOT categories.read_restricted\n          GROUP BY tags.id\n        )\n        SELECT\n          COALESCE(tags_with_public_topics.topic_count, 0 ) AS topic_count,\n          tags.id AS tag_id\n        FROM tags\n        LEFT JOIN tags_with_public_topics ON tags_with_public_topics.tag_id = tags.id\n      ) x\n      WHERE x.tag_id = t.id\n      AND x.topic_count <> t.public_topic_count;\n    SQL\n\n    DB.exec <<~SQL\n      UPDATE tags t\n         SET pm_topic_count = x.pm_topic_count\n        FROM (\n             SELECT COUNT(topics.id) AS pm_topic_count, tags.id AS tag_id\n               FROM tags\n          LEFT JOIN topic_tags ON tags.id = topic_tags.tag_id\n          LEFT JOIN topics ON topics.id = topic_tags.topic_id\n                          AND topics.deleted_at IS NULL\n                          AND topics.archetype = 'private_message'\n           GROUP BY tags.id\n        ) x\n       WHERE x.tag_id = t.id\n         AND x.pm_topic_count <> t.pm_topic_count\n    SQL\n  end\n\n  def self.find_by_name(name)\n    self.find_by(\"lower(name) = ?\", name.downcase)\n  end\n\n  def self.top_tags(limit_arg: nil, category: nil, guardian: Guardian.new)\n    # we add 1 to max_tags_in_filter_list to efficiently know we have more tags\n    # than the limit. Frontend is responsible to enforce limit.\n    limit = limit_arg || (SiteSetting.max_tags_in_filter_list + 1)\n    scope_category_ids = guardian.allowed_category_ids\n    scope_category_ids &= ([category.id] + category.subcategories.pluck(:id)) if category\n\n    return [] if scope_category_ids.empty?\n\n    filter_sql =\n      (\n        if guardian.is_staff?\n          \"\"\n        else\n          \" AND tags.id IN (#{DiscourseTagging.visible_tags(guardian).select(:id).to_sql})\"\n        end\n      )\n\n    tag_names_with_counts = DB.query <<~SQL\n      SELECT tags.name as tag_name, SUM(stats.topic_count) AS sum_topic_count\n        FROM category_tag_stats stats\n        JOIN tags ON stats.tag_id = tags.id AND stats.topic_count > 0\n       WHERE stats.category_id in (#{scope_category_ids.join(\",\")})\n       #{filter_sql}\n    GROUP BY tags.name\n    ORDER BY sum_topic_count DESC, tag_name ASC\n       LIMIT #{limit}\n    SQL\n\n    tag_names_with_counts.map { |row| row.tag_name }\n  end\n\n  def self.topic_count_column(guardian)\n    if guardian&.is_staff? || SiteSetting.include_secure_categories_in_tag_counts\n      \"staff_topic_count\"\n    else\n      \"public_topic_count\"\n    end\n  end\n\n  def self.pm_tags(limit: 1000, guardian: nil, allowed_user: nil)\n    return [] if allowed_user.blank? || !(guardian || Guardian.new).can_tag_pms?\n    user_id = allowed_user.id\n\n    DB.query_hash(<<~SQL).map!(&:symbolize_keys!)\n      SELECT tags.name as id, tags.name as text, COUNT(topics.id) AS count\n        FROM tags\n        JOIN topic_tags ON tags.id = topic_tags.tag_id\n        JOIN topics ON topics.id = topic_tags.topic_id\n                   AND topics.deleted_at IS NULL\n                   AND topics.archetype = 'private_message'\n       WHERE topic_tags.topic_id IN (\n          SELECT topic_id\n            FROM topic_allowed_users\n           WHERE user_id = #{user_id.to_i}\n           UNION\n          SELECT tg.topic_id\n            FROM topic_allowed_groups tg\n            JOIN group_users gu ON gu.user_id = #{user_id.to_i}\n                               AND gu.group_id = tg.group_id\n       )\n       GROUP BY tags.name\n       ORDER BY count DESC\n       LIMIT #{limit.to_i}\n    SQL\n  end\n\n  def self.include_tags?\n    SiteSetting.tagging_enabled\n  end\n\n  def url\n    \"#{Discourse.base_path}/tag/#{UrlHelper.encode_component(self.name)}\"\n  end\n\n  def full_url\n    \"#{Discourse.base_url}/tag/#{UrlHelper.encode_component(self.name)}\"\n  end\n\n  def index_search\n    SearchIndexer.index(self)\n  end\n\n  def synonym?\n    !self.target_tag_id.nil?\n  end\n\n  def target_tag_validator\n    if synonyms.exists?\n      errors.add(:target_tag_id, I18n.t(\"tags.synonyms_exist\"))\n    elsif target_tag&.synonym?\n      errors.add(:target_tag_id, I18n.t(\"tags.invalid_target_tag\"))\n    end\n  end\n\n  def update_synonym_associations\n    if target_tag_id && saved_change_to_target_tag_id?\n      target_tag.tag_groups.each do |tag_group|\n        tag_group.tags << self unless tag_group.tags.include?(self)\n      end\n      target_tag.categories.each do |category|\n        category.tags << self unless category.tags.include?(self)\n      end\n    end\n  end\n\n  %i[tag_created tag_updated tag_destroyed].each do |event|\n    define_method(\"trigger_#{event}_event\") do\n      DiscourseEvent.trigger(event, self)\n      true\n    end\n  end\n\n  private\n\n  def name_validator\n    errors.add(:name, :invalid) if name.present? && RESERVED_TAGS.include?(self.name.strip.downcase)\n  end\nend\n\n# == Schema Information\n#\n# Table name: tags\n#\n#  id                 :integer          not null, primary key\n#  name               :string           not null\n#  created_at         :datetime         not null\n#  updated_at         :datetime         not null\n#  pm_topic_count     :integer          default(0), not null\n#  target_tag_id      :integer\n#  description        :string\n#  public_topic_count :integer          default(0), not null\n#  staff_topic_count  :integer          default(0), not null\n#\n# Indexes\n#\n#  index_tags_on_lower_name  (lower((name)::text)) UNIQUE\n#  index_tags_on_name        (name) UNIQUE\n#\n", "<% if @topic_view %>\n  <div id=\"topic-title\">\n    <h1>\n      <%= render_topic_title(@topic_view.topic) %>\n    </h1>\n\n    <% if @breadcrumbs.present? %>\n      <div class=\"topic-category\" itemscope itemtype=\"http://schema.org/BreadcrumbList\">\n        <% @breadcrumbs.each_with_index do |c, i| %>\n          <span itemprop=\"itemListElement\" itemscope itemtype=\"http://schema.org/ListItem\">\n            <a href=\"<%= Discourse.base_url %><%= c[:url] %>\" class=\"badge-wrapper bullet\" itemprop=\"item\">\n              <span class='badge-category-bg' style='background-color: #<%= c[:color] %>'></span>\n              <span class='badge-category clear-badge'>\n                <span class='category-name' itemprop='name'><%= c[:name] %></span>\n              </span>\n            </a>\n            <meta itemprop=\"position\" content=\"<%= i + 1 %>\" />\n          </span>\n        <% end %>\n      </div>\n    <% end %>\n\n    <% if @tags.present? %>\n      <div class=\"topic-category\">\n        <div class='discourse-tags list-tags'>\n          <% @tags.each_with_index do |tag, i| %>\n            <a href='<%= \"#{Discourse.base_url}/tag/#{tag.name}\" %>' class='discourse-tag' rel=\"tag\"><%= tag.name -%></a><% if i < @tags.size - 1 %>, <% end %>\n          <% end %>\n        </div>\n      </div>\n    <% end %>\n  </div>\n\n  <%= server_plugin_outlet \"topic_header\" %>\n\n  <%- if include_crawler_content? %>\n\n  <% @topic_view.posts.each_with_index do |post, idx| %>\n    <% if (u = post.user) %>\n      <div id='post_<%= post.post_number %>' itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>\n        <div class='crawler-post-meta'>\n          <div itemprop='publisher' itemscope itemtype=\"http://schema.org/Organization\">\n            <meta itemprop='name' content='<%= SiteSetting.company_name.presence || SiteSetting.title %>'>\n            <% if application_logo_url.present? %>\n              <div itemprop='logo' itemscope itemtype=\"http://schema.org/ImageObject\">\n                <meta itemprop='url' content='<%= application_logo_url %>'>\n              </div>\n            <% end %>\n          </div>\n          <span class=\"creator\" itemprop=\"author\" itemscope itemtype=\"http://schema.org/Person\">\n            <a itemprop=\"url\" href='<%= Discourse.base_url %>/u/<%= u.username %>'><span itemprop='name'><%= u.username %></span></a>\n            <%= \"(#{u.name})\" if (SiteSetting.display_name_on_posts && SiteSetting.enable_names? && !u.name.blank?) %>\n            <%\n              post_custom_fields = @topic_view.post_custom_fields[post.id] || {}\n              who_username = post_custom_fields[\"action_code_who\"] || \"\"\n              small_action_href = post_custom_fields[\"action_code_path\"] || \"\"\n              if post.action_code\n            %>\n              <%= t(\"js.action_codes.#{post.action_code}\", when: \"\", who: who_username, href: small_action_href).html_safe %>\n            <% end %>\n          </span>\n\n          <link itemprop=\"mainEntityOfPage\" href=\"<%= post.topic.url %>\">\n\n          <% if post.image_url %>\n            <link itemprop=\"image\" href=\"<%= post.image_url %>\">\n          <% end %>\n\n          <span class=\"crawler-post-infos\">\n              <time itemprop='datePublished' datetime='<%= post.created_at.to_formatted_s(:iso8601) %>' class='post-time'>\n                <%= l post.created_at, format: :long %>\n              </time>\n            <% if post.version > 1 %>\n              <meta itemprop='dateModified' content='<%= post.last_version_at.to_formatted_s(:iso8601) %>'>\n            <% else %>\n              <meta itemprop='dateModified' content='<%= post.created_at.to_formatted_s(:iso8601) %>'>\n            <% end %>\n          <span itemprop='position'><%= post.post_number %></span>\n          </span>\n        </div>\n        <div class='post' itemprop='articleBody'>\n          <%= post.hidden ? t('flagging.user_must_edit').html_safe : post.cooked.html_safe %>\n        </div>\n\n        <meta itemprop='headline' content='<%= @topic_view.title %>'>\n        <% if idx == 0 %>\n          <meta itemprop='keywords' content='<%= @tags.map(&:name).join(', ') %>'>\n        <% end %>\n\n        <div itemprop=\"interactionStatistic\" itemscope itemtype=\"http://schema.org/InteractionCounter\">\n           <meta itemprop=\"interactionType\" content=\"http://schema.org/LikeAction\"/>\n           <meta itemprop=\"userInteractionCount\" content=\"<%= post.like_count %>\" />\n           <span class='post-likes'><%= post.like_count > 0 ? t('post.has_likes', count: post.like_count) : '' %></span>\n         </div>\n\n         <div itemprop=\"interactionStatistic\" itemscope itemtype=\"http://schema.org/InteractionCounter\">\n            <meta itemprop=\"interactionType\" content=\"http://schema.org/CommentAction\"/>\n            <meta itemprop=\"userInteractionCount\" content=\"<%= post.reply_count %>\" />\n          </div>\n\n          <% if @topic_view.link_counts[post.id] && @topic_view.link_counts[post.id].filter { |l| l[:reflection] }.length > 0 %>\n            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>\n              <% @topic_view.link_counts[post.id].each_with_index do |link, i| %>\n                <% if link[:reflection] && link[:title].present? %>\n                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>\n                    <a itemprop='url' href=\"<%=link[:url]%>\"><%=link[:title]%></a>\n                    <meta itemprop='position' content='<%= i+1 %>'>\n                  </div>\n                <% end %>\n              <% end %>\n            </div>\n         <% end %>\n      </div>\n    <% end %>\n  <% end %>\n\n  <% if @topic_view.prev_page || @topic_view.next_page %>\n    <div role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement' class=\"topic-body crawler-post\">\n      <% if @topic_view.prev_page %>\n        <span itemprop='name'><%= link_to t(:prev_page), @topic_view.prev_page_path, rel: 'prev', itemprop: 'url' %></span>\n      <% end %>\n      <% if @topic_view.next_page %>\n        <span itemprop='name'><b><%= link_to t(:next_page), @topic_view.next_page_path, rel: 'next', itemprop: 'url' %></b></span>\n      <% end %>\n    </div>\n  <% end %>\n\n  <% end %>\n\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(@topic_view, {action: :feed, slug: @topic_view.topic.slug, topic_id: @topic_view.topic.id}, rel: 'alternate nofollow', title: t('rss_posts_in_topic', topic: @topic_view.title), type: 'application/rss+xml') %>\n    <%= raw crawlable_meta_data(title: @topic_view.title, description: @topic_view.summary(strip_images: true), image: @topic_view.image_url, read_time: @topic_view.read_time, like_count: @topic_view.like_count, ignore_canonical: true, published_time: @topic_view.published_time, breadcrumbs: @breadcrumbs, tags: @topic_view.tags) %>\n\n    <% if @topic_view.prev_page || @topic_view.next_page %>\n      <% if @topic_view.prev_page %>\n        <link rel=\"prev\" href=\"<%= @topic_view.prev_page_path -%>\">\n      <% end %>\n      <% if @topic_view.next_page %>\n        <link rel=\"next\" href=\"<%= @topic_view.next_page_path -%>\">\n      <% end %>\n    <% end %>\n  <% end %>\n\n  <% content_for(:title) { @title || \"#{gsub_emoji_to_unicode(@topic_view.page_title)} - #{SiteSetting.title}\" } %>\n\n  <% if @topic_view.print %>\n    <% content_for :after_body do %>\n        <%= preload_script('print-page') %>\n    <% end %>\n  <% end %>\n<% end %>\n", "# frozen_string_literal: true\n\nclass TopicView\n  MEGA_TOPIC_POSTS_COUNT = 10_000\n  MIN_POST_READ_TIME = 4.0\n\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.cancel_preload(&blk)\n    if @preload\n      @preload.delete blk\n      @preload = nil if @preload.length == 0\n    end\n  end\n\n  def self.preload(topic_view)\n    @preload.each { |preload| preload.call(topic_view) } if @preload\n  end\n\n  attr_reader(\n    :topic,\n    :posts,\n    :guardian,\n    :filtered_posts,\n    :chunk_size,\n    :print,\n    :message_bus_last_id,\n    :queued_posts_enabled,\n    :personal_message,\n    :can_review_topic,\n    :page,\n  )\n  alias queued_posts_enabled? queued_posts_enabled\n\n  attr_accessor(\n    :draft,\n    :draft_key,\n    :draft_sequence,\n    :user_custom_fields,\n    :post_custom_fields,\n    :post_number,\n  )\n\n  delegate :category, to: :topic, allow_nil: true, private: true\n  delegate :require_reply_approval?, to: :category, prefix: true, allow_nil: true, private: true\n\n  def self.print_chunk_size\n    1000\n  end\n\n  def self.chunk_size\n    20\n  end\n\n  def self.default_post_custom_fields\n    @default_post_custom_fields ||= [Post::NOTICE, \"action_code_who\", \"action_code_path\"]\n  end\n\n  def self.post_custom_fields_allowlisters\n    @post_custom_fields_allowlisters ||= Set.new\n  end\n\n  def self.add_post_custom_fields_allowlister(&block)\n    post_custom_fields_allowlisters << block\n  end\n\n  def self.allowed_post_custom_fields(user, topic)\n    wpcf =\n      default_post_custom_fields + post_custom_fields_allowlisters.map { |w| w.call(user, topic) }\n    wpcf.flatten.uniq\n  end\n\n  def self.add_custom_filter(key, &blk)\n    @custom_filters ||= {}\n    @custom_filters[key] = blk\n  end\n\n  def self.custom_filters\n    @custom_filters || {}\n  end\n\n  # Configure a default scope to be applied to @filtered_posts.\n  # The registered block is called with @filtered_posts and an instance of\n  # `TopicView`.\n  #\n  # This API should be considered experimental until it is exposed in\n  # `Plugin::Instance`.\n  def self.apply_custom_default_scope(&block)\n    custom_default_scopes << block\n  end\n\n  def self.custom_default_scopes\n    @custom_default_scopes ||= []\n  end\n\n  # For testing\n  def self.reset_custom_default_scopes\n    @custom_default_scopes = nil\n  end\n\n  def initialize(topic_or_topic_id, user = nil, options = {})\n    @topic = find_topic(topic_or_topic_id)\n    @user = user\n    @guardian = Guardian.new(@user)\n\n    check_and_raise_exceptions(options[:skip_staff_action])\n\n    @message_bus_last_id = MessageBus.last_id(\"/topic/#{@topic.id}\")\n\n    options.each { |key, value| self.instance_variable_set(\"@#{key}\".to_sym, value) }\n\n    @post_number = [@post_number.to_i, 1].max\n\n    @include_suggested = options.fetch(:include_suggested) { true }\n    @include_related = options.fetch(:include_related) { true }\n\n    @chunk_size =\n      case\n      when @print\n        TopicView.print_chunk_size\n      else\n        TopicView.chunk_size\n      end\n\n    @limit ||= @chunk_size\n\n    @page = @page.to_i > 1 ? @page.to_i : calculate_page\n\n    setup_filtered_posts\n    @filtered_posts = apply_default_scope(@filtered_posts)\n    filter_posts(options)\n\n    if @posts && !@skip_custom_fields\n      if (added_fields = User.allowed_user_custom_fields(@guardian)).present?\n        @user_custom_fields = User.custom_fields_for_ids(@posts.map(&:user_id), added_fields)\n      end\n\n      if (allowed_fields = TopicView.allowed_post_custom_fields(@user, @topic)).present?\n        @post_custom_fields = Post.custom_fields_for_ids(@posts.map(&:id), allowed_fields)\n      end\n    end\n\n    TopicView.preload(self)\n\n    @draft_key = @topic.draft_key\n    @draft_sequence = DraftSequence.current(@user, @draft_key)\n\n    @can_review_topic = @guardian.can_review_topic?(@topic)\n    @queued_posts_enabled = NewPostManager.queue_enabled? || category_require_reply_approval?\n    @personal_message = @topic.private_message?\n  end\n\n  def show_read_indicator?\n    return false if !@user || !topic.private_message?\n\n    topic.allowed_groups.any? { |group| group.publish_read_state? && group.users.include?(@user) }\n  end\n\n  def canonical_path\n    if SiteSetting.embed_set_canonical_url\n      topic_embed = topic.topic_embed\n      return topic_embed.embed_url if topic_embed\n    end\n    path = relative_url.dup\n    path << ((@page > 1) ? \"?page=#{@page}\" : \"\")\n    path\n  end\n\n  def contains_gaps?\n    @contains_gaps\n  end\n\n  def gaps\n    return unless @contains_gaps\n\n    @gaps ||=\n      begin\n        if is_mega_topic?\n          nil\n        else\n          Gaps.new(filtered_post_ids, apply_default_scope(unfiltered_posts).pluck(:id))\n        end\n      end\n  end\n\n  def last_post\n    return nil if @posts.blank?\n    @last_post ||= @posts.last\n  end\n\n  def prev_page\n    @page > 1 && posts.size > 0 ? @page - 1 : nil\n  end\n\n  def next_page\n    @next_page ||=\n      begin\n        if last_post && highest_post_number && (highest_post_number > last_post.post_number)\n          @page + 1\n        end\n      end\n  end\n\n  def prev_page_path\n    if prev_page > 1\n      \"#{relative_url}?page=#{prev_page}\"\n    else\n      relative_url\n    end\n  end\n\n  def next_page_path\n    \"#{relative_url}?page=#{next_page}\"\n  end\n\n  def absolute_url\n    \"#{Discourse.base_url_no_prefix}#{relative_url}\"\n  end\n\n  def relative_url\n    \"#{@topic.relative_url}#{@print ? \"/print\" : \"\"}\"\n  end\n\n  def page_title\n    title = @topic.title\n    if @post_number > 1\n      title += \" - \"\n      post = @topic.posts.find_by(post_number: @post_number)\n      author = post&.user\n      if author && @guardian.can_see_post?(post)\n        title +=\n          I18n.t(\n            \"inline_oneboxer.topic_page_title_post_number_by_user\",\n            post_number: @post_number,\n            username: author.username,\n          )\n      else\n        title += I18n.t(\"inline_oneboxer.topic_page_title_post_number\", post_number: @post_number)\n      end\n    end\n    if SiteSetting.topic_page_title_includes_category\n      if @topic.category_id != SiteSetting.uncategorized_category_id && @topic.category_id &&\n           @topic.category\n        title += \" - #{@topic.category.name}\"\n      elsif SiteSetting.tagging_enabled && @topic.tags.exists?\n        title +=\n          \" - #{@topic.tags.order(\"tags.#{Tag.topic_count_column(@guardian)} DESC\").first.name}\"\n      end\n    end\n    title\n  end\n\n  def title\n    @topic.title\n  end\n\n  def desired_post\n    return @desired_post if @desired_post.present?\n    return nil if posts.blank?\n\n    @desired_post = posts.detect { |p| p.post_number == @post_number }\n    @desired_post ||= posts.first\n    @desired_post\n  end\n\n  def summary(opts = {})\n    return nil if desired_post.blank?\n    # TODO, this is actually quite slow, should be cached in the post table\n    excerpt = desired_post.excerpt(500, opts.merge(strip_links: true, text_entities: true))\n    (excerpt || \"\").gsub(/\\n/, \" \").strip\n  end\n\n  def read_time\n    return nil if @post_number > 1 # only show for topic URLs\n\n    if @topic.word_count && SiteSetting.read_time_word_count > 0\n      [\n        @topic.word_count / SiteSetting.read_time_word_count,\n        @topic.posts_count * MIN_POST_READ_TIME / 60,\n      ].max.ceil\n    end\n  end\n\n  def like_count\n    return nil if @post_number > 1 # only show for topic URLs\n    @topic.like_count\n  end\n\n  def published_time\n    return nil if desired_post.blank?\n    if desired_post.wiki && desired_post.post_number == 1 && desired_post.revisions.size > 0\n      desired_post.revisions.last.updated_at.strftime(\"%FT%T%:z\")\n    else\n      desired_post.created_at.strftime(\"%FT%T%:z\")\n    end\n  end\n\n  def image_url\n    return @topic.image_url if @post_number == 1\n    desired_post&.image_url\n  end\n\n  def filter_posts(opts = {})\n    if opts[:post_number].present?\n      filter_posts_near(opts[:post_number].to_i)\n    elsif opts[:post_ids].present?\n      filter_posts_by_ids(opts[:post_ids])\n    elsif opts[:filter_post_number].present?\n      # Only used for megatopics where we do not load the entire post stream\n      filter_posts_by_post_number(opts[:filter_post_number], opts[:asc])\n    elsif opts[:best].present?\n      # Only used for wordpress\n      filter_best(opts[:best], opts)\n    else\n      filter_posts_paged(@page)\n    end\n  end\n\n  def primary_group_names\n    return @group_names if @group_names\n\n    primary_group_ids = Set.new\n    @posts.each do |p|\n      primary_group_ids << p.user.primary_group_id if p.user.try(:primary_group_id)\n    end\n\n    result = {}\n    unless primary_group_ids.empty?\n      Group.where(id: primary_group_ids.to_a).pluck(:id, :name).each { |g| result[g[0]] = g[1] }\n    end\n\n    @group_names = result\n  end\n\n  # Filter to all posts near a particular post number\n  def filter_posts_near(post_number)\n    posts_before = (@limit.to_f / 4).floor\n    posts_before = 1 if posts_before.zero?\n    sort_order = get_sort_order(post_number)\n\n    before_post_ids =\n      @filtered_posts\n        .reverse_order\n        .where(\"posts.sort_order < ?\", sort_order)\n        .limit(posts_before)\n        .pluck(:id)\n\n    post_ids =\n      before_post_ids +\n        @filtered_posts\n          .where(\"posts.sort_order >= ?\", sort_order)\n          .limit(@limit - before_post_ids.length)\n          .pluck(:id)\n\n    if post_ids.length < @limit\n      post_ids =\n        post_ids +\n          @filtered_posts\n            .reverse_order\n            .where(\"posts.sort_order < ?\", sort_order)\n            .offset(before_post_ids.length)\n            .limit(@limit - post_ids.length)\n            .pluck(:id)\n    end\n\n    filter_posts_by_ids(post_ids)\n  end\n\n  def filter_posts_paged(page)\n    page = [page, 1].max\n    min = @limit * (page - 1)\n\n    # Sometimes we don't care about the OP, for example when embedding comments\n    min = 1 if min == 0 && @exclude_first\n\n    filter_posts_by_ids(@filtered_posts.offset(min).limit(@limit).pluck(:id))\n  end\n\n  def filter_best(max, opts = {})\n    filter = FilterBestPosts.new(@topic, @filtered_posts, max, opts)\n    @posts = filter.posts\n    @filtered_posts = filter.filtered_posts\n  end\n\n  def read?(post_number)\n    return true unless @user\n    read_posts_set.include?(post_number)\n  end\n\n  def has_deleted?\n    @predelete_filtered_posts\n      .with_deleted\n      .where(\"posts.deleted_at IS NOT NULL\")\n      .where(\"posts.post_number > 1\")\n      .exists?\n  end\n\n  def topic_user\n    @topic_user ||=\n      begin\n        return nil if @user.blank?\n        @topic.topic_users.find_by(user_id: @user.id)\n      end\n  end\n\n  def has_bookmarks?\n    bookmarks.any?\n  end\n\n  def bookmarks\n    return [] if @user.blank?\n    return [] if @topic.trashed?\n\n    @bookmarks ||=\n      Bookmark.for_user_in_topic(@user, @topic.id).select(\n        :id,\n        :bookmarkable_id,\n        :bookmarkable_type,\n        :reminder_at,\n        :name,\n        :auto_delete_preference,\n      )\n  end\n\n  MAX_PARTICIPANTS = 24\n\n  def post_counts_by_user\n    @post_counts_by_user ||=\n      begin\n        if is_mega_topic?\n          {}\n        else\n          sql = <<~SQL\n            SELECT user_id, count(*) AS count_all\n              FROM posts\n             WHERE topic_id = :topic_id\n               AND post_type IN (:post_types)\n               AND user_id IS NOT NULL\n               AND posts.deleted_at IS NULL\n               AND action_code IS NULL\n          GROUP BY user_id\n          ORDER BY count_all DESC\n             LIMIT #{MAX_PARTICIPANTS}\n        SQL\n\n          Hash[\n            *DB.query_single(\n              sql,\n              topic_id: @topic.id,\n              post_types: Topic.visible_post_types(@guardian&.user),\n            )\n          ]\n        end\n      end\n  end\n\n  # if a topic has more that N posts no longer attempt to\n  # get accurate participant count, instead grab cached count\n  # from topic\n  MAX_POSTS_COUNT_PARTICIPANTS = 500\n\n  def participant_count\n    @participant_count ||=\n      begin\n        if participants.size == MAX_PARTICIPANTS\n          if @topic.posts_count > MAX_POSTS_COUNT_PARTICIPANTS\n            @topic.participant_count\n          else\n            sql = <<~SQL\n              SELECT COUNT(DISTINCT user_id)\n              FROM posts\n              WHERE id IN (:post_ids)\n              AND user_id IS NOT NULL\n            SQL\n            DB.query_single(sql, post_ids: unfiltered_post_ids).first.to_i\n          end\n        else\n          participants.size\n        end\n      end\n  end\n\n  def participants\n    @participants ||=\n      begin\n        participants = {}\n        User\n          .where(id: post_counts_by_user.keys)\n          .includes(:primary_group, :flair_group)\n          .each { |u| participants[u.id] = u }\n        participants\n      end\n  end\n\n  def topic_allowed_group_ids\n    @topic_allowed_group_ids ||=\n      begin\n        @topic.allowed_groups.map(&:id)\n      end\n  end\n\n  def group_allowed_user_ids\n    return @group_allowed_user_ids unless @group_allowed_user_ids.nil?\n\n    @group_allowed_user_ids =\n      GroupUser.where(group_id: topic_allowed_group_ids).pluck(\"distinct user_id\")\n  end\n\n  def category_group_moderator_user_ids\n    @category_group_moderator_user_ids ||=\n      begin\n        if SiteSetting.enable_category_group_moderation? &&\n             @topic.category&.reviewable_by_group.present?\n          posts_user_ids = Set.new(@posts.map(&:user_id))\n          Set.new(\n            @topic\n              .category\n              .reviewable_by_group\n              .group_users\n              .where(user_id: posts_user_ids)\n              .pluck(\"distinct user_id\"),\n          )\n        else\n          Set.new\n        end\n      end\n  end\n\n  def all_post_actions\n    @all_post_actions ||= PostAction.counts_for(@posts, @user)\n  end\n\n  def links\n    @links ||= TopicLink.topic_map(@guardian, @topic.id)\n  end\n\n  def reviewable_counts\n    @reviewable_counts ||=\n      begin\n        sql = <<~SQL\n        SELECT\n          target_id,\n          MAX(r.id) reviewable_id,\n          COUNT(*) total,\n          SUM(CASE WHEN s.status = :pending THEN 1 ELSE 0 END) pending\n        FROM\n          reviewables r\n        JOIN\n          reviewable_scores s ON reviewable_id = r.id\n        WHERE\n          r.target_id IN (:post_ids) AND\n          r.target_type = 'Post' AND\n          COALESCE(s.reason, '') != 'category'\n        GROUP BY\n          target_id\n      SQL\n\n        counts = {}\n\n        DB\n          .query(sql, pending: ReviewableScore.statuses[:pending], post_ids: @posts.map(&:id))\n          .each do |row|\n            counts[row.target_id] = {\n              total: row.total,\n              pending: row.pending,\n              reviewable_id: row.reviewable_id,\n            }\n          end\n\n        counts\n      end\n  end\n\n  def pending_posts\n    @pending_posts ||=\n      ReviewableQueuedPost.pending.where(created_by: @user, topic: @topic).order(:created_at)\n  end\n\n  def actions_summary\n    return @actions_summary unless @actions_summary.nil?\n\n    @actions_summary = []\n    return @actions_summary unless post = posts&.first\n    PostActionType.topic_flag_types.each do |sym, id|\n      @actions_summary << {\n        id: id,\n        count: 0,\n        hidden: false,\n        can_act: @guardian.post_can_act?(post, sym),\n      }\n    end\n\n    @actions_summary\n  end\n\n  def link_counts\n    @link_counts ||= TopicLink.counts_for(@guardian, @topic, posts)\n  end\n\n  def pm_params\n    @pm_params ||= TopicQuery.new(@user).get_pm_params(topic)\n  end\n\n  def suggested_topics\n    if @include_suggested\n      @suggested_topics ||= TopicQuery.new(@user).list_suggested_for(topic, pm_params: pm_params)\n    else\n      nil\n    end\n  end\n\n  def related_messages\n    if @include_related\n      @related_messages ||= TopicQuery.new(@user).list_related_for(topic, pm_params: pm_params)\n    else\n      nil\n    end\n  end\n\n  # This is pending a larger refactor, that allows custom orders\n  # for now we need to look for the highest_post_number in the stream\n  # the cache on topics is not correct if there are deleted posts at\n  # the end of the stream (for mods), nor is it correct for filtered\n  # streams\n  def highest_post_number\n    @highest_post_number ||= @filtered_posts.maximum(:post_number)\n  end\n\n  def recent_posts\n    @filtered_posts.unscope(:order).by_newest.with_user.first(25)\n  end\n\n  # Returns an array of [id, days_ago] tuples.\n  # `days_ago` is there for the timeline calculations.\n  def filtered_post_stream\n    @filtered_post_stream ||=\n      begin\n        posts = @filtered_posts\n        columns = [:id]\n\n        if !is_mega_topic?\n          columns << \"(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - posts.created_at) / 86400)::INT AS days_ago\"\n        end\n\n        posts.pluck(*columns)\n      end\n  end\n\n  def filtered_post_ids\n    @filtered_post_ids ||=\n      filtered_post_stream.map do |tuple|\n        if is_mega_topic?\n          tuple\n        else\n          tuple[0]\n        end\n      end\n  end\n\n  def unfiltered_post_ids\n    @unfiltered_post_ids ||=\n      begin\n        if @contains_gaps\n          unfiltered_posts.pluck(:id)\n        else\n          filtered_post_ids\n        end\n      end\n  end\n\n  def filtered_post_id(post_number)\n    @filtered_posts.where(post_number: post_number).pick(:id)\n  end\n\n  def is_mega_topic?\n    @is_mega_topic ||= (@topic.posts_count >= MEGA_TOPIC_POSTS_COUNT)\n  end\n\n  def last_post_id\n    @filtered_posts.reverse_order.pick(:id)\n  end\n\n  def current_post_number\n    if highest_post_number.present?\n      post_number > highest_post_number ? highest_post_number : post_number\n    end\n  end\n\n  def queued_posts_count\n    ReviewableQueuedPost.viewable_by(@user).where(topic_id: @topic.id).pending.count\n  end\n\n  def published_page\n    @topic.published_page\n  end\n\n  def mentioned_users\n    @mentioned_users ||=\n      begin\n        mentions = @posts.to_h { |p| [p.id, p.mentions] }.reject { |_, v| v.empty? }\n        usernames = mentions.values\n        usernames.flatten!\n        usernames.uniq!\n\n        users = User.where(username: usernames).includes(:user_status).index_by(&:username)\n\n        mentions.reduce({}) do |hash, (post_id, post_mentioned_usernames)|\n          hash[post_id] = post_mentioned_usernames.map { |username| users[username] }.compact\n          hash\n        end\n      end\n  end\n\n  def tags\n    @topic.tags.map(&:name)\n  end\n\n  protected\n\n  def read_posts_set\n    @read_posts_set ||=\n      begin\n        result = Set.new\n        return result unless @user.present?\n        return result unless topic_user.present?\n\n        post_numbers =\n          PostTiming\n            .where(topic_id: @topic.id, user_id: @user.id)\n            .where(post_number: @posts.pluck(:post_number))\n            .pluck(:post_number)\n\n        post_numbers.each { |pn| result << pn }\n        result\n      end\n  end\n\n  private\n\n  def calculate_page\n    posts_count =\n      is_mega_topic? ? @post_number : unfiltered_posts.where(\"post_number <= ?\", @post_number).count\n    ((posts_count - 1) / @limit) + 1\n  end\n\n  def get_sort_order(post_number)\n    sql = <<~SQL\n      SELECT posts.sort_order\n      FROM posts\n      WHERE posts.post_number = #{post_number.to_i}\n      AND posts.topic_id = #{@topic.id.to_i}\n      LIMIT 1\n    SQL\n\n    sort_order = DB.query_single(sql).first\n\n    if !sort_order\n      sql = <<~SQL\n        SELECT posts.sort_order\n        FROM posts\n        WHERE posts.topic_id = #{@topic.id.to_i}\n        ORDER BY @(post_number - #{post_number.to_i})\n        LIMIT 1\n      SQL\n\n      sort_order = DB.query_single(sql).first\n    end\n\n    sort_order\n  end\n\n  def filter_post_types(posts)\n    return posts.where(post_type: Post.types[:regular]) if @only_regular\n\n    visible_types = Topic.visible_post_types(@user)\n\n    if @user.present?\n      posts.where(\"posts.user_id = ? OR post_type IN (?)\", @user.id, visible_types)\n    else\n      posts.where(post_type: visible_types)\n    end\n  end\n\n  def filter_posts_by_post_number(post_number, asc)\n    sort_order = get_sort_order(post_number)\n\n    posts =\n      if asc\n        @filtered_posts.where(\"sort_order > ?\", sort_order)\n      else\n        @filtered_posts.reverse_order.where(\"sort_order < ?\", sort_order)\n      end\n\n    posts = posts.limit(@limit) if !@skip_limit\n    filter_posts_by_ids(posts.pluck(:id))\n\n    @posts = @posts.reverse_order if !asc\n  end\n\n  def filter_posts_by_ids(post_ids)\n    @posts =\n      Post.where(id: post_ids, topic_id: @topic.id).includes(\n        { user: %i[primary_group flair_group] },\n        :reply_to_user,\n        :deleted_by,\n        :incoming_email,\n        :image_upload,\n      )\n\n    @posts = @posts.includes({ user: :user_status }) if SiteSetting.enable_user_status\n\n    @posts = apply_default_scope(@posts)\n    @posts = filter_post_types(@posts)\n    @posts = @posts.with_deleted if @guardian.can_see_deleted_posts?(@topic.category)\n    @posts\n  end\n\n  def find_topic(topic_or_topic_id)\n    return topic_or_topic_id if topic_or_topic_id.is_a?(Topic)\n    # with_deleted covered in #check_and_raise_exceptions\n    Topic.with_deleted.includes(:category, :tags).find_by(id: topic_or_topic_id)\n  end\n\n  def unfiltered_posts\n    result = filter_post_types(@topic.posts)\n    result = result.with_deleted if @guardian.can_see_deleted_posts?(@topic.category)\n    result = result.where(\"user_id IS NOT NULL\") if @exclude_deleted_users\n    result = result.where(hidden: false) if @exclude_hidden\n    result\n  end\n\n  def apply_default_scope(scope)\n    scope = scope.order(sort_order: :asc)\n\n    self.class.custom_default_scopes.each { |block| scope = block.call(scope, self) }\n\n    scope\n  end\n\n  def setup_filtered_posts\n    # Certain filters might leave gaps between posts. If that's true, we can return a gap structure\n    @contains_gaps = false\n    @filtered_posts = unfiltered_posts\n\n    if @user\n      sql = <<~SQL\n        SELECT ignored_user_id\n        FROM ignored_users as ig\n        INNER JOIN users as u ON u.id = ig.ignored_user_id\n        WHERE ig.user_id = :current_user_id\n          AND ig.ignored_user_id <> :current_user_id\n          AND NOT u.admin\n          AND NOT u.moderator\n      SQL\n\n      ignored_user_ids = DB.query_single(sql, current_user_id: @user.id)\n\n      if ignored_user_ids.present?\n        @filtered_posts =\n          @filtered_posts.where.not(\"user_id IN (?) AND posts.post_number != 1\", ignored_user_ids)\n        @contains_gaps = true\n      end\n    end\n\n    # Filters\n    if @filter == \"summary\"\n      @filtered_posts = @filtered_posts.summary(@topic.id)\n      @contains_gaps = true\n    end\n\n    if @filter.present? && @filter.to_s != \"summary\" && TopicView.custom_filters[@filter].present?\n      @filtered_posts = TopicView.custom_filters[@filter].call(@filtered_posts, self)\n    end\n\n    if @best.present?\n      @filtered_posts = @filtered_posts.where(\"posts.post_type = ?\", Post.types[:regular])\n      @contains_gaps = true\n    end\n\n    # Username filters\n    if @username_filters.present?\n      usernames = @username_filters.map { |u| u.downcase }\n\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.user_id IN (SELECT u.id FROM users u WHERE u.username_lower IN (?))\n      \",\n          usernames,\n        )\n\n      @contains_gaps = true\n    end\n\n    # Filter replies\n    if @replies_to_post_number.present?\n      post_id = filtered_post_id(@replies_to_post_number.to_i)\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.post_number = :post_number\n        OR posts.reply_to_post_number = :post_number\n        OR posts.id IN (SELECT pr.reply_post_id FROM post_replies pr WHERE pr.post_id = :post_id)\",\n          { post_number: @replies_to_post_number.to_i, post_id: post_id },\n        )\n\n      @contains_gaps = true\n    end\n\n    # Show Only Top Level Replies\n    if @filter_top_level_replies.present?\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number > 1\n        AND posts.reply_to_post_number IS NULL\n      \",\n        )\n    end\n\n    # Filtering upwards\n    if @filter_upwards_post_id.present?\n      post = Post.find(@filter_upwards_post_id)\n      post_ids = DB.query_single(<<~SQL, post_id: post.id, topic_id: post.topic_id)\n      WITH RECURSIVE breadcrumb(id, reply_to_post_number) AS (\n            SELECT p.id, p.reply_to_post_number FROM posts AS p\n              WHERE p.id = :post_id\n            UNION\n              SELECT p.id, p.reply_to_post_number FROM posts AS p, breadcrumb\n                WHERE breadcrumb.reply_to_post_number = p.post_number\n                  AND p.topic_id = :topic_id\n          )\n      SELECT id from breadcrumb\n      WHERE id <> :post_id\n      ORDER by id\n      SQL\n\n      post_ids = (post_ids[(0 - SiteSetting.max_reply_history)..-1] || post_ids)\n      post_ids.push(post.id)\n\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.id IN (:post_ids)\n        OR posts.id > :max_post_id\",\n          { post_ids: post_ids, max_post_id: post_ids.max },\n        )\n\n      @contains_gaps = true\n    end\n\n    # Deleted\n    # This should be last - don't want to tell the admin about deleted posts that clicking the button won't show\n    # copy the filter for has_deleted? method\n    @predelete_filtered_posts = @filtered_posts.spawn\n\n    if @guardian.can_see_deleted_posts?(@topic.category) && !@show_deleted && has_deleted?\n      @filtered_posts = @filtered_posts.where(\"posts.deleted_at IS NULL OR posts.post_number = 1\")\n\n      @contains_gaps = true\n    end\n  end\n\n  def check_and_raise_exceptions(skip_staff_action)\n    raise Discourse::NotFound if @topic.blank?\n    # Special case: If the topic is private and the user isn't logged in, ask them\n    # to log in!\n    raise Discourse::NotLoggedIn.new if @topic.present? && @topic.private_message? && @user.blank?\n    # can user see this topic?\n    unless @guardian.can_see?(@topic)\n      raise Discourse::InvalidAccess.new(\"can't see #{@topic}\", @topic)\n    end\n    # log personal message views\n    if SiteSetting.log_personal_messages_views && !skip_staff_action && @topic.present? &&\n         @topic.private_message? && @topic.all_allowed_users.where(id: @user.id).blank?\n      unless UserHistory\n               .where(\n                 acting_user_id: @user.id,\n                 action: UserHistory.actions[:check_personal_message],\n                 topic_id: @topic.id,\n               )\n               .where(\"created_at > ?\", 1.hour.ago)\n               .exists?\n        StaffActionLogger.new(@user).log_check_personal_message(@topic)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"topic_view\"\n\nRSpec.describe TopicView do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:evil_trout) { Fabricate(:evil_trout) }\n  fab!(:first_poster) { topic.user }\n  fab!(:anonymous) { Fabricate(:anonymous) }\n\n  let(:topic_view) { TopicView.new(topic.id, evil_trout) }\n\n  describe \"preload\" do\n    it \"allows preloading of data\" do\n      preloaded_topic_view = nil\n      preloader = lambda { |view| preloaded_topic_view = view }\n\n      TopicView.on_preload(&preloader)\n\n      expect(preloaded_topic_view).to eq(nil)\n      topic_view\n      expect(preloaded_topic_view).to eq(topic_view)\n\n      TopicView.cancel_preload(&preloader)\n    end\n  end\n\n  it \"raises a not found error if the topic doesn't exist\" do\n    expect { TopicView.new(1_231_232, evil_trout) }.to raise_error(Discourse::NotFound)\n  end\n\n  it \"accepts a topic or a topic id\" do\n    expect(TopicView.new(topic, evil_trout).topic).to eq(topic)\n    expect(TopicView.new(topic.id, evil_trout).topic).to eq(topic)\n  end\n\n  # see also spec/controllers/topics_controller_spec.rb TopicsController::show::permission errors\n  it \"raises an error if the user can't see the topic\" do\n    Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n    expect { topic_view }.to raise_error(Discourse::InvalidAccess)\n  end\n\n  it \"handles deleted topics\" do\n    topic.trash!(admin)\n    expect { TopicView.new(topic.id, user) }.to raise_error(Discourse::InvalidAccess)\n    expect { TopicView.new(topic.id, admin) }.not_to raise_error\n  end\n\n  describe \"filter options\" do\n    fab!(:p0) { Fabricate(:post, topic: topic) }\n    fab!(:p1) { Fabricate(:post, topic: topic, post_type: Post.types[:moderator_action]) }\n    fab!(:p2) { Fabricate(:post, topic: topic, post_type: Post.types[:small_action]) }\n\n    it \"omits moderator actions and small posts when only_regular is set\" do\n      tv = TopicView.new(topic.id, nil)\n      expect(tv.filtered_post_ids).to eq([p0.id, p1.id, p2.id])\n\n      tv = TopicView.new(topic.id, nil, only_regular: true)\n      expect(tv.filtered_post_ids).to eq([p0.id])\n    end\n\n    it \"omits the first post when exclude_first is set\" do\n      tv = TopicView.new(topic.id, nil, exclude_first: true)\n      expect(tv.filtered_post_ids).to eq([p0.id, p1.id, p2.id])\n    end\n  end\n\n  describe \"custom filters\" do\n    fab!(:p0) { Fabricate(:post, topic: topic) }\n    fab!(:p1) { Fabricate(:post, topic: topic, wiki: true) }\n\n    it \"allows to register custom filters\" do\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"wiki\" })\n      expect(tv.filter_posts({ filter: \"wiki\" })).to eq([p0, p1])\n\n      TopicView.add_custom_filter(\"wiki\") { |posts, topic_view| posts.where(wiki: true) }\n\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"wiki\" })\n      expect(tv.filter_posts).to eq([p1])\n\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"whatever\" })\n      expect(tv.filter_posts).to eq([p0, p1])\n    ensure\n      TopicView.instance_variable_set(:@custom_filters, {})\n    end\n  end\n\n  describe \"setup_filtered_posts\" do\n    describe \"filters posts with ignored users\" do\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: evil_trout, ignored_user: user) }\n      let!(:post) { Fabricate(:post, topic: topic, user: first_poster) }\n      let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout) }\n      let!(:post3) { Fabricate(:post, topic: topic, user: user) }\n\n      it \"filters out ignored user posts\" do\n        tv = TopicView.new(topic.id, evil_trout)\n        expect(tv.filtered_post_ids).to eq([post.id, post2.id])\n      end\n\n      it \"returns nil for next_page\" do\n        tv = TopicView.new(topic.id, evil_trout)\n        expect(tv.next_page).to eq(nil)\n      end\n\n      context \"when an ignored user made the original post\" do\n        let!(:post) { Fabricate(:post, topic: topic, user: user) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id])\n        end\n      end\n\n      context \"when an anonymous user made a post\" do\n        let!(:post4) { Fabricate(:post, topic: topic, user: anonymous) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post4.id])\n        end\n      end\n\n      context \"when an anonymous (non signed-in) user is viewing a Topic\" do\n        let!(:post4) { Fabricate(:post, topic: topic, user: anonymous) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, nil)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post3.id, post4.id])\n        end\n      end\n\n      context \"when a staff user is ignored\" do\n        let!(:admin) { Fabricate(:user, admin: true) }\n        let!(:admin_ignored_user) do\n          Fabricate(:ignored_user, user: evil_trout, ignored_user: admin)\n        end\n        let!(:post4) { Fabricate(:post, topic: topic, user: admin) }\n\n        it \"filters out ignored user excluding the staff user\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post4.id])\n        end\n      end\n    end\n  end\n\n  describe \"chunk_size\" do\n    it \"returns `chunk_size` by default\" do\n      expect(TopicView.new(topic.id, evil_trout).chunk_size).to eq(TopicView.chunk_size)\n    end\n\n    it \"returns `print_chunk_size` when print param is true\" do\n      tv = TopicView.new(topic.id, evil_trout, print: true)\n      expect(tv.chunk_size).to eq(TopicView.print_chunk_size)\n    end\n  end\n\n  context \"with a few sample posts\" do\n    fab!(:p1) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 1) }\n    fab!(:p2) { Fabricate(:post, topic: topic, user: evil_trout, percent_rank: 0.5) }\n    fab!(:p3) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 0) }\n\n    it \"it can find the best responses\" do\n      best2 = TopicView.new(topic.id, evil_trout, best: 2)\n      expect(best2.posts.count).to eq(2)\n      expect(best2.posts[0].id).to eq(p2.id)\n      expect(best2.posts[1].id).to eq(p3.id)\n\n      topic.update_status(\"closed\", true, admin)\n      expect(topic.posts.count).to eq(4)\n\n      # should not get the status post\n      best = TopicView.new(topic.id, nil, best: 99)\n      expect(best.posts.count).to eq(2)\n      expect(best.filtered_post_ids.size).to eq(3)\n      expect(best.posts.pluck(:id)).to match_array([p2.id, p3.id])\n\n      # should get no results for trust level too low\n      best = TopicView.new(topic.id, nil, best: 99, min_trust_level: evil_trout.trust_level + 1)\n      expect(best.posts.count).to eq(0)\n\n      # should filter out the posts with a score that is too low\n      best = TopicView.new(topic.id, nil, best: 99, min_score: 99)\n      expect(best.posts.count).to eq(0)\n\n      # should filter out everything if min replies not met\n      best = TopicView.new(topic.id, nil, best: 99, min_replies: 99)\n      expect(best.posts.count).to eq(0)\n\n      # should punch through posts if the score is high enough\n      p2.update_column(:score, 100)\n\n      best =\n        TopicView.new(\n          topic.id,\n          nil,\n          best: 99,\n          bypass_trust_level_score: 100,\n          min_trust_level: evil_trout.trust_level + 1,\n        )\n      expect(best.posts.count).to eq(1)\n\n      # 0 means ignore\n      best =\n        TopicView.new(\n          topic.id,\n          nil,\n          best: 99,\n          bypass_trust_level_score: 0,\n          min_trust_level: evil_trout.trust_level + 1,\n        )\n      expect(best.posts.count).to eq(0)\n\n      # If we restrict to posts a moderator liked, return none\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(0)\n\n      # It doesn't count likes from admins\n      PostActionCreator.like(admin, p3)\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(0)\n\n      # It should find the post liked by the moderator\n      PostActionCreator.like(moderator, p2)\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(1)\n    end\n\n    it \"raises NotLoggedIn if the user isn't logged in and is trying to view a private message\" do\n      Topic.any_instance.expects(:private_message?).returns(true)\n      expect { TopicView.new(topic.id, nil) }.to raise_error(Discourse::NotLoggedIn)\n    end\n\n    context \"when log_check_personal_message is enabled\" do\n      fab!(:group) { Fabricate(:group) }\n      fab!(:private_message) { Fabricate(:private_message_topic, allowed_groups: [group]) }\n\n      before do\n        SiteSetting.log_personal_messages_views = true\n        evil_trout.admin = true\n      end\n\n      it \"logs view if Admin views personal message for other user/group\" do\n        allowed_user = private_message.topic_allowed_users.first.user\n        TopicView.new(private_message.id, allowed_user)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          1,\n        )\n      end\n\n      it \"does not log personal message view for group he belongs to\" do\n        group.users << evil_trout\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view for his own personal message\" do\n        private_message.allowed_users << evil_trout\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view if user can't see the message\" do\n        expect { TopicView.new(private_message.id, user) }.to raise_error(Discourse::InvalidAccess)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view if there exists a similar log in previous hour\" do\n        2.times { TopicView.new(private_message.id, evil_trout) }\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          1,\n        )\n\n        freeze_time (2.hours.from_now)\n\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          2,\n        )\n      end\n    end\n\n    it \"provides an absolute url\" do\n      expect(topic_view.absolute_url).to eq(\"http://test.localhost/t/#{topic.slug}/#{topic.id}\")\n    end\n\n    context \"with subfolder\" do\n      it \"provides the correct absolute url\" do\n        set_subfolder \"/forum\"\n        expect(topic_view.absolute_url).to eq(\n          \"http://test.localhost/forum/t/#{topic.slug}/#{topic.id}\",\n        )\n      end\n    end\n\n    it \"provides a summary of the first post\" do\n      expect(topic_view.summary).to be_present\n    end\n\n    describe \"#get_canonical_path\" do\n      fab!(:topic) { Fabricate(:topic) }\n      let(:path) { \"/1234\" }\n\n      before do\n        topic.stubs(:relative_url).returns(path)\n        TopicView.any_instance.stubs(:find_topic).with(1234).returns(topic)\n      end\n\n      it \"generates canonical path correctly\" do\n        expect(TopicView.new(1234, user).canonical_path).to eql(path)\n        expect(TopicView.new(1234, user, page: 5).canonical_path).to eql(\"/1234?page=5\")\n      end\n\n      it \"generates a canonical correctly for paged results\" do\n        5.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n\n        expect(TopicView.new(1234, user, post_number: 5, limit: 2).canonical_path).to eql(\n          \"/1234?page=3\",\n        )\n      end\n\n      it \"generates canonical path correctly by skipping whisper posts\" do\n        2.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n        2.times { |i| Fabricate(:whisper, post_number: i + 3, topic: topic) }\n        Fabricate(:post, post_number: 5, topic: topic)\n\n        expect(TopicView.new(1234, user, post_number: 5, limit: 2).canonical_path).to eql(\n          \"/1234?page=2\",\n        )\n      end\n\n      it \"generates canonical path correctly for mega topics\" do\n        2.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n        2.times { |i| Fabricate(:whisper, post_number: i + 3, topic: topic) }\n        Fabricate(:post, post_number: 5, topic: topic)\n\n        expect(\n          TopicView.new(1234, user, post_number: 5, limit: 2, is_mega_topic: true).canonical_path,\n        ).to eql(\"/1234?page=3\")\n      end\n    end\n\n    describe \"#next_page\" do\n      let!(:post) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post2) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post3) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post4) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post5) { Fabricate(:post, topic: topic, user: user) }\n\n      before { TopicView.stubs(:chunk_size).returns(2) }\n\n      it \"should return the next page\" do\n        expect(TopicView.new(topic.id, user, { post_number: post.post_number }).next_page).to eql(3)\n      end\n    end\n\n    describe \".post_counts_by_user\" do\n      it \"returns the two posters with their appropriate counts\" do\n        SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n        Fabricate(:post, topic: topic, user: evil_trout, post_type: Post.types[:whisper])\n        # Should not be counted\n        Fabricate(\n          :post,\n          topic: topic,\n          user: evil_trout,\n          post_type: Post.types[:whisper],\n          action_code: \"assign\",\n        )\n\n        expect(TopicView.new(topic.id, admin).post_counts_by_user.to_a).to match_array(\n          [[first_poster.id, 2], [evil_trout.id, 2]],\n        )\n\n        expect(TopicView.new(topic.id, first_poster).post_counts_by_user.to_a).to match_array(\n          [[first_poster.id, 2], [evil_trout.id, 1]],\n        )\n      end\n\n      it \"doesn't return counts for posts with authors who have been deleted\" do\n        p2.user_id = nil\n        p2.save!\n\n        expect(topic_view.post_counts_by_user.to_a).to match_array([[first_poster.id, 2]])\n      end\n    end\n\n    describe \".participants\" do\n      it \"returns the two participants hashed by id\" do\n        expect(topic_view.participants.to_a).to match_array(\n          [[first_poster.id, first_poster], [evil_trout.id, evil_trout]],\n        )\n      end\n    end\n\n    describe \".all_post_actions\" do\n      it \"is blank at first\" do\n        expect(topic_view.all_post_actions).to be_blank\n      end\n\n      it \"returns the like\" do\n        PostActionCreator.like(evil_trout, p1)\n        expect(topic_view.all_post_actions[p1.id][PostActionType.types[:like]]).to be_present\n      end\n    end\n\n    describe \".read?\" do\n      it \"tracks correctly\" do\n        # anon is assumed to have read everything\n        expect(TopicView.new(topic.id).read?(1)).to eq(true)\n\n        # random user has nothing\n        expect(topic_view.read?(1)).to eq(false)\n\n        evil_trout.created_at = 2.days.ago\n\n        # a real user that just read it should have it marked\n        PostTiming.process_timings(evil_trout, topic.id, 1, [[1, 1000]])\n        expect(TopicView.new(topic.id, evil_trout).read?(1)).to eq(true)\n        expect(TopicView.new(topic.id, evil_trout).topic_user).to be_present\n      end\n    end\n\n    describe \"#bookmarks\" do\n      let!(:user) { Fabricate(:user) }\n      let!(:bookmark1) do\n        Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic), user: user)\n      end\n      let!(:bookmark2) do\n        Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic), user: user)\n      end\n      let!(:bookmark3) { Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic)) }\n\n      it \"returns all the bookmarks in the topic for a user\" do\n        expect(TopicView.new(topic.id, user).bookmarks.pluck(:id)).to match_array(\n          [bookmark1.id, bookmark2.id],\n        )\n      end\n\n      it \"returns [] for anon users\" do\n        expect(TopicView.new(topic.id, nil).bookmarks.pluck(:id)).to eq([])\n      end\n    end\n\n    describe \"#bookmarks\" do\n      let!(:user) { Fabricate(:user) }\n      let!(:bookmark1) do\n        Fabricate(:bookmark_next_business_day_reminder, bookmarkable: topic.first_post, user: user)\n      end\n      let!(:bookmark2) do\n        Fabricate(\n          :bookmark_next_business_day_reminder,\n          bookmarkable: topic.posts.order(:post_number)[1],\n          user: user,\n        )\n      end\n\n      it \"gets the first post bookmark reminder at for the user\" do\n        topic_view = TopicView.new(topic.id, user)\n\n        first, second = topic_view.bookmarks.sort_by(&:id)\n        expect(first[:bookmarkable_id]).to eq(bookmark1.bookmarkable_id)\n        expect(first[:reminder_at]).to eq_time(bookmark1.reminder_at)\n        expect(second[:bookmarkable_id]).to eq(bookmark2.bookmarkable_id)\n        expect(second[:reminder_at]).to eq_time(bookmark2.reminder_at)\n      end\n\n      context \"when the topic is deleted\" do\n        it \"returns []\" do\n          topic_view = TopicView.new(topic, user)\n          expect(topic_view.bookmarks).to match_array([bookmark1, bookmark2])\n          PostDestroyer.new(Fabricate(:admin), topic.first_post).destroy\n          topic.reload\n          topic_view.instance_variable_set(:@bookmarks, nil)\n          expect(topic_view.bookmarks).to eq([])\n        end\n      end\n\n      context \"when one of the posts is deleted\" do\n        it \"does not return that post's bookmark\" do\n          topic_view = TopicView.new(topic, user)\n          PostDestroyer.new(Fabricate(:admin), topic.posts.second).destroy\n          topic.reload\n\n          expect(topic_view.bookmarks.length).to eq(1)\n          first = topic_view.bookmarks.first\n          expect(first[:bookmarkable_id]).to eq(bookmark1.bookmarkable_id)\n          expect(first[:reminder_at]).to eq_time(bookmark1.reminder_at)\n        end\n      end\n    end\n\n    describe \".topic_user\" do\n      it \"returns nil when there is no user\" do\n        expect(TopicView.new(topic.id, nil).topic_user).to be_blank\n      end\n    end\n\n    describe \"#recent_posts\" do\n      before do\n        24.times do |t| # our let()s have already created 3\n          Fabricate(:post, topic: topic, user: first_poster, created_at: t.seconds.from_now)\n        end\n      end\n\n      it \"returns at most 25 recent posts ordered newest first\" do\n        recent_posts = topic_view.recent_posts\n\n        # count\n        expect(recent_posts.count).to eq(25)\n\n        # ordering\n        expect(recent_posts.include?(p1)).to eq(false)\n        expect(recent_posts.include?(p3)).to eq(true)\n        expect(recent_posts.first.created_at).to be > recent_posts.last.created_at\n      end\n    end\n  end\n\n  describe \"whispers\" do\n    it \"handles their visibility properly\" do\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n      p1 = Fabricate(:post, topic: topic, user: evil_trout)\n      p2 = Fabricate(:post, topic: topic, user: evil_trout, post_type: Post.types[:whisper])\n      p3 = Fabricate(:post, topic: topic, user: evil_trout)\n\n      ch_posts = TopicView.new(topic.id, evil_trout).posts\n      expect(ch_posts.map(&:id)).to eq([p1.id, p2.id, p3.id])\n\n      anon_posts = TopicView.new(topic.id).posts\n      expect(anon_posts.map(&:id)).to eq([p1.id, p3.id])\n\n      admin_posts = TopicView.new(topic.id, moderator).posts\n      expect(admin_posts.map(&:id)).to eq([p1.id, p2.id, p3.id])\n    end\n  end\n\n  describe \"#posts\" do\n    # Create the posts in a different order than the sort_order\n    let!(:p5) { Fabricate(:post, topic: topic, user: evil_trout) }\n    let!(:p2) { Fabricate(:post, topic: topic, user: evil_trout) }\n    let!(:p6) { Fabricate(:post, topic: topic, user: user, deleted_at: Time.now) }\n    let!(:p4) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }\n    let!(:p1) { Fabricate(:post, topic: topic, user: first_poster) }\n    let!(:p7) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }\n    let!(:p3) { Fabricate(:post, topic: topic, user: first_poster) }\n\n    before do\n      TopicView.stubs(:chunk_size).returns(3)\n\n      # Update them to the sort order we're checking for\n      [p1, p2, p3, p4, p5, p6, p7].each_with_index do |p, idx|\n        p.sort_order = idx + 1\n        p.save\n      end\n      p6.user_id = nil # user got nuked\n      p6.save!\n    end\n\n    describe \"contains_gaps?\" do\n      it \"works\" do\n        # does not contain contains_gaps with default filtering\n        expect(topic_view.contains_gaps?).to eq(false)\n        # contains contains_gaps when filtered by username\" do\n        expect(\n          TopicView.new(topic.id, evil_trout, username_filters: [\"eviltrout\"]).contains_gaps?,\n        ).to eq(true)\n        # contains contains_gaps when filtered by summary\n        expect(TopicView.new(topic.id, evil_trout, filter: \"summary\").contains_gaps?).to eq(true)\n        # contains contains_gaps when filtered by best\n        expect(TopicView.new(topic.id, evil_trout, best: 5).contains_gaps?).to eq(true)\n      end\n    end\n\n    it \"#restricts to correct topic\" do\n      t2 = Fabricate(:topic)\n\n      category = Fabricate(:category, name: \"my test\")\n      category.set_permissions(Group[:admins] => :full)\n      category.save\n\n      topic.category_id = category.id\n      topic.save!\n\n      expect { TopicView.new(topic.id, evil_trout).posts.count }.to raise_error(\n        Discourse::InvalidAccess,\n      )\n\n      expect(TopicView.new(t2.id, evil_trout, post_ids: [p1.id, p2.id]).posts.count).to eq(0)\n    end\n\n    describe \"#filter_posts_paged\" do\n      before { TopicView.stubs(:chunk_size).returns(2) }\n\n      it \"returns correct posts for all pages\" do\n        expect(topic_view.filter_posts_paged(1)).to eq([p1, p2])\n        expect(topic_view.filter_posts_paged(2)).to eq([p3, p5])\n        expect(topic_view.filter_posts_paged(3)).to eq([])\n        expect(topic_view.filter_posts_paged(100)).to eq([])\n      end\n    end\n\n    describe \"#filter_posts_by_post_number\" do\n      def create_topic_view(post_number)\n        TopicView.new(topic.id, evil_trout, filter_post_number: post_number, asc: asc)\n      end\n\n      describe \"ascending\" do\n        let(:asc) { true }\n\n        it \"should return the right posts\" do\n          topic_view = create_topic_view(p3.post_number)\n\n          expect(topic_view.posts).to eq([p5])\n\n          topic_view = create_topic_view(p6.post_number)\n          expect(topic_view.posts).to eq([])\n        end\n      end\n\n      describe \"descending\" do\n        let(:asc) { false }\n\n        it \"should return the right posts\" do\n          topic_view = create_topic_view(p7.post_number)\n\n          expect(topic_view.posts).to eq([p5, p3, p2])\n\n          topic_view = create_topic_view(p2.post_number)\n\n          expect(topic_view.posts).to eq([p1])\n        end\n      end\n    end\n\n    describe \"filter_posts_near\" do\n      def topic_view_near(post, show_deleted = false)\n        TopicView.new(\n          topic.id,\n          evil_trout,\n          post_number: post.post_number,\n          show_deleted: show_deleted,\n        )\n      end\n\n      it \"snaps to the lower boundary\" do\n        near_view = topic_view_near(p1)\n        expect(near_view.desired_post).to eq(p1)\n        expect(near_view.posts).to eq([p1, p2, p3])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"snaps to the upper boundary\" do\n        near_view = topic_view_near(p5)\n        expect(near_view.desired_post).to eq(p5)\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"returns the posts in the middle\" do\n        near_view = topic_view_near(p2)\n        expect(near_view.desired_post).to eq(p2)\n        expect(near_view.posts).to eq([p1, p2, p3])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      describe \"when post_number is too large\" do\n        it \"snaps to the lower boundary\" do\n          near_view = TopicView.new(topic.id, evil_trout, post_number: 99_999_999)\n\n          expect(near_view.desired_post).to eq(p2)\n          expect(near_view.posts).to eq([p2, p3, p5])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n      end\n\n      it \"gaps deleted posts to an admin\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p3)\n        expect(near_view.desired_post).to eq(p3)\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n        expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n      end\n\n      it \"returns deleted posts to an admin with show_deleted\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p3, true)\n        expect(near_view.desired_post).to eq(p3)\n        expect(near_view.posts).to eq([p2, p3, p4])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"gaps deleted posts by nuked users to an admin\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p5)\n        expect(near_view.desired_post).to eq(p5)\n        # note: both p4 and p6 get skipped\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n        expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n      end\n\n      it \"returns deleted posts by nuked users to an admin with show_deleted\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p5, true)\n        expect(near_view.desired_post).to eq(p5)\n        expect(near_view.posts).to eq([p4, p5, p6])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      context \"when 'posts per page' exceeds the number of posts\" do\n        before { TopicView.stubs(:chunk_size).returns(100) }\n\n        it \"returns all the posts\" do\n          near_view = topic_view_near(p5)\n          expect(near_view.posts).to eq([p1, p2, p3, p5])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n\n        it \"gaps deleted posts to admins\" do\n          evil_trout.admin = true\n          near_view = topic_view_near(p5)\n          expect(near_view.posts).to eq([p1, p2, p3, p5])\n          expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n          expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n        end\n\n        it \"returns deleted posts to admins\" do\n          evil_trout.admin = true\n          near_view = topic_view_near(p5, true)\n          expect(near_view.posts).to eq([p1, p2, p3, p4, p5, p6, p7])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n      end\n    end\n  end\n\n  describe \"page_title\" do\n    fab!(:tag1) { Fabricate(:tag, staff_topic_count: 0, public_topic_count: 0) }\n    fab!(:tag2) { Fabricate(:tag, staff_topic_count: 2, public_topic_count: 2) }\n    fab!(:op_post) { Fabricate(:post, topic: topic) }\n    fab!(:post1) { Fabricate(:post, topic: topic) }\n    fab!(:whisper) { Fabricate(:post, topic: topic, post_type: Post.types[:whisper]) }\n\n    subject { TopicView.new(topic.id, evil_trout).page_title }\n\n    context \"when a post number is specified\" do\n      context \"with admins\" do\n        it \"see post number and username for all posts\" do\n          title = TopicView.new(topic.id, admin, post_number: 0).page_title\n          expect(title).to eq(topic.title)\n          title = TopicView.new(topic.id, admin, post_number: 1).page_title\n          expect(title).to eq(topic.title)\n\n          title = TopicView.new(topic.id, admin, post_number: 2).page_title\n          expect(title).to eq(\"#{topic.title} - #2 by #{post1.user.username}\")\n          title = TopicView.new(topic.id, admin, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3 by #{whisper.user.username}\")\n        end\n      end\n\n      context \"with regular users\" do\n        it \"see post number and username for regular posts\" do\n          title = TopicView.new(topic.id, evil_trout, post_number: 0).page_title\n          expect(title).to eq(topic.title)\n          title = TopicView.new(topic.id, evil_trout, post_number: 1).page_title\n          expect(title).to eq(topic.title)\n\n          title = TopicView.new(topic.id, evil_trout, post_number: 2).page_title\n          expect(title).to eq(\"#{topic.title} - #2 by #{post1.user.username}\")\n        end\n\n        it \"see only post number for whisper posts\" do\n          title = TopicView.new(topic.id, evil_trout, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3\")\n          post2 = Fabricate(:post, topic: topic)\n          topic.reload\n          title = TopicView.new(topic.id, evil_trout, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3\")\n          title = TopicView.new(topic.id, evil_trout, post_number: 4).page_title\n          expect(title).to eq(\"#{topic.title} - #4 by #{post2.user.username}\")\n        end\n      end\n    end\n\n    context \"with uncategorized topic\" do\n      context \"when topic_page_title_includes_category is false\" do\n        before { SiteSetting.topic_page_title_includes_category = false }\n        it { is_expected.to eq(topic.title) }\n      end\n\n      context \"when topic_page_title_includes_category is true\" do\n        before { SiteSetting.topic_page_title_includes_category = true }\n        it { is_expected.to eq(topic.title) }\n\n        context \"with tagged topic\" do\n          before { topic.tags << [tag1, tag2] }\n\n          context \"with tagging enabled\" do\n            before { SiteSetting.tagging_enabled = true }\n\n            it { is_expected.to start_with(topic.title) }\n            it { is_expected.not_to include(tag1.name) }\n            it { is_expected.to end_with(tag2.name) } # tag2 has higher topic count\n          end\n\n          context \"with tagging disabled\" do\n            before { SiteSetting.tagging_enabled = false }\n\n            it { is_expected.to start_with(topic.title) }\n            it { is_expected.not_to include(tag1.name) }\n            it { is_expected.not_to include(tag2.name) }\n          end\n        end\n      end\n    end\n\n    context \"with categorized topic\" do\n      let(:category) { Fabricate(:category) }\n\n      before { topic.update(category_id: category.id) }\n\n      context \"when topic_page_title_includes_category is false\" do\n        before { SiteSetting.topic_page_title_includes_category = false }\n        it { is_expected.to eq(topic.title) }\n      end\n\n      context \"when topic_page_title_includes_category is true\" do\n        before { SiteSetting.topic_page_title_includes_category = true }\n        it { is_expected.to start_with(topic.title) }\n        it { is_expected.to end_with(category.name) }\n\n        context \"with tagged topic\" do\n          before do\n            SiteSetting.tagging_enabled = true\n            topic.tags << [tag1, tag2]\n          end\n\n          it { is_expected.to start_with(topic.title) }\n          it { is_expected.to end_with(category.name) }\n          it { is_expected.not_to include(tag1.name) }\n          it { is_expected.not_to include(tag2.name) }\n        end\n      end\n    end\n  end\n\n  describe \"#filtered_post_stream\" do\n    let!(:post) { Fabricate(:post, topic: topic, user: first_poster, created_at: 18.hours.ago) }\n    let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout, created_at: 6.hours.ago) }\n    let!(:post3) { Fabricate(:post, topic: topic, user: first_poster) }\n\n    it \"should return the right columns\" do\n      expect(topic_view.filtered_post_stream).to eq([[post.id, 1], [post2.id, 0], [post3.id, 0]])\n    end\n\n    describe \"for mega topics\" do\n      it \"should return the right columns\" do\n        stub_const(TopicView, \"MEGA_TOPIC_POSTS_COUNT\", 2) do\n          expect(topic_view.filtered_post_stream).to eq([post.id, post2.id, post3.id])\n        end\n      end\n    end\n  end\n\n  describe \"#filtered_post_id\" do\n    it \"should return the right id\" do\n      post = Fabricate(:post, topic: topic)\n\n      expect(topic_view.filtered_post_id(nil)).to eq(nil)\n      expect(topic_view.filtered_post_id(post.post_number)).to eq(post.id)\n    end\n  end\n\n  describe \"#last_post_id\" do\n    let!(:p3) { Fabricate(:post, topic: topic) }\n    let!(:p2) { Fabricate(:post, topic: topic) }\n    let!(:p1) { Fabricate(:post, topic: topic) }\n\n    before { [p1, p2, p3].each_with_index { |post, index| post.update!(sort_order: index + 1) } }\n\n    it \"should return the right id\" do\n      expect(topic_view.last_post_id).to eq(p3.id)\n    end\n  end\n\n  describe \"#read_time\" do\n    let!(:post) { Fabricate(:post, topic: topic) }\n\n    before do\n      PostCreator.create!(\n        Discourse.system_user,\n        topic_id: topic.id,\n        raw: \"![image|100x100](upload://upload.png)\",\n      )\n      topic_view.topic.reload\n    end\n\n    it \"should return the right read time\" do\n      SiteSetting.read_time_word_count = 500\n      expect(topic_view.read_time).to eq(1)\n\n      SiteSetting.read_time_word_count = 0\n      expect(topic_view.read_time).to eq(nil)\n    end\n  end\n\n  describe \"#image_url\" do\n    fab!(:op_upload) { Fabricate(:image_upload) }\n    fab!(:post3_upload) { Fabricate(:image_upload) }\n\n    fab!(:post1) { Fabricate(:post, topic: topic) }\n    fab!(:post2) { Fabricate(:post, topic: topic) }\n    fab!(:post3) do\n      Fabricate(:post, topic: topic)\n        .tap { |p| p.update_column(:image_upload_id, post3_upload.id) }\n        .reload\n    end\n\n    def topic_view_for_post(post_number)\n      TopicView.new(topic.id, evil_trout, post_number: post_number)\n    end\n\n    context \"when op has an image\" do\n      before do\n        topic.update_column(:image_upload_id, op_upload.id)\n        post1.update_column(:image_upload_id, op_upload.id)\n      end\n\n      it \"uses the topic image for op and posts image when they have one\" do\n        expect(topic_view_for_post(1).image_url).to end_with(op_upload.url)\n        expect(topic_view_for_post(2).image_url).to eq(nil)\n        expect(topic_view_for_post(3).image_url).to end_with(post3_upload.url)\n      end\n    end\n\n    context \"when op has no image\" do\n      it \"returns nil when posts have no image\" do\n        expect(topic_view_for_post(1).image_url).to eq(nil)\n        expect(topic_view_for_post(2).image_url).to eq(nil)\n        expect(topic_view_for_post(3).image_url).to end_with(post3_upload.url)\n      end\n    end\n  end\n\n  describe \"#show_read_indicator?\" do\n    let(:topic) { Fabricate(:topic) }\n    let(:pm_topic) { Fabricate(:private_message_topic) }\n\n    it \"shows read indicator for private messages\" do\n      group = Fabricate(:group, users: [admin], publish_read_state: true)\n      pm_topic.topic_allowed_groups = [Fabricate.build(:topic_allowed_group, group: group)]\n\n      topic_view = TopicView.new(pm_topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_truthy\n    end\n\n    it \"does not show read indicator if groups do not have read indicator enabled\" do\n      topic_view = TopicView.new(pm_topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_falsey\n    end\n\n    it \"does not show read indicator for topics with allowed groups\" do\n      group = Fabricate(:group, users: [admin], publish_read_state: true)\n      topic.topic_allowed_groups = [Fabricate.build(:topic_allowed_group, group: group)]\n\n      topic_view = TopicView.new(topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_falsey\n    end\n  end\n\n  describe \"#reviewable_counts\" do\n    it \"exclude posts queued because the category needs approval\" do\n      category = Fabricate.build(:category, user: admin)\n      category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n      category.save!\n      manager =\n        NewPostManager.new(\n          user,\n          raw: \"to the handler I say enqueue me!\",\n          title: \"this is the title of the queued post\",\n          category: category.id,\n        )\n      result = manager.perform\n      reviewable = result.reviewable\n      reviewable.perform(admin, :approve_post)\n\n      topic_view = TopicView.new(reviewable.topic, admin)\n\n      expect(topic_view.reviewable_counts).to be_empty\n    end\n\n    it \"include posts queued for other reasons\" do\n      Fabricate(:watched_word, word: \"darn\", action: WatchedWord.actions[:require_approval])\n      manager =\n        NewPostManager.new(\n          user,\n          raw: \"this is darn new post content\",\n          title: \"this is the title of the queued post\",\n        )\n      result = manager.perform\n      reviewable = result.reviewable\n      reviewable.perform(admin, :approve_post)\n\n      topic_view = TopicView.new(reviewable.topic, admin)\n\n      expect(topic_view.reviewable_counts.keys).to contain_exactly(reviewable.target_id)\n    end\n  end\n\n  describe \".apply_custom_default_scope\" do\n    fab!(:post) { Fabricate(:post, topic: topic, created_at: 2.hours.ago) }\n    fab!(:post_2) { Fabricate(:post, topic: topic, created_at: 1.hour.ago) }\n\n    after { TopicView.reset_custom_default_scopes }\n\n    it \"allows a custom default scope to be configured\" do\n      topic_view = TopicView.new(topic, admin)\n\n      expect(topic_view.filtered_post_ids).to eq([post.id, post_2.id])\n\n      TopicView.apply_custom_default_scope do |scope, _|\n        scope.unscope(:order).order(\"posts.created_at DESC\")\n      end\n\n      topic_view = TopicView.new(topic, admin)\n\n      expect(topic_view.filtered_post_ids).to eq([post_2.id, post.id])\n    end\n  end\n\n  describe \"#queued_posts_enabled?\" do\n    subject(:topic_view) { described_class.new(topic, user) }\n\n    let(:topic) { Fabricate(:topic) }\n    let(:user) { Fabricate(:user) }\n    let(:category) { topic.category }\n\n    before { NewPostManager.stubs(:queue_enabled?).returns(queue_enabled) }\n\n    context \"when queue is enabled globally\" do\n      let(:queue_enabled) { true }\n\n      it { expect(topic_view.queued_posts_enabled?).to be(true) }\n    end\n\n    context \"when queue is not enabled globally\" do\n      let(:queue_enabled) { false }\n\n      context \"when category is moderated\" do\n        before { category.custom_fields[Category::REQUIRE_REPLY_APPROVAL] = true }\n\n        it { expect(topic_view.queued_posts_enabled?).to be(true) }\n      end\n\n      context \"when category is not moderated\" do\n        it { expect(topic_view.queued_posts_enabled?).to be(nil) }\n      end\n    end\n  end\n\n  describe \"#tags\" do\n    subject(:topic_view_tags) { topic_view.tags }\n\n    let(:topic_view) { described_class.new(topic, user) }\n    let(:topic) { Fabricate.build(:topic, tags: tags) }\n    let(:tags) { Fabricate.build_times(2, :tag) }\n    let(:user) { Fabricate(:user) }\n\n    it \"returns the tags names\" do\n      expect(topic_view_tags).to match tags.map(&:name)\n    end\n  end\nend\n", "# coding: utf-8\n# frozen_string_literal: true\n\nRSpec.describe TopicsController do\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:dest_topic) { Fabricate(:topic) }\n  fab!(:invisible_topic) { Fabricate(:topic, visible: false) }\n\n  fab!(:pm) { Fabricate(:private_message_topic) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:post_author1) { Fabricate(:user) }\n  fab!(:post_author2) { Fabricate(:user) }\n  fab!(:post_author3) { Fabricate(:user) }\n  fab!(:post_author4) { Fabricate(:user) }\n  fab!(:post_author5) { Fabricate(:user) }\n  fab!(:post_author6) { Fabricate(:user) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:trust_level_0) { Fabricate(:trust_level_0) }\n  fab!(:trust_level_1) { Fabricate(:trust_level_1) }\n  fab!(:trust_level_4) { Fabricate(:trust_level_4) }\n\n  fab!(:category) { Fabricate(:category) }\n  fab!(:tracked_category) { Fabricate(:category) }\n  fab!(:shared_drafts_category) { Fabricate(:category) }\n  fab!(:staff_category) do\n    Fabricate(:category).tap do |staff_category|\n      staff_category.set_permissions(staff: :full)\n      staff_category.save!\n    end\n  end\n\n  fab!(:group_user) { Fabricate(:group_user) }\n\n  fab!(:tag) { Fabricate(:tag) }\n\n  before do\n    [\n      user,\n      user_2,\n      post_author1,\n      post_author2,\n      post_author3,\n      post_author4,\n      post_author5,\n      post_author6,\n      trust_level_0,\n      trust_level_1,\n      trust_level_4,\n    ].each { |u| Group.user_trust_level_change!(u.id, u.trust_level) }\n  end\n\n  describe \"#wordpress\" do\n    before { sign_in(moderator) }\n\n    fab!(:p1) { Fabricate(:post, user: moderator) }\n    fab!(:p2) { Fabricate(:post, topic: p1.topic, user: moderator) }\n\n    it \"returns the JSON in the format our wordpress plugin needs\" do\n      SiteSetting.external_system_avatars_enabled = false\n\n      get \"/t/#{p1.topic.id}/wordpress.json\", params: { best: 3 }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      # The JSON has the data the wordpress plugin needs\n      expect(json[\"id\"]).to eq(p1.topic.id)\n      expect(json[\"posts_count\"]).to eq(2)\n      expect(json[\"filtered_posts_count\"]).to eq(2)\n\n      # Posts\n      expect(json[\"posts\"].size).to eq(1)\n      post = json[\"posts\"][0]\n      expect(post[\"id\"]).to eq(p2.id)\n      expect(post[\"username\"]).to eq(moderator.username)\n      expect(post[\"avatar_template\"]).to eq(\n        \"#{Discourse.base_url_no_prefix}#{moderator.avatar_template}\",\n      )\n      expect(post[\"name\"]).to eq(moderator.name)\n      expect(post[\"created_at\"]).to be_present\n      expect(post[\"cooked\"]).to eq(p2.cooked)\n\n      # Participants\n      expect(json[\"participants\"].size).to eq(1)\n      participant = json[\"participants\"][0]\n      expect(participant[\"id\"]).to eq(moderator.id)\n      expect(participant[\"username\"]).to eq(moderator.username)\n      expect(participant[\"avatar_template\"]).to eq(\n        \"#{Discourse.base_url_no_prefix}#{moderator.avatar_template}\",\n      )\n    end\n  end\n\n  describe \"#move_posts\" do\n    before do\n      SiteSetting.min_topic_title_length = 2\n      SiteSetting.tagging_enabled = true\n    end\n\n    it \"needs you to be logged in\" do\n      post \"/t/111/move-posts.json\", params: { title: \"blah\", post_ids: [1, 2, 3] }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"moving to a new topic\" do\n      fab!(:p1) { Fabricate(:post, user: user, post_number: 1) }\n      let(:p2) { Fabricate(:post, user: user, post_number: 2, topic: p1.topic) }\n      let(:topic) { p1.topic }\n\n      it \"raises an error without post_ids\" do\n        sign_in(moderator)\n        post \"/t/#{topic.id}/move-posts.json\", params: { title: \"blah\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to move the posts\" do\n        sign_in(user)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when the OP is not a regular post\" do\n        sign_in(moderator)\n        p2 =\n          Fabricate(\n            :post,\n            user: post_author1,\n            topic: topic,\n            post_number: 2,\n            post_type: Post.types[:whisper],\n          )\n        p3 = Fabricate(:post, user: post_author2, topic: topic, post_number: 3)\n\n        post \"/t/#{topic.id}/move-posts.json\", params: { title: \"blah\", post_ids: [p2.id, p3.id] }\n        expect(response.status).to eq(422)\n\n        result = response.parsed_body\n\n        expect(result[\"errors\"]).to be_present\n      end\n\n      context \"with success\" do\n        before { sign_in(admin) }\n\n        it \"returns success\" do\n          expect do\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   title: \"Logan is a good movie\",\n                   post_ids: [p2.id],\n                   category_id: category.id,\n                   tags: %w[foo bar],\n                 }\n          end.to change { Topic.count }.by(1).and change { Tag.count }.by(2)\n\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n\n          expect(result[\"success\"]).to eq(true)\n\n          new_topic = Topic.last\n          expect(result[\"url\"]).to eq(new_topic.relative_url)\n          expect(new_topic.excerpt).to eq(p2.excerpt_for_topic)\n          expect(Tag.all.pluck(:name)).to include(\"foo\", \"bar\")\n        end\n\n        describe \"when topic has been deleted\" do\n          it \"should still be able to move posts\" do\n            PostDestroyer.new(admin, topic.first_post).destroy\n\n            expect(topic.reload.deleted_at).to_not be_nil\n\n            expect do\n              post \"/t/#{topic.id}/move-posts.json\",\n                   params: {\n                     title: \"Logan is a good movie\",\n                     post_ids: [p2.id],\n                     category_id: category.id,\n                   }\n            end.to change { Topic.count }.by(1)\n\n            expect(response.status).to eq(200)\n\n            result = response.parsed_body\n\n            expect(result[\"success\"]).to eq(true)\n            expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          sign_in(moderator)\n          post \"/t/#{topic.id}/move-posts.json\", params: { post_ids: [p2.id] }\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n\n      describe \"moving replied posts\" do\n        context \"with success\" do\n          it \"moves the child posts too\" do\n            sign_in(moderator)\n            p1 = Fabricate(:post, topic: topic, user: moderator)\n            p2 =\n              Fabricate(:post, topic: topic, user: moderator, reply_to_post_number: p1.post_number)\n            PostReply.create(post_id: p1.id, reply_post_id: p2.id)\n\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   title: \"new topic title\",\n                   post_ids: [p1.id],\n                   reply_post_ids: [p1.id],\n                 }\n            expect(response.status).to eq(200)\n\n            p1.reload\n            p2.reload\n\n            new_topic_id = response.parsed_body[\"url\"].split(\"/\").last.to_i\n            new_topic = Topic.find(new_topic_id)\n            expect(p1.topic.id).to eq(new_topic.id)\n            expect(p2.topic.id).to eq(new_topic.id)\n            expect(p2.reply_to_post_number).to eq(p1.post_number)\n          end\n        end\n      end\n    end\n\n    describe \"moving to a new topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: group_user.user, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: group_user.user, post_number: 2, topic: topic) }\n      let!(:user) { group_user.user }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        expect do\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 title: \"Logan is a good movie\",\n                 post_ids: [p2.id],\n                 category_id: category.id,\n               }\n        end.to change { Topic.count }.by(1)\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to eq(Topic.last.relative_url)\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"Logan is a good movie\",\n               post_ids: [p2.id],\n               category_id: staff_category.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n             }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"moving to an existing topic\" do\n      before { sign_in(moderator) }\n\n      fab!(:p1) { Fabricate(:post, user: moderator) }\n      fab!(:topic) { p1.topic }\n      fab!(:p2) { Fabricate(:post, user: moderator, topic: topic) }\n\n      context \"with success\" do\n        it \"returns success\" do\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 destination_topic_id: dest_topic.id,\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n\n        it \"triggers an event on merge\" do\n          begin\n            called = false\n\n            assert = ->(original_topic, destination_topic) {\n              called = true\n              expect(original_topic).to eq(topic)\n              expect(destination_topic).to eq(dest_topic)\n            }\n\n            DiscourseEvent.on(:topic_merged, &assert)\n\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   post_ids: [p2.id],\n                   destination_topic_id: dest_topic.id,\n                 }\n\n            expect(called).to eq(true)\n            expect(response.status).to eq(200)\n          ensure\n            DiscourseEvent.off(:topic_merged, &assert)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        fab!(:p2) { Fabricate(:post, user: moderator) }\n        it \"returns JSON with a false success\" do\n          post \"/t/#{topic.id}/move-posts.json\", params: { post_ids: [p2.id] }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n\n        it \"returns plugin validation error\" do\n          # stub here is to simulate validation added by plugin which would be triggered when post is moved\n          PostCreator.any_instance.stubs(:skip_validations?).returns(false)\n\n          p1.update_columns(raw: \"i\", cooked: \"\")\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 post_ids: [p1.id],\n                 destination_topic_id: dest_topic.id,\n               }\n\n          expect(response.status).to eq(422)\n          result = response.parsed_body\n          expect(result[\"errors\"]).to eq(\n            [\n              \"Body is too short (minimum is 5 characters) and Body seems unclear, is it a complete sentence?\",\n            ],\n          )\n        end\n      end\n    end\n\n    describe \"moving to an existing topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: group_user.user, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: group_user.user, post_number: 2, topic: topic) }\n\n      let!(:user) { group_user.user }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p2.id],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to be_present\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        dest_topic.update!(category: staff_category)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p2.id],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p1.post_number, p2.post_number],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"moving to a new message\" do\n      fab!(:message) { pm }\n      fab!(:p1) { Fabricate(:post, user: user, post_number: 1, topic: message) }\n      fab!(:p2) { Fabricate(:post, user: user, post_number: 2, topic: message) }\n\n      it \"raises an error without post_ids\" do\n        sign_in(moderator)\n        post \"/t/#{message.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               archetype: \"private_message\",\n             }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to move the posts\" do\n        sign_in(trust_level_4)\n\n        post \"/t/#{message.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n               archetype: \"private_message\",\n             }\n\n        expect(response.status).to eq(403)\n        result = response.parsed_body\n        expect(result[\"errors\"]).to be_present\n      end\n\n      context \"with success\" do\n        before { sign_in(admin) }\n\n        it \"returns success\" do\n          SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n\n          expect do\n            post \"/t/#{message.id}/move-posts.json\",\n                 params: {\n                   title: \"Logan is a good movie\",\n                   post_ids: [p2.id],\n                   archetype: \"private_message\",\n                   tags: %w[foo bar],\n                 }\n          end.to change { Topic.count }.by(1).and change { Tag.count }.by(2)\n\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          expect(Tag.all.pluck(:name)).to include(\"foo\", \"bar\")\n        end\n\n        describe \"when message has been deleted\" do\n          it \"should still be able to move posts\" do\n            PostDestroyer.new(admin, message.first_post).destroy\n\n            expect(message.reload.deleted_at).to_not be_nil\n\n            expect do\n              post \"/t/#{message.id}/move-posts.json\",\n                   params: {\n                     title: \"Logan is a good movie\",\n                     post_ids: [p2.id],\n                     archetype: \"private_message\",\n                   }\n            end.to change { Topic.count }.by(1)\n\n            expect(response.status).to eq(200)\n\n            result = response.parsed_body\n\n            expect(result[\"success\"]).to eq(true)\n            expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          sign_in(moderator)\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 archetype: \"private_message\",\n               }\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n    end\n\n    describe \"moving to an existing message\" do\n      before { sign_in(admin) }\n\n      fab!(:evil_trout) { Fabricate(:evil_trout) }\n      fab!(:message) { pm }\n      fab!(:p2) { Fabricate(:post, user: evil_trout, post_number: 2, topic: message) }\n\n      fab!(:dest_message) do\n        Fabricate(\n          :private_message_topic,\n          user: trust_level_4,\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: evil_trout)],\n        )\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 destination_topic_id: dest_message.id,\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n    end\n  end\n\n  describe \"#merge_topic\" do\n    it \"needs you to be logged in\" do\n      post \"/t/111/merge-topic.json\", params: { destination_topic_id: 345 }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"merging into another topic\" do\n      fab!(:p1) { Fabricate(:post, user: user) }\n      fab!(:topic) { p1.topic }\n\n      it \"raises an error without destination_topic_id\" do\n        sign_in(moderator)\n        post \"/t/#{topic.id}/merge-topic.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to merge\" do\n        sign_in(user)\n        post \"/t/111/merge-topic.json\", params: { destination_topic_id: 345 }\n        expect(response).to be_forbidden\n      end\n\n      context \"when moving all the posts to the destination topic\" do\n        it \"returns success\" do\n          sign_in(moderator)\n          post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n\n    describe \"merging into another topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: post_author1, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: post_author2, post_number: 2, topic: topic) }\n\n      before do\n        sign_in(group_user.user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to be_present\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        dest_topic.update!(category: staff_category)\n\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"merging into another message\" do\n      fab!(:message) { Fabricate(:private_message_topic, user: user) }\n      fab!(:p1) { Fabricate(:post, topic: message, user: trust_level_4) }\n      fab!(:p2) do\n        Fabricate(:post, topic: message, reply_to_post_number: p1.post_number, user: user)\n      end\n\n      fab!(:dest_message) do\n        Fabricate(\n          :private_message_topic,\n          user: trust_level_4,\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: moderator)],\n        )\n      end\n\n      it \"raises an error without destination_topic_id\" do\n        sign_in(moderator)\n        post \"/t/#{message.id}/merge-topic.json\", params: { archetype: \"private_message\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to merge\" do\n        sign_in(trust_level_4)\n        post \"/t/#{message.id}/merge-topic.json\",\n             params: {\n               destination_topic_id: 345,\n               archetype: \"private_message\",\n             }\n        expect(response).to be_forbidden\n      end\n\n      context \"when moving all the posts to the destination message\" do\n        it \"returns success\" do\n          sign_in(moderator)\n          post \"/t/#{message.id}/merge-topic.json\",\n               params: {\n                 destination_topic_id: dest_message.id,\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#change_post_owners\" do\n    it \"needs you to be logged in\" do\n      post \"/t/111/change-owner.json\", params: { username: \"user_a\", post_ids: [1, 2, 3] }\n      expect(response).to be_forbidden\n    end\n\n    describe \"forbidden to trust_level_4s\" do\n      before { sign_in(trust_level_4) }\n\n      it \"correctly denies\" do\n        post \"/t/111/change-owner.json\",\n             params: {\n               topic_id: 111,\n               username: \"user_a\",\n               post_ids: [1, 2, 3],\n             }\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"changing ownership\" do\n      fab!(:user_a) { Fabricate(:user) }\n      fab!(:p1) { Fabricate(:post, user: post_author1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: post_author2, topic: topic) }\n\n      describe \"moderator signed in\" do\n        let!(:editor) { sign_in(moderator) }\n\n        it \"returns 200 when moderators_change_post_ownership is true\" do\n          SiteSetting.moderators_change_post_ownership = true\n\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          expect(response.status).to eq(200)\n        end\n\n        it \"returns 403 when moderators_change_post_ownership is false\" do\n          SiteSetting.moderators_change_post_ownership = false\n\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          expect(response.status).to eq(403)\n        end\n      end\n      describe \"admin signed in\" do\n        let!(:editor) { sign_in(admin) }\n\n        it \"raises an error with a parameter missing\" do\n          [{ post_ids: [1, 2, 3] }, { username: \"user_a\" }].each do |params|\n            post \"/t/111/change-owner.json\", params: params\n            expect(response.status).to eq(400)\n          end\n        end\n\n        it \"changes the topic and posts ownership\" do\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          topic.reload\n          p1.reload\n          expect(response.status).to eq(200)\n          expect(topic.user.username).to eq(user_a.username)\n          expect(p1.user.username).to eq(user_a.username)\n        end\n\n        it \"changes multiple posts\" do\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id, p2.id],\n               }\n\n          expect(response.status).to eq(200)\n\n          p1.reload\n          p2.reload\n\n          expect(p1.user).to_not eq(nil)\n          expect(p1.reload.user).to eq(p2.reload.user)\n        end\n\n        it \"works with deleted users\" do\n          deleted_user = user\n          t2 = Fabricate(:topic, user: deleted_user)\n          p3 = Fabricate(:post, topic: t2, user: deleted_user)\n\n          UserDestroyer.new(editor).destroy(\n            deleted_user,\n            delete_posts: true,\n            context: \"test\",\n            delete_as_spammer: true,\n          )\n\n          post \"/t/#{t2.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p3.id],\n               }\n\n          expect(response.status).to eq(200)\n          t2.reload\n          p3.reload\n          expect(t2.deleted_at).to be_nil\n          expect(p3.user).to eq(user_a)\n        end\n\n        it \"removes likes by new owner\" do\n          now = Time.zone.now\n          freeze_time(now - 1.day)\n          PostActionCreator.like(user_a, p1)\n          p1.reload\n          freeze_time(now)\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          topic.reload\n          p1.reload\n          expect(response.status).to eq(200)\n          expect(topic.user.username).to eq(user_a.username)\n          expect(p1.user.username).to eq(user_a.username)\n          expect(p1.like_count).to eq(0)\n        end\n      end\n    end\n  end\n\n  describe \"#change_timestamps\" do\n    let!(:params) { { timestamp: Time.zone.now } }\n\n    it \"needs you to be logged in\" do\n      put \"/t/1/change-timestamp.json\", params: params\n      expect(response.status).to eq(403)\n    end\n\n    describe \"forbidden to trust_level_4\" do\n      before { sign_in(trust_level_4) }\n\n      it \"correctly denies\" do\n        put \"/t/1/change-timestamp.json\", params: params\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"changing timestamps\" do\n      before do\n        freeze_time\n        sign_in(moderator)\n      end\n\n      let!(:old_timestamp) { Time.zone.now }\n      let!(:new_timestamp) { old_timestamp - 1.day }\n      let!(:topic) { Fabricate(:topic, created_at: old_timestamp) }\n      let!(:p1) { Fabricate(:post, user: post_author1, topic: topic, created_at: old_timestamp) }\n      let!(:p2) do\n        Fabricate(:post, user: post_author2, topic: topic, created_at: old_timestamp + 1.day)\n      end\n\n      it \"should update the timestamps of selected posts\" do\n        # try to see if we fail with invalid first\n        put \"/t/1/change-timestamp.json\"\n        expect(response.status).to eq(400)\n\n        put \"/t/#{topic.id}/change-timestamp.json\", params: { timestamp: new_timestamp.to_f }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.created_at).to eq_time(new_timestamp)\n        expect(p1.reload.created_at).to eq_time(new_timestamp)\n        expect(p2.reload.created_at).to eq_time(old_timestamp)\n      end\n\n      it \"should create a staff log entry\" do\n        put \"/t/#{topic.id}/change-timestamp.json\", params: { timestamp: new_timestamp.to_f }\n\n        log = UserHistory.last\n        expect(log.acting_user_id).to eq(moderator.id)\n        expect(log.topic_id).to eq(topic.id)\n        expect(log.new_value).to eq(new_timestamp.utc.to_s)\n        expect(log.previous_value).to eq(old_timestamp.utc.to_s)\n      end\n    end\n  end\n\n  describe \"#clear_pin\" do\n    it \"needs you to be logged in\" do\n      put \"/t/1/clear-pin.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"fails when the user can't see the topic\" do\n        put \"/t/#{pm.id}/clear-pin.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"when the user can see the topic\" do\n        it \"succeeds\" do\n          expect do put \"/t/#{topic.id}/clear-pin.json\" end.to change {\n            TopicUser.where(topic_id: topic.id, user_id: user.id).count\n          }.by(1)\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe \"#status\" do\n    it \"needs you to be logged in\" do\n      put \"/t/1/status.json\", params: { status: \"visible\", enabled: true }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in as a moderator\" do\n      before { sign_in(moderator) }\n\n      it \"raises an exception if you can't change it\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"true\" }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the status parameter\" do\n        put \"/t/#{topic.id}/status.json\", params: { enabled: true }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires the enabled parameter\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error with a status not in the allowlist\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"title\", enabled: \"true\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"should update the status of the topic correctly\" do\n        closed_user_topic = Fabricate(:topic, user: user, closed: true)\n        Fabricate(:topic_timer, topic: closed_user_topic, status_type: TopicTimer.types[:open])\n\n        put \"/t/#{closed_user_topic.id}/status.json\", params: { status: \"closed\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(closed_user_topic.reload.closed).to eq(false)\n        expect(closed_user_topic.topic_timers).to eq([])\n\n        body = response.parsed_body\n\n        expect(body[\"topic_status_update\"]).to eq(nil)\n      end\n    end\n\n    describe \"when logged in as a group member with reviewable status\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n\n      before do\n        sign_in(group_user.user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"should allow a group moderator to close a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"closed\", enabled: \"true\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.closed).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"closed.enabled\")\n      end\n\n      it \"should allow a group moderator to open a closed topic\" do\n        topic.update!(closed: true)\n\n        expect do\n          put \"/t/#{topic.id}/status.json\", params: { status: \"closed\", enabled: \"false\" }\n        end.to change { topic.reload.posts.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.closed).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"closed.disabled\")\n      end\n\n      it \"should allow a group moderator to archive a topic\" do\n        expect do\n          put \"/t/#{topic.id}/status.json\", params: { status: \"archived\", enabled: \"true\" }\n        end.to change { topic.reload.posts.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.archived).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"archived.enabled\")\n      end\n\n      it \"should allow a group moderator to unarchive an archived topic\" do\n        topic.update!(archived: true)\n\n        put \"/t/#{topic.id}/status.json\", params: { status: \"archived\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.archived).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"archived.disabled\")\n      end\n\n      it \"should allow a group moderator to pin a topic\" do\n        put \"/t/#{topic.id}/status.json\",\n            params: {\n              status: \"pinned\",\n              enabled: \"true\",\n              until: 2.weeks.from_now,\n            }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.pinned_at).to_not eq(nil)\n      end\n\n      it \"should allow a group moderator to unpin a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"pinned\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.pinned_at).to eq(nil)\n      end\n\n      it \"should allow a group moderator to unlist a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.visible).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"visible.disabled\")\n      end\n\n      it \"should allow a group moderator to list an unlisted topic\" do\n        topic.update!(visible: false)\n\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"true\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.visible).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"visible.enabled\")\n      end\n    end\n\n    context \"with API key\" do\n      let(:api_key) { Fabricate(:api_key, user: moderator, created_by: moderator) }\n\n      context \"when key scope has restricted params\" do\n        before do\n          ApiKeyScope.create(\n            resource: \"topics\",\n            action: \"update\",\n            api_key_id: api_key.id,\n            allowed_parameters: {\n              \"category_id\" => [\"#{topic.category_id}\"],\n            },\n          )\n        end\n\n        it \"fails to update topic status in an unpermitted category\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n                category_id: tracked_category.id,\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(403)\n          expect(response.body).to include(I18n.t(\"invalid_access\"))\n          expect(topic.reload.closed).to eq(false)\n        end\n\n        it \"fails without a category_id\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(403)\n          expect(response.body).to include(I18n.t(\"invalid_access\"))\n          expect(topic.reload.closed).to eq(false)\n        end\n\n        it \"updates topic status in a permitted category\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n                category_id: topic.category_id,\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.closed).to eq(true)\n        end\n      end\n\n      context \"when key scope has no param restrictions\" do\n        before do\n          ApiKeyScope.create(\n            resource: \"topics\",\n            action: \"update\",\n            api_key_id: api_key.id,\n            allowed_parameters: {\n            },\n          )\n        end\n\n        it \"updates topic status\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.closed).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"#destroy_timings\" do\n    it \"needs you to be logged in\" do\n      delete \"/t/1/timings.json\"\n      expect(response.status).to eq(403)\n    end\n\n    def topic_user_post_timings_count(user, topic)\n      [TopicUser, PostTiming].map { |klass| klass.where(user: user, topic: topic).count }\n    end\n\n    context \"for last post only\" do\n      it \"should allow you to retain topic timing but remove last post only\" do\n        freeze_time\n\n        post1 = create_post\n        user = post1.user\n\n        topic = post1.topic\n\n        post2 = create_post(topic_id: topic.id)\n\n        PostTiming.create!(topic: topic, user: user, post_number: 2, msecs: 100)\n\n        user.user_stat.update!(first_unread_at: Time.now + 1.week)\n\n        topic_user = TopicUser.find_by(topic_id: topic.id, user_id: user.id)\n\n        topic_user.update!(last_read_post_number: 2)\n\n        # ensure we have 2 notifications\n        # fake notification on topic but it is read\n        first_notification =\n          Notification.create!(\n            user_id: user.id,\n            topic_id: topic.id,\n            data: \"{}\",\n            read: true,\n            notification_type: 1,\n          )\n\n        freeze_time 1.minute.from_now\n        PostAlerter.post_created(post2)\n\n        second_notification =\n          user.notifications.where(topic_id: topic.id).order(created_at: :desc).first\n        second_notification.update!(read: true)\n\n        sign_in(user)\n\n        delete \"/t/#{topic.id}/timings.json?last=1\"\n\n        expect(PostTiming.where(topic: topic, user: user, post_number: 2).exists?).to eq(false)\n        expect(PostTiming.where(topic: topic, user: user, post_number: 1).exists?).to eq(true)\n\n        expect(TopicUser.where(topic: topic, user: user, last_read_post_number: 1).exists?).to eq(\n          true,\n        )\n\n        user.user_stat.reload\n        expect(user.user_stat.first_unread_at).to eq_time(topic.updated_at)\n\n        first_notification.reload\n        second_notification.reload\n        expect(first_notification.read).to eq(true)\n        expect(second_notification.read).to eq(false)\n\n        PostDestroyer.new(admin, post2).destroy\n\n        delete \"/t/#{topic.id}/timings.json?last=1\"\n\n        expect(PostTiming.where(topic: topic, user: user, post_number: 1).exists?).to eq(false)\n        expect(TopicUser.where(topic: topic, user: user, last_read_post_number: nil).exists?).to eq(\n          true,\n        )\n      end\n    end\n\n    context \"when logged in\" do\n      fab!(:user_topic) { Fabricate(:topic, user: user) }\n      fab!(:user_post) { Fabricate(:post, user: user, topic: user_topic, post_number: 2) }\n\n      before do\n        sign_in(user)\n        TopicUser.create!(topic: user_topic, user: user)\n        PostTiming.create!(topic: user_topic, user: user, post_number: 2, msecs: 1000)\n      end\n\n      it \"deletes the forum topic user and post timings records\" do\n        expect do delete \"/t/#{user_topic.id}/timings.json\" end.to change {\n          topic_user_post_timings_count(user, user_topic)\n        }.from([1, 1]).to([0, 0])\n      end\n    end\n  end\n\n  describe \"#mute/unmute\" do\n    it \"needs you to be logged in\" do\n      put \"/t/99/mute.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"needs you to be logged in\" do\n      put \"/t/99/unmute.json\"\n      expect(response.status).to eq(403)\n    end\n  end\n\n  describe \"#recover\" do\n    it \"won't allow us to recover a topic when we're not logged in\" do\n      put \"/t/1/recover.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      let!(:topic) { Fabricate(:topic, user: user, deleted_at: Time.now, deleted_by: moderator) }\n      let!(:post) do\n        Fabricate(\n          :post,\n          user: user,\n          topic: topic,\n          post_number: 1,\n          deleted_at: Time.now,\n          deleted_by: moderator,\n        )\n      end\n\n      describe \"without access\" do\n        it \"raises an exception when the user doesn't have permission to delete the topic\" do\n          sign_in(user)\n          put \"/t/#{topic.id}/recover.json\"\n          expect(response).to be_forbidden\n        end\n      end\n\n      context \"with permission\" do\n        before { sign_in(moderator) }\n\n        it \"succeeds\" do\n          put \"/t/#{topic.id}/recover.json\"\n          topic.reload\n          post.reload\n          expect(response.status).to eq(200)\n          expect(topic.trashed?).to be_falsey\n          expect(post.trashed?).to be_falsey\n        end\n      end\n    end\n  end\n\n  describe \"#delete\" do\n    it \"won't allow us to delete a topic when we're not logged in\" do\n      delete \"/t/1.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      fab!(:topic) { Fabricate(:topic, user: user, created_at: 48.hours.ago) }\n      fab!(:post) { Fabricate(:post, topic: topic, user: user, post_number: 1) }\n\n      describe \"without access\" do\n        it \"raises an exception when the user doesn't have permission to delete the topic\" do\n          sign_in(user)\n          delete \"/t/#{topic.id}.json\"\n          expect(response.status).to eq(422)\n        end\n      end\n\n      describe \"with permission\" do\n        before { sign_in(moderator) }\n\n        it \"succeeds\" do\n          delete \"/t/#{topic.id}.json\"\n          expect(response.status).to eq(200)\n          topic.reload\n          expect(topic.trashed?).to be_truthy\n        end\n      end\n    end\n\n    describe \"force destroy\" do\n      fab!(:post) { Fabricate(:post, topic: topic, post_number: 1) }\n\n      before do\n        SiteSetting.can_permanently_delete = true\n\n        sign_in(admin)\n      end\n\n      it \"force destroys all deleted small actions in topic too\" do\n        small_action_post = Fabricate(:small_action, topic: topic)\n        PostDestroyer.new(Discourse.system_user, post).destroy\n        PostDestroyer.new(Discourse.system_user, small_action_post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(200)\n\n        expect(Topic.find_by(id: topic.id)).to eq(nil)\n        expect(Post.find_by(id: post.id)).to eq(nil)\n        expect(Post.find_by(id: small_action_post.id)).to eq(nil)\n      end\n\n      it \"does not allow to destroy topic if not all posts were force destroyed\" do\n        other_post = Fabricate(:post, topic: topic, post_number: 2)\n        PostDestroyer.new(Discourse.system_user, post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"does not allow to destroy topic if not all small action posts were deleted\" do\n        small_action_post = Fabricate(:small_action, topic: topic)\n        PostDestroyer.new(Discourse.system_user, small_action_post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe \"#id_for_slug\" do\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    it \"returns JSON for the slug\" do\n      get \"/t/id_for/#{topic.slug}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_id\"]).to eq(topic.id)\n      expect(json[\"url\"]).to eq(topic.url)\n      expect(json[\"slug\"]).to eq(topic.slug)\n    end\n\n    it \"returns invalid access if the user can't see the topic\" do\n      get \"/t/id_for/#{pm.slug}.json\"\n      expect(response).to be_forbidden\n    end\n  end\n\n  describe \"#update\" do\n    it \"won't allow us to update a topic when we're not logged in\" do\n      put \"/t/1.json\", params: { slug: \"xyz\" }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      fab!(:topic) { Fabricate(:topic, user: user) }\n\n      before_all { Fabricate(:post, user: post_author1, topic: topic) }\n\n      before do\n        SiteSetting.editing_grace_period = 0\n        sign_in(user)\n      end\n\n      it \"can not change category to a disallowed category\" do\n        category.set_permissions(staff: :full)\n        category.save!\n\n        put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n        expect(response.status).to eq(403)\n        expect(topic.reload.category_id).not_to eq(category.id)\n      end\n\n      it \"can not move to a category that requires topic approval\" do\n        category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n        category.save!\n\n        put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n        expect(response.status).to eq(403)\n        expect(topic.reload.category_id).not_to eq(category.id)\n      end\n\n      context \"when updating shared drafts\" do\n        fab!(:topic) { Fabricate(:topic, category: shared_drafts_category) }\n        fab!(:shared_draft) do\n          Fabricate(:shared_draft, topic: topic, category: Fabricate(:category))\n        end\n\n        it \"changes destination category\" do\n          put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n          expect(response.status).to eq(403)\n          expect(topic.shared_draft.category_id).not_to eq(category.id)\n        end\n      end\n\n      describe \"without permission\" do\n        it \"raises an exception when the user doesn't have permission to update the topic\" do\n          topic.update!(archived: true)\n          put \"/t/#{topic.slug}/#{topic.id}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"with permission\" do\n        fab!(:post_hook) { Fabricate(:post_web_hook) }\n        fab!(:topic_hook) { Fabricate(:topic_web_hook) }\n\n        it \"succeeds\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"basic_topic\"]).to be_present\n        end\n\n        it \"throws an error if it could not be saved\" do\n          PostRevisor.any_instance.stubs(:should_revise?).returns(false)\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: \"brand new title\" }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"].first).to eq(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_update\"),\n          )\n        end\n\n        it \"can update a topic to an uncategorized topic\" do\n          topic.update!(category: category)\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: \"\" }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.category_id).to eq(SiteSetting.uncategorized_category_id)\n        end\n\n        it \"allows a change of title\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n\n          # emits a topic_edited event but not a post_edited web hook event\n          expect(Jobs::EmitWebHookEvent.jobs.length).to eq(1)\n          job_args = Jobs::EmitWebHookEvent.jobs[0][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"topic_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"title\"]).to eq(\"This is a new title for the topic\")\n        end\n\n        it \"allows update on short non-slug url\" do\n          put \"/t/#{topic.id}.json\", params: { title: \"This is a new title for the topic\" }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n        end\n\n        it \"only allows update on digit ids\" do\n          non_digit_id = \"asdf\"\n          original_title = topic.title\n          put \"/t/#{non_digit_id}.json\", params: { title: \"This is a new title for the topic\" }\n\n          topic.reload\n          expect(topic.title).to eq(original_title)\n          expect(response.status).to eq(404)\n        end\n\n        it \"allows a change of then updating the OP\" do\n          topic.update(user: user)\n          topic.first_post.update(user: user)\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n\n          update_params = { post: { raw: \"edited body\", edit_reason: \"typo\" } }\n          put \"/posts/#{topic.first_post.id}.json\", params: update_params\n\n          # emits a topic_edited event and a post_edited web hook event\n          expect(Jobs::EmitWebHookEvent.jobs.length).to eq(2)\n          job_args = Jobs::EmitWebHookEvent.jobs[0][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"topic_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"title\"]).to eq(\"This is a new title for the topic\")\n\n          job_args = Jobs::EmitWebHookEvent.jobs[1][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"post_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"raw\"]).to eq(\"edited body\")\n        end\n\n        it \"returns errors with invalid titles\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: \"asdf\" }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to match_array(\n            [/Title is too short/, /Title seems unclear/],\n          )\n        end\n\n        it \"returns errors when the rate limit is exceeded\" do\n          EditRateLimiter\n            .any_instance\n            .expects(:performed!)\n            .raises(RateLimiter::LimitExceeded.new(60))\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"returns errors with invalid categories\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: -1 }\n\n          expect(response.status).to eq(422)\n        end\n\n        it \"doesn't call the PostRevisor when there is no changes\" do\n          expect do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: topic.category_id }\n          end.not_to change(PostRevision.all, :count)\n\n          expect(response.status).to eq(200)\n        end\n\n        context \"when using SiteSetting.disable_category_edit_notifications\" do\n          it \"doesn't bump the topic if the setting is enabled\" do\n            SiteSetting.disable_category_edit_notifications = true\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n            end.to change { topic.reload.category_id }.to(category.id)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).to eq_time(last_bumped_at)\n          end\n\n          it \"bumps the topic if the setting is disabled\" do\n            SiteSetting.disable_category_edit_notifications = false\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n            end.to change { topic.reload.category_id }.to(category.id)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).not_to eq_time(last_bumped_at)\n          end\n        end\n\n        context \"when using SiteSetting.disable_tags_edit_notifications\" do\n          fab!(:t1) { Fabricate(:tag) }\n          fab!(:t2) { Fabricate(:tag) }\n          let(:tags) { [t1, t2] }\n\n          it \"doesn't bump the topic if the setting is enabled\" do\n            SiteSetting.disable_tags_edit_notifications = true\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: tags.map(&:name) }\n\n            expect(topic.reload.tags).to match_array(tags)\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).to eq_time(last_bumped_at)\n          end\n\n          it \"bumps the topic if the setting is disabled\" do\n            SiteSetting.disable_tags_edit_notifications = false\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: tags.map(&:name) }\n\n            expect(topic.reload.tags).to match_array(tags)\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).not_to eq_time(last_bumped_at)\n          end\n        end\n\n        describe \"when first post is locked\" do\n          it \"blocks non-staff from editing even if 'trusted_users_can_edit_others' is true\" do\n            SiteSetting.trusted_users_can_edit_others = true\n            user.update!(trust_level: 3)\n            topic.first_post.update!(locked_by_id: admin.id)\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: topic.title + \" hello\" }\n\n            expect(response.status).to eq(403)\n          end\n\n          it \"allows staff to edit\" do\n            sign_in(Fabricate(:admin))\n            topic.first_post.update!(locked_by_id: admin.id)\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: topic.title + \" hello\" }\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"with tags\" do\n          before { SiteSetting.tagging_enabled = true }\n\n          it \"can add a tag to topic\" do\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [tag.name] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags.pluck(:id)).to contain_exactly(tag.id)\n          end\n\n          it \"can create a tag\" do\n            SiteSetting.min_trust_to_create_tag = 0\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [\"newtag\"] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags.pluck(:name)).to contain_exactly(\"newtag\")\n          end\n\n          it \"can change the category and create a new tag\" do\n            SiteSetting.min_trust_to_create_tag = 0\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\",\n                  params: {\n                    tags: [\"newtag\"],\n                    category_id: category.id,\n                  }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags.pluck(:name)).to contain_exactly(\"newtag\")\n          end\n\n          it \"can add a tag to wiki topic\" do\n            SiteSetting.min_trust_to_edit_wiki_post = 2\n            topic.first_post.update!(wiki: true)\n            sign_in(user_2)\n\n            expect do\n              put \"/t/#{topic.id}/tags.json\", params: { tags: [tag.name] }\n            end.not_to change { topic.reload.first_post.revisions.count }\n\n            expect(response.status).to eq(403)\n            user_2.update!(trust_level: 2)\n\n            expect do put \"/t/#{topic.id}/tags.json\", params: { tags: [tag.name] } end.to change {\n              topic.reload.first_post.revisions.count\n            }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags.pluck(:id)).to contain_exactly(tag.id)\n          end\n\n          it \"does not remove tag if no params is given\" do\n            topic.tags << tag\n\n            expect do put \"/t/#{topic.slug}/#{topic.id}.json\" end.to_not change {\n              topic.reload.tags.count\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can remove a tag\" do\n            topic.tags << tag\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [\"\"] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags).to eq([])\n          end\n\n          it \"does not cause a revision when tags have not changed\" do\n            topic.tags << tag\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [tag.name] }\n            end.not_to change { topic.reload.first_post.revisions.count }\n\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when topic is private\" do\n          before do\n            topic.update!(\n              archetype: Archetype.private_message,\n              category: nil,\n              allowed_users: [topic.user],\n            )\n          end\n\n          context \"when there are no changes\" do\n            it \"does not call the PostRevisor\" do\n              expect do\n                put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: topic.category_id }\n              end.not_to change(PostRevision.all, :count)\n\n              expect(response.status).to eq(200)\n            end\n          end\n        end\n\n        context \"when updating to a category with restricted tags\" do\n          fab!(:restricted_category) { Fabricate(:category) }\n          fab!(:tag1) { Fabricate(:tag) }\n          fab!(:tag2) { Fabricate(:tag) }\n          fab!(:tag3) { Fabricate(:tag) }\n          fab!(:tag_group_1) { Fabricate(:tag_group, tag_names: [tag1.name]) }\n          fab!(:tag_group_2) { Fabricate(:tag_group) }\n\n          before_all do\n            SiteSetting.tagging_enabled = true\n            topic.update!(tags: [tag1])\n          end\n\n          it \"can\u2019t change to a category disallowing this topic current tags\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            result = response.parsed_body\n\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"can\u2019t change to a category disallowing this topic current tag (through tag_group)\" do\n            tag_group_2.tags = [tag2]\n            restricted_category.allowed_tag_groups = [tag_group_2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            result = response.parsed_body\n\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"can change to a category allowing this topic current tags\" do\n            restricted_category.allowed_tags = [tag1.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can change to a category allowing this topic current tags (through tag_group)\" do\n            tag_group_1.tags = [tag1]\n            restricted_category.allowed_tag_groups = [tag_group_1.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can change to a category allowing any tag\" do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can\u2019t add a category-only tags from another category to a category\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [tag2.name],\n                  category_id: category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(result[\"errors\"][0]).to include(tag2.name)\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"allows category change when topic has a hidden tag\" do\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [tag1.name])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags).to include(tag1)\n          end\n\n          it \"allows category change when topic has a read-only tag\" do\n            Fabricate(\n              :tag_group,\n              permissions: {\n                \"staff\" => 1,\n                \"everyone\" => 3,\n              },\n              tag_names: [tag3.name],\n            )\n            topic.update!(tags: [tag3])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags).to contain_exactly(tag3)\n          end\n\n          it \"does not leak tag name when trying to use a staff tag\" do\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [tag3.name])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [tag3.name],\n                  category_id: category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(result[\"errors\"][0]).not_to include(tag3.name)\n          end\n\n          it \"will clean tag params\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [\"\"],\n                  category_id: restricted_category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when allow_uncategorized_topics is false\" do\n          before { SiteSetting.allow_uncategorized_topics = false }\n\n          it \"can add a category to an uncategorized topic\" do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.category).to eq(category)\n          end\n        end\n      end\n    end\n\n    describe \"featured links\" do\n      def fabricate_topic(user, category = nil)\n        topic = Fabricate(:topic, user: user, category: category)\n        Fabricate(:post, user: post_author1, topic: topic)\n        topic\n      end\n\n      it \"allows to update topic featured link\" do\n        sign_in(trust_level_1)\n\n        tl1_topic = fabricate_topic(trust_level_1)\n        put \"/t/#{tl1_topic.slug}/#{tl1_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't allow TL0 users to update topic featured link\" do\n        sign_in(trust_level_0)\n\n        tl0_topic = fabricate_topic(trust_level_0)\n        put \"/t/#{tl0_topic.slug}/#{tl0_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to update topic featured link if featured links are disabled in settings\" do\n        sign_in(trust_level_1)\n\n        SiteSetting.topic_featured_link_enabled = false\n        tl1_topic = fabricate_topic(trust_level_1)\n        put \"/t/#{tl1_topic.slug}/#{tl1_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to update topic featured link in the category with forbidden feature links\" do\n        sign_in(trust_level_1)\n\n        category = Fabricate(:category, topic_featured_link_allowed: false)\n        tl1_topic_in_category = fabricate_topic(trust_level_1, category)\n        put \"/t/#{tl1_topic_in_category.slug}/#{tl1_topic_in_category.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe \"#show_by_external_id\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, external_id: \"private\") }\n    fab!(:topic) { Fabricate(:topic, external_id: \"asdf\") }\n\n    it \"returns 301 when found\" do\n      get \"/t/external_id/asdf.json\"\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json\")\n    end\n\n    it \"returns right response when not found\" do\n      get \"/t/external_id/fdsa.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"preserves only select query params\" do\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json?filter_top_level_replies=true\")\n\n      get \"/t/external_id/asdf.json\", params: { not_valid: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json\")\n\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true, post_number: 9999 }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        topic.relative_url + \"/9999.json?filter_top_level_replies=true\",\n      )\n\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true, print: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        topic.relative_url + \".json?print=true&filter_top_level_replies=true\",\n      )\n    end\n\n    describe \"when user does not have access to the topic\" do\n      it \"should return the right response\" do\n        sign_in(user)\n\n        get \"/t/external_id/private.json\"\n\n        expect(response.status).to eq(403)\n        expect(response.body).to include(I18n.t(\"invalid_access\"))\n      end\n    end\n  end\n\n  describe \"#show\" do\n    use_redis_snapshotting\n\n    fab!(:private_topic) { pm }\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    fab!(:p1) { Fabricate(:post, user: topic.user) }\n    fab!(:p2) { Fabricate(:post, user: topic.user) }\n\n    describe \"when topic is not allowed\" do\n      it \"should return the right response\" do\n        SiteSetting.detailed_404 = true\n        sign_in(user)\n\n        get \"/t/#{private_topic.id}.json\"\n\n        expect(response.status).to eq(403)\n        expect(response.body).to include(I18n.t(\"invalid_access\"))\n      end\n    end\n\n    describe \"when topic is allowed to a group\" do\n      fab!(:group) { Fabricate(:group, public_admission: true) }\n      fab!(:category) do\n        Fabricate(:category_with_definition).tap do |category|\n          category.set_permissions(group => :full)\n          category.save!\n        end\n      end\n      fab!(:topic) { Fabricate(:topic, category: category) }\n\n      before { SiteSetting.detailed_404 = true }\n\n      it \"shows a descriptive error message containing the group name\" do\n        get \"/t/#{topic.id}.json\"\n\n        html = CGI.unescapeHTML(response.parsed_body[\"extras\"][\"html\"])\n        expect(response.status).to eq(403)\n        expect(html).to include(I18n.t(\"not_in_group.title_topic\", group: group.name))\n        expect(html).to include(I18n.t(\"not_in_group.join_group\"))\n      end\n    end\n\n    it \"correctly renders canonicals\" do\n      get \"/t/#{topic.id}\", params: { slug: topic.slug }\n\n      expect(response.status).to eq(200)\n      expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n      expect(response.headers[\"Cache-Control\"]).to eq(\"no-cache, no-store\")\n    end\n\n    it \"returns 301 even if slug does not match URL\" do\n      # in the past we had special logic for unlisted topics\n      # we would require slug unless you made a json call\n      # this was not really providing any security\n      #\n      # we no longer require a topic be visible to perform url correction\n      # if you need to properly hide a topic for users use a secure category\n      # or a PM\n      Fabricate(:post, user: post_author1, topic: invisible_topic)\n\n      get \"/t/#{invisible_topic.id}.json\", params: { slug: invisible_topic.slug }\n      expect(response.status).to eq(200)\n\n      get \"/t/#{topic.id}.json\", params: { slug: \"just-guessing\" }\n      expect(response.status).to eq(301)\n\n      get \"/t/#{topic.slug}.json\"\n      expect(response.status).to eq(301)\n    end\n\n    it \"shows a topic correctly\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"return 404 for an invalid page\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n      expect(response.status).to eq(404)\n    end\n\n    it \"can find a topic given a slug in the id param\" do\n      get \"/t/#{topic.slug}\"\n      expect(response).to redirect_to(topic.relative_url)\n    end\n\n    it \"can find a topic when a slug has a number in front\" do\n      another_topic = Fabricate(:post, user: post_author1).topic\n\n      topic.update_column(:slug, \"#{another_topic.id}-reasons-discourse-is-awesome\")\n      get \"/t/#{another_topic.id}-reasons-discourse-is-awesome\"\n\n      expect(response).to redirect_to(topic.relative_url)\n    end\n\n    it \"keeps the post_number parameter around when redirecting\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42 }\n      expect(response).to redirect_to(topic.relative_url + \"/42\")\n    end\n\n    it \"keeps the page around when redirecting\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42, page: 123 }\n\n      expect(response).to redirect_to(topic.relative_url + \"/42?page=123\")\n    end\n\n    it \"does not accept page params as an array\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42, page: [2] }\n\n      expect(response).to redirect_to(\"#{topic.relative_url}/42?page=1\")\n    end\n\n    it \"returns 404 when an invalid slug is given and no id\" do\n      get \"/t/nope-nope.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns a 404 when slug and topic id do not match a topic\" do\n      get \"/t/made-up-topic-slug/123456.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns a 404 for an ID that is larger than postgres limits\" do\n      get \"/t/made-up-topic-slug/5014217323220164041.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"doesn't use print mode when print equals false\" do\n      SiteSetting.max_prints_per_hour_per_user = 0\n\n      get \"/t/#{topic.slug}/#{topic.id}.json?print=false\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"does not result in N+1 queries problem when multiple topic participants have primary or flair group configured\" do\n      user2 = Fabricate(:user)\n      user3 = Fabricate(:user)\n      post2 = Fabricate(:post, topic: topic, user: user2)\n      post3 = Fabricate(:post, topic: topic, user: user3)\n      group = Fabricate(:group)\n      user2.update!(primary_group: group)\n      user3.update!(flair_group: group)\n\n      # warm up\n      get \"/t/#{topic.id}.json\"\n      expect(response.status).to eq(200)\n\n      first_request_queries =\n        track_sql_queries do\n          get \"/t/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n\n          expect(\n            response.parsed_body[\"details\"][\"participants\"].map { |u| u[\"id\"] },\n          ).to contain_exactly(post_author1.id, user2.id, user3.id)\n        end\n\n      group2 = Fabricate(:group)\n      user4 = Fabricate(:user, flair_group: group2)\n      user5 = Fabricate(:user, primary_group: group2)\n      post4 = Fabricate(:post, topic: topic, user: user4)\n      post5 = Fabricate(:post, topic: topic, user: user5)\n\n      second_request_queries =\n        track_sql_queries do\n          get \"/t/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n\n          expect(\n            response.parsed_body[\"details\"][\"participants\"].map { |u| u[\"id\"] },\n          ).to contain_exactly(post_author1.id, user2.id, user3.id, user4.id, user5.id)\n        end\n\n      expect(second_request_queries.count).to eq(first_request_queries.count)\n    end\n\n    context \"when a topic with nil slug exists\" do\n      before do\n        nil_slug_topic = Fabricate(:topic)\n        Topic.connection.execute(\"update topics set slug=null where id = #{nil_slug_topic.id}\") # can't find a way to set slug column to null using the model\n      end\n\n      it \"returns a 404 when slug and topic id do not match a topic\" do\n        get \"/t/made-up-topic-slug/123123.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with permission errors\" do\n      fab!(:allowed_user) { Fabricate(:user) }\n      fab!(:allowed_group) { Fabricate(:group) }\n      fab!(:accessible_group) { Fabricate(:group, public_admission: true) }\n      fab!(:secure_category) do\n        c = Fabricate(:category)\n        c.permissions = [[allowed_group, :full]]\n        c.save\n        allowed_user.groups = [allowed_group]\n        allowed_user.save\n        c\n      end\n      fab!(:accessible_category) do\n        Fabricate(:category).tap do |c|\n          c.set_permissions(accessible_group => :full)\n          c.save!\n        end\n      end\n      fab!(:normal_topic) { Fabricate(:topic) }\n      fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n      fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n      # Can't use fab!, because deleted_topics can't be re-found\n      before_all do\n        @deleted_topic = Fabricate(:deleted_topic)\n        @deleted_secure_topic = Fabricate(:topic, category: secure_category, deleted_at: 1.day.ago)\n        @deleted_private_topic =\n          Fabricate(:private_message_topic, user: allowed_user, deleted_at: 1.day.ago)\n      end\n      let(:deleted_topic) { @deleted_topic }\n      let(:deleted_secure_topic) { @deleted_secure_topic }\n      let(:deleted_private_topic) { @deleted_private_topic }\n\n      let!(:nonexistent_topic_id) { Topic.last.id + 10_000 }\n      fab!(:secure_accessible_topic) { Fabricate(:topic, category: accessible_category) }\n\n      shared_examples \"various scenarios\" do |expected, request_json:|\n        expected.each do |key, value|\n          it \"returns #{value} for #{key}\" do\n            slug = key == :nonexistent ? \"garbage-slug\" : send(key.to_s).slug\n            topic_id = key == :nonexistent ? nonexistent_topic_id : send(key.to_s).id\n            format = request_json ? \".json\" : \"\"\n            get \"/t/#{slug}/#{topic_id}#{format}\"\n            expect(response.status).to eq(value)\n          end\n        end\n\n        expected_slug_response = expected[:secure_topic] == 200 ? 301 : expected[:secure_topic]\n        it \"will return a #{expected_slug_response} when requesting a secure topic by slug\" do\n          format = request_json ? \".json\" : \"\"\n          get \"/t/#{secure_topic.slug}#{format}\"\n          expect(response.status).to eq(expected_slug_response)\n        end\n      end\n\n      context \"without detailed error pages\" do\n        before { SiteSetting.detailed_404 = false }\n\n        context \"when anonymous\" do\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when anonymous with login required\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 302,\n            secure_topic: 302,\n            private_topic: 302,\n            deleted_topic: 302,\n            deleted_secure_topic: 302,\n            deleted_private_topic: 302,\n            nonexistent: 302,\n            secure_accessible_topic: 302,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when anonymous with login required, requesting json\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 403,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 403,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 403,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when normal user\" do\n          before { sign_in(user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when allowed user\" do\n          before { sign_in(allowed_user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when moderator\" do\n          before { sign_in(moderator) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 200,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when admin\" do\n          before { sign_in(admin) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 200,\n            deleted_secure_topic: 200,\n            deleted_private_topic: 200,\n            nonexistent: 404,\n            secure_accessible_topic: 200,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n      end\n\n      context \"with detailed error pages\" do\n        before { SiteSetting.detailed_404 = true }\n\n        context \"when anonymous\" do\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 410,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when anonymous with login required\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 302,\n            secure_topic: 302,\n            private_topic: 302,\n            deleted_topic: 302,\n            deleted_secure_topic: 302,\n            deleted_private_topic: 302,\n            nonexistent: 302,\n            secure_accessible_topic: 302,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when normal user\" do\n          before { sign_in(user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 410,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when allowed user\" do\n          before { sign_in(allowed_user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 410,\n            deleted_secure_topic: 410,\n            deleted_private_topic: 410,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when moderator\" do\n          before { sign_in(moderator) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 200,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when admin\" do\n          before { sign_in(admin) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 200,\n            deleted_secure_topic: 200,\n            deleted_private_topic: 200,\n            nonexistent: 404,\n            secure_accessible_topic: 200,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n      end\n    end\n\n    it \"records a view\" do\n      expect do get \"/t/#{topic.slug}/#{topic.id}.json\" end.to change(TopicViewItem, :count).by(1)\n    end\n\n    it \"records a view to invalid post_number\" do\n      expect do\n        get \"/t/#{topic.slug}/#{topic.id}/#{256**4}\", params: { u: user.username }\n        expect(response.status).to eq(200)\n      end.to change { IncomingLink.count }.by(1)\n    end\n\n    it \"records incoming links\" do\n      expect do get \"/t/#{topic.slug}/#{topic.id}\", params: { u: user.username } end.to change {\n        IncomingLink.count\n      }.by(1)\n    end\n\n    context \"with print\" do\n      it \"doesn't renders the print view when disabled\" do\n        SiteSetting.max_prints_per_hour_per_user = 0\n\n        get \"/t/#{topic.slug}/#{topic.id}/print\"\n\n        expect(response).to be_forbidden\n      end\n\n      it \"renders the print view when enabled\" do\n        SiteSetting.max_prints_per_hour_per_user = 10\n        get \"/t/#{topic.slug}/#{topic.id}/print\", headers: { HTTP_USER_AGENT: \"Rails Testing\" }\n\n        expect(response.status).to eq(200)\n        body = response.body\n\n        expect(body).to have_tag(:body, class: \"crawler\")\n        expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n      end\n\n      it \"uses the application layout when there's no param\" do\n        SiteSetting.max_prints_per_hour_per_user = 10\n        get \"/t/#{topic.slug}/#{topic.id}\", headers: { HTTP_USER_AGENT: \"Rails Testing\" }\n\n        body = response.body\n\n        expect(body).to have_tag(:script, src: \"/assets/discourse.js\")\n        expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n      end\n    end\n\n    it \"records redirects\" do\n      get \"/t/#{topic.id}\", headers: { HTTP_REFERER: \"http://twitter.com\" }\n      get \"/t/#{topic.slug}/#{topic.id}\", headers: { HTTP_REFERER: nil }\n\n      link = IncomingLink.first\n      expect(link.referer).to eq(\"http://twitter.com\")\n    end\n\n    it \"tracks a visit for all html requests\" do\n      sign_in(user)\n      get \"/t/#{topic.slug}/#{topic.id}\"\n      topic_user = TopicUser.where(user: user, topic: topic).first\n      expect(topic_user.last_visited_at).to eq_time(topic_user.first_visited_at)\n    end\n\n    context \"when considering for a promotion\" do\n      before do\n        SiteSetting.tl1_requires_topics_entered = 0\n        SiteSetting.tl1_requires_read_posts = 0\n        SiteSetting.tl1_requires_time_spent_mins = 0\n        SiteSetting.tl1_requires_time_spent_mins = 0\n      end\n\n      it \"reviews the user for a promotion if they're new\" do\n        sign_in(user)\n        user.update_column(:trust_level, TrustLevel[0])\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n        user.reload\n        expect(user.trust_level).to eq(1)\n      end\n    end\n\n    context \"with filters\" do\n      def extract_post_stream\n        json = response.parsed_body\n        json[\"post_stream\"][\"posts\"].map { |post| post[\"id\"] }\n      end\n\n      before do\n        TopicView.stubs(:chunk_size).returns(2)\n        @post_ids = topic.posts.pluck(:id)\n        3.times { @post_ids << Fabricate(:post, user: post_author1, topic: topic).id }\n      end\n\n      it \"grabs the correct set of posts\" do\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..1])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..1])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[2..3])\n\n        post_number = topic.posts.pluck(:post_number).sort[3]\n        get \"/t/#{topic.slug}/#{topic.id}/#{post_number}.json\"\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[-2..-1])\n\n        TopicView.stubs(:chunk_size).returns(3)\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..2])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[3..3])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 3 }\n        expect(response.status).to eq(404)\n\n        TopicView.stubs(:chunk_size).returns(4)\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..3])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"#show filters\" do\n      fab!(:post) { Fabricate(:post, user: post_author1) }\n      fab!(:topic) { post.topic }\n      fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic) }\n\n      describe \"filter by replies to a post\" do\n        fab!(:post3) do\n          Fabricate(\n            :post,\n            user: post_author3,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post5) { Fabricate(:post, user: post_author5, topic: topic) }\n        fab!(:quote_reply) { Fabricate(:basic_reply, user: user, topic: topic) }\n        fab!(:post_reply) { PostReply.create(post_id: post2.id, reply_post_id: quote_reply.id) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { replies_to_post_number: post2.post_number }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          expect(ids).to eq([post.id, post2.id, post3.id, post4.id, quote_reply.id])\n        end\n      end\n\n      describe \"filter by top level replies\" do\n        fab!(:post3) do\n          Fabricate(\n            :post,\n            user: post_author3,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post5) { Fabricate(:post, user: post_author5, topic: topic) }\n        fab!(:post6) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post5.post_number,\n          )\n        end\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { filter_top_level_replies: true }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          expect(ids).to eq([post2.id, post5.id])\n        end\n      end\n\n      describe \"filter upwards by post id\" do\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post3.post_number,\n          )\n        end\n        fab!(:post5) do\n          Fabricate(\n            :post,\n            user: post_author5,\n            topic: topic,\n            reply_to_post_number: post4.post_number,\n          )\n        end\n        fab!(:post6) { Fabricate(:post, user: post_author6, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { filter_upwards_post_id: post5.id }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          # includes topic OP, current post and subsequent posts\n          # but only one level of parents, respecting default max_reply_history = 1\n          expect(ids).to eq([post.id, post4.id, post5.id, post6.id])\n        end\n\n        it \"should respect max_reply_history site setting\" do\n          SiteSetting.max_reply_history = 2\n\n          get \"/t/#{topic.id}.json\", params: { filter_upwards_post_id: post5.id }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n\n          # includes 2 levels of replies (post3 and post4)\n          expect(ids).to eq([post.id, post3.id, post4.id, post5.id, post6.id])\n        end\n      end\n    end\n\n    context \"when 'login required' site setting has been enabled\" do\n      before { SiteSetting.login_required = true }\n\n      context \"when the user is logged in\" do\n        before { sign_in(user) }\n\n        it \"shows the topic\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"when the user is not logged in\" do\n        let(:api_key) { Fabricate(:api_key, user: topic.user) }\n\n        it \"redirects browsers to the login page\" do\n          get \"/t/#{topic.slug}/#{topic.id}\"\n          expect(response).to redirect_to login_path\n        end\n\n        it \"raises a 403 for json requests\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\"\n          expect(response.status).to eq(403)\n        end\n\n        it \"shows the topic if valid api key is provided\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\", headers: { \"HTTP_API_KEY\" => api_key.key }\n\n          expect(response.status).to eq(200)\n          topic.reload\n          expect(topic.views).to eq(1)\n        end\n\n        it \"returns 403 for an invalid key\" do\n          %i[json html].each do |format|\n            get \"/t/#{topic.slug}/#{topic.id}.#{format}\", headers: { \"HTTP_API_KEY\" => \"bad\" }\n\n            expect(response.code.to_i).to eq(403)\n            expect(response.body).to include(I18n.t(\"invalid_access\"))\n          end\n        end\n      end\n    end\n\n    it \"is included for unlisted topics\" do\n      get \"/t/#{invisible_topic.slug}/#{invisible_topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    it \"is not included for normal topics\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(nil)\n    end\n\n    it \"is included when allow_index_in_robots_txt is set to false\" do\n      SiteSetting.allow_index_in_robots_txt = false\n\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex, nofollow\")\n    end\n\n    it \"doesn't store an incoming link when there's no referer\" do\n      expect { get \"/t/#{topic.id}.json\" }.not_to change(IncomingLink, :count)\n      expect(response.status).to eq(200)\n    end\n\n    it \"doesn't raise an error on a very long link\" do\n      get \"/t/#{topic.id}.json\", headers: { HTTP_REFERER: \"http://#{\"a\" * 2000}.com\" }\n      expect(response.status).to eq(200)\n    end\n\n    context \"when `enable_user_status` site setting is enabled\" do\n      fab!(:post) { Fabricate(:post, user: post_author1) }\n      fab!(:topic) { post.topic }\n      fab!(:post2) do\n        Fabricate(\n          :post,\n          user: post_author2,\n          topic: topic,\n          raw: \"I am mentioning @#{post_author1.username}.\",\n        )\n      end\n\n      before { SiteSetting.enable_user_status = true }\n\n      it \"does not return mentions when `enable_user_status` site setting is disabled\" do\n        SiteSetting.enable_user_status = false\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"]).to eq(nil)\n      end\n\n      it \"returns mentions with status\" do\n        post_author1.set_status!(\"off to dentist\", \"tooth\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"].length).to be(1)\n\n        mentioned_user = json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"][0]\n        expect(mentioned_user[\"id\"]).to be(post_author1.id)\n        expect(mentioned_user[\"name\"]).to eq(post_author1.name)\n        expect(mentioned_user[\"username\"]).to eq(post_author1.username)\n\n        status = mentioned_user[\"status\"]\n        expect(status).to be_present\n        expect(status[\"emoji\"]).to eq(post_author1.user_status.emoji)\n        expect(status[\"description\"]).to eq(post_author1.user_status.description)\n      end\n\n      it \"returns an empty list of mentioned users if there are no mentions in a post\" do\n        Fabricate(:post, user: post_author2, topic: topic, raw: \"Post without mentions.\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][2][\"mentioned_users\"].length).to be(0)\n      end\n\n      it \"returns an empty list of mentioned users if an unexisting user was mentioned\" do\n        Fabricate(:post, user: post_author2, topic: topic, raw: \"Mentioning an @unexisting_user.\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][2][\"mentioned_users\"].length).to be(0)\n      end\n    end\n\n    describe \"has_escaped_fragment?\" do\n      context \"when the SiteSetting is disabled\" do\n        it \"uses the application layout even with an escaped fragment param\" do\n          SiteSetting.enable_escaped_fragments = false\n\n          get \"/t/#{topic.slug}/#{topic.id}\", params: { _escaped_fragment_: \"true\" }\n\n          body = response.body\n\n          expect(response.status).to eq(200)\n          expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n\n      context \"when the SiteSetting is enabled\" do\n        before { SiteSetting.enable_escaped_fragments = true }\n\n        it \"uses the application layout when there's no param\" do\n          get \"/t/#{topic.slug}/#{topic.id}\"\n\n          body = response.body\n\n          expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n          expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n        end\n\n        it \"uses the crawler layout when there's an _escaped_fragment_ param\" do\n          get \"/t/#{topic.slug}/#{topic.id}\",\n              params: {\n                _escaped_fragment_: true,\n              },\n              headers: {\n                HTTP_USER_AGENT: \"Rails Testing\",\n              }\n\n          body = response.body\n\n          expect(response.status).to eq(200)\n          expect(body).to have_tag(:body, with: { class: \"crawler\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n    end\n\n    describe \"clear_notifications\" do\n      it \"correctly clears notifications if specified via cookie\" do\n        set_subfolder \"/eviltrout\"\n\n        notification = Fabricate(:notification)\n        sign_in(notification.user)\n\n        cookies[\"cn\"] = \"2828,100,#{notification.id}\"\n\n        get \"/t/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.cookies[\"cn\"]).to eq(nil)\n        expect(response.headers[\"Set-Cookie\"]).to match(%r{^cn=;.*path=/eviltrout})\n\n        notification.reload\n        expect(notification.read).to eq(true)\n      end\n\n      it \"correctly clears notifications if specified via header\" do\n        notification = Fabricate(:notification)\n        sign_in(notification.user)\n\n        get \"/t/#{topic.id}.json\",\n            headers: {\n              \"Discourse-Clear-Notifications\" => \"2828,100,#{notification.id}\",\n            }\n\n        expect(response.status).to eq(200)\n        notification.reload\n        expect(notification.read).to eq(true)\n      end\n    end\n\n    describe \"read only header\" do\n      it \"returns no read only header by default\" do\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"Discourse-Readonly\"]).to eq(nil)\n      end\n\n      it \"returns a readonly header if the site is read only\" do\n        Discourse.received_postgres_readonly!\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"Discourse-Readonly\"]).to eq(\"true\")\n      end\n    end\n\n    describe \"image only topic\" do\n      it \"uses image alt tag for meta description\" do\n        post =\n          Fabricate(\n            :post,\n            user: post_author1,\n            raw: \"![image_description|690x405](upload://sdtr5O5xaxf0iEOxICxL36YRj86.png)\",\n          )\n\n        get post.topic.url\n\n        body = response.body\n        expect(body).to have_tag(\n          :meta,\n          with: {\n            name: \"description\",\n            content: \"[image_description]\",\n          },\n        )\n      end\n\n      it \"uses image cdn url for schema markup\" do\n        set_cdn_url(\"http://cdn.localhost\")\n        post = Fabricate(:post_with_uploaded_image, user: post_author1)\n        cpp = CookedPostProcessor.new(post).update_post_image\n\n        get post.topic.url\n\n        body = response.body\n        expect(body).to have_tag(:link, with: { itemprop: \"image\", href: post.image_url })\n      end\n    end\n  end\n\n  describe \"#post_ids\" do\n    fab!(:post) { Fabricate(:post, user: post_author1) }\n    fab!(:topic) { post.topic }\n\n    before { TopicView.stubs(:chunk_size).returns(1) }\n\n    it \"returns the right post ids\" do\n      post2 = Fabricate(:post, user: post_author2, topic: topic)\n      post3 = Fabricate(:post, user: post_author3, topic: topic)\n\n      get \"/t/#{topic.id}/post_ids.json\", params: { post_number: post.post_number }\n\n      expect(response.status).to eq(200)\n\n      body = response.parsed_body\n\n      expect(body[\"post_ids\"]).to eq([post2.id, post3.id])\n    end\n\n    describe \"filtering by post number with filters\" do\n      describe \"username filters\" do\n        fab!(:post) { Fabricate(:post, user: user) }\n        fab!(:post2) { Fabricate(:post, topic: topic, user: user) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}/post_ids.json\",\n              params: {\n                post_number: post.post_number,\n                username_filters: post2.user.username,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_ids\"]).to eq([post2.id])\n        end\n      end\n\n      describe \"summary filter\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}/post_ids.json\",\n              params: {\n                post_number: post.post_number,\n                filter: \"summary\",\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_ids\"]).to eq([post2.id])\n        end\n      end\n\n      describe \"custom filters\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic, percent_rank: 0.5) }\n        it \"should return the right posts\" do\n          TopicView.add_custom_filter(\"percent\") do |posts, topic_view|\n            posts.where(percent_rank: 0.5)\n          end\n\n          get \"/t/#{topic.id}.json\", params: { post_number: post.post_number, filter: \"percent\" }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }).to eq([post3.id])\n        ensure\n          TopicView.instance_variable_set(:@custom_filters, {})\n        end\n      end\n    end\n  end\n\n  describe \"#posts\" do\n    fab!(:post) { Fabricate(:post, user: post_author1) }\n    fab!(:topic) { post.topic }\n\n    after { Discourse.redis.flushdb }\n\n    it \"returns first post of the topic\" do\n      # we need one for suggested\n      create_post\n\n      get \"/t/#{topic.id}/posts.json\"\n\n      expect(response.status).to eq(200)\n\n      body = response.parsed_body\n\n      expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post.id)\n\n      expect(body[\"suggested_topics\"]).to eq(nil)\n\n      get \"/t/#{topic.id}/posts.json?include_suggested=true\"\n      body = response.parsed_body\n\n      expect(body[\"suggested_topics\"]).not_to eq(nil)\n    end\n\n    describe \"filtering by post number with filters\" do\n      describe \"username filters\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          TopicView.stubs(:chunk_size).returns(2)\n\n          get \"/t/#{topic.id}/posts.json\",\n              params: {\n                post_number: post.post_number,\n                username_filters: post2.user.username,\n                asc: true,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post2.id)\n        end\n      end\n\n      describe \"summary filter\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          TopicView.stubs(:chunk_size).returns(2)\n\n          get \"/t/#{topic.id}/posts.json\",\n              params: {\n                post_number: post.post_number,\n                filter: \"summary\",\n                asc: true,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post2.id)\n        end\n      end\n    end\n  end\n\n  describe \"#feed\" do\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    it \"renders rss of the topic\" do\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n\n      # our RSS feed is full of post 1/2/3/4/5 links, we do not want it included\n      # in the index, and do not want links followed\n      # this allows us to remove it while allowing via robots.txt\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex, nofollow\")\n    end\n\n    it \"renders rss of the topic correctly with subfolder\" do\n      set_subfolder \"/forum\"\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not include(\"/forum/forum\")\n      expect(response.body).to include(\"http://test.localhost/forum/t/#{topic.slug}\")\n    end\n\n    it \"returns 404 when posts are deleted\" do\n      topic.posts.each(&:trash!)\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns 404 when the topic is deleted\" do\n      topic.trash!\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#invite_group\" do\n    let!(:admins) { Group[:admins] }\n\n    before do\n      sign_in(admin)\n      admins.messageable_level = Group::ALIAS_LEVELS[:everyone]\n      admins.save!\n    end\n\n    it \"disallows inviting a group to a topic\" do\n      post \"/t/#{topic.id}/invite-group.json\", params: { group: \"admins\" }\n\n      expect(response.status).to eq(422)\n    end\n\n    it \"allows inviting a group to a PM\" do\n      post \"/t/#{pm.id}/invite-group.json\", params: { group: \"admins\" }\n\n      expect(response.status).to eq(200)\n      expect(pm.allowed_groups.first.id).to eq(admins.id)\n    end\n  end\n\n  describe \"#make_banner\" do\n    it \"needs you to be a staff member\" do\n      tl4_topic = Fabricate(:topic, user: sign_in(trust_level_4))\n      put \"/t/#{tl4_topic.id}/make-banner.json\"\n      expect(response).to be_forbidden\n    end\n\n    describe \"when logged in\" do\n      it \"changes the topic archetype to 'banner'\" do\n        admin_topic = Fabricate(:topic, user: sign_in(admin))\n\n        put \"/t/#{admin_topic.id}/make-banner.json\"\n        expect(response.status).to eq(200)\n        admin_topic.reload\n        expect(admin_topic.archetype).to eq(Archetype.banner)\n      end\n    end\n  end\n\n  describe \"#remove_banner\" do\n    it \"needs you to be a staff member\" do\n      tl4_topic = Fabricate(:topic, user: sign_in(trust_level_4), archetype: Archetype.banner)\n      put \"/t/#{tl4_topic.id}/remove-banner.json\"\n      expect(response).to be_forbidden\n    end\n\n    describe \"when logged in\" do\n      it \"resets the topic archetype\" do\n        admin_topic = Fabricate(:topic, user: sign_in(admin), archetype: Archetype.banner)\n\n        put \"/t/#{admin_topic.id}/remove-banner.json\"\n        expect(response.status).to eq(200)\n        admin_topic.reload\n        expect(admin_topic.archetype).to eq(Archetype.default)\n      end\n    end\n  end\n\n  describe \"#remove_allowed_user\" do\n    it \"admin can be removed from a pm\" do\n      sign_in(admin)\n      pm =\n        create_post(\n          user: user,\n          archetype: \"private_message\",\n          target_usernames: [user.username, admin.username],\n        )\n\n      put \"/t/#{pm.topic_id}/remove-allowed-user.json\", params: { username: admin.username }\n\n      expect(response.status).to eq(200)\n      expect(TopicAllowedUser.where(topic_id: pm.topic_id, user_id: admin.id).first).to eq(nil)\n    end\n  end\n\n  describe \"#bulk\" do\n    it \"needs you to be logged in\" do\n      put \"/topics/bulk.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      before { sign_in(user) }\n      let!(:operation) { { type: \"change_category\", category_id: \"1\" } }\n      let!(:topic_ids) { [1, 2, 3] }\n\n      it \"requires a list of topic_ids or filter\" do\n        put \"/topics/bulk.json\", params: { operation: operation }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires an operation param\" do\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires a type field for the operation param\" do\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids, operation: {} }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can mark sub-categories unread\" do\n        sub = Fabricate(:category, parent_category_id: category.id)\n\n        topic.update!(category_id: sub.id)\n\n        post1 = create_post(user: user, topic_id: topic.id)\n        create_post(topic_id: topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              category_id: category.id,\n              include_subcategories: true,\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(post1.topic, post1.user).last_read_post_number).to eq(2)\n      end\n\n      it \"can mark tag topics unread\" do\n        TopicTag.create!(topic_id: topic.id, tag_id: tag.id)\n\n        post1 = create_post(user: user, topic_id: topic.id)\n        create_post(topic_id: topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              tag_name: tag.name,\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(post1.topic, post1.user).last_read_post_number).to eq(2)\n      end\n\n      context \"with private message\" do\n        before_all { Group.refresh_automatic_groups! }\n\n        fab!(:group) do\n          Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap do |g|\n            g.add(user_2)\n          end\n        end\n\n        fab!(:group_message) do\n          create_post(\n            user: user,\n            target_group_names: [group.name],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:private_message) do\n          create_post(\n            user: user,\n            target_usernames: [user_2.username],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:private_message_2) do\n          create_post(\n            user: user,\n            target_usernames: [user_2.username],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:group_pm_topic_user) do\n          TopicUser\n            .find_by(user: user_2, topic: group_message)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        fab!(:regular_pm_topic_user) do\n          TopicUser\n            .find_by(user: user_2, topic: private_message)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        fab!(:regular_pm_topic_user_2) do\n          TopicUser\n            .find_by(user: user_2, topic: private_message_2)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        before_all do\n          create_post(user: user, topic: group_message)\n          create_post(user: user, topic: private_message)\n          create_post(user: user, topic: private_message_2)\n        end\n\n        before { sign_in(user_2) }\n\n        it \"can dismiss all user and group private message topics\" do\n          expect do\n            put \"/topics/bulk.json\",\n                params: {\n                  filter: \"unread\",\n                  operation: {\n                    type: \"dismiss_posts\",\n                  },\n                  private_message_inbox: \"all\",\n                }\n\n            expect(response.status).to eq(200)\n          end.to change { group_pm_topic_user.reload.last_read_post_number }.from(1).to(\n            2,\n          ).and change { regular_pm_topic_user.reload.last_read_post_number }.from(1).to(2)\n        end\n\n        it \"can dismiss all user unread private message topics\" do\n          stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n            expect do\n              put \"/topics/bulk.json\",\n                  params: {\n                    filter: \"unread\",\n                    operation: {\n                      type: \"dismiss_posts\",\n                    },\n                    private_message_inbox: \"user\",\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { regular_pm_topic_user.reload.last_read_post_number }.from(1).to(\n              2,\n            ).and change { regular_pm_topic_user_2.reload.last_read_post_number }.from(1).to(2)\n\n            expect(group_pm_topic_user.reload.last_read_post_number).to eq(1)\n          end\n        end\n\n        it \"returns the right response when trying to dismiss private messages of an invalid group\" do\n          put \"/topics/bulk.json\",\n              params: {\n                filter: \"unread\",\n                operation: {\n                  type: \"dismiss_posts\",\n                },\n                private_message_inbox: \"group\",\n                group_name: \"randomgroup\",\n              }\n\n          expect(response.status).to eq(404)\n        end\n\n        it \"returns the right response when trying to dismiss private messages of a restricted group\" do\n          sign_in(user)\n\n          put \"/topics/bulk.json\",\n              params: {\n                filter: \"unread\",\n                operation: {\n                  type: \"dismiss_posts\",\n                },\n                private_message_inbox: \"group\",\n                group_name: group.name,\n              }\n\n          expect(response.status).to eq(404)\n        end\n\n        it \"can dismiss all group unread private message topics\" do\n          expect do\n            put \"/topics/bulk.json\",\n                params: {\n                  filter: \"unread\",\n                  operation: {\n                    type: \"dismiss_posts\",\n                  },\n                  private_message_inbox: \"group\",\n                  group_name: group.name,\n                }\n\n            expect(response.status).to eq(200)\n          end.to change { group_pm_topic_user.reload.last_read_post_number }.from(1).to(2)\n\n          expect(regular_pm_topic_user.reload.last_read_post_number).to eq(1)\n        end\n      end\n\n      it \"can find unread\" do\n        # mark all unread muted\n        put \"/topics/bulk.json\",\n            params: {\n              filter: \"unread\",\n              operation: {\n                type: :change_notification_level,\n                notification_level_id: 0,\n              },\n            }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"delegates work to `TopicsBulkAction`\" do\n        topics_bulk_action = mock\n        TopicsBulkAction\n          .expects(:new)\n          .with(user, topic_ids, operation, group: nil)\n          .returns(topics_bulk_action)\n        topics_bulk_action.expects(:perform!)\n\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids, operation: operation }\n      end\n\n      it \"raises an error if topic_ids is provided and it is not an array\" do\n        put \"/topics/bulk.json\", params: { topic_ids: \"1\", operation: operation }\n        expect(response.parsed_body[\"errors\"].first).to match(\n          /Expecting topic_ids to contain a list/,\n        )\n        put \"/topics/bulk.json\", params: { topic_ids: [1], operation: operation }\n        expect(response.parsed_body[\"errors\"]).to eq(nil)\n      end\n\n      it \"respects the tracked parameter\" do\n        # untracked topic\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:regular],\n          category.id,\n        )\n        create_post(user: user, topic_id: topic.id)\n        topic.update!(category_id: category.id)\n        create_post(topic_id: topic.id)\n\n        # tracked topic\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:tracking],\n          tracked_category.id,\n        )\n        tracked_topic = create_post(user: user).topic\n        tracked_topic.update!(category_id: tracked_category.id)\n        create_post(topic_id: tracked_topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n              tracked: true,\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(topic, user).last_read_post_number).to eq(topic.posts.count - 1)\n        expect(TopicUser.get(tracked_topic, user).last_read_post_number).to eq(\n          tracked_topic.posts.count,\n        )\n      end\n    end\n  end\n\n  describe \"#remove_bookmarks\" do\n    it \"should remove bookmarks properly from non first post\" do\n      sign_in(user)\n\n      post = create_post\n      post2 = create_post(topic_id: post.topic_id)\n      Fabricate(:bookmark, user: user, bookmarkable: post)\n      Fabricate(:bookmark, user: user, bookmarkable: post2)\n\n      put \"/t/#{post.topic_id}/remove_bookmarks.json\"\n      expect(Bookmark.where(user: user).count).to eq(0)\n    end\n\n    it \"should disallow bookmarks on posts you have no access to\" do\n      sign_in(Fabricate(:user))\n      pm = create_post(user: user, archetype: \"private_message\", target_usernames: [user.username])\n\n      put \"/t/#{pm.topic_id}/bookmark.json\"\n      expect(response).to be_forbidden\n    end\n\n    context \"with bookmarks with reminders\" do\n      it \"deletes all the bookmarks for the user in the topic\" do\n        sign_in(user)\n        post = create_post\n        Fabricate(:bookmark, bookmarkable: post, user: user)\n        put \"/t/#{post.topic_id}/remove_bookmarks.json\"\n        expect(Bookmark.for_user_in_topic(user.id, post.topic_id).count).to eq(0)\n      end\n    end\n  end\n\n  describe \"#bookmark\" do\n    before { sign_in(user) }\n\n    it \"should create a new bookmark for the topic\" do\n      post = create_post\n      post2 = create_post(topic_id: post.topic_id)\n      put \"/t/#{post.topic_id}/bookmark.json\"\n\n      expect(Bookmark.find_by(user_id: user.id).bookmarkable_id).to eq(post.topic_id)\n    end\n\n    it \"errors if the topic is already bookmarked for the user\" do\n      post = create_post\n      Bookmark.create(bookmarkable: post.topic, user: user)\n\n      put \"/t/#{post.topic_id}/bookmark.json\"\n      expect(response.status).to eq(400)\n    end\n  end\n\n  describe \"#reset_new\" do\n    context \"when a user is not signed in\" do\n      it \"fails\" do\n        put \"/topics/reset-new.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when a user is signed in\" do\n      before_all do\n        @old_date = 2.years.ago\n        user.user_stat.update_column(:new_since, @old_date)\n\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:tracking],\n          tracked_category.id,\n        )\n      end\n\n      let!(:old_date) { @old_date }\n\n      before { sign_in(user) }\n\n      context \"when tracked is unset\" do\n        it \"updates the `new_since` date\" do\n          TopicTrackingState.expects(:publish_dismiss_new)\n\n          put \"/topics/reset-new.json\"\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).not_to eq(old_date.to_date)\n        end\n      end\n\n      describe \"when tracked param is true\" do\n        it \"does not update user_stat.new_since\" do\n          put \"/topics/reset-new.json?tracked=true\"\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).to eq(old_date.to_date)\n        end\n\n        it \"creates dismissed topic user records for each new topic\" do\n          tracked_topic = create_post(category: tracked_category).topic\n\n          create_post # This is a new post, but is not tracked so a record will not be created for it\n          expect do put \"/topics/reset-new.json?tracked=true\" end.to change {\n            DismissedTopicUser.where(user_id: user.id, topic_id: tracked_topic.id).count\n          }.by(1)\n        end\n      end\n\n      context \"when 5 tracked topics exist\" do\n        before_all do\n          @tracked_topic_ids = 5.times.map { create_post(category: tracked_category).topic.id }\n          @tracked_topic_ids.freeze\n        end\n\n        describe \"when tracked param is true\" do\n          it \"creates dismissed topic user records if there are > 30 (default pagination) topics\" do\n            expect do\n              stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 2) do\n                put \"/topics/reset-new.json?tracked=true\"\n              end\n            end.to change {\n              DismissedTopicUser.where(user_id: user.id, topic_id: @tracked_topic_ids).count\n            }.by(5)\n          end\n\n          it \"creates dismissed topic user records if there are > 30 (default pagination) topics and topic_ids are provided\" do\n            dismissing_topic_ids = @tracked_topic_ids.sample(4)\n\n            expect do\n              stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 2) do\n                put \"/topics/reset-new.json?tracked=true\",\n                    params: {\n                      topic_ids: dismissing_topic_ids,\n                    }\n              end\n            end.to change {\n              DismissedTopicUser.where(user_id: user.id, topic_id: @tracked_topic_ids).count\n            }.by(4)\n          end\n        end\n\n        context \"when two extra topics exist\" do\n          before_all do\n            @topic_ids = @tracked_topic_ids + [Fabricate(:topic).id, Fabricate(:topic).id]\n            @topic_ids.freeze\n          end\n\n          context \"when tracked=false\" do\n            it \"updates the user_stat new_since column and dismisses all the new topics\" do\n              old_new_since = user.user_stat.new_since\n\n              put \"/topics/reset-new.json?tracked=false\"\n              expect(DismissedTopicUser.where(user_id: user.id, topic_id: @topic_ids).count).to eq(\n                7,\n              )\n              expect(user.reload.user_stat.new_since > old_new_since).to eq(true)\n            end\n\n            it \"does not pass topic ids that are not new for the user to the bulk action, limit the scope to new topics\" do\n              dismiss_ids = @topic_ids[0..1]\n              other_ids = @topic_ids[2..-1].sort.reverse\n\n              DismissedTopicUser.create(user_id: user.id, topic_id: dismiss_ids.first)\n              DismissedTopicUser.create(user_id: user.id, topic_id: dismiss_ids.second)\n\n              expect { put \"/topics/reset-new.json?tracked=false\" }.to change {\n                DismissedTopicUser.where(user_id: user.id).count\n              }.by(5)\n            end\n          end\n        end\n      end\n\n      context \"with category\" do\n        fab!(:subcategory) { Fabricate(:category, parent_category_id: category.id) }\n        fab!(:category_topic) { Fabricate(:topic, category: category) }\n        fab!(:subcategory_topic) { Fabricate(:topic, category: subcategory) }\n\n        it \"dismisses topics for main category\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [category_topic.id],\n          )\n\n          put \"/topics/reset-new.json?category_id=#{category.id}\"\n\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq(\n            [category_topic.id],\n          )\n        end\n\n        it \"dismisses topics for main category and subcategories\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [category_topic.id, subcategory_topic.id],\n          )\n\n          put \"/topics/reset-new.json?category_id=#{category.id}&include_subcategories=true\"\n\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id).sort).to eq(\n            [category_topic.id, subcategory_topic.id].sort,\n          )\n        end\n      end\n\n      context \"with tag\" do\n        fab!(:tag_topic) { Fabricate(:topic) }\n        fab!(:topic_tag) { Fabricate(:topic_tag, topic: tag_topic, tag: tag) }\n\n        it \"dismisses topics for tag\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(user.id, topic_ids: [tag_topic.id])\n          put \"/topics/reset-new.json?tag_id=#{tag.name}\"\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq([tag_topic.id])\n        end\n      end\n\n      context \"with tag and category\" do\n        fab!(:tag_topic) { Fabricate(:topic) }\n        fab!(:topic_tag) { Fabricate(:topic_tag, topic: tag_topic, tag: tag) }\n        fab!(:tag_and_category_topic) { Fabricate(:topic, category: category) }\n        fab!(:topic_tag2) { Fabricate(:topic_tag, topic: tag_and_category_topic, tag: tag) }\n\n        it \"dismisses topics for tag\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [tag_and_category_topic.id],\n          )\n          put \"/topics/reset-new.json?tag_id=#{tag.name}&category_id=#{category.id}\"\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq(\n            [tag_and_category_topic.id],\n          )\n        end\n      end\n\n      context \"with specific topics\" do\n        fab!(:topic2) { Fabricate(:topic) }\n        fab!(:topic3) { Fabricate(:topic) }\n\n        it \"updates the `new_since` date\" do\n          TopicTrackingState\n            .expects(:publish_dismiss_new)\n            .with(user.id, topic_ids: [topic2.id, topic3.id])\n            .at_least_once\n\n          put \"/topics/reset-new.json\", **{ params: { topic_ids: [topic2.id, topic3.id] } }\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).not_to eq(old_date.to_date)\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to match_array(\n            [topic2.id, topic3.id],\n          )\n        end\n\n        it \"raises an error if topic_ids is provided and it is not an array\" do\n          put \"/topics/reset-new.json\", params: { topic_ids: topic2.id }\n          expect(response.parsed_body[\"errors\"].first).to match(\n            /Expecting topic_ids to contain a list/,\n          )\n          put \"/topics/reset-new.json\", params: { topic_ids: [topic2.id] }\n          expect(response.parsed_body[\"errors\"]).to eq(nil)\n        end\n\n        describe \"when tracked param is true\" do\n          it \"does not update user_stat.new_since and does not dismiss untracked topics\" do\n            put \"/topics/reset-new.json?tracked=true\",\n                **{ params: { topic_ids: [topic2.id, topic3.id] } }\n            expect(response.status).to eq(200)\n            user.reload\n            expect(user.user_stat.new_since.to_date).to eq(old_date.to_date)\n            expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to be_empty\n          end\n\n          it \"creates topic user records for each unread topic\" do\n            tracked_topic = create_post.topic\n            tracked_topic.update!(category_id: tracked_category.id)\n            topic2.update!(category_id: tracked_category.id)\n\n            create_post # This is a new post, but is not tracked so a record will not be created for it\n            expect do\n              put \"/topics/reset-new.json?tracked=true\",\n                  **{ params: { topic_ids: [tracked_topic.id, topic2.id, topic3.id] } }\n            end.to change { DismissedTopicUser.where(user_id: user.id).count }.by(2)\n            expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to match_array(\n              [tracked_topic.id, topic2.id],\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#feature_stats\" do\n    it \"works\" do\n      get \"/topics/feature_stats.json\", params: { category_id: 1 }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"pinned_in_category_count\"]).to eq(0)\n      expect(json[\"pinned_globally_count\"]).to eq(0)\n      expect(json[\"banner_count\"]).to eq(0)\n    end\n\n    it \"allows unlisted banner topic\" do\n      Fabricate(:topic, category_id: 1, archetype: Archetype.banner, visible: false)\n\n      get \"/topics/feature_stats.json\", params: { category_id: 1 }\n      json = response.parsed_body\n      expect(json[\"banner_count\"]).to eq(1)\n    end\n  end\n\n  describe \"#excerpts\" do\n    it \"can correctly get excerpts\" do\n      first_post =\n        create_post(raw: \"This is the first post :)\", title: \"This is a test title I am making yay\")\n      second_post = create_post(raw: \"This is second post\", topic: first_post.topic)\n      third_post = first_post.topic.add_small_action(first_post.user, \"autobumped\")\n\n      random_post = Fabricate(:post, user: post_author1)\n\n      get \"/t/#{first_post.topic_id}/excerpts.json\",\n          params: {\n            post_ids: [first_post.id, second_post.id, third_post.id, random_post.id],\n          }\n\n      json = response.parsed_body\n      json.sort! { |a, b| a[\"post_id\"] <=> b[\"post_id\"] }\n\n      # no random post\n      expect(json.map { |p| p[\"post_id\"] }).to contain_exactly(\n        first_post.id,\n        second_post.id,\n        third_post.id,\n      )\n      # keep emoji images\n      expect(json[0][\"excerpt\"]).to match(/emoji/)\n      expect(json[0][\"excerpt\"]).to match(/first post/)\n      expect(json[0][\"username\"]).to eq(first_post.user.username)\n      expect(json[0][\"created_at\"].present?).to eq(false)\n\n      expect(json[1][\"excerpt\"]).to match(/second post/)\n\n      expect(json[2][\"action_code\"]).to eq(\"autobumped\")\n      expect(json[2][\"created_at\"].present?).to eq(true)\n    end\n  end\n\n  describe \"#convert_topic\" do\n    it \"needs you to be logged in\" do\n      put \"/t/111/convert-topic/private.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"converting public topic to private message\" do\n      fab!(:topic) { Fabricate(:topic, user: user) }\n      fab!(:post) { Fabricate(:post, user: user, topic: topic) }\n\n      before { Group.refresh_automatic_groups! }\n\n      it \"raises an error when the user doesn't have permission to convert topic\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/convert-topic/private.json\"\n        expect(response).to be_forbidden\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          sign_in(admin)\n          put \"/t/#{topic.id}/convert-topic/private.json\"\n\n          topic.reload\n          expect(topic.archetype).to eq(Archetype.private_message)\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n\n    describe \"converting private message to public topic\" do\n      fab!(:topic) { Fabricate(:private_message_topic, user: user) }\n      fab!(:post) { Fabricate(:post, user: post_author1, topic: topic) }\n\n      before { Group.refresh_automatic_groups! }\n\n      it \"raises an error when the user doesn't have permission to convert topic\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/convert-topic/public.json\"\n        expect(response).to be_forbidden\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          sign_in(admin)\n          put \"/t/#{topic.id}/convert-topic/public.json?category_id=#{category.id}\"\n\n          topic.reload\n          expect(topic.archetype).to eq(Archetype.default)\n          expect(topic.category_id).to eq(category.id)\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#timings\" do\n    fab!(:post_1) { Fabricate(:post, user: post_author1, topic: topic) }\n\n    it \"should record the timing\" do\n      sign_in(user)\n\n      post \"/topics/timings.json\",\n           params: {\n             topic_id: topic.id,\n             topic_time: 5,\n             timings: {\n               post_1.post_number => 2,\n             },\n           }\n\n      expect(response.status).to eq(200)\n\n      post_timing = PostTiming.first\n\n      expect(post_timing.topic).to eq(topic)\n      expect(post_timing.user).to eq(user)\n      expect(post_timing.msecs).to eq(2)\n    end\n\n    it \"caps post read time at the max integer value (2^31 - 1)\" do\n      PostTiming.create!(\n        topic_id: post_1.topic.id,\n        post_number: post_1.post_number,\n        user_id: user.id,\n        msecs: 2**31 - 10,\n      )\n      sign_in(user)\n\n      post \"/topics/timings.json\",\n           params: {\n             topic_id: topic.id,\n             topic_time: 5,\n             timings: {\n               post_1.post_number => 100,\n             },\n           }\n\n      expect(response.status).to eq(200)\n      post_timing = PostTiming.first\n\n      expect(post_timing.topic).to eq(topic)\n      expect(post_timing.user).to eq(user)\n      expect(post_timing.msecs).to eq(2**31 - 1)\n    end\n  end\n\n  describe \"#timer\" do\n    context \"when a user is not logged in\" do\n      it \"should return the right response\" do\n        post \"/t/#{topic.id}/timer.json\", params: { time: \"24\", status_type: TopicTimer.types[1] }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when does not have permission\" do\n      it \"should return the right response\" do\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: \"24\", status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n    end\n\n    context \"when time is in the past\" do\n      it \"returns an error\" do\n        freeze_time\n        sign_in(admin)\n\n        post \"/t/#{topic.id}/timer.json\",\n             params: {\n               time: Time.current - 1.day,\n               status_type: TopicTimer.types[1],\n             }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when logged in as an admin\" do\n      before do\n        freeze_time\n        sign_in(admin)\n      end\n\n      it \"should be able to create a topic status update\" do\n        post \"/t/#{topic.id}/timer.json\", params: { time: 24, status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(200)\n\n        topic_status_update = TopicTimer.last\n\n        expect(topic_status_update.topic).to eq(topic)\n        expect(topic_status_update.execute_at).to eq_time(24.hours.from_now)\n\n        json = response.parsed_body\n\n        expect(DateTime.parse(json[\"execute_at\"])).to eq_time(\n          DateTime.parse(topic_status_update.execute_at.to_s),\n        )\n\n        expect(json[\"duration_minutes\"]).to eq(topic_status_update.duration_minutes)\n        expect(json[\"closed\"]).to eq(topic.reload.closed)\n      end\n\n      it \"should be able to delete a topic status update\" do\n        Fabricate(:topic_timer, topic: topic)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: nil, status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.public_topic_timer).to eq(nil)\n\n        json = response.parsed_body\n\n        expect(json[\"execute_at\"]).to eq(nil)\n        expect(json[\"duration_minutes\"]).to eq(nil)\n        expect(json[\"closed\"]).to eq(topic.closed)\n      end\n\n      it \"should be able to create a topic status update with duration\" do\n        post \"/t/#{topic.id}/timer.json\",\n             params: {\n               duration_minutes: 7200,\n               status_type: TopicTimer.types[7],\n             }\n\n        expect(response.status).to eq(200)\n\n        topic_status_update = TopicTimer.last\n\n        expect(topic_status_update.topic).to eq(topic)\n        expect(topic_status_update.execute_at).to eq_time(5.days.from_now)\n        expect(topic_status_update.duration_minutes).to eq(7200)\n\n        json = response.parsed_body\n\n        expect(DateTime.parse(json[\"execute_at\"])).to eq_time(\n          DateTime.parse(topic_status_update.execute_at.to_s),\n        )\n\n        expect(json[\"duration_minutes\"]).to eq(topic_status_update.duration_minutes)\n      end\n\n      it \"should be able to delete a topic status update for delete_replies type\" do\n        Fabricate(:topic_timer, topic: topic, status_type: TopicTimer.types[:delete_replies])\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: nil, status_type: TopicTimer.types[7] }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.public_topic_timer).to eq(nil)\n\n        json = response.parsed_body\n\n        expect(json[\"execute_at\"]).to eq(nil)\n        expect(json[\"duration\"]).to eq(nil)\n        expect(json[\"closed\"]).to eq(topic.closed)\n      end\n\n      describe \"publishing topic to category in the future\" do\n        it \"should be able to create the topic status update\" do\n          post \"/t/#{topic.id}/timer.json\",\n               params: {\n                 time: 24,\n                 status_type: TopicTimer.types[3],\n                 category_id: topic.category_id,\n               }\n\n          expect(response.status).to eq(200)\n\n          topic_status_update = TopicTimer.last\n\n          expect(topic_status_update.topic).to eq(topic)\n          expect(topic_status_update.execute_at).to eq_time(24.hours.from_now)\n          expect(topic_status_update.status_type).to eq(TopicTimer.types[:publish_to_category])\n\n          json = response.parsed_body\n\n          expect(json[\"category_id\"]).to eq(topic.category_id)\n        end\n      end\n\n      describe \"invalid status type\" do\n        it \"should raise the right error\" do\n          post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"something\" }\n          expect(response.status).to eq(400)\n          expect(response.body).to include(\"status_type\")\n        end\n      end\n    end\n\n    context \"when logged in as a TL4 user\" do\n      before { SiteSetting.enable_category_group_moderation = true }\n      it \"raises an error if the user can't see the topic\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        pm_topic = Fabricate(:private_message_topic)\n\n        post \"/t/#{pm_topic.id}/timer.json\",\n             params: {\n               time: \"24\",\n               status_type: TopicTimer.types[1],\n             }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n\n      it \"allows a category moderator to create a delete timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        topic.category.update!(reviewable_by_group: user.groups.first)\n\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete\" }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error setting a delete timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete\" }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n\n      it \"raises an error setting delete_replies timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete_replies\" }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n    end\n  end\n\n  describe \"#set_slow_mode\" do\n    context \"when not logged in\" do\n      it \"returns a forbidden response\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in as an admin\" do\n      it \"allows admins to set the slow mode interval\" do\n        sign_in(admin)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        topic.reload\n        expect(response.status).to eq(200)\n        expect(topic.slow_mode_seconds).to eq(3600)\n      end\n    end\n\n    context \"when logged in as a regular user\" do\n      it \"does nothing if the user is not TL4\" do\n        user.update!(trust_level: TrustLevel[3])\n        sign_in(user)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows TL4 users to set the slow mode interval\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        topic.reload\n        expect(response.status).to eq(200)\n        expect(topic.slow_mode_seconds).to eq(3600)\n      end\n    end\n\n    context \"with auto-disable slow mode\" do\n      before { sign_in(admin) }\n\n      let!(:timestamp) { 1.week.from_now.to_formatted_s(:iso8601) }\n\n      it \"sets a topic timer to clear the slow mode automatically\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n        execute_at = created_timer.execute_at.to_formatted_s(:iso8601)\n\n        expect(execute_at).to eq(timestamp)\n      end\n\n      it \"deletes the topic timer\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"0\", enabled_until: timestamp }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n\n        expect(created_timer).to be_nil\n      end\n\n      it \"updates the existing timer\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        updated_timestamp = 1.hour.from_now.to_formatted_s(:iso8601)\n\n        put \"/t/#{topic.id}/slow_mode.json\",\n            params: {\n              seconds: \"3600\",\n              enabled_until: updated_timestamp,\n            }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n        execute_at = created_timer.execute_at.to_formatted_s(:iso8601)\n\n        expect(execute_at).to eq(updated_timestamp)\n      end\n    end\n  end\n\n  describe \"#invite\" do\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        post \"/t/#{topic.id}/invite.json\", params: { email: \"jake@adventuretime.ooo\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      context \"when topic id is not PM\" do\n        fab!(:user_topic) { Fabricate(:topic, user: user) }\n\n        it \"should return the right response\" do\n          user.update!(trust_level: SiteSetting.min_trust_level_to_allow_invite)\n\n          post \"/t/#{user_topic.id}/invite.json\", params: { email: \"someguy@email.com\" }\n\n          expect(response.status).to eq(422)\n        end\n      end\n\n      context \"when topic id is invalid\" do\n        it \"should return the right response\" do\n          id = topic.id\n          topic.destroy!\n          post \"/t/#{id}/invite.json\", params: { email: user.email }\n\n          expect(response.status).to eq(404)\n        end\n      end\n\n      it \"requires an email parameter\" do\n        post \"/t/#{topic.id}/invite.json\"\n        expect(response.status).to eq(422)\n      end\n\n      context \"when PM has reached maximum allowed numbers of recipients\" do\n        fab!(:pm) { Fabricate(:private_message_topic, user: user) }\n\n        fab!(:moderator_pm) { Fabricate(:private_message_topic, user: moderator) }\n\n        before do\n          SiteSetting.max_allowed_message_recipients = 2\n          Group.refresh_automatic_groups!\n        end\n\n        it \"doesn't allow normal users to invite\" do\n          post \"/t/#{pm.id}/invite.json\", params: { user: user_2.username }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to contain_exactly(\n            I18n.t(\n              \"pm_reached_recipients_limit\",\n              recipients_limit: SiteSetting.max_allowed_message_recipients,\n            ),\n          )\n        end\n\n        it \"allows staff to bypass limits\" do\n          sign_in(moderator)\n          post \"/t/#{moderator_pm.id}/invite.json\", params: { user: user_2.username }\n          expect(response.status).to eq(200)\n          expect(moderator_pm.reload.topic_allowed_users.count).to eq(3)\n        end\n      end\n\n      context \"when user does not have permission to invite to the topic\" do\n        fab!(:topic) { pm }\n\n        it \"should return the right response\" do\n          post \"/t/#{topic.id}/invite.json\", params: { user: user.username }\n\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe \"invite_group\" do\n    let!(:admins) { Group[:admins] }\n\n    def invite_group(topic, expected_status)\n      post \"/t/#{topic.id}/invite-group.json\", params: { group: admins.name }\n      expect(response.status).to eq(expected_status)\n    end\n\n    before { admins.update!(messageable_level: Group::ALIAS_LEVELS[:everyone]) }\n\n    context \"as an anon user\" do\n      it \"should be forbidden\" do\n        invite_group(pm, 403)\n      end\n    end\n\n    context \"as a normal user\" do\n      before { sign_in(user) }\n\n      context \"when user does not have permission to view the topic\" do\n        it \"should be forbidden\" do\n          invite_group(pm, 403)\n        end\n      end\n\n      context \"when user has permission to view the topic\" do\n        before { pm.allowed_users << user }\n\n        it \"should allow user to invite group to topic\" do\n          invite_group(pm, 200)\n          expect(pm.allowed_groups.first.id).to eq(admins.id)\n        end\n      end\n    end\n\n    context \"as an admin user\" do\n      before { sign_in(admin) }\n\n      it \"disallows inviting a group to a topic\" do\n        invite_group(topic, 422)\n      end\n\n      it \"allows inviting a group to a PM\" do\n        invite_group(pm, 200)\n        expect(pm.allowed_groups.first.id).to eq(admins.id)\n      end\n    end\n\n    context \"when PM has reached maximum allowed numbers of recipients\" do\n      fab!(:group) { Fabricate(:group, messageable_level: 99) }\n      fab!(:pm) { Fabricate(:private_message_topic, user: user) }\n\n      fab!(:moderator_pm) { Fabricate(:private_message_topic, user: moderator) }\n\n      before { SiteSetting.max_allowed_message_recipients = 2 }\n\n      it \"doesn't allow normal users to invite\" do\n        post \"/t/#{pm.id}/invite-group.json\", params: { group: group.name }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to contain_exactly(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      end\n\n      it \"allows staff to bypass limits\" do\n        sign_in(moderator)\n        post \"/t/#{moderator_pm.id}/invite-group.json\", params: { group: group.name }\n        expect(response.status).to eq(200)\n        expect(\n          moderator_pm.reload.topic_allowed_users.count + moderator_pm.topic_allowed_groups.count,\n        ).to eq(3)\n      end\n    end\n  end\n\n  describe \"shared drafts\" do\n    before { SiteSetting.shared_drafts_category = shared_drafts_category.id }\n\n    describe \"#update_shared_draft\" do\n      fab!(:other_cat) { Fabricate(:category) }\n      fab!(:topic) { Fabricate(:topic, category: shared_drafts_category, visible: false) }\n\n      context \"when anonymous\" do\n        it \"doesn't allow staff to update the shared draft\" do\n          put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n          expect(response.code.to_i).to eq(403)\n        end\n      end\n\n      context \"as a moderator\" do\n        before { sign_in(moderator) }\n\n        context \"with a shared draft\" do\n          fab!(:shared_draft) { Fabricate(:shared_draft, topic: topic, category: category) }\n          it \"allows staff to update the category id\" do\n            put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n            expect(response.status).to eq(200)\n            topic.reload\n            expect(topic.shared_draft.category_id).to eq(other_cat.id)\n          end\n        end\n\n        context \"without a shared draft\" do\n          it \"allows staff to update the category id\" do\n            put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n            expect(response.status).to eq(200)\n            topic.reload\n            expect(topic.shared_draft.category_id).to eq(other_cat.id)\n          end\n        end\n      end\n    end\n\n    describe \"#publish\" do\n      fab!(:topic) { Fabricate(:topic, category: shared_drafts_category, visible: false) }\n      fab!(:post) { Fabricate(:post, user: post_author1, topic: topic) }\n\n      it \"fails for anonymous users\" do\n        put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails as a regular user\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n        expect(response.status).to eq(403)\n      end\n\n      context \"as staff\" do\n        before { sign_in(moderator) }\n\n        it \"will publish the topic\" do\n          put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n          expect(response.status).to eq(200)\n          json = response.parsed_body[\"basic_topic\"]\n\n          result = Topic.find(json[\"id\"])\n          expect(result.category_id).to eq(category.id)\n          expect(result.visible).to eq(true)\n        end\n\n        it \"fails if the destination category is the shared drafts category\" do\n          put \"/t/#{topic.id}/publish.json\",\n              params: {\n                destination_category_id: shared_drafts_category.id,\n              }\n          expect(response.status).to eq(400)\n        end\n      end\n    end\n  end\n\n  describe \"crawler\" do\n    context \"when not a crawler\" do\n      it \"renders with the application layout\" do\n        get topic.url\n\n        body = response.body\n\n        expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n      end\n    end\n\n    context \"when a crawler\" do\n      it \"renders with the crawler layout, and handles proper pagination\" do\n        page1_time = 3.months.ago\n        page2_time = 2.months.ago\n        page3_time = 1.month.ago\n\n        freeze_time page1_time\n\n        Fabricate(:post, user: post_author2, topic: topic)\n        Fabricate(:post, user: post_author3, topic: topic)\n\n        freeze_time page2_time\n        Fabricate(:post, user: post_author4, topic: topic)\n        Fabricate(:post, user: post_author5, topic: topic)\n\n        freeze_time page3_time\n        Fabricate(:post, user: post_author6, topic: topic)\n\n        # ugly, but no interface to set this and we don't want to create\n        # 100 posts to test this thing\n        TopicView.stubs(:chunk_size).returns(2)\n\n        user_agent = \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n\n        get topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n\n        body = response.body\n\n        expect(body).to have_tag(:body, with: { class: \"crawler\" })\n        expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        expect(body).to include('<link rel=\"next\" href=\"' + topic.relative_url + \"?page=2\")\n\n        expect(body).to include(\"id='post_1'\")\n        expect(body).to include(\"id='post_2'\")\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page1_time.httpdate)\n\n        get topic.url + \"?page=2\", env: { \"HTTP_USER_AGENT\" => user_agent }\n        body = response.body\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page2_time.httpdate)\n\n        expect(body).to include(\"id='post_3'\")\n        expect(body).to include(\"id='post_4'\")\n\n        expect(body).to include('<link rel=\"prev\" href=\"' + topic.relative_url)\n        expect(body).to include('<link rel=\"next\" href=\"' + topic.relative_url + \"?page=3\")\n\n        get topic.url + \"?page=3\", env: { \"HTTP_USER_AGENT\" => user_agent }\n        body = response.body\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page3_time.httpdate)\n        expect(body).to include('<link rel=\"prev\" href=\"' + topic.relative_url + \"?page=2\")\n      end\n\n      context \"with canonical_url\" do\n        fab!(:topic_embed) { Fabricate(:topic_embed, embed_url: \"https://markvanlan.com\") }\n        let!(:user_agent) do\n          \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n        end\n\n        it \"set to topic.url when embed_set_canonical_url is false\" do\n          get topic_embed.topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n          expect(response.body).to include('<link rel=\"canonical\" href=\"' + topic_embed.topic.url)\n        end\n\n        it \"set to topic_embed.embed_url when embed_set_canonical_url is true\" do\n          SiteSetting.embed_set_canonical_url = true\n          get topic_embed.topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n          expect(response.body).to include('<link rel=\"canonical\" href=\"' + topic_embed.embed_url)\n        end\n      end\n\n      context \"with wayback machine\" do\n        it \"renders crawler layout\" do\n          get topic.url,\n              env: {\n                \"HTTP_USER_AGENT\" =>\n                  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\",\n                \"HTTP_VIA\" => \"HTTP/1.0 web.archive.org (Wayback Save Page)\",\n              }\n          body = response.body\n\n          expect(body).to have_tag(:body, with: { class: \"crawler\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n    end\n  end\n\n  describe \"#reset_bump_date\" do\n    context \"with errors\" do\n      it \"needs you to be logged in\" do\n        put \"/t/#{topic.id}/reset-bump-date.json\"\n        expect(response.status).to eq(403)\n      end\n\n      [:user].each do |user|\n        it \"denies access for #{user}\" do\n          sign_in(Fabricate(user))\n          put \"/t/#{topic.id}/reset-bump-date.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      it \"should fail for non-existent topic\" do\n        max_id = Topic.maximum(:id)\n        sign_in(admin)\n        put \"/t/#{max_id + 1}/reset-bump-date.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    %i[admin moderator trust_level_4].each do |user|\n      it \"should reset bumped_at as #{user}\" do\n        sign_in(public_send(user))\n        topic.update!(bumped_at: 1.hour.ago)\n        timestamp = 1.day.ago\n        Fabricate(:post, user: post_author1, topic: topic, created_at: timestamp)\n\n        put \"/t/#{topic.id}/reset-bump-date.json\"\n        expect(response.status).to eq(200)\n        expect(topic.reload.bumped_at).to eq_time(timestamp)\n      end\n    end\n  end\n\n  describe \"#private_message_reset_new\" do\n    before_all { Group.refresh_automatic_groups! }\n\n    fab!(:group) do\n      Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap { |g| g.add(user_2) }\n    end\n\n    fab!(:group_message) do\n      create_post(\n        user: user,\n        target_group_names: [group.name],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    fab!(:private_message) do\n      create_post(\n        user: user,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    fab!(:private_message_2) do\n      create_post(\n        user: user,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    before { sign_in(user_2) }\n\n    it \"returns the right response when inbox param is missing\" do\n      put \"/topics/pm-reset-new.json\"\n\n      expect(response.status).to eq(400)\n    end\n\n    it \"returns the right response when trying to reset new private messages of an invalid group\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: \"randomgroup\" }\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns the right response when trying to reset new private messages of a restricted group\" do\n      sign_in(user)\n\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: group.name }\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"can reset all new group private messages\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: group.name }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_ids\"]).to contain_exactly(group_message.id)\n\n      expect(DismissedTopicUser.count).to eq(1)\n\n      expect(DismissedTopicUser.exists?(topic: group_message, user: user_2)).to eq(true)\n    end\n\n    it \"can reset new personal private messages\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"user\" }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_ids\"]).to contain_exactly(\n        private_message.id,\n        private_message_2.id,\n      )\n\n      expect(DismissedTopicUser.count).to eq(2)\n\n      expect(\n        DismissedTopicUser.exists?(user: user_2, topic: [private_message, private_message_2]),\n      ).to eq(true)\n    end\n\n    it \"can reset new personal and group private messages\" do\n      stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n        put \"/topics/pm-reset-new.json\", params: { inbox: \"all\" }\n\n        expect(response.status).to eq(200)\n\n        expect(DismissedTopicUser.count).to eq(3)\n\n        expect(\n          DismissedTopicUser.exists?(\n            user: user_2,\n            topic: [private_message, private_message_2, group_message],\n          ),\n        ).to eq(true)\n      end\n    end\n\n    it \"returns the right response is topic_ids params is not valid\" do\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: \"1\" }\n\n      expect(response.status).to eq(400)\n    end\n\n    it \"can reset new private messages from given topic ids\" do\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: [group_message.id, \"12345\"] }\n\n      expect(response.status).to eq(200)\n\n      expect(DismissedTopicUser.count).to eq(1)\n\n      expect(DismissedTopicUser.exists?(topic: group_message, user: user_2)).to eq(true)\n\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: [private_message.id, \"12345\"] }\n\n      expect(response.status).to eq(200)\n\n      expect(DismissedTopicUser.exists?(topic: private_message, user: user_2)).to eq(true)\n    end\n  end\n\n  describe \"#archive_message\" do\n    before_all { Group.refresh_automatic_groups! }\n\n    fab!(:group) do\n      Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap { |g| g.add(user) }\n    end\n\n    fab!(:group_message) do\n      create_post(\n        user: user,\n        target_group_names: [group.name],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    it \"should be able to archive a private message\" do\n      sign_in(user)\n\n      message =\n        MessageBus\n          .track_publish(PrivateMessageTopicTrackingState.group_channel(group.id)) do\n            put \"/t/#{group_message.id}/archive-message.json\"\n\n            expect(response.status).to eq(200)\n          end\n          .first\n\n      expect(message.data[\"message_type\"]).to eq(\n        PrivateMessageTopicTrackingState::GROUP_ARCHIVE_MESSAGE_TYPE,\n      )\n\n      expect(message.data[\"payload\"][\"acting_user_id\"]).to eq(user.id)\n\n      body = response.parsed_body\n\n      expect(body[\"group_name\"]).to eq(group.name)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"ostruct\"\n\nRSpec.describe \"topics/show.html.erb\" do\n  fab!(:topic) { Fabricate(:topic) }\n\n  it \"add nofollow to RSS alternate link for topic\" do\n    topic_view = OpenStruct.new(topic: topic, posts: [])\n    topic_view.stubs(:summary).returns(\"\")\n    view.stubs(:crawler_layout?).returns(false)\n    view.stubs(:url_for).returns(\"https://www.example.com/test.rss\")\n    view.instance_variable_set(\"@topic_view\", topic_view)\n    render template: \"topics/show\", formats: [:html]\n\n    expect(view.content_for(:head)).to match(\n      %r{<link rel=\"alternate nofollow\" type=\"application/rss\\+xml\" title=\"[^\"]+\" href=\"https://www.example.com/test\\.rss\" />},\n    )\n  end\n\n  it \"adds sturctured data\" do\n    view.stubs(:include_crawler_content?).returns(true)\n    post = Fabricate(:post, topic: topic)\n    TopicLink.create!(\n      topic_id: post.topic_id,\n      post_id: post.id,\n      user_id: post.user_id,\n      url: \"https://example.com/\",\n      domain: \"example.com\",\n      link_topic_id: Fabricate(:topic).id,\n      reflection: true,\n    )\n    assign(:topic_view, TopicView.new(topic))\n    assign(:tags, [])\n\n    render template: \"topics/show\", formats: [:html]\n\n    links_list = Nokogiri::HTML5.fragment(rendered).css(\".crawler-linkback-list\")\n    first_item = links_list.css('[itemprop=\"itemListElement\"]')\n    expect(first_item.css('[itemprop=\"position\"]')[0][\"content\"]).to eq(\"1\")\n    expect(first_item.css('[itemprop=\"url\"]')[0][\"href\"]).to eq(\"https://example.com/\")\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass TopicsController < ApplicationController\n  requires_login only: %i[\n                   timings\n                   destroy_timings\n                   update\n                   update_shared_draft\n                   destroy\n                   recover\n                   status\n                   invite\n                   mute\n                   unmute\n                   set_notifications\n                   move_posts\n                   merge_topic\n                   clear_pin\n                   re_pin\n                   status_update\n                   timer\n                   bulk\n                   reset_new\n                   change_post_owners\n                   change_timestamps\n                   archive_message\n                   move_to_inbox\n                   convert_topic\n                   bookmark\n                   publish\n                   reset_bump_date\n                   set_slow_mode\n                 ]\n\n  before_action :consider_user_for_promotion, only: :show\n\n  skip_before_action :check_xhr, only: %i[show feed]\n\n  def id_for_slug\n    topic = Topic.find_by_slug(params[:slug])\n    guardian.ensure_can_see!(topic)\n    raise Discourse::NotFound unless topic\n    render json: { slug: topic.slug, topic_id: topic.id, url: topic.url }\n  end\n\n  def show_by_external_id\n    topic = Topic.find_by(external_id: params[:external_id])\n    raise Discourse::NotFound unless topic\n    guardian.ensure_can_see!(topic)\n    redirect_to_correct_topic(topic, params[:post_number])\n  end\n\n  def show\n    flash[\"referer\"] ||= request.referer[0..255] if request.referer\n\n    # We'd like to migrate the wordpress feed to another url. This keeps up backwards compatibility with\n    # existing installs.\n    return wordpress if params[:best].present?\n\n    # work around people somehow sending in arrays,\n    # arrays are not supported\n    params[:page] = begin\n      params[:page].to_i\n    rescue StandardError\n      1\n    end\n\n    opts =\n      params.slice(\n        :username_filters,\n        :filter,\n        :page,\n        :post_number,\n        :show_deleted,\n        :replies_to_post_number,\n        :filter_upwards_post_id,\n        :filter_top_level_replies,\n      )\n    username_filters = opts[:username_filters]\n\n    opts[:print] = true if params[:print] == \"true\"\n    opts[:username_filters] = username_filters.split(\",\") if username_filters.is_a?(String)\n\n    # Special case: a slug with a number in front should look by slug first before looking\n    # up that particular number\n    if params[:id] && params[:id] =~ /\\A\\d+[^\\d\\\\]+\\z/\n      topic = Topic.find_by_slug(params[:id])\n      return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n    end\n\n    if opts[:print]\n      raise Discourse::InvalidAccess if SiteSetting.max_prints_per_hour_per_user.zero?\n      begin\n        unless @guardian.is_admin?\n          RateLimiter.new(\n            current_user,\n            \"print-topic-per-hour\",\n            SiteSetting.max_prints_per_hour_per_user,\n            1.hour,\n          ).performed!\n        end\n      rescue RateLimiter::LimitExceeded\n        return render_json_error I18n.t(\"rate_limiter.slow_down\")\n      end\n    end\n\n    begin\n      @topic_view = TopicView.new(params[:id] || params[:topic_id], current_user, opts)\n    rescue Discourse::NotFound => ex\n      if params[:id]\n        topic = Topic.find_by_slug(params[:id])\n        return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n      end\n\n      raise ex\n    rescue Discourse::NotLoggedIn => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    rescue Discourse::InvalidAccess => ex\n      # If the user can't see the topic, clean up notifications for it.\n      Notification.remove_for(current_user.id, params[:topic_id]) if current_user\n\n      deleted =\n        guardian.can_see_topic?(ex.obj, false) ||\n          (!guardian.can_see_topic?(ex.obj) && ex.obj&.access_topic_via_group && ex.obj.deleted_at)\n\n      if SiteSetting.detailed_404\n        if deleted\n          raise Discourse::NotFound.new(\n                  \"deleted topic\",\n                  custom_message: \"deleted_topic\",\n                  status: 410,\n                  check_permalinks: true,\n                  original_path: ex.obj.relative_url,\n                )\n        elsif !guardian.can_see_topic?(ex.obj) && group = ex.obj&.access_topic_via_group\n          raise Discourse::InvalidAccess.new(\n                  \"not in group\",\n                  ex.obj,\n                  custom_message: \"not_in_group.title_topic\",\n                  custom_message_params: {\n                    group: group.name,\n                  },\n                  group: group,\n                )\n        end\n\n        raise ex\n      else\n        raise Discourse::NotFound.new(\n                nil,\n                check_permalinks: deleted,\n                original_path: ex.obj.relative_url,\n              )\n      end\n    end\n\n    page = params[:page]\n    if (page < 0) || ((page - 1) * @topic_view.chunk_size >= @topic_view.topic.highest_post_number)\n      raise Discourse::NotFound\n    end\n\n    discourse_expires_in 1.minute\n\n    if slugs_do_not_match || (!request.format.json? && params[:slug].nil?)\n      redirect_to_correct_topic(@topic_view.topic, opts[:post_number])\n      return\n    end\n\n    track_visit_to_topic\n\n    if should_track_visit_to_topic?\n      @topic_view.draft = Draft.get(current_user, @topic_view.draft_key, @topic_view.draft_sequence)\n    end\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex\" unless @topic_view.topic.visible\n\n    canonical_url UrlHelper.absolute_without_cdn(@topic_view.canonical_path)\n\n    # provide hint to crawlers only for now\n    # we would like to give them a bit more signal about age of data\n    if use_crawler_layout?\n      if last_modified = @topic_view.posts&.map { |p| p.updated_at }&.max&.httpdate\n        response.headers[\"Last-Modified\"] = last_modified\n      end\n    end\n\n    perform_show_response\n  end\n\n  def publish\n    params.permit(:id, :destination_category_id)\n\n    topic = Topic.find(params[:id])\n    category = Category.find(params[:destination_category_id])\n\n    raise Discourse::InvalidParameters if category.id == SiteSetting.shared_drafts_category.to_i\n\n    guardian.ensure_can_publish_topic!(topic, category)\n    topic = TopicPublisher.new(topic, current_user, category.id).publish!\n\n    render_serialized(topic.reload, BasicTopicSerializer)\n  end\n\n  def wordpress\n    params.require(:best)\n    params.require(:topic_id)\n    params.permit(\n      :min_trust_level,\n      :min_score,\n      :min_replies,\n      :bypass_trust_level_score,\n      :only_moderator_liked,\n    )\n\n    opts = {\n      best: params[:best].to_i,\n      min_trust_level: params[:min_trust_level] ? params[:min_trust_level].to_i : 1,\n      min_score: params[:min_score].to_i,\n      min_replies: params[:min_replies].to_i,\n      bypass_trust_level_score: params[:bypass_trust_level_score].to_i, # safe cause 0 means ignore\n      only_moderator_liked: params[:only_moderator_liked].to_s == \"true\",\n      exclude_hidden: true,\n    }\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, opts)\n    discourse_expires_in 1.minute\n\n    wordpress_serializer =\n      TopicViewWordpressSerializer.new(@topic_view, scope: guardian, root: false)\n    render_json_dump(wordpress_serializer)\n  end\n\n  def post_ids\n    params.require(:topic_id)\n    params.permit(:post_number, :username_filters, :filter)\n\n    options = {\n      filter_post_number: params[:post_number],\n      filter: params[:filter],\n      skip_limit: true,\n      asc: true,\n      skip_custom_fields: true,\n    }\n\n    fetch_topic_view(options)\n    render_json_dump(post_ids: @topic_view.posts.pluck(:id))\n  end\n\n  def posts\n    params.require(:topic_id)\n    params.permit(:post_ids, :post_number, :username_filters, :filter, :include_suggested)\n\n    include_suggested = params[:include_suggested] == \"true\"\n\n    options = {\n      filter_post_number: params[:post_number],\n      post_ids: params[:post_ids],\n      asc: ActiveRecord::Type::Boolean.new.deserialize(params[:asc]),\n      filter: params[:filter],\n      include_suggested: include_suggested,\n      include_related: include_suggested,\n    }\n\n    fetch_topic_view(options)\n\n    render_json_dump(\n      TopicViewPostsSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw],\n      ),\n    )\n  end\n\n  def excerpts\n    params.require(:topic_id)\n    params.require(:post_ids)\n\n    unless Array === params[:post_ids]\n      render_json_error(\"Expecting post_ids to contain a list of posts ids\")\n      return\n    end\n    post_ids = params[:post_ids].map(&:to_i)\n\n    if post_ids.length > 100\n      render_json_error(\"Requested a chunk that is too big\")\n      return\n    end\n\n    @topic = Topic.with_deleted.where(id: params[:topic_id]).first\n    guardian.ensure_can_see!(@topic)\n\n    @posts =\n      Post\n        .where(hidden: false, deleted_at: nil, topic_id: @topic.id)\n        .where(\"posts.id in (?)\", post_ids)\n        .joins(\"LEFT JOIN users u on u.id = posts.user_id\")\n        .pluck(:id, :cooked, :username, :action_code, :created_at)\n        .map do |post_id, cooked, username, action_code, created_at|\n          attrs = {\n            post_id: post_id,\n            username: username,\n            excerpt: PrettyText.excerpt(cooked, 800, keep_emoji_images: true),\n          }\n\n          if action_code\n            attrs[:action_code] = action_code\n            attrs[:created_at] = created_at\n          end\n\n          attrs\n        end\n\n    render json: @posts.to_json\n  end\n\n  def destroy_timings\n    topic_id = params[:topic_id].to_i\n\n    if params[:last].to_s == \"1\"\n      PostTiming.destroy_last_for(current_user, topic_id: topic_id)\n    else\n      PostTiming.destroy_for(current_user.id, [topic_id])\n    end\n\n    last_notification =\n      Notification\n        .where(user_id: current_user.id, topic_id: topic_id)\n        .order(created_at: :desc)\n        .limit(1)\n        .first\n\n    last_notification.update!(read: false) if last_notification\n\n    render body: nil\n  end\n\n  def update_shared_draft\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_edit!(topic)\n\n    category = Category.where(id: params[:category_id].to_i).first\n    guardian.ensure_can_publish_topic!(topic, category)\n\n    row_count = SharedDraft.where(topic_id: topic.id).update_all(category_id: category.id)\n    SharedDraft.create(topic_id: topic.id, category_id: category.id) if row_count == 0\n\n    render json: success_json\n  end\n\n  def update\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit!(topic)\n\n    if params[:category_id] && (params[:category_id].to_i != topic.category_id.to_i)\n      if topic.shared_draft\n        topic.shared_draft.update(category_id: params[:category_id])\n        params.delete(:category_id)\n      else\n        category = Category.find_by(id: params[:category_id])\n\n        if category || (params[:category_id].to_i == 0)\n          guardian.ensure_can_move_topic_to_category!(category)\n        else\n          return render_json_error(I18n.t(\"category.errors.not_found\"))\n        end\n\n        if category &&\n             topic_tags = (params[:tags] || topic.tags.pluck(:name)).reject { |c| c.empty? }\n          if topic_tags.present?\n            allowed_tags =\n              DiscourseTagging.filter_allowed_tags(guardian, category: category).map(&:name)\n\n            invalid_tags = topic_tags - allowed_tags\n\n            # Do not raise an error on a topic's hidden tags when not modifying tags\n            if params[:tags].blank?\n              invalid_tags.each do |tag_name|\n                if DiscourseTagging.hidden_tag_names.include?(tag_name)\n                  invalid_tags.delete(tag_name)\n                end\n              end\n            end\n\n            invalid_tags = Tag.where_name(invalid_tags).pluck(:name)\n\n            if !invalid_tags.empty?\n              if (invalid_tags & DiscourseTagging.hidden_tag_names).present?\n                return render_json_error(I18n.t(\"category.errors.disallowed_tags_generic\"))\n              else\n                return(\n                  render_json_error(\n                    I18n.t(\"category.errors.disallowed_topic_tags\", tags: invalid_tags.join(\", \")),\n                  )\n                )\n              end\n            end\n          end\n        end\n      end\n    end\n\n    changes = {}\n\n    PostRevisor.tracked_topic_fields.each_key { |f| changes[f] = params[f] if params.has_key?(f) }\n\n    changes.delete(:title) if topic.title == changes[:title]\n    changes.delete(:category_id) if topic.category_id.to_i == changes[:category_id].to_i\n\n    if Tag.include_tags?\n      topic_tags = topic.tags.map(&:name).sort\n      changes.delete(:tags) if changes[:tags]&.sort == topic_tags\n    end\n\n    success = true\n\n    if changes.length > 0\n      bypass_bump = should_bypass_bump?(changes)\n\n      first_post = topic.ordered_posts.first\n      success =\n        PostRevisor.new(first_post, topic).revise!(\n          current_user,\n          changes,\n          validate_post: false,\n          bypass_bump: bypass_bump,\n          keep_existing_draft: params[:keep_existing_draft].to_s == \"true\",\n        )\n\n      topic.errors.add(:base, :unable_to_update) if !success && topic.errors.blank?\n    end\n\n    # this is used to return the title to the client as it may have been changed by \"TextCleaner\"\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def update_tags\n    params.require(:tags)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit_tags!(topic)\n\n    success =\n      PostRevisor.new(topic.first_post, topic).revise!(\n        current_user,\n        { tags: params[:tags] },\n        validate_post: false,\n      )\n\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def feature_stats\n    params.require(:category_id)\n    category_id = params[:category_id].to_i\n\n    visible_topics = Topic.listable_topics.visible\n\n    render json: {\n             pinned_in_category_count:\n               visible_topics\n                 .where(category_id: category_id)\n                 .where(pinned_globally: false)\n                 .where.not(pinned_at: nil)\n                 .count,\n             pinned_globally_count:\n               visible_topics.where(pinned_globally: true).where.not(pinned_at: nil).count,\n             banner_count: Topic.listable_topics.where(archetype: Archetype.banner).count,\n           }\n  end\n\n  def status\n    params.require(:status)\n    params.require(:enabled)\n    params.permit(:until)\n\n    status = params[:status]\n    topic_id = params[:topic_id].to_i\n    enabled = params[:enabled] == \"true\"\n\n    check_for_status_presence(:status, status)\n    @topic =\n      if params[:category_id]\n        Topic.find_by(id: topic_id, category_id: params[:category_id].to_i)\n      else\n        Topic.find_by(id: topic_id)\n      end\n\n    case status\n    when \"closed\"\n      guardian.ensure_can_close_topic!(@topic)\n    when \"archived\"\n      guardian.ensure_can_archive_topic!(@topic)\n    when \"visible\"\n      guardian.ensure_can_toggle_topic_visibility!(@topic)\n    when \"pinned\"\n      guardian.ensure_can_pin_unpin_topic!(@topic)\n    else\n      guardian.ensure_can_moderate!(@topic)\n    end\n\n    params[:until] === \"\" ? params[:until] = nil : params[:until]\n\n    @topic.update_status(status, enabled, current_user, until: params[:until])\n\n    render json:\n             success_json.merge!(\n               topic_status_update:\n                 TopicTimerSerializer.new(TopicTimer.find_by(topic: @topic), root: false),\n             )\n  end\n\n  def mute\n    toggle_mute\n  end\n\n  def unmute\n    toggle_mute\n  end\n\n  def timer\n    params.permit(:time, :based_on_last_post, :category_id)\n    params.require(:status_type)\n\n    status_type =\n      begin\n        TopicTimer.types.fetch(params[:status_type].to_sym)\n      rescue StandardError\n        invalid_param(:status_type)\n      end\n    based_on_last_post = params[:based_on_last_post]\n    params.require(:duration_minutes) if based_on_last_post\n\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_moderate!(topic)\n\n    guardian.ensure_can_delete!(topic) if TopicTimer.destructive_types.values.include?(status_type)\n\n    options = { by_user: current_user, based_on_last_post: based_on_last_post }\n\n    options.merge!(category_id: params[:category_id]) if !params[:category_id].blank?\n    if params[:duration_minutes].present?\n      options.merge!(duration_minutes: params[:duration_minutes].to_i)\n    end\n    options.merge!(duration: params[:duration].to_i) if params[:duration].present?\n\n    begin\n      topic_timer = topic.set_or_create_timer(status_type, params[:time], **options)\n    rescue ActiveRecord::RecordInvalid => e\n      return render_json_error(e.message)\n    end\n\n    if topic.save\n      render json:\n               success_json.merge!(\n                 execute_at: topic_timer&.execute_at,\n                 duration_minutes: topic_timer&.duration_minutes,\n                 based_on_last_post: topic_timer&.based_on_last_post,\n                 closed: topic.closed,\n                 category_id: topic_timer&.category_id,\n               )\n    else\n      render_json_error(topic)\n    end\n  end\n\n  def make_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.make_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.remove_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_bookmarks\n    topic = Topic.find(params[:topic_id].to_i)\n    BookmarkManager.new(current_user).destroy_for_topic(topic)\n    render body: nil\n  end\n\n  def archive_message\n    toggle_archive_message(true)\n  end\n\n  def move_to_inbox\n    toggle_archive_message(false)\n  end\n\n  def toggle_archive_message(archive)\n    topic = Topic.find(params[:id].to_i)\n\n    group_id = nil\n\n    group_ids = current_user.groups.pluck(:id)\n    if group_ids.present?\n      allowed_groups =\n        topic.allowed_groups.where(\"topic_allowed_groups.group_id IN (?)\", group_ids).pluck(:id)\n\n      allowed_groups.each do |id|\n        if archive\n          GroupArchivedMessage.archive!(id, topic, acting_user_id: current_user.id)\n\n          group_id = id\n        else\n          GroupArchivedMessage.move_to_inbox!(id, topic, acting_user_id: current_user.id)\n        end\n      end\n    end\n\n    if topic.allowed_users.include?(current_user)\n      if archive\n        UserArchivedMessage.archive!(current_user.id, topic)\n      else\n        UserArchivedMessage.move_to_inbox!(current_user.id, topic)\n      end\n    end\n\n    if group_id\n      name = Group.find_by(id: group_id).try(:name)\n      render_json_dump(group_name: name)\n    else\n      render body: nil\n    end\n  end\n\n  def bookmark\n    topic = Topic.find(params[:topic_id].to_i)\n\n    bookmark_manager = BookmarkManager.new(current_user)\n    bookmark_manager.create_for(bookmarkable_id: topic.id, bookmarkable_type: \"Topic\")\n\n    return render_json_error(bookmark_manager, status: 400) if bookmark_manager.errors.any?\n\n    render body: nil\n  end\n\n  def destroy\n    topic = Topic.with_deleted.find_by(id: params[:id])\n    force_destroy = ActiveModel::Type::Boolean.new.cast(params[:force_destroy])\n\n    if force_destroy\n      if !topic\n        raise Discourse::InvalidAccess\n      elsif !guardian.can_permanently_delete?(topic)\n        return render_json_error topic.cannot_permanently_delete_reason(current_user), status: 403\n      end\n    else\n      guardian.ensure_can_delete!(topic)\n    end\n\n    PostDestroyer.new(\n      current_user,\n      topic.ordered_posts.with_deleted.first,\n      context: params[:context],\n      force_destroy: force_destroy,\n    ).destroy\n\n    render body: nil\n  rescue Discourse::InvalidAccess\n    render_json_error I18n.t(\"delete_topic_failed\")\n  end\n\n  def recover\n    topic = Topic.where(id: params[:topic_id]).with_deleted.first\n    guardian.ensure_can_recover_topic!(topic)\n\n    first_post = topic.posts.with_deleted.order(:post_number).first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).recover\n\n    render body: nil\n  end\n\n  def excerpt\n    render body: nil\n  end\n\n  def remove_allowed_user\n    params.require(:username)\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound unless topic\n    user = User.find_by(username: params[:username])\n    raise Discourse::NotFound unless user\n\n    guardian.ensure_can_remove_allowed_users!(topic, user)\n\n    if topic.remove_allowed_user(current_user, user)\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def remove_allowed_group\n    params.require(:name)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_remove_allowed_users!(topic)\n\n    if topic.remove_allowed_group(current_user, params[:name])\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite_group\n    group = Group.find_by(name: params[:group])\n    raise Discourse::NotFound if !group\n\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound if !topic\n\n    if !pm_has_slots?(topic)\n      return(\n        render_json_error(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      )\n    end\n\n    if topic.private_message?\n      guardian.ensure_can_invite_group_to_private_message!(group, topic)\n      topic.invite_group(current_user, group)\n      render_json_dump BasicGroupSerializer.new(group, scope: guardian, root: \"group\")\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound if !topic\n\n    return render_json_error(I18n.t(\"topic_invite.not_pm\")) if !topic.private_message?\n\n    if !pm_has_slots?(topic)\n      return(\n        render_json_error(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      )\n    end\n\n    guardian.ensure_can_invite_to!(topic)\n\n    username_or_email = params[:user] ? fetch_username : fetch_email\n    group_ids =\n      Group.lookup_groups(group_ids: params[:group_ids], group_names: params[:group_names]).pluck(\n        :id,\n      )\n\n    begin\n      if topic.invite(current_user, username_or_email, group_ids, params[:custom_message])\n        if user = User.find_by_username_or_email(username_or_email)\n          render_json_dump BasicUserSerializer.new(user, scope: guardian, root: \"user\")\n        else\n          render json: success_json\n        end\n      else\n        json = failed_json\n\n        unless topic.private_message?\n          group_names =\n            topic\n              .category\n              .visible_group_names(current_user)\n              .where(automatic: false)\n              .pluck(:name)\n              .join(\", \")\n\n          if group_names.present?\n            json.merge!(errors: [I18n.t(\"topic_invite.failed_to_invite\", group_names: group_names)])\n          end\n        end\n\n        render json: json, status: 422\n      end\n    rescue Topic::UserExists, Topic::NotAllowed => e\n      render json: { errors: [e.message] }, status: 422\n    end\n  end\n\n  def set_notifications\n    topic = Topic.find(params[:topic_id].to_i)\n    TopicUser.change(current_user, topic.id, notification_level: params[:notification_level].to_i)\n    render json: success_json\n  end\n\n  def merge_topic\n    topic_id = params.require(:topic_id)\n    destination_topic_id = params.require(:destination_topic_id)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    destination_topic = Topic.find_by(id: destination_topic_id)\n    guardian.ensure_can_create_post_on_topic!(destination_topic)\n\n    args = {}\n    args[:destination_topic_id] = destination_topic_id.to_i\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? &&\n        params[:archetype] == \"private_message\"\n    end\n\n    destination_topic = topic.move_posts(current_user, topic.posts.pluck(:id), args)\n    render_topic_changes(destination_topic)\n  end\n\n  def move_posts\n    post_ids = params.require(:post_ids)\n    topic_id = params.require(:topic_id)\n    params.permit(:category_id)\n    params.permit(:tags)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.with_deleted.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    if params[:title].present?\n      # when creating a new topic, ensure the 1st post is a regular post\n      if Post.where(topic: topic, id: post_ids).order(:post_number).pick(:post_type) !=\n           Post.types[:regular]\n        return(\n          render_json_error(\n            \"When moving posts to a new topic, the first post must be a regular post.\",\n          )\n        )\n      end\n\n      if params[:category_id].present?\n        guardian.ensure_can_create_topic_on_category!(params[:category_id])\n      end\n    end\n\n    destination_topic = move_posts_to_destination(topic)\n    render_topic_changes(destination_topic)\n  rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved => ex\n    render_json_error(ex)\n  end\n\n  def change_post_owners\n    params.require(:post_ids)\n    params.require(:topic_id)\n    params.require(:username)\n\n    guardian.ensure_can_change_post_owner!\n\n    begin\n      PostOwnerChanger.new(\n        post_ids: params[:post_ids].to_a,\n        topic_id: params[:topic_id].to_i,\n        new_owner: User.find_by(username: params[:username]),\n        acting_user: current_user,\n      ).change_owner!\n      render json: success_json\n    rescue ArgumentError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def change_timestamps\n    topic_id = params.require(:topic_id).to_i\n    timestamp = params.require(:timestamp).to_f\n\n    guardian.ensure_can_change_post_timestamps!\n\n    topic = Topic.with_deleted.find(topic_id)\n    previous_timestamp = topic.first_post.created_at\n\n    begin\n      TopicTimestampChanger.new(topic: topic, timestamp: timestamp).change!\n\n      StaffActionLogger.new(current_user).log_topic_timestamps_changed(\n        topic,\n        Time.zone.at(timestamp),\n        previous_timestamp,\n      )\n\n      render json: success_json\n    rescue ActiveRecord::RecordInvalid, TopicTimestampChanger::InvalidTimestampError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def clear_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.clear_pin_for(current_user)\n    render body: nil\n  end\n\n  def re_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.re_pin_for(current_user)\n    render body: nil\n  end\n\n  def timings\n    allowed_params = topic_params\n\n    topic_id = allowed_params[:topic_id].to_i\n    topic_time = allowed_params[:topic_time].to_i\n    timings = allowed_params[:timings].to_h || {}\n\n    # ensure we capture current user for the block\n    user = current_user\n\n    hijack do\n      PostTiming.process_timings(\n        user,\n        topic_id,\n        topic_time,\n        timings.map { |post_number, t| [post_number.to_i, t.to_i] },\n        mobile: view_context.mobile_view?,\n      )\n      render body: nil\n    end\n  end\n\n  def feed\n    raise Discourse::NotFound if !Post.exists?(topic_id: params[:topic_id])\n\n    begin\n      @topic_view = TopicView.new(params[:topic_id])\n    rescue Discourse::NotLoggedIn\n      raise Discourse::NotFound\n    rescue Discourse::InvalidAccess => ex\n      deleted =\n        guardian.can_see_topic?(ex.obj, false) ||\n          (!guardian.can_see_topic?(ex.obj) && ex.obj&.access_topic_via_group && ex.obj.deleted_at)\n\n      raise Discourse::NotFound.new(\n              nil,\n              check_permalinks: deleted,\n              original_path: ex.obj.relative_url,\n            )\n    end\n\n    discourse_expires_in 1.minute\n\n    response.headers[\"X-Robots-Tag\"] = \"noindex, nofollow\"\n    render \"topics/show\", formats: [:rss]\n  end\n\n  def bulk\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n    elsif params[:filter] == \"unread\"\n      topic_ids = bulk_unread_topic_ids\n    else\n      raise ActionController::ParameterMissing.new(:topic_ids)\n    end\n\n    operation =\n      params\n        .require(:operation)\n        .permit(\n          :type,\n          :group,\n          :category_id,\n          :notification_level_id,\n          *DiscoursePluginRegistry.permitted_bulk_action_parameters,\n          tags: [],\n        )\n        .to_h\n        .symbolize_keys\n\n    raise ActionController::ParameterMissing.new(:operation_type) if operation[:type].blank?\n    operator = TopicsBulkAction.new(current_user, topic_ids, operation, group: operation[:group])\n    changed_topic_ids = operator.perform!\n    render_json_dump topic_ids: changed_topic_ids\n  end\n\n  def private_message_reset_new\n    topic_query = TopicQuery.new(current_user, limit: false)\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n\n      topic_scope =\n        topic_query.private_messages_for(current_user, :all).where(\n          \"topics.id IN (?)\",\n          params[:topic_ids].map(&:to_i),\n        )\n    else\n      params.require(:inbox)\n      inbox = params[:inbox].to_s\n      filter = private_message_filter(topic_query, inbox)\n      topic_scope = topic_query.filter_private_message_new(current_user, filter)\n    end\n\n    topic_ids =\n      TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n\n    render json: success_json.merge(topic_ids: topic_ids)\n  end\n\n  def reset_new\n    topic_scope =\n      if params[:category_id].present?\n        category_ids = [params[:category_id]]\n        if params[:include_subcategories] == \"true\"\n          category_ids =\n            category_ids.concat(Category.where(parent_category_id: params[:category_id]).pluck(:id))\n        end\n\n        scope = Topic.where(category_id: category_ids)\n        scope = scope.joins(:tags).where(tags: { name: params[:tag_id] }) if params[:tag_id]\n        scope\n      elsif params[:tag_id].present?\n        Topic.joins(:tags).where(tags: { name: params[:tag_id] })\n      else\n        new_results = TopicQuery.new(current_user).new_results(limit: false)\n        if params[:tracked].to_s == \"true\"\n          TopicQuery.tracked_filter(new_results, current_user.id)\n        else\n          current_user.user_stat.update_column(:new_since, Time.zone.now)\n          new_results\n        end\n      end\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\"Expecting topic_ids to contain a list of topic ids\")\n      end\n\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n      topic_scope = topic_scope.where(id: topic_ids)\n    end\n\n    dismissed_topic_ids =\n      TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n    TopicTrackingState.publish_dismiss_new(current_user.id, topic_ids: dismissed_topic_ids)\n\n    render body: nil\n  end\n\n  def convert_topic\n    params.require(:id)\n    params.require(:type)\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_convert_topic!(topic)\n\n    if params[:type] == \"public\"\n      converted_topic =\n        topic.convert_to_public_topic(current_user, category_id: params[:category_id])\n    else\n      converted_topic = topic.convert_to_private_message(current_user)\n    end\n    render_topic_changes(converted_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def reset_bump_date\n    params.require(:id)\n    guardian.ensure_can_update_bumped_at!\n\n    topic = Topic.find_by(id: params[:id])\n    raise Discourse::NotFound.new unless topic\n\n    topic.reset_bumped_at\n    render body: nil\n  end\n\n  def set_slow_mode\n    topic = Topic.find(params[:topic_id])\n    slow_mode_type = TopicTimer.types[:clear_slow_mode]\n    timer = TopicTimer.find_by(topic: topic, status_type: slow_mode_type)\n\n    guardian.ensure_can_moderate!(topic)\n    topic.update!(slow_mode_seconds: params[:seconds])\n    enabled = params[:seconds].to_i > 0\n\n    time = enabled && params[:enabled_until].present? ? params[:enabled_until] : nil\n\n    topic.set_or_create_timer(slow_mode_type, time, by_user: timer&.user)\n\n    head :ok\n  end\n\n  private\n\n  def topic_params\n    params.permit(:topic_id, :topic_time, timings: {})\n  end\n\n  def fetch_topic_view(options)\n    if (username_filters = params[:username_filters]).present?\n      options[:username_filters] = username_filters.split(\",\")\n    end\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, options)\n  end\n\n  def toggle_mute\n    @topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(@topic)\n\n    @topic.toggle_mute(current_user)\n    render body: nil\n  end\n\n  def consider_user_for_promotion\n    Promotion.new(current_user).review if current_user.present?\n  end\n\n  def should_bypass_bump?(changes)\n    (changes[:category_id].present? && SiteSetting.disable_category_edit_notifications) ||\n      (changes[:tags].present? && SiteSetting.disable_tags_edit_notifications)\n  end\n\n  def slugs_do_not_match\n    if SiteSetting.slug_generation_method != \"encoded\"\n      params[:slug] && @topic_view.topic.slug != params[:slug]\n    else\n      params[:slug] && CGI.unescape(@topic_view.topic.slug) != params[:slug]\n    end\n  end\n\n  def redirect_to_correct_topic(topic, post_number = nil)\n    begin\n      guardian.ensure_can_see!(topic)\n    rescue Discourse::InvalidAccess => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    end\n\n    opts = params.slice(:page, :print, :filter_top_level_replies)\n    opts.delete(:page) if params[:page] == 0\n\n    url = topic.relative_url\n    url << \"/#{post_number}\" if post_number.to_i > 0\n    url << \".json\" if request.format.json?\n\n    opts.each do |k, v|\n      s = url.include?(\"?\") ? \"&\" : \"?\"\n      url << \"#{s}#{k}=#{v}\"\n    end\n\n    redirect_to url, status: 301\n  end\n\n  def track_visit_to_topic\n    topic_id = @topic_view.topic.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n    track_visit = should_track_visit_to_topic?\n\n    if !request.format.json?\n      hash = {\n        referer: request.referer || flash[:referer],\n        host: request.host,\n        current_user: current_user,\n        topic_id: @topic_view.topic.id,\n        post_number: @topic_view.current_post_number,\n        username: request[\"u\"],\n        ip_address: request.remote_ip,\n      }\n      # defer this way so we do not capture the whole controller\n      # in the closure\n      TopicsController.defer_add_incoming_link(hash)\n    end\n\n    TopicsController.defer_track_visit(topic_id, ip, user_id, track_visit)\n  end\n\n  def self.defer_track_visit(topic_id, ip, user_id, track_visit)\n    Scheduler::Defer.later \"Track Visit\" do\n      TopicViewItem.add(topic_id, ip, user_id)\n      TopicUser.track_visit!(topic_id, user_id) if track_visit\n    end\n  end\n\n  def self.defer_add_incoming_link(hash)\n    Scheduler::Defer.later \"Track Link\" do\n      IncomingLink.add(hash)\n    end\n  end\n\n  def should_track_visit_to_topic?\n    !!((!request.format.json? || params[:track_visit]) && current_user)\n  end\n\n  def perform_show_response\n    if request.head?\n      head :ok\n      return\n    end\n\n    topic_view_serializer =\n      TopicViewSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw],\n        exclude_suggested_and_related:\n          !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id] ||\n            !!params[:filter_top_level_replies],\n      )\n\n    respond_to do |format|\n      format.html do\n        @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags.visible(guardian) : []\n        @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || []\n        @description_meta =\n          @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary\n        store_preloaded(\"topic_#{@topic_view.topic.id}\", MultiJson.dump(topic_view_serializer))\n        render :show\n      end\n\n      format.json { render_json_dump(topic_view_serializer) }\n    end\n  end\n\n  def render_topic_changes(dest_topic)\n    if dest_topic.present?\n      render json: { success: true, url: dest_topic.relative_url }\n    else\n      render json: { success: false }\n    end\n  end\n\n  def move_posts_to_destination(topic)\n    args = {}\n    args[:title] = params[:title] if params[:title].present?\n    args[:destination_topic_id] = params[:destination_topic_id].to_i if params[\n      :destination_topic_id\n    ].present?\n    args[:tags] = params[:tags] if params[:tags].present?\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? &&\n        params[:archetype] == \"private_message\"\n    else\n      args[:category_id] = params[:category_id].to_i if params[:category_id].present?\n    end\n\n    topic.move_posts(current_user, post_ids_including_replies, args)\n  end\n\n  def check_for_status_presence(key, attr)\n    invalid_param(key) unless %w[pinned pinned_globally visible closed archived].include?(attr)\n  end\n\n  def invalid_param(key)\n    raise Discourse::InvalidParameters.new(key.to_sym)\n  end\n\n  def fetch_username\n    params.require(:user)\n    params[:user]\n  end\n\n  def fetch_email\n    params.require(:email)\n    params[:email]\n  end\n\n  def pm_has_slots?(pm)\n    guardian.is_staff? || !pm.reached_recipients_limit?\n  end\n\n  def bulk_unread_topic_ids\n    topic_query = TopicQuery.new(current_user)\n\n    if inbox = params[:private_message_inbox]\n      filter = private_message_filter(topic_query, inbox)\n      topic_query.options[:limit] = false\n      topics = topic_query.filter_private_messages_unread(current_user, filter)\n    else\n      topics =\n        TopicQuery.unread_filter(\n          topic_query.joined_topic_user,\n          whisperer: guardian.is_whisperer?,\n        ).listable_topics\n      topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == \"true\"\n\n      if params[:category_id]\n        if params[:include_subcategories]\n          topics = topics.where(<<~SQL, category_id: params[:category_id])\n            category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR\n            category_id = :category_id\n          SQL\n        else\n          topics = topics.where(\"category_id = ?\", params[:category_id])\n        end\n      end\n\n      if params[:tag_name].present?\n        topics = topics.joins(:tags).where(\"tags.name\": params[:tag_name])\n      end\n    end\n\n    topics.pluck(:id)\n  end\n\n  def private_message_filter(topic_query, inbox)\n    case inbox\n    when \"group\"\n      group_name = params[:group_name]\n      group = Group.find_by(\"lower(name) = ?\", group_name)\n      raise Discourse::NotFound if !group\n      raise Discourse::NotFound if !guardian.can_see_group_messages?(group)\n      topic_query.options[:group_name] = group_name\n      :group\n    when \"user\"\n      :user\n    else\n      :all\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass Tag < ActiveRecord::Base\n  include Searchable\n  include HasDestroyedWebHook\n\n  self.ignored_columns = [\n    \"topic_count\", # TODO(tgxworld): Remove on 1 July 2023\n  ]\n\n  RESERVED_TAGS = [\n    \"none\",\n    \"constructor\", # prevents issues with javascript's constructor of objects\n  ]\n\n  validates :name, presence: true, uniqueness: { case_sensitive: false }\n\n  validate :target_tag_validator,\n           if: Proc.new { |t| t.new_record? || t.will_save_change_to_target_tag_id? }\n  validate :name_validator\n  validates :description, length: { maximum: 280 }\n\n  scope :where_name,\n        ->(name) {\n          name = Array(name).map(&:downcase)\n          where(\"lower(tags.name) IN (?)\", name)\n        }\n\n  # tags that have never been used and don't belong to a tag group\n  scope :unused,\n        -> {\n          where(staff_topic_count: 0, pm_topic_count: 0).joins(\n            \"LEFT JOIN tag_group_memberships tgm ON tags.id = tgm.tag_id\",\n          ).where(\"tgm.tag_id IS NULL\")\n        }\n\n  scope :used_tags_in_regular_topics,\n        ->(guardian) { where(\"tags.#{Tag.topic_count_column(guardian)} > 0\") }\n\n  scope :base_tags, -> { where(target_tag_id: nil) }\n  scope :visible, ->(guardian = nil) { merge(DiscourseTagging.visible_tags(guardian)) }\n\n  has_many :tag_users, dependent: :destroy # notification settings\n\n  has_many :topic_tags, dependent: :destroy\n  has_many :topics, through: :topic_tags\n\n  has_many :category_tag_stats, dependent: :destroy\n  has_many :category_tags, dependent: :destroy\n  has_many :categories, through: :category_tags\n\n  has_many :tag_group_memberships, dependent: :destroy\n  has_many :tag_groups, through: :tag_group_memberships\n\n  belongs_to :target_tag, class_name: \"Tag\", optional: true\n  has_many :synonyms, class_name: \"Tag\", foreign_key: \"target_tag_id\", dependent: :destroy\n  has_many :sidebar_section_links, as: :linkable, dependent: :delete_all\n\n  after_save :index_search\n  after_save :update_synonym_associations\n\n  after_commit :trigger_tag_created_event, on: :create\n  after_commit :trigger_tag_updated_event, on: :update\n  after_commit :trigger_tag_destroyed_event, on: :destroy\n\n  def self.ensure_consistency!\n    update_topic_counts\n  end\n\n  def self.update_topic_counts\n    DB.exec <<~SQL\n      UPDATE tags t\n         SET staff_topic_count = x.topic_count\n        FROM (\n             SELECT COUNT(topics.id) AS topic_count, tags.id AS tag_id\n               FROM tags\n          LEFT JOIN topic_tags ON tags.id = topic_tags.tag_id\n          LEFT JOIN topics ON topics.id = topic_tags.topic_id\n                          AND topics.deleted_at IS NULL\n                          AND topics.archetype != 'private_message'\n           GROUP BY tags.id\n        ) x\n       WHERE x.tag_id = t.id\n         AND x.topic_count <> t.staff_topic_count\n    SQL\n\n    DB.exec <<~SQL\n      UPDATE tags t\n      SET public_topic_count = x.topic_count\n      FROM (\n        WITH tags_with_public_topics AS (\n          SELECT\n            COUNT(topics.id) AS topic_count,\n            tags.id AS tag_id\n          FROM tags\n          INNER JOIN topic_tags ON tags.id = topic_tags.tag_id\n          INNER JOIN topics ON topics.id = topic_tags.topic_id AND topics.deleted_at IS NULL AND topics.archetype != 'private_message'\n          INNER JOIN categories ON categories.id = topics.category_id AND NOT categories.read_restricted\n          GROUP BY tags.id\n        )\n        SELECT\n          COALESCE(tags_with_public_topics.topic_count, 0 ) AS topic_count,\n          tags.id AS tag_id\n        FROM tags\n        LEFT JOIN tags_with_public_topics ON tags_with_public_topics.tag_id = tags.id\n      ) x\n      WHERE x.tag_id = t.id\n      AND x.topic_count <> t.public_topic_count;\n    SQL\n\n    DB.exec <<~SQL\n      UPDATE tags t\n         SET pm_topic_count = x.pm_topic_count\n        FROM (\n             SELECT COUNT(topics.id) AS pm_topic_count, tags.id AS tag_id\n               FROM tags\n          LEFT JOIN topic_tags ON tags.id = topic_tags.tag_id\n          LEFT JOIN topics ON topics.id = topic_tags.topic_id\n                          AND topics.deleted_at IS NULL\n                          AND topics.archetype = 'private_message'\n           GROUP BY tags.id\n        ) x\n       WHERE x.tag_id = t.id\n         AND x.pm_topic_count <> t.pm_topic_count\n    SQL\n  end\n\n  def self.find_by_name(name)\n    self.find_by(\"lower(name) = ?\", name.downcase)\n  end\n\n  def self.top_tags(limit_arg: nil, category: nil, guardian: Guardian.new)\n    # we add 1 to max_tags_in_filter_list to efficiently know we have more tags\n    # than the limit. Frontend is responsible to enforce limit.\n    limit = limit_arg || (SiteSetting.max_tags_in_filter_list + 1)\n    scope_category_ids = guardian.allowed_category_ids\n    scope_category_ids &= ([category.id] + category.subcategories.pluck(:id)) if category\n\n    return [] if scope_category_ids.empty?\n\n    filter_sql =\n      (\n        if guardian.is_staff?\n          \"\"\n        else\n          \" AND tags.id IN (#{DiscourseTagging.visible_tags(guardian).select(:id).to_sql})\"\n        end\n      )\n\n    tag_names_with_counts = DB.query <<~SQL\n      SELECT tags.name as tag_name, SUM(stats.topic_count) AS sum_topic_count\n        FROM category_tag_stats stats\n        JOIN tags ON stats.tag_id = tags.id AND stats.topic_count > 0\n       WHERE stats.category_id in (#{scope_category_ids.join(\",\")})\n       #{filter_sql}\n    GROUP BY tags.name\n    ORDER BY sum_topic_count DESC, tag_name ASC\n       LIMIT #{limit}\n    SQL\n\n    tag_names_with_counts.map { |row| row.tag_name }\n  end\n\n  def self.topic_count_column(guardian)\n    if guardian&.is_staff? || SiteSetting.include_secure_categories_in_tag_counts\n      \"staff_topic_count\"\n    else\n      \"public_topic_count\"\n    end\n  end\n\n  def self.pm_tags(limit: 1000, guardian: nil, allowed_user: nil)\n    return [] if allowed_user.blank? || !(guardian || Guardian.new).can_tag_pms?\n    user_id = allowed_user.id\n\n    DB.query_hash(<<~SQL).map!(&:symbolize_keys!)\n      SELECT tags.name as id, tags.name as text, COUNT(topics.id) AS count\n        FROM tags\n        JOIN topic_tags ON tags.id = topic_tags.tag_id\n        JOIN topics ON topics.id = topic_tags.topic_id\n                   AND topics.deleted_at IS NULL\n                   AND topics.archetype = 'private_message'\n       WHERE topic_tags.topic_id IN (\n          SELECT topic_id\n            FROM topic_allowed_users\n           WHERE user_id = #{user_id.to_i}\n           UNION\n          SELECT tg.topic_id\n            FROM topic_allowed_groups tg\n            JOIN group_users gu ON gu.user_id = #{user_id.to_i}\n                               AND gu.group_id = tg.group_id\n       )\n       GROUP BY tags.name\n       ORDER BY count DESC\n       LIMIT #{limit.to_i}\n    SQL\n  end\n\n  def self.include_tags?\n    SiteSetting.tagging_enabled\n  end\n\n  def url\n    \"#{Discourse.base_path}/tag/#{UrlHelper.encode_component(self.name)}\"\n  end\n\n  def full_url\n    \"#{Discourse.base_url}/tag/#{UrlHelper.encode_component(self.name)}\"\n  end\n\n  def index_search\n    SearchIndexer.index(self)\n  end\n\n  def synonym?\n    !self.target_tag_id.nil?\n  end\n\n  def target_tag_validator\n    if synonyms.exists?\n      errors.add(:target_tag_id, I18n.t(\"tags.synonyms_exist\"))\n    elsif target_tag&.synonym?\n      errors.add(:target_tag_id, I18n.t(\"tags.invalid_target_tag\"))\n    end\n  end\n\n  def update_synonym_associations\n    if target_tag_id && saved_change_to_target_tag_id?\n      target_tag.tag_groups.each do |tag_group|\n        tag_group.tags << self unless tag_group.tags.include?(self)\n      end\n      target_tag.categories.each do |category|\n        category.tags << self unless category.tags.include?(self)\n      end\n    end\n  end\n\n  %i[tag_created tag_updated tag_destroyed].each do |event|\n    define_method(\"trigger_#{event}_event\") do\n      DiscourseEvent.trigger(event, self)\n      true\n    end\n  end\n\n  private\n\n  def name_validator\n    errors.add(:name, :invalid) if name.present? && RESERVED_TAGS.include?(self.name.strip.downcase)\n  end\nend\n\n# == Schema Information\n#\n# Table name: tags\n#\n#  id                 :integer          not null, primary key\n#  name               :string           not null\n#  created_at         :datetime         not null\n#  updated_at         :datetime         not null\n#  pm_topic_count     :integer          default(0), not null\n#  target_tag_id      :integer\n#  description        :string\n#  public_topic_count :integer          default(0), not null\n#  staff_topic_count  :integer          default(0), not null\n#\n# Indexes\n#\n#  index_tags_on_lower_name  (lower((name)::text)) UNIQUE\n#  index_tags_on_name        (name) UNIQUE\n#\n", "<% if @topic_view %>\n  <div id=\"topic-title\">\n    <h1>\n      <%= render_topic_title(@topic_view.topic) %>\n    </h1>\n\n    <% if @breadcrumbs.present? %>\n      <div class=\"topic-category\" itemscope itemtype=\"http://schema.org/BreadcrumbList\">\n        <% @breadcrumbs.each_with_index do |c, i| %>\n          <span itemprop=\"itemListElement\" itemscope itemtype=\"http://schema.org/ListItem\">\n            <a href=\"<%= Discourse.base_url %><%= c[:url] %>\" class=\"badge-wrapper bullet\" itemprop=\"item\">\n              <span class='badge-category-bg' style='background-color: #<%= c[:color] %>'></span>\n              <span class='badge-category clear-badge'>\n                <span class='category-name' itemprop='name'><%= c[:name] %></span>\n              </span>\n            </a>\n            <meta itemprop=\"position\" content=\"<%= i + 1 %>\" />\n          </span>\n        <% end %>\n      </div>\n    <% end %>\n\n    <% if @tags.present? %>\n      <div class=\"topic-category\">\n        <div class='discourse-tags list-tags'>\n          <% @tags.each_with_index do |tag, i| %>\n            <a href='<%= \"#{Discourse.base_url}/tag/#{tag.name}\" %>' class='discourse-tag' rel=\"tag\"><%= tag.name -%></a><% if i < @tags.size - 1 %>, <% end %>\n          <% end %>\n        </div>\n      </div>\n    <% end %>\n  </div>\n\n  <%= server_plugin_outlet \"topic_header\" %>\n\n  <%- if include_crawler_content? %>\n\n  <% @topic_view.posts.each_with_index do |post, idx| %>\n    <% if (u = post.user) %>\n      <div id='post_<%= post.post_number %>' itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>\n        <div class='crawler-post-meta'>\n          <div itemprop='publisher' itemscope itemtype=\"http://schema.org/Organization\">\n            <meta itemprop='name' content='<%= SiteSetting.company_name.presence || SiteSetting.title %>'>\n            <% if application_logo_url.present? %>\n              <div itemprop='logo' itemscope itemtype=\"http://schema.org/ImageObject\">\n                <meta itemprop='url' content='<%= application_logo_url %>'>\n              </div>\n            <% end %>\n          </div>\n          <span class=\"creator\" itemprop=\"author\" itemscope itemtype=\"http://schema.org/Person\">\n            <a itemprop=\"url\" href='<%= Discourse.base_url %>/u/<%= u.username %>'><span itemprop='name'><%= u.username %></span></a>\n            <%= \"(#{u.name})\" if (SiteSetting.display_name_on_posts && SiteSetting.enable_names? && !u.name.blank?) %>\n            <%\n              post_custom_fields = @topic_view.post_custom_fields[post.id] || {}\n              who_username = post_custom_fields[\"action_code_who\"] || \"\"\n              small_action_href = post_custom_fields[\"action_code_path\"] || \"\"\n              if post.action_code\n            %>\n              <%= t(\"js.action_codes.#{post.action_code}\", when: \"\", who: who_username, href: small_action_href).html_safe %>\n            <% end %>\n          </span>\n\n          <link itemprop=\"mainEntityOfPage\" href=\"<%= post.topic.url %>\">\n\n          <% if post.image_url %>\n            <link itemprop=\"image\" href=\"<%= post.image_url %>\">\n          <% end %>\n\n          <span class=\"crawler-post-infos\">\n              <time itemprop='datePublished' datetime='<%= post.created_at.to_formatted_s(:iso8601) %>' class='post-time'>\n                <%= l post.created_at, format: :long %>\n              </time>\n            <% if post.version > 1 %>\n              <meta itemprop='dateModified' content='<%= post.last_version_at.to_formatted_s(:iso8601) %>'>\n            <% else %>\n              <meta itemprop='dateModified' content='<%= post.created_at.to_formatted_s(:iso8601) %>'>\n            <% end %>\n          <span itemprop='position'><%= post.post_number %></span>\n          </span>\n        </div>\n        <div class='post' itemprop='articleBody'>\n          <%= post.hidden ? t('flagging.user_must_edit').html_safe : post.cooked.html_safe %>\n        </div>\n\n        <meta itemprop='headline' content='<%= @topic_view.title %>'>\n        <% if idx == 0 %>\n          <meta itemprop='keywords' content='<%= @tags.map(&:name).join(', ') %>'>\n        <% end %>\n\n        <div itemprop=\"interactionStatistic\" itemscope itemtype=\"http://schema.org/InteractionCounter\">\n           <meta itemprop=\"interactionType\" content=\"http://schema.org/LikeAction\"/>\n           <meta itemprop=\"userInteractionCount\" content=\"<%= post.like_count %>\" />\n           <span class='post-likes'><%= post.like_count > 0 ? t('post.has_likes', count: post.like_count) : '' %></span>\n         </div>\n\n         <div itemprop=\"interactionStatistic\" itemscope itemtype=\"http://schema.org/InteractionCounter\">\n            <meta itemprop=\"interactionType\" content=\"http://schema.org/CommentAction\"/>\n            <meta itemprop=\"userInteractionCount\" content=\"<%= post.reply_count %>\" />\n          </div>\n\n          <% if @topic_view.link_counts[post.id] && @topic_view.link_counts[post.id].filter { |l| l[:reflection] }.length > 0 %>\n            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>\n              <% @topic_view.link_counts[post.id].each_with_index do |link, i| %>\n                <% if link[:reflection] && link[:title].present? %>\n                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>\n                    <a itemprop='url' href=\"<%=link[:url]%>\"><%=link[:title]%></a>\n                    <meta itemprop='position' content='<%= i+1 %>'>\n                  </div>\n                <% end %>\n              <% end %>\n            </div>\n         <% end %>\n      </div>\n    <% end %>\n  <% end %>\n\n  <% if @topic_view.prev_page || @topic_view.next_page %>\n    <div role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement' class=\"topic-body crawler-post\">\n      <% if @topic_view.prev_page %>\n        <span itemprop='name'><%= link_to t(:prev_page), @topic_view.prev_page_path, rel: 'prev', itemprop: 'url' %></span>\n      <% end %>\n      <% if @topic_view.next_page %>\n        <span itemprop='name'><b><%= link_to t(:next_page), @topic_view.next_page_path, rel: 'next', itemprop: 'url' %></b></span>\n      <% end %>\n    </div>\n  <% end %>\n\n  <% end %>\n\n  <% content_for :head do %>\n    <%= auto_discovery_link_tag(@topic_view, {action: :feed, slug: @topic_view.topic.slug, topic_id: @topic_view.topic.id}, rel: 'alternate nofollow', title: t('rss_posts_in_topic', topic: @topic_view.title), type: 'application/rss+xml') %>\n    <%= raw crawlable_meta_data(title: @topic_view.title, description: @topic_view.summary(strip_images: true), image: @topic_view.image_url, read_time: @topic_view.read_time, like_count: @topic_view.like_count, ignore_canonical: true, published_time: @topic_view.published_time, breadcrumbs: @breadcrumbs, tags: @tags.map(&:name)) %>\n\n    <% if @topic_view.prev_page || @topic_view.next_page %>\n      <% if @topic_view.prev_page %>\n        <link rel=\"prev\" href=\"<%= @topic_view.prev_page_path -%>\">\n      <% end %>\n      <% if @topic_view.next_page %>\n        <link rel=\"next\" href=\"<%= @topic_view.next_page_path -%>\">\n      <% end %>\n    <% end %>\n  <% end %>\n\n  <% content_for(:title) { @title || \"#{gsub_emoji_to_unicode(@topic_view.page_title)} - #{SiteSetting.title}\" } %>\n\n  <% if @topic_view.print %>\n    <% content_for :after_body do %>\n        <%= preload_script('print-page') %>\n    <% end %>\n  <% end %>\n<% end %>\n", "# frozen_string_literal: true\n\nclass TopicView\n  MEGA_TOPIC_POSTS_COUNT = 10_000\n  MIN_POST_READ_TIME = 4.0\n\n  def self.on_preload(&blk)\n    (@preload ||= Set.new) << blk\n  end\n\n  def self.cancel_preload(&blk)\n    if @preload\n      @preload.delete blk\n      @preload = nil if @preload.length == 0\n    end\n  end\n\n  def self.preload(topic_view)\n    @preload.each { |preload| preload.call(topic_view) } if @preload\n  end\n\n  attr_reader(\n    :topic,\n    :posts,\n    :guardian,\n    :filtered_posts,\n    :chunk_size,\n    :print,\n    :message_bus_last_id,\n    :queued_posts_enabled,\n    :personal_message,\n    :can_review_topic,\n    :page,\n  )\n  alias queued_posts_enabled? queued_posts_enabled\n\n  attr_accessor(\n    :draft,\n    :draft_key,\n    :draft_sequence,\n    :user_custom_fields,\n    :post_custom_fields,\n    :post_number,\n  )\n\n  delegate :category, to: :topic, allow_nil: true, private: true\n  delegate :require_reply_approval?, to: :category, prefix: true, allow_nil: true, private: true\n\n  def self.print_chunk_size\n    1000\n  end\n\n  def self.chunk_size\n    20\n  end\n\n  def self.default_post_custom_fields\n    @default_post_custom_fields ||= [Post::NOTICE, \"action_code_who\", \"action_code_path\"]\n  end\n\n  def self.post_custom_fields_allowlisters\n    @post_custom_fields_allowlisters ||= Set.new\n  end\n\n  def self.add_post_custom_fields_allowlister(&block)\n    post_custom_fields_allowlisters << block\n  end\n\n  def self.allowed_post_custom_fields(user, topic)\n    wpcf =\n      default_post_custom_fields + post_custom_fields_allowlisters.map { |w| w.call(user, topic) }\n    wpcf.flatten.uniq\n  end\n\n  def self.add_custom_filter(key, &blk)\n    @custom_filters ||= {}\n    @custom_filters[key] = blk\n  end\n\n  def self.custom_filters\n    @custom_filters || {}\n  end\n\n  # Configure a default scope to be applied to @filtered_posts.\n  # The registered block is called with @filtered_posts and an instance of\n  # `TopicView`.\n  #\n  # This API should be considered experimental until it is exposed in\n  # `Plugin::Instance`.\n  def self.apply_custom_default_scope(&block)\n    custom_default_scopes << block\n  end\n\n  def self.custom_default_scopes\n    @custom_default_scopes ||= []\n  end\n\n  # For testing\n  def self.reset_custom_default_scopes\n    @custom_default_scopes = nil\n  end\n\n  def initialize(topic_or_topic_id, user = nil, options = {})\n    @topic = find_topic(topic_or_topic_id)\n    @user = user\n    @guardian = Guardian.new(@user)\n\n    check_and_raise_exceptions(options[:skip_staff_action])\n\n    @message_bus_last_id = MessageBus.last_id(\"/topic/#{@topic.id}\")\n\n    options.each { |key, value| self.instance_variable_set(\"@#{key}\".to_sym, value) }\n\n    @post_number = [@post_number.to_i, 1].max\n\n    @include_suggested = options.fetch(:include_suggested) { true }\n    @include_related = options.fetch(:include_related) { true }\n\n    @chunk_size =\n      case\n      when @print\n        TopicView.print_chunk_size\n      else\n        TopicView.chunk_size\n      end\n\n    @limit ||= @chunk_size\n\n    @page = @page.to_i > 1 ? @page.to_i : calculate_page\n\n    setup_filtered_posts\n    @filtered_posts = apply_default_scope(@filtered_posts)\n    filter_posts(options)\n\n    if @posts && !@skip_custom_fields\n      if (added_fields = User.allowed_user_custom_fields(@guardian)).present?\n        @user_custom_fields = User.custom_fields_for_ids(@posts.map(&:user_id), added_fields)\n      end\n\n      if (allowed_fields = TopicView.allowed_post_custom_fields(@user, @topic)).present?\n        @post_custom_fields = Post.custom_fields_for_ids(@posts.map(&:id), allowed_fields)\n      end\n    end\n\n    TopicView.preload(self)\n\n    @draft_key = @topic.draft_key\n    @draft_sequence = DraftSequence.current(@user, @draft_key)\n\n    @can_review_topic = @guardian.can_review_topic?(@topic)\n    @queued_posts_enabled = NewPostManager.queue_enabled? || category_require_reply_approval?\n    @personal_message = @topic.private_message?\n  end\n\n  def show_read_indicator?\n    return false if !@user || !topic.private_message?\n\n    topic.allowed_groups.any? { |group| group.publish_read_state? && group.users.include?(@user) }\n  end\n\n  def canonical_path\n    if SiteSetting.embed_set_canonical_url\n      topic_embed = topic.topic_embed\n      return topic_embed.embed_url if topic_embed\n    end\n    path = relative_url.dup\n    path << ((@page > 1) ? \"?page=#{@page}\" : \"\")\n    path\n  end\n\n  def contains_gaps?\n    @contains_gaps\n  end\n\n  def gaps\n    return unless @contains_gaps\n\n    @gaps ||=\n      begin\n        if is_mega_topic?\n          nil\n        else\n          Gaps.new(filtered_post_ids, apply_default_scope(unfiltered_posts).pluck(:id))\n        end\n      end\n  end\n\n  def last_post\n    return nil if @posts.blank?\n    @last_post ||= @posts.last\n  end\n\n  def prev_page\n    @page > 1 && posts.size > 0 ? @page - 1 : nil\n  end\n\n  def next_page\n    @next_page ||=\n      begin\n        if last_post && highest_post_number && (highest_post_number > last_post.post_number)\n          @page + 1\n        end\n      end\n  end\n\n  def prev_page_path\n    if prev_page > 1\n      \"#{relative_url}?page=#{prev_page}\"\n    else\n      relative_url\n    end\n  end\n\n  def next_page_path\n    \"#{relative_url}?page=#{next_page}\"\n  end\n\n  def absolute_url\n    \"#{Discourse.base_url_no_prefix}#{relative_url}\"\n  end\n\n  def relative_url\n    \"#{@topic.relative_url}#{@print ? \"/print\" : \"\"}\"\n  end\n\n  def page_title\n    title = @topic.title\n    if @post_number > 1\n      title += \" - \"\n      post = @topic.posts.find_by(post_number: @post_number)\n      author = post&.user\n      if author && @guardian.can_see_post?(post)\n        title +=\n          I18n.t(\n            \"inline_oneboxer.topic_page_title_post_number_by_user\",\n            post_number: @post_number,\n            username: author.username,\n          )\n      else\n        title += I18n.t(\"inline_oneboxer.topic_page_title_post_number\", post_number: @post_number)\n      end\n    end\n    if SiteSetting.topic_page_title_includes_category\n      if @topic.category_id != SiteSetting.uncategorized_category_id && @topic.category_id &&\n           @topic.category\n        title += \" - #{@topic.category.name}\"\n      elsif SiteSetting.tagging_enabled && visible_tags.exists?\n        title +=\n          \" - #{visible_tags.order(\"tags.#{Tag.topic_count_column(@guardian)} DESC\").first.name}\"\n      end\n    end\n    title\n  end\n\n  def title\n    @topic.title\n  end\n\n  def desired_post\n    return @desired_post if @desired_post.present?\n    return nil if posts.blank?\n\n    @desired_post = posts.detect { |p| p.post_number == @post_number }\n    @desired_post ||= posts.first\n    @desired_post\n  end\n\n  def summary(opts = {})\n    return nil if desired_post.blank?\n    # TODO, this is actually quite slow, should be cached in the post table\n    excerpt = desired_post.excerpt(500, opts.merge(strip_links: true, text_entities: true))\n    (excerpt || \"\").gsub(/\\n/, \" \").strip\n  end\n\n  def read_time\n    return nil if @post_number > 1 # only show for topic URLs\n\n    if @topic.word_count && SiteSetting.read_time_word_count > 0\n      [\n        @topic.word_count / SiteSetting.read_time_word_count,\n        @topic.posts_count * MIN_POST_READ_TIME / 60,\n      ].max.ceil\n    end\n  end\n\n  def like_count\n    return nil if @post_number > 1 # only show for topic URLs\n    @topic.like_count\n  end\n\n  def published_time\n    return nil if desired_post.blank?\n    if desired_post.wiki && desired_post.post_number == 1 && desired_post.revisions.size > 0\n      desired_post.revisions.last.updated_at.strftime(\"%FT%T%:z\")\n    else\n      desired_post.created_at.strftime(\"%FT%T%:z\")\n    end\n  end\n\n  def image_url\n    return @topic.image_url if @post_number == 1\n    desired_post&.image_url\n  end\n\n  def filter_posts(opts = {})\n    if opts[:post_number].present?\n      filter_posts_near(opts[:post_number].to_i)\n    elsif opts[:post_ids].present?\n      filter_posts_by_ids(opts[:post_ids])\n    elsif opts[:filter_post_number].present?\n      # Only used for megatopics where we do not load the entire post stream\n      filter_posts_by_post_number(opts[:filter_post_number], opts[:asc])\n    elsif opts[:best].present?\n      # Only used for wordpress\n      filter_best(opts[:best], opts)\n    else\n      filter_posts_paged(@page)\n    end\n  end\n\n  def primary_group_names\n    return @group_names if @group_names\n\n    primary_group_ids = Set.new\n    @posts.each do |p|\n      primary_group_ids << p.user.primary_group_id if p.user.try(:primary_group_id)\n    end\n\n    result = {}\n    unless primary_group_ids.empty?\n      Group.where(id: primary_group_ids.to_a).pluck(:id, :name).each { |g| result[g[0]] = g[1] }\n    end\n\n    @group_names = result\n  end\n\n  # Filter to all posts near a particular post number\n  def filter_posts_near(post_number)\n    posts_before = (@limit.to_f / 4).floor\n    posts_before = 1 if posts_before.zero?\n    sort_order = get_sort_order(post_number)\n\n    before_post_ids =\n      @filtered_posts\n        .reverse_order\n        .where(\"posts.sort_order < ?\", sort_order)\n        .limit(posts_before)\n        .pluck(:id)\n\n    post_ids =\n      before_post_ids +\n        @filtered_posts\n          .where(\"posts.sort_order >= ?\", sort_order)\n          .limit(@limit - before_post_ids.length)\n          .pluck(:id)\n\n    if post_ids.length < @limit\n      post_ids =\n        post_ids +\n          @filtered_posts\n            .reverse_order\n            .where(\"posts.sort_order < ?\", sort_order)\n            .offset(before_post_ids.length)\n            .limit(@limit - post_ids.length)\n            .pluck(:id)\n    end\n\n    filter_posts_by_ids(post_ids)\n  end\n\n  def filter_posts_paged(page)\n    page = [page, 1].max\n    min = @limit * (page - 1)\n\n    # Sometimes we don't care about the OP, for example when embedding comments\n    min = 1 if min == 0 && @exclude_first\n\n    filter_posts_by_ids(@filtered_posts.offset(min).limit(@limit).pluck(:id))\n  end\n\n  def filter_best(max, opts = {})\n    filter = FilterBestPosts.new(@topic, @filtered_posts, max, opts)\n    @posts = filter.posts\n    @filtered_posts = filter.filtered_posts\n  end\n\n  def read?(post_number)\n    return true unless @user\n    read_posts_set.include?(post_number)\n  end\n\n  def has_deleted?\n    @predelete_filtered_posts\n      .with_deleted\n      .where(\"posts.deleted_at IS NOT NULL\")\n      .where(\"posts.post_number > 1\")\n      .exists?\n  end\n\n  def topic_user\n    @topic_user ||=\n      begin\n        return nil if @user.blank?\n        @topic.topic_users.find_by(user_id: @user.id)\n      end\n  end\n\n  def has_bookmarks?\n    bookmarks.any?\n  end\n\n  def bookmarks\n    return [] if @user.blank?\n    return [] if @topic.trashed?\n\n    @bookmarks ||=\n      Bookmark.for_user_in_topic(@user, @topic.id).select(\n        :id,\n        :bookmarkable_id,\n        :bookmarkable_type,\n        :reminder_at,\n        :name,\n        :auto_delete_preference,\n      )\n  end\n\n  MAX_PARTICIPANTS = 24\n\n  def post_counts_by_user\n    @post_counts_by_user ||=\n      begin\n        if is_mega_topic?\n          {}\n        else\n          sql = <<~SQL\n            SELECT user_id, count(*) AS count_all\n              FROM posts\n             WHERE topic_id = :topic_id\n               AND post_type IN (:post_types)\n               AND user_id IS NOT NULL\n               AND posts.deleted_at IS NULL\n               AND action_code IS NULL\n          GROUP BY user_id\n          ORDER BY count_all DESC\n             LIMIT #{MAX_PARTICIPANTS}\n        SQL\n\n          Hash[\n            *DB.query_single(\n              sql,\n              topic_id: @topic.id,\n              post_types: Topic.visible_post_types(@guardian&.user),\n            )\n          ]\n        end\n      end\n  end\n\n  # if a topic has more that N posts no longer attempt to\n  # get accurate participant count, instead grab cached count\n  # from topic\n  MAX_POSTS_COUNT_PARTICIPANTS = 500\n\n  def participant_count\n    @participant_count ||=\n      begin\n        if participants.size == MAX_PARTICIPANTS\n          if @topic.posts_count > MAX_POSTS_COUNT_PARTICIPANTS\n            @topic.participant_count\n          else\n            sql = <<~SQL\n              SELECT COUNT(DISTINCT user_id)\n              FROM posts\n              WHERE id IN (:post_ids)\n              AND user_id IS NOT NULL\n            SQL\n            DB.query_single(sql, post_ids: unfiltered_post_ids).first.to_i\n          end\n        else\n          participants.size\n        end\n      end\n  end\n\n  def participants\n    @participants ||=\n      begin\n        participants = {}\n        User\n          .where(id: post_counts_by_user.keys)\n          .includes(:primary_group, :flair_group)\n          .each { |u| participants[u.id] = u }\n        participants\n      end\n  end\n\n  def topic_allowed_group_ids\n    @topic_allowed_group_ids ||=\n      begin\n        @topic.allowed_groups.map(&:id)\n      end\n  end\n\n  def group_allowed_user_ids\n    return @group_allowed_user_ids unless @group_allowed_user_ids.nil?\n\n    @group_allowed_user_ids =\n      GroupUser.where(group_id: topic_allowed_group_ids).pluck(\"distinct user_id\")\n  end\n\n  def category_group_moderator_user_ids\n    @category_group_moderator_user_ids ||=\n      begin\n        if SiteSetting.enable_category_group_moderation? &&\n             @topic.category&.reviewable_by_group.present?\n          posts_user_ids = Set.new(@posts.map(&:user_id))\n          Set.new(\n            @topic\n              .category\n              .reviewable_by_group\n              .group_users\n              .where(user_id: posts_user_ids)\n              .pluck(\"distinct user_id\"),\n          )\n        else\n          Set.new\n        end\n      end\n  end\n\n  def all_post_actions\n    @all_post_actions ||= PostAction.counts_for(@posts, @user)\n  end\n\n  def links\n    @links ||= TopicLink.topic_map(@guardian, @topic.id)\n  end\n\n  def reviewable_counts\n    @reviewable_counts ||=\n      begin\n        sql = <<~SQL\n        SELECT\n          target_id,\n          MAX(r.id) reviewable_id,\n          COUNT(*) total,\n          SUM(CASE WHEN s.status = :pending THEN 1 ELSE 0 END) pending\n        FROM\n          reviewables r\n        JOIN\n          reviewable_scores s ON reviewable_id = r.id\n        WHERE\n          r.target_id IN (:post_ids) AND\n          r.target_type = 'Post' AND\n          COALESCE(s.reason, '') != 'category'\n        GROUP BY\n          target_id\n      SQL\n\n        counts = {}\n\n        DB\n          .query(sql, pending: ReviewableScore.statuses[:pending], post_ids: @posts.map(&:id))\n          .each do |row|\n            counts[row.target_id] = {\n              total: row.total,\n              pending: row.pending,\n              reviewable_id: row.reviewable_id,\n            }\n          end\n\n        counts\n      end\n  end\n\n  def pending_posts\n    @pending_posts ||=\n      ReviewableQueuedPost.pending.where(created_by: @user, topic: @topic).order(:created_at)\n  end\n\n  def actions_summary\n    return @actions_summary unless @actions_summary.nil?\n\n    @actions_summary = []\n    return @actions_summary unless post = posts&.first\n    PostActionType.topic_flag_types.each do |sym, id|\n      @actions_summary << {\n        id: id,\n        count: 0,\n        hidden: false,\n        can_act: @guardian.post_can_act?(post, sym),\n      }\n    end\n\n    @actions_summary\n  end\n\n  def link_counts\n    @link_counts ||= TopicLink.counts_for(@guardian, @topic, posts)\n  end\n\n  def pm_params\n    @pm_params ||= TopicQuery.new(@user).get_pm_params(topic)\n  end\n\n  def suggested_topics\n    if @include_suggested\n      @suggested_topics ||= TopicQuery.new(@user).list_suggested_for(topic, pm_params: pm_params)\n    else\n      nil\n    end\n  end\n\n  def related_messages\n    if @include_related\n      @related_messages ||= TopicQuery.new(@user).list_related_for(topic, pm_params: pm_params)\n    else\n      nil\n    end\n  end\n\n  # This is pending a larger refactor, that allows custom orders\n  # for now we need to look for the highest_post_number in the stream\n  # the cache on topics is not correct if there are deleted posts at\n  # the end of the stream (for mods), nor is it correct for filtered\n  # streams\n  def highest_post_number\n    @highest_post_number ||= @filtered_posts.maximum(:post_number)\n  end\n\n  def recent_posts\n    @filtered_posts.unscope(:order).by_newest.with_user.first(25)\n  end\n\n  # Returns an array of [id, days_ago] tuples.\n  # `days_ago` is there for the timeline calculations.\n  def filtered_post_stream\n    @filtered_post_stream ||=\n      begin\n        posts = @filtered_posts\n        columns = [:id]\n\n        if !is_mega_topic?\n          columns << \"(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - posts.created_at) / 86400)::INT AS days_ago\"\n        end\n\n        posts.pluck(*columns)\n      end\n  end\n\n  def filtered_post_ids\n    @filtered_post_ids ||=\n      filtered_post_stream.map do |tuple|\n        if is_mega_topic?\n          tuple\n        else\n          tuple[0]\n        end\n      end\n  end\n\n  def unfiltered_post_ids\n    @unfiltered_post_ids ||=\n      begin\n        if @contains_gaps\n          unfiltered_posts.pluck(:id)\n        else\n          filtered_post_ids\n        end\n      end\n  end\n\n  def filtered_post_id(post_number)\n    @filtered_posts.where(post_number: post_number).pick(:id)\n  end\n\n  def is_mega_topic?\n    @is_mega_topic ||= (@topic.posts_count >= MEGA_TOPIC_POSTS_COUNT)\n  end\n\n  def last_post_id\n    @filtered_posts.reverse_order.pick(:id)\n  end\n\n  def current_post_number\n    if highest_post_number.present?\n      post_number > highest_post_number ? highest_post_number : post_number\n    end\n  end\n\n  def queued_posts_count\n    ReviewableQueuedPost.viewable_by(@user).where(topic_id: @topic.id).pending.count\n  end\n\n  def published_page\n    @topic.published_page\n  end\n\n  def mentioned_users\n    @mentioned_users ||=\n      begin\n        mentions = @posts.to_h { |p| [p.id, p.mentions] }.reject { |_, v| v.empty? }\n        usernames = mentions.values\n        usernames.flatten!\n        usernames.uniq!\n\n        users = User.where(username: usernames).includes(:user_status).index_by(&:username)\n\n        mentions.reduce({}) do |hash, (post_id, post_mentioned_usernames)|\n          hash[post_id] = post_mentioned_usernames.map { |username| users[username] }.compact\n          hash\n        end\n      end\n  end\n\n  protected\n\n  def read_posts_set\n    @read_posts_set ||=\n      begin\n        result = Set.new\n        return result unless @user.present?\n        return result unless topic_user.present?\n\n        post_numbers =\n          PostTiming\n            .where(topic_id: @topic.id, user_id: @user.id)\n            .where(post_number: @posts.pluck(:post_number))\n            .pluck(:post_number)\n\n        post_numbers.each { |pn| result << pn }\n        result\n      end\n  end\n\n  private\n\n  def calculate_page\n    posts_count =\n      is_mega_topic? ? @post_number : unfiltered_posts.where(\"post_number <= ?\", @post_number).count\n    ((posts_count - 1) / @limit) + 1\n  end\n\n  def get_sort_order(post_number)\n    sql = <<~SQL\n      SELECT posts.sort_order\n      FROM posts\n      WHERE posts.post_number = #{post_number.to_i}\n      AND posts.topic_id = #{@topic.id.to_i}\n      LIMIT 1\n    SQL\n\n    sort_order = DB.query_single(sql).first\n\n    if !sort_order\n      sql = <<~SQL\n        SELECT posts.sort_order\n        FROM posts\n        WHERE posts.topic_id = #{@topic.id.to_i}\n        ORDER BY @(post_number - #{post_number.to_i})\n        LIMIT 1\n      SQL\n\n      sort_order = DB.query_single(sql).first\n    end\n\n    sort_order\n  end\n\n  def filter_post_types(posts)\n    return posts.where(post_type: Post.types[:regular]) if @only_regular\n\n    visible_types = Topic.visible_post_types(@user)\n\n    if @user.present?\n      posts.where(\"posts.user_id = ? OR post_type IN (?)\", @user.id, visible_types)\n    else\n      posts.where(post_type: visible_types)\n    end\n  end\n\n  def filter_posts_by_post_number(post_number, asc)\n    sort_order = get_sort_order(post_number)\n\n    posts =\n      if asc\n        @filtered_posts.where(\"sort_order > ?\", sort_order)\n      else\n        @filtered_posts.reverse_order.where(\"sort_order < ?\", sort_order)\n      end\n\n    posts = posts.limit(@limit) if !@skip_limit\n    filter_posts_by_ids(posts.pluck(:id))\n\n    @posts = @posts.reverse_order if !asc\n  end\n\n  def filter_posts_by_ids(post_ids)\n    @posts =\n      Post.where(id: post_ids, topic_id: @topic.id).includes(\n        { user: %i[primary_group flair_group] },\n        :reply_to_user,\n        :deleted_by,\n        :incoming_email,\n        :image_upload,\n      )\n\n    @posts = @posts.includes({ user: :user_status }) if SiteSetting.enable_user_status\n\n    @posts = apply_default_scope(@posts)\n    @posts = filter_post_types(@posts)\n    @posts = @posts.with_deleted if @guardian.can_see_deleted_posts?(@topic.category)\n    @posts\n  end\n\n  def find_topic(topic_or_topic_id)\n    return topic_or_topic_id if topic_or_topic_id.is_a?(Topic)\n    # with_deleted covered in #check_and_raise_exceptions\n    Topic.with_deleted.includes(:category).find_by(id: topic_or_topic_id)\n  end\n\n  def unfiltered_posts\n    result = filter_post_types(@topic.posts)\n    result = result.with_deleted if @guardian.can_see_deleted_posts?(@topic.category)\n    result = result.where(\"user_id IS NOT NULL\") if @exclude_deleted_users\n    result = result.where(hidden: false) if @exclude_hidden\n    result\n  end\n\n  def apply_default_scope(scope)\n    scope = scope.order(sort_order: :asc)\n\n    self.class.custom_default_scopes.each { |block| scope = block.call(scope, self) }\n\n    scope\n  end\n\n  def setup_filtered_posts\n    # Certain filters might leave gaps between posts. If that's true, we can return a gap structure\n    @contains_gaps = false\n    @filtered_posts = unfiltered_posts\n\n    if @user\n      sql = <<~SQL\n        SELECT ignored_user_id\n        FROM ignored_users as ig\n        INNER JOIN users as u ON u.id = ig.ignored_user_id\n        WHERE ig.user_id = :current_user_id\n          AND ig.ignored_user_id <> :current_user_id\n          AND NOT u.admin\n          AND NOT u.moderator\n      SQL\n\n      ignored_user_ids = DB.query_single(sql, current_user_id: @user.id)\n\n      if ignored_user_ids.present?\n        @filtered_posts =\n          @filtered_posts.where.not(\"user_id IN (?) AND posts.post_number != 1\", ignored_user_ids)\n        @contains_gaps = true\n      end\n    end\n\n    # Filters\n    if @filter == \"summary\"\n      @filtered_posts = @filtered_posts.summary(@topic.id)\n      @contains_gaps = true\n    end\n\n    if @filter.present? && @filter.to_s != \"summary\" && TopicView.custom_filters[@filter].present?\n      @filtered_posts = TopicView.custom_filters[@filter].call(@filtered_posts, self)\n    end\n\n    if @best.present?\n      @filtered_posts = @filtered_posts.where(\"posts.post_type = ?\", Post.types[:regular])\n      @contains_gaps = true\n    end\n\n    # Username filters\n    if @username_filters.present?\n      usernames = @username_filters.map { |u| u.downcase }\n\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.user_id IN (SELECT u.id FROM users u WHERE u.username_lower IN (?))\n      \",\n          usernames,\n        )\n\n      @contains_gaps = true\n    end\n\n    # Filter replies\n    if @replies_to_post_number.present?\n      post_id = filtered_post_id(@replies_to_post_number.to_i)\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.post_number = :post_number\n        OR posts.reply_to_post_number = :post_number\n        OR posts.id IN (SELECT pr.reply_post_id FROM post_replies pr WHERE pr.post_id = :post_id)\",\n          { post_number: @replies_to_post_number.to_i, post_id: post_id },\n        )\n\n      @contains_gaps = true\n    end\n\n    # Show Only Top Level Replies\n    if @filter_top_level_replies.present?\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number > 1\n        AND posts.reply_to_post_number IS NULL\n      \",\n        )\n    end\n\n    # Filtering upwards\n    if @filter_upwards_post_id.present?\n      post = Post.find(@filter_upwards_post_id)\n      post_ids = DB.query_single(<<~SQL, post_id: post.id, topic_id: post.topic_id)\n      WITH RECURSIVE breadcrumb(id, reply_to_post_number) AS (\n            SELECT p.id, p.reply_to_post_number FROM posts AS p\n              WHERE p.id = :post_id\n            UNION\n              SELECT p.id, p.reply_to_post_number FROM posts AS p, breadcrumb\n                WHERE breadcrumb.reply_to_post_number = p.post_number\n                  AND p.topic_id = :topic_id\n          )\n      SELECT id from breadcrumb\n      WHERE id <> :post_id\n      ORDER by id\n      SQL\n\n      post_ids = (post_ids[(0 - SiteSetting.max_reply_history)..-1] || post_ids)\n      post_ids.push(post.id)\n\n      @filtered_posts =\n        @filtered_posts.where(\n          \"\n        posts.post_number = 1\n        OR posts.id IN (:post_ids)\n        OR posts.id > :max_post_id\",\n          { post_ids: post_ids, max_post_id: post_ids.max },\n        )\n\n      @contains_gaps = true\n    end\n\n    # Deleted\n    # This should be last - don't want to tell the admin about deleted posts that clicking the button won't show\n    # copy the filter for has_deleted? method\n    @predelete_filtered_posts = @filtered_posts.spawn\n\n    if @guardian.can_see_deleted_posts?(@topic.category) && !@show_deleted && has_deleted?\n      @filtered_posts = @filtered_posts.where(\"posts.deleted_at IS NULL OR posts.post_number = 1\")\n\n      @contains_gaps = true\n    end\n  end\n\n  def check_and_raise_exceptions(skip_staff_action)\n    raise Discourse::NotFound if @topic.blank?\n    # Special case: If the topic is private and the user isn't logged in, ask them\n    # to log in!\n    raise Discourse::NotLoggedIn.new if @topic.present? && @topic.private_message? && @user.blank?\n    # can user see this topic?\n    unless @guardian.can_see?(@topic)\n      raise Discourse::InvalidAccess.new(\"can't see #{@topic}\", @topic)\n    end\n    # log personal message views\n    if SiteSetting.log_personal_messages_views && !skip_staff_action && @topic.present? &&\n         @topic.private_message? && @topic.all_allowed_users.where(id: @user.id).blank?\n      unless UserHistory\n               .where(\n                 acting_user_id: @user.id,\n                 action: UserHistory.actions[:check_personal_message],\n                 topic_id: @topic.id,\n               )\n               .where(\"created_at > ?\", 1.hour.ago)\n               .exists?\n        StaffActionLogger.new(@user).log_check_personal_message(@topic)\n      end\n    end\n  end\n\n  def visible_tags\n    @visible_tags ||= topic.tags.visible(guardian)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"topic_view\"\n\nRSpec.describe TopicView do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:evil_trout) { Fabricate(:evil_trout) }\n  fab!(:first_poster) { topic.user }\n  fab!(:anonymous) { Fabricate(:anonymous) }\n\n  let(:topic_view) { TopicView.new(topic.id, evil_trout) }\n\n  describe \"preload\" do\n    it \"allows preloading of data\" do\n      preloaded_topic_view = nil\n      preloader = lambda { |view| preloaded_topic_view = view }\n\n      TopicView.on_preload(&preloader)\n\n      expect(preloaded_topic_view).to eq(nil)\n      topic_view\n      expect(preloaded_topic_view).to eq(topic_view)\n\n      TopicView.cancel_preload(&preloader)\n    end\n  end\n\n  it \"raises a not found error if the topic doesn't exist\" do\n    expect { TopicView.new(1_231_232, evil_trout) }.to raise_error(Discourse::NotFound)\n  end\n\n  it \"accepts a topic or a topic id\" do\n    expect(TopicView.new(topic, evil_trout).topic).to eq(topic)\n    expect(TopicView.new(topic.id, evil_trout).topic).to eq(topic)\n  end\n\n  # see also spec/controllers/topics_controller_spec.rb TopicsController::show::permission errors\n  it \"raises an error if the user can't see the topic\" do\n    Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n    expect { topic_view }.to raise_error(Discourse::InvalidAccess)\n  end\n\n  it \"handles deleted topics\" do\n    topic.trash!(admin)\n    expect { TopicView.new(topic.id, user) }.to raise_error(Discourse::InvalidAccess)\n    expect { TopicView.new(topic.id, admin) }.not_to raise_error\n  end\n\n  describe \"filter options\" do\n    fab!(:p0) { Fabricate(:post, topic: topic) }\n    fab!(:p1) { Fabricate(:post, topic: topic, post_type: Post.types[:moderator_action]) }\n    fab!(:p2) { Fabricate(:post, topic: topic, post_type: Post.types[:small_action]) }\n\n    it \"omits moderator actions and small posts when only_regular is set\" do\n      tv = TopicView.new(topic.id, nil)\n      expect(tv.filtered_post_ids).to eq([p0.id, p1.id, p2.id])\n\n      tv = TopicView.new(topic.id, nil, only_regular: true)\n      expect(tv.filtered_post_ids).to eq([p0.id])\n    end\n\n    it \"omits the first post when exclude_first is set\" do\n      tv = TopicView.new(topic.id, nil, exclude_first: true)\n      expect(tv.filtered_post_ids).to eq([p0.id, p1.id, p2.id])\n    end\n  end\n\n  describe \"custom filters\" do\n    fab!(:p0) { Fabricate(:post, topic: topic) }\n    fab!(:p1) { Fabricate(:post, topic: topic, wiki: true) }\n\n    it \"allows to register custom filters\" do\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"wiki\" })\n      expect(tv.filter_posts({ filter: \"wiki\" })).to eq([p0, p1])\n\n      TopicView.add_custom_filter(\"wiki\") { |posts, topic_view| posts.where(wiki: true) }\n\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"wiki\" })\n      expect(tv.filter_posts).to eq([p1])\n\n      tv = TopicView.new(topic.id, evil_trout, { filter: \"whatever\" })\n      expect(tv.filter_posts).to eq([p0, p1])\n    ensure\n      TopicView.instance_variable_set(:@custom_filters, {})\n    end\n  end\n\n  describe \"setup_filtered_posts\" do\n    describe \"filters posts with ignored users\" do\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: evil_trout, ignored_user: user) }\n      let!(:post) { Fabricate(:post, topic: topic, user: first_poster) }\n      let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout) }\n      let!(:post3) { Fabricate(:post, topic: topic, user: user) }\n\n      it \"filters out ignored user posts\" do\n        tv = TopicView.new(topic.id, evil_trout)\n        expect(tv.filtered_post_ids).to eq([post.id, post2.id])\n      end\n\n      it \"returns nil for next_page\" do\n        tv = TopicView.new(topic.id, evil_trout)\n        expect(tv.next_page).to eq(nil)\n      end\n\n      context \"when an ignored user made the original post\" do\n        let!(:post) { Fabricate(:post, topic: topic, user: user) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id])\n        end\n      end\n\n      context \"when an anonymous user made a post\" do\n        let!(:post4) { Fabricate(:post, topic: topic, user: anonymous) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post4.id])\n        end\n      end\n\n      context \"when an anonymous (non signed-in) user is viewing a Topic\" do\n        let!(:post4) { Fabricate(:post, topic: topic, user: anonymous) }\n\n        it \"filters out ignored user posts only\" do\n          tv = TopicView.new(topic.id, nil)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post3.id, post4.id])\n        end\n      end\n\n      context \"when a staff user is ignored\" do\n        let!(:admin) { Fabricate(:user, admin: true) }\n        let!(:admin_ignored_user) do\n          Fabricate(:ignored_user, user: evil_trout, ignored_user: admin)\n        end\n        let!(:post4) { Fabricate(:post, topic: topic, user: admin) }\n\n        it \"filters out ignored user excluding the staff user\" do\n          tv = TopicView.new(topic.id, evil_trout)\n          expect(tv.filtered_post_ids).to eq([post.id, post2.id, post4.id])\n        end\n      end\n    end\n  end\n\n  describe \"chunk_size\" do\n    it \"returns `chunk_size` by default\" do\n      expect(TopicView.new(topic.id, evil_trout).chunk_size).to eq(TopicView.chunk_size)\n    end\n\n    it \"returns `print_chunk_size` when print param is true\" do\n      tv = TopicView.new(topic.id, evil_trout, print: true)\n      expect(tv.chunk_size).to eq(TopicView.print_chunk_size)\n    end\n  end\n\n  context \"with a few sample posts\" do\n    fab!(:p1) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 1) }\n    fab!(:p2) { Fabricate(:post, topic: topic, user: evil_trout, percent_rank: 0.5) }\n    fab!(:p3) { Fabricate(:post, topic: topic, user: first_poster, percent_rank: 0) }\n\n    it \"it can find the best responses\" do\n      best2 = TopicView.new(topic.id, evil_trout, best: 2)\n      expect(best2.posts.count).to eq(2)\n      expect(best2.posts[0].id).to eq(p2.id)\n      expect(best2.posts[1].id).to eq(p3.id)\n\n      topic.update_status(\"closed\", true, admin)\n      expect(topic.posts.count).to eq(4)\n\n      # should not get the status post\n      best = TopicView.new(topic.id, nil, best: 99)\n      expect(best.posts.count).to eq(2)\n      expect(best.filtered_post_ids.size).to eq(3)\n      expect(best.posts.pluck(:id)).to match_array([p2.id, p3.id])\n\n      # should get no results for trust level too low\n      best = TopicView.new(topic.id, nil, best: 99, min_trust_level: evil_trout.trust_level + 1)\n      expect(best.posts.count).to eq(0)\n\n      # should filter out the posts with a score that is too low\n      best = TopicView.new(topic.id, nil, best: 99, min_score: 99)\n      expect(best.posts.count).to eq(0)\n\n      # should filter out everything if min replies not met\n      best = TopicView.new(topic.id, nil, best: 99, min_replies: 99)\n      expect(best.posts.count).to eq(0)\n\n      # should punch through posts if the score is high enough\n      p2.update_column(:score, 100)\n\n      best =\n        TopicView.new(\n          topic.id,\n          nil,\n          best: 99,\n          bypass_trust_level_score: 100,\n          min_trust_level: evil_trout.trust_level + 1,\n        )\n      expect(best.posts.count).to eq(1)\n\n      # 0 means ignore\n      best =\n        TopicView.new(\n          topic.id,\n          nil,\n          best: 99,\n          bypass_trust_level_score: 0,\n          min_trust_level: evil_trout.trust_level + 1,\n        )\n      expect(best.posts.count).to eq(0)\n\n      # If we restrict to posts a moderator liked, return none\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(0)\n\n      # It doesn't count likes from admins\n      PostActionCreator.like(admin, p3)\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(0)\n\n      # It should find the post liked by the moderator\n      PostActionCreator.like(moderator, p2)\n      best = TopicView.new(topic.id, nil, best: 99, only_moderator_liked: true)\n      expect(best.posts.count).to eq(1)\n    end\n\n    it \"raises NotLoggedIn if the user isn't logged in and is trying to view a private message\" do\n      Topic.any_instance.expects(:private_message?).returns(true)\n      expect { TopicView.new(topic.id, nil) }.to raise_error(Discourse::NotLoggedIn)\n    end\n\n    context \"when log_check_personal_message is enabled\" do\n      fab!(:group) { Fabricate(:group) }\n      fab!(:private_message) { Fabricate(:private_message_topic, allowed_groups: [group]) }\n\n      before do\n        SiteSetting.log_personal_messages_views = true\n        evil_trout.admin = true\n      end\n\n      it \"logs view if Admin views personal message for other user/group\" do\n        allowed_user = private_message.topic_allowed_users.first.user\n        TopicView.new(private_message.id, allowed_user)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          1,\n        )\n      end\n\n      it \"does not log personal message view for group he belongs to\" do\n        group.users << evil_trout\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view for his own personal message\" do\n        private_message.allowed_users << evil_trout\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view if user can't see the message\" do\n        expect { TopicView.new(private_message.id, user) }.to raise_error(Discourse::InvalidAccess)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          0,\n        )\n      end\n\n      it \"does not log personal message view if there exists a similar log in previous hour\" do\n        2.times { TopicView.new(private_message.id, evil_trout) }\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          1,\n        )\n\n        freeze_time (2.hours.from_now)\n\n        TopicView.new(private_message.id, evil_trout)\n        expect(UserHistory.where(action: UserHistory.actions[:check_personal_message]).count).to eq(\n          2,\n        )\n      end\n    end\n\n    it \"provides an absolute url\" do\n      expect(topic_view.absolute_url).to eq(\"http://test.localhost/t/#{topic.slug}/#{topic.id}\")\n    end\n\n    context \"with subfolder\" do\n      it \"provides the correct absolute url\" do\n        set_subfolder \"/forum\"\n        expect(topic_view.absolute_url).to eq(\n          \"http://test.localhost/forum/t/#{topic.slug}/#{topic.id}\",\n        )\n      end\n    end\n\n    it \"provides a summary of the first post\" do\n      expect(topic_view.summary).to be_present\n    end\n\n    describe \"#get_canonical_path\" do\n      fab!(:topic) { Fabricate(:topic) }\n      let(:path) { \"/1234\" }\n\n      before do\n        topic.stubs(:relative_url).returns(path)\n        TopicView.any_instance.stubs(:find_topic).with(1234).returns(topic)\n      end\n\n      it \"generates canonical path correctly\" do\n        expect(TopicView.new(1234, user).canonical_path).to eql(path)\n        expect(TopicView.new(1234, user, page: 5).canonical_path).to eql(\"/1234?page=5\")\n      end\n\n      it \"generates a canonical correctly for paged results\" do\n        5.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n\n        expect(TopicView.new(1234, user, post_number: 5, limit: 2).canonical_path).to eql(\n          \"/1234?page=3\",\n        )\n      end\n\n      it \"generates canonical path correctly by skipping whisper posts\" do\n        2.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n        2.times { |i| Fabricate(:whisper, post_number: i + 3, topic: topic) }\n        Fabricate(:post, post_number: 5, topic: topic)\n\n        expect(TopicView.new(1234, user, post_number: 5, limit: 2).canonical_path).to eql(\n          \"/1234?page=2\",\n        )\n      end\n\n      it \"generates canonical path correctly for mega topics\" do\n        2.times { |i| Fabricate(:post, post_number: i + 1, topic: topic) }\n        2.times { |i| Fabricate(:whisper, post_number: i + 3, topic: topic) }\n        Fabricate(:post, post_number: 5, topic: topic)\n\n        expect(\n          TopicView.new(1234, user, post_number: 5, limit: 2, is_mega_topic: true).canonical_path,\n        ).to eql(\"/1234?page=3\")\n      end\n    end\n\n    describe \"#next_page\" do\n      let!(:post) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post2) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post3) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post4) { Fabricate(:post, topic: topic, user: user) }\n      let!(:post5) { Fabricate(:post, topic: topic, user: user) }\n\n      before { TopicView.stubs(:chunk_size).returns(2) }\n\n      it \"should return the next page\" do\n        expect(TopicView.new(topic.id, user, { post_number: post.post_number }).next_page).to eql(3)\n      end\n    end\n\n    describe \".post_counts_by_user\" do\n      it \"returns the two posters with their appropriate counts\" do\n        SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n        Fabricate(:post, topic: topic, user: evil_trout, post_type: Post.types[:whisper])\n        # Should not be counted\n        Fabricate(\n          :post,\n          topic: topic,\n          user: evil_trout,\n          post_type: Post.types[:whisper],\n          action_code: \"assign\",\n        )\n\n        expect(TopicView.new(topic.id, admin).post_counts_by_user.to_a).to match_array(\n          [[first_poster.id, 2], [evil_trout.id, 2]],\n        )\n\n        expect(TopicView.new(topic.id, first_poster).post_counts_by_user.to_a).to match_array(\n          [[first_poster.id, 2], [evil_trout.id, 1]],\n        )\n      end\n\n      it \"doesn't return counts for posts with authors who have been deleted\" do\n        p2.user_id = nil\n        p2.save!\n\n        expect(topic_view.post_counts_by_user.to_a).to match_array([[first_poster.id, 2]])\n      end\n    end\n\n    describe \".participants\" do\n      it \"returns the two participants hashed by id\" do\n        expect(topic_view.participants.to_a).to match_array(\n          [[first_poster.id, first_poster], [evil_trout.id, evil_trout]],\n        )\n      end\n    end\n\n    describe \".all_post_actions\" do\n      it \"is blank at first\" do\n        expect(topic_view.all_post_actions).to be_blank\n      end\n\n      it \"returns the like\" do\n        PostActionCreator.like(evil_trout, p1)\n        expect(topic_view.all_post_actions[p1.id][PostActionType.types[:like]]).to be_present\n      end\n    end\n\n    describe \".read?\" do\n      it \"tracks correctly\" do\n        # anon is assumed to have read everything\n        expect(TopicView.new(topic.id).read?(1)).to eq(true)\n\n        # random user has nothing\n        expect(topic_view.read?(1)).to eq(false)\n\n        evil_trout.created_at = 2.days.ago\n\n        # a real user that just read it should have it marked\n        PostTiming.process_timings(evil_trout, topic.id, 1, [[1, 1000]])\n        expect(TopicView.new(topic.id, evil_trout).read?(1)).to eq(true)\n        expect(TopicView.new(topic.id, evil_trout).topic_user).to be_present\n      end\n    end\n\n    describe \"#bookmarks\" do\n      let!(:user) { Fabricate(:user) }\n      let!(:bookmark1) do\n        Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic), user: user)\n      end\n      let!(:bookmark2) do\n        Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic), user: user)\n      end\n      let!(:bookmark3) { Fabricate(:bookmark, bookmarkable: Fabricate(:post, topic: topic)) }\n\n      it \"returns all the bookmarks in the topic for a user\" do\n        expect(TopicView.new(topic.id, user).bookmarks.pluck(:id)).to match_array(\n          [bookmark1.id, bookmark2.id],\n        )\n      end\n\n      it \"returns [] for anon users\" do\n        expect(TopicView.new(topic.id, nil).bookmarks.pluck(:id)).to eq([])\n      end\n    end\n\n    describe \"#bookmarks\" do\n      let!(:user) { Fabricate(:user) }\n      let!(:bookmark1) do\n        Fabricate(:bookmark_next_business_day_reminder, bookmarkable: topic.first_post, user: user)\n      end\n      let!(:bookmark2) do\n        Fabricate(\n          :bookmark_next_business_day_reminder,\n          bookmarkable: topic.posts.order(:post_number)[1],\n          user: user,\n        )\n      end\n\n      it \"gets the first post bookmark reminder at for the user\" do\n        topic_view = TopicView.new(topic.id, user)\n\n        first, second = topic_view.bookmarks.sort_by(&:id)\n        expect(first[:bookmarkable_id]).to eq(bookmark1.bookmarkable_id)\n        expect(first[:reminder_at]).to eq_time(bookmark1.reminder_at)\n        expect(second[:bookmarkable_id]).to eq(bookmark2.bookmarkable_id)\n        expect(second[:reminder_at]).to eq_time(bookmark2.reminder_at)\n      end\n\n      context \"when the topic is deleted\" do\n        it \"returns []\" do\n          topic_view = TopicView.new(topic, user)\n          expect(topic_view.bookmarks).to match_array([bookmark1, bookmark2])\n          PostDestroyer.new(Fabricate(:admin), topic.first_post).destroy\n          topic.reload\n          topic_view.instance_variable_set(:@bookmarks, nil)\n          expect(topic_view.bookmarks).to eq([])\n        end\n      end\n\n      context \"when one of the posts is deleted\" do\n        it \"does not return that post's bookmark\" do\n          topic_view = TopicView.new(topic, user)\n          PostDestroyer.new(Fabricate(:admin), topic.posts.second).destroy\n          topic.reload\n\n          expect(topic_view.bookmarks.length).to eq(1)\n          first = topic_view.bookmarks.first\n          expect(first[:bookmarkable_id]).to eq(bookmark1.bookmarkable_id)\n          expect(first[:reminder_at]).to eq_time(bookmark1.reminder_at)\n        end\n      end\n    end\n\n    describe \".topic_user\" do\n      it \"returns nil when there is no user\" do\n        expect(TopicView.new(topic.id, nil).topic_user).to be_blank\n      end\n    end\n\n    describe \"#recent_posts\" do\n      before do\n        24.times do |t| # our let()s have already created 3\n          Fabricate(:post, topic: topic, user: first_poster, created_at: t.seconds.from_now)\n        end\n      end\n\n      it \"returns at most 25 recent posts ordered newest first\" do\n        recent_posts = topic_view.recent_posts\n\n        # count\n        expect(recent_posts.count).to eq(25)\n\n        # ordering\n        expect(recent_posts.include?(p1)).to eq(false)\n        expect(recent_posts.include?(p3)).to eq(true)\n        expect(recent_posts.first.created_at).to be > recent_posts.last.created_at\n      end\n    end\n  end\n\n  describe \"whispers\" do\n    it \"handles their visibility properly\" do\n      SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\"\n      p1 = Fabricate(:post, topic: topic, user: evil_trout)\n      p2 = Fabricate(:post, topic: topic, user: evil_trout, post_type: Post.types[:whisper])\n      p3 = Fabricate(:post, topic: topic, user: evil_trout)\n\n      ch_posts = TopicView.new(topic.id, evil_trout).posts\n      expect(ch_posts.map(&:id)).to eq([p1.id, p2.id, p3.id])\n\n      anon_posts = TopicView.new(topic.id).posts\n      expect(anon_posts.map(&:id)).to eq([p1.id, p3.id])\n\n      admin_posts = TopicView.new(topic.id, moderator).posts\n      expect(admin_posts.map(&:id)).to eq([p1.id, p2.id, p3.id])\n    end\n  end\n\n  describe \"#posts\" do\n    # Create the posts in a different order than the sort_order\n    let!(:p5) { Fabricate(:post, topic: topic, user: evil_trout) }\n    let!(:p2) { Fabricate(:post, topic: topic, user: evil_trout) }\n    let!(:p6) { Fabricate(:post, topic: topic, user: user, deleted_at: Time.now) }\n    let!(:p4) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }\n    let!(:p1) { Fabricate(:post, topic: topic, user: first_poster) }\n    let!(:p7) { Fabricate(:post, topic: topic, user: evil_trout, deleted_at: Time.now) }\n    let!(:p3) { Fabricate(:post, topic: topic, user: first_poster) }\n\n    before do\n      TopicView.stubs(:chunk_size).returns(3)\n\n      # Update them to the sort order we're checking for\n      [p1, p2, p3, p4, p5, p6, p7].each_with_index do |p, idx|\n        p.sort_order = idx + 1\n        p.save\n      end\n      p6.user_id = nil # user got nuked\n      p6.save!\n    end\n\n    describe \"contains_gaps?\" do\n      it \"works\" do\n        # does not contain contains_gaps with default filtering\n        expect(topic_view.contains_gaps?).to eq(false)\n        # contains contains_gaps when filtered by username\" do\n        expect(\n          TopicView.new(topic.id, evil_trout, username_filters: [\"eviltrout\"]).contains_gaps?,\n        ).to eq(true)\n        # contains contains_gaps when filtered by summary\n        expect(TopicView.new(topic.id, evil_trout, filter: \"summary\").contains_gaps?).to eq(true)\n        # contains contains_gaps when filtered by best\n        expect(TopicView.new(topic.id, evil_trout, best: 5).contains_gaps?).to eq(true)\n      end\n    end\n\n    it \"#restricts to correct topic\" do\n      t2 = Fabricate(:topic)\n\n      category = Fabricate(:category, name: \"my test\")\n      category.set_permissions(Group[:admins] => :full)\n      category.save\n\n      topic.category_id = category.id\n      topic.save!\n\n      expect { TopicView.new(topic.id, evil_trout).posts.count }.to raise_error(\n        Discourse::InvalidAccess,\n      )\n\n      expect(TopicView.new(t2.id, evil_trout, post_ids: [p1.id, p2.id]).posts.count).to eq(0)\n    end\n\n    describe \"#filter_posts_paged\" do\n      before { TopicView.stubs(:chunk_size).returns(2) }\n\n      it \"returns correct posts for all pages\" do\n        expect(topic_view.filter_posts_paged(1)).to eq([p1, p2])\n        expect(topic_view.filter_posts_paged(2)).to eq([p3, p5])\n        expect(topic_view.filter_posts_paged(3)).to eq([])\n        expect(topic_view.filter_posts_paged(100)).to eq([])\n      end\n    end\n\n    describe \"#filter_posts_by_post_number\" do\n      def create_topic_view(post_number)\n        TopicView.new(topic.id, evil_trout, filter_post_number: post_number, asc: asc)\n      end\n\n      describe \"ascending\" do\n        let(:asc) { true }\n\n        it \"should return the right posts\" do\n          topic_view = create_topic_view(p3.post_number)\n\n          expect(topic_view.posts).to eq([p5])\n\n          topic_view = create_topic_view(p6.post_number)\n          expect(topic_view.posts).to eq([])\n        end\n      end\n\n      describe \"descending\" do\n        let(:asc) { false }\n\n        it \"should return the right posts\" do\n          topic_view = create_topic_view(p7.post_number)\n\n          expect(topic_view.posts).to eq([p5, p3, p2])\n\n          topic_view = create_topic_view(p2.post_number)\n\n          expect(topic_view.posts).to eq([p1])\n        end\n      end\n    end\n\n    describe \"filter_posts_near\" do\n      def topic_view_near(post, show_deleted = false)\n        TopicView.new(\n          topic.id,\n          evil_trout,\n          post_number: post.post_number,\n          show_deleted: show_deleted,\n        )\n      end\n\n      it \"snaps to the lower boundary\" do\n        near_view = topic_view_near(p1)\n        expect(near_view.desired_post).to eq(p1)\n        expect(near_view.posts).to eq([p1, p2, p3])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"snaps to the upper boundary\" do\n        near_view = topic_view_near(p5)\n        expect(near_view.desired_post).to eq(p5)\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"returns the posts in the middle\" do\n        near_view = topic_view_near(p2)\n        expect(near_view.desired_post).to eq(p2)\n        expect(near_view.posts).to eq([p1, p2, p3])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      describe \"when post_number is too large\" do\n        it \"snaps to the lower boundary\" do\n          near_view = TopicView.new(topic.id, evil_trout, post_number: 99_999_999)\n\n          expect(near_view.desired_post).to eq(p2)\n          expect(near_view.posts).to eq([p2, p3, p5])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n      end\n\n      it \"gaps deleted posts to an admin\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p3)\n        expect(near_view.desired_post).to eq(p3)\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n        expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n      end\n\n      it \"returns deleted posts to an admin with show_deleted\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p3, true)\n        expect(near_view.desired_post).to eq(p3)\n        expect(near_view.posts).to eq([p2, p3, p4])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      it \"gaps deleted posts by nuked users to an admin\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p5)\n        expect(near_view.desired_post).to eq(p5)\n        # note: both p4 and p6 get skipped\n        expect(near_view.posts).to eq([p2, p3, p5])\n        expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n        expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n      end\n\n      it \"returns deleted posts by nuked users to an admin with show_deleted\" do\n        evil_trout.admin = true\n        near_view = topic_view_near(p5, true)\n        expect(near_view.desired_post).to eq(p5)\n        expect(near_view.posts).to eq([p4, p5, p6])\n        expect(near_view.contains_gaps?).to eq(false)\n      end\n\n      context \"when 'posts per page' exceeds the number of posts\" do\n        before { TopicView.stubs(:chunk_size).returns(100) }\n\n        it \"returns all the posts\" do\n          near_view = topic_view_near(p5)\n          expect(near_view.posts).to eq([p1, p2, p3, p5])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n\n        it \"gaps deleted posts to admins\" do\n          evil_trout.admin = true\n          near_view = topic_view_near(p5)\n          expect(near_view.posts).to eq([p1, p2, p3, p5])\n          expect(near_view.gaps.before).to eq(p5.id => [p4.id])\n          expect(near_view.gaps.after).to eq(p5.id => [p6.id, p7.id])\n        end\n\n        it \"returns deleted posts to admins\" do\n          evil_trout.admin = true\n          near_view = topic_view_near(p5, true)\n          expect(near_view.posts).to eq([p1, p2, p3, p4, p5, p6, p7])\n          expect(near_view.contains_gaps?).to eq(false)\n        end\n      end\n    end\n  end\n\n  describe \"page_title\" do\n    fab!(:tag1) { Fabricate(:tag, staff_topic_count: 0, public_topic_count: 0) }\n    fab!(:tag2) { Fabricate(:tag, staff_topic_count: 2, public_topic_count: 2) }\n    fab!(:op_post) { Fabricate(:post, topic: topic) }\n    fab!(:post1) { Fabricate(:post, topic: topic) }\n    fab!(:whisper) { Fabricate(:post, topic: topic, post_type: Post.types[:whisper]) }\n\n    subject { TopicView.new(topic.id, evil_trout).page_title }\n\n    context \"when a post number is specified\" do\n      context \"with admins\" do\n        it \"see post number and username for all posts\" do\n          title = TopicView.new(topic.id, admin, post_number: 0).page_title\n          expect(title).to eq(topic.title)\n          title = TopicView.new(topic.id, admin, post_number: 1).page_title\n          expect(title).to eq(topic.title)\n\n          title = TopicView.new(topic.id, admin, post_number: 2).page_title\n          expect(title).to eq(\"#{topic.title} - #2 by #{post1.user.username}\")\n          title = TopicView.new(topic.id, admin, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3 by #{whisper.user.username}\")\n        end\n      end\n\n      context \"with regular users\" do\n        it \"see post number and username for regular posts\" do\n          title = TopicView.new(topic.id, evil_trout, post_number: 0).page_title\n          expect(title).to eq(topic.title)\n          title = TopicView.new(topic.id, evil_trout, post_number: 1).page_title\n          expect(title).to eq(topic.title)\n\n          title = TopicView.new(topic.id, evil_trout, post_number: 2).page_title\n          expect(title).to eq(\"#{topic.title} - #2 by #{post1.user.username}\")\n        end\n\n        it \"see only post number for whisper posts\" do\n          title = TopicView.new(topic.id, evil_trout, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3\")\n          post2 = Fabricate(:post, topic: topic)\n          topic.reload\n          title = TopicView.new(topic.id, evil_trout, post_number: 3).page_title\n          expect(title).to eq(\"#{topic.title} - #3\")\n          title = TopicView.new(topic.id, evil_trout, post_number: 4).page_title\n          expect(title).to eq(\"#{topic.title} - #4 by #{post2.user.username}\")\n        end\n      end\n    end\n\n    context \"with uncategorized topic\" do\n      context \"when topic_page_title_includes_category is false\" do\n        before { SiteSetting.topic_page_title_includes_category = false }\n        it { is_expected.to eq(topic.title) }\n      end\n\n      context \"when topic_page_title_includes_category is true\" do\n        before { SiteSetting.topic_page_title_includes_category = true }\n        it { is_expected.to eq(topic.title) }\n\n        context \"with tagged topic\" do\n          before { topic.tags << [tag1, tag2] }\n\n          context \"with tagging enabled\" do\n            before { SiteSetting.tagging_enabled = true }\n\n            it { is_expected.to start_with(topic.title) }\n            it { is_expected.not_to include(tag1.name) }\n            it { is_expected.to end_with(tag2.name) } # tag2 has higher topic count\n          end\n\n          context \"with tagging disabled\" do\n            before { SiteSetting.tagging_enabled = false }\n\n            it { is_expected.to start_with(topic.title) }\n            it { is_expected.not_to include(tag1.name) }\n            it { is_expected.not_to include(tag2.name) }\n          end\n\n          context \"with restricted tags\" do\n            let(:tag_group) { Fabricate.build(:tag_group) }\n            let(:tag_group_permission) do\n              Fabricate.build(:tag_group_permission, tag_group: tag_group)\n            end\n\n            before do\n              SiteSetting.tagging_enabled = true\n              # avoid triggering a `before_create` callback in `TagGroup` which\n              # messes with permissions\n              tag_group.tag_group_permissions << tag_group_permission\n              tag_group.save!\n              tag_group_permission.tag_group.tags << tag2\n            end\n\n            it { is_expected.not_to include(tag2.name) }\n            it { is_expected.to include(tag1.name) }\n          end\n        end\n      end\n    end\n\n    context \"with categorized topic\" do\n      let(:category) { Fabricate(:category) }\n\n      before { topic.update(category_id: category.id) }\n\n      context \"when topic_page_title_includes_category is false\" do\n        before { SiteSetting.topic_page_title_includes_category = false }\n        it { is_expected.to eq(topic.title) }\n      end\n\n      context \"when topic_page_title_includes_category is true\" do\n        before { SiteSetting.topic_page_title_includes_category = true }\n        it { is_expected.to start_with(topic.title) }\n        it { is_expected.to end_with(category.name) }\n\n        context \"with tagged topic\" do\n          before do\n            SiteSetting.tagging_enabled = true\n            topic.tags << [tag1, tag2]\n          end\n\n          it { is_expected.to start_with(topic.title) }\n          it { is_expected.to end_with(category.name) }\n          it { is_expected.not_to include(tag1.name) }\n          it { is_expected.not_to include(tag2.name) }\n        end\n      end\n    end\n  end\n\n  describe \"#filtered_post_stream\" do\n    let!(:post) { Fabricate(:post, topic: topic, user: first_poster, created_at: 18.hours.ago) }\n    let!(:post2) { Fabricate(:post, topic: topic, user: evil_trout, created_at: 6.hours.ago) }\n    let!(:post3) { Fabricate(:post, topic: topic, user: first_poster) }\n\n    it \"should return the right columns\" do\n      expect(topic_view.filtered_post_stream).to eq([[post.id, 1], [post2.id, 0], [post3.id, 0]])\n    end\n\n    describe \"for mega topics\" do\n      it \"should return the right columns\" do\n        stub_const(TopicView, \"MEGA_TOPIC_POSTS_COUNT\", 2) do\n          expect(topic_view.filtered_post_stream).to eq([post.id, post2.id, post3.id])\n        end\n      end\n    end\n  end\n\n  describe \"#filtered_post_id\" do\n    it \"should return the right id\" do\n      post = Fabricate(:post, topic: topic)\n\n      expect(topic_view.filtered_post_id(nil)).to eq(nil)\n      expect(topic_view.filtered_post_id(post.post_number)).to eq(post.id)\n    end\n  end\n\n  describe \"#last_post_id\" do\n    let!(:p3) { Fabricate(:post, topic: topic) }\n    let!(:p2) { Fabricate(:post, topic: topic) }\n    let!(:p1) { Fabricate(:post, topic: topic) }\n\n    before { [p1, p2, p3].each_with_index { |post, index| post.update!(sort_order: index + 1) } }\n\n    it \"should return the right id\" do\n      expect(topic_view.last_post_id).to eq(p3.id)\n    end\n  end\n\n  describe \"#read_time\" do\n    let!(:post) { Fabricate(:post, topic: topic) }\n\n    before do\n      PostCreator.create!(\n        Discourse.system_user,\n        topic_id: topic.id,\n        raw: \"![image|100x100](upload://upload.png)\",\n      )\n      topic_view.topic.reload\n    end\n\n    it \"should return the right read time\" do\n      SiteSetting.read_time_word_count = 500\n      expect(topic_view.read_time).to eq(1)\n\n      SiteSetting.read_time_word_count = 0\n      expect(topic_view.read_time).to eq(nil)\n    end\n  end\n\n  describe \"#image_url\" do\n    fab!(:op_upload) { Fabricate(:image_upload) }\n    fab!(:post3_upload) { Fabricate(:image_upload) }\n\n    fab!(:post1) { Fabricate(:post, topic: topic) }\n    fab!(:post2) { Fabricate(:post, topic: topic) }\n    fab!(:post3) do\n      Fabricate(:post, topic: topic)\n        .tap { |p| p.update_column(:image_upload_id, post3_upload.id) }\n        .reload\n    end\n\n    def topic_view_for_post(post_number)\n      TopicView.new(topic.id, evil_trout, post_number: post_number)\n    end\n\n    context \"when op has an image\" do\n      before do\n        topic.update_column(:image_upload_id, op_upload.id)\n        post1.update_column(:image_upload_id, op_upload.id)\n      end\n\n      it \"uses the topic image for op and posts image when they have one\" do\n        expect(topic_view_for_post(1).image_url).to end_with(op_upload.url)\n        expect(topic_view_for_post(2).image_url).to eq(nil)\n        expect(topic_view_for_post(3).image_url).to end_with(post3_upload.url)\n      end\n    end\n\n    context \"when op has no image\" do\n      it \"returns nil when posts have no image\" do\n        expect(topic_view_for_post(1).image_url).to eq(nil)\n        expect(topic_view_for_post(2).image_url).to eq(nil)\n        expect(topic_view_for_post(3).image_url).to end_with(post3_upload.url)\n      end\n    end\n  end\n\n  describe \"#show_read_indicator?\" do\n    let(:topic) { Fabricate(:topic) }\n    let(:pm_topic) { Fabricate(:private_message_topic) }\n\n    it \"shows read indicator for private messages\" do\n      group = Fabricate(:group, users: [admin], publish_read_state: true)\n      pm_topic.topic_allowed_groups = [Fabricate.build(:topic_allowed_group, group: group)]\n\n      topic_view = TopicView.new(pm_topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_truthy\n    end\n\n    it \"does not show read indicator if groups do not have read indicator enabled\" do\n      topic_view = TopicView.new(pm_topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_falsey\n    end\n\n    it \"does not show read indicator for topics with allowed groups\" do\n      group = Fabricate(:group, users: [admin], publish_read_state: true)\n      topic.topic_allowed_groups = [Fabricate.build(:topic_allowed_group, group: group)]\n\n      topic_view = TopicView.new(topic.id, admin)\n      expect(topic_view.show_read_indicator?).to be_falsey\n    end\n  end\n\n  describe \"#reviewable_counts\" do\n    it \"exclude posts queued because the category needs approval\" do\n      category = Fabricate.build(:category, user: admin)\n      category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n      category.save!\n      manager =\n        NewPostManager.new(\n          user,\n          raw: \"to the handler I say enqueue me!\",\n          title: \"this is the title of the queued post\",\n          category: category.id,\n        )\n      result = manager.perform\n      reviewable = result.reviewable\n      reviewable.perform(admin, :approve_post)\n\n      topic_view = TopicView.new(reviewable.topic, admin)\n\n      expect(topic_view.reviewable_counts).to be_empty\n    end\n\n    it \"include posts queued for other reasons\" do\n      Fabricate(:watched_word, word: \"darn\", action: WatchedWord.actions[:require_approval])\n      manager =\n        NewPostManager.new(\n          user,\n          raw: \"this is darn new post content\",\n          title: \"this is the title of the queued post\",\n        )\n      result = manager.perform\n      reviewable = result.reviewable\n      reviewable.perform(admin, :approve_post)\n\n      topic_view = TopicView.new(reviewable.topic, admin)\n\n      expect(topic_view.reviewable_counts.keys).to contain_exactly(reviewable.target_id)\n    end\n  end\n\n  describe \".apply_custom_default_scope\" do\n    fab!(:post) { Fabricate(:post, topic: topic, created_at: 2.hours.ago) }\n    fab!(:post_2) { Fabricate(:post, topic: topic, created_at: 1.hour.ago) }\n\n    after { TopicView.reset_custom_default_scopes }\n\n    it \"allows a custom default scope to be configured\" do\n      topic_view = TopicView.new(topic, admin)\n\n      expect(topic_view.filtered_post_ids).to eq([post.id, post_2.id])\n\n      TopicView.apply_custom_default_scope do |scope, _|\n        scope.unscope(:order).order(\"posts.created_at DESC\")\n      end\n\n      topic_view = TopicView.new(topic, admin)\n\n      expect(topic_view.filtered_post_ids).to eq([post_2.id, post.id])\n    end\n  end\n\n  describe \"#queued_posts_enabled?\" do\n    subject(:topic_view) { described_class.new(topic, user) }\n\n    let(:topic) { Fabricate(:topic) }\n    let(:user) { Fabricate(:user) }\n    let(:category) { topic.category }\n\n    before { NewPostManager.stubs(:queue_enabled?).returns(queue_enabled) }\n\n    context \"when queue is enabled globally\" do\n      let(:queue_enabled) { true }\n\n      it { expect(topic_view.queued_posts_enabled?).to be(true) }\n    end\n\n    context \"when queue is not enabled globally\" do\n      let(:queue_enabled) { false }\n\n      context \"when category is moderated\" do\n        before { category.custom_fields[Category::REQUIRE_REPLY_APPROVAL] = true }\n\n        it { expect(topic_view.queued_posts_enabled?).to be(true) }\n      end\n\n      context \"when category is not moderated\" do\n        it { expect(topic_view.queued_posts_enabled?).to be(nil) }\n      end\n    end\n  end\nend\n", "# coding: utf-8\n# frozen_string_literal: true\n\nRSpec.describe TopicsController do\n  fab!(:topic) { Fabricate(:topic) }\n  fab!(:dest_topic) { Fabricate(:topic) }\n  fab!(:invisible_topic) { Fabricate(:topic, visible: false) }\n\n  fab!(:pm) { Fabricate(:private_message_topic) }\n\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:post_author1) { Fabricate(:user) }\n  fab!(:post_author2) { Fabricate(:user) }\n  fab!(:post_author3) { Fabricate(:user) }\n  fab!(:post_author4) { Fabricate(:user) }\n  fab!(:post_author5) { Fabricate(:user) }\n  fab!(:post_author6) { Fabricate(:user) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:trust_level_0) { Fabricate(:trust_level_0) }\n  fab!(:trust_level_1) { Fabricate(:trust_level_1) }\n  fab!(:trust_level_4) { Fabricate(:trust_level_4) }\n\n  fab!(:category) { Fabricate(:category) }\n  fab!(:tracked_category) { Fabricate(:category) }\n  fab!(:shared_drafts_category) { Fabricate(:category) }\n  fab!(:staff_category) do\n    Fabricate(:category).tap do |staff_category|\n      staff_category.set_permissions(staff: :full)\n      staff_category.save!\n    end\n  end\n\n  fab!(:group_user) { Fabricate(:group_user) }\n\n  fab!(:tag) { Fabricate(:tag) }\n\n  before do\n    [\n      user,\n      user_2,\n      post_author1,\n      post_author2,\n      post_author3,\n      post_author4,\n      post_author5,\n      post_author6,\n      trust_level_0,\n      trust_level_1,\n      trust_level_4,\n    ].each { |u| Group.user_trust_level_change!(u.id, u.trust_level) }\n  end\n\n  describe \"#wordpress\" do\n    before { sign_in(moderator) }\n\n    fab!(:p1) { Fabricate(:post, user: moderator) }\n    fab!(:p2) { Fabricate(:post, topic: p1.topic, user: moderator) }\n\n    it \"returns the JSON in the format our wordpress plugin needs\" do\n      SiteSetting.external_system_avatars_enabled = false\n\n      get \"/t/#{p1.topic.id}/wordpress.json\", params: { best: 3 }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      # The JSON has the data the wordpress plugin needs\n      expect(json[\"id\"]).to eq(p1.topic.id)\n      expect(json[\"posts_count\"]).to eq(2)\n      expect(json[\"filtered_posts_count\"]).to eq(2)\n\n      # Posts\n      expect(json[\"posts\"].size).to eq(1)\n      post = json[\"posts\"][0]\n      expect(post[\"id\"]).to eq(p2.id)\n      expect(post[\"username\"]).to eq(moderator.username)\n      expect(post[\"avatar_template\"]).to eq(\n        \"#{Discourse.base_url_no_prefix}#{moderator.avatar_template}\",\n      )\n      expect(post[\"name\"]).to eq(moderator.name)\n      expect(post[\"created_at\"]).to be_present\n      expect(post[\"cooked\"]).to eq(p2.cooked)\n\n      # Participants\n      expect(json[\"participants\"].size).to eq(1)\n      participant = json[\"participants\"][0]\n      expect(participant[\"id\"]).to eq(moderator.id)\n      expect(participant[\"username\"]).to eq(moderator.username)\n      expect(participant[\"avatar_template\"]).to eq(\n        \"#{Discourse.base_url_no_prefix}#{moderator.avatar_template}\",\n      )\n    end\n  end\n\n  describe \"#move_posts\" do\n    before do\n      SiteSetting.min_topic_title_length = 2\n      SiteSetting.tagging_enabled = true\n    end\n\n    it \"needs you to be logged in\" do\n      post \"/t/111/move-posts.json\", params: { title: \"blah\", post_ids: [1, 2, 3] }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"moving to a new topic\" do\n      fab!(:p1) { Fabricate(:post, user: user, post_number: 1) }\n      let(:p2) { Fabricate(:post, user: user, post_number: 2, topic: p1.topic) }\n      let(:topic) { p1.topic }\n\n      it \"raises an error without post_ids\" do\n        sign_in(moderator)\n        post \"/t/#{topic.id}/move-posts.json\", params: { title: \"blah\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to move the posts\" do\n        sign_in(user)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when the OP is not a regular post\" do\n        sign_in(moderator)\n        p2 =\n          Fabricate(\n            :post,\n            user: post_author1,\n            topic: topic,\n            post_number: 2,\n            post_type: Post.types[:whisper],\n          )\n        p3 = Fabricate(:post, user: post_author2, topic: topic, post_number: 3)\n\n        post \"/t/#{topic.id}/move-posts.json\", params: { title: \"blah\", post_ids: [p2.id, p3.id] }\n        expect(response.status).to eq(422)\n\n        result = response.parsed_body\n\n        expect(result[\"errors\"]).to be_present\n      end\n\n      context \"with success\" do\n        before { sign_in(admin) }\n\n        it \"returns success\" do\n          expect do\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   title: \"Logan is a good movie\",\n                   post_ids: [p2.id],\n                   category_id: category.id,\n                   tags: %w[foo bar],\n                 }\n          end.to change { Topic.count }.by(1).and change { Tag.count }.by(2)\n\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n\n          expect(result[\"success\"]).to eq(true)\n\n          new_topic = Topic.last\n          expect(result[\"url\"]).to eq(new_topic.relative_url)\n          expect(new_topic.excerpt).to eq(p2.excerpt_for_topic)\n          expect(Tag.all.pluck(:name)).to include(\"foo\", \"bar\")\n        end\n\n        describe \"when topic has been deleted\" do\n          it \"should still be able to move posts\" do\n            PostDestroyer.new(admin, topic.first_post).destroy\n\n            expect(topic.reload.deleted_at).to_not be_nil\n\n            expect do\n              post \"/t/#{topic.id}/move-posts.json\",\n                   params: {\n                     title: \"Logan is a good movie\",\n                     post_ids: [p2.id],\n                     category_id: category.id,\n                   }\n            end.to change { Topic.count }.by(1)\n\n            expect(response.status).to eq(200)\n\n            result = response.parsed_body\n\n            expect(result[\"success\"]).to eq(true)\n            expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          sign_in(moderator)\n          post \"/t/#{topic.id}/move-posts.json\", params: { post_ids: [p2.id] }\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n\n      describe \"moving replied posts\" do\n        context \"with success\" do\n          it \"moves the child posts too\" do\n            sign_in(moderator)\n            p1 = Fabricate(:post, topic: topic, user: moderator)\n            p2 =\n              Fabricate(:post, topic: topic, user: moderator, reply_to_post_number: p1.post_number)\n            PostReply.create(post_id: p1.id, reply_post_id: p2.id)\n\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   title: \"new topic title\",\n                   post_ids: [p1.id],\n                   reply_post_ids: [p1.id],\n                 }\n            expect(response.status).to eq(200)\n\n            p1.reload\n            p2.reload\n\n            new_topic_id = response.parsed_body[\"url\"].split(\"/\").last.to_i\n            new_topic = Topic.find(new_topic_id)\n            expect(p1.topic.id).to eq(new_topic.id)\n            expect(p2.topic.id).to eq(new_topic.id)\n            expect(p2.reply_to_post_number).to eq(p1.post_number)\n          end\n        end\n      end\n    end\n\n    describe \"moving to a new topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: group_user.user, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: group_user.user, post_number: 2, topic: topic) }\n      let!(:user) { group_user.user }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        expect do\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 title: \"Logan is a good movie\",\n                 post_ids: [p2.id],\n                 category_id: category.id,\n               }\n        end.to change { Topic.count }.by(1)\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to eq(Topic.last.relative_url)\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"Logan is a good movie\",\n               post_ids: [p2.id],\n               category_id: staff_category.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n             }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"moving to an existing topic\" do\n      before { sign_in(moderator) }\n\n      fab!(:p1) { Fabricate(:post, user: moderator) }\n      fab!(:topic) { p1.topic }\n      fab!(:p2) { Fabricate(:post, user: moderator, topic: topic) }\n\n      context \"with success\" do\n        it \"returns success\" do\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 destination_topic_id: dest_topic.id,\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n\n        it \"triggers an event on merge\" do\n          begin\n            called = false\n\n            assert = ->(original_topic, destination_topic) {\n              called = true\n              expect(original_topic).to eq(topic)\n              expect(destination_topic).to eq(dest_topic)\n            }\n\n            DiscourseEvent.on(:topic_merged, &assert)\n\n            post \"/t/#{topic.id}/move-posts.json\",\n                 params: {\n                   post_ids: [p2.id],\n                   destination_topic_id: dest_topic.id,\n                 }\n\n            expect(called).to eq(true)\n            expect(response.status).to eq(200)\n          ensure\n            DiscourseEvent.off(:topic_merged, &assert)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        fab!(:p2) { Fabricate(:post, user: moderator) }\n        it \"returns JSON with a false success\" do\n          post \"/t/#{topic.id}/move-posts.json\", params: { post_ids: [p2.id] }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n\n        it \"returns plugin validation error\" do\n          # stub here is to simulate validation added by plugin which would be triggered when post is moved\n          PostCreator.any_instance.stubs(:skip_validations?).returns(false)\n\n          p1.update_columns(raw: \"i\", cooked: \"\")\n          post \"/t/#{topic.id}/move-posts.json\",\n               params: {\n                 post_ids: [p1.id],\n                 destination_topic_id: dest_topic.id,\n               }\n\n          expect(response.status).to eq(422)\n          result = response.parsed_body\n          expect(result[\"errors\"]).to eq(\n            [\n              \"Body is too short (minimum is 5 characters) and Body seems unclear, is it a complete sentence?\",\n            ],\n          )\n        end\n      end\n    end\n\n    describe \"moving to an existing topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: group_user.user, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: group_user.user, post_number: 2, topic: topic) }\n\n      let!(:user) { group_user.user }\n\n      before do\n        sign_in(user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p2.id],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to be_present\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        dest_topic.update!(category: staff_category)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p2.id],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/move-posts.json\",\n             params: {\n               post_ids: [p1.post_number, p2.post_number],\n               destination_topic_id: dest_topic.id,\n             }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"moving to a new message\" do\n      fab!(:message) { pm }\n      fab!(:p1) { Fabricate(:post, user: user, post_number: 1, topic: message) }\n      fab!(:p2) { Fabricate(:post, user: user, post_number: 2, topic: message) }\n\n      it \"raises an error without post_ids\" do\n        sign_in(moderator)\n        post \"/t/#{message.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               archetype: \"private_message\",\n             }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to move the posts\" do\n        sign_in(trust_level_4)\n\n        post \"/t/#{message.id}/move-posts.json\",\n             params: {\n               title: \"blah\",\n               post_ids: [p1.post_number, p2.post_number],\n               archetype: \"private_message\",\n             }\n\n        expect(response.status).to eq(403)\n        result = response.parsed_body\n        expect(result[\"errors\"]).to be_present\n      end\n\n      context \"with success\" do\n        before { sign_in(admin) }\n\n        it \"returns success\" do\n          SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n\n          expect do\n            post \"/t/#{message.id}/move-posts.json\",\n                 params: {\n                   title: \"Logan is a good movie\",\n                   post_ids: [p2.id],\n                   archetype: \"private_message\",\n                   tags: %w[foo bar],\n                 }\n          end.to change { Topic.count }.by(1).and change { Tag.count }.by(2)\n\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          expect(Tag.all.pluck(:name)).to include(\"foo\", \"bar\")\n        end\n\n        describe \"when message has been deleted\" do\n          it \"should still be able to move posts\" do\n            PostDestroyer.new(admin, message.first_post).destroy\n\n            expect(message.reload.deleted_at).to_not be_nil\n\n            expect do\n              post \"/t/#{message.id}/move-posts.json\",\n                   params: {\n                     title: \"Logan is a good movie\",\n                     post_ids: [p2.id],\n                     archetype: \"private_message\",\n                   }\n            end.to change { Topic.count }.by(1)\n\n            expect(response.status).to eq(200)\n\n            result = response.parsed_body\n\n            expect(result[\"success\"]).to eq(true)\n            expect(result[\"url\"]).to eq(Topic.last.relative_url)\n          end\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          sign_in(moderator)\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 archetype: \"private_message\",\n               }\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n    end\n\n    describe \"moving to an existing message\" do\n      before { sign_in(admin) }\n\n      fab!(:evil_trout) { Fabricate(:evil_trout) }\n      fab!(:message) { pm }\n      fab!(:p2) { Fabricate(:post, user: evil_trout, post_number: 2, topic: message) }\n\n      fab!(:dest_message) do\n        Fabricate(\n          :private_message_topic,\n          user: trust_level_4,\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: evil_trout)],\n        )\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 destination_topic_id: dest_message.id,\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n\n      context \"with failure\" do\n        it \"returns JSON with a false success\" do\n          post \"/t/#{message.id}/move-posts.json\",\n               params: {\n                 post_ids: [p2.id],\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(false)\n          expect(result[\"url\"]).to be_blank\n        end\n      end\n    end\n  end\n\n  describe \"#merge_topic\" do\n    it \"needs you to be logged in\" do\n      post \"/t/111/merge-topic.json\", params: { destination_topic_id: 345 }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"merging into another topic\" do\n      fab!(:p1) { Fabricate(:post, user: user) }\n      fab!(:topic) { p1.topic }\n\n      it \"raises an error without destination_topic_id\" do\n        sign_in(moderator)\n        post \"/t/#{topic.id}/merge-topic.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to merge\" do\n        sign_in(user)\n        post \"/t/111/merge-topic.json\", params: { destination_topic_id: 345 }\n        expect(response).to be_forbidden\n      end\n\n      context \"when moving all the posts to the destination topic\" do\n        it \"returns success\" do\n          sign_in(moderator)\n          post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n\n    describe \"merging into another topic as a group moderator\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n      fab!(:p1) { Fabricate(:post, user: post_author1, post_number: 1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: post_author2, post_number: 2, topic: topic) }\n\n      before do\n        sign_in(group_user.user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"moves the posts\" do\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n        expect(result[\"url\"]).to be_present\n      end\n\n      it \"does not allow posts to be moved to a private category\" do\n        dest_topic.update!(category: staff_category)\n\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"does not allow posts outside of the category to be moved\" do\n        topic.update!(category: nil)\n\n        post \"/t/#{topic.id}/merge-topic.json\", params: { destination_topic_id: dest_topic.id }\n\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"merging into another message\" do\n      fab!(:message) { Fabricate(:private_message_topic, user: user) }\n      fab!(:p1) { Fabricate(:post, topic: message, user: trust_level_4) }\n      fab!(:p2) do\n        Fabricate(:post, topic: message, reply_to_post_number: p1.post_number, user: user)\n      end\n\n      fab!(:dest_message) do\n        Fabricate(\n          :private_message_topic,\n          user: trust_level_4,\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: moderator)],\n        )\n      end\n\n      it \"raises an error without destination_topic_id\" do\n        sign_in(moderator)\n        post \"/t/#{message.id}/merge-topic.json\", params: { archetype: \"private_message\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error when the user doesn't have permission to merge\" do\n        sign_in(trust_level_4)\n        post \"/t/#{message.id}/merge-topic.json\",\n             params: {\n               destination_topic_id: 345,\n               archetype: \"private_message\",\n             }\n        expect(response).to be_forbidden\n      end\n\n      context \"when moving all the posts to the destination message\" do\n        it \"returns success\" do\n          sign_in(moderator)\n          post \"/t/#{message.id}/merge-topic.json\",\n               params: {\n                 destination_topic_id: dest_message.id,\n                 archetype: \"private_message\",\n               }\n\n          expect(response.status).to eq(200)\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#change_post_owners\" do\n    it \"needs you to be logged in\" do\n      post \"/t/111/change-owner.json\", params: { username: \"user_a\", post_ids: [1, 2, 3] }\n      expect(response).to be_forbidden\n    end\n\n    describe \"forbidden to trust_level_4s\" do\n      before { sign_in(trust_level_4) }\n\n      it \"correctly denies\" do\n        post \"/t/111/change-owner.json\",\n             params: {\n               topic_id: 111,\n               username: \"user_a\",\n               post_ids: [1, 2, 3],\n             }\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"changing ownership\" do\n      fab!(:user_a) { Fabricate(:user) }\n      fab!(:p1) { Fabricate(:post, user: post_author1, topic: topic) }\n      fab!(:p2) { Fabricate(:post, user: post_author2, topic: topic) }\n\n      describe \"moderator signed in\" do\n        let!(:editor) { sign_in(moderator) }\n\n        it \"returns 200 when moderators_change_post_ownership is true\" do\n          SiteSetting.moderators_change_post_ownership = true\n\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          expect(response.status).to eq(200)\n        end\n\n        it \"returns 403 when moderators_change_post_ownership is false\" do\n          SiteSetting.moderators_change_post_ownership = false\n\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          expect(response.status).to eq(403)\n        end\n      end\n      describe \"admin signed in\" do\n        let!(:editor) { sign_in(admin) }\n\n        it \"raises an error with a parameter missing\" do\n          [{ post_ids: [1, 2, 3] }, { username: \"user_a\" }].each do |params|\n            post \"/t/111/change-owner.json\", params: params\n            expect(response.status).to eq(400)\n          end\n        end\n\n        it \"changes the topic and posts ownership\" do\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          topic.reload\n          p1.reload\n          expect(response.status).to eq(200)\n          expect(topic.user.username).to eq(user_a.username)\n          expect(p1.user.username).to eq(user_a.username)\n        end\n\n        it \"changes multiple posts\" do\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id, p2.id],\n               }\n\n          expect(response.status).to eq(200)\n\n          p1.reload\n          p2.reload\n\n          expect(p1.user).to_not eq(nil)\n          expect(p1.reload.user).to eq(p2.reload.user)\n        end\n\n        it \"works with deleted users\" do\n          deleted_user = user\n          t2 = Fabricate(:topic, user: deleted_user)\n          p3 = Fabricate(:post, topic: t2, user: deleted_user)\n\n          UserDestroyer.new(editor).destroy(\n            deleted_user,\n            delete_posts: true,\n            context: \"test\",\n            delete_as_spammer: true,\n          )\n\n          post \"/t/#{t2.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p3.id],\n               }\n\n          expect(response.status).to eq(200)\n          t2.reload\n          p3.reload\n          expect(t2.deleted_at).to be_nil\n          expect(p3.user).to eq(user_a)\n        end\n\n        it \"removes likes by new owner\" do\n          now = Time.zone.now\n          freeze_time(now - 1.day)\n          PostActionCreator.like(user_a, p1)\n          p1.reload\n          freeze_time(now)\n          post \"/t/#{topic.id}/change-owner.json\",\n               params: {\n                 username: user_a.username_lower,\n                 post_ids: [p1.id],\n               }\n          topic.reload\n          p1.reload\n          expect(response.status).to eq(200)\n          expect(topic.user.username).to eq(user_a.username)\n          expect(p1.user.username).to eq(user_a.username)\n          expect(p1.like_count).to eq(0)\n        end\n      end\n    end\n  end\n\n  describe \"#change_timestamps\" do\n    let!(:params) { { timestamp: Time.zone.now } }\n\n    it \"needs you to be logged in\" do\n      put \"/t/1/change-timestamp.json\", params: params\n      expect(response.status).to eq(403)\n    end\n\n    describe \"forbidden to trust_level_4\" do\n      before { sign_in(trust_level_4) }\n\n      it \"correctly denies\" do\n        put \"/t/1/change-timestamp.json\", params: params\n        expect(response).to be_forbidden\n      end\n    end\n\n    describe \"changing timestamps\" do\n      before do\n        freeze_time\n        sign_in(moderator)\n      end\n\n      let!(:old_timestamp) { Time.zone.now }\n      let!(:new_timestamp) { old_timestamp - 1.day }\n      let!(:topic) { Fabricate(:topic, created_at: old_timestamp) }\n      let!(:p1) { Fabricate(:post, user: post_author1, topic: topic, created_at: old_timestamp) }\n      let!(:p2) do\n        Fabricate(:post, user: post_author2, topic: topic, created_at: old_timestamp + 1.day)\n      end\n\n      it \"should update the timestamps of selected posts\" do\n        # try to see if we fail with invalid first\n        put \"/t/1/change-timestamp.json\"\n        expect(response.status).to eq(400)\n\n        put \"/t/#{topic.id}/change-timestamp.json\", params: { timestamp: new_timestamp.to_f }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.created_at).to eq_time(new_timestamp)\n        expect(p1.reload.created_at).to eq_time(new_timestamp)\n        expect(p2.reload.created_at).to eq_time(old_timestamp)\n      end\n\n      it \"should create a staff log entry\" do\n        put \"/t/#{topic.id}/change-timestamp.json\", params: { timestamp: new_timestamp.to_f }\n\n        log = UserHistory.last\n        expect(log.acting_user_id).to eq(moderator.id)\n        expect(log.topic_id).to eq(topic.id)\n        expect(log.new_value).to eq(new_timestamp.utc.to_s)\n        expect(log.previous_value).to eq(old_timestamp.utc.to_s)\n      end\n    end\n  end\n\n  describe \"#clear_pin\" do\n    it \"needs you to be logged in\" do\n      put \"/t/1/clear-pin.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      it \"fails when the user can't see the topic\" do\n        put \"/t/#{pm.id}/clear-pin.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"when the user can see the topic\" do\n        it \"succeeds\" do\n          expect do put \"/t/#{topic.id}/clear-pin.json\" end.to change {\n            TopicUser.where(topic_id: topic.id, user_id: user.id).count\n          }.by(1)\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe \"#status\" do\n    it \"needs you to be logged in\" do\n      put \"/t/1/status.json\", params: { status: \"visible\", enabled: true }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in as a moderator\" do\n      before { sign_in(moderator) }\n\n      it \"raises an exception if you can't change it\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"true\" }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the status parameter\" do\n        put \"/t/#{topic.id}/status.json\", params: { enabled: true }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires the enabled parameter\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"raises an error with a status not in the allowlist\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"title\", enabled: \"true\" }\n        expect(response.status).to eq(400)\n      end\n\n      it \"should update the status of the topic correctly\" do\n        closed_user_topic = Fabricate(:topic, user: user, closed: true)\n        Fabricate(:topic_timer, topic: closed_user_topic, status_type: TopicTimer.types[:open])\n\n        put \"/t/#{closed_user_topic.id}/status.json\", params: { status: \"closed\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(closed_user_topic.reload.closed).to eq(false)\n        expect(closed_user_topic.topic_timers).to eq([])\n\n        body = response.parsed_body\n\n        expect(body[\"topic_status_update\"]).to eq(nil)\n      end\n    end\n\n    describe \"when logged in as a group member with reviewable status\" do\n      fab!(:category) { Fabricate(:category, reviewable_by_group: group_user.group) }\n      fab!(:topic) { Fabricate(:topic, category: category) }\n\n      before do\n        sign_in(group_user.user)\n        SiteSetting.enable_category_group_moderation = true\n      end\n\n      it \"should allow a group moderator to close a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"closed\", enabled: \"true\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.closed).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"closed.enabled\")\n      end\n\n      it \"should allow a group moderator to open a closed topic\" do\n        topic.update!(closed: true)\n\n        expect do\n          put \"/t/#{topic.id}/status.json\", params: { status: \"closed\", enabled: \"false\" }\n        end.to change { topic.reload.posts.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.closed).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"closed.disabled\")\n      end\n\n      it \"should allow a group moderator to archive a topic\" do\n        expect do\n          put \"/t/#{topic.id}/status.json\", params: { status: \"archived\", enabled: \"true\" }\n        end.to change { topic.reload.posts.count }.by(1)\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.archived).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"archived.enabled\")\n      end\n\n      it \"should allow a group moderator to unarchive an archived topic\" do\n        topic.update!(archived: true)\n\n        put \"/t/#{topic.id}/status.json\", params: { status: \"archived\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.archived).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"archived.disabled\")\n      end\n\n      it \"should allow a group moderator to pin a topic\" do\n        put \"/t/#{topic.id}/status.json\",\n            params: {\n              status: \"pinned\",\n              enabled: \"true\",\n              until: 2.weeks.from_now,\n            }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.pinned_at).to_not eq(nil)\n      end\n\n      it \"should allow a group moderator to unpin a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"pinned\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.pinned_at).to eq(nil)\n      end\n\n      it \"should allow a group moderator to unlist a topic\" do\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"false\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.visible).to eq(false)\n        expect(topic.posts.last.action_code).to eq(\"visible.disabled\")\n      end\n\n      it \"should allow a group moderator to list an unlisted topic\" do\n        topic.update!(visible: false)\n\n        put \"/t/#{topic.id}/status.json\", params: { status: \"visible\", enabled: \"true\" }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.visible).to eq(true)\n        expect(topic.posts.last.action_code).to eq(\"visible.enabled\")\n      end\n    end\n\n    context \"with API key\" do\n      let(:api_key) { Fabricate(:api_key, user: moderator, created_by: moderator) }\n\n      context \"when key scope has restricted params\" do\n        before do\n          ApiKeyScope.create(\n            resource: \"topics\",\n            action: \"update\",\n            api_key_id: api_key.id,\n            allowed_parameters: {\n              \"category_id\" => [\"#{topic.category_id}\"],\n            },\n          )\n        end\n\n        it \"fails to update topic status in an unpermitted category\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n                category_id: tracked_category.id,\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(403)\n          expect(response.body).to include(I18n.t(\"invalid_access\"))\n          expect(topic.reload.closed).to eq(false)\n        end\n\n        it \"fails without a category_id\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(403)\n          expect(response.body).to include(I18n.t(\"invalid_access\"))\n          expect(topic.reload.closed).to eq(false)\n        end\n\n        it \"updates topic status in a permitted category\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n                category_id: topic.category_id,\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.closed).to eq(true)\n        end\n      end\n\n      context \"when key scope has no param restrictions\" do\n        before do\n          ApiKeyScope.create(\n            resource: \"topics\",\n            action: \"update\",\n            api_key_id: api_key.id,\n            allowed_parameters: {\n            },\n          )\n        end\n\n        it \"updates topic status\" do\n          put \"/t/#{topic.id}/status.json\",\n              params: {\n                status: \"closed\",\n                enabled: \"true\",\n              },\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.closed).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"#destroy_timings\" do\n    it \"needs you to be logged in\" do\n      delete \"/t/1/timings.json\"\n      expect(response.status).to eq(403)\n    end\n\n    def topic_user_post_timings_count(user, topic)\n      [TopicUser, PostTiming].map { |klass| klass.where(user: user, topic: topic).count }\n    end\n\n    context \"for last post only\" do\n      it \"should allow you to retain topic timing but remove last post only\" do\n        freeze_time\n\n        post1 = create_post\n        user = post1.user\n\n        topic = post1.topic\n\n        post2 = create_post(topic_id: topic.id)\n\n        PostTiming.create!(topic: topic, user: user, post_number: 2, msecs: 100)\n\n        user.user_stat.update!(first_unread_at: Time.now + 1.week)\n\n        topic_user = TopicUser.find_by(topic_id: topic.id, user_id: user.id)\n\n        topic_user.update!(last_read_post_number: 2)\n\n        # ensure we have 2 notifications\n        # fake notification on topic but it is read\n        first_notification =\n          Notification.create!(\n            user_id: user.id,\n            topic_id: topic.id,\n            data: \"{}\",\n            read: true,\n            notification_type: 1,\n          )\n\n        freeze_time 1.minute.from_now\n        PostAlerter.post_created(post2)\n\n        second_notification =\n          user.notifications.where(topic_id: topic.id).order(created_at: :desc).first\n        second_notification.update!(read: true)\n\n        sign_in(user)\n\n        delete \"/t/#{topic.id}/timings.json?last=1\"\n\n        expect(PostTiming.where(topic: topic, user: user, post_number: 2).exists?).to eq(false)\n        expect(PostTiming.where(topic: topic, user: user, post_number: 1).exists?).to eq(true)\n\n        expect(TopicUser.where(topic: topic, user: user, last_read_post_number: 1).exists?).to eq(\n          true,\n        )\n\n        user.user_stat.reload\n        expect(user.user_stat.first_unread_at).to eq_time(topic.updated_at)\n\n        first_notification.reload\n        second_notification.reload\n        expect(first_notification.read).to eq(true)\n        expect(second_notification.read).to eq(false)\n\n        PostDestroyer.new(admin, post2).destroy\n\n        delete \"/t/#{topic.id}/timings.json?last=1\"\n\n        expect(PostTiming.where(topic: topic, user: user, post_number: 1).exists?).to eq(false)\n        expect(TopicUser.where(topic: topic, user: user, last_read_post_number: nil).exists?).to eq(\n          true,\n        )\n      end\n    end\n\n    context \"when logged in\" do\n      fab!(:user_topic) { Fabricate(:topic, user: user) }\n      fab!(:user_post) { Fabricate(:post, user: user, topic: user_topic, post_number: 2) }\n\n      before do\n        sign_in(user)\n        TopicUser.create!(topic: user_topic, user: user)\n        PostTiming.create!(topic: user_topic, user: user, post_number: 2, msecs: 1000)\n      end\n\n      it \"deletes the forum topic user and post timings records\" do\n        expect do delete \"/t/#{user_topic.id}/timings.json\" end.to change {\n          topic_user_post_timings_count(user, user_topic)\n        }.from([1, 1]).to([0, 0])\n      end\n    end\n  end\n\n  describe \"#mute/unmute\" do\n    it \"needs you to be logged in\" do\n      put \"/t/99/mute.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"needs you to be logged in\" do\n      put \"/t/99/unmute.json\"\n      expect(response.status).to eq(403)\n    end\n  end\n\n  describe \"#recover\" do\n    it \"won't allow us to recover a topic when we're not logged in\" do\n      put \"/t/1/recover.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      let!(:topic) { Fabricate(:topic, user: user, deleted_at: Time.now, deleted_by: moderator) }\n      let!(:post) do\n        Fabricate(\n          :post,\n          user: user,\n          topic: topic,\n          post_number: 1,\n          deleted_at: Time.now,\n          deleted_by: moderator,\n        )\n      end\n\n      describe \"without access\" do\n        it \"raises an exception when the user doesn't have permission to delete the topic\" do\n          sign_in(user)\n          put \"/t/#{topic.id}/recover.json\"\n          expect(response).to be_forbidden\n        end\n      end\n\n      context \"with permission\" do\n        before { sign_in(moderator) }\n\n        it \"succeeds\" do\n          put \"/t/#{topic.id}/recover.json\"\n          topic.reload\n          post.reload\n          expect(response.status).to eq(200)\n          expect(topic.trashed?).to be_falsey\n          expect(post.trashed?).to be_falsey\n        end\n      end\n    end\n  end\n\n  describe \"#delete\" do\n    it \"won't allow us to delete a topic when we're not logged in\" do\n      delete \"/t/1.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      fab!(:topic) { Fabricate(:topic, user: user, created_at: 48.hours.ago) }\n      fab!(:post) { Fabricate(:post, topic: topic, user: user, post_number: 1) }\n\n      describe \"without access\" do\n        it \"raises an exception when the user doesn't have permission to delete the topic\" do\n          sign_in(user)\n          delete \"/t/#{topic.id}.json\"\n          expect(response.status).to eq(422)\n        end\n      end\n\n      describe \"with permission\" do\n        before { sign_in(moderator) }\n\n        it \"succeeds\" do\n          delete \"/t/#{topic.id}.json\"\n          expect(response.status).to eq(200)\n          topic.reload\n          expect(topic.trashed?).to be_truthy\n        end\n      end\n    end\n\n    describe \"force destroy\" do\n      fab!(:post) { Fabricate(:post, topic: topic, post_number: 1) }\n\n      before do\n        SiteSetting.can_permanently_delete = true\n\n        sign_in(admin)\n      end\n\n      it \"force destroys all deleted small actions in topic too\" do\n        small_action_post = Fabricate(:small_action, topic: topic)\n        PostDestroyer.new(Discourse.system_user, post).destroy\n        PostDestroyer.new(Discourse.system_user, small_action_post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(200)\n\n        expect(Topic.find_by(id: topic.id)).to eq(nil)\n        expect(Post.find_by(id: post.id)).to eq(nil)\n        expect(Post.find_by(id: small_action_post.id)).to eq(nil)\n      end\n\n      it \"does not allow to destroy topic if not all posts were force destroyed\" do\n        other_post = Fabricate(:post, topic: topic, post_number: 2)\n        PostDestroyer.new(Discourse.system_user, post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"does not allow to destroy topic if not all small action posts were deleted\" do\n        small_action_post = Fabricate(:small_action, topic: topic)\n        PostDestroyer.new(Discourse.system_user, small_action_post).destroy\n\n        delete \"/t/#{topic.id}.json\", params: { force_destroy: true }\n\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe \"#id_for_slug\" do\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    it \"returns JSON for the slug\" do\n      get \"/t/id_for/#{topic.slug}.json\"\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"topic_id\"]).to eq(topic.id)\n      expect(json[\"url\"]).to eq(topic.url)\n      expect(json[\"slug\"]).to eq(topic.slug)\n    end\n\n    it \"returns invalid access if the user can't see the topic\" do\n      get \"/t/id_for/#{pm.slug}.json\"\n      expect(response).to be_forbidden\n    end\n  end\n\n  describe \"#update\" do\n    it \"won't allow us to update a topic when we're not logged in\" do\n      put \"/t/1.json\", params: { slug: \"xyz\" }\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      fab!(:topic) { Fabricate(:topic, user: user) }\n\n      before_all { Fabricate(:post, user: post_author1, topic: topic) }\n\n      before do\n        SiteSetting.editing_grace_period = 0\n        sign_in(user)\n      end\n\n      it \"can not change category to a disallowed category\" do\n        category.set_permissions(staff: :full)\n        category.save!\n\n        put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n        expect(response.status).to eq(403)\n        expect(topic.reload.category_id).not_to eq(category.id)\n      end\n\n      it \"can not move to a category that requires topic approval\" do\n        category.custom_fields[Category::REQUIRE_TOPIC_APPROVAL] = true\n        category.save!\n\n        put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n        expect(response.status).to eq(403)\n        expect(topic.reload.category_id).not_to eq(category.id)\n      end\n\n      context \"when updating shared drafts\" do\n        fab!(:topic) { Fabricate(:topic, category: shared_drafts_category) }\n        fab!(:shared_draft) do\n          Fabricate(:shared_draft, topic: topic, category: Fabricate(:category))\n        end\n\n        it \"changes destination category\" do\n          put \"/t/#{topic.id}.json\", params: { category_id: category.id }\n\n          expect(response.status).to eq(403)\n          expect(topic.shared_draft.category_id).not_to eq(category.id)\n        end\n      end\n\n      describe \"without permission\" do\n        it \"raises an exception when the user doesn't have permission to update the topic\" do\n          topic.update!(archived: true)\n          put \"/t/#{topic.slug}/#{topic.id}.json\"\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe \"with permission\" do\n        fab!(:post_hook) { Fabricate(:post_web_hook) }\n        fab!(:topic_hook) { Fabricate(:topic_web_hook) }\n\n        it \"succeeds\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"basic_topic\"]).to be_present\n        end\n\n        it \"throws an error if it could not be saved\" do\n          PostRevisor.any_instance.stubs(:should_revise?).returns(false)\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: \"brand new title\" }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"].first).to eq(\n            I18n.t(\"activerecord.errors.models.topic.attributes.base.unable_to_update\"),\n          )\n        end\n\n        it \"can update a topic to an uncategorized topic\" do\n          topic.update!(category: category)\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: \"\" }\n\n          expect(response.status).to eq(200)\n          expect(topic.reload.category_id).to eq(SiteSetting.uncategorized_category_id)\n        end\n\n        it \"allows a change of title\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n\n          # emits a topic_edited event but not a post_edited web hook event\n          expect(Jobs::EmitWebHookEvent.jobs.length).to eq(1)\n          job_args = Jobs::EmitWebHookEvent.jobs[0][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"topic_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"title\"]).to eq(\"This is a new title for the topic\")\n        end\n\n        it \"allows update on short non-slug url\" do\n          put \"/t/#{topic.id}.json\", params: { title: \"This is a new title for the topic\" }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n        end\n\n        it \"only allows update on digit ids\" do\n          non_digit_id = \"asdf\"\n          original_title = topic.title\n          put \"/t/#{non_digit_id}.json\", params: { title: \"This is a new title for the topic\" }\n\n          topic.reload\n          expect(topic.title).to eq(original_title)\n          expect(response.status).to eq(404)\n        end\n\n        it \"allows a change of then updating the OP\" do\n          topic.update(user: user)\n          topic.first_post.update(user: user)\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          topic.reload\n          expect(topic.title).to eq(\"This is a new title for the topic\")\n\n          update_params = { post: { raw: \"edited body\", edit_reason: \"typo\" } }\n          put \"/posts/#{topic.first_post.id}.json\", params: update_params\n\n          # emits a topic_edited event and a post_edited web hook event\n          expect(Jobs::EmitWebHookEvent.jobs.length).to eq(2)\n          job_args = Jobs::EmitWebHookEvent.jobs[0][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"topic_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"title\"]).to eq(\"This is a new title for the topic\")\n\n          job_args = Jobs::EmitWebHookEvent.jobs[1][\"args\"].first\n\n          expect(job_args[\"event_name\"]).to eq(\"post_edited\")\n          payload = JSON.parse(job_args[\"payload\"])\n          expect(payload[\"raw\"]).to eq(\"edited body\")\n        end\n\n        it \"returns errors with invalid titles\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: \"asdf\" }\n\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to match_array(\n            [/Title is too short/, /Title seems unclear/],\n          )\n        end\n\n        it \"returns errors when the rate limit is exceeded\" do\n          EditRateLimiter\n            .any_instance\n            .expects(:performed!)\n            .raises(RateLimiter::LimitExceeded.new(60))\n\n          put \"/t/#{topic.slug}/#{topic.id}.json\",\n              params: {\n                title: \"This is a new title for the topic\",\n              }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"returns errors with invalid categories\" do\n          put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: -1 }\n\n          expect(response.status).to eq(422)\n        end\n\n        it \"doesn't call the PostRevisor when there is no changes\" do\n          expect do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: topic.category_id }\n          end.not_to change(PostRevision.all, :count)\n\n          expect(response.status).to eq(200)\n        end\n\n        context \"when using SiteSetting.disable_category_edit_notifications\" do\n          it \"doesn't bump the topic if the setting is enabled\" do\n            SiteSetting.disable_category_edit_notifications = true\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n            end.to change { topic.reload.category_id }.to(category.id)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).to eq_time(last_bumped_at)\n          end\n\n          it \"bumps the topic if the setting is disabled\" do\n            SiteSetting.disable_category_edit_notifications = false\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n            end.to change { topic.reload.category_id }.to(category.id)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).not_to eq_time(last_bumped_at)\n          end\n        end\n\n        context \"when using SiteSetting.disable_tags_edit_notifications\" do\n          fab!(:t1) { Fabricate(:tag) }\n          fab!(:t2) { Fabricate(:tag) }\n          let(:tags) { [t1, t2] }\n\n          it \"doesn't bump the topic if the setting is enabled\" do\n            SiteSetting.disable_tags_edit_notifications = true\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: tags.map(&:name) }\n\n            expect(topic.reload.tags).to match_array(tags)\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).to eq_time(last_bumped_at)\n          end\n\n          it \"bumps the topic if the setting is disabled\" do\n            SiteSetting.disable_tags_edit_notifications = false\n            last_bumped_at = topic.bumped_at\n            expect(last_bumped_at).not_to be_nil\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: tags.map(&:name) }\n\n            expect(topic.reload.tags).to match_array(tags)\n            expect(response.status).to eq(200)\n            expect(topic.reload.bumped_at).not_to eq_time(last_bumped_at)\n          end\n        end\n\n        describe \"when first post is locked\" do\n          it \"blocks non-staff from editing even if 'trusted_users_can_edit_others' is true\" do\n            SiteSetting.trusted_users_can_edit_others = true\n            user.update!(trust_level: 3)\n            topic.first_post.update!(locked_by_id: admin.id)\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: topic.title + \" hello\" }\n\n            expect(response.status).to eq(403)\n          end\n\n          it \"allows staff to edit\" do\n            sign_in(Fabricate(:admin))\n            topic.first_post.update!(locked_by_id: admin.id)\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { title: topic.title + \" hello\" }\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"with tags\" do\n          before { SiteSetting.tagging_enabled = true }\n\n          it \"can add a tag to topic\" do\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [tag.name] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags.pluck(:id)).to contain_exactly(tag.id)\n          end\n\n          it \"can create a tag\" do\n            SiteSetting.min_trust_to_create_tag = 0\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [\"newtag\"] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags.pluck(:name)).to contain_exactly(\"newtag\")\n          end\n\n          it \"can change the category and create a new tag\" do\n            SiteSetting.min_trust_to_create_tag = 0\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\",\n                  params: {\n                    tags: [\"newtag\"],\n                    category_id: category.id,\n                  }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags.pluck(:name)).to contain_exactly(\"newtag\")\n          end\n\n          it \"can add a tag to wiki topic\" do\n            SiteSetting.min_trust_to_edit_wiki_post = 2\n            topic.first_post.update!(wiki: true)\n            sign_in(user_2)\n\n            expect do\n              put \"/t/#{topic.id}/tags.json\", params: { tags: [tag.name] }\n            end.not_to change { topic.reload.first_post.revisions.count }\n\n            expect(response.status).to eq(403)\n            user_2.update!(trust_level: 2)\n\n            expect do put \"/t/#{topic.id}/tags.json\", params: { tags: [tag.name] } end.to change {\n              topic.reload.first_post.revisions.count\n            }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags.pluck(:id)).to contain_exactly(tag.id)\n          end\n\n          it \"does not remove tag if no params is given\" do\n            topic.tags << tag\n\n            expect do put \"/t/#{topic.slug}/#{topic.id}.json\" end.to_not change {\n              topic.reload.tags.count\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can remove a tag\" do\n            topic.tags << tag\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [\"\"] }\n            end.to change { topic.reload.first_post.revisions.count }.by(1)\n\n            expect(response.status).to eq(200)\n            expect(topic.tags).to eq([])\n          end\n\n          it \"does not cause a revision when tags have not changed\" do\n            topic.tags << tag\n\n            expect do\n              put \"/t/#{topic.slug}/#{topic.id}.json\", params: { tags: [tag.name] }\n            end.not_to change { topic.reload.first_post.revisions.count }\n\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when topic is private\" do\n          before do\n            topic.update!(\n              archetype: Archetype.private_message,\n              category: nil,\n              allowed_users: [topic.user],\n            )\n          end\n\n          context \"when there are no changes\" do\n            it \"does not call the PostRevisor\" do\n              expect do\n                put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: topic.category_id }\n              end.not_to change(PostRevision.all, :count)\n\n              expect(response.status).to eq(200)\n            end\n          end\n        end\n\n        context \"when updating to a category with restricted tags\" do\n          fab!(:restricted_category) { Fabricate(:category) }\n          fab!(:tag1) { Fabricate(:tag) }\n          fab!(:tag2) { Fabricate(:tag) }\n          fab!(:tag3) { Fabricate(:tag) }\n          fab!(:tag_group_1) { Fabricate(:tag_group, tag_names: [tag1.name]) }\n          fab!(:tag_group_2) { Fabricate(:tag_group) }\n\n          before_all do\n            SiteSetting.tagging_enabled = true\n            topic.update!(tags: [tag1])\n          end\n\n          it \"can\u2019t change to a category disallowing this topic current tags\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            result = response.parsed_body\n\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"can\u2019t change to a category disallowing this topic current tag (through tag_group)\" do\n            tag_group_2.tags = [tag2]\n            restricted_category.allowed_tag_groups = [tag_group_2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            result = response.parsed_body\n\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"can change to a category allowing this topic current tags\" do\n            restricted_category.allowed_tags = [tag1.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can change to a category allowing this topic current tags (through tag_group)\" do\n            tag_group_1.tags = [tag1]\n            restricted_category.allowed_tag_groups = [tag_group_1.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: restricted_category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can change to a category allowing any tag\" do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            expect(response.status).to eq(200)\n          end\n\n          it \"can\u2019t add a category-only tags from another category to a category\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [tag2.name],\n                  category_id: category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(result[\"errors\"][0]).to include(tag2.name)\n            expect(topic.reload.category_id).not_to eq(restricted_category.id)\n          end\n\n          it \"allows category change when topic has a hidden tag\" do\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [tag1.name])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags).to include(tag1)\n          end\n\n          it \"allows category change when topic has a read-only tag\" do\n            Fabricate(\n              :tag_group,\n              permissions: {\n                \"staff\" => 1,\n                \"everyone\" => 3,\n              },\n              tag_names: [tag3.name],\n            )\n            topic.update!(tags: [tag3])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n            expect(topic.reload.tags).to contain_exactly(tag3)\n          end\n\n          it \"does not leak tag name when trying to use a staff tag\" do\n            Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [tag3.name])\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [tag3.name],\n                  category_id: category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(422)\n            expect(result[\"errors\"]).to be_present\n            expect(result[\"errors\"][0]).not_to include(tag3.name)\n          end\n\n          it \"will clean tag params\" do\n            restricted_category.allowed_tags = [tag2.name]\n\n            put \"/t/#{topic.slug}/#{topic.id}.json\",\n                params: {\n                  tags: [\"\"],\n                  category_id: restricted_category.id,\n                }\n\n            result = response.parsed_body\n            expect(response.status).to eq(200)\n          end\n        end\n\n        context \"when allow_uncategorized_topics is false\" do\n          before { SiteSetting.allow_uncategorized_topics = false }\n\n          it \"can add a category to an uncategorized topic\" do\n            put \"/t/#{topic.slug}/#{topic.id}.json\", params: { category_id: category.id }\n\n            expect(response.status).to eq(200)\n            expect(topic.reload.category).to eq(category)\n          end\n        end\n      end\n    end\n\n    describe \"featured links\" do\n      def fabricate_topic(user, category = nil)\n        topic = Fabricate(:topic, user: user, category: category)\n        Fabricate(:post, user: post_author1, topic: topic)\n        topic\n      end\n\n      it \"allows to update topic featured link\" do\n        sign_in(trust_level_1)\n\n        tl1_topic = fabricate_topic(trust_level_1)\n        put \"/t/#{tl1_topic.slug}/#{tl1_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"doesn't allow TL0 users to update topic featured link\" do\n        sign_in(trust_level_0)\n\n        tl0_topic = fabricate_topic(trust_level_0)\n        put \"/t/#{tl0_topic.slug}/#{tl0_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to update topic featured link if featured links are disabled in settings\" do\n        sign_in(trust_level_1)\n\n        SiteSetting.topic_featured_link_enabled = false\n        tl1_topic = fabricate_topic(trust_level_1)\n        put \"/t/#{tl1_topic.slug}/#{tl1_topic.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"doesn't allow to update topic featured link in the category with forbidden feature links\" do\n        sign_in(trust_level_1)\n\n        category = Fabricate(:category, topic_featured_link_allowed: false)\n        tl1_topic_in_category = fabricate_topic(trust_level_1, category)\n        put \"/t/#{tl1_topic_in_category.slug}/#{tl1_topic_in_category.id}.json\",\n            params: {\n              featured_link: \"https://discourse.org\",\n            }\n\n        expect(response.status).to eq(422)\n      end\n    end\n  end\n\n  describe \"#show_by_external_id\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, external_id: \"private\") }\n    fab!(:topic) { Fabricate(:topic, external_id: \"asdf\") }\n\n    it \"returns 301 when found\" do\n      get \"/t/external_id/asdf.json\"\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json\")\n    end\n\n    it \"returns right response when not found\" do\n      get \"/t/external_id/fdsa.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"preserves only select query params\" do\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json?filter_top_level_replies=true\")\n\n      get \"/t/external_id/asdf.json\", params: { not_valid: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(topic.relative_url + \".json\")\n\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true, post_number: 9999 }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        topic.relative_url + \"/9999.json?filter_top_level_replies=true\",\n      )\n\n      get \"/t/external_id/asdf.json\", params: { filter_top_level_replies: true, print: true }\n      expect(response.status).to eq(301)\n      expect(response).to redirect_to(\n        topic.relative_url + \".json?print=true&filter_top_level_replies=true\",\n      )\n    end\n\n    describe \"when user does not have access to the topic\" do\n      it \"should return the right response\" do\n        sign_in(user)\n\n        get \"/t/external_id/private.json\"\n\n        expect(response.status).to eq(403)\n        expect(response.body).to include(I18n.t(\"invalid_access\"))\n      end\n    end\n  end\n\n  describe \"#show\" do\n    use_redis_snapshotting\n\n    fab!(:private_topic) { pm }\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    fab!(:p1) { Fabricate(:post, user: topic.user) }\n    fab!(:p2) { Fabricate(:post, user: topic.user) }\n\n    describe \"when topic is not allowed\" do\n      it \"should return the right response\" do\n        SiteSetting.detailed_404 = true\n        sign_in(user)\n\n        get \"/t/#{private_topic.id}.json\"\n\n        expect(response.status).to eq(403)\n        expect(response.body).to include(I18n.t(\"invalid_access\"))\n      end\n    end\n\n    describe \"when topic is allowed to a group\" do\n      fab!(:group) { Fabricate(:group, public_admission: true) }\n      fab!(:category) do\n        Fabricate(:category_with_definition).tap do |category|\n          category.set_permissions(group => :full)\n          category.save!\n        end\n      end\n      fab!(:topic) { Fabricate(:topic, category: category) }\n\n      before { SiteSetting.detailed_404 = true }\n\n      it \"shows a descriptive error message containing the group name\" do\n        get \"/t/#{topic.id}.json\"\n\n        html = CGI.unescapeHTML(response.parsed_body[\"extras\"][\"html\"])\n        expect(response.status).to eq(403)\n        expect(html).to include(I18n.t(\"not_in_group.title_topic\", group: group.name))\n        expect(html).to include(I18n.t(\"not_in_group.join_group\"))\n      end\n    end\n\n    it \"correctly renders canonicals\" do\n      get \"/t/#{topic.id}\", params: { slug: topic.slug }\n\n      expect(response.status).to eq(200)\n      expect(css_select(\"link[rel=canonical]\").length).to eq(1)\n      expect(response.headers[\"Cache-Control\"]).to eq(\"no-cache, no-store\")\n    end\n\n    it \"returns 301 even if slug does not match URL\" do\n      # in the past we had special logic for unlisted topics\n      # we would require slug unless you made a json call\n      # this was not really providing any security\n      #\n      # we no longer require a topic be visible to perform url correction\n      # if you need to properly hide a topic for users use a secure category\n      # or a PM\n      Fabricate(:post, user: post_author1, topic: invisible_topic)\n\n      get \"/t/#{invisible_topic.id}.json\", params: { slug: invisible_topic.slug }\n      expect(response.status).to eq(200)\n\n      get \"/t/#{topic.id}.json\", params: { slug: \"just-guessing\" }\n      expect(response.status).to eq(301)\n\n      get \"/t/#{topic.slug}.json\"\n      expect(response.status).to eq(301)\n    end\n\n    it \"shows a topic correctly\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"return 404 for an invalid page\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n      expect(response.status).to eq(404)\n    end\n\n    it \"can find a topic given a slug in the id param\" do\n      get \"/t/#{topic.slug}\"\n      expect(response).to redirect_to(topic.relative_url)\n    end\n\n    it \"can find a topic when a slug has a number in front\" do\n      another_topic = Fabricate(:post, user: post_author1).topic\n\n      topic.update_column(:slug, \"#{another_topic.id}-reasons-discourse-is-awesome\")\n      get \"/t/#{another_topic.id}-reasons-discourse-is-awesome\"\n\n      expect(response).to redirect_to(topic.relative_url)\n    end\n\n    it \"keeps the post_number parameter around when redirecting\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42 }\n      expect(response).to redirect_to(topic.relative_url + \"/42\")\n    end\n\n    it \"keeps the page around when redirecting\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42, page: 123 }\n\n      expect(response).to redirect_to(topic.relative_url + \"/42?page=123\")\n    end\n\n    it \"does not accept page params as an array\" do\n      get \"/t/#{topic.slug}\", params: { post_number: 42, page: [2] }\n\n      expect(response).to redirect_to(\"#{topic.relative_url}/42?page=1\")\n    end\n\n    it \"returns 404 when an invalid slug is given and no id\" do\n      get \"/t/nope-nope.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns a 404 when slug and topic id do not match a topic\" do\n      get \"/t/made-up-topic-slug/123456.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns a 404 for an ID that is larger than postgres limits\" do\n      get \"/t/made-up-topic-slug/5014217323220164041.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"doesn't use print mode when print equals false\" do\n      SiteSetting.max_prints_per_hour_per_user = 0\n\n      get \"/t/#{topic.slug}/#{topic.id}.json?print=false\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"does not result in N+1 queries problem when multiple topic participants have primary or flair group configured\" do\n      user2 = Fabricate(:user)\n      user3 = Fabricate(:user)\n      post2 = Fabricate(:post, topic: topic, user: user2)\n      post3 = Fabricate(:post, topic: topic, user: user3)\n      group = Fabricate(:group)\n      user2.update!(primary_group: group)\n      user3.update!(flair_group: group)\n\n      # warm up\n      get \"/t/#{topic.id}.json\"\n      expect(response.status).to eq(200)\n\n      first_request_queries =\n        track_sql_queries do\n          get \"/t/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n\n          expect(\n            response.parsed_body[\"details\"][\"participants\"].map { |u| u[\"id\"] },\n          ).to contain_exactly(post_author1.id, user2.id, user3.id)\n        end\n\n      group2 = Fabricate(:group)\n      user4 = Fabricate(:user, flair_group: group2)\n      user5 = Fabricate(:user, primary_group: group2)\n      post4 = Fabricate(:post, topic: topic, user: user4)\n      post5 = Fabricate(:post, topic: topic, user: user5)\n\n      second_request_queries =\n        track_sql_queries do\n          get \"/t/#{topic.id}.json\"\n\n          expect(response.status).to eq(200)\n\n          expect(\n            response.parsed_body[\"details\"][\"participants\"].map { |u| u[\"id\"] },\n          ).to contain_exactly(post_author1.id, user2.id, user3.id, user4.id, user5.id)\n        end\n\n      expect(second_request_queries.count).to eq(first_request_queries.count)\n    end\n\n    context \"when a topic with nil slug exists\" do\n      before do\n        nil_slug_topic = Fabricate(:topic)\n        Topic.connection.execute(\"update topics set slug=null where id = #{nil_slug_topic.id}\") # can't find a way to set slug column to null using the model\n      end\n\n      it \"returns a 404 when slug and topic id do not match a topic\" do\n        get \"/t/made-up-topic-slug/123123.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with permission errors\" do\n      fab!(:allowed_user) { Fabricate(:user) }\n      fab!(:allowed_group) { Fabricate(:group) }\n      fab!(:accessible_group) { Fabricate(:group, public_admission: true) }\n      fab!(:secure_category) do\n        c = Fabricate(:category)\n        c.permissions = [[allowed_group, :full]]\n        c.save\n        allowed_user.groups = [allowed_group]\n        allowed_user.save\n        c\n      end\n      fab!(:accessible_category) do\n        Fabricate(:category).tap do |c|\n          c.set_permissions(accessible_group => :full)\n          c.save!\n        end\n      end\n      fab!(:normal_topic) { Fabricate(:topic) }\n      fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n      fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n      # Can't use fab!, because deleted_topics can't be re-found\n      before_all do\n        @deleted_topic = Fabricate(:deleted_topic)\n        @deleted_secure_topic = Fabricate(:topic, category: secure_category, deleted_at: 1.day.ago)\n        @deleted_private_topic =\n          Fabricate(:private_message_topic, user: allowed_user, deleted_at: 1.day.ago)\n      end\n      let(:deleted_topic) { @deleted_topic }\n      let(:deleted_secure_topic) { @deleted_secure_topic }\n      let(:deleted_private_topic) { @deleted_private_topic }\n\n      let!(:nonexistent_topic_id) { Topic.last.id + 10_000 }\n      fab!(:secure_accessible_topic) { Fabricate(:topic, category: accessible_category) }\n\n      shared_examples \"various scenarios\" do |expected, request_json:|\n        expected.each do |key, value|\n          it \"returns #{value} for #{key}\" do\n            slug = key == :nonexistent ? \"garbage-slug\" : send(key.to_s).slug\n            topic_id = key == :nonexistent ? nonexistent_topic_id : send(key.to_s).id\n            format = request_json ? \".json\" : \"\"\n            get \"/t/#{slug}/#{topic_id}#{format}\"\n            expect(response.status).to eq(value)\n          end\n        end\n\n        expected_slug_response = expected[:secure_topic] == 200 ? 301 : expected[:secure_topic]\n        it \"will return a #{expected_slug_response} when requesting a secure topic by slug\" do\n          format = request_json ? \".json\" : \"\"\n          get \"/t/#{secure_topic.slug}#{format}\"\n          expect(response.status).to eq(expected_slug_response)\n        end\n      end\n\n      context \"without detailed error pages\" do\n        before { SiteSetting.detailed_404 = false }\n\n        context \"when anonymous\" do\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when anonymous with login required\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 302,\n            secure_topic: 302,\n            private_topic: 302,\n            deleted_topic: 302,\n            deleted_secure_topic: 302,\n            deleted_private_topic: 302,\n            nonexistent: 302,\n            secure_accessible_topic: 302,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when anonymous with login required, requesting json\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 403,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 403,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 403,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when normal user\" do\n          before { sign_in(user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when allowed user\" do\n          before { sign_in(allowed_user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 404,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when moderator\" do\n          before { sign_in(moderator) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 404,\n            private_topic: 404,\n            deleted_topic: 200,\n            deleted_secure_topic: 404,\n            deleted_private_topic: 404,\n            nonexistent: 404,\n            secure_accessible_topic: 404,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when admin\" do\n          before { sign_in(admin) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 200,\n            deleted_secure_topic: 200,\n            deleted_private_topic: 200,\n            nonexistent: 404,\n            secure_accessible_topic: 200,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n      end\n\n      context \"with detailed error pages\" do\n        before { SiteSetting.detailed_404 = true }\n\n        context \"when anonymous\" do\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 410,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when anonymous with login required\" do\n          before { SiteSetting.login_required = true }\n          expected = {\n            normal_topic: 302,\n            secure_topic: 302,\n            private_topic: 302,\n            deleted_topic: 302,\n            deleted_secure_topic: 302,\n            deleted_private_topic: 302,\n            nonexistent: 302,\n            secure_accessible_topic: 302,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when normal user\" do\n          before { sign_in(user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 410,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: true\n        end\n\n        context \"when allowed user\" do\n          before { sign_in(allowed_user) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 410,\n            deleted_secure_topic: 410,\n            deleted_private_topic: 410,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when moderator\" do\n          before { sign_in(moderator) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 403,\n            private_topic: 403,\n            deleted_topic: 200,\n            deleted_secure_topic: 403,\n            deleted_private_topic: 403,\n            nonexistent: 404,\n            secure_accessible_topic: 403,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n\n        context \"when admin\" do\n          before { sign_in(admin) }\n\n          expected = {\n            normal_topic: 200,\n            secure_topic: 200,\n            private_topic: 200,\n            deleted_topic: 200,\n            deleted_secure_topic: 200,\n            deleted_private_topic: 200,\n            nonexistent: 404,\n            secure_accessible_topic: 200,\n          }\n          include_examples \"various scenarios\", expected, request_json: false\n        end\n      end\n    end\n\n    it \"records a view\" do\n      expect do get \"/t/#{topic.slug}/#{topic.id}.json\" end.to change(TopicViewItem, :count).by(1)\n    end\n\n    it \"records a view to invalid post_number\" do\n      expect do\n        get \"/t/#{topic.slug}/#{topic.id}/#{256**4}\", params: { u: user.username }\n        expect(response.status).to eq(200)\n      end.to change { IncomingLink.count }.by(1)\n    end\n\n    it \"records incoming links\" do\n      expect do get \"/t/#{topic.slug}/#{topic.id}\", params: { u: user.username } end.to change {\n        IncomingLink.count\n      }.by(1)\n    end\n\n    context \"with print\" do\n      it \"doesn't renders the print view when disabled\" do\n        SiteSetting.max_prints_per_hour_per_user = 0\n\n        get \"/t/#{topic.slug}/#{topic.id}/print\"\n\n        expect(response).to be_forbidden\n      end\n\n      it \"renders the print view when enabled\" do\n        SiteSetting.max_prints_per_hour_per_user = 10\n        get \"/t/#{topic.slug}/#{topic.id}/print\", headers: { HTTP_USER_AGENT: \"Rails Testing\" }\n\n        expect(response.status).to eq(200)\n        body = response.body\n\n        expect(body).to have_tag(:body, class: \"crawler\")\n        expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n      end\n\n      it \"uses the application layout when there's no param\" do\n        SiteSetting.max_prints_per_hour_per_user = 10\n        get \"/t/#{topic.slug}/#{topic.id}\", headers: { HTTP_USER_AGENT: \"Rails Testing\" }\n\n        body = response.body\n\n        expect(body).to have_tag(:script, src: \"/assets/discourse.js\")\n        expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n      end\n\n      context \"with restricted tags\" do\n        let(:tag_group) { Fabricate.build(:tag_group) }\n        let(:tag_group_permission) { Fabricate.build(:tag_group_permission, tag_group: tag_group) }\n        let(:restricted_tag) { Fabricate(:tag) }\n        let(:public_tag) { Fabricate(:tag) }\n\n        before do\n          # avoid triggering a `before_create` callback in `TagGroup` which\n          # messes with permissions\n          tag_group.tag_group_permissions << tag_group_permission\n          tag_group.save!\n          tag_group_permission.tag_group.tags << restricted_tag\n          topic.tags << [public_tag, restricted_tag]\n        end\n\n        it \"doesn\u2019t expose restricted tags\" do\n          get \"/t/#{topic.slug}/#{topic.id}/print\", headers: { HTTP_USER_AGENT: \"Rails Testing\" }\n          expect(response.body).to match(public_tag.name)\n          expect(response.body).not_to match(restricted_tag.name)\n        end\n      end\n    end\n\n    it \"records redirects\" do\n      get \"/t/#{topic.id}\", headers: { HTTP_REFERER: \"http://twitter.com\" }\n      get \"/t/#{topic.slug}/#{topic.id}\", headers: { HTTP_REFERER: nil }\n\n      link = IncomingLink.first\n      expect(link.referer).to eq(\"http://twitter.com\")\n    end\n\n    it \"tracks a visit for all html requests\" do\n      sign_in(user)\n      get \"/t/#{topic.slug}/#{topic.id}\"\n      topic_user = TopicUser.where(user: user, topic: topic).first\n      expect(topic_user.last_visited_at).to eq_time(topic_user.first_visited_at)\n    end\n\n    context \"when considering for a promotion\" do\n      before do\n        SiteSetting.tl1_requires_topics_entered = 0\n        SiteSetting.tl1_requires_read_posts = 0\n        SiteSetting.tl1_requires_time_spent_mins = 0\n        SiteSetting.tl1_requires_time_spent_mins = 0\n      end\n\n      it \"reviews the user for a promotion if they're new\" do\n        sign_in(user)\n        user.update_column(:trust_level, TrustLevel[0])\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n        user.reload\n        expect(user.trust_level).to eq(1)\n      end\n    end\n\n    context \"with filters\" do\n      def extract_post_stream\n        json = response.parsed_body\n        json[\"post_stream\"][\"posts\"].map { |post| post[\"id\"] }\n      end\n\n      before do\n        TopicView.stubs(:chunk_size).returns(2)\n        @post_ids = topic.posts.pluck(:id)\n        3.times { @post_ids << Fabricate(:post, user: post_author1, topic: topic).id }\n      end\n\n      it \"grabs the correct set of posts\" do\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..1])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..1])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[2..3])\n\n        post_number = topic.posts.pluck(:post_number).sort[3]\n        get \"/t/#{topic.slug}/#{topic.id}/#{post_number}.json\"\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[-2..-1])\n\n        TopicView.stubs(:chunk_size).returns(3)\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..2])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[3..3])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 3 }\n        expect(response.status).to eq(404)\n\n        TopicView.stubs(:chunk_size).returns(4)\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 1 }\n        expect(response.status).to eq(200)\n        expect(extract_post_stream).to eq(@post_ids[0..3])\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\", params: { page: 2 }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe \"#show filters\" do\n      fab!(:post) { Fabricate(:post, user: post_author1) }\n      fab!(:topic) { post.topic }\n      fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic) }\n\n      describe \"filter by replies to a post\" do\n        fab!(:post3) do\n          Fabricate(\n            :post,\n            user: post_author3,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post5) { Fabricate(:post, user: post_author5, topic: topic) }\n        fab!(:quote_reply) { Fabricate(:basic_reply, user: user, topic: topic) }\n        fab!(:post_reply) { PostReply.create(post_id: post2.id, reply_post_id: quote_reply.id) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { replies_to_post_number: post2.post_number }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          expect(ids).to eq([post.id, post2.id, post3.id, post4.id, quote_reply.id])\n        end\n      end\n\n      describe \"filter by top level replies\" do\n        fab!(:post3) do\n          Fabricate(\n            :post,\n            user: post_author3,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post2.post_number,\n          )\n        end\n        fab!(:post5) { Fabricate(:post, user: post_author5, topic: topic) }\n        fab!(:post6) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post5.post_number,\n          )\n        end\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { filter_top_level_replies: true }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          expect(ids).to eq([post2.id, post5.id])\n        end\n      end\n\n      describe \"filter upwards by post id\" do\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n        fab!(:post4) do\n          Fabricate(\n            :post,\n            user: post_author4,\n            topic: topic,\n            reply_to_post_number: post3.post_number,\n          )\n        end\n        fab!(:post5) do\n          Fabricate(\n            :post,\n            user: post_author5,\n            topic: topic,\n            reply_to_post_number: post4.post_number,\n          )\n        end\n        fab!(:post6) { Fabricate(:post, user: post_author6, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}.json\", params: { filter_upwards_post_id: post5.id }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body.has_key?(\"suggested_topics\")).to eq(false)\n          expect(body.has_key?(\"related_messages\")).to eq(false)\n\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n          # includes topic OP, current post and subsequent posts\n          # but only one level of parents, respecting default max_reply_history = 1\n          expect(ids).to eq([post.id, post4.id, post5.id, post6.id])\n        end\n\n        it \"should respect max_reply_history site setting\" do\n          SiteSetting.max_reply_history = 2\n\n          get \"/t/#{topic.id}.json\", params: { filter_upwards_post_id: post5.id }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n          ids = body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }\n\n          # includes 2 levels of replies (post3 and post4)\n          expect(ids).to eq([post.id, post3.id, post4.id, post5.id, post6.id])\n        end\n      end\n    end\n\n    context \"when 'login required' site setting has been enabled\" do\n      before { SiteSetting.login_required = true }\n\n      context \"when the user is logged in\" do\n        before { sign_in(user) }\n\n        it \"shows the topic\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"when the user is not logged in\" do\n        let(:api_key) { Fabricate(:api_key, user: topic.user) }\n\n        it \"redirects browsers to the login page\" do\n          get \"/t/#{topic.slug}/#{topic.id}\"\n          expect(response).to redirect_to login_path\n        end\n\n        it \"raises a 403 for json requests\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\"\n          expect(response.status).to eq(403)\n        end\n\n        it \"shows the topic if valid api key is provided\" do\n          get \"/t/#{topic.slug}/#{topic.id}.json\", headers: { \"HTTP_API_KEY\" => api_key.key }\n\n          expect(response.status).to eq(200)\n          topic.reload\n          expect(topic.views).to eq(1)\n        end\n\n        it \"returns 403 for an invalid key\" do\n          %i[json html].each do |format|\n            get \"/t/#{topic.slug}/#{topic.id}.#{format}\", headers: { \"HTTP_API_KEY\" => \"bad\" }\n\n            expect(response.code.to_i).to eq(403)\n            expect(response.body).to include(I18n.t(\"invalid_access\"))\n          end\n        end\n      end\n    end\n\n    it \"is included for unlisted topics\" do\n      get \"/t/#{invisible_topic.slug}/#{invisible_topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex\")\n    end\n\n    it \"is not included for normal topics\" do\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(nil)\n    end\n\n    it \"is included when allow_index_in_robots_txt is set to false\" do\n      SiteSetting.allow_index_in_robots_txt = false\n\n      get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex, nofollow\")\n    end\n\n    it \"doesn't store an incoming link when there's no referer\" do\n      expect { get \"/t/#{topic.id}.json\" }.not_to change(IncomingLink, :count)\n      expect(response.status).to eq(200)\n    end\n\n    it \"doesn't raise an error on a very long link\" do\n      get \"/t/#{topic.id}.json\", headers: { HTTP_REFERER: \"http://#{\"a\" * 2000}.com\" }\n      expect(response.status).to eq(200)\n    end\n\n    context \"when `enable_user_status` site setting is enabled\" do\n      fab!(:post) { Fabricate(:post, user: post_author1) }\n      fab!(:topic) { post.topic }\n      fab!(:post2) do\n        Fabricate(\n          :post,\n          user: post_author2,\n          topic: topic,\n          raw: \"I am mentioning @#{post_author1.username}.\",\n        )\n      end\n\n      before { SiteSetting.enable_user_status = true }\n\n      it \"does not return mentions when `enable_user_status` site setting is disabled\" do\n        SiteSetting.enable_user_status = false\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"]).to eq(nil)\n      end\n\n      it \"returns mentions with status\" do\n        post_author1.set_status!(\"off to dentist\", \"tooth\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"].length).to be(1)\n\n        mentioned_user = json[\"post_stream\"][\"posts\"][1][\"mentioned_users\"][0]\n        expect(mentioned_user[\"id\"]).to be(post_author1.id)\n        expect(mentioned_user[\"name\"]).to eq(post_author1.name)\n        expect(mentioned_user[\"username\"]).to eq(post_author1.username)\n\n        status = mentioned_user[\"status\"]\n        expect(status).to be_present\n        expect(status[\"emoji\"]).to eq(post_author1.user_status.emoji)\n        expect(status[\"description\"]).to eq(post_author1.user_status.description)\n      end\n\n      it \"returns an empty list of mentioned users if there are no mentions in a post\" do\n        Fabricate(:post, user: post_author2, topic: topic, raw: \"Post without mentions.\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][2][\"mentioned_users\"].length).to be(0)\n      end\n\n      it \"returns an empty list of mentioned users if an unexisting user was mentioned\" do\n        Fabricate(:post, user: post_author2, topic: topic, raw: \"Mentioning an @unexisting_user.\")\n\n        get \"/t/#{topic.slug}/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"post_stream\"][\"posts\"][2][\"mentioned_users\"].length).to be(0)\n      end\n    end\n\n    describe \"has_escaped_fragment?\" do\n      context \"when the SiteSetting is disabled\" do\n        it \"uses the application layout even with an escaped fragment param\" do\n          SiteSetting.enable_escaped_fragments = false\n\n          get \"/t/#{topic.slug}/#{topic.id}\", params: { _escaped_fragment_: \"true\" }\n\n          body = response.body\n\n          expect(response.status).to eq(200)\n          expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n\n      context \"when the SiteSetting is enabled\" do\n        before { SiteSetting.enable_escaped_fragments = true }\n\n        it \"uses the application layout when there's no param\" do\n          get \"/t/#{topic.slug}/#{topic.id}\"\n\n          body = response.body\n\n          expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n          expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n        end\n\n        it \"uses the crawler layout when there's an _escaped_fragment_ param\" do\n          get \"/t/#{topic.slug}/#{topic.id}\",\n              params: {\n                _escaped_fragment_: true,\n              },\n              headers: {\n                HTTP_USER_AGENT: \"Rails Testing\",\n              }\n\n          body = response.body\n\n          expect(response.status).to eq(200)\n          expect(body).to have_tag(:body, with: { class: \"crawler\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n    end\n\n    describe \"clear_notifications\" do\n      it \"correctly clears notifications if specified via cookie\" do\n        set_subfolder \"/eviltrout\"\n\n        notification = Fabricate(:notification)\n        sign_in(notification.user)\n\n        cookies[\"cn\"] = \"2828,100,#{notification.id}\"\n\n        get \"/t/#{topic.id}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.cookies[\"cn\"]).to eq(nil)\n        expect(response.headers[\"Set-Cookie\"]).to match(%r{^cn=;.*path=/eviltrout})\n\n        notification.reload\n        expect(notification.read).to eq(true)\n      end\n\n      it \"correctly clears notifications if specified via header\" do\n        notification = Fabricate(:notification)\n        sign_in(notification.user)\n\n        get \"/t/#{topic.id}.json\",\n            headers: {\n              \"Discourse-Clear-Notifications\" => \"2828,100,#{notification.id}\",\n            }\n\n        expect(response.status).to eq(200)\n        notification.reload\n        expect(notification.read).to eq(true)\n      end\n    end\n\n    describe \"read only header\" do\n      it \"returns no read only header by default\" do\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"Discourse-Readonly\"]).to eq(nil)\n      end\n\n      it \"returns a readonly header if the site is read only\" do\n        Discourse.received_postgres_readonly!\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers[\"Discourse-Readonly\"]).to eq(\"true\")\n      end\n    end\n\n    describe \"image only topic\" do\n      it \"uses image alt tag for meta description\" do\n        post =\n          Fabricate(\n            :post,\n            user: post_author1,\n            raw: \"![image_description|690x405](upload://sdtr5O5xaxf0iEOxICxL36YRj86.png)\",\n          )\n\n        get post.topic.url\n\n        body = response.body\n        expect(body).to have_tag(\n          :meta,\n          with: {\n            name: \"description\",\n            content: \"[image_description]\",\n          },\n        )\n      end\n\n      it \"uses image cdn url for schema markup\" do\n        set_cdn_url(\"http://cdn.localhost\")\n        post = Fabricate(:post_with_uploaded_image, user: post_author1)\n        cpp = CookedPostProcessor.new(post).update_post_image\n\n        get post.topic.url\n\n        body = response.body\n        expect(body).to have_tag(:link, with: { itemprop: \"image\", href: post.image_url })\n      end\n    end\n  end\n\n  describe \"#post_ids\" do\n    fab!(:post) { Fabricate(:post, user: post_author1) }\n    fab!(:topic) { post.topic }\n\n    before { TopicView.stubs(:chunk_size).returns(1) }\n\n    it \"returns the right post ids\" do\n      post2 = Fabricate(:post, user: post_author2, topic: topic)\n      post3 = Fabricate(:post, user: post_author3, topic: topic)\n\n      get \"/t/#{topic.id}/post_ids.json\", params: { post_number: post.post_number }\n\n      expect(response.status).to eq(200)\n\n      body = response.parsed_body\n\n      expect(body[\"post_ids\"]).to eq([post2.id, post3.id])\n    end\n\n    describe \"filtering by post number with filters\" do\n      describe \"username filters\" do\n        fab!(:post) { Fabricate(:post, user: user) }\n        fab!(:post2) { Fabricate(:post, topic: topic, user: user) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}/post_ids.json\",\n              params: {\n                post_number: post.post_number,\n                username_filters: post2.user.username,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_ids\"]).to eq([post2.id])\n        end\n      end\n\n      describe \"summary filter\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          get \"/t/#{topic.id}/post_ids.json\",\n              params: {\n                post_number: post.post_number,\n                filter: \"summary\",\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_ids\"]).to eq([post2.id])\n        end\n      end\n\n      describe \"custom filters\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic, percent_rank: 0.5) }\n        it \"should return the right posts\" do\n          TopicView.add_custom_filter(\"percent\") do |posts, topic_view|\n            posts.where(percent_rank: 0.5)\n          end\n\n          get \"/t/#{topic.id}.json\", params: { post_number: post.post_number, filter: \"percent\" }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].map { |p| p[\"id\"] }).to eq([post3.id])\n        ensure\n          TopicView.instance_variable_set(:@custom_filters, {})\n        end\n      end\n    end\n  end\n\n  describe \"#posts\" do\n    fab!(:post) { Fabricate(:post, user: post_author1) }\n    fab!(:topic) { post.topic }\n\n    after { Discourse.redis.flushdb }\n\n    it \"returns first post of the topic\" do\n      # we need one for suggested\n      create_post\n\n      get \"/t/#{topic.id}/posts.json\"\n\n      expect(response.status).to eq(200)\n\n      body = response.parsed_body\n\n      expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post.id)\n\n      expect(body[\"suggested_topics\"]).to eq(nil)\n\n      get \"/t/#{topic.id}/posts.json?include_suggested=true\"\n      body = response.parsed_body\n\n      expect(body[\"suggested_topics\"]).not_to eq(nil)\n    end\n\n    describe \"filtering by post number with filters\" do\n      describe \"username filters\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          TopicView.stubs(:chunk_size).returns(2)\n\n          get \"/t/#{topic.id}/posts.json\",\n              params: {\n                post_number: post.post_number,\n                username_filters: post2.user.username,\n                asc: true,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post2.id)\n        end\n      end\n\n      describe \"summary filter\" do\n        fab!(:post2) { Fabricate(:post, user: post_author2, topic: topic, percent_rank: 0.2) }\n        fab!(:post3) { Fabricate(:post, user: post_author3, topic: topic) }\n\n        it \"should return the right posts\" do\n          TopicView.stubs(:chunk_size).returns(2)\n\n          get \"/t/#{topic.id}/posts.json\",\n              params: {\n                post_number: post.post_number,\n                filter: \"summary\",\n                asc: true,\n              }\n\n          expect(response.status).to eq(200)\n\n          body = response.parsed_body\n\n          expect(body[\"post_stream\"][\"posts\"].first[\"id\"]).to eq(post2.id)\n        end\n      end\n    end\n  end\n\n  describe \"#feed\" do\n    fab!(:topic) { Fabricate(:post, user: post_author1).topic }\n\n    it \"renders rss of the topic\" do\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(200)\n      expect(response.media_type).to eq(\"application/rss+xml\")\n\n      # our RSS feed is full of post 1/2/3/4/5 links, we do not want it included\n      # in the index, and do not want links followed\n      # this allows us to remove it while allowing via robots.txt\n      expect(response.headers[\"X-Robots-Tag\"]).to eq(\"noindex, nofollow\")\n    end\n\n    it \"renders rss of the topic correctly with subfolder\" do\n      set_subfolder \"/forum\"\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(200)\n      expect(response.body).to_not include(\"/forum/forum\")\n      expect(response.body).to include(\"http://test.localhost/forum/t/#{topic.slug}\")\n    end\n\n    it \"returns 404 when posts are deleted\" do\n      topic.posts.each(&:trash!)\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns 404 when the topic is deleted\" do\n      topic.trash!\n      get \"/t/foo/#{topic.id}.rss\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#invite_group\" do\n    let!(:admins) { Group[:admins] }\n\n    before do\n      sign_in(admin)\n      admins.messageable_level = Group::ALIAS_LEVELS[:everyone]\n      admins.save!\n    end\n\n    it \"disallows inviting a group to a topic\" do\n      post \"/t/#{topic.id}/invite-group.json\", params: { group: \"admins\" }\n\n      expect(response.status).to eq(422)\n    end\n\n    it \"allows inviting a group to a PM\" do\n      post \"/t/#{pm.id}/invite-group.json\", params: { group: \"admins\" }\n\n      expect(response.status).to eq(200)\n      expect(pm.allowed_groups.first.id).to eq(admins.id)\n    end\n  end\n\n  describe \"#make_banner\" do\n    it \"needs you to be a staff member\" do\n      tl4_topic = Fabricate(:topic, user: sign_in(trust_level_4))\n      put \"/t/#{tl4_topic.id}/make-banner.json\"\n      expect(response).to be_forbidden\n    end\n\n    describe \"when logged in\" do\n      it \"changes the topic archetype to 'banner'\" do\n        admin_topic = Fabricate(:topic, user: sign_in(admin))\n\n        put \"/t/#{admin_topic.id}/make-banner.json\"\n        expect(response.status).to eq(200)\n        admin_topic.reload\n        expect(admin_topic.archetype).to eq(Archetype.banner)\n      end\n    end\n  end\n\n  describe \"#remove_banner\" do\n    it \"needs you to be a staff member\" do\n      tl4_topic = Fabricate(:topic, user: sign_in(trust_level_4), archetype: Archetype.banner)\n      put \"/t/#{tl4_topic.id}/remove-banner.json\"\n      expect(response).to be_forbidden\n    end\n\n    describe \"when logged in\" do\n      it \"resets the topic archetype\" do\n        admin_topic = Fabricate(:topic, user: sign_in(admin), archetype: Archetype.banner)\n\n        put \"/t/#{admin_topic.id}/remove-banner.json\"\n        expect(response.status).to eq(200)\n        admin_topic.reload\n        expect(admin_topic.archetype).to eq(Archetype.default)\n      end\n    end\n  end\n\n  describe \"#remove_allowed_user\" do\n    it \"admin can be removed from a pm\" do\n      sign_in(admin)\n      pm =\n        create_post(\n          user: user,\n          archetype: \"private_message\",\n          target_usernames: [user.username, admin.username],\n        )\n\n      put \"/t/#{pm.topic_id}/remove-allowed-user.json\", params: { username: admin.username }\n\n      expect(response.status).to eq(200)\n      expect(TopicAllowedUser.where(topic_id: pm.topic_id, user_id: admin.id).first).to eq(nil)\n    end\n  end\n\n  describe \"#bulk\" do\n    it \"needs you to be logged in\" do\n      put \"/topics/bulk.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"when logged in\" do\n      before { sign_in(user) }\n      let!(:operation) { { type: \"change_category\", category_id: \"1\" } }\n      let!(:topic_ids) { [1, 2, 3] }\n\n      it \"requires a list of topic_ids or filter\" do\n        put \"/topics/bulk.json\", params: { operation: operation }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires an operation param\" do\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids }\n        expect(response.status).to eq(400)\n      end\n\n      it \"requires a type field for the operation param\" do\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids, operation: {} }\n        expect(response.status).to eq(400)\n      end\n\n      it \"can mark sub-categories unread\" do\n        sub = Fabricate(:category, parent_category_id: category.id)\n\n        topic.update!(category_id: sub.id)\n\n        post1 = create_post(user: user, topic_id: topic.id)\n        create_post(topic_id: topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              category_id: category.id,\n              include_subcategories: true,\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(post1.topic, post1.user).last_read_post_number).to eq(2)\n      end\n\n      it \"can mark tag topics unread\" do\n        TopicTag.create!(topic_id: topic.id, tag_id: tag.id)\n\n        post1 = create_post(user: user, topic_id: topic.id)\n        create_post(topic_id: topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              tag_name: tag.name,\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(post1.topic, post1.user).last_read_post_number).to eq(2)\n      end\n\n      context \"with private message\" do\n        before_all { Group.refresh_automatic_groups! }\n\n        fab!(:group) do\n          Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap do |g|\n            g.add(user_2)\n          end\n        end\n\n        fab!(:group_message) do\n          create_post(\n            user: user,\n            target_group_names: [group.name],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:private_message) do\n          create_post(\n            user: user,\n            target_usernames: [user_2.username],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:private_message_2) do\n          create_post(\n            user: user,\n            target_usernames: [user_2.username],\n            archetype: Archetype.private_message,\n          ).topic\n        end\n\n        fab!(:group_pm_topic_user) do\n          TopicUser\n            .find_by(user: user_2, topic: group_message)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        fab!(:regular_pm_topic_user) do\n          TopicUser\n            .find_by(user: user_2, topic: private_message)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        fab!(:regular_pm_topic_user_2) do\n          TopicUser\n            .find_by(user: user_2, topic: private_message_2)\n            .tap { |tu| tu.update!(last_read_post_number: 1) }\n        end\n\n        before_all do\n          create_post(user: user, topic: group_message)\n          create_post(user: user, topic: private_message)\n          create_post(user: user, topic: private_message_2)\n        end\n\n        before { sign_in(user_2) }\n\n        it \"can dismiss all user and group private message topics\" do\n          expect do\n            put \"/topics/bulk.json\",\n                params: {\n                  filter: \"unread\",\n                  operation: {\n                    type: \"dismiss_posts\",\n                  },\n                  private_message_inbox: \"all\",\n                }\n\n            expect(response.status).to eq(200)\n          end.to change { group_pm_topic_user.reload.last_read_post_number }.from(1).to(\n            2,\n          ).and change { regular_pm_topic_user.reload.last_read_post_number }.from(1).to(2)\n        end\n\n        it \"can dismiss all user unread private message topics\" do\n          stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n            expect do\n              put \"/topics/bulk.json\",\n                  params: {\n                    filter: \"unread\",\n                    operation: {\n                      type: \"dismiss_posts\",\n                    },\n                    private_message_inbox: \"user\",\n                  }\n\n              expect(response.status).to eq(200)\n            end.to change { regular_pm_topic_user.reload.last_read_post_number }.from(1).to(\n              2,\n            ).and change { regular_pm_topic_user_2.reload.last_read_post_number }.from(1).to(2)\n\n            expect(group_pm_topic_user.reload.last_read_post_number).to eq(1)\n          end\n        end\n\n        it \"returns the right response when trying to dismiss private messages of an invalid group\" do\n          put \"/topics/bulk.json\",\n              params: {\n                filter: \"unread\",\n                operation: {\n                  type: \"dismiss_posts\",\n                },\n                private_message_inbox: \"group\",\n                group_name: \"randomgroup\",\n              }\n\n          expect(response.status).to eq(404)\n        end\n\n        it \"returns the right response when trying to dismiss private messages of a restricted group\" do\n          sign_in(user)\n\n          put \"/topics/bulk.json\",\n              params: {\n                filter: \"unread\",\n                operation: {\n                  type: \"dismiss_posts\",\n                },\n                private_message_inbox: \"group\",\n                group_name: group.name,\n              }\n\n          expect(response.status).to eq(404)\n        end\n\n        it \"can dismiss all group unread private message topics\" do\n          expect do\n            put \"/topics/bulk.json\",\n                params: {\n                  filter: \"unread\",\n                  operation: {\n                    type: \"dismiss_posts\",\n                  },\n                  private_message_inbox: \"group\",\n                  group_name: group.name,\n                }\n\n            expect(response.status).to eq(200)\n          end.to change { group_pm_topic_user.reload.last_read_post_number }.from(1).to(2)\n\n          expect(regular_pm_topic_user.reload.last_read_post_number).to eq(1)\n        end\n      end\n\n      it \"can find unread\" do\n        # mark all unread muted\n        put \"/topics/bulk.json\",\n            params: {\n              filter: \"unread\",\n              operation: {\n                type: :change_notification_level,\n                notification_level_id: 0,\n              },\n            }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"delegates work to `TopicsBulkAction`\" do\n        topics_bulk_action = mock\n        TopicsBulkAction\n          .expects(:new)\n          .with(user, topic_ids, operation, group: nil)\n          .returns(topics_bulk_action)\n        topics_bulk_action.expects(:perform!)\n\n        put \"/topics/bulk.json\", params: { topic_ids: topic_ids, operation: operation }\n      end\n\n      it \"raises an error if topic_ids is provided and it is not an array\" do\n        put \"/topics/bulk.json\", params: { topic_ids: \"1\", operation: operation }\n        expect(response.parsed_body[\"errors\"].first).to match(\n          /Expecting topic_ids to contain a list/,\n        )\n        put \"/topics/bulk.json\", params: { topic_ids: [1], operation: operation }\n        expect(response.parsed_body[\"errors\"]).to eq(nil)\n      end\n\n      it \"respects the tracked parameter\" do\n        # untracked topic\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:regular],\n          category.id,\n        )\n        create_post(user: user, topic_id: topic.id)\n        topic.update!(category_id: category.id)\n        create_post(topic_id: topic.id)\n\n        # tracked topic\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:tracking],\n          tracked_category.id,\n        )\n        tracked_topic = create_post(user: user).topic\n        tracked_topic.update!(category_id: tracked_category.id)\n        create_post(topic_id: tracked_topic.id)\n\n        put \"/topics/bulk.json\",\n            params: {\n              filter: \"unread\",\n              operation: {\n                type: \"dismiss_posts\",\n              },\n              tracked: true,\n            }\n\n        expect(response.status).to eq(200)\n        expect(TopicUser.get(topic, user).last_read_post_number).to eq(topic.posts.count - 1)\n        expect(TopicUser.get(tracked_topic, user).last_read_post_number).to eq(\n          tracked_topic.posts.count,\n        )\n      end\n    end\n  end\n\n  describe \"#remove_bookmarks\" do\n    it \"should remove bookmarks properly from non first post\" do\n      sign_in(user)\n\n      post = create_post\n      post2 = create_post(topic_id: post.topic_id)\n      Fabricate(:bookmark, user: user, bookmarkable: post)\n      Fabricate(:bookmark, user: user, bookmarkable: post2)\n\n      put \"/t/#{post.topic_id}/remove_bookmarks.json\"\n      expect(Bookmark.where(user: user).count).to eq(0)\n    end\n\n    it \"should disallow bookmarks on posts you have no access to\" do\n      sign_in(Fabricate(:user))\n      pm = create_post(user: user, archetype: \"private_message\", target_usernames: [user.username])\n\n      put \"/t/#{pm.topic_id}/bookmark.json\"\n      expect(response).to be_forbidden\n    end\n\n    context \"with bookmarks with reminders\" do\n      it \"deletes all the bookmarks for the user in the topic\" do\n        sign_in(user)\n        post = create_post\n        Fabricate(:bookmark, bookmarkable: post, user: user)\n        put \"/t/#{post.topic_id}/remove_bookmarks.json\"\n        expect(Bookmark.for_user_in_topic(user.id, post.topic_id).count).to eq(0)\n      end\n    end\n  end\n\n  describe \"#bookmark\" do\n    before { sign_in(user) }\n\n    it \"should create a new bookmark for the topic\" do\n      post = create_post\n      post2 = create_post(topic_id: post.topic_id)\n      put \"/t/#{post.topic_id}/bookmark.json\"\n\n      expect(Bookmark.find_by(user_id: user.id).bookmarkable_id).to eq(post.topic_id)\n    end\n\n    it \"errors if the topic is already bookmarked for the user\" do\n      post = create_post\n      Bookmark.create(bookmarkable: post.topic, user: user)\n\n      put \"/t/#{post.topic_id}/bookmark.json\"\n      expect(response.status).to eq(400)\n    end\n  end\n\n  describe \"#reset_new\" do\n    context \"when a user is not signed in\" do\n      it \"fails\" do\n        put \"/topics/reset-new.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when a user is signed in\" do\n      before_all do\n        @old_date = 2.years.ago\n        user.user_stat.update_column(:new_since, @old_date)\n\n        CategoryUser.set_notification_level_for_category(\n          user,\n          NotificationLevels.all[:tracking],\n          tracked_category.id,\n        )\n      end\n\n      let!(:old_date) { @old_date }\n\n      before { sign_in(user) }\n\n      context \"when tracked is unset\" do\n        it \"updates the `new_since` date\" do\n          TopicTrackingState.expects(:publish_dismiss_new)\n\n          put \"/topics/reset-new.json\"\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).not_to eq(old_date.to_date)\n        end\n      end\n\n      describe \"when tracked param is true\" do\n        it \"does not update user_stat.new_since\" do\n          put \"/topics/reset-new.json?tracked=true\"\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).to eq(old_date.to_date)\n        end\n\n        it \"creates dismissed topic user records for each new topic\" do\n          tracked_topic = create_post(category: tracked_category).topic\n\n          create_post # This is a new post, but is not tracked so a record will not be created for it\n          expect do put \"/topics/reset-new.json?tracked=true\" end.to change {\n            DismissedTopicUser.where(user_id: user.id, topic_id: tracked_topic.id).count\n          }.by(1)\n        end\n      end\n\n      context \"when 5 tracked topics exist\" do\n        before_all do\n          @tracked_topic_ids = 5.times.map { create_post(category: tracked_category).topic.id }\n          @tracked_topic_ids.freeze\n        end\n\n        describe \"when tracked param is true\" do\n          it \"creates dismissed topic user records if there are > 30 (default pagination) topics\" do\n            expect do\n              stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 2) do\n                put \"/topics/reset-new.json?tracked=true\"\n              end\n            end.to change {\n              DismissedTopicUser.where(user_id: user.id, topic_id: @tracked_topic_ids).count\n            }.by(5)\n          end\n\n          it \"creates dismissed topic user records if there are > 30 (default pagination) topics and topic_ids are provided\" do\n            dismissing_topic_ids = @tracked_topic_ids.sample(4)\n\n            expect do\n              stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 2) do\n                put \"/topics/reset-new.json?tracked=true\",\n                    params: {\n                      topic_ids: dismissing_topic_ids,\n                    }\n              end\n            end.to change {\n              DismissedTopicUser.where(user_id: user.id, topic_id: @tracked_topic_ids).count\n            }.by(4)\n          end\n        end\n\n        context \"when two extra topics exist\" do\n          before_all do\n            @topic_ids = @tracked_topic_ids + [Fabricate(:topic).id, Fabricate(:topic).id]\n            @topic_ids.freeze\n          end\n\n          context \"when tracked=false\" do\n            it \"updates the user_stat new_since column and dismisses all the new topics\" do\n              old_new_since = user.user_stat.new_since\n\n              put \"/topics/reset-new.json?tracked=false\"\n              expect(DismissedTopicUser.where(user_id: user.id, topic_id: @topic_ids).count).to eq(\n                7,\n              )\n              expect(user.reload.user_stat.new_since > old_new_since).to eq(true)\n            end\n\n            it \"does not pass topic ids that are not new for the user to the bulk action, limit the scope to new topics\" do\n              dismiss_ids = @topic_ids[0..1]\n              other_ids = @topic_ids[2..-1].sort.reverse\n\n              DismissedTopicUser.create(user_id: user.id, topic_id: dismiss_ids.first)\n              DismissedTopicUser.create(user_id: user.id, topic_id: dismiss_ids.second)\n\n              expect { put \"/topics/reset-new.json?tracked=false\" }.to change {\n                DismissedTopicUser.where(user_id: user.id).count\n              }.by(5)\n            end\n          end\n        end\n      end\n\n      context \"with category\" do\n        fab!(:subcategory) { Fabricate(:category, parent_category_id: category.id) }\n        fab!(:category_topic) { Fabricate(:topic, category: category) }\n        fab!(:subcategory_topic) { Fabricate(:topic, category: subcategory) }\n\n        it \"dismisses topics for main category\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [category_topic.id],\n          )\n\n          put \"/topics/reset-new.json?category_id=#{category.id}\"\n\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq(\n            [category_topic.id],\n          )\n        end\n\n        it \"dismisses topics for main category and subcategories\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [category_topic.id, subcategory_topic.id],\n          )\n\n          put \"/topics/reset-new.json?category_id=#{category.id}&include_subcategories=true\"\n\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id).sort).to eq(\n            [category_topic.id, subcategory_topic.id].sort,\n          )\n        end\n      end\n\n      context \"with tag\" do\n        fab!(:tag_topic) { Fabricate(:topic) }\n        fab!(:topic_tag) { Fabricate(:topic_tag, topic: tag_topic, tag: tag) }\n\n        it \"dismisses topics for tag\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(user.id, topic_ids: [tag_topic.id])\n          put \"/topics/reset-new.json?tag_id=#{tag.name}\"\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq([tag_topic.id])\n        end\n      end\n\n      context \"with tag and category\" do\n        fab!(:tag_topic) { Fabricate(:topic) }\n        fab!(:topic_tag) { Fabricate(:topic_tag, topic: tag_topic, tag: tag) }\n        fab!(:tag_and_category_topic) { Fabricate(:topic, category: category) }\n        fab!(:topic_tag2) { Fabricate(:topic_tag, topic: tag_and_category_topic, tag: tag) }\n\n        it \"dismisses topics for tag\" do\n          TopicTrackingState.expects(:publish_dismiss_new).with(\n            user.id,\n            topic_ids: [tag_and_category_topic.id],\n          )\n          put \"/topics/reset-new.json?tag_id=#{tag.name}&category_id=#{category.id}\"\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to eq(\n            [tag_and_category_topic.id],\n          )\n        end\n      end\n\n      context \"with specific topics\" do\n        fab!(:topic2) { Fabricate(:topic) }\n        fab!(:topic3) { Fabricate(:topic) }\n\n        it \"updates the `new_since` date\" do\n          TopicTrackingState\n            .expects(:publish_dismiss_new)\n            .with(user.id, topic_ids: [topic2.id, topic3.id])\n            .at_least_once\n\n          put \"/topics/reset-new.json\", **{ params: { topic_ids: [topic2.id, topic3.id] } }\n          expect(response.status).to eq(200)\n          user.reload\n          expect(user.user_stat.new_since.to_date).not_to eq(old_date.to_date)\n          expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to match_array(\n            [topic2.id, topic3.id],\n          )\n        end\n\n        it \"raises an error if topic_ids is provided and it is not an array\" do\n          put \"/topics/reset-new.json\", params: { topic_ids: topic2.id }\n          expect(response.parsed_body[\"errors\"].first).to match(\n            /Expecting topic_ids to contain a list/,\n          )\n          put \"/topics/reset-new.json\", params: { topic_ids: [topic2.id] }\n          expect(response.parsed_body[\"errors\"]).to eq(nil)\n        end\n\n        describe \"when tracked param is true\" do\n          it \"does not update user_stat.new_since and does not dismiss untracked topics\" do\n            put \"/topics/reset-new.json?tracked=true\",\n                **{ params: { topic_ids: [topic2.id, topic3.id] } }\n            expect(response.status).to eq(200)\n            user.reload\n            expect(user.user_stat.new_since.to_date).to eq(old_date.to_date)\n            expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to be_empty\n          end\n\n          it \"creates topic user records for each unread topic\" do\n            tracked_topic = create_post.topic\n            tracked_topic.update!(category_id: tracked_category.id)\n            topic2.update!(category_id: tracked_category.id)\n\n            create_post # This is a new post, but is not tracked so a record will not be created for it\n            expect do\n              put \"/topics/reset-new.json?tracked=true\",\n                  **{ params: { topic_ids: [tracked_topic.id, topic2.id, topic3.id] } }\n            end.to change { DismissedTopicUser.where(user_id: user.id).count }.by(2)\n            expect(DismissedTopicUser.where(user_id: user.id).pluck(:topic_id)).to match_array(\n              [tracked_topic.id, topic2.id],\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#feature_stats\" do\n    it \"works\" do\n      get \"/topics/feature_stats.json\", params: { category_id: 1 }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"pinned_in_category_count\"]).to eq(0)\n      expect(json[\"pinned_globally_count\"]).to eq(0)\n      expect(json[\"banner_count\"]).to eq(0)\n    end\n\n    it \"allows unlisted banner topic\" do\n      Fabricate(:topic, category_id: 1, archetype: Archetype.banner, visible: false)\n\n      get \"/topics/feature_stats.json\", params: { category_id: 1 }\n      json = response.parsed_body\n      expect(json[\"banner_count\"]).to eq(1)\n    end\n  end\n\n  describe \"#excerpts\" do\n    it \"can correctly get excerpts\" do\n      first_post =\n        create_post(raw: \"This is the first post :)\", title: \"This is a test title I am making yay\")\n      second_post = create_post(raw: \"This is second post\", topic: first_post.topic)\n      third_post = first_post.topic.add_small_action(first_post.user, \"autobumped\")\n\n      random_post = Fabricate(:post, user: post_author1)\n\n      get \"/t/#{first_post.topic_id}/excerpts.json\",\n          params: {\n            post_ids: [first_post.id, second_post.id, third_post.id, random_post.id],\n          }\n\n      json = response.parsed_body\n      json.sort! { |a, b| a[\"post_id\"] <=> b[\"post_id\"] }\n\n      # no random post\n      expect(json.map { |p| p[\"post_id\"] }).to contain_exactly(\n        first_post.id,\n        second_post.id,\n        third_post.id,\n      )\n      # keep emoji images\n      expect(json[0][\"excerpt\"]).to match(/emoji/)\n      expect(json[0][\"excerpt\"]).to match(/first post/)\n      expect(json[0][\"username\"]).to eq(first_post.user.username)\n      expect(json[0][\"created_at\"].present?).to eq(false)\n\n      expect(json[1][\"excerpt\"]).to match(/second post/)\n\n      expect(json[2][\"action_code\"]).to eq(\"autobumped\")\n      expect(json[2][\"created_at\"].present?).to eq(true)\n    end\n  end\n\n  describe \"#convert_topic\" do\n    it \"needs you to be logged in\" do\n      put \"/t/111/convert-topic/private.json\"\n      expect(response.status).to eq(403)\n    end\n\n    describe \"converting public topic to private message\" do\n      fab!(:topic) { Fabricate(:topic, user: user) }\n      fab!(:post) { Fabricate(:post, user: user, topic: topic) }\n\n      before { Group.refresh_automatic_groups! }\n\n      it \"raises an error when the user doesn't have permission to convert topic\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/convert-topic/private.json\"\n        expect(response).to be_forbidden\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          sign_in(admin)\n          put \"/t/#{topic.id}/convert-topic/private.json\"\n\n          topic.reload\n          expect(topic.archetype).to eq(Archetype.private_message)\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n\n    describe \"converting private message to public topic\" do\n      fab!(:topic) { Fabricate(:private_message_topic, user: user) }\n      fab!(:post) { Fabricate(:post, user: post_author1, topic: topic) }\n\n      before { Group.refresh_automatic_groups! }\n\n      it \"raises an error when the user doesn't have permission to convert topic\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/convert-topic/public.json\"\n        expect(response).to be_forbidden\n      end\n\n      context \"with success\" do\n        it \"returns success\" do\n          sign_in(admin)\n          put \"/t/#{topic.id}/convert-topic/public.json?category_id=#{category.id}\"\n\n          topic.reload\n          expect(topic.archetype).to eq(Archetype.default)\n          expect(topic.category_id).to eq(category.id)\n          expect(response.status).to eq(200)\n\n          result = response.parsed_body\n          expect(result[\"success\"]).to eq(true)\n          expect(result[\"url\"]).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#timings\" do\n    fab!(:post_1) { Fabricate(:post, user: post_author1, topic: topic) }\n\n    it \"should record the timing\" do\n      sign_in(user)\n\n      post \"/topics/timings.json\",\n           params: {\n             topic_id: topic.id,\n             topic_time: 5,\n             timings: {\n               post_1.post_number => 2,\n             },\n           }\n\n      expect(response.status).to eq(200)\n\n      post_timing = PostTiming.first\n\n      expect(post_timing.topic).to eq(topic)\n      expect(post_timing.user).to eq(user)\n      expect(post_timing.msecs).to eq(2)\n    end\n\n    it \"caps post read time at the max integer value (2^31 - 1)\" do\n      PostTiming.create!(\n        topic_id: post_1.topic.id,\n        post_number: post_1.post_number,\n        user_id: user.id,\n        msecs: 2**31 - 10,\n      )\n      sign_in(user)\n\n      post \"/topics/timings.json\",\n           params: {\n             topic_id: topic.id,\n             topic_time: 5,\n             timings: {\n               post_1.post_number => 100,\n             },\n           }\n\n      expect(response.status).to eq(200)\n      post_timing = PostTiming.first\n\n      expect(post_timing.topic).to eq(topic)\n      expect(post_timing.user).to eq(user)\n      expect(post_timing.msecs).to eq(2**31 - 1)\n    end\n  end\n\n  describe \"#timer\" do\n    context \"when a user is not logged in\" do\n      it \"should return the right response\" do\n        post \"/t/#{topic.id}/timer.json\", params: { time: \"24\", status_type: TopicTimer.types[1] }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when does not have permission\" do\n      it \"should return the right response\" do\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: \"24\", status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n    end\n\n    context \"when time is in the past\" do\n      it \"returns an error\" do\n        freeze_time\n        sign_in(admin)\n\n        post \"/t/#{topic.id}/timer.json\",\n             params: {\n               time: Time.current - 1.day,\n               status_type: TopicTimer.types[1],\n             }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when logged in as an admin\" do\n      before do\n        freeze_time\n        sign_in(admin)\n      end\n\n      it \"should be able to create a topic status update\" do\n        post \"/t/#{topic.id}/timer.json\", params: { time: 24, status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(200)\n\n        topic_status_update = TopicTimer.last\n\n        expect(topic_status_update.topic).to eq(topic)\n        expect(topic_status_update.execute_at).to eq_time(24.hours.from_now)\n\n        json = response.parsed_body\n\n        expect(DateTime.parse(json[\"execute_at\"])).to eq_time(\n          DateTime.parse(topic_status_update.execute_at.to_s),\n        )\n\n        expect(json[\"duration_minutes\"]).to eq(topic_status_update.duration_minutes)\n        expect(json[\"closed\"]).to eq(topic.reload.closed)\n      end\n\n      it \"should be able to delete a topic status update\" do\n        Fabricate(:topic_timer, topic: topic)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: nil, status_type: TopicTimer.types[1] }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.public_topic_timer).to eq(nil)\n\n        json = response.parsed_body\n\n        expect(json[\"execute_at\"]).to eq(nil)\n        expect(json[\"duration_minutes\"]).to eq(nil)\n        expect(json[\"closed\"]).to eq(topic.closed)\n      end\n\n      it \"should be able to create a topic status update with duration\" do\n        post \"/t/#{topic.id}/timer.json\",\n             params: {\n               duration_minutes: 7200,\n               status_type: TopicTimer.types[7],\n             }\n\n        expect(response.status).to eq(200)\n\n        topic_status_update = TopicTimer.last\n\n        expect(topic_status_update.topic).to eq(topic)\n        expect(topic_status_update.execute_at).to eq_time(5.days.from_now)\n        expect(topic_status_update.duration_minutes).to eq(7200)\n\n        json = response.parsed_body\n\n        expect(DateTime.parse(json[\"execute_at\"])).to eq_time(\n          DateTime.parse(topic_status_update.execute_at.to_s),\n        )\n\n        expect(json[\"duration_minutes\"]).to eq(topic_status_update.duration_minutes)\n      end\n\n      it \"should be able to delete a topic status update for delete_replies type\" do\n        Fabricate(:topic_timer, topic: topic, status_type: TopicTimer.types[:delete_replies])\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: nil, status_type: TopicTimer.types[7] }\n\n        expect(response.status).to eq(200)\n        expect(topic.reload.public_topic_timer).to eq(nil)\n\n        json = response.parsed_body\n\n        expect(json[\"execute_at\"]).to eq(nil)\n        expect(json[\"duration\"]).to eq(nil)\n        expect(json[\"closed\"]).to eq(topic.closed)\n      end\n\n      describe \"publishing topic to category in the future\" do\n        it \"should be able to create the topic status update\" do\n          post \"/t/#{topic.id}/timer.json\",\n               params: {\n                 time: 24,\n                 status_type: TopicTimer.types[3],\n                 category_id: topic.category_id,\n               }\n\n          expect(response.status).to eq(200)\n\n          topic_status_update = TopicTimer.last\n\n          expect(topic_status_update.topic).to eq(topic)\n          expect(topic_status_update.execute_at).to eq_time(24.hours.from_now)\n          expect(topic_status_update.status_type).to eq(TopicTimer.types[:publish_to_category])\n\n          json = response.parsed_body\n\n          expect(json[\"category_id\"]).to eq(topic.category_id)\n        end\n      end\n\n      describe \"invalid status type\" do\n        it \"should raise the right error\" do\n          post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"something\" }\n          expect(response.status).to eq(400)\n          expect(response.body).to include(\"status_type\")\n        end\n      end\n    end\n\n    context \"when logged in as a TL4 user\" do\n      before { SiteSetting.enable_category_group_moderation = true }\n      it \"raises an error if the user can't see the topic\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        pm_topic = Fabricate(:private_message_topic)\n\n        post \"/t/#{pm_topic.id}/timer.json\",\n             params: {\n               time: \"24\",\n               status_type: TopicTimer.types[1],\n             }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n\n      it \"allows a category moderator to create a delete timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        topic.category.update!(reviewable_by_group: user.groups.first)\n\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete\" }\n\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error setting a delete timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete\" }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n\n      it \"raises an error setting delete_replies timer\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        post \"/t/#{topic.id}/timer.json\", params: { time: 10, status_type: \"delete_replies\" }\n\n        expect(response.status).to eq(403)\n        expect(response.parsed_body[\"error_type\"]).to eq(\"invalid_access\")\n      end\n    end\n  end\n\n  describe \"#set_slow_mode\" do\n    context \"when not logged in\" do\n      it \"returns a forbidden response\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in as an admin\" do\n      it \"allows admins to set the slow mode interval\" do\n        sign_in(admin)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        topic.reload\n        expect(response.status).to eq(200)\n        expect(topic.slow_mode_seconds).to eq(3600)\n      end\n    end\n\n    context \"when logged in as a regular user\" do\n      it \"does nothing if the user is not TL4\" do\n        user.update!(trust_level: TrustLevel[3])\n        sign_in(user)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows TL4 users to set the slow mode interval\" do\n        user.update!(trust_level: TrustLevel[4])\n        sign_in(user)\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\" }\n\n        topic.reload\n        expect(response.status).to eq(200)\n        expect(topic.slow_mode_seconds).to eq(3600)\n      end\n    end\n\n    context \"with auto-disable slow mode\" do\n      before { sign_in(admin) }\n\n      let!(:timestamp) { 1.week.from_now.to_formatted_s(:iso8601) }\n\n      it \"sets a topic timer to clear the slow mode automatically\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n        execute_at = created_timer.execute_at.to_formatted_s(:iso8601)\n\n        expect(execute_at).to eq(timestamp)\n      end\n\n      it \"deletes the topic timer\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"0\", enabled_until: timestamp }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n\n        expect(created_timer).to be_nil\n      end\n\n      it \"updates the existing timer\" do\n        put \"/t/#{topic.id}/slow_mode.json\", params: { seconds: \"3600\", enabled_until: timestamp }\n\n        updated_timestamp = 1.hour.from_now.to_formatted_s(:iso8601)\n\n        put \"/t/#{topic.id}/slow_mode.json\",\n            params: {\n              seconds: \"3600\",\n              enabled_until: updated_timestamp,\n            }\n\n        created_timer = TopicTimer.find_by(topic: topic)\n        execute_at = created_timer.execute_at.to_formatted_s(:iso8601)\n\n        expect(execute_at).to eq(updated_timestamp)\n      end\n    end\n  end\n\n  describe \"#invite\" do\n    context \"when not logged in\" do\n      it \"should return the right response\" do\n        post \"/t/#{topic.id}/invite.json\", params: { email: \"jake@adventuretime.ooo\" }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"when logged in\" do\n      before { sign_in(user) }\n\n      context \"when topic id is not PM\" do\n        fab!(:user_topic) { Fabricate(:topic, user: user) }\n\n        it \"should return the right response\" do\n          user.update!(trust_level: SiteSetting.min_trust_level_to_allow_invite)\n\n          post \"/t/#{user_topic.id}/invite.json\", params: { email: \"someguy@email.com\" }\n\n          expect(response.status).to eq(422)\n        end\n      end\n\n      context \"when topic id is invalid\" do\n        it \"should return the right response\" do\n          id = topic.id\n          topic.destroy!\n          post \"/t/#{id}/invite.json\", params: { email: user.email }\n\n          expect(response.status).to eq(404)\n        end\n      end\n\n      it \"requires an email parameter\" do\n        post \"/t/#{topic.id}/invite.json\"\n        expect(response.status).to eq(422)\n      end\n\n      context \"when PM has reached maximum allowed numbers of recipients\" do\n        fab!(:pm) { Fabricate(:private_message_topic, user: user) }\n\n        fab!(:moderator_pm) { Fabricate(:private_message_topic, user: moderator) }\n\n        before do\n          SiteSetting.max_allowed_message_recipients = 2\n          Group.refresh_automatic_groups!\n        end\n\n        it \"doesn't allow normal users to invite\" do\n          post \"/t/#{pm.id}/invite.json\", params: { user: user_2.username }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body[\"errors\"]).to contain_exactly(\n            I18n.t(\n              \"pm_reached_recipients_limit\",\n              recipients_limit: SiteSetting.max_allowed_message_recipients,\n            ),\n          )\n        end\n\n        it \"allows staff to bypass limits\" do\n          sign_in(moderator)\n          post \"/t/#{moderator_pm.id}/invite.json\", params: { user: user_2.username }\n          expect(response.status).to eq(200)\n          expect(moderator_pm.reload.topic_allowed_users.count).to eq(3)\n        end\n      end\n\n      context \"when user does not have permission to invite to the topic\" do\n        fab!(:topic) { pm }\n\n        it \"should return the right response\" do\n          post \"/t/#{topic.id}/invite.json\", params: { user: user.username }\n\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe \"invite_group\" do\n    let!(:admins) { Group[:admins] }\n\n    def invite_group(topic, expected_status)\n      post \"/t/#{topic.id}/invite-group.json\", params: { group: admins.name }\n      expect(response.status).to eq(expected_status)\n    end\n\n    before { admins.update!(messageable_level: Group::ALIAS_LEVELS[:everyone]) }\n\n    context \"as an anon user\" do\n      it \"should be forbidden\" do\n        invite_group(pm, 403)\n      end\n    end\n\n    context \"as a normal user\" do\n      before { sign_in(user) }\n\n      context \"when user does not have permission to view the topic\" do\n        it \"should be forbidden\" do\n          invite_group(pm, 403)\n        end\n      end\n\n      context \"when user has permission to view the topic\" do\n        before { pm.allowed_users << user }\n\n        it \"should allow user to invite group to topic\" do\n          invite_group(pm, 200)\n          expect(pm.allowed_groups.first.id).to eq(admins.id)\n        end\n      end\n    end\n\n    context \"as an admin user\" do\n      before { sign_in(admin) }\n\n      it \"disallows inviting a group to a topic\" do\n        invite_group(topic, 422)\n      end\n\n      it \"allows inviting a group to a PM\" do\n        invite_group(pm, 200)\n        expect(pm.allowed_groups.first.id).to eq(admins.id)\n      end\n    end\n\n    context \"when PM has reached maximum allowed numbers of recipients\" do\n      fab!(:group) { Fabricate(:group, messageable_level: 99) }\n      fab!(:pm) { Fabricate(:private_message_topic, user: user) }\n\n      fab!(:moderator_pm) { Fabricate(:private_message_topic, user: moderator) }\n\n      before { SiteSetting.max_allowed_message_recipients = 2 }\n\n      it \"doesn't allow normal users to invite\" do\n        post \"/t/#{pm.id}/invite-group.json\", params: { group: group.name }\n        expect(response.status).to eq(422)\n        expect(response.parsed_body[\"errors\"]).to contain_exactly(\n          I18n.t(\n            \"pm_reached_recipients_limit\",\n            recipients_limit: SiteSetting.max_allowed_message_recipients,\n          ),\n        )\n      end\n\n      it \"allows staff to bypass limits\" do\n        sign_in(moderator)\n        post \"/t/#{moderator_pm.id}/invite-group.json\", params: { group: group.name }\n        expect(response.status).to eq(200)\n        expect(\n          moderator_pm.reload.topic_allowed_users.count + moderator_pm.topic_allowed_groups.count,\n        ).to eq(3)\n      end\n    end\n  end\n\n  describe \"shared drafts\" do\n    before { SiteSetting.shared_drafts_category = shared_drafts_category.id }\n\n    describe \"#update_shared_draft\" do\n      fab!(:other_cat) { Fabricate(:category) }\n      fab!(:topic) { Fabricate(:topic, category: shared_drafts_category, visible: false) }\n\n      context \"when anonymous\" do\n        it \"doesn't allow staff to update the shared draft\" do\n          put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n          expect(response.code.to_i).to eq(403)\n        end\n      end\n\n      context \"as a moderator\" do\n        before { sign_in(moderator) }\n\n        context \"with a shared draft\" do\n          fab!(:shared_draft) { Fabricate(:shared_draft, topic: topic, category: category) }\n          it \"allows staff to update the category id\" do\n            put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n            expect(response.status).to eq(200)\n            topic.reload\n            expect(topic.shared_draft.category_id).to eq(other_cat.id)\n          end\n        end\n\n        context \"without a shared draft\" do\n          it \"allows staff to update the category id\" do\n            put \"/t/#{topic.id}/shared-draft.json\", params: { category_id: other_cat.id }\n            expect(response.status).to eq(200)\n            topic.reload\n            expect(topic.shared_draft.category_id).to eq(other_cat.id)\n          end\n        end\n      end\n    end\n\n    describe \"#publish\" do\n      fab!(:topic) { Fabricate(:topic, category: shared_drafts_category, visible: false) }\n      fab!(:post) { Fabricate(:post, user: post_author1, topic: topic) }\n\n      it \"fails for anonymous users\" do\n        put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"fails as a regular user\" do\n        sign_in(user)\n        put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n        expect(response.status).to eq(403)\n      end\n\n      context \"as staff\" do\n        before { sign_in(moderator) }\n\n        it \"will publish the topic\" do\n          put \"/t/#{topic.id}/publish.json\", params: { destination_category_id: category.id }\n          expect(response.status).to eq(200)\n          json = response.parsed_body[\"basic_topic\"]\n\n          result = Topic.find(json[\"id\"])\n          expect(result.category_id).to eq(category.id)\n          expect(result.visible).to eq(true)\n        end\n\n        it \"fails if the destination category is the shared drafts category\" do\n          put \"/t/#{topic.id}/publish.json\",\n              params: {\n                destination_category_id: shared_drafts_category.id,\n              }\n          expect(response.status).to eq(400)\n        end\n      end\n    end\n  end\n\n  describe \"crawler\" do\n    context \"when not a crawler\" do\n      it \"renders with the application layout\" do\n        get topic.url\n\n        body = response.body\n\n        expect(body).to have_tag(:script, with: { src: \"/assets/discourse.js\" })\n        expect(body).to have_tag(:meta, with: { name: \"fragment\" })\n      end\n    end\n\n    context \"when a crawler\" do\n      it \"renders with the crawler layout, and handles proper pagination\" do\n        page1_time = 3.months.ago\n        page2_time = 2.months.ago\n        page3_time = 1.month.ago\n\n        freeze_time page1_time\n\n        Fabricate(:post, user: post_author2, topic: topic)\n        Fabricate(:post, user: post_author3, topic: topic)\n\n        freeze_time page2_time\n        Fabricate(:post, user: post_author4, topic: topic)\n        Fabricate(:post, user: post_author5, topic: topic)\n\n        freeze_time page3_time\n        Fabricate(:post, user: post_author6, topic: topic)\n\n        # ugly, but no interface to set this and we don't want to create\n        # 100 posts to test this thing\n        TopicView.stubs(:chunk_size).returns(2)\n\n        user_agent = \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n\n        get topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n\n        body = response.body\n\n        expect(body).to have_tag(:body, with: { class: \"crawler\" })\n        expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        expect(body).to include('<link rel=\"next\" href=\"' + topic.relative_url + \"?page=2\")\n\n        expect(body).to include(\"id='post_1'\")\n        expect(body).to include(\"id='post_2'\")\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page1_time.httpdate)\n\n        get topic.url + \"?page=2\", env: { \"HTTP_USER_AGENT\" => user_agent }\n        body = response.body\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page2_time.httpdate)\n\n        expect(body).to include(\"id='post_3'\")\n        expect(body).to include(\"id='post_4'\")\n\n        expect(body).to include('<link rel=\"prev\" href=\"' + topic.relative_url)\n        expect(body).to include('<link rel=\"next\" href=\"' + topic.relative_url + \"?page=3\")\n\n        get topic.url + \"?page=3\", env: { \"HTTP_USER_AGENT\" => user_agent }\n        body = response.body\n\n        expect(response.headers[\"Last-Modified\"]).to eq(page3_time.httpdate)\n        expect(body).to include('<link rel=\"prev\" href=\"' + topic.relative_url + \"?page=2\")\n      end\n\n      context \"with canonical_url\" do\n        fab!(:topic_embed) { Fabricate(:topic_embed, embed_url: \"https://markvanlan.com\") }\n        let!(:user_agent) do\n          \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n        end\n\n        it \"set to topic.url when embed_set_canonical_url is false\" do\n          get topic_embed.topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n          expect(response.body).to include('<link rel=\"canonical\" href=\"' + topic_embed.topic.url)\n        end\n\n        it \"set to topic_embed.embed_url when embed_set_canonical_url is true\" do\n          SiteSetting.embed_set_canonical_url = true\n          get topic_embed.topic.url, env: { \"HTTP_USER_AGENT\" => user_agent }\n          expect(response.body).to include('<link rel=\"canonical\" href=\"' + topic_embed.embed_url)\n        end\n      end\n\n      context \"with wayback machine\" do\n        it \"renders crawler layout\" do\n          get topic.url,\n              env: {\n                \"HTTP_USER_AGENT\" =>\n                  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\",\n                \"HTTP_VIA\" => \"HTTP/1.0 web.archive.org (Wayback Save Page)\",\n              }\n          body = response.body\n\n          expect(body).to have_tag(:body, with: { class: \"crawler\" })\n          expect(body).to_not have_tag(:meta, with: { name: \"fragment\" })\n        end\n      end\n    end\n  end\n\n  describe \"#reset_bump_date\" do\n    context \"with errors\" do\n      it \"needs you to be logged in\" do\n        put \"/t/#{topic.id}/reset-bump-date.json\"\n        expect(response.status).to eq(403)\n      end\n\n      [:user].each do |user|\n        it \"denies access for #{user}\" do\n          sign_in(Fabricate(user))\n          put \"/t/#{topic.id}/reset-bump-date.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      it \"should fail for non-existent topic\" do\n        max_id = Topic.maximum(:id)\n        sign_in(admin)\n        put \"/t/#{max_id + 1}/reset-bump-date.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    %i[admin moderator trust_level_4].each do |user|\n      it \"should reset bumped_at as #{user}\" do\n        sign_in(public_send(user))\n        topic.update!(bumped_at: 1.hour.ago)\n        timestamp = 1.day.ago\n        Fabricate(:post, user: post_author1, topic: topic, created_at: timestamp)\n\n        put \"/t/#{topic.id}/reset-bump-date.json\"\n        expect(response.status).to eq(200)\n        expect(topic.reload.bumped_at).to eq_time(timestamp)\n      end\n    end\n  end\n\n  describe \"#private_message_reset_new\" do\n    before_all { Group.refresh_automatic_groups! }\n\n    fab!(:group) do\n      Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap { |g| g.add(user_2) }\n    end\n\n    fab!(:group_message) do\n      create_post(\n        user: user,\n        target_group_names: [group.name],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    fab!(:private_message) do\n      create_post(\n        user: user,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    fab!(:private_message_2) do\n      create_post(\n        user: user,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    before { sign_in(user_2) }\n\n    it \"returns the right response when inbox param is missing\" do\n      put \"/topics/pm-reset-new.json\"\n\n      expect(response.status).to eq(400)\n    end\n\n    it \"returns the right response when trying to reset new private messages of an invalid group\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: \"randomgroup\" }\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"returns the right response when trying to reset new private messages of a restricted group\" do\n      sign_in(user)\n\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: group.name }\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"can reset all new group private messages\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"group\", group_name: group.name }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_ids\"]).to contain_exactly(group_message.id)\n\n      expect(DismissedTopicUser.count).to eq(1)\n\n      expect(DismissedTopicUser.exists?(topic: group_message, user: user_2)).to eq(true)\n    end\n\n    it \"can reset new personal private messages\" do\n      put \"/topics/pm-reset-new.json\", params: { inbox: \"user\" }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"topic_ids\"]).to contain_exactly(\n        private_message.id,\n        private_message_2.id,\n      )\n\n      expect(DismissedTopicUser.count).to eq(2)\n\n      expect(\n        DismissedTopicUser.exists?(user: user_2, topic: [private_message, private_message_2]),\n      ).to eq(true)\n    end\n\n    it \"can reset new personal and group private messages\" do\n      stub_const(TopicQuery, \"DEFAULT_PER_PAGE_COUNT\", 1) do\n        put \"/topics/pm-reset-new.json\", params: { inbox: \"all\" }\n\n        expect(response.status).to eq(200)\n\n        expect(DismissedTopicUser.count).to eq(3)\n\n        expect(\n          DismissedTopicUser.exists?(\n            user: user_2,\n            topic: [private_message, private_message_2, group_message],\n          ),\n        ).to eq(true)\n      end\n    end\n\n    it \"returns the right response is topic_ids params is not valid\" do\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: \"1\" }\n\n      expect(response.status).to eq(400)\n    end\n\n    it \"can reset new private messages from given topic ids\" do\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: [group_message.id, \"12345\"] }\n\n      expect(response.status).to eq(200)\n\n      expect(DismissedTopicUser.count).to eq(1)\n\n      expect(DismissedTopicUser.exists?(topic: group_message, user: user_2)).to eq(true)\n\n      put \"/topics/pm-reset-new.json\", params: { topic_ids: [private_message.id, \"12345\"] }\n\n      expect(response.status).to eq(200)\n\n      expect(DismissedTopicUser.exists?(topic: private_message, user: user_2)).to eq(true)\n    end\n  end\n\n  describe \"#archive_message\" do\n    before_all { Group.refresh_automatic_groups! }\n\n    fab!(:group) do\n      Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone]).tap { |g| g.add(user) }\n    end\n\n    fab!(:group_message) do\n      create_post(\n        user: user,\n        target_group_names: [group.name],\n        archetype: Archetype.private_message,\n      ).topic\n    end\n\n    it \"should be able to archive a private message\" do\n      sign_in(user)\n\n      message =\n        MessageBus\n          .track_publish(PrivateMessageTopicTrackingState.group_channel(group.id)) do\n            put \"/t/#{group_message.id}/archive-message.json\"\n\n            expect(response.status).to eq(200)\n          end\n          .first\n\n      expect(message.data[\"message_type\"]).to eq(\n        PrivateMessageTopicTrackingState::GROUP_ARCHIVE_MESSAGE_TYPE,\n      )\n\n      expect(message.data[\"payload\"][\"acting_user_id\"]).to eq(user.id)\n\n      body = response.parsed_body\n\n      expect(body[\"group_name\"]).to eq(group.name)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"ostruct\"\n\nRSpec.describe \"topics/show.html.erb\" do\n  fab!(:topic) { Fabricate(:topic) }\n\n  it \"add nofollow to RSS alternate link for topic\" do\n    topic_view = OpenStruct.new(topic: topic, posts: [])\n    topic_view.stubs(:summary).returns(\"\")\n    view.stubs(:crawler_layout?).returns(false)\n    view.stubs(:url_for).returns(\"https://www.example.com/test.rss\")\n    view.instance_variable_set(\"@topic_view\", topic_view)\n    assign(:tags, [])\n\n    render template: \"topics/show\", formats: [:html]\n\n    expect(view.content_for(:head)).to match(\n      %r{<link rel=\"alternate nofollow\" type=\"application/rss\\+xml\" title=\"[^\"]+\" href=\"https://www.example.com/test\\.rss\" />},\n    )\n  end\n\n  it \"adds sturctured data\" do\n    view.stubs(:include_crawler_content?).returns(true)\n    post = Fabricate(:post, topic: topic)\n    TopicLink.create!(\n      topic_id: post.topic_id,\n      post_id: post.id,\n      user_id: post.user_id,\n      url: \"https://example.com/\",\n      domain: \"example.com\",\n      link_topic_id: Fabricate(:topic).id,\n      reflection: true,\n    )\n    assign(:topic_view, TopicView.new(topic))\n    assign(:tags, [])\n\n    render template: \"topics/show\", formats: [:html]\n\n    links_list = Nokogiri::HTML5.fragment(rendered).css(\".crawler-linkback-list\")\n    first_item = links_list.css('[itemprop=\"itemListElement\"]')\n    expect(first_item.css('[itemprop=\"position\"]')[0][\"content\"]).to eq(\"1\")\n    expect(first_item.css('[itemprop=\"url\"]')[0][\"href\"]).to eq(\"https://example.com/\")\n  end\nend\n"], "filenames": ["app/controllers/topics_controller.rb", "app/models/tag.rb", "app/views/topics/show.html.erb", "lib/topic_view.rb", "spec/lib/topic_view_spec.rb", "spec/requests/topics_controller_spec.rb", "spec/views/topics/show.html.erb_spec.rb"], "buggy_code_start_loc": [1234, 40, 132, 247, 827, 2509, 14], "buggy_code_end_loc": [1235, 40, 133, 992, 1088, 2509, 14], "fixing_code_start_loc": [1234, 41, 132, 247, 828, 2510, 15], "fixing_code_end_loc": [1235, 42, 133, 993, 1093, 2532, 17], "type": "CWE-200", "message": "Discourse is an open source platform for community discussion. Tags that are normally private are showing in metadata. This affects any site running the `tests-passed` or `beta` branches >= 3.1.0.beta2. The issue is patched in the latest `beta` and `tests-passed` version of Discourse.", "other": {"cve": {"id": "CVE-2023-25819", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-04T01:15:10.227", "lastModified": "2023-03-09T21:11:07.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. Tags that are normally private are showing in metadata. This affects any site running the `tests-passed` or `beta` branches >= 3.1.0.beta2. The issue is patched in the latest `beta` and `tests-passed` version of Discourse."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-359"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.0", "matchCriteriaId": "D3608D4A-04A7-4EA4-B4CF-EDF6E2AB7E97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "888B8ECF-EBE0-4821-82F6-B0026E95E407"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/a9f2c6db64e7d78b8e0f55e7bd77c5fe3459b831", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-xx2h-mwm7-hq6q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/a9f2c6db64e7d78b8e0f55e7bd77c5fe3459b831"}}