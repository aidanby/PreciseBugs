{"buggy_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\nvolatile int volatile1024 = 1024;\n#include \"../vp8/util/memory.hh\"\n#include \"../vp8/util/debug.hh\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <ctime>\n#include <memory>\n#include <atomic>\n#include <signal.h>\n#ifndef _WIN32\n#include <sys/time.h>\n#include <sys/types.h>\n    #include <unistd.h>\n#else\n    #include <io.h>\n#include <chrono>\n#include <ctime>\n#endif\n#ifdef __linux__\n#include <sys/sysinfo.h>\n#include <linux/seccomp.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n\n#endif\n\n#ifndef USE_SCALAR\n#include <emmintrin.h>\n#include <immintrin.h>\n#endif\n\n#include \"jpgcoder.hh\"\n#include \"recoder.hh\"\n#include \"bitops.hh\"\n#include \"htables.hh\"\n#include \"component_info.hh\"\n#include \"uncompressed_components.hh\"\n#include \"vp8_decoder.hh\"\n#include \"vp8_encoder.hh\"\n#include \"simple_decoder.hh\"\n#include \"simple_encoder.hh\"\n#include \"fork_serve.hh\"\n#include \"socket_serve.hh\"\n#include \"validation.hh\"\n#include \"../io/ZlibCompression.hh\"\n#include \"../io/BrotliCompression.hh\"\n#include \"../io/MemReadWriter.hh\"\n#include \"../io/BufferedIO.hh\"\n#include \"../io/Zlib0.hh\"\n#include \"../io/Seccomp.hh\"\n#include \"../vp8/encoder/vpx_bool_writer.hh\"\n#include \"generic_compress.hh\"\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#endif\nunsigned char g_zlib_0_writer[sizeof(Sirikata::Zlib0Writer)];\nvoid * uninit_g_zlib_0_writer = &g_zlib_0_writer[0];\nunsigned char EOI[ 2 ] = { 0xFF, 0xD9 }; // EOI segment\nextern int r_bitcount;\nint g_argc = 0;\nconst char** g_argv = NULL;\n#ifndef GIT_REVISION\n#include \"version.hh\"\n#ifndef GIT_REVISION\n#define GIT_REVISION \"unknown\"\n#endif\n#endif\nbool g_permissive = false;\nbool fast_exit = true;\n#ifdef SKIP_VALIDATION\nbool g_skip_validation = true;\n#else\nbool g_skip_validation = false;\n#endif\n#define QUANT(cmp,bpos) ( cmpnfo[cmp].qtable[ bpos ] )\n#define MAX_V(cmp,bpos) ( ( freqmax[bpos] + QUANT(cmp,bpos) - 1 ) /  QUANT(cmp,bpos) )\n\n#define ENVLI(s,v)        ( ( v > 0 ) ? v : ( v - 1 ) + ( 1 << s ) )\n#define DEVLI(s,n)        ((s) == 0 ? (n) : ( ( (n) >= ( 1 << ((s) - 1) ) ) ? (n) : (n) + 1 - ( 1 << (s) ) ))\n#define E_ENVLI(s,v)    ( v - ( 1 << s ) )\n#define E_DEVLI(s,n)    ( n + ( 1 << s ) )\n\n#define COS_DCT(l,s,n)  ( cos( ( ( 2 * l + 1 ) * s * M_PI ) / ( 2 * n ) ) )\n#define C_DCT(n)        ( ( n == 0 ) ? ( 1 ) : ( sqrt( 2 ) ) )\n#define DCT_SCALE        sqrt( 8 )\n\n#define ABS(v1)            ( (v1 < 0) ? -v1 : v1 )\n#define ABSDIFF(v1,v2)    ( (v1 > v2) ? (v1 - v2) : (v2 - v1) )\n#define IPOS(w,v,h)        ( ( v * w ) + h )\n#define NPOS(n1,n2,p)    ( ( ( p / n1 ) * n2 ) + ( p % n1 ) )\n#define ROUND_F(v1)        ( (v1 < 0) ? (int) (v1 - 0.5) : (int) (v1 + 0.5) )\n#define B_SHORT(v1,v2)    ( ( ((int) v1) << 8 ) + ((int) v2) )\n#define CLAMPED(l,h,v)    ( ( v < l ) ? l : ( v > h ) ? h : v )\n\n#define MEM_ERRMSG    \"out of memory error\"\n#define FRD_ERRMSG    \"could not read file / file not found: %s\"\n#define FWR_ERRMSG    \"could not write file / file write-protected: %s\"\nsize_t local_atoi(const char *data);\nnamespace TimingHarness {\n\nSirikata::Array1d<Sirikata::Array1d<uint64_t, NUM_STAGES>, MAX_NUM_THREADS> timing = {{{{0}}}};\n\nuint64_t get_time_us(bool force) {\n#ifdef _WIN32\n    return std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n#else\n    if (force || !g_use_seccomp) {\n        struct timeval val = {0,0};\n        gettimeofday(&val,NULL);\n        uint64_t retval = val.tv_sec;\n        retval *= 1000000;\n        retval += val.tv_usec;\n        return retval;\n    }\n#endif\n    return 0;\n}\nconst char * stage_names[] = {FOREACH_TIMING_STAGE(GENERATE_TIMING_STRING) \"EOF\"};\nvoid print_results() {\n    if (!g_use_seccomp) {\n        uint64_t earliest_time = get_time_us();\n        for (int i = 0; i < NUM_STAGES; ++i) {\n            for (unsigned int j = 0; j < MAX_NUM_THREADS && j < NUM_THREADS; ++j) {\n                if (timing[j][i] && timing[j][i] < earliest_time) {\n                    earliest_time = timing[j][i];\n                }\n            }\n        }\n        for (int i = 0; i < NUM_STAGES; ++i) {\n            for (unsigned int j = 0; j < MAX_NUM_THREADS && j < NUM_THREADS; ++j) {\n                if (timing[j][i]) {\n                    fprintf(stderr,\n                            \"%s\\t(%d)\\t%f\\n\",\n                            stage_names[i], j,\n                            (timing[j][i] - earliest_time) * 0.000001);\n                }\n            }\n        }\n    }\n}\n}\n/* -----------------------------------------------\n    struct & enum declarations\n    ----------------------------------------------- */\nenum {\n    JPG_READ_BUFFER_SIZE = 1024 * 256,\n    ABIT_WRITER_PRELOAD = 4096 * 1024 + 1024\n};\n\nenum ACTION {\n    comp  =  1,\n    forkserve = 2,\n    socketserve = 3,\n    info = 4,\n    lepton_concatenate = 5\n};\n\n\nnamespace {\nuint32_t LEtoUint32(const uint8_t*buffer) {\n    uint32_t retval = buffer[3];\n    retval <<=8;\n    retval |= buffer[2];\n    retval <<= 8;\n    retval |= buffer[1];\n    retval <<= 8;\n    retval |= buffer[0];\n    return retval;\n}\n}\n\nvoid uint32toLE(uint32_t value, uint8_t *retval) {\n    retval[0] = uint8_t(value & 0xff);\n    retval[1] = uint8_t((value >> 8) & 0xff);\n    retval[2] = uint8_t((value >> 16) & 0xff);\n    retval[3] = uint8_t((value >> 24) & 0xff);\n}\n/* -----------------------------------------------\n    function declarations: main interface\n    ----------------------------------------------- */\n\n// returns the max size of the input file\nint initialize_options( int argc, const char*const* argv );\nvoid execute(const std::function<bool()> &);\nvoid show_help( void );\n\n\n/* -----------------------------------------------\n    function declarations: main functions\n    ----------------------------------------------- */\n\nbool check_file(int fd_in, int fd_out, uint32_t max_file_size, bool force_zlib0,\n                bool is_embedded_jpeg, Sirikata::Array1d<uint8_t, 2> two_byte_header,\n                bool is_socket);\n\ntemplate <class stream_reader>\nbool read_jpeg(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offset,\n               stream_reader *jpg_str_in,\n               Sirikata::Array1d<uint8_t, 2> header,\n               bool is_embedded_jpeg);\nbool read_jpeg_wrapper(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offset,\n                       ibytestream *jpg_str_in,\n                       Sirikata::Array1d<uint8_t, 2> header,\n                       bool is_embedded_jpeg) {\n    return read_jpeg(huff_input_offset, jpg_str_in, header, is_embedded_jpeg);\n}\n\nbool read_jpeg_and_copy_to_side_channel(std::vector<std::pair<uint32_t,\n                                                    uint32_t>> *huff_input_offset,\n                                        ibytestreamcopier *jpg_str_in,\n                                        Sirikata::Array1d<uint8_t, 2> header,\n                                        bool is_embedded_jpeg) {\n    return read_jpeg(huff_input_offset, jpg_str_in, header, is_embedded_jpeg);\n}\n\nstruct MergeJpegProgress;\nbool decode_jpeg(const std::vector<std::pair<uint32_t,\n                                   uint32_t> > &huff_input_offset,\n                 std::vector<ThreadHandoff>*row_thread_handoffs);\nbool recode_jpeg( void );\n\nbool adapt_icos( void );\nbool check_value_range( void );\nbool write_ujpg(std::vector<ThreadHandoff> row_thread_handoffs,\n                std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >*jpeg_file_raw_bytes);\nbool read_ujpg( void );\nunsigned char read_fixed_ujpg_header( void );\nbool reset_buffers( void );\n\n\n/* -----------------------------------------------\n    function declarations: jpeg-specific\n    ----------------------------------------------- */\nbool is_jpeg_header(Sirikata::Array1d<uint8_t, 2> header) {\n    return header[0] == 0xFF && header[1] == 0xD8;\n}\n\n// baseline single threaded decoding need only two rows of the image in memory\nbool setup_imginfo_jpg(bool only_allocate_two_image_rows);\nbool parse_jfif_jpg( unsigned char type, unsigned int len, uint32_t alloc_len, unsigned char* segment );\nbool rebuild_header_jpg( void );\n\nint decode_block_seq( abitreader* huffr, huffTree* dctree, huffTree* actree, short* block );\nint encode_block_seq( abitwriter* huffw, huffCodes* dctbl, huffCodes* actbl, short* block );\n\nint decode_dc_prg_fs( abitreader* huffr, huffTree* dctree, short* block );\nint encode_dc_prg_fs( abitwriter* huffw, huffCodes* dctbl, short* block );\nint decode_ac_prg_fs( abitreader* huffr, huffTree* actree, short* block,\n                        unsigned int* eobrun, int from, int to );\nint encode_ac_prg_fs( abitwriter* huffw, huffCodes* actbl, short* block,\n                        unsigned int* eobrun, int from, int to );\n\nint decode_dc_prg_sa( abitreader* huffr, short* block );\nint encode_dc_prg_sa( abitwriter* huffw, short* block );\nint decode_ac_prg_sa( abitreader* huffr, huffTree* actree, short* block,\n                        unsigned int* eobrun, int from, int to );\nint encode_ac_prg_sa( abitwriter* huffw, abytewriter* storw, huffCodes* actbl,\n                        short* block, unsigned int* eobrun, int from, int to );\n\nint decode_eobrun_sa( abitreader* huffr, short* block, unsigned int* eobrun, int from, int to );\nint encode_eobrun( abitwriter* huffw, huffCodes* actbl, unsigned int* eobrun );\nint encode_crbits( abitwriter* huffw, abytewriter* storw );\n\nint next_huffcode( abitreader *huffw, huffTree *ctree , Billing min_bill, Billing max_bill);\nint next_mcupos( int* mcu, int* cmp, int* csc, int* sub, int* dpos, int* rstw, int cs_cmpc);\nint next_mcuposn( int* cmp, int* dpos, int* rstw );\nint skip_eobrun( int* cmp, int* dpos, int* rstw, unsigned int* eobrun );\n\nbool build_huffcodes( unsigned char *clen, uint32_t clenlen,  unsigned char *cval, uint32_t cvallen,\n                huffCodes *hc, huffTree *ht );\n\n\n\n\n\n/* -----------------------------------------------\n    function declarations: developers functions\n    ----------------------------------------------- */\n\n// these are developers functions, they are not needed\n// in any way to compress jpg or decompress ujg\nbool write_hdr( void );\nbool write_huf( void );\nbool write_info( void );\nclock_t pre_byte = 0;\nclock_t post_byte = 0;\nclock_t read_done = 0;\nclock_t overall_start = 0;\n\n/* -----------------------------------------------\n    global variables: data storage\n    ----------------------------------------------- */\n\nsize_t g_decompression_memory_bound = 0;\nSirikata::Array1d<Sirikata::Array1d<unsigned short, 64>, 4> qtables; // quantization tables\nSirikata::Array1d<Sirikata::Array1d<huffCodes, 4>, 2> hcodes; // huffman codes\nSirikata::Array1d<Sirikata::Array1d<huffTree, 4>, 2> htrees; // huffman decoding trees\nSirikata::Array1d<Sirikata::Array1d<unsigned char, 4>, 2> htset;// 1 if huffman table is set\nbool embedded_jpeg = false;\nunsigned char* grbgdata            =     NULL;    // garbage data\nunsigned char* hdrdata          =   NULL;   // header data\nunsigned char* huffdata         =   NULL;   // huffman coded data\nint            hufs             =    0  ;   // size of huffman data\nuint32_t       hdrs             =    0  ;   // size of header\nuint32_t       zlib_hdrs        =    0  ;   // size of compressed header\nsize_t         total_framebuffer_allocated = 0; // framebuffer allocated\nint            grbs             =    0  ;   // size of garbage\nint            prefix_grbs = 0; // size of prefix;\nunsigned char *prefix_grbgdata = NULL; // if prefix_grb is specified, header is not prepended\n\nstd::vector<unsigned int>  rstp;   // restart markers positions in huffdata\nstd::vector<unsigned int>  scnp;   // scan start positions in huffdata\nint            rstc             =    0  ;   // count of restart markers\nint            scnc             =    0  ;   // count of scans\nint            rsti             =    0  ;   // restart interval\nint8_t         padbit           =    -1 ;   // padbit (for huffman coding)\nstd::vector<unsigned char> rst_err;   // number of wrong-set RST markers per scan\nstd::vector<unsigned int> rst_cnt;\nbool rst_cnt_set = false;\nint            max_file_size    =    0  ;   // support for truncated jpegs 0 means full jpeg\nsize_t            start_byte       =    0;     // support for producing a slice of jpeg\nsize_t         jpeg_embedding_offset = 0;\nunsigned int min_encode_threads = 1;\nsize_t max_encode_threads = \n#ifdef DEFAULT_SINGLE_THREAD\n                                         1\n#else\n                                         MAX_NUM_THREADS\n#endif\n                                         ;\nUncompressedComponents colldata; // baseline sorted DCT coefficients\n\n\n\n/* -----------------------------------------------\n    global variables: info about image\n    ----------------------------------------------- */\n\n// seperate info for each color component\nSirikata::Array1d<componentInfo, 4> cmpnfo;\n\nint cmpc        = 0; // component count\nint imgwidth    = 0; // width of image\nint imgheight   = 0; // height of image\n\nint sfhm        = 0; // max horizontal sample factor\nint sfvm        = 0; // max verical sample factor\nint mcuv        = 0; // mcus per line\nunsigned int mcuh        = 0; // mcus per collumn\nint mcuc        = 0; // count of mcus\nbool early_eof_encountered = false;\n\nint max_cmp = 0; // the maximum component in a truncated image\nint max_bpos = 0; // the maximum band in a truncated image\nint max_dpos[4] = {}; // the maximum dpos in a truncated image\nint max_sah = 0; // the maximum bit in a truncated image\n\n\nvoid standard_eof(abytewriter* hdrw, abytewriter* huffw) {\n    // get pointer for header data & size\n    hdrdata  = hdrw->getptr_aligned();\n    hdrs     = hdrw->getpos();\n    // get pointer for huffman data & size\n    huffdata = huffw->getptr_aligned();\n    hufs     = huffw->getpos();\n}\n\nvoid early_eof(abytewriter* hdrw, abytewriter* huffw) {\n    early_eof_encountered = true;\n    standard_eof(hdrw, huffw);\n}\n\n\n/* -----------------------------------------------\n    global variables: info about current scan\n    ----------------------------------------------- */\n\nint cs_cmpc      =   0  ; // component count in current scan\nSirikata::Array1d<int, 4> cs_cmp = {{ 0 }}; // component numbers  in current scan\nint cs_from      =   0  ; // begin - band of current scan ( inclusive )\nint cs_to        =   0  ; // end - band of current scan ( inclusive )\nint cs_sah       =   0  ; // successive approximation bit pos high\nint cs_sal       =   0  ; // successive approximation bit pos low\nvoid kill_workers(void * workers, uint64_t num_workers);\nBaseDecoder* g_decoder = NULL;\nGenericWorker * get_worker_threads(unsigned int num_workers) {\n    // in this case decoding is asymmetric to encoding, just forget the assert\n    if (NUM_THREADS < 2) {\n        return NULL;\n    }\n    GenericWorker* retval = GenericWorker::get_n_worker_threads(num_workers);\n    TimingHarness::timing[0][TimingHarness::TS_THREAD_STARTED] = TimingHarness::get_time_us();\n\n    return retval;\n}\n\ntemplate <class BoolDecoder>VP8ComponentDecoder<BoolDecoder> *makeBoth(bool threaded, bool start_workers) {\n    VP8ComponentDecoder<BoolDecoder> *retval = new VP8ComponentDecoder<BoolDecoder>(threaded);\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n    if (start_workers) {\n        retval->registerWorkers(get_worker_threads(\n                                    NUM_THREADS\n                                    ),\n                                NUM_THREADS\n            );\n    }\n    return retval;\n}\n\ntemplate <class BoolDecoder>BaseEncoder *makeEncoder(bool threaded, bool start_workers) {\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT_BEGIN] = TimingHarness::get_time_us();\n    VP8ComponentEncoder<BoolDecoder> * retval = new VP8ComponentEncoder<BoolDecoder>(threaded, IsDecoderAns<BoolDecoder>::IS_ANS);\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n    if (start_workers) {\n        retval->registerWorkers(get_worker_threads(NUM_THREADS - 1), NUM_THREADS - 1);\n    }\n    return retval;\n}\nBaseDecoder *makeDecoder(bool threaded, bool start_workers, bool ans) {\n    if (ans) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n        return makeBoth<ANSBoolReader>(threaded, start_workers);\n#else\n        always_assert(false && \"ANS compile flag not selected\");\n#endif\n    }\n    return makeBoth<VPXBoolReader>(threaded, start_workers);\n}\n/* -----------------------------------------------\n    global variables: info about files\n    ----------------------------------------------- */\nint    jpgfilesize;            // size of JPEG file\nint    ujgfilesize;            // size of UJG file\nint    jpegtype = 0;        // type of JPEG coding: 0->unknown, 1->sequential, 2->progressive\nF_TYPE filetype;            // type of current file\nF_TYPE ofiletype = LEPTON;            // desired type of output file\nbool g_do_preload = false;\nstd::unique_ptr<BaseEncoder> g_encoder;\n\nstd::unique_ptr<BaseDecoder> g_reference_to_free;\nServiceInfo g_socketserve_info;\nbool g_threaded = true;\n// this overrides the progressive bit in the header so that legacy progressive files may be decoded\nbool g_force_progressive = false;\nbool g_allow_progressive = \n#ifdef DEFAULT_ALLOW_PROGRESSIVE\n    true\n#else\n    false\n#endif\n    ;\nbool g_unkillable = false;\nuint64_t g_time_bound_ms = 0;\nint g_inject_syscall_test = 0;\nbool g_force_zlib0_out = false;\n\nSirikata::DecoderReader* str_in  = NULL;    // input stream\nbounded_iostream* str_out = NULL;    // output stream\n// output stream\nIOUtil::FileWriter * ujg_out = NULL;\nIOUtil::FileReader * ujg_base_in = NULL;\n\nconst char** filelist = NULL;        // list of files to process\nint    file_cnt = 0;        // count of files in list (1 for input only)\nint    file_no  = 0;        // number of current file\n/* -----------------------------------------------\n    global variables: messages\n    ----------------------------------------------- */\n\nstd::string errormessage;\nstd::atomic<int> errorlevel(0);\n// meaning of errorlevel:\n// -1 -> wrong input\n// 0 -> no error\n// 1 -> warning\n// 2 -> fatal error\n\n\n/* -----------------------------------------------\n    global variables: settings\n    ----------------------------------------------- */\n\nint  verbosity  = 0;        // level of verbosity\nbool overwrite  = false;    // overwrite files yes / no\nint  err_tresh  = 1;        // error threshold ( proceed on warnings yes (2) / no (1) )\nbool disc_meta  = false;    // discard meta-info yes / no\n\nbool developer  = false;    // allow developers functions yes/no\nACTION action   = comp;        // what to do with JPEG/UJG files\n\nFILE*  msgout   = stderr;    // stream for output of messages\nbool   pipe_on  = false;    // use stdin/stdout instead of filelist\n\n\n\nvoid sig_nop(int){}\n/* -----------------------------------------------\n    global variables: info about program\n    ----------------------------------------------- */\n\nunsigned char ujgversion   = 1;\nbool g_even_thread_split = false;\nuint8_t get_current_file_lepton_version() {\n    return ujgversion;\n}\nstatic const char*  appname      = \"lepton\";\nstatic const unsigned char   ujg_header[] = { 'U', 'J' };\nstatic const unsigned char   lepton_header[] = { 0xcf, 0x84 }; // the tau symbol for a tau lepton in utf-8\nstatic const unsigned char   zlepton_header[] = { 0xce, 0xb6 }; // the zeta symbol for a zlib compressed lepton\n\n\nFILE * timing_log = NULL;\nchar current_operation = '\\0';\n#ifdef _WIN32\nclock_t current_operation_begin = 0;\nclock_t current_operation_first_byte = 0;\nclock_t current_operation_end = 0;\n#else\nstruct timeval current_operation_begin = {0, 0};\nstruct timeval current_operation_first_byte = {0, 0};\nstruct timeval current_operation_end = {0, 0};\n#endif\n\nvoid timing_operation_start( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    current_operation = operation;\n#ifdef _WIN32\n    current_operation_begin = clock();\n    current_operation_first_byte = 0;\n    current_operation_end = 0;\n#else\n    gettimeofday(&current_operation_begin, NULL);\n    memset(&current_operation_first_byte, 0, sizeof(current_operation_first_byte));\n    memset(&current_operation_end, 0, sizeof(current_operation_end));\n#endif\n    fprintf(stderr,\"START ACHIEVED %ld %ld\\n\",\n            (long)current_operation_begin.tv_sec, (long)current_operation_begin.tv_usec );\n#endif\n}\n\nvoid timing_operation_first_byte( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    dev_assert(current_operation == operation);\n#ifdef _WIN32\n    if (current_operation_first_byte == 0) {\n        current_operation_first_byte = clock();\n    }\n#else\n    if (current_operation_first_byte.tv_sec == 0 &&\n        current_operation_first_byte.tv_usec == 0) {\n        gettimeofday(&current_operation_first_byte, NULL);\n    }\n#endif\n#endif\n}\n\nvoid timing_operation_complete( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    dev_assert(current_operation == operation);\n#ifdef _WIN32\n    current_operation_end = clock();\n    if (timing_log) {\n        double begin_to_end = (current_operation_end - current_operation_begin) / (double)CLOCKS_PER_SEC;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte != 0) { // if we were successful\n            begin_to_first_byte = (current_operation_first_byte - current_operation_begin) / (double)CLOCKS_PER_SEC;\n        }\n        fprintf(timing_log, \"%c %f %f\\n\", current_operation, begin_to_first_byte, begin_to_end);\n        fflush(timing_log);\n    }\n    current_operation_end = 0;\n    current_operation_begin = 0;\n    current_operation_first_byte = 0;\n#else\n    gettimeofday(&current_operation_end, NULL);\n    if (timing_log) {\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = current_operation_end.tv_sec + (double)current_operation_end.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n        fprintf(timing_log, \"%c %f %f\\n\", current_operation, begin_to_first_byte, begin_to_end);\n        fflush(timing_log);\n    }\n    memset(&current_operation_end, 0, sizeof(current_operation_end));\n    memset(&current_operation_begin, 0, sizeof(current_operation_begin));\n    memset(&current_operation_first_byte, 0, sizeof(current_operation_first_byte));\n#endif\n#endif\n}\n\nsize_t local_atoi(const char *data) {\n    const char * odata = data;\n    size_t retval = 0;\n    int counter = 0;\n    while (*data) {\n        if (*data >= '0' && *data <='9') {\n            retval *= 10;\n            retval += *data - '0';\n            ++data;\n            ++counter;\n            if (counter > 16) {\n                fprintf(stderr, \"Could not allocate so much memory %s\\n\", odata);\n                exit(1);\n            }\n        } else if ('M' == *data) {\n            retval *= 1024 * 1024;\n            break;\n        } else if ('K' == *data) {\n            retval *= 1024;\n            break;\n        } else {\n            fprintf(stderr, \"Could not allocate alphanumeric memory %s\\n\", odata);\n            exit(1);\n        }\n    }\n    return retval;\n}\nbool starts_with(const char * a, const char * b) {\n    while (*b) {\n        if (*a != *b) {\n            return false;\n        }\n        ++a;\n        ++b;\n    }\n    return true;\n}\nvoid compute_thread_mem(const char * arg,\n                        size_t * mem_init,\n                        size_t * thread_mem_init,\n                        bool *needs_huge_pages,\n                        bool *avx2upgrade) {\n    if (strcmp(arg, \"-hugepages\") == 0) {\n        *needs_huge_pages = true;\n    }\n    if ( strcmp(arg, \"-avx2upgrade\") == 0) {\n        *avx2upgrade = true;\n    }\n    if (strstr(arg, \"-help\")) {\n        show_help();\n        exit(0);\n    }\n    if (strcmp(arg, \"-h\") == 0) {\n        show_help();\n        exit(0);\n    }\n    const char mem_arg_name[]=\"-memory=\";\n    const char thread_mem_arg_name[]=\"-threadmemory=\";\n    if (starts_with(arg, mem_arg_name)) {\n        arg += strlen(mem_arg_name);\n        *mem_init = local_atoi(arg);\n    }\n    if (starts_with(arg, thread_mem_arg_name)) {\n        arg += strlen(thread_mem_arg_name);\n        *thread_mem_init = local_atoi(arg);\n    }\n}\n/* -----------------------------------------------\n    main-function\n    ----------------------------------------------- */\n\n#ifdef EMSCRIPTEN\nconst char *fake_argv[] =  {\n    \"lepton-scalar\",\n    \"-skipverify\",\n    \"-singlethread\",\n    \"-\",\n};\n\nconst int fake_argc = sizeof(fake_argv) / sizeof(char *);\nint EMSCRIPTEN_KEEPALIVE main(void) {\n    const int argc = fake_argc;\n    const char **argv = fake_argv;\n    g_argc = argc;\n    g_argv = argv;\n    TimingHarness::timing[0][TimingHarness::TS_MAIN]\n        = TimingHarness::get_time_us(true);\n    size_t thread_mem_limit = 128 * 1024 * 1024;\n    size_t mem_limit = 1280 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1);\n    bool needs_huge_pages = false;\n    for (int i = 1; i < argc; ++i) {\n        bool avx2upgrade = false;\n        compute_thread_mem(argv[i],\n                           &mem_limit,\n                           &thread_mem_limit,\n                           &needs_huge_pages,\n                           &avx2upgrade);\n    }\n\n    // the system needs 33 megs of ram ontop of the uncompressed image buffer.\n    // This adds a few extra megs just to keep things real\n    UncompressedComponents::max_number_of_blocks = ( mem_limit / 4 ) * 3;\n    if (mem_limit > 48 * 1024 * 1024) {\n        UncompressedComponents::max_number_of_blocks = mem_limit - 36 * 1024 * 1024;\n    }\n    UncompressedComponents::max_number_of_blocks /= (sizeof(uint16_t) * 64);\n    int n_threads = MAX_NUM_THREADS - 1;\n    clock_t begin = 0, end = 1;\n\n    int error_cnt = 0;\n    int warn_cnt  = 0;\n\n    int acc_jpgsize = 0;\n    int acc_ujgsize = 0;\n\n    int speed, bpms;\n    float cr;\n\n    errorlevel.store(0);\n\n    // read options from command line\n    int max_file_size = initialize_options( argc, argv );\n    if (action != forkserve && action != socketserve) {\n        // write program info to screen\n        fprintf( msgout,  \"%s v%i.0-%s\\n\",\n                 appname, ujgversion, GIT_REVISION );\n    }\n    // check if user input is wrong, show help screen if it is\n    if ((file_cnt == 0 && action != forkserve && action != socketserve)\n        || ((!developer) && ((action != comp && action != forkserve && action != socketserve)))) {\n        show_help();\n        return -1;\n    }\n\n\n    // (re)set program has to be done first\n    reset_buffers();\n\n    // process file(s) - this is the main function routine\n    begin = clock();\n    if (file_cnt > 2) {\n        show_help();\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    process_file(nullptr, nullptr, max_file_size, g_force_zlib0_out);\n    if (errorlevel.load() >= err_tresh) error_cnt++;\n    if (errorlevel.load() == 1 ) warn_cnt++;\n    if ( errorlevel.load() < err_tresh ) {\n        acc_jpgsize += jpgfilesize;\n        acc_ujgsize += ujgfilesize;\n    }\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    if (action != socketserve && action != forkserve) {\n        // show statistics\n        fprintf(msgout,  \"\\n\\n-> %i file(s) processed, %i error(s), %i warning(s)\\n\",\n                file_cnt, error_cnt, warn_cnt);\n    }\n    if ( ( file_cnt > error_cnt ) && ( verbosity > 0 ) )\n    if ( action == comp ) {\n        speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n        bpms  = ( speed > 0 ) ? ( acc_jpgsize / speed ) : acc_jpgsize;\n        cr    = ( acc_jpgsize > 0 ) ? ( 100.0 * acc_ujgsize / acc_jpgsize ) : 0;\n\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n        fprintf( msgout,  \" time taken        : %8i msec\\n\", speed );\n        fprintf( msgout,  \" avrg. byte per ms : %8i byte\\n\", bpms );\n        fprintf( msgout,  \" avrg. comp. ratio : %8.2f %%\\n\", cr );\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n    }\n    return error_cnt == 0 ? 0 : 1;\n}\n#else\nint app_main( int argc, char** argv )\n{\n    g_argc = argc;\n    g_argv = (const char **)argv;\n    TimingHarness::timing[0][TimingHarness::TS_MAIN]\n        = TimingHarness::get_time_us(true);\n    size_t thread_mem_limit = \n#ifdef HIGH_MEMORY\n        64 * 1024 * 1024\n#else\n        3 * 1024 * 1024\n#endif\n        ;//8192;\n    size_t mem_limit = \n#ifdef HIGH_MEMORY\n        1024 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1)\n#else\n        176 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1)\n#endif\n        ;\n    bool needs_huge_pages = false;\n    for (int i = 1; i < argc; ++i) {\n        bool avx2upgrade = false;\n        compute_thread_mem(argv[i],\n                           &mem_limit,\n                           &thread_mem_limit,\n                           &needs_huge_pages,\n                           &avx2upgrade);\n#ifndef __AVX2__\n#ifndef __clang__\n#ifndef _ARCH_PPC        \n#ifndef _WIN32\n        if (avx2upgrade &&\n            __builtin_cpu_supports(\"avx2\")\n) {\n            for (int j = i + 1; j < argc; ++j) {\n                argv[j - 1] = argv[j];\n            }\n            --argc;\n            argv[argc] = NULL; // since we have eliminated the upgrade arg...\n            size_t command_len = strlen(argv[0]);\n            size_t postfix_len = strlen(\"-avx\") + 1;\n            char * command = (char*)malloc(postfix_len + command_len);\n            memcpy(command, argv[0], command_len);\n            memcpy(command + command_len, \"-avx\", postfix_len);\n            char * old_command = argv[0];\n            argv[0] = command;\n            execvp(command, argv);\n            argv[0] = old_command; // exec failed\n        }\n#endif\n#endif\n#endif\n#endif\n    }\n\n    // the system needs 33 megs of ram ontop of the uncompressed image buffer.\n    // This adds a few extra megs just to keep things real\n    UncompressedComponents::max_number_of_blocks = ( mem_limit / 4 ) * 3;\n    if (mem_limit > 48 * 1024 * 1024) {\n        UncompressedComponents::max_number_of_blocks = mem_limit - 36 * 1024 * 1024;\n    }\n    UncompressedComponents::max_number_of_blocks /= (sizeof(uint16_t) * 64);\n    int n_threads = MAX_NUM_THREADS;\n#ifndef __linux__\n    n_threads += 4;\n#endif\n#if !defined(_WIN32) && !defined(EMSCRIPTEN)\n    Sirikata::memmgr_init(mem_limit,\n                          thread_mem_limit,\n                          n_threads,\n                          256,\n                          needs_huge_pages);\n#endif\n    clock_t begin = 0, end = 1;\n\n    int error_cnt = 0;\n    int warn_cnt  = 0;\n\n    int acc_jpgsize = 0;\n    int acc_ujgsize = 0;\n\n    int speed, bpms;\n    float cr;\n\n    errorlevel.store(0);\n\n    // read options from command line\n    int max_file_size = initialize_options( argc, argv );\n    if (action != forkserve && action != socketserve) {\n        // write program info to screen\n        fprintf( msgout,  \"%s v%i.0-%s\\n\",\n                 appname, ujgversion, GIT_REVISION );\n    }\n    // check if user input is wrong, show help screen if it is\n    if ((file_cnt == 0 && action != forkserve && action != socketserve)\n        || ((!developer) && ((action != lepton_concatenate && action != comp && action != forkserve && action != socketserve)))) {\n        show_help();\n        return -1;\n    }\n\n\n    // (re)set program has to be done first\n    reset_buffers();\n\n    // process file(s) - this is the main function routine\n    begin = clock();\n    if (file_cnt > 2 && action != lepton_concatenate) {\n        show_help();\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    if (action == forkserve) {\n#ifdef _WIN32\n        abort(); // not implemented\n#else\n        fork_serve();\n#endif\n    } else if (action == socketserve) {\n#ifdef _WIN32\n        abort(); // not implemented\n#else\n        socket_serve(&process_file, max_file_size, g_socketserve_info);\n#endif\n    } else {\n        process_file(nullptr, nullptr, max_file_size, g_force_zlib0_out);\n    }\n    if (errorlevel.load() >= err_tresh) error_cnt++;\n    if (errorlevel.load() == 1 ) warn_cnt++;\n    if ( errorlevel.load() < err_tresh ) {\n        acc_jpgsize += jpgfilesize;\n        acc_ujgsize += ujgfilesize;\n    }\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    if (action != socketserve && action != forkserve) {\n        // show statistics\n        fprintf(msgout,  \"\\n\\n-> %i file(s) processed, %i error(s), %i warning(s)\\n\",\n                file_cnt, error_cnt, warn_cnt);\n    }\n    if ( ( file_cnt > error_cnt ) && ( verbosity > 0 ) )\n    if ( action == comp ) {\n        speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n        bpms  = ( speed > 0 ) ? ( acc_jpgsize / speed ) : acc_jpgsize;\n        cr    = ( acc_jpgsize > 0 ) ? ( 100.0 * acc_ujgsize / acc_jpgsize ) : 0;\n\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n        fprintf( msgout,  \" time taken        : %8i msec\\n\", speed );\n        fprintf( msgout,  \" avrg. byte per ms : %8i byte\\n\", bpms );\n        fprintf( msgout,  \" avrg. comp. ratio : %8.2f %%\\n\", cr );\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n    }\n\n\n    return error_cnt == 0 ? 0 : 1;\n}\n#endif\n\n/* ----------------------- Begin of main interface functions -------------------------- */\n\n/* -----------------------------------------------\n    reads in commandline arguments\n    ----------------------------------------------- */\nchar g_dash[] = \"-\";\n// returns the maximum file size\nint initialize_options( int argc, const char*const * argv )\n{\n    const char** tmp_flp;\n    int tmp_val;\n    int max_file_size = 0;\n    // get memory for filelist & preset with NULL\n    filelist = (const char**)custom_calloc(argc * sizeof(char*));\n\n    // preset temporary filelist pointer\n    tmp_flp = filelist;\n    // read in arguments\n    while ( --argc > 0 ) {\n        argv++;\n        // switches begin with '-'\n        if ( sscanf( (*argv), \"-v%i\", &tmp_val ) == 1 ){\n            verbosity = tmp_val;\n            verbosity = ( verbosity < 0 ) ? 0 : verbosity;\n            verbosity = ( verbosity > 2 ) ? 2 : verbosity;\n        }\n        else if ( strcmp((*argv), \"-o\" ) == 0 ) {\n            overwrite = true;\n        }\n        else if (strcmp((*argv), \"-revision\" ) == 0 || strcmp((*argv), \"--revision\") == 0) {\n            printf(\"%s\\n\", GIT_REVISION);\n            exit(0);\n        }\n        else if (strcmp((*argv), \"-version\" ) == 0 || strcmp((*argv), \"--version\") == 0) {\n            printf(\"%02x\\n\", ujgversion);\n            exit(0);\n        } else if ( strcmp((*argv), \"-preload\" ) == 0 ) {\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-decode\" ) == 0 ) { // deprecated commands to preload it all\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-recode\" ) == 0 ) {\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-p\" ) == 0 ) {\n            err_tresh = 2;\n        }\n        else if ( strncmp((*argv), \"-timebound=\", strlen(\"-timebound=\")) == 0) {\n            char * endptr = NULL;\n            g_time_bound_ms = strtoll((*argv) + strlen(\"-timebound=\"), &endptr, 10);\n            if (endptr) {\n                if (strcmp(endptr, \"s\") == 0) {\n                    g_time_bound_ms *= 1000;\n                } else if (strcmp(endptr, \"us\") == 0) {\n                    g_time_bound_ms /= 1000;\n                } else if (strcmp(endptr, \"ms\") != 0) {\n                    fprintf(stderr, \"Time must have units (ms or s)\\n\");\n                    exit(1);\n                }\n            }\n        }\n        else if ( strcmp((*argv), \"-zlib0\" ) == 0)  {\n            g_force_zlib0_out = true;\n        }\n        else if ( strcmp((*argv), \"-unkillable\" ) == 0)  {\n            g_unkillable = true;\n        }\n        else if ( strcmp((*argv), \"-singlethread\" ) == 0)  {\n            g_threaded = false;\n        }\n        else if ( strcmp((*argv), \"-allowprogressive\" ) == 0)  {\n            g_allow_progressive = true;\n        }\n        else if ( strcmp((*argv), \"-forceprogressive\" ) == 0)  {\n            g_allow_progressive = true;\n            g_force_progressive = true;\n        }\n        else if ( strcmp((*argv), \"-rejectprogressive\" ) == 0)  {\n            g_allow_progressive = false;\n        }\n        else if ( strcmp((*argv), \"-unjailed\" ) == 0)  {\n            g_use_seccomp = false;\n        } else if ( strcmp((*argv), \"-multithread\" ) == 0 || strcmp((*argv), \"-m\") == 0)  {\n            g_threaded = true;\n        } else if ( strcmp((*argv), \"-evensplit\" ) == 0)  {\n            g_even_thread_split = true;\n        } else if ( strstr((*argv), \"-recodememory=\") == *argv ) {\n            g_decompression_memory_bound\n                = local_atoi(*argv + strlen(\"-recodememory=\"));\n        } else if ( strstr((*argv), \"-memory=\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-hugepages\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-defermd5\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-avx2upgrade\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-threadmemory=\") == *argv ) {\n\n        } else if ( strncmp((*argv), \"-timing=\", strlen(\"-timing=\") ) == 0 ) {\n            timing_log = fopen((*argv) + strlen(\"-timing=\"), \"a\");\n        } else if (strncmp((*argv), \"-maxencodethreads=\", strlen(\"-maxencodethreads=\") ) == 0 ) {\n            max_encode_threads = local_atoi((*argv) + strlen(\"-maxencodethreads=\"));\n            if (max_encode_threads > MAX_NUM_THREADS) {\n                custom_exit(ExitCode::VERSION_UNSUPPORTED);\n            }\n        } else if (strcmp((*argv), \"-lepcat\") == 0) {\n            action = lepton_concatenate;\n        } else if (strncmp((*argv), \"-minencodethreads=\", strlen(\"-minencodethreads=\") ) == 0 ) {\n            min_encode_threads = local_atoi((*argv) + strlen(\"-minencodethreads=\"));\n        } else if ( strncmp((*argv), \"-injectsyscall=\", strlen(\"-injectsyscall=\") ) == 0 ) {\n            g_inject_syscall_test = strtol((*argv) + strlen(\"-injectsyscall=\"), NULL, 10);\n        } else if ( strcmp((*argv), \"-skipvalidation\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipvalidate\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipverify\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipverification\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skiproundtrip\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-validate\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-validation\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-verify\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-verification\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-roundtrip\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-permissive\") == 0 ) {\n            g_permissive = true;\n#ifndef _WIN32\n            signal(SIGPIPE, SIG_IGN);\n#endif\n        } else if ( strcmp((*argv), \"-brotliheader\") == 0 ) {\n            if (ujgversion < 2) {\n                ujgversion = 2; // use brotli to compress the header and trailer rather than zlib\n            }\n        } else if ( strcmp((*argv), \"-ans\") == 0 ) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n            ujgversion = 3; // use brotli to compress the header and trailer rather than zlib and ANS encoder/decoder\n#else\n            always_assert(false && \"ANS selected via command line but not enabled in build flags\");\n#endif          \n        } else if ( strncmp((*argv), \"-maxchildren=\", strlen(\"-maxchildren=\") ) == 0 ) {\n            g_socketserve_info.max_children = strtol((*argv) + strlen(\"-maxchildren=\"), NULL, 10);\n        }\n        else if ( strncmp((*argv), \"-listenbacklog=\", strlen(\"-listenbacklog=\") ) == 0 ) {\n            g_socketserve_info.listen_backlog = strtol((*argv) + strlen(\"-listenbacklog=\"), NULL, 10);\n        }\n        else if ( strncmp((*argv), \"-startbyte=\", strlen(\"-startbyte=\") ) == 0 ) {\n            start_byte = local_atoi((*argv) + strlen(\"-startbyte=\"));\n        }        \n        else if ( strncmp((*argv), \"-embedding=\", strlen(\"-embedding=\") ) == 0 ) {\n            jpeg_embedding_offset = local_atoi((*argv) + strlen(\"-embedding=\"));\n            embedded_jpeg = true;\n        }\n        else if ( strncmp((*argv), \"-trunc=\", strlen(\"-trunc=\") ) == 0 ) {\n            max_file_size = local_atoi((*argv) + strlen(\"-trunc=\"));\n        }\n        else if ( strncmp((*argv), \"-trunctiming=\", strlen(\"-trunctiming=\") ) == 0 ) {\n            timing_log = fopen((*argv) + strlen(\"-trunctiming=\"), \"w\");\n        }\n        else if ( strcmp((*argv), \"-d\" ) == 0 ) {\n            disc_meta = true;\n        }\n        else if ( strcmp((*argv), \"-dev\") == 0 ) {\n            developer = true;\n        } else if ( ( strcmp((*argv), \"-ujg\") == 0 ) ||\n                    ( strcmp((*argv), \"-ujpg\") == 0 )) {\n            fprintf(stderr, \"FOUND UJG ARG: using that as output\\n\");\n            action = comp;\n            ofiletype = UJG;\n#ifndef _WIN32\n        } else if ( strcmp((*argv), \"-fork\") == 0 ) {    \n            action = forkserve;\n            // sets it up in serving mode\n            msgout = stderr;\n            // use \"-\" as placeholder for the socket\n            *(tmp_flp++) = g_dash;\n        } else if ( strncmp((*argv), \"-socket\", strlen(\"-socket\")) == 0 ) {\n            if (action != socketserve) {\n                action = socketserve;\n                // sets it up in serving mode\n                msgout = stderr;\n                // use \"-\" as placeholder for the socket\n                *(tmp_flp++) = g_dash;\n            }\n            if ((*argv)[strlen(\"-socket\")] == '=') {\n                g_socketserve_info.uds = (*argv) + strlen(\"-socket=\");\n            }\n        } else if ( strncmp((*argv), \"-listen\", strlen(\"-listen\")) == 0 ) {\n            g_socketserve_info.listen_tcp = true;\n            if (action != socketserve) {\n                action = socketserve;\n                // sets it up in serving mode\n                msgout = stderr;\n                // use \"-\" as placeholder for the socket\n                *(tmp_flp++) = g_dash;\n            }\n            if ((*argv)[strlen(\"-listen\")] == '=') {\n                g_socketserve_info.port = atoi((*argv) + strlen(\"-listen=\"));\n            }\n        } else if ( strncmp((*argv), \"-zliblisten\", strlen(\"-zliblisten\")) == 0 ) {\n            g_socketserve_info.zlib_port = atoi((*argv) + strlen(\"-zliblisten=\"));\n#endif\n        } else if ( strcmp((*argv), \"-\") == 0 ) {    \n            msgout = stderr;\n            // set binary mode for stdin & stdout\n            #ifdef _WIN32\n                setmode( fileno( stdin ), O_BINARY );\n                setmode( fileno( stdout ), O_BINARY );\n            #endif\n            // use \"-\" as placeholder for stdin\n            *(tmp_flp++) = g_dash;\n        }\n        else {\n            // if argument is not switch, it's a filename\n            *(tmp_flp++) = *argv;\n        }\n    }\n    for ( file_cnt = 0; filelist[ file_cnt ] != NULL; file_cnt++ ) {\n    }\n    if (start_byte != 0) {\n        // Encode of partial progressive images not allowed\n        g_allow_progressive = false;\n    }\n    if (g_time_bound_ms && action == forkserve) {\n        fprintf(stderr, \"Time bound action only supported with UNIX domain sockets\\n\");\n        exit(1);\n    }\n    if (g_do_preload && g_skip_validation) {\n        VP8ComponentDecoder<VPXBoolReader> *d = makeBoth<VPXBoolReader>(g_threaded, g_threaded && action != forkserve && action != socketserve);\n        g_encoder.reset(d);\n        g_decoder = d;\n    }\n    return max_file_size;\n}\nsize_t decompression_memory_bound() {\n    if (ofiletype == UJG || filetype == UJG) {\n        return 0;\n    }\n    size_t cumulative_buffer_size = 0;\n    size_t streaming_buffer_size = 0;\n    size_t current_run_size = 0;\n    for (int i = 0; i < colldata.get_num_components(); ++i) {\n        size_t streaming_size = \n            colldata.block_width(i)\n            * 2 * NUM_THREADS * 64 * sizeof(uint16_t);\n        size_t frame_buffer_size = colldata.component_size_allocated(i);\n        if (cs_cmpc != colldata.get_num_components() || jpegtype != 1) {\n            streaming_size = frame_buffer_size;\n        } else if (filetype != JPEG) {\n            if (!g_threaded) {\n                frame_buffer_size = colldata.block_width(i) * 2 * 64 * sizeof(uint16_t);\n\n            } else {\n                frame_buffer_size = streaming_size;\n            }\n        }\n        cumulative_buffer_size += frame_buffer_size;\n        streaming_buffer_size += streaming_size;\n    }\n    current_run_size = cumulative_buffer_size;\n\n    size_t bit_writer_augmentation = 0;\n    if (g_allow_progressive) {\n        for (size_t cur_size = jpgfilesize - 1; cur_size; cur_size >>=1) {\n            bit_writer_augmentation |= cur_size;\n        }\n        bit_writer_augmentation += 1; // this is used to compute the buffer size of the abit_writer for writing\n    }\n    size_t garbage_augmentation = 0;\n    for (size_t cur_size = hdrs - 1; cur_size; cur_size >>=1) {\n        garbage_augmentation |= cur_size;\n    }\n    garbage_augmentation += 1; // this is used to compute the buffer size of the abit_writer for writing\n    int non_preloaded_mux = 4096 * 1024 + 131072; // only 1 thread hence only one extra 131072\n    size_t decode_header_needed_size = hdrs + zlib_hdrs * 3;\n    if (zlib_hdrs && zlib_hdrs * 2 < hdrs) {\n        size_t doubled = zlib_hdrs * 2;\n        do {\n            decode_header_needed_size += doubled;\n            doubled *= 2;\n        } while (doubled < (size_t)hdrs);\n    }\n    size_t single_threaded_model_bonus = 0;\n    size_t single_threaded_buffer_bonus = 0; //the threads have to save their output to 3/4 of the jpeg before writing it\n    if (g_decoder) {\n        single_threaded_model_bonus += g_decoder->get_model_worker_memory_usage();\n    } else if (g_encoder) {\n        single_threaded_model_bonus += g_encoder->get_decode_model_worker_memory_usage();\n    }\n    if (filetype != JPEG && !g_threaded) {\n        single_threaded_buffer_bonus += jpgfilesize;\n    }\n    size_t abit_writer = 0;\n    if (g_allow_progressive) {\n\n        if (zlib_hdrs * 3 < ABIT_WRITER_PRELOAD * 2 + 64) {\n            if (zlib_hdrs * 3 < ABIT_WRITER_PRELOAD + 64) {\n                abit_writer += ABIT_WRITER_PRELOAD * 2 + 64;// these can't be reused memory\n            } else {\n                abit_writer += ABIT_WRITER_PRELOAD + 64;// these can't be reused\n            }\n        }\n    } else {\n        abit_writer += 65536 + 64;\n    }\n    if (g_allow_progressive &&\n        jpgfilesize > ABIT_WRITER_PRELOAD) {\n        // we currently buffer the whole jpeg in memory while streaming out\n        abit_writer += 3 * jpgfilesize;\n    }\n    size_t total = Sirikata::memmgr_size_allocated();\n    ptrdiff_t decom_memory_bound = total;\n    decom_memory_bound -= current_run_size;\n    decom_memory_bound += streaming_buffer_size;\n    decom_memory_bound -= single_threaded_model_bonus;\n    decom_memory_bound += single_threaded_buffer_bonus;\n    if (decom_memory_bound < 1){\n        decom_memory_bound = 1;\n    }\n    if (filetype == JPEG) {\n        decom_memory_bound = streaming_buffer_size\n            + abit_writer + jpgfilesize + sizeof(ProbabilityTablesBase)\n            + garbage_augmentation + decode_header_needed_size + non_preloaded_mux;\n    }\n    return decom_memory_bound;\n}\n\nvoid check_decompression_memory_bound_ok() {\n    if (g_decompression_memory_bound) {\n        size_t adjustment = 0;\n        if (!uninit_g_zlib_0_writer) {\n            adjustment = 8192; // add an extra 8kb if we're decoding zlib\n        }\n        if (decompression_memory_bound() > g_decompression_memory_bound + adjustment) {\n            custom_exit(ExitCode::TOO_MUCH_MEMORY_NEEDED);\n        }\n    }\n}\nvoid test_syscall_injection(std::atomic<int>*value) {\n#ifndef _WIN32\n    char buf[128 + 1];\n    buf[sizeof(buf) - 1] = 0;\n    value->store(-1);\n    char * ret = getcwd(buf, sizeof(buf) - 1);\n    value->store(ret ? 1 : 2);\n#endif\n}\nbool recode_baseline_jpeg_wrapper() {\n    bool retval = recode_baseline_jpeg(str_out, max_file_size);\n    if (!retval) {\n        errorlevel.store(2);\n        return retval;\n    }\n    // get filesize\n    jpgfilesize = str_out->getsize();\n    if (ujg_base_in) {\n        ujgfilesize = ujg_base_in->getsize();\n    } else {\n        ujgfilesize = 4096 * 1024;\n    }\n#ifndef _WIN32\n    if (!g_use_seccomp) {\n        clock_t final = clock();\n        struct timeval fin = {0,0};\n        gettimeofday(&fin,NULL);\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = fin.tv_sec + (double)fin.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n\n        fprintf(stderr, \"TIMING (new method): %f to first byte %f total\\n\",\n                begin_to_first_byte,\n                begin_to_end);\n        (void)final;\n        fprintf(stderr, \"Read took: %f\\n\",\n                (read_done - overall_start)/(double)CLOCKS_PER_SEC);\n    }\n#endif\n    // store last scan & restart positions\n    if ( !rstp.empty() )\n        rstp.at(rstc) = hufs;\n\n\n    return retval;\n}\n\n\n\n\n\nint open_fdin(const char *ifilename,\n              IOUtil::FileReader *reader,\n              Sirikata::Array1d<uint8_t, 2> &header,\n              ssize_t *bytes_read,\n              bool *is_socket) {\n    int fdin = -1;    \n    if (reader != NULL) {\n        *is_socket = reader->is_socket();\n        fdin = reader->get_fd();\n    }\n    else if (strcmp(ifilename, \"-\") == 0) {\n        fdin = 0;\n        *is_socket = false;\n    }\n    else {\n        *is_socket = false;\n         do {\n            fdin = open(ifilename, O_RDONLY\n#ifdef _WIN32\n                |O_BINARY\n#endif\n            );\n        } while (fdin == -1 && errno == EINTR);\n        if (fdin == -1) {\n            const char * errormessage = \"Input file unable to be opened for writing:\";\n            while(write(2, errormessage, strlen(errormessage)) == -1 && errno == EINTR) {}\n            while(write(2, ifilename, strlen(ifilename)) == -1 && errno == EINTR) {}\n            while(write(2, \"\\n\", 1) == -1 && errno == EINTR) {}\n        }\n    }\n    *bytes_read = 0;\n    ssize_t data_read = 0;\n    do {\n        data_read = read(fdin, &header[0], 2);\n    } while (data_read == -1 && errno == EINTR);\n    if (data_read >= 0) {\n        *bytes_read = data_read;\n    }\n    if (__builtin_expect(data_read < 2, false)) {\n        do {\n            data_read = read(fdin, &header[1], 1);\n        } while (data_read == -1 && errno == EINTR);\n        if (data_read >= 0) {\n            *bytes_read += data_read;\n        }\n    }\n    if (data_read < 0) {\n        perror(\"read\");\n        const char * fail = \"Failed to read 2 byte header\\n\";\n        while(write(2, fail, strlen(fail)) == -1 && errno == EINTR) {}        \n    }\n    return fdin;\n}\n\nstd::string uniq_filename(std::string filename) {\n    FILE * fp = fopen(filename.c_str(), \"rb\");\n    while (fp != NULL) {\n        fclose(fp);\n        filename += \"_\";\n        fp = fopen(filename.c_str(), \"rb\");\n    }\n    return filename;\n}\n\nstd::string postfix_uniq(const std::string &filename, const char * ext) {\n    std::string::size_type where =filename.find_last_of(\"./\\\\\");\n    if (where == std::string::npos || filename[where] != '.') {\n        return uniq_filename(filename + ext);\n    }\n    return uniq_filename(filename.substr(0, where) + ext);\n}\n\n\nint open_fdout(const char *ifilename,\n                    IOUtil::FileWriter *writer,\n               bool is_embedded_jpeg,\n                    Sirikata::Array1d<uint8_t, 2> fileid,\n                    bool force_compressed_output,\n                    bool *is_socket) {\n    if (writer != NULL) {\n        *is_socket = writer->is_socket();\n        return writer->get_fd();\n    }\n    *is_socket = false;\n    if (strcmp(ifilename, \"-\") == 0) {\n        return 1;\n    }\n    int retval = -1;\n    std::string ofilename;\n    // check file id, determine filetype\n    if (file_no + 1 < file_cnt && ofilename != ifilename) {\n        ofilename = filelist[file_no + 1];\n    } else if (is_jpeg_header(fileid) || is_embedded_jpeg || g_permissive) {\n        ofilename = postfix_uniq(ifilename, (ofiletype == UJG ? \".ujg\" : \".lep\"));\n    } else if ( ( ( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) )\n                || ( ( fileid[0] == lepton_header[0] ) && ( fileid[1] == lepton_header[1] ) )\n                || ( ( fileid[0] == zlepton_header[0] ) && ( fileid[1] == zlepton_header[1] ) ) ){\n        if ((fileid[0] == zlepton_header[0] && fileid[1] == zlepton_header[1])\n            || force_compressed_output) {\n            ofilename = postfix_uniq(ifilename, \".jpg.z\");\n        } else {\n            ofilename = postfix_uniq(ifilename, \".jpg\");\n        }\n    }\n    do {\n        retval = open(ofilename.c_str(), O_WRONLY|O_CREAT|O_TRUNC\n#ifdef _WIN32\n            | O_BINARY\n#endif\n            , 0\n#ifdef _WIN32\n            | S_IREAD| S_IWRITE\n#else\n            | S_IWUSR | S_IRUSR\n#endif\n        );\n    }while (retval == -1 && errno == EINTR);\n    if (retval == -1) {\n        const char * errormessage = \"Output file unable to be opened for writing:\";\n        while(write(2, errormessage, strlen(errormessage)) == -1 && errno == EINTR) {}\n        while(write(2, ofilename.c_str(), ofilename.length()) == -1 && errno == EINTR) {}\n        while(write(2, \"\\n\", 1) == -1 && errno == EINTR) {}\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    return retval;\n}\n\n\nvoid prep_for_new_file() {\n    r_bitcount = 0;\n    if (prefix_grbgdata) {\n        aligned_dealloc(prefix_grbgdata);\n        prefix_grbgdata = NULL;\n    }\n    if (grbgdata && grbgdata != &EOI[0]) {\n        aligned_dealloc(grbgdata);\n        grbgdata = NULL;\n    }\n\n    prefix_grbs = 0;\n    reset_buffers();\n    auto cur_num_threads = read_fixed_ujpg_header();\n    always_assert(cur_num_threads <= NUM_THREADS); // this is an invariant we need to maintain\n    str_out->prep_for_new_file();\n}\n\nvoid concatenate_files(int fdint, int fdout);\n\nvoid process_file(IOUtil::FileReader* reader,\n                  IOUtil::FileWriter *writer,\n                  int max_file_size,\n                  bool force_zlib0)\n{\n    clock_t begin = 0, end = 1;\n    const char* actionmsg  = NULL;\n    const char* errtypemsg = NULL;\n    int speed, bpms;\n    float cr;\n\n\n    if (g_inject_syscall_test == 2) {\n        unsigned int num_workers = std::max(\n            NUM_THREADS - 1,\n            1U);\n        GenericWorker* generic_workers = get_worker_threads(num_workers);\n        if (g_inject_syscall_test == 2) {\n            for (size_t i = 0; i < num_workers; ++i) {\n                std::atomic<int> value;\n                value.store(0);\n                generic_workers[i].work = std::bind(&test_syscall_injection, &value);\n                generic_workers[i].activate_work();\n                generic_workers[i].instruct_to_exit();\n                generic_workers[i].join_via_syscall();\n                if (value.load() < 1) {\n                    abort(); // this should exit_group\n                }\n            }\n            g_threaded = false;\n        }\n    }\n    // main function routine\n    errorlevel.store(0);\n    jpgfilesize = 0;\n    ujgfilesize = 0;\n\n    Sirikata::Array1d<uint8_t, 2> header = {{0, 0}};\n    const char * ifilename = filelist[file_no];\n    bool is_socket = false;\n    ssize_t bytes_read =0 ;\n    int fdin = open_fdin(ifilename, reader, header, &bytes_read, &is_socket);\n    /*\n    if (g_permissive && bytes_read < 2) {\n        std::vector<uint8_t> input(bytes_read);\n        if (bytes_read > 0) {\n            memcpy(&input[0], header.data, bytes_read);\n        }\n        Sirikata::MuxReader::ResizableByteBuffer lepton_data;\n        ExitCode exit_code = ExitCode::UNSUPPORTED_JPEG;\n        ValidationContinuation validation_exit_code = generic_compress(&input, &lepton_data, &exit_code);\n        if (exit_code != ExitCode::SUCCESS) {\n            custom_exit(exit_code);\n        }\n        if (validation_exit_code != ValidationContinuation::ROUNDTRIP_OK) {\n            custom_exit(ExitCode::UNSUPPORTED_JPEG);\n        }\n        int fdout = open_fdout(ifilename, writer, true, header, g_force_zlib0_out || force_zlib0, &is_socket);\n        for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n            ssize_t sent = write(fdout,\n                                 lepton_data.data() + data_sent,\n                                 lepton_data.size() - data_sent);\n            if (sent < 0 && errno == EINTR){\n                continue;\n            }\n            if (sent <= 0) {\n                custom_exit(ExitCode::SHORT_READ);\n            }\n            data_sent += sent;\n        }\n        //fprintf(stderr, \"OK...\\n\");\n        custom_exit(ExitCode::SUCCESS);\n        \n        }*/\n    int fdout = -1;\n    if ((embedded_jpeg || is_jpeg_header(header) || g_permissive) && (g_permissive ||  !g_skip_validation)) {\n        //fprintf(stderr, \"ENTERED VALIDATION...\\n\");\n        ExitCode validation_exit_code = ExitCode::SUCCESS;\n        Sirikata::MuxReader::ResizableByteBuffer lepton_data;\n        std::vector<uint8_t> permissive_jpeg_return_backing;\n        switch (validateAndCompress(&fdin, &fdout, header,\n                                    bytes_read,\n                                    start_byte, max_file_size,\n                                    &validation_exit_code,\n                                    &lepton_data,\n                                    g_argc,\n                                    g_argv,\n                                    g_permissive,\n                                    is_socket,\n                                    g_permissive? &permissive_jpeg_return_backing:NULL)) {\n          case ValidationContinuation::CONTINUE_AS_JPEG:\n            //fprintf(stderr, \"CONTINUE AS JPEG...\\n\");\n            is_socket = false;\n            break;\n          case ValidationContinuation::CONTINUE_AS_LEPTON:\n            embedded_jpeg = false;\n            is_socket = false;\n            g_force_zlib0_out = false;\n            force_zlib0 = false;\n            if (ofiletype ==  UJG) {\n                filetype = UJG;\n                header[0] = ujg_header[0];\n                header[1] = ujg_header[1];\n            } else {\n                filetype = LEPTON;\n                header[0] = lepton_header[0];\n                header[1] = lepton_header[1];\n            }\n            //fprintf(stderr, \"CONTINUE AS LEPTON...\\n\");\n            break;\n        case ValidationContinuation::EVALUATE_AS_PERMISSIVE:\n            if (permissive_jpeg_return_backing.size() == 0) {\n                custom_exit(ExitCode::UNSUPPORTED_JPEG);\n            }\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n            {ExitCode validation_exit_code = ExitCode::UNSUPPORTED_JPEG;\n            generic_compress(&permissive_jpeg_return_backing, &lepton_data, &validation_exit_code);\n            if (validation_exit_code != ExitCode::SUCCESS) {\n                custom_exit(validation_exit_code);\n            }}\n            for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n                ssize_t sent = write(fdout,\n                                     lepton_data.data() + data_sent,\n                                     lepton_data.size() - data_sent);\n                if (sent < 0 && errno == EINTR){\n                    continue;\n                }\n                if (sent <= 0) {\n                    custom_exit(ExitCode::SHORT_READ);\n                }\n                data_sent += sent;\n            }\n            //fprintf(stderr, \"OK...\\n\");\n            custom_exit(ExitCode::SUCCESS);\n            break;\n        case ValidationContinuation::ROUNDTRIP_OK:\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n            for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n                ssize_t sent = write(fdout,\n                                     lepton_data.data() + data_sent,\n                                     lepton_data.size() - data_sent);\n                if (sent < 0 && errno == EINTR){\n                    continue;\n                }\n                if (sent <= 0) {\n                    custom_exit(ExitCode::SHORT_READ);\n                }\n                data_sent += sent;\n            }\n            //fprintf(stderr, \"OK...\\n\");\n            custom_exit(ExitCode::SUCCESS);\n          case ValidationContinuation::BAD:\n          default:\n            always_assert(validation_exit_code != ExitCode::SUCCESS);\n            custom_exit(validation_exit_code);\n        }        \n    } else {\n        if (action != lepton_concatenate) {\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n        }\n    }\n    if (action == lepton_concatenate) {\n        concatenate_files(fdin, fdout);\n        return;\n    }\n    // check input file and determine filetype\n    check_file(fdin, fdout, max_file_size, force_zlib0, embedded_jpeg, header, is_socket);\n    \n    begin = clock();\n    if ( filetype == JPEG )\n    {\n\n\n        if (ofiletype == LEPTON) {\n            if (!g_encoder) {\n                if (ujgversion == 3) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n                    g_encoder.reset(makeEncoder<ANSBoolReader>(g_threaded, g_threaded));\n#else\n                    always_assert(false&&\"ANS-encoded file encountered but ANS not selected in build flags\");\n#endif\n                } else {\n                    g_encoder.reset(makeEncoder<VPXBoolReader>(g_threaded, g_threaded));\n                }\n                TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n                g_decoder = NULL;\n            } else if (g_threaded && (action == socketserve || action == forkserve)) {\n                g_encoder->registerWorkers(get_worker_threads(NUM_THREADS - 1), NUM_THREADS  - 1);\n            }\n        }else if (ofiletype == UJG) {\n            g_encoder.reset(new SimpleComponentEncoder);\n            g_decoder = NULL;\n        }\n    } else if (filetype == LEPTON) {\n        NUM_THREADS = read_fixed_ujpg_header();\n        if (NUM_THREADS == 1) {\n            g_threaded = false; // with singlethreaded, doesn't make sense to split out reader/writer\n        }\n        if (!g_decoder) {\n            g_decoder = makeDecoder(g_threaded, g_threaded, ujgversion == 3);\n            TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n            g_reference_to_free.reset(g_decoder);\n        } else if (NUM_THREADS > 1 && g_threaded && (action == socketserve || action == forkserve)) {\n            g_decoder->registerWorkers(get_worker_threads(NUM_THREADS), NUM_THREADS);\n        }\n    }else if (filetype == UJG) {\n        (void)read_fixed_ujpg_header();\n        g_decoder = new SimpleComponentDecoder;\n        g_reference_to_free.reset(g_decoder);\n    }\n#ifndef _WIN32\n    //FIXME\n    if (g_time_bound_ms) {\n        struct itimerval bound;\n        bound.it_value.tv_sec = g_time_bound_ms / 1000;\n        bound.it_value.tv_usec = (g_time_bound_ms % 1000) * 1000;\n        bound.it_interval.tv_sec = 0;\n        bound.it_interval.tv_usec = 0;\n        int ret = setitimer(ITIMER_REAL, &bound, NULL);\n\n        dev_assert(ret == 0 && \"Timer must be able to be set\");\n        if (ret != 0) {\n            exit((int)ExitCode::OS_ERROR);\n        }\n    }\n#endif\n    if (g_unkillable) { // only set this after the time bound has been set\n        if (!g_time_bound_ms) {\n            fprintf(stderr, \"Only allowed to set unkillable for items with a time bound\\n\");\n            exit(1);\n        }\n        signal(SIGTERM, &sig_nop);\n#ifndef _WIN32\n        signal(SIGQUIT, &sig_nop);\n#endif\n    }\n\n    if (g_use_seccomp) {\n        Sirikata::installStrictSyscallFilter(true);\n    }\n#ifndef _WIN32\n    if (g_inject_syscall_test == 1) {\n        char buf[128 + 1];\n        buf[sizeof(buf) - 1] = 0;\n        char * ret = getcwd(buf, sizeof(buf) - 1);\n        (void)ret;\n    }\n#endif\n    // get specific action message\n    if ( filetype == UNK ) {\n        actionmsg = \"unknown filetype\";\n    } else if (action == info) {\n        actionmsg = \"Parsing\";\n    } else if ( filetype == JPEG ) {\n        actionmsg = \"Writing to LEPTON\\n\";\n    } else {\n        actionmsg = \"Decompressing to JPEG\\n\";\n    }\n\n    if ( verbosity > 0 ) {\n        while (write(2, actionmsg , strlen(actionmsg)) < 0 && errno == EINTR) {}\n    }\n\n\n    std::vector<std::pair<uint32_t, uint32_t> > huff_input_offset;\n    if ( filetype == JPEG )\n    {\n        switch ( action )\n        {\n            case lepton_concatenate:\n              fprintf(stderr, \"Unable to concatenate raw JPEG files together\\n\");\n              custom_exit(ExitCode::VERSION_UNSUPPORTED);\n              break;\n            case comp:\n            case forkserve:\n            case socketserve:\n                timing_operation_start( 'c' );\n                TimingHarness::timing[0][TimingHarness::TS_READ_STARTED] = TimingHarness::get_time_us();\n                {\n                    std::vector<uint8_t,\n                                Sirikata::JpegAllocator<uint8_t> > jpeg_file_raw_bytes;\n                    unsigned int jpg_ident_offset = 2;\n                    if (start_byte == 0) {\n                        ibytestream str_jpg_in(str_in,\n                                               jpg_ident_offset,\n                                               Sirikata::JpegAllocator<uint8_t>());\n\n                        execute(std::bind(&read_jpeg_wrapper, &huff_input_offset, &str_jpg_in, header, embedded_jpeg));\n                    } else {\n                        ibytestreamcopier str_jpg_in(str_in,\n                                                     jpg_ident_offset,\n                                                     max_file_size,\n                                                     Sirikata::JpegAllocator<uint8_t>());\n                        str_jpg_in.mutate_read_data().push_back(0xff);\n                        str_jpg_in.mutate_read_data().push_back(0xd8);\n                        execute(std::bind(&read_jpeg_and_copy_to_side_channel,\n                                          &huff_input_offset, &str_jpg_in, header,\n                                          embedded_jpeg));\n                        jpeg_file_raw_bytes.swap(str_jpg_in.mutate_read_data());\n                    }\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_DECODE_STARTED] =\n                        TimingHarness::timing[0][TimingHarness::TS_READ_FINISHED] = TimingHarness::get_time_us();\n                    std::vector<ThreadHandoff> luma_row_offsets;\n                    execute(std::bind(&decode_jpeg, huff_input_offset, &luma_row_offsets));\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_DECODE_FINISHED]\n                        = TimingHarness::get_time_us();\n                    //execute( check_value_range );\n                    execute(std::bind(&write_ujpg,\n                                      std::move(luma_row_offsets),\n                                      jpeg_file_raw_bytes.empty() ? NULL : &jpeg_file_raw_bytes));\n                }\n                timing_operation_complete( 'c' );\n                break;\n\n            case info:\n                {\n                    unsigned int jpg_ident_offset = 2;\n                    ibytestream str_jpg_in(str_in, jpg_ident_offset, Sirikata::JpegAllocator<uint8_t>());\n                    execute(std::bind(read_jpeg_wrapper, &huff_input_offset, &str_jpg_in, header,\n                                      embedded_jpeg));\n                }\n                execute( write_info );\n                break;\n        }\n    }\n    else if ( filetype == UJG || filetype == LEPTON)\n    {\n        switch ( action )\n        {\n            case lepton_concatenate:\n              always_assert(false && \"should have been handled above\");\n            case comp:\n            case forkserve:\n            case socketserve:\n                if (!g_use_seccomp) {\n                    overall_start = clock();\n                }\n                timing_operation_start( 'd' );\n                TimingHarness::timing[0][TimingHarness::TS_READ_STARTED] = TimingHarness::get_time_us();\n                while (true) {\n                    execute( read_ujpg ); // replace with decompression function!\n                    TimingHarness::timing[0][TimingHarness::TS_READ_FINISHED] = TimingHarness::get_time_us();\n                    if (!g_use_seccomp) {\n                        read_done = clock();\n                    }\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();\n                    if (filetype != UJG && !g_allow_progressive) {\n                        execute(recode_baseline_jpeg_wrapper);\n                    } else {\n                        execute(recode_jpeg);\n                    }\n                    timing_operation_complete( 'd' );\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_FINISHED] = TimingHarness::get_time_us();\n                    Sirikata::Array1d<uint8_t, 6> trailer_new_header;\n                    std::pair<uint32_t, Sirikata::JpegError> continuity;\n                    size_t off = 0;\n                    while (off < trailer_new_header.size()) {\n                        continuity = str_in->Read(&trailer_new_header[off], trailer_new_header.size() - off);\n                        off += continuity.first;\n                        if (continuity.second != Sirikata::JpegError::nil()) {\n                            break;\n                        }\n                    }\n                    if (continuity.second != Sirikata::JpegError::nil()) {\n                        break;\n                    } else if (trailer_new_header[4] != header[0] ||  trailer_new_header[5] != header[1]) {\n                        break;\n                    } else {\n                        prep_for_new_file();\n                    }\n                }\n                str_out->close();\n                break;\n            case info:\n                execute( read_ujpg );\n                execute( write_info );\n                break;\n        }\n    }\n    if (!fast_exit) {\n        // close iostreams\n        if ( str_in  != NULL ) delete( str_in  ); str_in  = NULL;\n        if ( str_out != NULL ) delete( str_out ); str_out = NULL;\n        if ( ujg_out != NULL ) delete( ujg_out ); ujg_out = NULL;\n        // delete if broken or if output not needed\n        if ((!pipe_on) && ((errorlevel.load() >= err_tresh)\n                           || (action != comp && action != forkserve && action != socketserve))) {\n            // FIXME: can't delete broken output--it's gone already\n        }\n    }\n    TimingHarness::timing[0][TimingHarness::TS_DONE] = TimingHarness::get_time_us();\n    TimingHarness::print_results();\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    {\n        size_t bound = decompression_memory_bound();\n        char bound_out[] = \"XXXXXXXXXX bytes needed to decompress this file\\n\";\n        bound_out[0] = '0' + (bound / 1000000000)%10;\n        bound_out[1] = '0' + (bound / 100000000)%10;\n        bound_out[2] = '0' + (bound / 10000000)%10;\n        bound_out[3] = '0' + (bound / 1000000)%10;\n        bound_out[4] = '0' + (bound / 100000)%10;\n        bound_out[5] = '0' + (bound / 10000)%10;\n        bound_out[6] = '0' + (bound / 1000)%10;\n        bound_out[7] = '0' + (bound / 100)%10;\n        bound_out[8] = '0' + (bound / 10)%10;\n        bound_out[9] = '0' + (bound / 1)%10;\n        const char * to_write = bound_out;\n        while(to_write[0] == '0') {\n            ++to_write;\n        }\n        while(write(2, to_write, strlen(to_write)) < 0 && errno == EINTR) {\n        }\n    }\n    print_bill(2);\n    // speed and compression ratio calculation\n    speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n    bpms  = ( speed > 0 ) ? ( jpgfilesize / speed ) : jpgfilesize;\n    cr    = ( jpgfilesize > 0 ) ? ( 100.0 * ujgfilesize / jpgfilesize ) : 0;\n\n    switch ( verbosity )\n    {\n        case 0:\n          if ( errorlevel.load() < err_tresh ) {\n                if (action == comp ) {\n                    fprintf(stderr, \"%d %d\\n\",(int)ujgfilesize, (int)jpgfilesize);\n                    char percentage_report[]=\" XX.XX%\\n\";\n                    double pct = cr + .005;\n                    percentage_report[0] = '0' + (int)(pct / 100) % 10;\n                    percentage_report[1] = '0' + (int)(pct / 10) % 10;\n                    percentage_report[2] = '0' + (int)(pct) % 10;\n                    percentage_report[4] = '0' + (int)(pct * 10) % 10;\n                    percentage_report[5] = '0' + (int)(pct * 100) % 10;\n                    char * output = percentage_report;\n                    if (cr < 100) {\n                        ++output;\n                    }\n                    while (write(2, output, strlen(output)) < 0 && errno == EINTR) {\n                    }\n                }\n                else {\n                    fprintf( msgout,  \"DONE\\n\" );\n                }\n            }\n            break;\n\n        case 1:\n          if ( errorlevel.load() < err_tresh ) fprintf( msgout,  \"DONE\\n\" );\n            else fprintf( msgout,  \"ERROR\\n\" );\n            break;\n\n        case 2:\n            fprintf( msgout,  \"\\n----------------------------------------\\n\" );\n            if ( errorlevel.load() < err_tresh ) fprintf( msgout,  \"-> %s OK\\n\", actionmsg );\n            break;\n    }\n\n    switch ( errorlevel.load() )\n    {\n        case 0:\n            errtypemsg = \"none\";\n            break;\n\n        case 1:\n            if ( errorlevel.load() < err_tresh )\n                errtypemsg = \"warning (ignored)\";\n            else\n                errtypemsg = \"warning (skipped file)\";\n            break;\n\n        case 2:\n            errtypemsg = \"fatal error\";\n            break;\n    }\n\n    if ( errorlevel.load() > 0 )\n    {\n        if (false && action != socketserve && action != forkserve) {\n            fprintf( stderr, \" %s:\\n\", errtypemsg  );\n            fprintf( stderr, \" %s\\n\", errormessage.c_str() );\n            if ( verbosity > 1 )\n                fprintf( stderr, \" (in file \\\"%s\\\")\\n\", filelist[ file_no ] );\n        }\n    }\n    if ( (verbosity > 0) && (errorlevel.load() < err_tresh) )\n    if ( action == comp )\n    {\n        fprintf( msgout,  \" time taken  : %7i msec\\n\", speed );\n        fprintf( msgout,  \" byte per ms : %7i byte\\n\", bpms );\n        fprintf( msgout,  \" comp. ratio : %7.2f %%\\n\", cr );\n    }\n\n    if ( ( verbosity > 1 ) && ( action == comp ) )\n        fprintf( msgout,  \"\\n\" );\n    LeptonDebug::dumpDebugData();\n    if (errorlevel.load()) {\n        custom_exit(ExitCode::UNSUPPORTED_JPEG); // custom exit will delete generic_workers\n    } else {\n        custom_exit(ExitCode::SUCCESS);\n    }\n    reset_buffers();\n}\n\n\n/* -----------------------------------------------\n    main-function execution routine\n    ----------------------------------------------- */\n\nvoid execute(const std::function<bool()> &function)\n{\n    clock_t begin = 0, end = 0;\n    bool success;\n\n\n\n    if ( errorlevel.load() < err_tresh )\n    {\n        // get statusmessage\n        //function();\n        // write statusmessage\n        // set starttime\n        if (!g_use_seccomp) {\n            begin = clock();\n        }\n        // call function\n        success = function();\n        // set endtime\n        if (!g_use_seccomp) {\n            end = clock();\n        }\n\n        // write statusmessage\n        if ( success ) {\n            if (verbosity == 2 && !g_use_seccomp) {\n                fprintf( msgout,  \"%6ims\",\n                         (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC ) );\n            }\n        }\n        else {\n            if ( verbosity == 2 ) {\n                while(write(2, \"ERROR\\n\", strlen(\"ERROR\\n\")) < 0 && errno == EINTR) {\n\n                }\n            }\n        }\n    }\n}\n\n\n/* -----------------------------------------------\n    shows help in case of wrong input\n    ----------------------------------------------- */\n\nvoid show_help( void )\n{\n    fprintf(msgout, \"Usage: %s [switches] input_file [output_file]\", appname );\n    fprintf(msgout, \"\\n\" );\n    fprintf(msgout, \"\\n\" );\n    fprintf(msgout, \" [-version]       File format version of lepton codec\\n\" );\n    fprintf(msgout, \" [-revision]      GIT Hash of lepton source that built this binary\\n\");\n    fprintf(msgout, \" [-zlib0]         Instead of a jpg, return a zlib-compressed jpeg\\n\");\n    fprintf(msgout, \" [-startbyte=<n>] Encoded file will only contain data at and after <n>\\n\");\n    fprintf(msgout, \" [-trunc=<n>]     Encoded file will be truncated at size <n> - startbyte\\n\");\n//    fprintf(msgout, \" [-avx2upgrade]   Try to exec <binaryname>-avx if avx is available\\n\");\n//    fprintf(msgout, \" [-injectsyscall={1..4}]  Inject a \\\"chdir\\\" syscall & check SECCOMP crashes\\n\");\n    fprintf(msgout, \" [-unjailed]      Do not jail this process (use only with trusted data)\\n\" );\n    fprintf(msgout, \" [-singlethread]  Do not clone threads to operate on the input file\\n\" );\n    fprintf(msgout, \" [-maxencodethreads=<n>] Can use <n> threads to decode: higher=bigger file\\n\");\n    fprintf(msgout, \" [-allowprogressive] Allow progressive jpegs through the compressor\\n\");\n    fprintf(msgout, \" [-rejectprogressive] Reject encoding of progressive jpegs\\n\");\n    fprintf(msgout, \" [-timebound=<>ms]For -socket, enforce a timeout since first byte received\\n\");\n    fprintf(msgout, \" [-lepcat] Concatenate lepton files together into a file that contains multiple substrings\\n\");\n    fprintf(msgout, \" [-memory=<>M]    Upper bound on the amount of memory allocated by main\\n\");\n    fprintf(msgout, \" [-threadmemory=<>M] Bound on the amount of memory allocated by threads\\n\");\n    fprintf(msgout, \" [-recodememory=<>M] Check that a singlethreaded recode only uses <>M mem\\n\");\n#ifndef _WIN32\n    fprintf(msgout, \" [-hugepages]     Allocate from the hugepages on the system\\n\");\n    fprintf(msgout, \" [-socket=<name>] Serve requests on a Unix Domain Socket at path <name>\\n\" );\n    fprintf(msgout, \" [-listen=<port>] Serve requests on a TCP socket on <port> (default 2402)\\n\" );\n    fprintf(msgout, \" [-listenbacklog=<n>] n clients queued for encoding if maxchildren reached\\n\" );\n    fprintf(msgout, \" [-zliblisten=<port>] Serve requests on a TCP socket on <port> (def 2403)\\n\" );\n    fprintf(msgout, \" [-maxchildren]   Max codes to ever spawn at the same time in socket mode\\n\");\n#endif\n    fprintf(msgout, \" [-benchmark]     Run a benchmark on optional [<input_file>] (or included file)\\n\");\n    fprintf(msgout, \" [-verbose]       Run the benchmark in verbose mode (more output to stderr)\\n\");\n    fprintf(msgout, \" [-benchreps=<n>] Number of trials to run the benchmark for each category\\n\");\n    fprintf(msgout, \" [-benchthreads=<n>] Max number of parallel codings to benchmark\\n\");\n#ifdef SKIP_VALIDATION\n    fprintf(msgout, \" [-validate]      Round-trip this file when encoding [default:off]\\n\");\n#else\n    fprintf(msgout, \" [-validate]      Round-trip this file when encoding [default:on]\\n\");\n    fprintf(msgout, \" [-skipvalidate]  Avoid round-trip check when encoding (Warning: unsafe)\\n\");\n#endif\n}\n\n/* ----------------------- End of main interface functions -------------------------- */\n\n/* ----------------------- Begin of main functions -------------------------- */\n\n\nvoid nop (Sirikata::DecoderWriter*w, size_t) {\n}\n\n//void static_cast_to_zlib_and_call (Sirikata::DecoderWriter*w, size_t size) {\n//    (static_cast<Sirikata::Zlib0Writer*>(w))->setFullFileSize(size);\n//}\n\n\n/* -----------------------------------------------\n    check file and determine filetype\n    ----------------------------------------------- */\nunsigned char read_fixed_ujpg_header() {\n    Sirikata::Array1d<unsigned char, 22> header;\n    header.memset(0);\n\n    if (IOUtil::ReadFull(str_in, header.begin(), 22) != 22) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    // check version number\n    if (header[0] != 1 && header[0] != 2 && header[0] != 3 && header[0] != 4 && header[0] != ujgversion) {\n        // let us roll out a new version gently\n        fprintf( stderr, \"incompatible file, use %s v%i.%i\",\n            appname, header[ 0 ] / 10, header[ 0 ] % 10 );\n        custom_exit(ExitCode::VERSION_UNSUPPORTED);\n    }\n    ujgversion = header[0];\n    if (header[1] == 'X') {\n    } else if (header[1] != 'Z' && header[1] != 'Y') {\n        char err[] = \"?: Unknown Item in header instead of Z\";\n        err[0] = header[1];\n        while(write(2, err, sizeof(err) - 1) < 0 && errno == EINTR) {\n        }\n    }\n    if (header[1] == 'Z' || (header[1] & 1) == ('Y' & 1)) {\n        if (!g_force_progressive) {\n            g_allow_progressive = false;\n        }\n    }\n    unsigned char num_threads_hint = header[2];\n    always_assert(num_threads_hint != 0);\n    if (num_threads_hint < NUM_THREADS && num_threads_hint != 0) {\n        NUM_THREADS = num_threads_hint;\n    }\n// full size of the original file\n    Sirikata::Array1d<unsigned char, 4>::Slice file_size = header.slice<18,22>();\n    max_file_size = LEtoUint32(file_size.begin());\n    return NUM_THREADS;\n}\n\nbool check_file(int fd_in, int fd_out, uint32_t max_file_size, bool force_zlib0,\n                bool is_embedded_jpeg, Sirikata::Array1d<uint8_t, 2> fileid, bool is_socket)\n{\n    IOUtil::FileReader * reader = IOUtil::BindFdToReader(fd_in, max_file_size, is_socket);\n    if (!reader) {\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    reader->mark_some_bytes_already_read((uint32_t)fileid.size());\n    if (is_socket) {\n        dev_assert(fd_in == fd_out);\n    }\n    IOUtil::FileWriter * writer = IOUtil::BindFdToWriter(fd_out == -1 ? 1 /* stdout */ : fd_out, is_socket);\n    ujg_base_in = reader;\n    // check file id, determine filetype\n    if (is_embedded_jpeg || is_jpeg_header(fileid)) {\n        str_in = new Sirikata::BufferedReader<JPG_READ_BUFFER_SIZE>(reader);\n        // file is JPEG\n        filetype = JPEG;\n        NUM_THREADS = std::min(NUM_THREADS, (unsigned int)max_encode_threads);\n        // open output stream, check for errors\n        ujg_out = writer;\n    }\n    else if ( ( ( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) )\n              || ( ( fileid[0] == lepton_header[0] ) && ( fileid[1] == lepton_header[1] ) )\n              || ( ( fileid[0] == zlepton_header[0] ) && ( fileid[1] == zlepton_header[1] ) ) ){\n        str_in = reader;\n        bool compressed_output = (fileid[0] == zlepton_header[0]) && (fileid[1] == zlepton_header[1]);\n        compressed_output = compressed_output || g_force_zlib0_out || force_zlib0;\n        // file is UJG\n        filetype = (( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) ) ? UJG : LEPTON;\n        std::function<void(Sirikata::DecoderWriter*, size_t file_size)> known_size_callback = &nop;\n        Sirikata::DecoderWriter * write_target = writer;\n        if (compressed_output) {\n            Sirikata::Zlib0Writer * zwriter;\n            if (uninit_g_zlib_0_writer) {\n                zwriter = new(uninit_g_zlib_0_writer)Sirikata::Zlib0Writer(writer, 0);\n                uninit_g_zlib_0_writer = NULL;\n            }else {\n                zwriter = new Sirikata::Zlib0Writer(writer, 0);\n            }\n            known_size_callback = &nop;\n            write_target = zwriter;\n        }\n        str_out = new bounded_iostream( write_target,\n                                        known_size_callback,\n                                        Sirikata::JpegAllocator<uint8_t>());\n        if ( str_out->chkerr() ) {\n            fprintf( stderr, FWR_ERRMSG, filelist[file_no]);\n            errorlevel.store(2);\n            return false;\n        }\n    }\n    else {\n        // file is neither\n        filetype = UNK;\n        fprintf( stderr, \"filetype of file \\\"%s\\\" is unknown\", filelist[ file_no ] );\n        errorlevel.store(2);\n        return false;\n    }\n\n\n    return true;\n}\n\nbool is_needed_for_second_block(const std::vector<unsigned char>&segment) {\n    if (segment.size() <= 2) {\n        return true; // don't understand this type of header\n    }\n    if (segment[0] != 0xff) {\n        return true; // don't understand this type of header\n    }\n    switch (segment[1]) {\n      case 0xC4: // DHT segment\n      case 0xDB: // DQT segment\n      case 0xDD: // DRI segment\n      case 0xDA: // Start of scan\n      case 0xC0:\n      case 0xC1:\n      case 0xC2:\n        return true;\n      case 0xD8:\n      case 0xD9:\n        dev_assert(false && \"This should be filtered out by the previous loop\");\n        return true;\n      default:\n        return false;\n    }\n}\n/* -----------------------------------------------\n    Read in header & image data\n    ----------------------------------------------- */\ntemplate<class input_byte_stream>\nbool read_jpeg(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offsets,\n               input_byte_stream *jpg_in,\n               Sirikata::Array1d<uint8_t, 2> header,\n               bool is_embedded_jpeg){\n    if (jpeg_embedding_offset) {\n        prefix_grbs = jpeg_embedding_offset + 2;\n        prefix_grbgdata = aligned_alloc(prefix_grbs);\n        prefix_grbgdata[0] = header[0];\n        prefix_grbgdata[1] = header[1];\n        prefix_grbs = jpg_in->read(prefix_grbgdata + 2, jpeg_embedding_offset);\n        always_assert((size_t)prefix_grbs == jpeg_embedding_offset); // the ffd8 gets baked in...again\n    }\n    std::vector<unsigned char> segment(1024); // storage for current segment\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   crst = 0; // current rst marker counter\n    unsigned int   cpos = 0; // rst marker counter\n    unsigned char  tmp;\n\n    abytewriter* huffw;\n    abytewriter* hdrw;\n    abytewriter* grbgw;\n\n    // preset count of scans\n    scnc = 0;\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n    hdrs = 0; // size of header data, start with 0\n\n    // start huffman writer\n    huffw = new abytewriter( 0 );\n    hufs  = 0; // size of image data, start with 0\n\n    // JPEG reader loop\n    while ( true ) {\n        if ( type == 0xDA ) { // if last marker was sos\n            // switch to huffman data reading mode\n            cpos = 0;\n            crst = 0;\n            while ( true ) {\n                huff_input_offsets->push_back(std::pair<uint32_t, uint32_t>(huffw->getpos(),\n                                                                            jpg_in->getsize()));\n                // read byte from imagedata\n                if ( jpg_in->read_byte( &tmp) == false ) {\n                    early_eof(hdrw, huffw);\n                    fprintf(stderr, \"Early EOF\\n\");\n                    break;\n                }\n                // non-0xFF loop\n                if ( tmp != 0xFF ) {\n                    crst = 0;\n                    while ( tmp != 0xFF ) {\n                        huffw->write( tmp );\n                        if ( jpg_in->read_byte( &tmp ) == false ) {\n                            early_eof(hdrw, huffw);\n                            break;\n                        }\n                    }\n                }\n\n                // treatment of 0xFF\n                if ( tmp == 0xFF ) {\n                    if ( jpg_in->read_byte( &tmp ) == false ) {\n                        early_eof(hdrw, huffw);\n                        break; // read next byte & check\n                    }\n                    if ( tmp == 0x00 ) {\n                        crst = 0;\n                        // no zeroes needed -> ignore 0x00. write 0xFF\n                        huffw->write( 0xFF );\n                        write_byte_bill(Billing::DELIMITERS, false, 1);\n                    }\n                    else if ( tmp == 0xD0 + ( cpos & 7 ) ) { // restart marker\n                        // increment rst counters\n                        write_byte_bill(Billing::DELIMITERS, false, 2);\n                        cpos++;\n                        crst++;\n                        while (rst_cnt.size() <= (size_t)scnc) {\n                            rst_cnt.push_back(0);\n                        }\n                        ++rst_cnt.at(scnc);\n                    }\n                    else { // in all other cases leave it to the header parser routines\n                        // store number of falsely set rst markers\n                        if((int)rst_err.size() < scnc) {\n                            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n                        }\n                        rst_err.push_back(crst);\n                        // end of current scan\n                        scnc++;\n                        always_assert(rst_err.size() == (size_t)scnc && \"All reset errors must be accounted for\");\n                        // on with the header parser routines\n                        segment[ 0 ] = 0xFF;\n                        segment[ 1 ] = tmp;\n                        break;\n                    }\n                }\n                else {\n                    // otherwise this means end-of-file, so break out\n                    break;\n                }\n            }\n        }\n        else {\n            // read in next marker\n            if ( jpg_in->read( segment.data(), 2 ) != 2 ) break;\n            if ( segment[ 0 ] != 0xFF ) {\n                // ugly fix for incorrect marker segment sizes\n                fprintf( stderr, \"size mismatch in marker segment FF %2X\", type );\n                errorlevel.store(2);\n                if ( type == 0xFE ) { //  if last marker was COM try again\n                    if ( jpg_in->read( segment.data(), 1) != 1 ) break;\n                    if ( segment[ 0 ] == 0xFF ) errorlevel.store(1);\n                }\n                if ( errorlevel.load() == 2 ) {\n                    delete ( hdrw );\n                    delete ( huffw );\n                    return false;\n                }\n            }\n        }\n\n        // read segment type\n        type = segment[ 1 ];\n\n        // if EOI is encountered make a quick exit\n        if ( type == EOI[1] ) {\n            standard_eof(hdrw, huffw);\n            // everything is done here now\n            break;\n        }\n\n        // read in next segments' length and check it\n        if ( jpg_in->read( segment.data() + 2, 2 ) != 2 ) break;\n        len = 2 + B_SHORT( segment[ 2 ], segment[ 3 ] );\n        if ( len < 4 ) break;\n\n        // realloc segment data if needed\n        segment.resize(len);\n\n        // read rest of segment, store back in header writer\n        if ( jpg_in->read( ( segment.data() + 4 ), ( len - 4 ) ) !=\n            ( unsigned short ) ( len - 4 ) ) break;\n        if (start_byte == 0 || is_needed_for_second_block(segment)) {\n            hdrw->write_n( segment.data(), len );\n        }\n    }\n    // JPEG reader loop end\n\n    // free writers\n    delete ( hdrw );\n    delete ( huffw );\n\n    // check if everything went OK\n    if ( hdrs == 0 ) {\n        fprintf( stderr, \"unexpected end of data encountered in header\" );\n        errorlevel.store(2);\n        return false;\n    }\n    if ( hufs == 0 ) {\n        fprintf( stderr, \"unexpected end of data encountered in huffman\" );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // store garbage at EOI\n    grbgw = new abytewriter( 1024 );\n    unsigned char grb0 = jpg_in->get_penultimate_read();\n    unsigned char grb1 = jpg_in->get_last_read();\n    grbgw->write( grb0 ); // should be 0xff (except if truncated)\n    grbgw->write( grb1 ); // should be d9 (except if truncated)\n    while( true ) {\n        len = jpg_in->read( segment.data(), segment.size() );\n        if ( len == 0 ) break;\n        grbgw->write_n( segment.data(), len );\n    }\n    grbgdata = grbgw->getptr_aligned();\n    grbs     = grbgw->getpos();\n    delete ( grbgw );\n    if (grbs == sizeof(EOI) && 0 == memcmp(grbgdata, EOI, sizeof(EOI))) {\n        grbs = 0;\n        aligned_dealloc(grbgdata);\n        grbgdata = NULL;\n    }\n\n    // get filesize\n    jpgfilesize = jpg_in->getsize();\n\n    // parse header for image info\n    if ( !setup_imginfo_jpg(false) ) {\n        return false;\n    }\n\n\n    return true;\n}\n\n\nenum MergeJpegStreamingStatus{\n    STREAMING_ERROR = 0,\n    STREAMING_SUCCESS = 1,\n    STREAMING_NEED_DATA = 2,\n    STREAMING_DISABLED = 3\n};\n\nbool aligned_memchr16ff(const unsigned char *local_huff_data) {\n#if USE_SCALAR\n    return memchr(local_huff_data, 0xff, 16) != NULL;\n#else\n    __m128i buf = _mm_load_si128((__m128i const*)local_huff_data);\n    __m128i ff = _mm_set1_epi8(-1);\n    __m128i res = _mm_cmpeq_epi8(buf, ff);\n    uint32_t movmask = _mm_movemask_epi8(res);\n    bool retval = movmask != 0x0;\n    dev_assert (retval == (memchr(local_huff_data, 0xff, 16) != NULL));\n    return retval;\n#endif\n}\n\nunsigned char hex_to_nibble(char val) {\n    if (val >= 'A' && val <= 'F') {\n        return val - 'A' + 10;\n    }\n    if (val >= 'a' && val <= 'f') {\n        return val - 'a' + 10;\n    }\n    return val - '0';\n}\nunsigned char hex_pair_to_byte(char big, char little) {\n    return hex_to_nibble(big) * 16 + hex_to_nibble(little);\n}\nbool hex_to_bin(unsigned char *output, const char *input, size_t output_size) {\n    size_t i = 0;\n    for (; i < output_size && input[i * 2] && input[i * 2 + 1]; ++i) {\n        output[i] = hex_pair_to_byte(input[i * 2], input[i * 2 + 1]);\n    }\n    return i == output_size;\n}\nbool rst_cnt_ok(int scan, unsigned int num_rst_markers_this_scan) {\n    if (rstp.empty()) {\n        return false;\n    }\n    if (!rst_cnt_set) {\n        return true;\n    }\n    return rst_cnt.size() > (size_t)scan - 1 && num_rst_markers_this_scan < rst_cnt.at(scan - 1);\n}\n\n\nThreadHandoff crystallize_thread_handoff(abitreader *reader,\n                                         const std::vector<std::pair<uint32_t, uint32_t> >&huff_input_offsets,\n                                         int mcu_y,\n                                         int lastdc[4],\n                                         int luma_mul) {\n    auto iter = std::lower_bound(huff_input_offsets.begin(), huff_input_offsets.end(),\n                                 std::pair<uint32_t, uint32_t>(reader->getpos(), reader->getpos()));\n    uint32_t mapped_item = 0;\n    if (iter != huff_input_offsets.begin()) {\n        --iter;\n    }\n    if (iter != huff_input_offsets.end()) {\n        mapped_item = iter->second;\n        mapped_item += reader->getpos() - iter->first;\n    }\n    //fprintf(stderr, \"ROWx (%08lx): %x -> %x\\n\", reader->debug_peek(), reader->getpos(), mapped_item);\n    ThreadHandoff retval = ThreadHandoff::zero();\n    retval.segment_size = mapped_item; // the caller will need to take the difference of the chosen items\n    // to compute the actual segment size\n    for (unsigned int i = 0; i < 4 && i < sizeof(retval.last_dc)/ sizeof(retval.last_dc[0]); ++i) {\n        retval.last_dc[i] = lastdc[i];\n        retval.luma_y_start = luma_mul * mcu_y;\n        retval.luma_y_end = luma_mul * (mcu_y + 1);\n    }\n\n    std::tie( retval.num_overhang_bits, retval.overhang_byte ) = reader->overhang();\n\n/*\n    fprintf(stderr, \"%d: %d -> %d  lastdc %d %d %d size %d overhang %d (cnt: %d)\\n\",\n            mcu_y,\n            retval.luma_y_start,\n            retval.luma_y_end,\n            retval.last_dc[0],\n            retval.last_dc[1],\n            retval.last_dc[2],\n            retval.segment_size,\n            retval.overhang_byte,\n            retval.num_overhang_bits);\n*/\n    return retval;\n}\n\nMergeJpegStreamingStatus merge_jpeg_streaming(MergeJpegProgress *stored_progress, const unsigned char * local_huff_data, unsigned int max_byte_coded,\n                                              bool flush) {\n    MergeJpegProgress progress(stored_progress);\n    unsigned char SOI[ 2 ] = { 0xFF, 0xD8 }; // SOI segment\n    //unsigned char EOI[ 2 ] = { 0xFF, 0xD9 }; // EOI segment\n\n    unsigned char  type = 0x00; // type of current marker segment\n\n    if (progress.ipos == 0 && progress.hpos == 0 && progress.scan == 1 && progress.within_scan == false) {\n        always_assert(max_file_size > grbs && \"Lepton only supports files that have some scan data\");\n        str_out->set_bound(max_file_size - grbs);\n\n        // write SOI\n        str_out->write( SOI, 2 );\n    }\n\n    // JPEG writing loop\n    while ( true )\n    {\n        if (!progress.within_scan) {\n            progress.within_scan = true;\n            // store current header position\n            unsigned int   tmp; // temporary storage variable\n            tmp = progress.hpos;\n\n            // seek till start-of-scan\n            for ( type = 0x00; type != 0xDA; ) {\n                if ( 3 + (uint64_t) progress.hpos >= hdrs ) break;\n                type = hdrdata[ progress.hpos + 1 ];\n                int len = 2 + B_SHORT( hdrdata[ progress.hpos + 2 ], hdrdata[progress.hpos + 3 ] );\n                progress.hpos += len;\n            }\n            unsigned int actual_progress_hpos = std::min(progress.hpos, hdrs);\n            // write header data to file\n            str_out->write( hdrdata + tmp, ( actual_progress_hpos - tmp ) );\n            for (unsigned int i = actual_progress_hpos; i < progress.hpos; ++i) {\n                str_out->write(\"\", 1); // write out null bytes beyond buffer\n            }\n            if ((!g_use_seccomp) && post_byte == 0) {\n                post_byte = clock();\n            }\n\n            // get out if last marker segment type was not SOS\n            if ( type != 0xDA ) break;\n\n            // (re)set corrected rst pos\n            progress.cpos = 0;\n            progress.ipos = scnp.at(progress.scan - 1);\n        }\n        if ((int)progress.scan > scnc + 1) { // don't want to go beyond our known number of scans (FIXME: danielrh@ is this > or >= )\n            break;\n        }\n        if (progress.ipos < max_byte_coded) {\n            timing_operation_first_byte( 'd' );\n        }\n        // write & expand huffman coded image data\n        unsigned int progress_ipos = progress.ipos;\n        unsigned int progress_scan = scnp.at(progress.scan);\n        unsigned int rstp_progress_rpos = rstp.empty() ? INT_MAX : rstp[ progress.rpos ];\n        const unsigned char mrk = 0xFF; // marker start\n        const unsigned char stv = 0x00; // 0xFF stuff value\n        for ( ; progress_ipos & 0xf; progress_ipos++ ) {\n            if (__builtin_expect(!(progress_ipos < max_byte_coded && (progress_scan == 0 || progress_ipos < progress_scan)), 0)) {\n                break;\n            }\n            uint8_t byte_to_write = local_huff_data[progress_ipos];\n            str_out->write_byte(byte_to_write);\n            // check current byte, stuff if needed\n            if (__builtin_expect(byte_to_write == 0xFF, 0))\n                str_out->write_byte(stv);\n            // insert restart markers if needed\n            if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan)) {\n                    const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                    str_out->write_byte(mrk);\n                    str_out->write_byte(rst);\n                    progress.rpos++; progress.cpos++;\n                    rstp_progress_rpos = rstp.at(progress.rpos);\n                    ++progress.num_rst_markers_this_scan;\n                }\n            }\n        }\n\n        while(true) {\n            if (__builtin_expect(!(progress_ipos + 15 < max_byte_coded && (progress_scan == 0 || progress_ipos + 15 < progress_scan)), 0)) {\n                break;\n            }\n            if ( __builtin_expect(aligned_memchr16ff(local_huff_data + progress_ipos)\n                                  || (progress_ipos <= rstp_progress_rpos\n                                      && progress_ipos + 15 >= rstp_progress_rpos), 0)){\n                // insert restart markers if needed\n                for (int veci = 0 ; veci < 16; ++veci, ++progress_ipos ) {\n                    if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                        uint8_t byte_to_write = local_huff_data[progress_ipos];\n                        str_out->write_byte(byte_to_write);\n                        // check current byte, stuff if needed\n                        if (__builtin_expect(byte_to_write == 0xFF, 0)) {\n                            str_out->write_byte(stv);\n                        }\n                        if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan)) {\n                                const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                                str_out->write_byte(mrk);\n                                str_out->write_byte(rst);\n                                progress.rpos++; progress.cpos++;\n                                rstp_progress_rpos = rstp.at(progress.rpos);\n                                ++progress.num_rst_markers_this_scan;\n                        }\n                    } else {\n                        uint8_t byte_to_write = local_huff_data[progress_ipos];\n                        str_out->write_byte(byte_to_write);\n                        // check current byte, stuff if needed\n                        if (__builtin_expect(byte_to_write == 0xFF, 0)) {\n                            str_out->write_byte(stv);\n                        }\n                    }\n                }\n            } else {\n                str_out->write(local_huff_data + progress_ipos, 16);\n                progress_ipos+=16;\n            }\n        }\n        for ( ; ; progress_ipos++ ) {\n            if (__builtin_expect(!(progress_ipos < max_byte_coded && (progress_scan == 0 || progress_ipos < progress_scan)), 0)) {\n                break;\n            }\n            uint8_t byte_to_write = local_huff_data[progress_ipos];\n            str_out->write_byte(byte_to_write);\n            // check current byte, stuff if needed\n            if (__builtin_expect(byte_to_write == 0xFF, 0))\n                str_out->write_byte(stv);\n            // insert restart markers if needed\n            if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan )) {\n                    const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                    str_out->write_byte(mrk);\n                    str_out->write_byte(rst);\n                    progress.rpos++; progress.cpos++;\n                    rstp_progress_rpos = rstp.at(progress.rpos);\n                    ++progress.num_rst_markers_this_scan;\n                }\n            }\n        }\n        progress.ipos = progress_ipos;\n        if (scnp.at(progress.scan) == 0 && !flush) {\n            return STREAMING_NEED_DATA;\n        }\n        if (progress.ipos >= max_byte_coded && progress.ipos != scnp.at(progress.scan) && !flush) {\n            return STREAMING_NEED_DATA;\n        }\n        // insert false rst markers at end if needed\n        if (progress.scan - 1 < rst_err.size()) {\n            while ( rst_err.at(progress.scan - 1) > 0 ) {\n                const unsigned char rst = 0xD0 + ( progress.cpos & 7 );\n                str_out->write_byte(mrk);\n                str_out->write_byte(rst);\n                progress.cpos++;    rst_err.at(progress.scan - 1)--;\n            }\n        }\n        progress.num_rst_markers_this_scan = 0;\n        progress.within_scan = false;\n        // proceed with next scan\n        progress.scan++;\n        if(str_out->has_reached_bound()) {\n            check_decompression_memory_bound_ok();\n            break;\n        }\n    }\n\n    // write EOI (now EOI is stored in garbage of at least 2 bytes)\n    // this guarantees that we can stop the write in time.\n    // if it used too much memory\n    // str_out->write( EOI, 1, 2 );\n    str_out->set_bound(max_file_size);\n    check_decompression_memory_bound_ok();\n    // write garbage if needed\n    if ( grbs > 0 )\n        str_out->write( grbgdata, grbs );\n    check_decompression_memory_bound_ok();\n    str_out->flush();\n\n    // errormessage if write error\n    if ( str_out->chkerr() ) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return STREAMING_ERROR;\n    }\n    // get filesize\n\n    jpgfilesize = str_out->getsize();\n    // get filesize\n    if (ujg_base_in) {\n        ujgfilesize = ujg_base_in->getsize();\n    } else {\n        ujgfilesize = 4096 * 1024;\n    }\n#ifndef _WIN32\n    //FIXME\n    if (!g_use_seccomp) {\n        clock_t final = clock();\n        struct timeval fin = {0,0};\n        gettimeofday(&fin,NULL);\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = fin.tv_sec + (double)fin.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n\n        fprintf(stderr, \"TIMING (new method): %f to first byte %f total\\n\",\n                begin_to_first_byte,\n                begin_to_end);\n        (void)final;\n/*\n        fprintf(stderr, \"TIMING (recode): %f to first byte %f total\\n\",\n                (double)(post_byte - pre_byte)/(double)CLOCKS_PER_SEC,\n                (final - pre_byte)/(double)CLOCKS_PER_SEC);\n        fprintf(stderr, \"TIMING(overall): %f to first byte %f total\\n\",\n                (post_byte - overall_start)/(double)CLOCKS_PER_SEC,\n                (final - overall_start)/(double)CLOCKS_PER_SEC);\n*/\n        fprintf(stderr, \"Read took: %f\\n\",\n                (read_done - overall_start)/(double)CLOCKS_PER_SEC);\n    }\n#endif\n    return STREAMING_SUCCESS;\n\n}\n\n\n\n\n/* -----------------------------------------------\n    JPEG decoding routine\n    ----------------------------------------------- */\n\nbool decode_jpeg(const std::vector<std::pair<uint32_t, uint32_t> > & huff_input_offsets,\n                 std::vector<ThreadHandoff>*luma_row_offset_return)\n{\n    abitreader* huffr; // bitwise reader for image data\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // current position in header\n\n    int lastdc[ 4 ] = {0, 0, 0, 0}; // last dc for each component\n    Sirikata::Aligned256Array1d<int16_t,64> block; // store block for coeffs\n    int peobrun; // previous eobrun\n    unsigned int eobrun; // run of eobs\n    int rstw; // restart wait counter\n\n    int cmp, bpos, dpos;\n    int mcu = 0, sub, csc;\n    int eob, sta;\n    bool is_baseline = true;\n    max_cmp = 0; // the maximum component in a truncated image\n    max_bpos = 0; // the maximum band in a truncated image\n    memset(max_dpos, 0, sizeof(max_dpos)); // the maximum dpos in a truncated image\n    max_sah = 0; // the maximum bit in a truncated image\n\n    // open huffman coded image data for input in abitreader\n    huffr = new abitreader( huffdata, hufs );\n    // preset count of scans\n    scnc = 0;\n\n    // JPEG decompression loop\n    while ( true )\n    {\n        // seek till start-of-scan, parse only DHT, DRI and SOS\n        for ( type = 0x00; type != 0xDA; ) {\n            if ( 3 + ( uint64_t ) hpos >= hdrs ) break;\n            type = hdrdata[ hpos + 1 ];\n            len = 2 + B_SHORT( hdrdata[ hpos + 2 ], hdrdata[ hpos + 3 ] );\n            if ( ( type == 0xC4 ) || ( type == 0xDA ) || ( type == 0xDD ) ) {\n                std::vector<unsigned char> over_data;\n                unsigned char * hdr_seg_data = NULL;\n                if ((uint64_t)hpos + (uint64_t)len > (uint64_t)hdrs) {\n                    over_data.insert(over_data.end(), &hdrdata[hpos], &hdrdata[hpos] + (hdrs - hpos));\n                    over_data.resize(len);\n                    hdr_seg_data = &over_data[0];\n                } else {\n                    hdr_seg_data = &( hdrdata[ hpos ] );\n                }\n                if ( !parse_jfif_jpg( type, len, len, hdr_seg_data ) ) {\n                    delete huffr;\n                    return false;\n                }\n            }\n            hpos += len;\n        }\n\n        // get out if last marker segment type was not SOS\n        if ( type != 0xDA ) break;\n\n        // check if huffman tables are available\n        for ( csc = 0; csc < cs_cmpc; csc++ ) {\n            cmp = cs_cmp[ csc ];\n            if ( (( jpegtype == 1 || (( cs_cmpc > 1 || cs_to == 0 ) && cs_sah == 0 )) && htset[ 0 ][ cmpnfo[cmp].huffdc ] == 0 ) || \n                 ( jpegtype == 1 && htset[ 1 ][ cmpnfo[cmp].huffdc ] == 0 ) ||\n                 ( cs_cmpc == 1 && cs_to > 0 && cs_sah == 0 && htset[ 1 ][ cmpnfo[cmp].huffac ] == 0 ) ) {\n                fprintf( stderr, \"huffman table missing in scan%i\", scnc );\n                delete huffr;\n                errorlevel.store(2);\n                return false;\n            }\n        }\n\n\n        // intial variables set for decoding\n        cmp  = cs_cmp[ 0 ];\n        csc  = 0;\n        mcu  = 0;\n        sub  = 0;\n        dpos = 0;\n        if (!huffr->eof) {\n            max_bpos = std::max(max_bpos, cs_to);\n            // FIXME: not sure why only first bit of cs_sah is examined but 4 bits of it are stored\n            max_sah = std::max(max_sah, std::max(cs_sal,cs_sah));\n            for (int i = 0; i < cs_cmpc; ++i) {\n                max_cmp = std::max(max_cmp, cs_cmp[i]);\n            }\n        }\n/*\n        // startup\n        luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                     huff_input_offsets,\n                                                                     mcu / mcuh,\n                                                                     lastdc,\n                                                                     cmpnfo[0].bcv / mcuv));\n*/\n        bool do_handoff_print = true;\n        // JPEG imagedata decoding routines\n        while ( true )\n        {\n            // (re)set last DCs for diff coding\n            lastdc[ 0 ] = 0;\n            lastdc[ 1 ] = 0;\n            lastdc[ 2 ] = 0;\n            lastdc[ 3 ] = 0;\n\n            // (re)set status\n            sta = 0;\n\n            // (re)set eobrun\n            eobrun  = 0;\n            peobrun = 0;\n\n            // (re)set rst wait counter\n            rstw = rsti;\n            if (cs_cmpc != colldata.get_num_components()) {\n                if (!g_allow_progressive) {\n                    custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n                } else {\n                    is_baseline = false;\n                }\n            }\n\n            if (jpegtype != 1) {\n                if (!g_allow_progressive) {\n                    custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n                } else {\n                    is_baseline = false;\n                }\n            }\n            // decoding for interleaved data\n            if ( cs_cmpc > 1 )\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential interleaved decoding <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         mcu / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n\n                        if(!huffr->eof) {\n                            max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block read\n                        }\n                        // decode block\n                        eob = decode_block_seq( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                            block.begin() );\n                        if ( eob > 1 && !block[ eob - 1 ] ) {\n                            fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                            errorlevel.store(1);\n                        }\n\n                        // fix dc\n                        block[ 0 ] += lastdc[ cmp ];\n                        lastdc[ cmp ] = block[ 0 ];\n\n                        AlignedBlock&aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n\n                        // copy to colldata\n                        for ( bpos = 0; bpos < eob; bpos++ ) {\n                            aligned_block.mutable_coefficients_zigzag(bpos) = block[ bpos ];\n                        }\n                        // check for errors, proceed if no error encountered\n                        int old_mcu = mcu;\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (mcu % mcuh == 0 && old_mcu !=  mcu) {\n                            do_handoff_print = true;\n                            //fprintf(stderr, \"ROW %d\\n\", (int)row_handoff.size());\n                            \n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else if ( cs_sah == 0 ) {\n                    // ---> progressive interleaved DC decoding <---\n                    // ---> succesive approximation first stage <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         mcu / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        sta = decode_dc_prg_fs( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            block.begin() );\n\n                        // fix dc for diff coding\n                        colldata.set((BlockType)cmp,0,dpos) = block[0] + lastdc[ cmp ];\n                        \n                        uint16_t u_last_dc = lastdc[ cmp ] = colldata.set((BlockType)cmp,0,dpos);\n                        u_last_dc <<= cs_sal; // lastdc might be negative--this avoids UB\n                        // bitshift for succesive approximation\n                        colldata.set((BlockType)cmp,0,dpos) = u_last_dc;\n\n                        // next mcupos if no error happened\n                        int old_mcu = mcu;\n                        if ( sta != -1 ) {\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        }\n                        if (mcu % mcuh == 0 && old_mcu !=  mcu) {\n                            do_handoff_print = true;\n                            //fprintf(stderr, \"ROW %d\\n\", (int)row_handoff.size());\n                            \n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else {\n                    // ---> progressive interleaved DC decoding <---\n                    // ---> succesive approximation later stage <---\n                    while ( sta == 0 ) {\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        // decode next bit\n                        sta = decode_dc_prg_sa( huffr,\n                            block.begin() );\n\n                        // shift in next bit\n                        colldata.set((BlockType)cmp,0,dpos) += block[0] << cs_sal;\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n            }\n            else // decoding for non interleaved data\n            {\n                if ( jpegtype == 1 ) {\n                    int vmul = cmpnfo[0].bcv / mcuv;\n                    int hmul = cmpnfo[0].bch / mcuh;\n                    // ---> sequential non interleaved decoding <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         (dpos/(hmul * vmul)) / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        // decode block\n                        eob = decode_block_seq( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                            block.begin() );\n                        if ( eob > 1 && !block[ eob - 1 ] ) {\n                            fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                            errorlevel.store(1);\n                        }\n                        // fix dc\n                        block[ 0 ] += lastdc[ cmp ];\n                        lastdc[ cmp ] = block[ 0 ];\n\n                        // copy to colldata\n                        AlignedBlock& aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                        for ( bpos = 0; bpos < eob; bpos++ ) {\n                            aligned_block.mutable_coefficients_zigzag(bpos) = block[ bpos ];\n                        }\n                        \n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcuposn( &cmp, &dpos, &rstw);\n                        mcu = dpos / (hmul * vmul);\n                        if (cmp == 0 && (mcu % mcuh == 0) && (dpos %(hmul *vmul) == 0)) {\n                            do_handoff_print = true;\n\n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else if ( cs_to == 0 ) {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved DC decoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            if (do_handoff_print) {\n                                luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                             huff_input_offsets,\n                                                                                             dpos / cmpnfo[cmp].bch,\n                                                                                             lastdc,\n                                                                                             cmpnfo[0].bcv / mcuv));\n                                do_handoff_print = false;\n                            }\n\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            sta = decode_dc_prg_fs( huffr,\n                                &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                block.begin() );\n\n                            // fix dc for diff coding\n                            colldata.set((BlockType)cmp,0,dpos) = block[0] + lastdc[ cmp ];\n                            lastdc[ cmp ] = colldata.set((BlockType)cmp,0,dpos);\n\n                            // bitshift for succesive approximation\n                            colldata.set((BlockType)cmp,0,dpos) <<= cs_sal;\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (cmp == 0 && dpos % cmpnfo[cmp].bch == 0) {\n                                do_handoff_print = true;\n                            }\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved DC decoding <---\n                        // ---> succesive approximation later stage <---\n                        while( sta == 0 ) {\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            // decode next bit\n                            sta = decode_dc_prg_sa( huffr,\n                                block.begin() );\n\n                            // shift in next bit\n                            colldata.set((BlockType)cmp,0,dpos) += block[0] << cs_sal;\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                }\n                else {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved AC decoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            // decode block\n                            eob = decode_ac_prg_fs( huffr,\n                                                    &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                    block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for non optimal coding\n                            if ( ( eob == cs_from ) && ( eobrun > 0 ) &&\n                                ( peobrun > 0 ) && ( peobrun <\n                                hcodes[ 1 ][ cmpnfo[cmp].huffac ].max_eobrun - 1 ) ) {\n                                fprintf( stderr,\n                                    \"reconstruction of non optimal coding not supported\" );\n                                errorlevel.store(1);\n                            }\n                            AlignedBlock &aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                            // copy to colldata\n                            for ( bpos = cs_from; bpos < eob; bpos++ ) {\n                                uint16_t block_bpos = block[ bpos ];\n                                block_bpos <<= cs_sal; // prevents UB since block_bpos could be negative\n                                aligned_block.mutable_coefficients_zigzag(bpos) = block_bpos;\n                            }\n                            // check for errors\n                            if ( eob < 0 ) sta = -1;\n                            else sta = skip_eobrun( &cmp, &dpos, &rstw, &eobrun );\n\n                            // proceed only if no error encountered\n                            if ( sta == 0 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved AC decoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            // copy from colldata\n                            AlignedBlock &aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] = aligned_block.coefficients_zigzag(bpos);\n                            }\n                            if ( eobrun == 0 ) {\n                                if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                                // decode block (long routine)\n                                eob = decode_ac_prg_sa( huffr,\n                                                        &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                        block.begin(), &eobrun, cs_from, cs_to );\n\n                                // check for non optimal coding\n                                if ( ( eob == cs_from ) && ( eobrun > 0 ) &&\n                                    ( peobrun > 0 ) && ( peobrun <\n                                    hcodes[ 1 ][ cmpnfo[cmp].huffac ].max_eobrun - 1 ) ) {\n                                    fprintf( stderr,\n                                        \"reconstruction of non optimal coding not supported\" );\n                                    errorlevel.store(1);\n                                }\n\n                            }\n                            else {\n                                if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                                // decode block (short routine)\n                                eob = decode_eobrun_sa( huffr,\n                                                        block.begin(), &eobrun, cs_from, cs_to );\n                                if ( eob > 1 && !block[ eob - 1 ] ) {\n                                    fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                                    errorlevel.store(1);\n                                }\n                            }\n                            // store eobrun\n                            peobrun = eobrun;\n                            // copy back to colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                uint16_t block_bpos = block[ bpos ];\n                                block_bpos <<= cs_sal;\n                                aligned_block.mutable_coefficients_zigzag(bpos) += block_bpos;\n                            }\n                            // proceed only if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            // unpad huffman reader / check padbit\n            if ( padbit != -1 ) {\n                if ( padbit != huffr->unpad( padbit ) ) {\n                    fprintf( stderr, \"inconsistent use of padbits\" );\n                    padbit = 1;\n                    errorlevel.store(1);\n                }\n            }\n            else {\n                padbit = huffr->unpad( padbit );\n            }\n            // evaluate status\n            if ( sta == -1 ) { // status -1 means error\n                fprintf( stderr, \"decode error in scan%i / mcu%i\",\n                    scnc, ( cs_cmpc > 1 ) ? mcu : dpos );\n                delete huffr;\n                errorlevel.store(2);\n                return false;\n            }\n            else if ( sta == 2 ) { // status 2/3 means done\n                scnc++; // increment scan counter\n                break; // leave decoding loop, everything is done here\n            }\n            // else if ( sta == 1 ); // status 1 means restart - so stay in the loop\n        }\n    }\n    if (early_eof_encountered) {\n        colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n    }\n    luma_row_offset_return->push_back(crystallize_thread_handoff(huffr, huff_input_offsets, (uint16_t)(mcu / mcuh), lastdc, cmpnfo[0].bcv / mcuv));\n    for (size_t i = 1; i < luma_row_offset_return->size(); ++i) {\n        if ((*luma_row_offset_return)[i].luma_y_start < \n            (*luma_row_offset_return)[i-1].luma_y_end) {\n            (*luma_row_offset_return)[i].luma_y_start = (*luma_row_offset_return)[i-1].luma_y_end;\n        }\n    }\n    // check for unneeded data\n    if ( !huffr->eof ) {\n        fprintf( stderr, \"unneeded data found after coded image data\" );\n        errorlevel.store(1);\n    }\n\n    // clean up\n    delete( huffr );\n\n    if (is_baseline) {\n        g_allow_progressive = false;\n    }\n    return true;\n}\n\n\n/* -----------------------------------------------\n    JPEG encoding routine\n    ----------------------------------------------- */\n\nbool recode_jpeg( void )\n{\n    if (!g_use_seccomp) {\n        pre_byte = clock();\n    }\n    abitwriter*  huffw; // bitwise writer for image data\n    abytewriter* storw; // bytewise writer for storage of correction bits\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // current position in header\n\n    int lastdc[ 4 ]; // last dc for each component\n    Sirikata::Aligned256Array1d<int16_t, 64> block; // store block for coeffs\n    unsigned int eobrun; // run of eobs\n    int rstw; // restart wait counter\n\n    int cmp, bpos, dpos;\n    int mcu, sub, csc;\n    int eob, sta;\n    int tmp;\n\n    // open huffman coded image data in abitwriter\n    huffw = new abitwriter( ABIT_WRITER_PRELOAD, max_file_size);\n    huffw->fillbit = padbit;\n\n    // init storage writer\n    storw = new abytewriter( ABIT_WRITER_PRELOAD);\n\n    // preset count of scans and restarts\n    scnc = 0;\n    rstc = 0;\n    MergeJpegProgress streaming_progress;\n\n    // JPEG decompression loop\n    while ( true )\n    {\n        // seek till start-of-scan, parse only DHT, DRI and SOS\n        for ( type = 0x00; type != 0xDA; ) {\n            if ( hpos >= hdrs ) break;\n            type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0;\n            len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n            if ( ( type == 0xC4 ) || ( type == 0xDA ) || ( type == 0xDD ) ) {\n                if ( !parse_jfif_jpg( type, len, len > hdrs - hpos ? hdrs - hpos : len, &( hdrdata[ hpos ] ) ) ) {\n                    delete huffw;\n                    delete storw;\n                    return false;\n                }\n                int max_scan = 0;\n                for (int i = 0; i < cmpc; ++i) {\n                    max_scan = std::max(max_scan, cmpnfo[i].bcv);\n                }\n                rstp.reserve(max_scan);\n                scnp.reserve(max_scan);\n                hpos += len;\n            }\n            else {\n                hpos += len;\n                continue;\n            }\n        }\n\n        // get out if last marker segment type was not SOS\n        if ( type != 0xDA ) break;\n\n\n        // (re)alloc scan positons array\n        while ((int)scnp.size() < scnc + 2) {\n            scnp.push_back(0);\n        }\n\n        // (re)alloc restart marker positons array if needed\n        if ( rsti > 0 ) {\n            tmp = rstc + ( ( cs_cmpc > 1 ) ?\n                ( mcuc / rsti ) : ( cmpnfo[ cs_cmp[ 0 ] ].bc / rsti ) );\n            while ((int)rstp.size() <= tmp ) {\n                rstp.push_back((unsigned int) -1 );\n            }\n        }\n\n        // intial variables set for encoding\n        cmp  = cs_cmp[ 0 ];\n        csc  = 0;\n        mcu  = 0;\n        sub  = 0;\n        dpos = 0;\n\n        // store scan position\n        scnp.at(scnc) = huffw->getpos();\n        scnp.at(scnc + 1) = 0; // danielrh@ avoid uninitialized memory when doing progressive writeout\n        bool first_pass = true;\n        // JPEG imagedata encoding routines\n        while ( true )\n        {\n            // (re)set last DCs for diff coding\n            lastdc[ 0 ] = 0;\n            lastdc[ 1 ] = 0;\n            lastdc[ 2 ] = 0;\n            lastdc[ 3 ] = 0;\n\n            // (re)set status\n            sta = 0;\n\n            // (re)set eobrun\n            eobrun = 0;\n\n            // (re)set rst wait counter\n            rstw = rsti;\n            if (cs_cmpc != colldata.get_num_components() && !g_allow_progressive) {\n                custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n            }\n            if (jpegtype != 1 && !g_allow_progressive) {\n                custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n            }\n            if ((jpegtype != 1 || cs_cmpc != colldata.get_num_components())\n                && colldata.is_memory_optimized(0)\n                && first_pass) {\n                colldata.init(cmpnfo, cmpc, mcuh, mcuv, false);\n            }\n            first_pass = false;\n            // encoding for interleaved data\n            if ( cs_cmpc > 1 )\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential interleaved encoding <---\n                    while ( sta == 0 ) {\n                        // copy from colldata\n                        const AlignedBlock &aligned_block = colldata.block((BlockType)cmp, dpos);\n                        //fprintf(stderr, \"Reading from cmp(%d) dpos %d\\n\", cmp, dpos);\n                        for ( bpos = 0; bpos < 64; bpos++ ) {\n                            block[bpos] = aligned_block.coefficients_zigzag(bpos);\n                        }\n                        int16_t dc = block[0];\n                        // diff coding for dc\n                        block[ 0 ] -= lastdc[ cmp ];\n                        lastdc[ cmp ] = dc;\n\n                        // encode block\n                        eob = encode_block_seq( huffw,\n                                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                block.begin() );\n\n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else if ( cs_sah == 0 ) {\n                    // ---> progressive interleaved DC encoding <---\n                    // ---> succesive approximation first stage <---\n                    while ( sta == 0 ) {\n                        // diff coding & bitshifting for dc\n                        tmp = colldata.at((BlockType)cmp , 0 , dpos ) >> cs_sal;\n                        block[ 0 ] = tmp - lastdc[ cmp ];\n                        lastdc[ cmp ] = tmp;\n\n                        // encode dc\n                        sta = encode_dc_prg_fs( huffw,\n                                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                block.begin() );\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else {\n                    // ---> progressive interleaved DC encoding <---\n                    // ---> succesive approximation later stage <---\n                    while ( sta == 0 ) {\n                        // fetch bit from current bitplane\n                        block[ 0 ] = BITN( colldata.at((BlockType)cmp , 0 , dpos ), cs_sal );\n\n                        // encode dc correction bit\n                        sta = encode_dc_prg_sa( huffw, block.begin() );\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n\n                    }\n                }\n            }\n            else // encoding for non interleaved data\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential non interleaved encoding <---\n                    while ( sta == 0 ) {\n                        const AlignedBlock& aligned_block = colldata.block((BlockType)cmp, dpos);\n                        // copy from colldata\n                        int16_t dc = block[ 0 ] = aligned_block.dc();\n                        for ( bpos = 1; bpos < 64; bpos++ )\n                            block[ bpos ] = aligned_block.coefficients_zigzag(bpos);\n\n                        // diff coding for dc\n                        block[ 0 ] -= lastdc[ cmp ];\n                        lastdc[ cmp ] = dc;\n\n                        // encode block\n                        eob = encode_block_seq( huffw,\n                            &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                block.begin() );\n\n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcuposn( &cmp, &dpos, &rstw);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n\n                    }\n                }\n                else if ( cs_to == 0 ) {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved DC encoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            // diff coding & bitshifting for dc\n                            tmp = colldata.at((BlockType)cmp , 0 , dpos ) >> cs_sal;\n                            block[ 0 ] = tmp - lastdc[ cmp ];\n                            lastdc[ cmp ] = tmp;\n\n                            // encode dc\n                            sta = encode_dc_prg_fs( huffw,\n                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                    block.begin() );\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved DC encoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            // fetch bit from current bitplane\n                            block[ 0 ] = BITN( colldata.at((BlockType)cmp , 0 , dpos ), cs_sal );\n\n                            // encode dc correction bit\n                            sta = encode_dc_prg_sa( huffw, block.begin() );\n\n                            // next mcupos if no error happened\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved AC encoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            const AlignedBlock& aligned_block = colldata.block((BlockType)cmp, dpos);\n                            // copy from colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] =\n                                    FDIV2( aligned_block.coefficients_zigzag(bpos), cs_sal );\n                            }\n                            // encode block\n                            eob = encode_ac_prg_fs( huffw,\n                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                    block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for errors, proceed if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n\n                        // encode remaining eobrun\n                        encode_eobrun( huffw,\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                            &eobrun );\n\n                    }\n                    else {\n                        // ---> progressive non interleaved AC encoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            const AlignedBlock& aligned_block= colldata.block((BlockType)cmp, dpos);\n                            // copy from colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] =\n                                    FDIV2( aligned_block.coefficients_zigzag(bpos), cs_sal );\n                            }\n                            // encode block\n                            eob = encode_ac_prg_sa( huffw, storw,\n                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for errors, proceed if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n\n                        // encode remaining eobrun\n                        encode_eobrun( huffw,\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                            &eobrun );\n\n                        // encode remaining correction bits\n                        encode_crbits( huffw, storw );\n                    }\n                }\n            }\n\n            // pad huffman writer\n            huffw->pad( padbit );\n\n            // evaluate status\n            if ( sta == -1 ) { // status -1 means error\n                fprintf( stderr, \"encode error in scan%i / mcu%i\",\n                    scnc, ( cs_cmpc > 1 ) ? mcu : dpos );\n                delete huffw;\n                errorlevel.store(2);\n                return false;\n            }\n            else if ( sta == 2 ) { // status 2 means done\n                scnc++; // increment scan counter\n                break; // leave decoding loop, everything is done here\n            }\n            else if ( sta == 1 ) { // status 1 means restart\n                if ( rsti > 0 ) // store rstp & stay in the loop\n                    rstp.at(rstc++) = huffw->getpos() - 1;\n            }\n            huffw->flush_no_pad();\n            dev_assert(huffw->no_remainder() && \"this should have been padded\");\n            if (huffw->no_remainder()) {\n                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n            }\n        }\n    }\n\n    // safety check for error in huffwriter\n    if ( huffw->error ) {\n        delete huffw;\n        fprintf( stderr, MEM_ERRMSG );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // get data into huffdata\n    huffdata = huffw->getptr();\n    hufs = huffw->getpos();\n    always_assert(huffw->no_remainder() && \"this should have been padded\");\n    merge_jpeg_streaming(&streaming_progress, huffdata, hufs, true);\n    if (!fast_exit) {\n        delete huffw;\n\n        // remove storage writer\n        delete storw;\n    }\n    // store last scan & restart positions\n    if (scnc >= scnp.size()) {\n        delete huffw;\n        fprintf( stderr, MEM_ERRMSG );\n        errorlevel.store(2);\n        return false;\n    }\n    scnp.at(scnc) = hufs;\n    if ( !rstp.empty() )\n        rstp.at(rstc) = hufs;\n\n\n    return true;\n}\n\n\n\n\n/* -----------------------------------------------\n    checks range of values, error if out of bounds\n    ----------------------------------------------- */\n\nbool check_value_range( void )\n{\n    int bad_cmp = 0, bad_bpos = 0, bad_dpos = 0;\n    bool bad_colldata = false;\n    // out of range should never happen with unmodified JPEGs\n    for (int cmp = 0; cmp < cmpc && cmp < 4; cmp++ ) {\n        int absmax[64];\n        for (int bpos = 0; bpos < 64; bpos++ ) {\n            absmax[zigzag_to_aligned.at(bpos)] = MAX_V( cmp, bpos );\n        }\n        for (int dpos = 0; dpos < cmpnfo[cmp].bc && dpos <= max_dpos[cmp] ; dpos++ ) {\n            const int16_t * raw_data = colldata.block_nosync((BlockType)cmp, dpos).raw_data();\n            for (int aligned_pos = 0; aligned_pos < 64; ++aligned_pos, ++raw_data) {\n                if ((*raw_data) > absmax[aligned_pos] ||\n                    (*raw_data) < -absmax[aligned_pos]) {\n                    int bpos = aligned_to_zigzag.at(aligned_pos);\n                    if (!early_eof_encountered) {\n                        fprintf( stderr, \"value out of range error: cmp%i, frq%i, val %i, max %i\",\n                             cmp, bpos, colldata.at_nosync((BlockType)cmp,bpos,dpos), absmax[aligned_pos] );\n                        errorlevel.store(2);\n                        return false;\n                    }\n                    bad_cmp = cmp;\n                    bad_bpos = bpos;\n                    bad_dpos = dpos;\n                    colldata.set((BlockType)bad_cmp, bad_bpos, bad_dpos) = 0; // zero this puppy out\n                    bad_colldata = true;\n                }\n            }\n        }\n    }\n    if (bad_colldata) {\n        colldata.set((BlockType)bad_cmp, bad_bpos, bad_dpos) = 0; // zero this puppy out\n    }\n    return true;\n}\n\n\nclass ThreadHandoffSegmentCompare {\npublic: bool operator() (const ThreadHandoff &a,\n                         const ThreadHandoff &b) const {\n    return a.segment_size < b.segment_size;\n}\n};\n\n/* -----------------------------------------------\n    write uncompressed JPEG file\n    ----------------------------------------------- */\nbool write_ujpg(std::vector<ThreadHandoff> row_thread_handoffs,\n                std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >*jpeg_file_raw_bytes)\n{\n    unsigned char ujpg_mrk[ 64 ];\n    bool has_lepton_entropy_coding = (ofiletype == LEPTON || filetype == LEPTON );\n    Sirikata::JpegError err = Sirikata::JpegError::nil();\n\n    if (!has_lepton_entropy_coding) {\n        // UJG-Header\n        err = ujg_out->Write( ujg_header, 2 ).second;\n    } else {\n        // lepton-Header\n        err = ujg_out->Write( lepton_header, 2 ).second;\n    }\n    // store version number\n    ujpg_mrk[ 0 ] = ujgversion;\n    ujg_out->Write( ujpg_mrk, 1 );\n\n    // discard meta information from header if needed\n    if ( disc_meta )\n        if ( !rebuild_header_jpg() )\n            return false;\n    if (start_byte) {\n        std::vector<ThreadHandoff> local_row_thread_handoffs;\n        for (std::vector<ThreadHandoff>::iterator i = row_thread_handoffs.begin(),\n                 ie = row_thread_handoffs.end(); i != ie; ++i) {\n            auto j = i;\n            ++j;\n            if ((j == ie || i->segment_size >= start_byte)\n                && (max_file_size == 0 || i->segment_size <= max_file_size + start_byte)) {\n                local_row_thread_handoffs.push_back(*i);\n                //fprintf(stderr, \"OK: %d (%d %d)\\n\", i->segment_size, i->luma_y_start, i->luma_y_end);\n            } else {\n                //fprintf(stderr, \"XX: %d (%d %d)\\n\", i->segment_size, i->luma_y_start, i->luma_y_end);\n            }\n        }\n        row_thread_handoffs.swap(local_row_thread_handoffs);\n    }\n    if (start_byte) {\n        always_assert(jpeg_file_raw_bytes);\n    }\n    if (start_byte && jpeg_file_raw_bytes && !row_thread_handoffs.empty()) { // FIXME: respect jpeg_embedding?\n        if (row_thread_handoffs[0].segment_size >= start_byte) {\n            prefix_grbs = row_thread_handoffs[0].segment_size - start_byte;\n            if (row_thread_handoffs.size() > 1) {\n                if (prefix_grbs) {\n                    --prefix_grbs; //FIXME why is this ?!\n                }\n            }\n        } else {\n            prefix_grbs = 0;\n            custom_exit(ExitCode::ONLY_GARBAGE_NO_JPEG);\n        }\n        if (prefix_grbs > 0) {\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            always_assert(jpeg_file_raw_bytes->size() >= (size_t)prefix_grbs + start_byte);\n            memcpy(prefix_grbgdata,\n                   &(*jpeg_file_raw_bytes)[start_byte],\n                   std::min((size_t)prefix_grbs,\n                            jpeg_file_raw_bytes->size() - start_byte));\n        } else {\n            prefix_grbgdata = aligned_alloc(1); // so it's nonnull\n            prefix_grbgdata[0] = 0;\n        }\n    }\n    Sirikata::MemReadWriter mrw((Sirikata::JpegAllocator<uint8_t>()));\n#if 0\n    for (uint32_t i = 0; i < row_thread_handoffs.size() ; ++ i) {\n        fprintf(stderr,\n                \"Row [%d - %d], %d size %d overhang byte %d num overhang bits %d  dc %d %d %d\\n\",\n                (int)row_thread_handoffs[i].luma_y_start,\n                (int)row_thread_handoffs[i].luma_y_end,\n                (int)i,\n                (int)row_thread_handoffs[i].segment_size,\n                (int)row_thread_handoffs[i].overhang_byte,\n                (int)row_thread_handoffs[i].num_overhang_bits,\n                (int)row_thread_handoffs[i].last_dc[0],\n                (int)row_thread_handoffs[i].last_dc[1],\n                (int)row_thread_handoffs[i].last_dc[2]);\n    }\n#endif\n    uint32_t framebuffer_byte_size = row_thread_handoffs.back().segment_size - row_thread_handoffs.front().segment_size;\n    uint32_t num_rows = row_thread_handoffs.size();\n    NUM_THREADS = std::min(NUM_THREADS, (unsigned int)max_encode_threads);\n    if (num_rows / 2 < NUM_THREADS) {\n        unsigned int desired_count = std::max((unsigned int)num_rows / 2,\n                                              (unsigned int)min_encode_threads);\n        NUM_THREADS = std::min(std::max(desired_count, 1U), (unsigned int)NUM_THREADS);\n    }\n    if (framebuffer_byte_size < 125000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 1U), (unsigned int)NUM_THREADS);\n    } else if (framebuffer_byte_size < 250000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 2U), (unsigned int)NUM_THREADS);\n    } else if (framebuffer_byte_size < 500000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 4U), (unsigned int)NUM_THREADS);\n    }\n    //fprintf(stderr, \"Byte size %d num_rows %d Using num threads %u\\n\", framebuffer_byte_size, num_rows, NUM_THREADS);\n    std::vector<ThreadHandoff> selected_splits(NUM_THREADS);\n    std::vector<int> split_indices(NUM_THREADS);\n    for (uint32_t i = 0; g_even_thread_split == false && i < NUM_THREADS - 1 ; ++ i) {\n        ThreadHandoff desired_handoff = row_thread_handoffs.back();\n        if(max_file_size && max_file_size + start_byte < desired_handoff.segment_size) {\n            desired_handoff.segment_size += row_thread_handoffs.front().segment_size;\n        }\n        desired_handoff.segment_size -= row_thread_handoffs.front().segment_size;\n        \n        desired_handoff.segment_size *= (i + 1);\n        desired_handoff.segment_size /= NUM_THREADS;\n        desired_handoff.segment_size += row_thread_handoffs.front().segment_size;\n        auto split = std::lower_bound(row_thread_handoffs.begin() + 1, row_thread_handoffs.end(),\n                                      desired_handoff,\n                                      ThreadHandoffSegmentCompare());\n        if (split == row_thread_handoffs.begin() && split != row_thread_handoffs.end()) {\n            //++split;\n        } else if (split != row_thread_handoffs.begin() + 1) {\n            --split;\n        }\n        split_indices[i] = split - row_thread_handoffs.begin();\n    }\n    for (uint32_t i = 0; g_even_thread_split && i < NUM_THREADS - 1 ; ++ i) {\n        split_indices[i] = row_thread_handoffs.size() * (i + 1) / NUM_THREADS;\n    }\n    for (uint32_t index = 0; index < NUM_THREADS - 1 ; ++ index) {\n        if (split_indices[index] == split_indices[index + 1]) {\n            for (uint32_t i = 0; i < NUM_THREADS - 1 ; ++ i) {\n                split_indices[i] = (i + 1) * row_thread_handoffs.size() / NUM_THREADS;\n            }\n            break;\n        }\n    }\n    split_indices[NUM_THREADS - 1] = row_thread_handoffs.size() - 1;\n    size_t last_split_index = 0;\n    for (size_t i = 0; i < selected_splits.size(); ++i) {\n        size_t beginning_of_range = last_split_index;\n        size_t end_of_range = split_indices[i];\n        //fprintf(stderr, \"Beginning %ld end %ld\\n\", beginning_of_range, end_of_range);\n        last_split_index = end_of_range;\n        always_assert( end_of_range < row_thread_handoffs.size() );\n        selected_splits[i] = row_thread_handoffs[ end_of_range ] - row_thread_handoffs[ beginning_of_range ];\n        if (i + 1 == selected_splits.size() && row_thread_handoffs[ end_of_range ].num_overhang_bits) {\n            ++selected_splits[i].segment_size; // need room for that last byte to hold the overhang byte\n        }\n#if 0\n        fprintf(stderr, \"%d->%d) %d - %d {%ld}\\n\", selected_splits[i].luma_y_start,\n                selected_splits[i].luma_y_end, \n                row_thread_handoffs[ beginning_of_range ].segment_size,\n                row_thread_handoffs[ end_of_range ].segment_size, row_thread_handoffs.size());\n#endif\n/*\n        if (i + 1 == selected_splits.size()) {\n            int tmp = selected_splits[i].segment_size;\n            selected_splits[i].segment_size = jpgfilesize - row_thread_handoffs[ beginning_of_range ].segment_size;\n            fprintf(stderr, \"Split size was %x and is %x - %x = %x\\n\", tmp, jpgfilesize, row_thread_handoffs[ beginning_of_range ].segment_size, selected_splits[i].segment_size);\n        }\n*/\n    }\n#if 0\n    for (uint32_t i = 0; i < selected_splits.size() ; ++ i) {\n        fprintf(stderr,\n                \"Row [%d - %d] %d size %d overhang byte %d num overhang bits %d  dc %d %d %d\\n\",\n                (int)selected_splits[i].luma_y_start,\n                (int)selected_splits[i].luma_y_end,\n\n                (int)i,\n                (int)selected_splits[i].segment_size,\n                (int)selected_splits[i].overhang_byte,\n                (int)selected_splits[i].num_overhang_bits,\n                (int)selected_splits[i].last_dc[0],\n                (int)selected_splits[i].last_dc[1],\n                (int)selected_splits[i].last_dc[2]);\n    }\n#endif\n\n    always_assert(start_byte||!selected_splits[0].luma_y_start);\n    // write header to file\n    // marker: \"HDR\" + [size of header]\n    unsigned char hdr_mrk[] = {'H', 'D', 'R'};\n    err = mrw.Write( hdr_mrk, sizeof(hdr_mrk) ).second;\n    uint32toLE(hdrs, ujpg_mrk);\n    err = mrw.Write( ujpg_mrk, 4).second;\n    // data: data from header\n    mrw.Write( hdrdata, hdrs );\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // marker: P0D\"\n    unsigned char pad_mrk[] = {'P', '0', 'D'};\n    err = mrw.Write( pad_mrk, sizeof(pad_mrk) ).second;\n    // data: padbit\n    err = mrw.Write( (unsigned char*) &padbit, 1 ).second;\n\n    // write luma splits\n    unsigned char luma_mrk[1] = {'H'};\n    err = mrw.Write( luma_mrk, sizeof(luma_mrk) ).second;\n    // data: serialized luma splits\n    auto serialized_splits = ThreadHandoff::serialize(&selected_splits[0], selected_splits.size());\n    err = mrw.Write(&serialized_splits[0], serialized_splits.size()).second;\n\n    if (!rst_cnt.empty()) {\n        unsigned char frs_mrk[] = {'C', 'R', 'S'};\n        err = mrw.Write( frs_mrk, 3 ).second;\n        uint32toLE((uint32_t)rst_cnt.size(), ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4).second;\n        for (size_t i = 0; i < rst_cnt.size(); ++i) {\n            uint32toLE((uint32_t)rst_cnt.at(i), ujpg_mrk);\n            err = mrw.Write( ujpg_mrk, 4).second;\n        }\n    }\n    // write number of false set RST markers per scan (if available) to file\n    if (!rst_err.empty()) {\n        // marker: \"FRS\" + [number of scans]\n        unsigned char frs_mrk[] = {'F', 'R', 'S'};\n        err = mrw.Write( frs_mrk, 3 ).second;\n        uint32toLE((uint32_t)rst_err.size(), ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4).second;\n        // data: numbers of false set markers\n        err = mrw.Write( rst_err.data(), rst_err.size() ).second;\n    }\n    if (early_eof_encountered) {\n        unsigned char early_eof[] = {'E', 'E', 'E'};\n        err = mrw.Write( early_eof, sizeof(early_eof) ).second;\n        uint32toLE(max_cmp, ujpg_mrk);\n        uint32toLE(max_bpos, ujpg_mrk + 4);\n        uint32toLE(max_sah, ujpg_mrk + 8);\n        uint32toLE(max_dpos[0], ujpg_mrk + 12);\n        uint32toLE(max_dpos[1], ujpg_mrk + 16);\n        uint32toLE(max_dpos[2], ujpg_mrk + 20);\n        uint32toLE(max_dpos[3], ujpg_mrk + 24);\n        err = mrw.Write(ujpg_mrk, 28).second;\n    }\n    // write garbage (data including and after EOI) (if any) to file\n    if ( prefix_grbs > 0 || prefix_grbgdata != NULL) {\n        // marker: \"GRB\" + [size of garbage]\n        unsigned char grb_mrk[] = {'P', 'G', embedded_jpeg ? (unsigned char)'E': (unsigned char)'R'};\n        err = mrw.Write( grb_mrk, sizeof(grb_mrk) ).second;\n        uint32toLE(prefix_grbs, ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4 ).second;\n        // data: garbage data\n        err = mrw.Write( prefix_grbgdata, prefix_grbs ).second;\n    }\n    // write garbage (data including and after EOI) (if any) to file\n    if ( grbs > 0 ) {\n        // marker: \"GRB\" + [size of garbage]\n        unsigned char grb_mrk[] = {'G', 'R', 'B'};\n        err = mrw.Write( grb_mrk, sizeof(grb_mrk) ).second;\n        uint32toLE(grbs, ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4 ).second;\n        // data: garbage data\n        err = mrw.Write( grbgdata, grbs ).second;\n    }\n    if (mrw.buffer().size() > 1024 * 1024) {\n        //custom_exit(ExitCode::HEADER_TOO_LARGE);\n    }\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> > compressed_header;\n    if (ujgversion == 1) {\n        compressed_header =\n            Sirikata::ZlibDecoderCompressionWriter::Compress(mrw.buffer().data(),\n                                                             mrw.buffer().size(),\n                                                             Sirikata::JpegAllocator<uint8_t>());\n    } else {\n        compressed_header = Sirikata::BrotliCodec::Compress(mrw.buffer().data(),\n                                                            mrw.buffer().size(),\n                                                            Sirikata::JpegAllocator<uint8_t>());\n    }\n    write_byte_bill(Billing::HEADER, false, 2 + hdrs + prefix_grbs + grbs);\n    static_assert(MAX_NUM_THREADS <= 255, \"We only have a single byte for num threads\");\n    always_assert(NUM_THREADS <= 255);\n    unsigned char zed[] = {'\\0'};\n    if (start_byte != 0) {\n        zed[0] = (unsigned char)'Y';\n    } else if (g_allow_progressive) {\n        zed[0] = (unsigned char)'X';\n    } else {\n        zed[0] = (unsigned char)'Z';\n    }\n    err =  ujg_out->Write(zed, sizeof(zed)).second;\n    unsigned char num_threads[] = {(unsigned char)NUM_THREADS};\n    err =  ujg_out->Write(num_threads, sizeof(num_threads)).second;\n    unsigned char zero3[3] = {};\n    err =  ujg_out->Write(zero3, sizeof(zero3)).second;\n    unsigned char git_revision[12] = {0}; // we only have 12 chars in the header for this\n    hex_to_bin(git_revision, GIT_REVISION, sizeof(git_revision));\n    err = ujg_out->Write(git_revision, sizeof(git_revision) ).second;\n    uint32toLE(jpgfilesize - start_byte, ujpg_mrk);\n    err = ujg_out->Write( ujpg_mrk, 4).second;\n    write_byte_bill(Billing::HEADER, true, 24);\n    uint32toLE((uint32_t)compressed_header.size(), ujpg_mrk);\n    err = ujg_out->Write( ujpg_mrk, 4).second;\n    write_byte_bill(Billing::HEADER, true, 4);\n    auto err2 = ujg_out->Write(compressed_header.data(),\n                               compressed_header.size());\n    write_byte_bill(Billing::HEADER, true, compressed_header.size());\n    zlib_hdrs = compressed_header.size();\n    if (err != Sirikata::JpegError::nil() || err2.second != Sirikata::JpegError::nil()) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return false;\n    }\n    unsigned char cmp_mrk[] = {'C', 'M', 'P'};\n    err = ujg_out->Write( cmp_mrk, sizeof(cmp_mrk) ).second;\n    write_byte_bill(Billing::HEADER, true, 3);\n    while (g_encoder->encode_chunk(&colldata, ujg_out,\n                                   &selected_splits[0], selected_splits.size()) == CODING_PARTIAL) {\n    }\n    \n    // errormessage if write error\n    if ( err != Sirikata::JpegError::nil() ) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // get filesize, if avail\n    if (ujg_out) {\n        ujgfilesize = ujg_out->getsize();\n    }\n\n\n    return true;\n}\n\n\n/* -----------------------------------------------\n    read uncompressed JPEG file\n    ----------------------------------------------- */\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\nvoid mem_nop (void *opaque, void *ptr){\n\n}\nvoid * mem_init_nop(size_t prealloc_size, uint8_t align){\n    return NULL;\n}\nvoid* mem_realloc_nop(void * ptr, size_t size, size_t *actualSize, unsigned int movable, void *opaque){\n    return NULL;\n}\n#endif\n\nSirikata::MemReadWriter *header_reader = NULL;\n\nbool read_ujpg( void )\n{\n    using namespace IOUtil;\n    using namespace Sirikata;\n//    colldata.start_decoder_worker_thread(std::bind(&simple_decoder, &colldata, str_in));\n    unsigned char ujpg_mrk[ 64 ];\n    // this is where we will enable seccomp, before reading user data\n    write_byte_bill(Billing::HEADER, true, 24); // for the fixed header\n\n    str_out->call_size_callback(max_file_size);\n    uint32_t compressed_header_size = 0;\n    if (ReadFull(str_in, ujpg_mrk, 4) != 4) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    write_byte_bill(Billing::HEADER, true, 4);\n\n    compressed_header_size = LEtoUint32(ujpg_mrk);\n    if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {\n        always_assert(false && \"Only support images < 128 megs\");\n        return false; // bool too big\n    }\n    bool pending_header_reads = false;\n    if (header_reader == NULL) {\n        std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);\n        IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());\n        header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));\n        {\n            if (ujgversion == 1) {\n                JpegAllocator<uint8_t> no_free_allocator;\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\n                no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,\n                                                         16,\n                                                         &mem_init_nop,\n                                                         &MemMgrAllocatorMalloc,\n                                                         &mem_nop,\n                                                         &mem_realloc_nop,\n                                                         &MemMgrAllocatorMsize);\n#endif\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),\n                                                                         compressed_header_buffer.size(),\n                                                                         no_free_allocator,\n                                                                         max_file_size + 2048));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);\n            } else {\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),\n                                                                compressed_header_buffer.size(),\n                                                                JpegAllocator<uint8_t>(),\n                                                                max_file_size * 2 + 128 * 1024 * 1024));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);            \n            }\n        }\n        write_byte_bill(Billing::HEADER,\n                        true,\n                        compressed_header_buffer.size());\n    } else {\n        always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");\n    }\n    grbs = sizeof(EOI);\n    grbgdata = EOI; // if we don't have any garbage, assume FFD9 EOI\n    // read header from file\n    ReadFull(header_reader, ujpg_mrk, 3 ) ;\n    // check marker\n    if ( memcmp( ujpg_mrk, \"HDR\", 3 ) == 0 ) {\n        // read size of header, alloc memory\n        ReadFull(header_reader, ujpg_mrk, 4 );\n        hdrs = LEtoUint32(ujpg_mrk);\n        hdrdata = (unsigned char*) aligned_alloc(hdrs);\n        memset(hdrdata, 0, hdrs);\n        if ( hdrdata == NULL ) {\n            fprintf( stderr, MEM_ERRMSG );\n            errorlevel.store(2);\n            return false;\n        }\n        // read hdrdata\n        ReadFull(header_reader, hdrdata, hdrs );\n    }\n    else {\n        fprintf( stderr, \"HDR marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;\n    // parse header for image-info\n    if ( !setup_imginfo_jpg(memory_optimized_image) )\n        return false;\n\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // read padbit information from file\n    ReadFull(header_reader, ujpg_mrk, 3 );\n    // check marker\n    if ( memcmp( ujpg_mrk, \"P0D\", 3 ) == 0 ) {\n        // This is a more nuanced pad byte that can have different values per bit\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n    }\n    else if ( memcmp( ujpg_mrk, \"PAD\", 3 ) == 0 ) {\n        // this is a single pad bit that is implied to have all the same values\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n        if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {\n            while (write(2,\n                        \"Legacy Padbit must be 0, 1 or -1\\n\",\n                         strlen(\"Legacy Padbit must be 0, 1 or -1\\n\")) < 0\n                   && errno == EINTR) {\n            }\n            custom_exit(ExitCode::STREAM_INCONSISTENT);\n        }\n        if (padbit == 1) {\n            padbit = 0x7f; // all 6 bits set\n        }\n    }\n    else {\n        fprintf( stderr, \"PAD marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    std::vector<ThreadHandoff> thread_handoff;\n    // read further recovery information if any\n    while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {\n        // check marker\n        if ( memcmp( ujpg_mrk, \"CRS\", 3 ) == 0 ) {\n            rst_cnt_set = true;\n            ReadFull(header_reader, ujpg_mrk, 4);\n            rst_cnt.resize(LEtoUint32(ujpg_mrk));\n            for (size_t i = 0; i < rst_cnt.size(); ++i) {\n                ReadFull(header_reader, ujpg_mrk, 4);\n                rst_cnt.at(i) = LEtoUint32(ujpg_mrk);\n            }\n        } else if ( memcmp( ujpg_mrk, \"HHX\", 2 ) == 0 ) { // only look at first two bytes\n            size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;\n            if(to_alloc) {\n                std::vector<unsigned char> data(to_alloc);\n                data[0] = ujpg_mrk[1];\n                data[1] = ujpg_mrk[2];\n                ReadFull(header_reader, &data[2], to_alloc - 2);\n                thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);\n            }\n        } else if ( memcmp( ujpg_mrk, \"FRS\", 3 ) == 0 ) {\n            // read number of false set RST markers per scan from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            scnc = LEtoUint32(ujpg_mrk);\n            \n            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n            // read data\n            ReadFull(header_reader, rst_err.data(), scnc );\n        }\n        else if ( memcmp( ujpg_mrk, \"GRB\", 3 ) == 0 ) {\n            // read garbage (data after end of JPG) from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            grbs = LEtoUint32(ujpg_mrk);\n            grbgdata = aligned_alloc(grbs);\n            memset(grbgdata, 0, sizeof(grbs));\n            if ( grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, grbgdata, grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"PGR\", 3 ) == 0 || memcmp( ujpg_mrk, \"PGE\", 3 ) == 0 ) {\n            // read prefix garbage (data before beginning of JPG) from file\n            if (ujpg_mrk[2] == 'E') {\n                // embedded jpeg: full header required\n                embedded_jpeg = true;\n            }\n            ReadFull(header_reader, ujpg_mrk, 4);\n            prefix_grbs = LEtoUint32(ujpg_mrk);\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            memset(prefix_grbgdata, 0, sizeof(prefix_grbs));\n            if ( prefix_grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, prefix_grbgdata, prefix_grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"SIZ\", 3 ) == 0 ) {\n            // full size of the original file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            max_file_size = LEtoUint32(ujpg_mrk);\n        }\n        else if ( memcmp( ujpg_mrk, \"EEE\", 3) == 0) {\n            ReadFull(header_reader, ujpg_mrk, 28);\n            max_cmp = LEtoUint32(ujpg_mrk);\n            max_bpos = LEtoUint32(ujpg_mrk + 4);\n            max_sah = LEtoUint32(ujpg_mrk + 8);\n            max_dpos[0] = LEtoUint32(ujpg_mrk + 12);\n            max_dpos[1] = LEtoUint32(ujpg_mrk + 16);\n            max_dpos[2] = LEtoUint32(ujpg_mrk + 20);\n            max_dpos[3] = LEtoUint32(ujpg_mrk + 24);\n            early_eof_encountered = true;\n            colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n        }\n        else {\n            if (memcmp(ujpg_mrk, \"CNT\", 3) == 0 ) {\n                pending_header_reads = true;\n                break;\n            } else if (memcmp(ujpg_mrk, \"CMP\", 3) == 0 ) {\n                break;\n            } else {\n                fprintf( stderr, \"unknown data found\" );\n                errorlevel.store(2);\n            }\n            return false;\n        }\n    }\n    if (!pending_header_reads) {\n        delete header_reader;\n        header_reader = NULL;\n    }\n    write_byte_bill(Billing::HEADER,\n                    false,\n                    2 + hdrs + prefix_grbs + grbs);\n\n    ReadFull(str_in, ujpg_mrk, 3 ) ;\n    write_byte_bill(Billing::HEADER, true, 3);\n\n    write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS); // trailing vpx_encode bits\n    write_byte_bill(Billing::HEADER, true, 4); //trailing size\n\n    if (memcmp(ujpg_mrk, \"CMP\", 3) != 0) {\n        always_assert(false && \"CMP must be present (uncompressed) in the file or CNT continue marker\");\n        return false; // not a JPG\n    }\n    colldata.signal_worker_should_begin();\n    g_decoder->initialize(str_in, thread_handoff);\n    colldata.start_decoder(g_decoder);\n    return true;\n}\n\n\n/* -----------------------------------------------\n    set each variable to its initial value\n    ----------------------------------------------- */\n\nbool reset_buffers( void )\n{\n    int cmp, bpos;\n    int i;\n\n\n    // -- free buffers --\n\n    // free buffers & set pointers NULL\n    if ( hdrdata  != NULL ) aligned_dealloc ( hdrdata );\n    if ( huffdata != NULL ) aligned_dealloc ( huffdata );\n    if ( grbgdata != NULL && grbgdata != EOI ) aligned_dealloc ( grbgdata );\n    rst_err.clear();\n    rstp.resize(0);\n    scnp.resize(0);\n    hdrdata   = NULL;\n    huffdata  = NULL;\n    grbgdata  = NULL;\n\n    // free image arrays\n    colldata.reset();\n\n\n    // -- set variables --\n\n    // preset componentinfo\n    for ( cmp = 0; cmp < 4; cmp++ ) {\n        cmpnfo[ cmp ].sfv = -1;\n        cmpnfo[ cmp ].sfh = -1;\n        cmpnfo[ cmp ].mbs = -1;\n        cmpnfo[ cmp ].bcv = -1;\n        cmpnfo[ cmp ].bch = -1;\n        cmpnfo[ cmp ].bc  = -1;\n        cmpnfo[ cmp ].ncv = -1;\n        cmpnfo[ cmp ].nch = -1;\n        cmpnfo[ cmp ].nc  = -1;\n        cmpnfo[ cmp ].sid = -1;\n        cmpnfo[ cmp ].jid = -1;\n        cmpnfo[ cmp ].qtable = NULL;\n        cmpnfo[ cmp ].huffdc = -1;\n        cmpnfo[ cmp ].huffac = -1;\n    }\n\n    // preset imgwidth / imgheight / component count\n    imgwidth  = 0;\n    imgheight = 0;\n    cmpc      = 0;\n\n    // preset mcu info variables / restart interval\n    sfhm      = 0;\n    sfvm      = 0;\n    mcuc      = 0;\n    mcuh      = 0;\n    mcuv      = 0;\n    rsti      = 0;\n    max_file_size = 0; // this file isn't truncated\n    // reset quantization / huffman tables\n    for ( i = 0; i < 4; i++ ) {\n        htset[ 0 ][ i ] = 0;\n        htset[ 1 ][ i ] = 0;\n        for ( bpos = 0; bpos < 64; bpos++ )\n            qtables[ i ][ bpos ] = 0;\n    }\n\n    // preset jpegtype\n    jpegtype  = 0;\n\n    // reset padbit\n    padbit = -1;\n\n    return true;\n}\n\n/* ----------------------- End of main functions -------------------------- */\n\n/* ----------------------- Begin of JPEG specific functions -------------------------- */\n\n\n/* -----------------------------------------------\n    Parses header for imageinfo\n    ----------------------------------------------- */\nbool setup_imginfo_jpg(bool only_allocate_two_image_rows)\n{\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // position in header\n\n    int cmp;\n\n    // header parser loop\n    while ( hpos < hdrs ) {\n        type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ] : 0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] : 0);\n        // do not parse DHT & DRI\n        if ( ( type != 0xDA ) && ( type != 0xC4 ) && ( type != 0xDD ) ) {\n            if ( !parse_jfif_jpg( type, len, hdrs-hpos, &( hdrdata[ hpos ] ) ) )\n                return false;\n        }\n        hpos += len;\n    }\n\n    // check if information is complete\n    if ( cmpc == 0 ) {\n        fprintf( stderr, \"header contains incomplete information\" );\n        errorlevel.store(2);\n        return false;\n    }\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( ( cmpnfo[cmp].sfv == 0 ) ||\n             ( cmpnfo[cmp].sfh == 0 ) ||\n             ( cmpnfo[cmp].qtable == NULL ) ||\n             ( cmpnfo[cmp].qtable[0] == 0 ) ||\n             ( jpegtype == 0 ) ) {\n            fprintf( stderr, \"header information is incomplete\" );\n            errorlevel.store(2);\n            return false;\n        }\n    }\n        \n    // do all remaining component info calculations\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( cmpnfo[ cmp ].sfh > sfhm ) sfhm = cmpnfo[ cmp ].sfh;\n        if ( cmpnfo[ cmp ].sfv > sfvm ) sfvm = cmpnfo[ cmp ].sfv;\n    }\n    mcuv = ( int ) ceil( (float) imgheight / (float) ( 8 * sfhm ) );\n    mcuh = ( int ) ceil( (float) imgwidth  / (float) ( 8 * sfvm ) );\n    mcuc  = mcuv * mcuh;\n    int maxChromaWidth = 0;\n    int maxChromaHeight = 0;\n    int maxLumaWidth = 0;\n    int maxLumaHeight = 0;\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        cmpnfo[ cmp ].mbs = cmpnfo[ cmp ].sfv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bcv = mcuv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bch = mcuh * cmpnfo[ cmp ].sfv;\n        cmpnfo[ cmp ].bc  = cmpnfo[ cmp ].bcv * cmpnfo[ cmp ].bch;\n        cmpnfo[ cmp ].ncv = ( int ) ceil( (float) imgheight *\n                            ( (float) cmpnfo[ cmp ].sfh / ( 8.0 * sfhm ) ) );\n        cmpnfo[ cmp ].nch = ( int ) ceil( (float) imgwidth *\n                            ( (float) cmpnfo[ cmp ].sfv / ( 8.0 * sfvm ) ) );\n        cmpnfo[ cmp ].nc  = cmpnfo[ cmp ].ncv * cmpnfo[ cmp ].nch;\n        cmpnfo[cmp].check_valid_value_range();\n        if (cmp == 0) {\n            maxLumaWidth = cmpnfo[ cmp ].bch * 8;\n            maxLumaHeight = cmpnfo[ cmp ].bcv * 8;\n        } else {\n            if (maxChromaWidth < cmpnfo[ cmp ].bch * 8) {\n                maxChromaWidth = cmpnfo[ cmp ].bch * 8;\n            }\n            if (maxChromaHeight < cmpnfo[ cmp ].bcv * 8) {\n                maxChromaHeight = cmpnfo[ cmp ].bcv * 8;\n            }\n        }\n    }\n    LeptonDebug::setupDebugData(maxLumaWidth, maxLumaHeight,\n                                maxChromaWidth, maxChromaHeight);\n\n    // decide components' statistical ids\n    if ( cmpc <= 3 ) {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = cmp;\n    }\n    else {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = 0;\n    }\n    size_t start_allocated = Sirikata::memmgr_size_allocated();\n    // alloc memory for further operations\n    colldata.init(cmpnfo, cmpc, mcuh, mcuv, jpegtype == 1 && only_allocate_two_image_rows);\n    size_t end_allocated = Sirikata::memmgr_size_allocated();\n    total_framebuffer_allocated = end_allocated - start_allocated;\n    return true;\n}\n\n\n/* -----------------------------------------------\n    Parse routines for JFIF segments\n    ----------------------------------------------- */\nbool parse_jfif_jpg( unsigned char type, unsigned int len, unsigned int alloc_len, unsigned char* segment )\n{\n    unsigned int hpos = 4; // current position in segment, start after segment header\n    int lval, rval; // temporary variables\n    int skip;\n    int cmp;\n    int i;\n\n\n    switch ( type )\n    {\n        case 0xC4: // DHT segment\n            // build huffman trees & codes\n            while ( hpos < len ) {\n                lval = LBITS( hpos < alloc_len ? segment[ hpos ] : 0, 4 );\n                rval = RBITS( hpos < alloc_len ? segment[ hpos ]: 0, 4 );\n                if ( ((lval < 0) || (lval >= 2)) || ((rval < 0) || (rval >= 4)) )\n                    break;\n\n                hpos++;\n                // build huffman codes & trees\n                if (!build_huffcodes( &(segment[ hpos + 0 ]), alloc_len > hpos ? alloc_len - hpos : 0,\n                                      &(segment[ hpos + 16 ]),  alloc_len > hpos + 16 ? alloc_len - hpos - 16 : 0,\n                                      &(hcodes[ lval ][ rval ]), &(htrees[ lval ][ rval ]) )) {\n                    errorlevel.store(2);\n                    return false;\n                }\n                htset[ lval ][ rval ] = 1;\n\n                skip = 16;\n                for ( i = 0; i < 16; i++ )\n                    skip += ( int ) (hpos + i < alloc_len ? segment[ hpos + i ] : 0);\n                hpos += skip;\n            }\n\n            if ( hpos != len ) {\n                // if we get here, something went wrong\n                fprintf( stderr, \"size mismatch in dht marker\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xDB: // DQT segment\n            // copy quantization tables to internal memory\n            while ( hpos < len ) {\n                lval = LBITS( hpos < alloc_len ? segment[ hpos ] :  0, 4 );\n                rval = RBITS( hpos < alloc_len ? segment[ hpos ] : 0, 4 );\n                if ( (lval < 0) || (lval >= 2) ) break;\n                if ( (rval < 0) || (rval >= 4) ) break;\n                hpos++;\n                if ( lval == 0 ) { // 8 bit precision\n                    for ( i = 0; i < 64; i++ ) {\n                        qtables[ rval ][ i ] = ( unsigned short ) (hpos + i < alloc_len ? segment[ hpos + i ] : 0);\n                        if ( qtables[ rval ][ i ] == 0 ) break;\n                    }\n                    hpos += 64;\n                }\n                else { // 16 bit precision\n                    for ( i = 0; i < 64; i++ ) {\n                        qtables[ rval ][ i ] =\n                            B_SHORT( (hpos + (2*i)< alloc_len ? segment[ hpos + (2*i) ] : 0), (hpos + 2*i+1 < alloc_len?segment[ hpos + (2*i) + 1 ]:0) );\n                        if ( qtables[ rval ][ i ] == 0 ) break;\n                    }\n                    hpos += 128;\n                }\n            }\n\n            if ( hpos != len ) {\n                // if we get here, something went wrong\n                fprintf( stderr, \"size mismatch in dqt marker\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xDD: // DRI segment\n            // define restart interval\n          rsti = B_SHORT( hpos < alloc_len ? segment[ hpos ]:0, hpos +1 < alloc_len ?segment[ hpos + 1 ]:0 );\n            return true;\n\n        case 0xDA: // SOS segment\n            // prepare next scan\n            cs_cmpc = hpos < alloc_len ? segment[ hpos ] : 0;\n            if ( cs_cmpc > cmpc ) {\n                fprintf( stderr, \"%i components in scan, only %i are allowed\",\n                            cs_cmpc, cmpc );\n                errorlevel.store(2);\n                return false;\n            }\n            hpos++;\n            for ( i = 0; i < cs_cmpc; i++ ) {\n                for ( cmp = 0; ( (hpos < alloc_len ? segment[ hpos ]:0) != cmpnfo[ cmp ].jid ) && ( cmp < cmpc ); cmp++ );\n                if ( cmp == cmpc ) {\n                    fprintf( stderr, \"component id mismatch in start-of-scan\" );\n                    errorlevel.store(2);\n                    return false;\n                }\n                cs_cmp[ i ] = cmp;\n                cmpnfo[ cmp ].huffdc = LBITS( hpos + 1< alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                cmpnfo[ cmp ].huffac = RBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                if ( ( cmpnfo[ cmp ].huffdc < 0 ) || ( cmpnfo[ cmp ].huffdc >= 4 ) ||\n                     ( cmpnfo[ cmp ].huffac < 0 ) || ( cmpnfo[ cmp ].huffac >= 4 ) ) {\n                    fprintf( stderr, \"huffman table number mismatch\" );\n                    errorlevel.store(2);\n                    return false;\n                }\n                hpos += 2;\n            }\n            cs_from = hpos < alloc_len ? segment[ hpos + 0 ]:0;\n            cs_to   = hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0;\n            cs_sah  = LBITS( hpos + 2 < alloc_len ? segment[ hpos + 2 ]:0, 4 );\n            cs_sal  = RBITS( hpos +2  <  alloc_len ? segment[ hpos + 2 ]:0, 4 );\n            // check for errors\n            if ( ( cs_from > cs_to ) || ( cs_from > 63 ) || ( cs_to > 63 ) ) {\n                fprintf( stderr, \"spectral selection parameter out of range\" );\n                errorlevel.store(2);\n                return false;\n            }\n            if ( ( cs_sah >= 12 ) || ( cs_sal >= 12 ) ) {\n                fprintf( stderr, \"successive approximation parameter out of range\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xC0: // SOF0 segment\n            // coding process: baseline DCT\n\n        case 0xC1: // SOF1 segment\n            // coding process: extended sequential DCT\n\n        case 0xC2: // SOF2 segment\n            // coding process: progressive DCT\n\n            // set JPEG coding type\n            if ( type == 0xC2 )\n                jpegtype = 2;\n            else\n                jpegtype = 1;\n\n            // check data precision, only 8 bit is allowed\n            lval = hpos < alloc_len ? segment[ hpos ]:0;\n            if ( lval != 8 ) {\n                fprintf( stderr, \"%i bit data precision is not supported\", lval );\n                errorlevel.store(2);\n                return false;\n            }\n\n            // image size, height & component count\n            imgheight = B_SHORT( hpos +  1  < alloc_len ? segment[ hpos + 1 ]:0, hpos +  2 < alloc_len ?segment[ hpos + 2 ] :0);\n            imgwidth  = B_SHORT( hpos + 3 < alloc_len ?segment[ hpos + 3 ]:0, hpos + 4 < alloc_len ?segment[ hpos + 4 ]:0 );\n            cmpc      = hpos + 5 < alloc_len ?  segment[ hpos + 5 ]:0;\n            if ( cmpc > 4 ) {\n                cmpc = 4;\n                fprintf( stderr, \"image has %i components, max 4 are supported\", cmpc );\n                errorlevel.store(2);\n                return false;\n            }\n            hpos += 6;\n            // components contained in image\n            for ( cmp = 0; cmp < cmpc; cmp++ ) {\n                cmpnfo[ cmp ].jid = hpos < alloc_len ? segment[ hpos ]:0;\n                cmpnfo[ cmp ].sfv = LBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                cmpnfo[ cmp ].sfh = RBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                if (cmpnfo[ cmp ].sfv > 4\n                    || cmpnfo[ cmp ].sfh > 4) {\n                    custom_exit(ExitCode::SAMPLING_BEYOND_FOUR_UNSUPPORTED);\n                }\n#ifndef ALLOW_3_OR_4_SCALING_FACTOR\n                if (cmpnfo[ cmp ].sfv > 2\n                    || cmpnfo[ cmp ].sfh > 2) {\n                    custom_exit(ExitCode::SAMPLING_BEYOND_TWO_UNSUPPORTED);\n                }\n#endif\n                uint32_t quantization_table_value = hpos + 2 < alloc_len ? segment[ hpos + 2 ]:0;\n                if (quantization_table_value >= qtables.size()) {\n                    errorlevel.store(2);\n                    return false;\n                }\n                cmpnfo[ cmp ].qtable = qtables[quantization_table_value].begin();\n                hpos += 3;\n            }\n    \n            return true;\n\n        case 0xC3: // SOF3 segment\n            // coding process: lossless sequential\n            fprintf( stderr, \"sof3 marker found, image is coded lossless\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC5: // SOF5 segment\n            // coding process: differential sequential DCT\n            fprintf( stderr, \"sof5 marker found, image is coded diff. sequential\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC6: // SOF6 segment\n            // coding process: differential progressive DCT\n            fprintf( stderr, \"sof6 marker found, image is coded diff. progressive\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC7: // SOF7 segment\n            // coding process: differential lossless\n            fprintf( stderr, \"sof7 marker found, image is coded diff. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xC9: // SOF9 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof9 marker found, image is coded arithm. sequential\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCA: // SOF10 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof10 marker found, image is coded arithm. progressive\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCB: // SOF11 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof11 marker found, image is coded arithm. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCD: // SOF13 segment\n            // coding process: arithmetic differntial sequential DCT\n            fprintf( stderr, \"sof13 marker found, image is coded arithm. diff. sequential\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCE: // SOF14 segment\n            // coding process: arithmetic differential progressive DCT\n            fprintf( stderr, \"sof14 marker found, image is coded arithm. diff. progressive\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xCF: // SOF15 segment\n            // coding process: arithmetic differntial lossless\n            fprintf( stderr, \"sof15 marker found, image is coded arithm. diff. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xE0: // APP0 segment\n        case 0xE1: // APP1 segment\n        case 0xE2: // APP2 segment\n        case 0xE3: // APP3 segment\n        case 0xE4: // APP4 segment\n        case 0xE5: // APP5 segment\n        case 0xE6: // APP6 segment\n        case 0xE7: // APP7 segment\n        case 0xE8: // APP8 segment\n        case 0xE9: // APP9 segment\n        case 0xEA: // APP10 segment\n        case 0xEB: // APP11 segment\n        case 0xEC: // APP12segment\n        case 0xED: // APP13 segment\n        case 0xEE: // APP14 segment\n        case 0xEF: // APP15 segment\n        case 0xFE: // COM segment\n            // do nothing - return true\n            return true;\n    \n        case 0xD0: // RST0 segment\n        case 0xD1: // RST1segment\n        case 0xD2: // RST2 segment\n        case 0xD3: // RST3 segment\n        case 0xD4: // RST4 segment\n        case 0xD5: // RST5 segment\n        case 0xD6: // RST6 segment\n        case 0xD7: // RST7 segment\n            // return errormessage - RST is out of place here\n            fprintf( stderr, \"rst marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xD8: // SOI segment\n            // return errormessage - start-of-image is out of place here\n            fprintf( stderr, \"soi marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xD9: // EOI segment\n            // return errormessage - end-of-image is out of place here\n            fprintf( stderr, \"eoi marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n    \n        default: // unknown marker segment\n            // return warning\n            fprintf( stderr, \"unknown marker found: FF %2X\", type );\n            errorlevel.store(1);\n            return true;\n    }\n}\n\n\n/* -----------------------------------------------\n    JFIF header rebuilding routine\n    ----------------------------------------------- */\nbool rebuild_header_jpg( void )\n{\n    abytewriter* hdrw; // new header writer\n\n    unsigned char  type = 0x00; // type of current marker segment\n    uint32_t   len  = 0; // length of current marker segment\n    uint32_t   hpos = 0; // position in header\n\n\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n\n    // header parser loop\n    while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) {\n        type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n        // discard any unneeded meta info\n        if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) ||\n             ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) ||\n             ( type == 0xDD ) ) {\n            uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos;\n            hdrw->write_n( &(hdrdata[ hpos ]), to_copy);\n            if (to_copy <  len) {\n                for (uint32_t i = 0;i <to_copy -len;++i) {\n                    uint8_t zero = 0;\n                    hdrw->write_n(&zero, 1);\n                }\n            }\n        }\n        hpos += len;\n    }\n\n    // replace current header with the new one\n    custom_free( hdrdata );\n    hdrdata = hdrw->getptr_aligned();\n    hdrs    = hdrw->getpos();\n    delete( hdrw );\n\n\n    return true;\n}\n\n/* -----------------------------------------------\n    sequential block decoding routine\n    ----------------------------------------------- */\nint decode_block_seq( abitreader* huffr, huffTree* dctree, huffTree* actree, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = 64;\n    int bpos;\n    int hc;\n\n\n    // decode dc\n    hc = next_huffcode( huffr, dctree, Billing::EXP0_DC, Billing::EXPN_DC);\n    if ( hc < 0 ) return -1; // return error\n    else s = ( unsigned char ) hc;\n    n = huffr->read( s );\n    if (s) {\n        write_bit_bill(Billing::RES_DC, false, s - 1);\n        write_bit_bill(Billing::SIGN_DC, false, 1);\n    }\n    block[ 0 ] = DEVLI( s, n );\n    bool eof_fixup = false;\n    // decode ac\n    for ( bpos = 1; bpos < 64; )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n        // analyse code\n        if ( hc > 0 ) {\n            z = LBITS( hc, 4 );\n            s = RBITS( hc, 4 );\n            n = huffr->read( s );\n            if (s) {\n                write_bit_bill(is_edge(bpos) ? Billing::RES_EDGE : Billing::RES_7x7, false, s - 1);\n                write_bit_bill(is_edge(bpos) ? Billing::SIGN_EDGE : Billing::SIGN_7x7, false, 1);\n            }\n            if ( ( z + bpos ) >= 64 ) {\n                eof_fixup = true;\n                break;\n            }\n            while ( z > 0 ) { // write zeroes\n                block[ bpos++ ] = 0;\n                z--;\n            }\n            block[ bpos++ ] = ( short ) DEVLI( s, n ); // decode cvli\n        }\n        else if ( hc == 0 ) { // EOB\n            eob = bpos;\n            // while( bpos < 64 ) // fill remaining block with zeroes\n            //    block[ bpos++ ] = 0;\n            break;\n        }\n        else {\n            return -1; // return error\n        }\n    }\n    if (eof_fixup) {\n        always_assert(huffr->eof && \"If 0run is longer than the block must be truncated\");\n        for(;bpos < eob; ++bpos) {\n            block[bpos] = 0;\n        }\n        if (eob) {\n            block[eob - 1] = 1; // set the value to something matching the EOB\n        }\n    }\n    // return position of eob\n    return eob;\n}\n\n\n\n/* -----------------------------------------------\n    progressive DC decoding routine\n    ----------------------------------------------- */\nint decode_dc_prg_fs( abitreader* huffr, huffTree* dctree, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    int hc;\n\n\n    // decode dc\n    hc = next_huffcode( huffr, dctree, Billing::EXP0_DC, Billing::EXPN_DC);\n    if ( hc < 0 ) return -1; // return error\n    else s = ( unsigned char ) hc;\n    n = huffr->read( s );\n    block[ 0 ] = DEVLI( s, n );\n\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive DC encoding routine\n    ----------------------------------------------- */\nint encode_dc_prg_fs( abitwriter* huffw, huffCodes* dctbl, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    int tmp;\n\n\n    // encode DC\n    tmp = block[ 0 ];\n    s = uint16bit_length(ABS(tmp));\n    n = ENVLI( s, tmp );\n    huffw->write( dctbl->cval[ s ], dctbl->clen[ s ] );\n    huffw->write( n, s );\n\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive AC decoding routine\n    ----------------------------------------------- */\nint decode_ac_prg_fs( abitreader* huffr, huffTree* actree, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = to + 1;\n    int bpos;\n    int hc;\n    int l;\n    int r;\n\n\n    // check eobrun\n    if ( (*eobrun) > 0 ) {\n        for ( bpos = from; bpos <= to; ++bpos)\n            block[ bpos ] = 0;\n        (*eobrun)--;\n        return from;\n    }\n\n    // decode ac\n    for ( bpos = from; bpos <= to; )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n        if ( hc < 0 ) return -1;\n        l = LBITS( hc, 4 );\n        r = RBITS( hc, 4 );\n        // analyse code\n        if ( ( l == 15 ) || ( r > 0 ) ) { // decode run/level combination\n            z = l;\n            s = r;\n            n = huffr->read( s );\n            if ( ( z + bpos ) > to )\n                return -1; // run is to long\n            while ( z > 0 ) { // write zeroes\n                block[ bpos++ ] = 0;\n                z--;\n            }\n            block[ bpos++ ] = ( short ) DEVLI( s, n ); // decode cvli\n        }\n        else { // decode eobrun\n            eob = bpos;\n            s = l;\n            n = huffr->read( s );\n            (*eobrun) = E_DEVLI( s, n );\n            // while( bpos <= to ) // fill remaining block with zeroes\n            //    block[ bpos++ ] = 0;\n            (*eobrun)--; // decrement eobrun ( for this one )\n            break;\n        }\n    }\n\n\n    // return position of eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    progressive AC encoding routine\n    ----------------------------------------------- */\nint encode_ac_prg_fs( abitwriter* huffw, huffCodes* actbl, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int bpos;\n    int hc;\n    int tmp;\n\n    // encode AC\n    z = 0;\n    for ( bpos = from; bpos <= to; bpos++ )\n    {\n        // if nonzero is encountered\n        tmp = block[ bpos ];\n        if ( tmp != 0 ) {\n            // encode eobrun\n            encode_eobrun( huffw, actbl, eobrun );\n            // write remaining zeroes\n            while ( z >= 16 ) {\n                huffw->write( actbl->cval[ 0xF0 ], actbl->clen[ 0xF0 ] );\n                z -= 16;\n            }\n            // vli encode\n            s = nonzero_bit_length(ABS(tmp));\n            n = ENVLI( s, tmp);\n            hc = ( ( z << 4 ) + s );\n            // write to huffman writer\n            huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n            huffw->write( n, s );\n            // reset zeroes\n            z = 0;\n        }\n        else { // increment zero counter\n            z++;\n        }\n    }\n\n    // check eob, increment eobrun if needed\n    if ( z > 0 ) {\n        (*eobrun)++;\n        // check eobrun, encode if needed\n        if ( (*eobrun) == actbl->max_eobrun )\n            encode_eobrun( huffw, actbl, eobrun );\n        return 1 + to - z;\n    }\n    else {\n        return 1 + to;\n    }\n}\n\n\n/* -----------------------------------------------\n    progressive DC SA decoding routine\n    ----------------------------------------------- */\nint decode_dc_prg_sa( abitreader* huffr, short* block )\n{\n    // decode next bit of dc coefficient\n    block[ 0 ] = huffr->read( 1 );\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive DC SA encoding routine\n    ----------------------------------------------- */\nint encode_dc_prg_sa( abitwriter* huffw, short* block )\n{\n    // enocode next bit of dc coefficient\n    huffw->write( block[ 0 ], 1 );\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive AC SA decoding routine\n    ----------------------------------------------- */\nint decode_ac_prg_sa( abitreader* huffr, huffTree* actree, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    signed char    z;\n    signed char    v;\n    int bpos = from;\n    int eob = to;\n    int hc;\n    int l;\n    int r;\n\n\n    // decode AC succesive approximation bits\n    if ( (*eobrun) == 0 )\n    while ( bpos <= to )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n\n        if ( hc < 0 ) return -1;\n        l = LBITS( hc, 4 );\n        r = RBITS( hc, 4 );\n        // analyse code\n        if ( ( l == 15 ) || ( r > 0 ) ) { // decode run/level combination\n            z = l;\n            s = r;\n            if ( s == 0 ) v = 0;\n            else if ( s == 1 ) {\n                n = huffr->read( 1 );\n                v = ( n == 0 ) ? -1 : 1; // fast decode vli\n            }\n            else return -1; // decoding error\n            // write zeroes / write correction bits\n            while ( true ) {\n                if ( block[ bpos ] == 0 ) { // skip zeroes / write value\n                    if ( z > 0 ) z--;\n                    else {\n                        block[ bpos++ ] = v;\n                        break;\n                    }\n                }\n                else { // read correction bit\n                    n = huffr->read( 1 );\n                    block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n                }\n                if ( bpos++ >= to ) return -1; // error check            \n            }\n        }\n        else { // decode eobrun\n            eob = bpos;\n            s = l;\n            n = huffr->read( s );\n            (*eobrun) = E_DEVLI( s, n );\n            break;\n        }\n    }\n\n    // read after eob correction bits\n    if ( (*eobrun) > 0 ) {\n        for ( ; bpos <= to; bpos++ ) {\n            if ( block[ bpos ] != 0 ) {\n                n = huffr->read( 1 );\n                block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n            }\n        }\n        // decrement eobrun\n        (*eobrun)--;\n    }\n\n    // return eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    progressive AC SA encoding routine\n    ----------------------------------------------- */\nint encode_ac_prg_sa( abitwriter* huffw, abytewriter* storw, huffCodes* actbl, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = from;\n    int bpos;\n    int hc;\n    int tmp;\n\n    // check if block contains any newly nonzero coefficients and find out position of eob\n    for ( bpos = to; bpos >= from; bpos-- )    {\n        if ( ( block[ bpos ] == 1 ) || ( block[ bpos ] == -1 ) ) {\n            eob = bpos + 1;\n            break;\n        }\n    }\n\n    // encode eobrun if needed\n    if ( ( eob > from ) && ( (*eobrun) > 0 ) ) {\n        encode_eobrun( huffw, actbl, eobrun );\n        encode_crbits( huffw, storw );\n    }\n\n    // encode AC\n    z = 0;\n    for ( bpos = from; bpos < eob; bpos++ )\n    {\n        tmp = block[ bpos ];\n        // if zero is encountered\n        if ( tmp == 0 ) {\n            z++; // increment zero counter\n            if ( z == 16 ) { // write zeroes if needed\n                huffw->write( actbl->cval[ 0xF0 ], actbl->clen[ 0xF0 ] );\n                encode_crbits( huffw, storw );\n                z = 0;\n            }\n        }\n        // if nonzero is encountered\n        else if ( ( tmp == 1 ) || ( tmp == -1 ) ) {\n            // vli encode\n            s = nonzero_bit_length(ABS(tmp));\n            n = ENVLI( s, tmp );\n            hc = ( ( z << 4 ) + s );\n            // write to huffman writer\n            huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n            huffw->write( n, s );\n            // write correction bits\n            encode_crbits( huffw, storw );\n            // reset zeroes\n            z = 0;\n        }\n        else { // store correction bits\n            n = block[ bpos ] & 0x1;\n            storw->write( n );\n        }\n    }\n\n    // fast processing after eob\n    for ( ;bpos <= to; bpos++ )\n    {\n        if ( block[ bpos ] != 0 ) { // store correction bits\n            n = block[ bpos ] & 0x1;\n            storw->write( n );\n        }\n    }\n\n    // check eob, increment eobrun if needed\n    if ( eob <= to ) {\n        (*eobrun)++;\n        // check eobrun, encode if needed\n        if ( (*eobrun) == actbl->max_eobrun ) {\n            encode_eobrun( huffw, actbl, eobrun );\n            encode_crbits( huffw, storw );\n        }\n    }\n\n    // return eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    run of EOB SA decoding routine\n    ----------------------------------------------- */\nint decode_eobrun_sa( abitreader* huffr, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    int bpos;\n\n\n    // fast eobrun decoding routine for succesive approximation\n    for ( bpos = from; bpos <= to; bpos++ ) {\n        if ( block[ bpos ] != 0 ) {\n            n = huffr->read( 1 );\n            block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n        }\n    }\n\n    // decrement eobrun\n    (*eobrun)--;\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    run of EOB encoding routine\n    ----------------------------------------------- */\nint encode_eobrun( abitwriter* huffw, huffCodes* actbl, unsigned int* eobrun )\n{\n    unsigned short n;\n    unsigned int  s;\n    int hc;\n\n\n    if ( (*eobrun) > 0 ) {\n        while ( (*eobrun) > actbl->max_eobrun ) {\n            huffw->write( actbl->cval[ 0xE0 ], actbl->clen[ 0xE0 ] );\n            huffw->write( E_ENVLI( 14, 32767 ), 14 );\n            (*eobrun) -= actbl->max_eobrun;\n        }\n        s = uint16bit_length((*eobrun));\n        dev_assert(s && \"actbl->max_eobrun needs to be > 0\");\n        if (s) s--;\n        n = E_ENVLI( s, (*eobrun) );\n        hc = ( s << 4 );\n        huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n        huffw->write( n, s );\n        (*eobrun) = 0;\n    }\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    correction bits encoding routine\n    ----------------------------------------------- */\nint encode_crbits( abitwriter* huffw, abytewriter* storw )\n{\n    unsigned char* data;\n    int len;\n    int i;\n\n\n    // peek into data from abytewriter\n    len = storw->getpos();\n    if ( len == 0 ) return 0;\n    data = storw->peekptr_aligned();\n\n    // write bits to huffwriter\n    for ( i = 0; i < len; i++ )\n        huffw->write( data[ i ], 1 );\n\n    // reset abytewriter, discard data\n    storw->reset();\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    returns next code (from huffman-tree & -data)\n    ----------------------------------------------- */\nint next_huffcode( abitreader *huffw, huffTree *ctree, Billing min_bill, Billing max_bill)\n{\n    int node = 0;\n\n\n    while ( node < 256 ) {\n#if defined(ENABLE_BILLING) || !defined(NDEBUG)\n        write_bit_bill(min_bill, false, 1);\n        if (min_bill != max_bill) {\n            min_bill = (Billing)((int)min_bill + 1);\n        }\n#endif\n        node = ( huffw->read( 1 ) == 1 ) ?\n                ctree->r[ node ] : ctree->l[ node ];\n        if ( node == 0 ) break;\n    }\n\n    return ( node - 256 );\n}\n\n\n\n/* -----------------------------------------------\n    calculates next position (non interleaved)\n    ----------------------------------------------- */\nint next_mcuposn( int* cmp, int* dpos, int* rstw )\n{\n    // increment position\n    (*dpos)++;\n\n    // fix for non interleaved mcu - horizontal\n    if ( cmpnfo[(*cmp)].bch != cmpnfo[(*cmp)].nch ) {\n        if ( (*dpos) % cmpnfo[(*cmp)].bch == cmpnfo[(*cmp)].nch )\n            (*dpos) += ( cmpnfo[(*cmp)].bch - cmpnfo[(*cmp)].nch );\n    }\n\n    // fix for non interleaved mcu - vertical\n    if ( cmpnfo[(*cmp)].bcv != cmpnfo[(*cmp)].ncv ) {\n        if ( (*dpos) / cmpnfo[(*cmp)].bch == cmpnfo[(*cmp)].ncv )\n            (*dpos) = cmpnfo[(*cmp)].bc;\n    }\n\n    // check position\n    if ( (*dpos) >= cmpnfo[(*cmp)].bc ) return 2;\n    else if ( rsti > 0 )\n        if ( --(*rstw) == 0 ) return 1;\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    skips the eobrun, calculates next position\n    ----------------------------------------------- */\nint skip_eobrun( int* cmp, int* dpos, int* rstw, unsigned int* eobrun )\n{\n    if ( (*eobrun) > 0 ) // error check for eobrun\n    {\n        // compare rst wait counter if needed\n        if ( rsti > 0 ) {\n            if ( (int)(*eobrun) > (*rstw) )\n                return -1;\n            else\n                (*rstw) -= (*eobrun);\n        }\n\n        // fix for non interleaved mcu - horizontal\n        if ( cmpnfo[(*cmp)].bch != cmpnfo[(*cmp)].nch ) {\n            (*dpos) += ( ( ( (*dpos) % cmpnfo[(*cmp)].bch ) + (*eobrun) ) /\n                        cmpnfo[(*cmp)].nch ) * ( cmpnfo[(*cmp)].bch - cmpnfo[(*cmp)].nch );\n        }\n\n        // fix for non interleaved mcu - vertical\n        if ( cmpnfo[(*cmp)].bcv != cmpnfo[(*cmp)].ncv ) {\n            if ( (*dpos) / cmpnfo[(*cmp)].bch >= cmpnfo[(*cmp)].ncv )\n                (*dpos) += ( cmpnfo[(*cmp)].bcv - cmpnfo[(*cmp)].ncv ) *\n                        cmpnfo[(*cmp)].bch;\n        }\n\n        // skip blocks\n        (*dpos) += (*eobrun);\n\n        // reset eobrun\n        (*eobrun) = 0;\n\n        // check position\n        if ( (*dpos) == cmpnfo[(*cmp)].bc ) return 2;\n        else if ( (*dpos) > cmpnfo[(*cmp)].bc ) return -1;\n        else if ( rsti > 0 )\n            if ( (*rstw) == 0 ) return 1;\n    }\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    creates huffman-codes & -trees from dht-data\n    ----------------------------------------------- */\nbool build_huffcodes( unsigned char *clen, uint32_t clenlen, unsigned char *cval, uint32_t cvallen, huffCodes *hc, huffTree *ht )\n{\n    int nextfree;\n    int code;\n    int node;\n    int i, j, k;\n\n\n    // fill with zeroes\n    memset( hc->clen, 0, 256 * sizeof( short ) );\n    memset( hc->cval, 0, 256 * sizeof( short ) );\n    memset( ht->l, 0, 256 * sizeof( short ) );\n    memset( ht->r, 0, 256 * sizeof( short ) );\n\n    // 1st part -> build huffman codes\n\n    // creating huffman-codes\n    k = 0;\n    code = 0;\n\n    // symbol-value of code is its position in the table\n    for( i = 0; i < 16; i++ ) {\n        uint32_t clen_index = i & 0xff;\n        for( j = 0; j < (int) (clen_index < clenlen ? clen[clen_index] : 0); j++ ) {\n            uint32_t cval_index = k&0xff;\n            uint8_t cval_val= cval_index < cvallen ? cval[cval_index] : 0;\n            hc->clen[ (int) cval_val&0xff] = 1 + i;\n            hc->cval[ (int) cval_val&0xff] = code;\n\n            k++;\n            code++;\n        }\n        code = code << 1;\n    }\n\n    // find out eobrun max value\n    hc->max_eobrun = 0;\n    for ( i = 14; i >= 0; i-- ) {\n        if ( hc->clen[(i << 4) & 255] > 0 ) {\n            hc->max_eobrun = ( 2 << i ) - 1;\n            break;\n        }\n    }\n\n    // 2nd -> part use codes to build the coding tree\n\n    // initial value for next free place\n    nextfree = 1;\n    const char * huffman_no_space = \"Huffman table out of space\\n\";\n    // work through every code creating links between the nodes (represented through ints)\n    for ( i = 0; i < 256; i++ )    {\n        // (re)set current node\n        node = 0;\n        // go through each code & store path\n        for ( j = hc->clen[i] - 1; j > 0; j-- ) {\n            if (node <= 0xff) {\n                if ( BITN( hc->cval[i], j ) == 1 ) {\n                    if ( ht->r[node] == 0 ) {\n                         ht->r[node] = nextfree++;\n                    }\n                    node = ht->r[node];\n                }\n                else {\n                    if ( ht->l[node] == 0 ) {\n                        ht->l[node] = nextfree++;\n                    }\n                    node = ht->l[node];\n                }\n            } else {\n                while(write(2, huffman_no_space, strlen(huffman_no_space)) == -1 && errno == EINTR) {}\n                if (filetype == JPEG) {\n                    return false;\n                }\n            }\n        }\n        if (node <= 0xff) {\n            // last link is number of targetvalue + 256\n            if ( hc->clen[i] > 0 ) {\n                if ( BITN( hc->cval[i], 0 ) == 1 ) {\n                    ht->r[node] = i + 256;\n                } else {\n                    ht->l[node] = i + 256;\n                }\n            }\n        } else {\n            while(write(2, huffman_no_space, strlen(huffman_no_space)) == -1 && errno == EINTR) {}\n            if (filetype == JPEG) {\n                return false; // we accept any .lep file that was encoded this way\n            }\n        }\n    }\n    return true;\n}\n\n/* ----------------------- End of JPEG specific functions -------------------------- */\n\n/* ----------------------- Begin of developers functions -------------------------- */\n\n\n\n\n\n/* -----------------------------------------------\n    Writes info to textfile\n    ----------------------------------------------- */\nbool write_info( void )\n{\n    FILE* fp;\n    const char* fn = \"stdout\";\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // position in header\n\n    int cmp, bpos;\n    int i;\n\n\n    // open file for output\n    fp = stdout;\n    if ( fp == NULL ){\n        fprintf( stderr, FWR_ERRMSG, fn);\n        errorlevel.store(2);\n        return false;\n    }\n\n    // info about image\n    fprintf( fp, \"<Infofile for JPEG image:>\\n\\n\\n\");\n    fprintf( fp, \"coding process: %s\\n\", ( jpegtype == 1 ) ? \"sequential\" : \"progressive\" );\n    // fprintf( fp, \"no of scans: %i\\n\", scnc );\n    fprintf( fp, \"imageheight: %i / imagewidth: %i\\n\", imgheight, imgwidth );\n    fprintf( fp, \"component count: %i\\n\", cmpc );\n    fprintf( fp, \"mcu count: %i/%i/%i (all/v/h)\\n\\n\", mcuc, mcuv, mcuh );\n\n    // info about header\n    fprintf( fp, \"\\nfile header structure:\\n\" );\n    fprintf( fp, \" type  length   hpos\\n\" );\n    // header parser loop\n    for ( hpos = 0; hpos < hdrs; hpos += len ) {\n        type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0 ;\n        len = 2 + B_SHORT( hpos  + 2 < hdrs ? hdrdata[ hpos + 2 ] : 0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] : 0);\n        fprintf( fp, \" FF%2X  %6i %6i\\n\", type, len, hpos );\n    }\n    fprintf( fp, \" _END       0 %6i\\n\", hpos );\n    fprintf( fp, \"\\n\" );\n\n    // info about components\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        fprintf( fp, \"\\n\" );\n        fprintf( fp, \"component number %i ->\\n\", cmp );\n        fprintf( fp, \"sample factors: %i/%i (v/h)\\n\", cmpnfo[cmp].sfv, cmpnfo[cmp].sfh );\n        fprintf( fp, \"blocks per mcu: %i\\n\", cmpnfo[cmp].mbs );\n        fprintf( fp, \"block count (mcu): %i/%i/%i (all/v/h)\\n\",\n            cmpnfo[cmp].bc, cmpnfo[cmp].bcv, cmpnfo[cmp].bch );\n        fprintf( fp, \"block count (sng): %i/%i/%i (all/v/h)\\n\",\n            cmpnfo[cmp].nc, cmpnfo[cmp].ncv, cmpnfo[cmp].nch );\n        fprintf( fp, \"quantiser table ->\" );\n        for ( i = 0; i < 64; i++ ) {\n            bpos = zigzag[ i ];\n            if ( ( i % 8 ) == 0 ) fprintf( fp, \"\\n\" );\n            fprintf( fp, \"%4i, \", QUANT( cmp, bpos ) );\n        }\n        fprintf( fp, \"\\n\" );\n        fprintf( fp, \"maximum values ->\" );\n        for ( i = 0; i < 64; i++ ) {\n            bpos = zigzag[ i ];\n            if ( ( i % 8 ) == 0 ) fprintf( fp, \"\\n\" );\n            fprintf( fp, \"%4i, \", MAX_V( cmp, bpos ) );\n        }\n        fprintf( fp, \"\\n\\n\" );\n    }\n\n\n    fclose( fp );\n\n\n    return true;\n}\n\n/* ----------------------- End of developers functions -------------------------- */\n\n/* ----------------------- End of file -------------------------- */\n"], "fixing_code": ["/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/**\nCopyright (c) 2006...2016, Matthias Stirner and HTW Aalen University\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **/\n\nvolatile int volatile1024 = 1024;\n#include \"../vp8/util/memory.hh\"\n#include \"../vp8/util/debug.hh\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <ctime>\n#include <memory>\n#include <atomic>\n#include <signal.h>\n#ifndef _WIN32\n#include <sys/time.h>\n#include <sys/types.h>\n    #include <unistd.h>\n#else\n    #include <io.h>\n#include <chrono>\n#include <ctime>\n#endif\n#ifdef __linux__\n#include <sys/sysinfo.h>\n#include <linux/seccomp.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n\n#endif\n\n#ifndef USE_SCALAR\n#include <emmintrin.h>\n#include <immintrin.h>\n#endif\n\n#include \"jpgcoder.hh\"\n#include \"recoder.hh\"\n#include \"bitops.hh\"\n#include \"htables.hh\"\n#include \"component_info.hh\"\n#include \"uncompressed_components.hh\"\n#include \"vp8_decoder.hh\"\n#include \"vp8_encoder.hh\"\n#include \"simple_decoder.hh\"\n#include \"simple_encoder.hh\"\n#include \"fork_serve.hh\"\n#include \"socket_serve.hh\"\n#include \"validation.hh\"\n#include \"../io/ZlibCompression.hh\"\n#include \"../io/BrotliCompression.hh\"\n#include \"../io/MemReadWriter.hh\"\n#include \"../io/BufferedIO.hh\"\n#include \"../io/Zlib0.hh\"\n#include \"../io/Seccomp.hh\"\n#include \"../vp8/encoder/vpx_bool_writer.hh\"\n#include \"generic_compress.hh\"\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#endif\nunsigned char g_zlib_0_writer[sizeof(Sirikata::Zlib0Writer)];\nvoid * uninit_g_zlib_0_writer = &g_zlib_0_writer[0];\nunsigned char EOI[ 2 ] = { 0xFF, 0xD9 }; // EOI segment\nextern int r_bitcount;\nint g_argc = 0;\nconst char** g_argv = NULL;\n#ifndef GIT_REVISION\n#include \"version.hh\"\n#ifndef GIT_REVISION\n#define GIT_REVISION \"unknown\"\n#endif\n#endif\nbool g_permissive = false;\nbool fast_exit = true;\n#ifdef SKIP_VALIDATION\nbool g_skip_validation = true;\n#else\nbool g_skip_validation = false;\n#endif\n#define QUANT(cmp,bpos) ( cmpnfo[cmp].qtable[ bpos ] )\n#define MAX_V(cmp,bpos) ( ( freqmax[bpos] + QUANT(cmp,bpos) - 1 ) /  QUANT(cmp,bpos) )\n\n#define ENVLI(s,v)        ( ( v > 0 ) ? v : ( v - 1 ) + ( 1 << s ) )\n#define DEVLI(s,n)        ((s) == 0 ? (n) : ( ( (n) >= ( 1 << ((s) - 1) ) ) ? (n) : (n) + 1 - ( 1 << (s) ) ))\n#define E_ENVLI(s,v)    ( v - ( 1 << s ) )\n#define E_DEVLI(s,n)    ( n + ( 1 << s ) )\n\n#define COS_DCT(l,s,n)  ( cos( ( ( 2 * l + 1 ) * s * M_PI ) / ( 2 * n ) ) )\n#define C_DCT(n)        ( ( n == 0 ) ? ( 1 ) : ( sqrt( 2 ) ) )\n#define DCT_SCALE        sqrt( 8 )\n\n#define ABS(v1)            ( (v1 < 0) ? -v1 : v1 )\n#define ABSDIFF(v1,v2)    ( (v1 > v2) ? (v1 - v2) : (v2 - v1) )\n#define IPOS(w,v,h)        ( ( v * w ) + h )\n#define NPOS(n1,n2,p)    ( ( ( p / n1 ) * n2 ) + ( p % n1 ) )\n#define ROUND_F(v1)        ( (v1 < 0) ? (int) (v1 - 0.5) : (int) (v1 + 0.5) )\n#define B_SHORT(v1,v2)    ( ( ((int) v1) << 8 ) + ((int) v2) )\n#define CLAMPED(l,h,v)    ( ( v < l ) ? l : ( v > h ) ? h : v )\n\n#define MEM_ERRMSG    \"out of memory error\"\n#define FRD_ERRMSG    \"could not read file / file not found: %s\"\n#define FWR_ERRMSG    \"could not write file / file write-protected: %s\"\nsize_t local_atoi(const char *data);\nnamespace TimingHarness {\n\nSirikata::Array1d<Sirikata::Array1d<uint64_t, NUM_STAGES>, MAX_NUM_THREADS> timing = {{{{0}}}};\n\nuint64_t get_time_us(bool force) {\n#ifdef _WIN32\n    return std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n#else\n    if (force || !g_use_seccomp) {\n        struct timeval val = {0,0};\n        gettimeofday(&val,NULL);\n        uint64_t retval = val.tv_sec;\n        retval *= 1000000;\n        retval += val.tv_usec;\n        return retval;\n    }\n#endif\n    return 0;\n}\nconst char * stage_names[] = {FOREACH_TIMING_STAGE(GENERATE_TIMING_STRING) \"EOF\"};\nvoid print_results() {\n    if (!g_use_seccomp) {\n        uint64_t earliest_time = get_time_us();\n        for (int i = 0; i < NUM_STAGES; ++i) {\n            for (unsigned int j = 0; j < MAX_NUM_THREADS && j < NUM_THREADS; ++j) {\n                if (timing[j][i] && timing[j][i] < earliest_time) {\n                    earliest_time = timing[j][i];\n                }\n            }\n        }\n        for (int i = 0; i < NUM_STAGES; ++i) {\n            for (unsigned int j = 0; j < MAX_NUM_THREADS && j < NUM_THREADS; ++j) {\n                if (timing[j][i]) {\n                    fprintf(stderr,\n                            \"%s\\t(%d)\\t%f\\n\",\n                            stage_names[i], j,\n                            (timing[j][i] - earliest_time) * 0.000001);\n                }\n            }\n        }\n    }\n}\n}\n/* -----------------------------------------------\n    struct & enum declarations\n    ----------------------------------------------- */\nenum {\n    JPG_READ_BUFFER_SIZE = 1024 * 256,\n    ABIT_WRITER_PRELOAD = 4096 * 1024 + 1024\n};\n\nenum ACTION {\n    comp  =  1,\n    forkserve = 2,\n    socketserve = 3,\n    info = 4,\n    lepton_concatenate = 5\n};\n\n\nnamespace {\nuint32_t LEtoUint32(const uint8_t*buffer) {\n    uint32_t retval = buffer[3];\n    retval <<=8;\n    retval |= buffer[2];\n    retval <<= 8;\n    retval |= buffer[1];\n    retval <<= 8;\n    retval |= buffer[0];\n    return retval;\n}\n}\n\nvoid uint32toLE(uint32_t value, uint8_t *retval) {\n    retval[0] = uint8_t(value & 0xff);\n    retval[1] = uint8_t((value >> 8) & 0xff);\n    retval[2] = uint8_t((value >> 16) & 0xff);\n    retval[3] = uint8_t((value >> 24) & 0xff);\n}\n/* -----------------------------------------------\n    function declarations: main interface\n    ----------------------------------------------- */\n\n// returns the max size of the input file\nint initialize_options( int argc, const char*const* argv );\nvoid execute(const std::function<bool()> &);\nvoid show_help( void );\n\n\n/* -----------------------------------------------\n    function declarations: main functions\n    ----------------------------------------------- */\n\nbool check_file(int fd_in, int fd_out, uint32_t max_file_size, bool force_zlib0,\n                bool is_embedded_jpeg, Sirikata::Array1d<uint8_t, 2> two_byte_header,\n                bool is_socket);\n\ntemplate <class stream_reader>\nbool read_jpeg(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offset,\n               stream_reader *jpg_str_in,\n               Sirikata::Array1d<uint8_t, 2> header,\n               bool is_embedded_jpeg);\nbool read_jpeg_wrapper(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offset,\n                       ibytestream *jpg_str_in,\n                       Sirikata::Array1d<uint8_t, 2> header,\n                       bool is_embedded_jpeg) {\n    return read_jpeg(huff_input_offset, jpg_str_in, header, is_embedded_jpeg);\n}\n\nbool read_jpeg_and_copy_to_side_channel(std::vector<std::pair<uint32_t,\n                                                    uint32_t>> *huff_input_offset,\n                                        ibytestreamcopier *jpg_str_in,\n                                        Sirikata::Array1d<uint8_t, 2> header,\n                                        bool is_embedded_jpeg) {\n    return read_jpeg(huff_input_offset, jpg_str_in, header, is_embedded_jpeg);\n}\n\nstruct MergeJpegProgress;\nbool decode_jpeg(const std::vector<std::pair<uint32_t,\n                                   uint32_t> > &huff_input_offset,\n                 std::vector<ThreadHandoff>*row_thread_handoffs);\nbool recode_jpeg( void );\n\nbool adapt_icos( void );\nbool check_value_range( void );\nbool write_ujpg(std::vector<ThreadHandoff> row_thread_handoffs,\n                std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >*jpeg_file_raw_bytes);\nbool read_ujpg( void );\nunsigned char read_fixed_ujpg_header( void );\nbool reset_buffers( void );\n\n\n/* -----------------------------------------------\n    function declarations: jpeg-specific\n    ----------------------------------------------- */\nbool is_jpeg_header(Sirikata::Array1d<uint8_t, 2> header) {\n    return header[0] == 0xFF && header[1] == 0xD8;\n}\n\n// baseline single threaded decoding need only two rows of the image in memory\nbool setup_imginfo_jpg(bool only_allocate_two_image_rows);\nbool parse_jfif_jpg( unsigned char type, unsigned int len, uint32_t alloc_len, unsigned char* segment );\nbool rebuild_header_jpg( void );\n\nint decode_block_seq( abitreader* huffr, huffTree* dctree, huffTree* actree, short* block );\nint encode_block_seq( abitwriter* huffw, huffCodes* dctbl, huffCodes* actbl, short* block );\n\nint decode_dc_prg_fs( abitreader* huffr, huffTree* dctree, short* block );\nint encode_dc_prg_fs( abitwriter* huffw, huffCodes* dctbl, short* block );\nint decode_ac_prg_fs( abitreader* huffr, huffTree* actree, short* block,\n                        unsigned int* eobrun, int from, int to );\nint encode_ac_prg_fs( abitwriter* huffw, huffCodes* actbl, short* block,\n                        unsigned int* eobrun, int from, int to );\n\nint decode_dc_prg_sa( abitreader* huffr, short* block );\nint encode_dc_prg_sa( abitwriter* huffw, short* block );\nint decode_ac_prg_sa( abitreader* huffr, huffTree* actree, short* block,\n                        unsigned int* eobrun, int from, int to );\nint encode_ac_prg_sa( abitwriter* huffw, abytewriter* storw, huffCodes* actbl,\n                        short* block, unsigned int* eobrun, int from, int to );\n\nint decode_eobrun_sa( abitreader* huffr, short* block, unsigned int* eobrun, int from, int to );\nint encode_eobrun( abitwriter* huffw, huffCodes* actbl, unsigned int* eobrun );\nint encode_crbits( abitwriter* huffw, abytewriter* storw );\n\nint next_huffcode( abitreader *huffw, huffTree *ctree , Billing min_bill, Billing max_bill);\nint next_mcupos( int* mcu, int* cmp, int* csc, int* sub, int* dpos, int* rstw, int cs_cmpc);\nint next_mcuposn( int* cmp, int* dpos, int* rstw );\nint skip_eobrun( int* cmp, int* dpos, int* rstw, unsigned int* eobrun );\n\nbool build_huffcodes( unsigned char *clen, uint32_t clenlen,  unsigned char *cval, uint32_t cvallen,\n                huffCodes *hc, huffTree *ht );\n\n\n\n\n\n/* -----------------------------------------------\n    function declarations: developers functions\n    ----------------------------------------------- */\n\n// these are developers functions, they are not needed\n// in any way to compress jpg or decompress ujg\nbool write_hdr( void );\nbool write_huf( void );\nbool write_info( void );\nclock_t pre_byte = 0;\nclock_t post_byte = 0;\nclock_t read_done = 0;\nclock_t overall_start = 0;\n\n/* -----------------------------------------------\n    global variables: data storage\n    ----------------------------------------------- */\n\nsize_t g_decompression_memory_bound = 0;\nSirikata::Array1d<Sirikata::Array1d<unsigned short, 64>, 4> qtables; // quantization tables\nSirikata::Array1d<Sirikata::Array1d<huffCodes, 4>, 2> hcodes; // huffman codes\nSirikata::Array1d<Sirikata::Array1d<huffTree, 4>, 2> htrees; // huffman decoding trees\nSirikata::Array1d<Sirikata::Array1d<unsigned char, 4>, 2> htset;// 1 if huffman table is set\nbool embedded_jpeg = false;\nunsigned char* grbgdata            =     NULL;    // garbage data\nunsigned char* hdrdata          =   NULL;   // header data\nunsigned char* huffdata         =   NULL;   // huffman coded data\nint            hufs             =    0  ;   // size of huffman data\nuint32_t       hdrs             =    0  ;   // size of header\nuint32_t       zlib_hdrs        =    0  ;   // size of compressed header\nsize_t         total_framebuffer_allocated = 0; // framebuffer allocated\nint            grbs             =    0  ;   // size of garbage\nint            prefix_grbs = 0; // size of prefix;\nunsigned char *prefix_grbgdata = NULL; // if prefix_grb is specified, header is not prepended\n\nstd::vector<unsigned int>  rstp;   // restart markers positions in huffdata\nstd::vector<unsigned int>  scnp;   // scan start positions in huffdata\nint            rstc             =    0  ;   // count of restart markers\nint            scnc             =    0  ;   // count of scans\nint            rsti             =    0  ;   // restart interval\nint8_t         padbit           =    -1 ;   // padbit (for huffman coding)\nstd::vector<unsigned char> rst_err;   // number of wrong-set RST markers per scan\nstd::vector<unsigned int> rst_cnt;\nbool rst_cnt_set = false;\nint            max_file_size    =    0  ;   // support for truncated jpegs 0 means full jpeg\nsize_t            start_byte       =    0;     // support for producing a slice of jpeg\nsize_t         jpeg_embedding_offset = 0;\nunsigned int min_encode_threads = 1;\nsize_t max_encode_threads = \n#ifdef DEFAULT_SINGLE_THREAD\n                                         1\n#else\n                                         MAX_NUM_THREADS\n#endif\n                                         ;\nUncompressedComponents colldata; // baseline sorted DCT coefficients\n\n\n\n/* -----------------------------------------------\n    global variables: info about image\n    ----------------------------------------------- */\n\n// seperate info for each color component\nSirikata::Array1d<componentInfo, 4> cmpnfo;\n\nint cmpc        = 0; // component count\nint imgwidth    = 0; // width of image\nint imgheight   = 0; // height of image\n\nint sfhm        = 0; // max horizontal sample factor\nint sfvm        = 0; // max verical sample factor\nint mcuv        = 0; // mcus per line\nunsigned int mcuh        = 0; // mcus per collumn\nint mcuc        = 0; // count of mcus\nbool early_eof_encountered = false;\n\nint max_cmp = 0; // the maximum component in a truncated image\nint max_bpos = 0; // the maximum band in a truncated image\nint max_dpos[4] = {}; // the maximum dpos in a truncated image\nint max_sah = 0; // the maximum bit in a truncated image\n\n\nvoid standard_eof(abytewriter* hdrw, abytewriter* huffw) {\n    // get pointer for header data & size\n    hdrdata  = hdrw->getptr_aligned();\n    hdrs     = hdrw->getpos();\n    // get pointer for huffman data & size\n    huffdata = huffw->getptr_aligned();\n    hufs     = huffw->getpos();\n}\n\nvoid early_eof(abytewriter* hdrw, abytewriter* huffw) {\n    early_eof_encountered = true;\n    standard_eof(hdrw, huffw);\n}\n\n\n/* -----------------------------------------------\n    global variables: info about current scan\n    ----------------------------------------------- */\n\nint cs_cmpc      =   0  ; // component count in current scan\nSirikata::Array1d<int, 4> cs_cmp = {{ 0 }}; // component numbers  in current scan\nint cs_from      =   0  ; // begin - band of current scan ( inclusive )\nint cs_to        =   0  ; // end - band of current scan ( inclusive )\nint cs_sah       =   0  ; // successive approximation bit pos high\nint cs_sal       =   0  ; // successive approximation bit pos low\nvoid kill_workers(void * workers, uint64_t num_workers);\nBaseDecoder* g_decoder = NULL;\nGenericWorker * get_worker_threads(unsigned int num_workers) {\n    // in this case decoding is asymmetric to encoding, just forget the assert\n    if (NUM_THREADS < 2) {\n        return NULL;\n    }\n    GenericWorker* retval = GenericWorker::get_n_worker_threads(num_workers);\n    TimingHarness::timing[0][TimingHarness::TS_THREAD_STARTED] = TimingHarness::get_time_us();\n\n    return retval;\n}\n\ntemplate <class BoolDecoder>VP8ComponentDecoder<BoolDecoder> *makeBoth(bool threaded, bool start_workers) {\n    VP8ComponentDecoder<BoolDecoder> *retval = new VP8ComponentDecoder<BoolDecoder>(threaded);\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n    if (start_workers) {\n        retval->registerWorkers(get_worker_threads(\n                                    NUM_THREADS\n                                    ),\n                                NUM_THREADS\n            );\n    }\n    return retval;\n}\n\ntemplate <class BoolDecoder>BaseEncoder *makeEncoder(bool threaded, bool start_workers) {\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT_BEGIN] = TimingHarness::get_time_us();\n    VP8ComponentEncoder<BoolDecoder> * retval = new VP8ComponentEncoder<BoolDecoder>(threaded, IsDecoderAns<BoolDecoder>::IS_ANS);\n    TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n    if (start_workers) {\n        retval->registerWorkers(get_worker_threads(NUM_THREADS - 1), NUM_THREADS - 1);\n    }\n    return retval;\n}\nBaseDecoder *makeDecoder(bool threaded, bool start_workers, bool ans) {\n    if (ans) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n        return makeBoth<ANSBoolReader>(threaded, start_workers);\n#else\n        always_assert(false && \"ANS compile flag not selected\");\n#endif\n    }\n    return makeBoth<VPXBoolReader>(threaded, start_workers);\n}\n/* -----------------------------------------------\n    global variables: info about files\n    ----------------------------------------------- */\nint    jpgfilesize;            // size of JPEG file\nint    ujgfilesize;            // size of UJG file\nint    jpegtype = 0;        // type of JPEG coding: 0->unknown, 1->sequential, 2->progressive\nF_TYPE filetype;            // type of current file\nF_TYPE ofiletype = LEPTON;            // desired type of output file\nbool g_do_preload = false;\nstd::unique_ptr<BaseEncoder> g_encoder;\n\nstd::unique_ptr<BaseDecoder> g_reference_to_free;\nServiceInfo g_socketserve_info;\nbool g_threaded = true;\n// this overrides the progressive bit in the header so that legacy progressive files may be decoded\nbool g_force_progressive = false;\nbool g_allow_progressive = \n#ifdef DEFAULT_ALLOW_PROGRESSIVE\n    true\n#else\n    false\n#endif\n    ;\nbool g_unkillable = false;\nuint64_t g_time_bound_ms = 0;\nint g_inject_syscall_test = 0;\nbool g_force_zlib0_out = false;\n\nSirikata::DecoderReader* str_in  = NULL;    // input stream\nbounded_iostream* str_out = NULL;    // output stream\n// output stream\nIOUtil::FileWriter * ujg_out = NULL;\nIOUtil::FileReader * ujg_base_in = NULL;\n\nconst char** filelist = NULL;        // list of files to process\nint    file_cnt = 0;        // count of files in list (1 for input only)\nint    file_no  = 0;        // number of current file\n/* -----------------------------------------------\n    global variables: messages\n    ----------------------------------------------- */\n\nstd::string errormessage;\nstd::atomic<int> errorlevel(0);\n// meaning of errorlevel:\n// -1 -> wrong input\n// 0 -> no error\n// 1 -> warning\n// 2 -> fatal error\n\n\n/* -----------------------------------------------\n    global variables: settings\n    ----------------------------------------------- */\n\nint  verbosity  = 0;        // level of verbosity\nbool overwrite  = false;    // overwrite files yes / no\nint  err_tresh  = 1;        // error threshold ( proceed on warnings yes (2) / no (1) )\nbool disc_meta  = false;    // discard meta-info yes / no\n\nbool developer  = false;    // allow developers functions yes/no\nACTION action   = comp;        // what to do with JPEG/UJG files\n\nFILE*  msgout   = stderr;    // stream for output of messages\nbool   pipe_on  = false;    // use stdin/stdout instead of filelist\n\n\n\nvoid sig_nop(int){}\n/* -----------------------------------------------\n    global variables: info about program\n    ----------------------------------------------- */\n\nunsigned char ujgversion   = 1;\nbool g_even_thread_split = false;\nuint8_t get_current_file_lepton_version() {\n    return ujgversion;\n}\nstatic const char*  appname      = \"lepton\";\nstatic const unsigned char   ujg_header[] = { 'U', 'J' };\nstatic const unsigned char   lepton_header[] = { 0xcf, 0x84 }; // the tau symbol for a tau lepton in utf-8\nstatic const unsigned char   zlepton_header[] = { 0xce, 0xb6 }; // the zeta symbol for a zlib compressed lepton\n\n\nFILE * timing_log = NULL;\nchar current_operation = '\\0';\n#ifdef _WIN32\nclock_t current_operation_begin = 0;\nclock_t current_operation_first_byte = 0;\nclock_t current_operation_end = 0;\n#else\nstruct timeval current_operation_begin = {0, 0};\nstruct timeval current_operation_first_byte = {0, 0};\nstruct timeval current_operation_end = {0, 0};\n#endif\n\nvoid timing_operation_start( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    current_operation = operation;\n#ifdef _WIN32\n    current_operation_begin = clock();\n    current_operation_first_byte = 0;\n    current_operation_end = 0;\n#else\n    gettimeofday(&current_operation_begin, NULL);\n    memset(&current_operation_first_byte, 0, sizeof(current_operation_first_byte));\n    memset(&current_operation_end, 0, sizeof(current_operation_end));\n#endif\n    fprintf(stderr,\"START ACHIEVED %ld %ld\\n\",\n            (long)current_operation_begin.tv_sec, (long)current_operation_begin.tv_usec );\n#endif\n}\n\nvoid timing_operation_first_byte( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    dev_assert(current_operation == operation);\n#ifdef _WIN32\n    if (current_operation_first_byte == 0) {\n        current_operation_first_byte = clock();\n    }\n#else\n    if (current_operation_first_byte.tv_sec == 0 &&\n        current_operation_first_byte.tv_usec == 0) {\n        gettimeofday(&current_operation_first_byte, NULL);\n    }\n#endif\n#endif\n}\n\nvoid timing_operation_complete( char operation ) {\n#ifndef _WIN32\n    if (g_use_seccomp) {\n        return;\n    }\n    dev_assert(current_operation == operation);\n#ifdef _WIN32\n    current_operation_end = clock();\n    if (timing_log) {\n        double begin_to_end = (current_operation_end - current_operation_begin) / (double)CLOCKS_PER_SEC;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte != 0) { // if we were successful\n            begin_to_first_byte = (current_operation_first_byte - current_operation_begin) / (double)CLOCKS_PER_SEC;\n        }\n        fprintf(timing_log, \"%c %f %f\\n\", current_operation, begin_to_first_byte, begin_to_end);\n        fflush(timing_log);\n    }\n    current_operation_end = 0;\n    current_operation_begin = 0;\n    current_operation_first_byte = 0;\n#else\n    gettimeofday(&current_operation_end, NULL);\n    if (timing_log) {\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = current_operation_end.tv_sec + (double)current_operation_end.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n        fprintf(timing_log, \"%c %f %f\\n\", current_operation, begin_to_first_byte, begin_to_end);\n        fflush(timing_log);\n    }\n    memset(&current_operation_end, 0, sizeof(current_operation_end));\n    memset(&current_operation_begin, 0, sizeof(current_operation_begin));\n    memset(&current_operation_first_byte, 0, sizeof(current_operation_first_byte));\n#endif\n#endif\n}\n\nsize_t local_atoi(const char *data) {\n    const char * odata = data;\n    size_t retval = 0;\n    int counter = 0;\n    while (*data) {\n        if (*data >= '0' && *data <='9') {\n            retval *= 10;\n            retval += *data - '0';\n            ++data;\n            ++counter;\n            if (counter > 16) {\n                fprintf(stderr, \"Could not allocate so much memory %s\\n\", odata);\n                exit(1);\n            }\n        } else if ('M' == *data) {\n            retval *= 1024 * 1024;\n            break;\n        } else if ('K' == *data) {\n            retval *= 1024;\n            break;\n        } else {\n            fprintf(stderr, \"Could not allocate alphanumeric memory %s\\n\", odata);\n            exit(1);\n        }\n    }\n    return retval;\n}\nbool starts_with(const char * a, const char * b) {\n    while (*b) {\n        if (*a != *b) {\n            return false;\n        }\n        ++a;\n        ++b;\n    }\n    return true;\n}\nvoid compute_thread_mem(const char * arg,\n                        size_t * mem_init,\n                        size_t * thread_mem_init,\n                        bool *needs_huge_pages,\n                        bool *avx2upgrade) {\n    if (strcmp(arg, \"-hugepages\") == 0) {\n        *needs_huge_pages = true;\n    }\n    if ( strcmp(arg, \"-avx2upgrade\") == 0) {\n        *avx2upgrade = true;\n    }\n    if (strstr(arg, \"-help\")) {\n        show_help();\n        exit(0);\n    }\n    if (strcmp(arg, \"-h\") == 0) {\n        show_help();\n        exit(0);\n    }\n    const char mem_arg_name[]=\"-memory=\";\n    const char thread_mem_arg_name[]=\"-threadmemory=\";\n    if (starts_with(arg, mem_arg_name)) {\n        arg += strlen(mem_arg_name);\n        *mem_init = local_atoi(arg);\n    }\n    if (starts_with(arg, thread_mem_arg_name)) {\n        arg += strlen(thread_mem_arg_name);\n        *thread_mem_init = local_atoi(arg);\n    }\n}\n/* -----------------------------------------------\n    main-function\n    ----------------------------------------------- */\n\n#ifdef EMSCRIPTEN\nconst char *fake_argv[] =  {\n    \"lepton-scalar\",\n    \"-skipverify\",\n    \"-singlethread\",\n    \"-\",\n};\n\nconst int fake_argc = sizeof(fake_argv) / sizeof(char *);\nint EMSCRIPTEN_KEEPALIVE main(void) {\n    const int argc = fake_argc;\n    const char **argv = fake_argv;\n    g_argc = argc;\n    g_argv = argv;\n    TimingHarness::timing[0][TimingHarness::TS_MAIN]\n        = TimingHarness::get_time_us(true);\n    size_t thread_mem_limit = 128 * 1024 * 1024;\n    size_t mem_limit = 1280 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1);\n    bool needs_huge_pages = false;\n    for (int i = 1; i < argc; ++i) {\n        bool avx2upgrade = false;\n        compute_thread_mem(argv[i],\n                           &mem_limit,\n                           &thread_mem_limit,\n                           &needs_huge_pages,\n                           &avx2upgrade);\n    }\n\n    // the system needs 33 megs of ram ontop of the uncompressed image buffer.\n    // This adds a few extra megs just to keep things real\n    UncompressedComponents::max_number_of_blocks = ( mem_limit / 4 ) * 3;\n    if (mem_limit > 48 * 1024 * 1024) {\n        UncompressedComponents::max_number_of_blocks = mem_limit - 36 * 1024 * 1024;\n    }\n    UncompressedComponents::max_number_of_blocks /= (sizeof(uint16_t) * 64);\n    int n_threads = MAX_NUM_THREADS - 1;\n    clock_t begin = 0, end = 1;\n\n    int error_cnt = 0;\n    int warn_cnt  = 0;\n\n    int acc_jpgsize = 0;\n    int acc_ujgsize = 0;\n\n    int speed, bpms;\n    float cr;\n\n    errorlevel.store(0);\n\n    // read options from command line\n    int max_file_size = initialize_options( argc, argv );\n    if (action != forkserve && action != socketserve) {\n        // write program info to screen\n        fprintf( msgout,  \"%s v%i.0-%s\\n\",\n                 appname, ujgversion, GIT_REVISION );\n    }\n    // check if user input is wrong, show help screen if it is\n    if ((file_cnt == 0 && action != forkserve && action != socketserve)\n        || ((!developer) && ((action != comp && action != forkserve && action != socketserve)))) {\n        show_help();\n        return -1;\n    }\n\n\n    // (re)set program has to be done first\n    reset_buffers();\n\n    // process file(s) - this is the main function routine\n    begin = clock();\n    if (file_cnt > 2) {\n        show_help();\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    process_file(nullptr, nullptr, max_file_size, g_force_zlib0_out);\n    if (errorlevel.load() >= err_tresh) error_cnt++;\n    if (errorlevel.load() == 1 ) warn_cnt++;\n    if ( errorlevel.load() < err_tresh ) {\n        acc_jpgsize += jpgfilesize;\n        acc_ujgsize += ujgfilesize;\n    }\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    if (action != socketserve && action != forkserve) {\n        // show statistics\n        fprintf(msgout,  \"\\n\\n-> %i file(s) processed, %i error(s), %i warning(s)\\n\",\n                file_cnt, error_cnt, warn_cnt);\n    }\n    if ( ( file_cnt > error_cnt ) && ( verbosity > 0 ) )\n    if ( action == comp ) {\n        speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n        bpms  = ( speed > 0 ) ? ( acc_jpgsize / speed ) : acc_jpgsize;\n        cr    = ( acc_jpgsize > 0 ) ? ( 100.0 * acc_ujgsize / acc_jpgsize ) : 0;\n\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n        fprintf( msgout,  \" time taken        : %8i msec\\n\", speed );\n        fprintf( msgout,  \" avrg. byte per ms : %8i byte\\n\", bpms );\n        fprintf( msgout,  \" avrg. comp. ratio : %8.2f %%\\n\", cr );\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n    }\n    return error_cnt == 0 ? 0 : 1;\n}\n#else\nint app_main( int argc, char** argv )\n{\n    g_argc = argc;\n    g_argv = (const char **)argv;\n    TimingHarness::timing[0][TimingHarness::TS_MAIN]\n        = TimingHarness::get_time_us(true);\n    size_t thread_mem_limit = \n#ifdef HIGH_MEMORY\n        64 * 1024 * 1024\n#else\n        3 * 1024 * 1024\n#endif\n        ;//8192;\n    size_t mem_limit = \n#ifdef HIGH_MEMORY\n        1024 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1)\n#else\n        176 * 1024 * 1024 - thread_mem_limit * (MAX_NUM_THREADS - 1)\n#endif\n        ;\n    bool needs_huge_pages = false;\n    for (int i = 1; i < argc; ++i) {\n        bool avx2upgrade = false;\n        compute_thread_mem(argv[i],\n                           &mem_limit,\n                           &thread_mem_limit,\n                           &needs_huge_pages,\n                           &avx2upgrade);\n#ifndef __AVX2__\n#ifndef __clang__\n#ifndef _ARCH_PPC        \n#ifndef _WIN32\n        if (avx2upgrade &&\n            __builtin_cpu_supports(\"avx2\")\n) {\n            for (int j = i + 1; j < argc; ++j) {\n                argv[j - 1] = argv[j];\n            }\n            --argc;\n            argv[argc] = NULL; // since we have eliminated the upgrade arg...\n            size_t command_len = strlen(argv[0]);\n            size_t postfix_len = strlen(\"-avx\") + 1;\n            char * command = (char*)malloc(postfix_len + command_len);\n            memcpy(command, argv[0], command_len);\n            memcpy(command + command_len, \"-avx\", postfix_len);\n            char * old_command = argv[0];\n            argv[0] = command;\n            execvp(command, argv);\n            argv[0] = old_command; // exec failed\n        }\n#endif\n#endif\n#endif\n#endif\n    }\n\n    // the system needs 33 megs of ram ontop of the uncompressed image buffer.\n    // This adds a few extra megs just to keep things real\n    UncompressedComponents::max_number_of_blocks = ( mem_limit / 4 ) * 3;\n    if (mem_limit > 48 * 1024 * 1024) {\n        UncompressedComponents::max_number_of_blocks = mem_limit - 36 * 1024 * 1024;\n    }\n    UncompressedComponents::max_number_of_blocks /= (sizeof(uint16_t) * 64);\n    int n_threads = MAX_NUM_THREADS;\n#ifndef __linux__\n    n_threads += 4;\n#endif\n#if !defined(_WIN32) && !defined(EMSCRIPTEN)\n    Sirikata::memmgr_init(mem_limit,\n                          thread_mem_limit,\n                          n_threads,\n                          256,\n                          needs_huge_pages);\n#endif\n    clock_t begin = 0, end = 1;\n\n    int error_cnt = 0;\n    int warn_cnt  = 0;\n\n    int acc_jpgsize = 0;\n    int acc_ujgsize = 0;\n\n    int speed, bpms;\n    float cr;\n\n    errorlevel.store(0);\n\n    // read options from command line\n    int max_file_size = initialize_options( argc, argv );\n    if (action != forkserve && action != socketserve) {\n        // write program info to screen\n        fprintf( msgout,  \"%s v%i.0-%s\\n\",\n                 appname, ujgversion, GIT_REVISION );\n    }\n    // check if user input is wrong, show help screen if it is\n    if ((file_cnt == 0 && action != forkserve && action != socketserve)\n        || ((!developer) && ((action != lepton_concatenate && action != comp && action != forkserve && action != socketserve)))) {\n        show_help();\n        return -1;\n    }\n\n\n    // (re)set program has to be done first\n    reset_buffers();\n\n    // process file(s) - this is the main function routine\n    begin = clock();\n    if (file_cnt > 2 && action != lepton_concatenate) {\n        show_help();\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    if (action == forkserve) {\n#ifdef _WIN32\n        abort(); // not implemented\n#else\n        fork_serve();\n#endif\n    } else if (action == socketserve) {\n#ifdef _WIN32\n        abort(); // not implemented\n#else\n        socket_serve(&process_file, max_file_size, g_socketserve_info);\n#endif\n    } else {\n        process_file(nullptr, nullptr, max_file_size, g_force_zlib0_out);\n    }\n    if (errorlevel.load() >= err_tresh) error_cnt++;\n    if (errorlevel.load() == 1 ) warn_cnt++;\n    if ( errorlevel.load() < err_tresh ) {\n        acc_jpgsize += jpgfilesize;\n        acc_ujgsize += ujgfilesize;\n    }\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    if (action != socketserve && action != forkserve) {\n        // show statistics\n        fprintf(msgout,  \"\\n\\n-> %i file(s) processed, %i error(s), %i warning(s)\\n\",\n                file_cnt, error_cnt, warn_cnt);\n    }\n    if ( ( file_cnt > error_cnt ) && ( verbosity > 0 ) )\n    if ( action == comp ) {\n        speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n        bpms  = ( speed > 0 ) ? ( acc_jpgsize / speed ) : acc_jpgsize;\n        cr    = ( acc_jpgsize > 0 ) ? ( 100.0 * acc_ujgsize / acc_jpgsize ) : 0;\n\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n        fprintf( msgout,  \" time taken        : %8i msec\\n\", speed );\n        fprintf( msgout,  \" avrg. byte per ms : %8i byte\\n\", bpms );\n        fprintf( msgout,  \" avrg. comp. ratio : %8.2f %%\\n\", cr );\n        fprintf( msgout,  \" --------------------------------- \\n\" );\n    }\n\n\n    return error_cnt == 0 ? 0 : 1;\n}\n#endif\n\n/* ----------------------- Begin of main interface functions -------------------------- */\n\n/* -----------------------------------------------\n    reads in commandline arguments\n    ----------------------------------------------- */\nchar g_dash[] = \"-\";\n// returns the maximum file size\nint initialize_options( int argc, const char*const * argv )\n{\n    const char** tmp_flp;\n    int tmp_val;\n    int max_file_size = 0;\n    // get memory for filelist & preset with NULL\n    filelist = (const char**)custom_calloc(argc * sizeof(char*));\n\n    // preset temporary filelist pointer\n    tmp_flp = filelist;\n    // read in arguments\n    while ( --argc > 0 ) {\n        argv++;\n        // switches begin with '-'\n        if ( sscanf( (*argv), \"-v%i\", &tmp_val ) == 1 ){\n            verbosity = tmp_val;\n            verbosity = ( verbosity < 0 ) ? 0 : verbosity;\n            verbosity = ( verbosity > 2 ) ? 2 : verbosity;\n        }\n        else if ( strcmp((*argv), \"-o\" ) == 0 ) {\n            overwrite = true;\n        }\n        else if (strcmp((*argv), \"-revision\" ) == 0 || strcmp((*argv), \"--revision\") == 0) {\n            printf(\"%s\\n\", GIT_REVISION);\n            exit(0);\n        }\n        else if (strcmp((*argv), \"-version\" ) == 0 || strcmp((*argv), \"--version\") == 0) {\n            printf(\"%02x\\n\", ujgversion);\n            exit(0);\n        } else if ( strcmp((*argv), \"-preload\" ) == 0 ) {\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-decode\" ) == 0 ) { // deprecated commands to preload it all\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-recode\" ) == 0 ) {\n            g_do_preload = true;\n        } else if ( strcmp((*argv), \"-p\" ) == 0 ) {\n            err_tresh = 2;\n        }\n        else if ( strncmp((*argv), \"-timebound=\", strlen(\"-timebound=\")) == 0) {\n            char * endptr = NULL;\n            g_time_bound_ms = strtoll((*argv) + strlen(\"-timebound=\"), &endptr, 10);\n            if (endptr) {\n                if (strcmp(endptr, \"s\") == 0) {\n                    g_time_bound_ms *= 1000;\n                } else if (strcmp(endptr, \"us\") == 0) {\n                    g_time_bound_ms /= 1000;\n                } else if (strcmp(endptr, \"ms\") != 0) {\n                    fprintf(stderr, \"Time must have units (ms or s)\\n\");\n                    exit(1);\n                }\n            }\n        }\n        else if ( strcmp((*argv), \"-zlib0\" ) == 0)  {\n            g_force_zlib0_out = true;\n        }\n        else if ( strcmp((*argv), \"-unkillable\" ) == 0)  {\n            g_unkillable = true;\n        }\n        else if ( strcmp((*argv), \"-singlethread\" ) == 0)  {\n            g_threaded = false;\n        }\n        else if ( strcmp((*argv), \"-allowprogressive\" ) == 0)  {\n            g_allow_progressive = true;\n        }\n        else if ( strcmp((*argv), \"-forceprogressive\" ) == 0)  {\n            g_allow_progressive = true;\n            g_force_progressive = true;\n        }\n        else if ( strcmp((*argv), \"-rejectprogressive\" ) == 0)  {\n            g_allow_progressive = false;\n        }\n        else if ( strcmp((*argv), \"-unjailed\" ) == 0)  {\n            g_use_seccomp = false;\n        } else if ( strcmp((*argv), \"-multithread\" ) == 0 || strcmp((*argv), \"-m\") == 0)  {\n            g_threaded = true;\n        } else if ( strcmp((*argv), \"-evensplit\" ) == 0)  {\n            g_even_thread_split = true;\n        } else if ( strstr((*argv), \"-recodememory=\") == *argv ) {\n            g_decompression_memory_bound\n                = local_atoi(*argv + strlen(\"-recodememory=\"));\n        } else if ( strstr((*argv), \"-memory=\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-hugepages\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-defermd5\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-avx2upgrade\") == *argv ) {\n\n        } else if ( strstr((*argv), \"-threadmemory=\") == *argv ) {\n\n        } else if ( strncmp((*argv), \"-timing=\", strlen(\"-timing=\") ) == 0 ) {\n            timing_log = fopen((*argv) + strlen(\"-timing=\"), \"a\");\n        } else if (strncmp((*argv), \"-maxencodethreads=\", strlen(\"-maxencodethreads=\") ) == 0 ) {\n            max_encode_threads = local_atoi((*argv) + strlen(\"-maxencodethreads=\"));\n            if (max_encode_threads > MAX_NUM_THREADS) {\n                custom_exit(ExitCode::VERSION_UNSUPPORTED);\n            }\n        } else if (strcmp((*argv), \"-lepcat\") == 0) {\n            action = lepton_concatenate;\n        } else if (strncmp((*argv), \"-minencodethreads=\", strlen(\"-minencodethreads=\") ) == 0 ) {\n            min_encode_threads = local_atoi((*argv) + strlen(\"-minencodethreads=\"));\n        } else if ( strncmp((*argv), \"-injectsyscall=\", strlen(\"-injectsyscall=\") ) == 0 ) {\n            g_inject_syscall_test = strtol((*argv) + strlen(\"-injectsyscall=\"), NULL, 10);\n        } else if ( strcmp((*argv), \"-skipvalidation\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipvalidate\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipverify\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skipverification\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-skiproundtrip\") == 0 ) {\n            g_skip_validation = true;\n        } else if ( strcmp((*argv), \"-validate\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-validation\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-verify\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-verification\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-roundtrip\") == 0 ) {\n            g_skip_validation = false;\n        } else if ( strcmp((*argv), \"-permissive\") == 0 ) {\n            g_permissive = true;\n#ifndef _WIN32\n            signal(SIGPIPE, SIG_IGN);\n#endif\n        } else if ( strcmp((*argv), \"-brotliheader\") == 0 ) {\n            if (ujgversion < 2) {\n                ujgversion = 2; // use brotli to compress the header and trailer rather than zlib\n            }\n        } else if ( strcmp((*argv), \"-ans\") == 0 ) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n            ujgversion = 3; // use brotli to compress the header and trailer rather than zlib and ANS encoder/decoder\n#else\n            always_assert(false && \"ANS selected via command line but not enabled in build flags\");\n#endif          \n        } else if ( strncmp((*argv), \"-maxchildren=\", strlen(\"-maxchildren=\") ) == 0 ) {\n            g_socketserve_info.max_children = strtol((*argv) + strlen(\"-maxchildren=\"), NULL, 10);\n        }\n        else if ( strncmp((*argv), \"-listenbacklog=\", strlen(\"-listenbacklog=\") ) == 0 ) {\n            g_socketserve_info.listen_backlog = strtol((*argv) + strlen(\"-listenbacklog=\"), NULL, 10);\n        }\n        else if ( strncmp((*argv), \"-startbyte=\", strlen(\"-startbyte=\") ) == 0 ) {\n            start_byte = local_atoi((*argv) + strlen(\"-startbyte=\"));\n        }        \n        else if ( strncmp((*argv), \"-embedding=\", strlen(\"-embedding=\") ) == 0 ) {\n            jpeg_embedding_offset = local_atoi((*argv) + strlen(\"-embedding=\"));\n            embedded_jpeg = true;\n        }\n        else if ( strncmp((*argv), \"-trunc=\", strlen(\"-trunc=\") ) == 0 ) {\n            max_file_size = local_atoi((*argv) + strlen(\"-trunc=\"));\n        }\n        else if ( strncmp((*argv), \"-trunctiming=\", strlen(\"-trunctiming=\") ) == 0 ) {\n            timing_log = fopen((*argv) + strlen(\"-trunctiming=\"), \"w\");\n        }\n        else if ( strcmp((*argv), \"-d\" ) == 0 ) {\n            disc_meta = true;\n        }\n        else if ( strcmp((*argv), \"-dev\") == 0 ) {\n            developer = true;\n        } else if ( ( strcmp((*argv), \"-ujg\") == 0 ) ||\n                    ( strcmp((*argv), \"-ujpg\") == 0 )) {\n            fprintf(stderr, \"FOUND UJG ARG: using that as output\\n\");\n            action = comp;\n            ofiletype = UJG;\n#ifndef _WIN32\n        } else if ( strcmp((*argv), \"-fork\") == 0 ) {    \n            action = forkserve;\n            // sets it up in serving mode\n            msgout = stderr;\n            // use \"-\" as placeholder for the socket\n            *(tmp_flp++) = g_dash;\n        } else if ( strncmp((*argv), \"-socket\", strlen(\"-socket\")) == 0 ) {\n            if (action != socketserve) {\n                action = socketserve;\n                // sets it up in serving mode\n                msgout = stderr;\n                // use \"-\" as placeholder for the socket\n                *(tmp_flp++) = g_dash;\n            }\n            if ((*argv)[strlen(\"-socket\")] == '=') {\n                g_socketserve_info.uds = (*argv) + strlen(\"-socket=\");\n            }\n        } else if ( strncmp((*argv), \"-listen\", strlen(\"-listen\")) == 0 ) {\n            g_socketserve_info.listen_tcp = true;\n            if (action != socketserve) {\n                action = socketserve;\n                // sets it up in serving mode\n                msgout = stderr;\n                // use \"-\" as placeholder for the socket\n                *(tmp_flp++) = g_dash;\n            }\n            if ((*argv)[strlen(\"-listen\")] == '=') {\n                g_socketserve_info.port = atoi((*argv) + strlen(\"-listen=\"));\n            }\n        } else if ( strncmp((*argv), \"-zliblisten\", strlen(\"-zliblisten\")) == 0 ) {\n            g_socketserve_info.zlib_port = atoi((*argv) + strlen(\"-zliblisten=\"));\n#endif\n        } else if ( strcmp((*argv), \"-\") == 0 ) {    \n            msgout = stderr;\n            // set binary mode for stdin & stdout\n            #ifdef _WIN32\n                setmode( fileno( stdin ), O_BINARY );\n                setmode( fileno( stdout ), O_BINARY );\n            #endif\n            // use \"-\" as placeholder for stdin\n            *(tmp_flp++) = g_dash;\n        }\n        else {\n            // if argument is not switch, it's a filename\n            *(tmp_flp++) = *argv;\n        }\n    }\n    for ( file_cnt = 0; filelist[ file_cnt ] != NULL; file_cnt++ ) {\n    }\n    if (start_byte != 0) {\n        // Encode of partial progressive images not allowed\n        g_allow_progressive = false;\n    }\n    if (g_time_bound_ms && action == forkserve) {\n        fprintf(stderr, \"Time bound action only supported with UNIX domain sockets\\n\");\n        exit(1);\n    }\n    if (g_do_preload && g_skip_validation) {\n        VP8ComponentDecoder<VPXBoolReader> *d = makeBoth<VPXBoolReader>(g_threaded, g_threaded && action != forkserve && action != socketserve);\n        g_encoder.reset(d);\n        g_decoder = d;\n    }\n    return max_file_size;\n}\nsize_t decompression_memory_bound() {\n    if (ofiletype == UJG || filetype == UJG) {\n        return 0;\n    }\n    size_t cumulative_buffer_size = 0;\n    size_t streaming_buffer_size = 0;\n    size_t current_run_size = 0;\n    for (int i = 0; i < colldata.get_num_components(); ++i) {\n        size_t streaming_size = \n            colldata.block_width(i)\n            * 2 * NUM_THREADS * 64 * sizeof(uint16_t);\n        size_t frame_buffer_size = colldata.component_size_allocated(i);\n        if (cs_cmpc != colldata.get_num_components() || jpegtype != 1) {\n            streaming_size = frame_buffer_size;\n        } else if (filetype != JPEG) {\n            if (!g_threaded) {\n                frame_buffer_size = colldata.block_width(i) * 2 * 64 * sizeof(uint16_t);\n\n            } else {\n                frame_buffer_size = streaming_size;\n            }\n        }\n        cumulative_buffer_size += frame_buffer_size;\n        streaming_buffer_size += streaming_size;\n    }\n    current_run_size = cumulative_buffer_size;\n\n    size_t bit_writer_augmentation = 0;\n    if (g_allow_progressive) {\n        for (size_t cur_size = jpgfilesize - 1; cur_size; cur_size >>=1) {\n            bit_writer_augmentation |= cur_size;\n        }\n        bit_writer_augmentation += 1; // this is used to compute the buffer size of the abit_writer for writing\n    }\n    size_t garbage_augmentation = 0;\n    for (size_t cur_size = hdrs - 1; cur_size; cur_size >>=1) {\n        garbage_augmentation |= cur_size;\n    }\n    garbage_augmentation += 1; // this is used to compute the buffer size of the abit_writer for writing\n    int non_preloaded_mux = 4096 * 1024 + 131072; // only 1 thread hence only one extra 131072\n    size_t decode_header_needed_size = hdrs + zlib_hdrs * 3;\n    if (zlib_hdrs && zlib_hdrs * 2 < hdrs) {\n        size_t doubled = zlib_hdrs * 2;\n        do {\n            decode_header_needed_size += doubled;\n            doubled *= 2;\n        } while (doubled < (size_t)hdrs);\n    }\n    size_t single_threaded_model_bonus = 0;\n    size_t single_threaded_buffer_bonus = 0; //the threads have to save their output to 3/4 of the jpeg before writing it\n    if (g_decoder) {\n        single_threaded_model_bonus += g_decoder->get_model_worker_memory_usage();\n    } else if (g_encoder) {\n        single_threaded_model_bonus += g_encoder->get_decode_model_worker_memory_usage();\n    }\n    if (filetype != JPEG && !g_threaded) {\n        single_threaded_buffer_bonus += jpgfilesize;\n    }\n    size_t abit_writer = 0;\n    if (g_allow_progressive) {\n\n        if (zlib_hdrs * 3 < ABIT_WRITER_PRELOAD * 2 + 64) {\n            if (zlib_hdrs * 3 < ABIT_WRITER_PRELOAD + 64) {\n                abit_writer += ABIT_WRITER_PRELOAD * 2 + 64;// these can't be reused memory\n            } else {\n                abit_writer += ABIT_WRITER_PRELOAD + 64;// these can't be reused\n            }\n        }\n    } else {\n        abit_writer += 65536 + 64;\n    }\n    if (g_allow_progressive &&\n        jpgfilesize > ABIT_WRITER_PRELOAD) {\n        // we currently buffer the whole jpeg in memory while streaming out\n        abit_writer += 3 * jpgfilesize;\n    }\n    size_t total = Sirikata::memmgr_size_allocated();\n    ptrdiff_t decom_memory_bound = total;\n    decom_memory_bound -= current_run_size;\n    decom_memory_bound += streaming_buffer_size;\n    decom_memory_bound -= single_threaded_model_bonus;\n    decom_memory_bound += single_threaded_buffer_bonus;\n    if (decom_memory_bound < 1){\n        decom_memory_bound = 1;\n    }\n    if (filetype == JPEG) {\n        decom_memory_bound = streaming_buffer_size\n            + abit_writer + jpgfilesize + sizeof(ProbabilityTablesBase)\n            + garbage_augmentation + decode_header_needed_size + non_preloaded_mux;\n    }\n    return decom_memory_bound;\n}\n\nvoid check_decompression_memory_bound_ok() {\n    if (g_decompression_memory_bound) {\n        size_t adjustment = 0;\n        if (!uninit_g_zlib_0_writer) {\n            adjustment = 8192; // add an extra 8kb if we're decoding zlib\n        }\n        if (decompression_memory_bound() > g_decompression_memory_bound + adjustment) {\n            custom_exit(ExitCode::TOO_MUCH_MEMORY_NEEDED);\n        }\n    }\n}\nvoid test_syscall_injection(std::atomic<int>*value) {\n#ifndef _WIN32\n    char buf[128 + 1];\n    buf[sizeof(buf) - 1] = 0;\n    value->store(-1);\n    char * ret = getcwd(buf, sizeof(buf) - 1);\n    value->store(ret ? 1 : 2);\n#endif\n}\nbool recode_baseline_jpeg_wrapper() {\n    bool retval = recode_baseline_jpeg(str_out, max_file_size);\n    if (!retval) {\n        errorlevel.store(2);\n        return retval;\n    }\n    // get filesize\n    jpgfilesize = str_out->getsize();\n    if (ujg_base_in) {\n        ujgfilesize = ujg_base_in->getsize();\n    } else {\n        ujgfilesize = 4096 * 1024;\n    }\n#ifndef _WIN32\n    if (!g_use_seccomp) {\n        clock_t final = clock();\n        struct timeval fin = {0,0};\n        gettimeofday(&fin,NULL);\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = fin.tv_sec + (double)fin.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n\n        fprintf(stderr, \"TIMING (new method): %f to first byte %f total\\n\",\n                begin_to_first_byte,\n                begin_to_end);\n        (void)final;\n        fprintf(stderr, \"Read took: %f\\n\",\n                (read_done - overall_start)/(double)CLOCKS_PER_SEC);\n    }\n#endif\n    // store last scan & restart positions\n    if ( !rstp.empty() )\n        rstp.at(rstc) = hufs;\n\n\n    return retval;\n}\n\n\n\n\n\nint open_fdin(const char *ifilename,\n              IOUtil::FileReader *reader,\n              Sirikata::Array1d<uint8_t, 2> &header,\n              ssize_t *bytes_read,\n              bool *is_socket) {\n    int fdin = -1;    \n    if (reader != NULL) {\n        *is_socket = reader->is_socket();\n        fdin = reader->get_fd();\n    }\n    else if (strcmp(ifilename, \"-\") == 0) {\n        fdin = 0;\n        *is_socket = false;\n    }\n    else {\n        *is_socket = false;\n         do {\n            fdin = open(ifilename, O_RDONLY\n#ifdef _WIN32\n                |O_BINARY\n#endif\n            );\n        } while (fdin == -1 && errno == EINTR);\n        if (fdin == -1) {\n            const char * errormessage = \"Input file unable to be opened for writing:\";\n            while(write(2, errormessage, strlen(errormessage)) == -1 && errno == EINTR) {}\n            while(write(2, ifilename, strlen(ifilename)) == -1 && errno == EINTR) {}\n            while(write(2, \"\\n\", 1) == -1 && errno == EINTR) {}\n        }\n    }\n    *bytes_read = 0;\n    ssize_t data_read = 0;\n    do {\n        data_read = read(fdin, &header[0], 2);\n    } while (data_read == -1 && errno == EINTR);\n    if (data_read >= 0) {\n        *bytes_read = data_read;\n    }\n    if (__builtin_expect(data_read < 2, false)) {\n        do {\n            data_read = read(fdin, &header[1], 1);\n        } while (data_read == -1 && errno == EINTR);\n        if (data_read >= 0) {\n            *bytes_read += data_read;\n        }\n    }\n    if (data_read < 0) {\n        perror(\"read\");\n        const char * fail = \"Failed to read 2 byte header\\n\";\n        while(write(2, fail, strlen(fail)) == -1 && errno == EINTR) {}        \n    }\n    return fdin;\n}\n\nstd::string uniq_filename(std::string filename) {\n    FILE * fp = fopen(filename.c_str(), \"rb\");\n    while (fp != NULL) {\n        fclose(fp);\n        filename += \"_\";\n        fp = fopen(filename.c_str(), \"rb\");\n    }\n    return filename;\n}\n\nstd::string postfix_uniq(const std::string &filename, const char * ext) {\n    std::string::size_type where =filename.find_last_of(\"./\\\\\");\n    if (where == std::string::npos || filename[where] != '.') {\n        return uniq_filename(filename + ext);\n    }\n    return uniq_filename(filename.substr(0, where) + ext);\n}\n\n\nint open_fdout(const char *ifilename,\n                    IOUtil::FileWriter *writer,\n               bool is_embedded_jpeg,\n                    Sirikata::Array1d<uint8_t, 2> fileid,\n                    bool force_compressed_output,\n                    bool *is_socket) {\n    if (writer != NULL) {\n        *is_socket = writer->is_socket();\n        return writer->get_fd();\n    }\n    *is_socket = false;\n    if (strcmp(ifilename, \"-\") == 0) {\n        return 1;\n    }\n    int retval = -1;\n    std::string ofilename;\n    // check file id, determine filetype\n    if (file_no + 1 < file_cnt && ofilename != ifilename) {\n        ofilename = filelist[file_no + 1];\n    } else if (is_jpeg_header(fileid) || is_embedded_jpeg || g_permissive) {\n        ofilename = postfix_uniq(ifilename, (ofiletype == UJG ? \".ujg\" : \".lep\"));\n    } else if ( ( ( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) )\n                || ( ( fileid[0] == lepton_header[0] ) && ( fileid[1] == lepton_header[1] ) )\n                || ( ( fileid[0] == zlepton_header[0] ) && ( fileid[1] == zlepton_header[1] ) ) ){\n        if ((fileid[0] == zlepton_header[0] && fileid[1] == zlepton_header[1])\n            || force_compressed_output) {\n            ofilename = postfix_uniq(ifilename, \".jpg.z\");\n        } else {\n            ofilename = postfix_uniq(ifilename, \".jpg\");\n        }\n    }\n    do {\n        retval = open(ofilename.c_str(), O_WRONLY|O_CREAT|O_TRUNC\n#ifdef _WIN32\n            | O_BINARY\n#endif\n            , 0\n#ifdef _WIN32\n            | S_IREAD| S_IWRITE\n#else\n            | S_IWUSR | S_IRUSR\n#endif\n        );\n    }while (retval == -1 && errno == EINTR);\n    if (retval == -1) {\n        const char * errormessage = \"Output file unable to be opened for writing:\";\n        while(write(2, errormessage, strlen(errormessage)) == -1 && errno == EINTR) {}\n        while(write(2, ofilename.c_str(), ofilename.length()) == -1 && errno == EINTR) {}\n        while(write(2, \"\\n\", 1) == -1 && errno == EINTR) {}\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    return retval;\n}\n\n\nvoid prep_for_new_file() {\n    r_bitcount = 0;\n    if (prefix_grbgdata) {\n        aligned_dealloc(prefix_grbgdata);\n        prefix_grbgdata = NULL;\n    }\n    if (grbgdata && grbgdata != &EOI[0]) {\n        aligned_dealloc(grbgdata);\n        grbgdata = NULL;\n    }\n\n    prefix_grbs = 0;\n    reset_buffers();\n    auto cur_num_threads = read_fixed_ujpg_header();\n    always_assert(cur_num_threads <= NUM_THREADS); // this is an invariant we need to maintain\n    str_out->prep_for_new_file();\n}\n\nvoid concatenate_files(int fdint, int fdout);\n\nvoid process_file(IOUtil::FileReader* reader,\n                  IOUtil::FileWriter *writer,\n                  int max_file_size,\n                  bool force_zlib0)\n{\n    clock_t begin = 0, end = 1;\n    const char* actionmsg  = NULL;\n    const char* errtypemsg = NULL;\n    int speed, bpms;\n    float cr;\n\n\n    if (g_inject_syscall_test == 2) {\n        unsigned int num_workers = std::max(\n            NUM_THREADS - 1,\n            1U);\n        GenericWorker* generic_workers = get_worker_threads(num_workers);\n        if (g_inject_syscall_test == 2) {\n            for (size_t i = 0; i < num_workers; ++i) {\n                std::atomic<int> value;\n                value.store(0);\n                generic_workers[i].work = std::bind(&test_syscall_injection, &value);\n                generic_workers[i].activate_work();\n                generic_workers[i].instruct_to_exit();\n                generic_workers[i].join_via_syscall();\n                if (value.load() < 1) {\n                    abort(); // this should exit_group\n                }\n            }\n            g_threaded = false;\n        }\n    }\n    // main function routine\n    errorlevel.store(0);\n    jpgfilesize = 0;\n    ujgfilesize = 0;\n\n    Sirikata::Array1d<uint8_t, 2> header = {{0, 0}};\n    const char * ifilename = filelist[file_no];\n    bool is_socket = false;\n    ssize_t bytes_read =0 ;\n    int fdin = open_fdin(ifilename, reader, header, &bytes_read, &is_socket);\n    /*\n    if (g_permissive && bytes_read < 2) {\n        std::vector<uint8_t> input(bytes_read);\n        if (bytes_read > 0) {\n            memcpy(&input[0], header.data, bytes_read);\n        }\n        Sirikata::MuxReader::ResizableByteBuffer lepton_data;\n        ExitCode exit_code = ExitCode::UNSUPPORTED_JPEG;\n        ValidationContinuation validation_exit_code = generic_compress(&input, &lepton_data, &exit_code);\n        if (exit_code != ExitCode::SUCCESS) {\n            custom_exit(exit_code);\n        }\n        if (validation_exit_code != ValidationContinuation::ROUNDTRIP_OK) {\n            custom_exit(ExitCode::UNSUPPORTED_JPEG);\n        }\n        int fdout = open_fdout(ifilename, writer, true, header, g_force_zlib0_out || force_zlib0, &is_socket);\n        for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n            ssize_t sent = write(fdout,\n                                 lepton_data.data() + data_sent,\n                                 lepton_data.size() - data_sent);\n            if (sent < 0 && errno == EINTR){\n                continue;\n            }\n            if (sent <= 0) {\n                custom_exit(ExitCode::SHORT_READ);\n            }\n            data_sent += sent;\n        }\n        //fprintf(stderr, \"OK...\\n\");\n        custom_exit(ExitCode::SUCCESS);\n        \n        }*/\n    int fdout = -1;\n    if ((embedded_jpeg || is_jpeg_header(header) || g_permissive) && (g_permissive ||  !g_skip_validation)) {\n        //fprintf(stderr, \"ENTERED VALIDATION...\\n\");\n        ExitCode validation_exit_code = ExitCode::SUCCESS;\n        Sirikata::MuxReader::ResizableByteBuffer lepton_data;\n        std::vector<uint8_t> permissive_jpeg_return_backing;\n        switch (validateAndCompress(&fdin, &fdout, header,\n                                    bytes_read,\n                                    start_byte, max_file_size,\n                                    &validation_exit_code,\n                                    &lepton_data,\n                                    g_argc,\n                                    g_argv,\n                                    g_permissive,\n                                    is_socket,\n                                    g_permissive? &permissive_jpeg_return_backing:NULL)) {\n          case ValidationContinuation::CONTINUE_AS_JPEG:\n            //fprintf(stderr, \"CONTINUE AS JPEG...\\n\");\n            is_socket = false;\n            break;\n          case ValidationContinuation::CONTINUE_AS_LEPTON:\n            embedded_jpeg = false;\n            is_socket = false;\n            g_force_zlib0_out = false;\n            force_zlib0 = false;\n            if (ofiletype ==  UJG) {\n                filetype = UJG;\n                header[0] = ujg_header[0];\n                header[1] = ujg_header[1];\n            } else {\n                filetype = LEPTON;\n                header[0] = lepton_header[0];\n                header[1] = lepton_header[1];\n            }\n            //fprintf(stderr, \"CONTINUE AS LEPTON...\\n\");\n            break;\n        case ValidationContinuation::EVALUATE_AS_PERMISSIVE:\n            if (permissive_jpeg_return_backing.size() == 0) {\n                custom_exit(ExitCode::UNSUPPORTED_JPEG);\n            }\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n            {ExitCode validation_exit_code = ExitCode::UNSUPPORTED_JPEG;\n            generic_compress(&permissive_jpeg_return_backing, &lepton_data, &validation_exit_code);\n            if (validation_exit_code != ExitCode::SUCCESS) {\n                custom_exit(validation_exit_code);\n            }}\n            for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n                ssize_t sent = write(fdout,\n                                     lepton_data.data() + data_sent,\n                                     lepton_data.size() - data_sent);\n                if (sent < 0 && errno == EINTR){\n                    continue;\n                }\n                if (sent <= 0) {\n                    custom_exit(ExitCode::SHORT_READ);\n                }\n                data_sent += sent;\n            }\n            //fprintf(stderr, \"OK...\\n\");\n            custom_exit(ExitCode::SUCCESS);\n            break;\n        case ValidationContinuation::ROUNDTRIP_OK:\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n            for (size_t data_sent = 0; data_sent < lepton_data.size();) {\n                ssize_t sent = write(fdout,\n                                     lepton_data.data() + data_sent,\n                                     lepton_data.size() - data_sent);\n                if (sent < 0 && errno == EINTR){\n                    continue;\n                }\n                if (sent <= 0) {\n                    custom_exit(ExitCode::SHORT_READ);\n                }\n                data_sent += sent;\n            }\n            //fprintf(stderr, \"OK...\\n\");\n            custom_exit(ExitCode::SUCCESS);\n          case ValidationContinuation::BAD:\n          default:\n            always_assert(validation_exit_code != ExitCode::SUCCESS);\n            custom_exit(validation_exit_code);\n        }        \n    } else {\n        if (action != lepton_concatenate) {\n            fdout = open_fdout(ifilename, writer, embedded_jpeg, header, g_force_zlib0_out || force_zlib0, &is_socket);\n        }\n    }\n    if (action == lepton_concatenate) {\n        concatenate_files(fdin, fdout);\n        return;\n    }\n    // check input file and determine filetype\n    check_file(fdin, fdout, max_file_size, force_zlib0, embedded_jpeg, header, is_socket);\n    \n    begin = clock();\n    if ( filetype == JPEG )\n    {\n\n\n        if (ofiletype == LEPTON) {\n            if (!g_encoder) {\n                if (ujgversion == 3) {\n#ifdef ENABLE_ANS_EXPERIMENTAL\n                    g_encoder.reset(makeEncoder<ANSBoolReader>(g_threaded, g_threaded));\n#else\n                    always_assert(false&&\"ANS-encoded file encountered but ANS not selected in build flags\");\n#endif\n                } else {\n                    g_encoder.reset(makeEncoder<VPXBoolReader>(g_threaded, g_threaded));\n                }\n                TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n                g_decoder = NULL;\n            } else if (g_threaded && (action == socketserve || action == forkserve)) {\n                g_encoder->registerWorkers(get_worker_threads(NUM_THREADS - 1), NUM_THREADS  - 1);\n            }\n        }else if (ofiletype == UJG) {\n            g_encoder.reset(new SimpleComponentEncoder);\n            g_decoder = NULL;\n        }\n    } else if (filetype == LEPTON) {\n        NUM_THREADS = read_fixed_ujpg_header();\n        if (NUM_THREADS == 1) {\n            g_threaded = false; // with singlethreaded, doesn't make sense to split out reader/writer\n        }\n        if (!g_decoder) {\n            g_decoder = makeDecoder(g_threaded, g_threaded, ujgversion == 3);\n            TimingHarness::timing[0][TimingHarness::TS_MODEL_INIT] = TimingHarness::get_time_us();\n            g_reference_to_free.reset(g_decoder);\n        } else if (NUM_THREADS > 1 && g_threaded && (action == socketserve || action == forkserve)) {\n            g_decoder->registerWorkers(get_worker_threads(NUM_THREADS), NUM_THREADS);\n        }\n    }else if (filetype == UJG) {\n        (void)read_fixed_ujpg_header();\n        g_decoder = new SimpleComponentDecoder;\n        g_reference_to_free.reset(g_decoder);\n    }\n#ifndef _WIN32\n    //FIXME\n    if (g_time_bound_ms) {\n        struct itimerval bound;\n        bound.it_value.tv_sec = g_time_bound_ms / 1000;\n        bound.it_value.tv_usec = (g_time_bound_ms % 1000) * 1000;\n        bound.it_interval.tv_sec = 0;\n        bound.it_interval.tv_usec = 0;\n        int ret = setitimer(ITIMER_REAL, &bound, NULL);\n\n        dev_assert(ret == 0 && \"Timer must be able to be set\");\n        if (ret != 0) {\n            exit((int)ExitCode::OS_ERROR);\n        }\n    }\n#endif\n    if (g_unkillable) { // only set this after the time bound has been set\n        if (!g_time_bound_ms) {\n            fprintf(stderr, \"Only allowed to set unkillable for items with a time bound\\n\");\n            exit(1);\n        }\n        signal(SIGTERM, &sig_nop);\n#ifndef _WIN32\n        signal(SIGQUIT, &sig_nop);\n#endif\n    }\n\n    if (g_use_seccomp) {\n        Sirikata::installStrictSyscallFilter(true);\n    }\n#ifndef _WIN32\n    if (g_inject_syscall_test == 1) {\n        char buf[128 + 1];\n        buf[sizeof(buf) - 1] = 0;\n        char * ret = getcwd(buf, sizeof(buf) - 1);\n        (void)ret;\n    }\n#endif\n    // get specific action message\n    if ( filetype == UNK ) {\n        actionmsg = \"unknown filetype\";\n    } else if (action == info) {\n        actionmsg = \"Parsing\";\n    } else if ( filetype == JPEG ) {\n        actionmsg = \"Writing to LEPTON\\n\";\n    } else {\n        actionmsg = \"Decompressing to JPEG\\n\";\n    }\n\n    if ( verbosity > 0 ) {\n        while (write(2, actionmsg , strlen(actionmsg)) < 0 && errno == EINTR) {}\n    }\n\n\n    std::vector<std::pair<uint32_t, uint32_t> > huff_input_offset;\n    if ( filetype == JPEG )\n    {\n        switch ( action )\n        {\n            case lepton_concatenate:\n              fprintf(stderr, \"Unable to concatenate raw JPEG files together\\n\");\n              custom_exit(ExitCode::VERSION_UNSUPPORTED);\n              break;\n            case comp:\n            case forkserve:\n            case socketserve:\n                timing_operation_start( 'c' );\n                TimingHarness::timing[0][TimingHarness::TS_READ_STARTED] = TimingHarness::get_time_us();\n                {\n                    std::vector<uint8_t,\n                                Sirikata::JpegAllocator<uint8_t> > jpeg_file_raw_bytes;\n                    unsigned int jpg_ident_offset = 2;\n                    if (start_byte == 0) {\n                        ibytestream str_jpg_in(str_in,\n                                               jpg_ident_offset,\n                                               Sirikata::JpegAllocator<uint8_t>());\n\n                        execute(std::bind(&read_jpeg_wrapper, &huff_input_offset, &str_jpg_in, header, embedded_jpeg));\n                    } else {\n                        ibytestreamcopier str_jpg_in(str_in,\n                                                     jpg_ident_offset,\n                                                     max_file_size,\n                                                     Sirikata::JpegAllocator<uint8_t>());\n                        str_jpg_in.mutate_read_data().push_back(0xff);\n                        str_jpg_in.mutate_read_data().push_back(0xd8);\n                        execute(std::bind(&read_jpeg_and_copy_to_side_channel,\n                                          &huff_input_offset, &str_jpg_in, header,\n                                          embedded_jpeg));\n                        jpeg_file_raw_bytes.swap(str_jpg_in.mutate_read_data());\n                    }\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_DECODE_STARTED] =\n                        TimingHarness::timing[0][TimingHarness::TS_READ_FINISHED] = TimingHarness::get_time_us();\n                    std::vector<ThreadHandoff> luma_row_offsets;\n                    execute(std::bind(&decode_jpeg, huff_input_offset, &luma_row_offsets));\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_DECODE_FINISHED]\n                        = TimingHarness::get_time_us();\n                    //execute( check_value_range );\n                    execute(std::bind(&write_ujpg,\n                                      std::move(luma_row_offsets),\n                                      jpeg_file_raw_bytes.empty() ? NULL : &jpeg_file_raw_bytes));\n                }\n                timing_operation_complete( 'c' );\n                break;\n\n            case info:\n                {\n                    unsigned int jpg_ident_offset = 2;\n                    ibytestream str_jpg_in(str_in, jpg_ident_offset, Sirikata::JpegAllocator<uint8_t>());\n                    execute(std::bind(read_jpeg_wrapper, &huff_input_offset, &str_jpg_in, header,\n                                      embedded_jpeg));\n                }\n                execute( write_info );\n                break;\n        }\n    }\n    else if ( filetype == UJG || filetype == LEPTON)\n    {\n        switch ( action )\n        {\n            case lepton_concatenate:\n              always_assert(false && \"should have been handled above\");\n            case comp:\n            case forkserve:\n            case socketserve:\n                if (!g_use_seccomp) {\n                    overall_start = clock();\n                }\n                timing_operation_start( 'd' );\n                TimingHarness::timing[0][TimingHarness::TS_READ_STARTED] = TimingHarness::get_time_us();\n                while (true) {\n                    execute( read_ujpg ); // replace with decompression function!\n                    TimingHarness::timing[0][TimingHarness::TS_READ_FINISHED] = TimingHarness::get_time_us();\n                    if (!g_use_seccomp) {\n                        read_done = clock();\n                    }\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();\n                    if (filetype != UJG && !g_allow_progressive) {\n                        execute(recode_baseline_jpeg_wrapper);\n                    } else {\n                        execute(recode_jpeg);\n                    }\n                    timing_operation_complete( 'd' );\n                    TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_FINISHED] = TimingHarness::get_time_us();\n                    Sirikata::Array1d<uint8_t, 6> trailer_new_header;\n                    std::pair<uint32_t, Sirikata::JpegError> continuity;\n                    size_t off = 0;\n                    while (off < trailer_new_header.size()) {\n                        continuity = str_in->Read(&trailer_new_header[off], trailer_new_header.size() - off);\n                        off += continuity.first;\n                        if (continuity.second != Sirikata::JpegError::nil()) {\n                            break;\n                        }\n                    }\n                    if (continuity.second != Sirikata::JpegError::nil()) {\n                        break;\n                    } else if (trailer_new_header[4] != header[0] ||  trailer_new_header[5] != header[1]) {\n                        break;\n                    } else {\n                        prep_for_new_file();\n                    }\n                }\n                str_out->close();\n                break;\n            case info:\n                execute( read_ujpg );\n                execute( write_info );\n                break;\n        }\n    }\n    if (!fast_exit) {\n        // close iostreams\n        if ( str_in  != NULL ) delete( str_in  ); str_in  = NULL;\n        if ( str_out != NULL ) delete( str_out ); str_out = NULL;\n        if ( ujg_out != NULL ) delete( ujg_out ); ujg_out = NULL;\n        // delete if broken or if output not needed\n        if ((!pipe_on) && ((errorlevel.load() >= err_tresh)\n                           || (action != comp && action != forkserve && action != socketserve))) {\n            // FIXME: can't delete broken output--it's gone already\n        }\n    }\n    TimingHarness::timing[0][TimingHarness::TS_DONE] = TimingHarness::get_time_us();\n    TimingHarness::print_results();\n    if (!g_use_seccomp) {\n        end = clock();\n    }\n    {\n        size_t bound = decompression_memory_bound();\n        char bound_out[] = \"XXXXXXXXXX bytes needed to decompress this file\\n\";\n        bound_out[0] = '0' + (bound / 1000000000)%10;\n        bound_out[1] = '0' + (bound / 100000000)%10;\n        bound_out[2] = '0' + (bound / 10000000)%10;\n        bound_out[3] = '0' + (bound / 1000000)%10;\n        bound_out[4] = '0' + (bound / 100000)%10;\n        bound_out[5] = '0' + (bound / 10000)%10;\n        bound_out[6] = '0' + (bound / 1000)%10;\n        bound_out[7] = '0' + (bound / 100)%10;\n        bound_out[8] = '0' + (bound / 10)%10;\n        bound_out[9] = '0' + (bound / 1)%10;\n        const char * to_write = bound_out;\n        while(to_write[0] == '0') {\n            ++to_write;\n        }\n        while(write(2, to_write, strlen(to_write)) < 0 && errno == EINTR) {\n        }\n    }\n    print_bill(2);\n    // speed and compression ratio calculation\n    speed = (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC );\n    bpms  = ( speed > 0 ) ? ( jpgfilesize / speed ) : jpgfilesize;\n    cr    = ( jpgfilesize > 0 ) ? ( 100.0 * ujgfilesize / jpgfilesize ) : 0;\n\n    switch ( verbosity )\n    {\n        case 0:\n          if ( errorlevel.load() < err_tresh ) {\n                if (action == comp ) {\n                    fprintf(stderr, \"%d %d\\n\",(int)ujgfilesize, (int)jpgfilesize);\n                    char percentage_report[]=\" XX.XX%\\n\";\n                    double pct = cr + .005;\n                    percentage_report[0] = '0' + (int)(pct / 100) % 10;\n                    percentage_report[1] = '0' + (int)(pct / 10) % 10;\n                    percentage_report[2] = '0' + (int)(pct) % 10;\n                    percentage_report[4] = '0' + (int)(pct * 10) % 10;\n                    percentage_report[5] = '0' + (int)(pct * 100) % 10;\n                    char * output = percentage_report;\n                    if (cr < 100) {\n                        ++output;\n                    }\n                    while (write(2, output, strlen(output)) < 0 && errno == EINTR) {\n                    }\n                }\n                else {\n                    fprintf( msgout,  \"DONE\\n\" );\n                }\n            }\n            break;\n\n        case 1:\n          if ( errorlevel.load() < err_tresh ) fprintf( msgout,  \"DONE\\n\" );\n            else fprintf( msgout,  \"ERROR\\n\" );\n            break;\n\n        case 2:\n            fprintf( msgout,  \"\\n----------------------------------------\\n\" );\n            if ( errorlevel.load() < err_tresh ) fprintf( msgout,  \"-> %s OK\\n\", actionmsg );\n            break;\n    }\n\n    switch ( errorlevel.load() )\n    {\n        case 0:\n            errtypemsg = \"none\";\n            break;\n\n        case 1:\n            if ( errorlevel.load() < err_tresh )\n                errtypemsg = \"warning (ignored)\";\n            else\n                errtypemsg = \"warning (skipped file)\";\n            break;\n\n        case 2:\n            errtypemsg = \"fatal error\";\n            break;\n    }\n\n    if ( errorlevel.load() > 0 )\n    {\n        if (false && action != socketserve && action != forkserve) {\n            fprintf( stderr, \" %s:\\n\", errtypemsg  );\n            fprintf( stderr, \" %s\\n\", errormessage.c_str() );\n            if ( verbosity > 1 )\n                fprintf( stderr, \" (in file \\\"%s\\\")\\n\", filelist[ file_no ] );\n        }\n    }\n    if ( (verbosity > 0) && (errorlevel.load() < err_tresh) )\n    if ( action == comp )\n    {\n        fprintf( msgout,  \" time taken  : %7i msec\\n\", speed );\n        fprintf( msgout,  \" byte per ms : %7i byte\\n\", bpms );\n        fprintf( msgout,  \" comp. ratio : %7.2f %%\\n\", cr );\n    }\n\n    if ( ( verbosity > 1 ) && ( action == comp ) )\n        fprintf( msgout,  \"\\n\" );\n    LeptonDebug::dumpDebugData();\n    if (errorlevel.load()) {\n        custom_exit(ExitCode::UNSUPPORTED_JPEG); // custom exit will delete generic_workers\n    } else {\n        custom_exit(ExitCode::SUCCESS);\n    }\n    reset_buffers();\n}\n\n\n/* -----------------------------------------------\n    main-function execution routine\n    ----------------------------------------------- */\n\nvoid execute(const std::function<bool()> &function)\n{\n    clock_t begin = 0, end = 0;\n    bool success;\n\n\n\n    if ( errorlevel.load() < err_tresh )\n    {\n        // get statusmessage\n        //function();\n        // write statusmessage\n        // set starttime\n        if (!g_use_seccomp) {\n            begin = clock();\n        }\n        // call function\n        success = function();\n        // set endtime\n        if (!g_use_seccomp) {\n            end = clock();\n        }\n\n        // write statusmessage\n        if ( success ) {\n            if (verbosity == 2 && !g_use_seccomp) {\n                fprintf( msgout,  \"%6ims\",\n                         (int) ( (double) (( end - begin ) * 1000) / CLOCKS_PER_SEC ) );\n            }\n        }\n        else {\n            if ( verbosity == 2 ) {\n                while(write(2, \"ERROR\\n\", strlen(\"ERROR\\n\")) < 0 && errno == EINTR) {\n\n                }\n            }\n        }\n    }\n}\n\n\n/* -----------------------------------------------\n    shows help in case of wrong input\n    ----------------------------------------------- */\n\nvoid show_help( void )\n{\n    fprintf(msgout, \"Usage: %s [switches] input_file [output_file]\", appname );\n    fprintf(msgout, \"\\n\" );\n    fprintf(msgout, \"\\n\" );\n    fprintf(msgout, \" [-version]       File format version of lepton codec\\n\" );\n    fprintf(msgout, \" [-revision]      GIT Hash of lepton source that built this binary\\n\");\n    fprintf(msgout, \" [-zlib0]         Instead of a jpg, return a zlib-compressed jpeg\\n\");\n    fprintf(msgout, \" [-startbyte=<n>] Encoded file will only contain data at and after <n>\\n\");\n    fprintf(msgout, \" [-trunc=<n>]     Encoded file will be truncated at size <n> - startbyte\\n\");\n//    fprintf(msgout, \" [-avx2upgrade]   Try to exec <binaryname>-avx if avx is available\\n\");\n//    fprintf(msgout, \" [-injectsyscall={1..4}]  Inject a \\\"chdir\\\" syscall & check SECCOMP crashes\\n\");\n    fprintf(msgout, \" [-unjailed]      Do not jail this process (use only with trusted data)\\n\" );\n    fprintf(msgout, \" [-singlethread]  Do not clone threads to operate on the input file\\n\" );\n    fprintf(msgout, \" [-maxencodethreads=<n>] Can use <n> threads to decode: higher=bigger file\\n\");\n    fprintf(msgout, \" [-allowprogressive] Allow progressive jpegs through the compressor\\n\");\n    fprintf(msgout, \" [-rejectprogressive] Reject encoding of progressive jpegs\\n\");\n    fprintf(msgout, \" [-timebound=<>ms]For -socket, enforce a timeout since first byte received\\n\");\n    fprintf(msgout, \" [-lepcat] Concatenate lepton files together into a file that contains multiple substrings\\n\");\n    fprintf(msgout, \" [-memory=<>M]    Upper bound on the amount of memory allocated by main\\n\");\n    fprintf(msgout, \" [-threadmemory=<>M] Bound on the amount of memory allocated by threads\\n\");\n    fprintf(msgout, \" [-recodememory=<>M] Check that a singlethreaded recode only uses <>M mem\\n\");\n#ifndef _WIN32\n    fprintf(msgout, \" [-hugepages]     Allocate from the hugepages on the system\\n\");\n    fprintf(msgout, \" [-socket=<name>] Serve requests on a Unix Domain Socket at path <name>\\n\" );\n    fprintf(msgout, \" [-listen=<port>] Serve requests on a TCP socket on <port> (default 2402)\\n\" );\n    fprintf(msgout, \" [-listenbacklog=<n>] n clients queued for encoding if maxchildren reached\\n\" );\n    fprintf(msgout, \" [-zliblisten=<port>] Serve requests on a TCP socket on <port> (def 2403)\\n\" );\n    fprintf(msgout, \" [-maxchildren]   Max codes to ever spawn at the same time in socket mode\\n\");\n#endif\n    fprintf(msgout, \" [-benchmark]     Run a benchmark on optional [<input_file>] (or included file)\\n\");\n    fprintf(msgout, \" [-verbose]       Run the benchmark in verbose mode (more output to stderr)\\n\");\n    fprintf(msgout, \" [-benchreps=<n>] Number of trials to run the benchmark for each category\\n\");\n    fprintf(msgout, \" [-benchthreads=<n>] Max number of parallel codings to benchmark\\n\");\n#ifdef SKIP_VALIDATION\n    fprintf(msgout, \" [-validate]      Round-trip this file when encoding [default:off]\\n\");\n#else\n    fprintf(msgout, \" [-validate]      Round-trip this file when encoding [default:on]\\n\");\n    fprintf(msgout, \" [-skipvalidate]  Avoid round-trip check when encoding (Warning: unsafe)\\n\");\n#endif\n}\n\n/* ----------------------- End of main interface functions -------------------------- */\n\n/* ----------------------- Begin of main functions -------------------------- */\n\n\nvoid nop (Sirikata::DecoderWriter*w, size_t) {\n}\n\n//void static_cast_to_zlib_and_call (Sirikata::DecoderWriter*w, size_t size) {\n//    (static_cast<Sirikata::Zlib0Writer*>(w))->setFullFileSize(size);\n//}\n\n\n/* -----------------------------------------------\n    check file and determine filetype\n    ----------------------------------------------- */\nunsigned char read_fixed_ujpg_header() {\n    Sirikata::Array1d<unsigned char, 22> header;\n    header.memset(0);\n\n    if (IOUtil::ReadFull(str_in, header.begin(), 22) != 22) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    // check version number\n    if (header[0] != 1 && header[0] != 2 && header[0] != 3 && header[0] != 4 && header[0] != ujgversion) {\n        // let us roll out a new version gently\n        fprintf( stderr, \"incompatible file, use %s v%i.%i\",\n            appname, header[ 0 ] / 10, header[ 0 ] % 10 );\n        custom_exit(ExitCode::VERSION_UNSUPPORTED);\n    }\n    ujgversion = header[0];\n    if (header[1] == 'X') {\n    } else if (header[1] != 'Z' && header[1] != 'Y') {\n        char err[] = \"?: Unknown Item in header instead of Z\";\n        err[0] = header[1];\n        while(write(2, err, sizeof(err) - 1) < 0 && errno == EINTR) {\n        }\n    }\n    if (header[1] == 'Z' || (header[1] & 1) == ('Y' & 1)) {\n        if (!g_force_progressive) {\n            g_allow_progressive = false;\n        }\n    }\n    unsigned char num_threads_hint = header[2];\n    always_assert(num_threads_hint != 0);\n    if (num_threads_hint < NUM_THREADS && num_threads_hint != 0) {\n        NUM_THREADS = num_threads_hint;\n    }\n// full size of the original file\n    Sirikata::Array1d<unsigned char, 4>::Slice file_size = header.slice<18,22>();\n    max_file_size = LEtoUint32(file_size.begin());\n    return NUM_THREADS;\n}\n\nbool check_file(int fd_in, int fd_out, uint32_t max_file_size, bool force_zlib0,\n                bool is_embedded_jpeg, Sirikata::Array1d<uint8_t, 2> fileid, bool is_socket)\n{\n    IOUtil::FileReader * reader = IOUtil::BindFdToReader(fd_in, max_file_size, is_socket);\n    if (!reader) {\n        custom_exit(ExitCode::FILE_NOT_FOUND);\n    }\n    reader->mark_some_bytes_already_read((uint32_t)fileid.size());\n    if (is_socket) {\n        dev_assert(fd_in == fd_out);\n    }\n    IOUtil::FileWriter * writer = IOUtil::BindFdToWriter(fd_out == -1 ? 1 /* stdout */ : fd_out, is_socket);\n    ujg_base_in = reader;\n    // check file id, determine filetype\n    if (is_embedded_jpeg || is_jpeg_header(fileid)) {\n        str_in = new Sirikata::BufferedReader<JPG_READ_BUFFER_SIZE>(reader);\n        // file is JPEG\n        filetype = JPEG;\n        NUM_THREADS = std::min(NUM_THREADS, (unsigned int)max_encode_threads);\n        // open output stream, check for errors\n        ujg_out = writer;\n    }\n    else if ( ( ( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) )\n              || ( ( fileid[0] == lepton_header[0] ) && ( fileid[1] == lepton_header[1] ) )\n              || ( ( fileid[0] == zlepton_header[0] ) && ( fileid[1] == zlepton_header[1] ) ) ){\n        str_in = reader;\n        bool compressed_output = (fileid[0] == zlepton_header[0]) && (fileid[1] == zlepton_header[1]);\n        compressed_output = compressed_output || g_force_zlib0_out || force_zlib0;\n        // file is UJG\n        filetype = (( fileid[0] == ujg_header[0] ) && ( fileid[1] == ujg_header[1] ) ) ? UJG : LEPTON;\n        std::function<void(Sirikata::DecoderWriter*, size_t file_size)> known_size_callback = &nop;\n        Sirikata::DecoderWriter * write_target = writer;\n        if (compressed_output) {\n            Sirikata::Zlib0Writer * zwriter;\n            if (uninit_g_zlib_0_writer) {\n                zwriter = new(uninit_g_zlib_0_writer)Sirikata::Zlib0Writer(writer, 0);\n                uninit_g_zlib_0_writer = NULL;\n            }else {\n                zwriter = new Sirikata::Zlib0Writer(writer, 0);\n            }\n            known_size_callback = &nop;\n            write_target = zwriter;\n        }\n        str_out = new bounded_iostream( write_target,\n                                        known_size_callback,\n                                        Sirikata::JpegAllocator<uint8_t>());\n        if ( str_out->chkerr() ) {\n            fprintf( stderr, FWR_ERRMSG, filelist[file_no]);\n            errorlevel.store(2);\n            return false;\n        }\n    }\n    else {\n        // file is neither\n        filetype = UNK;\n        fprintf( stderr, \"filetype of file \\\"%s\\\" is unknown\", filelist[ file_no ] );\n        errorlevel.store(2);\n        return false;\n    }\n\n\n    return true;\n}\n\nbool is_needed_for_second_block(const std::vector<unsigned char>&segment) {\n    if (segment.size() <= 2) {\n        return true; // don't understand this type of header\n    }\n    if (segment[0] != 0xff) {\n        return true; // don't understand this type of header\n    }\n    switch (segment[1]) {\n      case 0xC4: // DHT segment\n      case 0xDB: // DQT segment\n      case 0xDD: // DRI segment\n      case 0xDA: // Start of scan\n      case 0xC0:\n      case 0xC1:\n      case 0xC2:\n        return true;\n      case 0xD8:\n      case 0xD9:\n        dev_assert(false && \"This should be filtered out by the previous loop\");\n        return true;\n      default:\n        return false;\n    }\n}\n/* -----------------------------------------------\n    Read in header & image data\n    ----------------------------------------------- */\ntemplate<class input_byte_stream>\nbool read_jpeg(std::vector<std::pair<uint32_t,\n                                     uint32_t>> *huff_input_offsets,\n               input_byte_stream *jpg_in,\n               Sirikata::Array1d<uint8_t, 2> header,\n               bool is_embedded_jpeg){\n    if (jpeg_embedding_offset) {\n        prefix_grbs = jpeg_embedding_offset + 2;\n        prefix_grbgdata = aligned_alloc(prefix_grbs);\n        prefix_grbgdata[0] = header[0];\n        prefix_grbgdata[1] = header[1];\n        prefix_grbs = jpg_in->read(prefix_grbgdata + 2, jpeg_embedding_offset);\n        always_assert((size_t)prefix_grbs == jpeg_embedding_offset); // the ffd8 gets baked in...again\n    }\n    std::vector<unsigned char> segment(1024); // storage for current segment\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   crst = 0; // current rst marker counter\n    unsigned int   cpos = 0; // rst marker counter\n    unsigned char  tmp;\n\n    abytewriter* huffw;\n    abytewriter* hdrw;\n    abytewriter* grbgw;\n\n    // preset count of scans\n    scnc = 0;\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n    hdrs = 0; // size of header data, start with 0\n\n    // start huffman writer\n    huffw = new abytewriter( 0 );\n    hufs  = 0; // size of image data, start with 0\n\n    // JPEG reader loop\n    while ( true ) {\n        if ( type == 0xDA ) { // if last marker was sos\n            // switch to huffman data reading mode\n            cpos = 0;\n            crst = 0;\n            while ( true ) {\n                huff_input_offsets->push_back(std::pair<uint32_t, uint32_t>(huffw->getpos(),\n                                                                            jpg_in->getsize()));\n                // read byte from imagedata\n                if ( jpg_in->read_byte( &tmp) == false ) {\n                    early_eof(hdrw, huffw);\n                    fprintf(stderr, \"Early EOF\\n\");\n                    break;\n                }\n                // non-0xFF loop\n                if ( tmp != 0xFF ) {\n                    crst = 0;\n                    while ( tmp != 0xFF ) {\n                        huffw->write( tmp );\n                        if ( jpg_in->read_byte( &tmp ) == false ) {\n                            early_eof(hdrw, huffw);\n                            break;\n                        }\n                    }\n                }\n\n                // treatment of 0xFF\n                if ( tmp == 0xFF ) {\n                    if ( jpg_in->read_byte( &tmp ) == false ) {\n                        early_eof(hdrw, huffw);\n                        break; // read next byte & check\n                    }\n                    if ( tmp == 0x00 ) {\n                        crst = 0;\n                        // no zeroes needed -> ignore 0x00. write 0xFF\n                        huffw->write( 0xFF );\n                        write_byte_bill(Billing::DELIMITERS, false, 1);\n                    }\n                    else if ( tmp == 0xD0 + ( cpos & 7 ) ) { // restart marker\n                        // increment rst counters\n                        write_byte_bill(Billing::DELIMITERS, false, 2);\n                        cpos++;\n                        crst++;\n                        while (rst_cnt.size() <= (size_t)scnc) {\n                            rst_cnt.push_back(0);\n                        }\n                        ++rst_cnt.at(scnc);\n                    }\n                    else { // in all other cases leave it to the header parser routines\n                        // store number of falsely set rst markers\n                        if((int)rst_err.size() < scnc) {\n                            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n                        }\n                        rst_err.push_back(crst);\n                        // end of current scan\n                        scnc++;\n                        always_assert(rst_err.size() == (size_t)scnc && \"All reset errors must be accounted for\");\n                        // on with the header parser routines\n                        segment[ 0 ] = 0xFF;\n                        segment[ 1 ] = tmp;\n                        break;\n                    }\n                }\n                else {\n                    // otherwise this means end-of-file, so break out\n                    break;\n                }\n            }\n        }\n        else {\n            // read in next marker\n            if ( jpg_in->read( segment.data(), 2 ) != 2 ) break;\n            if ( segment[ 0 ] != 0xFF ) {\n                // ugly fix for incorrect marker segment sizes\n                fprintf( stderr, \"size mismatch in marker segment FF %2X\", type );\n                errorlevel.store(2);\n                if ( type == 0xFE ) { //  if last marker was COM try again\n                    if ( jpg_in->read( segment.data(), 1) != 1 ) break;\n                    if ( segment[ 0 ] == 0xFF ) errorlevel.store(1);\n                }\n                if ( errorlevel.load() == 2 ) {\n                    delete ( hdrw );\n                    delete ( huffw );\n                    return false;\n                }\n            }\n        }\n\n        // read segment type\n        type = segment[ 1 ];\n\n        // if EOI is encountered make a quick exit\n        if ( type == EOI[1] ) {\n            standard_eof(hdrw, huffw);\n            // everything is done here now\n            break;\n        }\n\n        // read in next segments' length and check it\n        if ( jpg_in->read( segment.data() + 2, 2 ) != 2 ) break;\n        len = 2 + B_SHORT( segment[ 2 ], segment[ 3 ] );\n        if ( len < 4 ) break;\n\n        // realloc segment data if needed\n        segment.resize(len);\n\n        // read rest of segment, store back in header writer\n        if ( jpg_in->read( ( segment.data() + 4 ), ( len - 4 ) ) !=\n            ( unsigned short ) ( len - 4 ) ) break;\n        if (start_byte == 0 || is_needed_for_second_block(segment)) {\n            hdrw->write_n( segment.data(), len );\n        }\n    }\n    // JPEG reader loop end\n\n    // free writers\n    delete ( hdrw );\n    delete ( huffw );\n\n    // check if everything went OK\n    if ( hdrs == 0 ) {\n        fprintf( stderr, \"unexpected end of data encountered in header\" );\n        errorlevel.store(2);\n        return false;\n    }\n    if ( hufs == 0 ) {\n        fprintf( stderr, \"unexpected end of data encountered in huffman\" );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // store garbage at EOI\n    grbgw = new abytewriter( 1024 );\n    unsigned char grb0 = jpg_in->get_penultimate_read();\n    unsigned char grb1 = jpg_in->get_last_read();\n    grbgw->write( grb0 ); // should be 0xff (except if truncated)\n    grbgw->write( grb1 ); // should be d9 (except if truncated)\n    while( true ) {\n        len = jpg_in->read( segment.data(), segment.size() );\n        if ( len == 0 ) break;\n        grbgw->write_n( segment.data(), len );\n    }\n    grbgdata = grbgw->getptr_aligned();\n    grbs     = grbgw->getpos();\n    delete ( grbgw );\n    if (grbs == sizeof(EOI) && 0 == memcmp(grbgdata, EOI, sizeof(EOI))) {\n        grbs = 0;\n        aligned_dealloc(grbgdata);\n        grbgdata = NULL;\n    }\n\n    // get filesize\n    jpgfilesize = jpg_in->getsize();\n\n    // parse header for image info\n    if ( !setup_imginfo_jpg(false) ) {\n        return false;\n    }\n\n\n    return true;\n}\n\n\nenum MergeJpegStreamingStatus{\n    STREAMING_ERROR = 0,\n    STREAMING_SUCCESS = 1,\n    STREAMING_NEED_DATA = 2,\n    STREAMING_DISABLED = 3\n};\n\nbool aligned_memchr16ff(const unsigned char *local_huff_data) {\n#if USE_SCALAR\n    return memchr(local_huff_data, 0xff, 16) != NULL;\n#else\n    __m128i buf = _mm_load_si128((__m128i const*)local_huff_data);\n    __m128i ff = _mm_set1_epi8(-1);\n    __m128i res = _mm_cmpeq_epi8(buf, ff);\n    uint32_t movmask = _mm_movemask_epi8(res);\n    bool retval = movmask != 0x0;\n    dev_assert (retval == (memchr(local_huff_data, 0xff, 16) != NULL));\n    return retval;\n#endif\n}\n\nunsigned char hex_to_nibble(char val) {\n    if (val >= 'A' && val <= 'F') {\n        return val - 'A' + 10;\n    }\n    if (val >= 'a' && val <= 'f') {\n        return val - 'a' + 10;\n    }\n    return val - '0';\n}\nunsigned char hex_pair_to_byte(char big, char little) {\n    return hex_to_nibble(big) * 16 + hex_to_nibble(little);\n}\nbool hex_to_bin(unsigned char *output, const char *input, size_t output_size) {\n    size_t i = 0;\n    for (; i < output_size && input[i * 2] && input[i * 2 + 1]; ++i) {\n        output[i] = hex_pair_to_byte(input[i * 2], input[i * 2 + 1]);\n    }\n    return i == output_size;\n}\nbool rst_cnt_ok(int scan, unsigned int num_rst_markers_this_scan) {\n    if (rstp.empty()) {\n        return false;\n    }\n    if (!rst_cnt_set) {\n        return true;\n    }\n    return rst_cnt.size() > (size_t)scan - 1 && num_rst_markers_this_scan < rst_cnt.at(scan - 1);\n}\n\n\nThreadHandoff crystallize_thread_handoff(abitreader *reader,\n                                         const std::vector<std::pair<uint32_t, uint32_t> >&huff_input_offsets,\n                                         int mcu_y,\n                                         int lastdc[4],\n                                         int luma_mul) {\n    auto iter = std::lower_bound(huff_input_offsets.begin(), huff_input_offsets.end(),\n                                 std::pair<uint32_t, uint32_t>(reader->getpos(), reader->getpos()));\n    uint32_t mapped_item = 0;\n    if (iter != huff_input_offsets.begin()) {\n        --iter;\n    }\n    if (iter != huff_input_offsets.end()) {\n        mapped_item = iter->second;\n        mapped_item += reader->getpos() - iter->first;\n    }\n    //fprintf(stderr, \"ROWx (%08lx): %x -> %x\\n\", reader->debug_peek(), reader->getpos(), mapped_item);\n    ThreadHandoff retval = ThreadHandoff::zero();\n    retval.segment_size = mapped_item; // the caller will need to take the difference of the chosen items\n    // to compute the actual segment size\n    for (unsigned int i = 0; i < 4 && i < sizeof(retval.last_dc)/ sizeof(retval.last_dc[0]); ++i) {\n        retval.last_dc[i] = lastdc[i];\n        retval.luma_y_start = luma_mul * mcu_y;\n        retval.luma_y_end = luma_mul * (mcu_y + 1);\n    }\n\n    std::tie( retval.num_overhang_bits, retval.overhang_byte ) = reader->overhang();\n\n/*\n    fprintf(stderr, \"%d: %d -> %d  lastdc %d %d %d size %d overhang %d (cnt: %d)\\n\",\n            mcu_y,\n            retval.luma_y_start,\n            retval.luma_y_end,\n            retval.last_dc[0],\n            retval.last_dc[1],\n            retval.last_dc[2],\n            retval.segment_size,\n            retval.overhang_byte,\n            retval.num_overhang_bits);\n*/\n    return retval;\n}\n\nMergeJpegStreamingStatus merge_jpeg_streaming(MergeJpegProgress *stored_progress, const unsigned char * local_huff_data, unsigned int max_byte_coded,\n                                              bool flush) {\n    MergeJpegProgress progress(stored_progress);\n    unsigned char SOI[ 2 ] = { 0xFF, 0xD8 }; // SOI segment\n    //unsigned char EOI[ 2 ] = { 0xFF, 0xD9 }; // EOI segment\n\n    unsigned char  type = 0x00; // type of current marker segment\n\n    if (progress.ipos == 0 && progress.hpos == 0 && progress.scan == 1 && progress.within_scan == false) {\n        always_assert(max_file_size > grbs && \"Lepton only supports files that have some scan data\");\n        str_out->set_bound(max_file_size - grbs);\n\n        // write SOI\n        str_out->write( SOI, 2 );\n    }\n\n    // JPEG writing loop\n    while ( true )\n    {\n        if (!progress.within_scan) {\n            progress.within_scan = true;\n            // store current header position\n            unsigned int   tmp; // temporary storage variable\n            tmp = progress.hpos;\n\n            // seek till start-of-scan\n            for ( type = 0x00; type != 0xDA; ) {\n                if ( 3 + (uint64_t) progress.hpos >= hdrs ) break;\n                type = hdrdata[ progress.hpos + 1 ];\n                int len = 2 + B_SHORT( hdrdata[ progress.hpos + 2 ], hdrdata[progress.hpos + 3 ] );\n                progress.hpos += len;\n            }\n            unsigned int actual_progress_hpos = std::min(progress.hpos, hdrs);\n            // write header data to file\n            str_out->write( hdrdata + tmp, ( actual_progress_hpos - tmp ) );\n            for (unsigned int i = actual_progress_hpos; i < progress.hpos; ++i) {\n                str_out->write(\"\", 1); // write out null bytes beyond buffer\n            }\n            if ((!g_use_seccomp) && post_byte == 0) {\n                post_byte = clock();\n            }\n\n            // get out if last marker segment type was not SOS\n            if ( type != 0xDA ) break;\n\n            // (re)set corrected rst pos\n            progress.cpos = 0;\n            progress.ipos = scnp.at(progress.scan - 1);\n        }\n        if ((int)progress.scan > scnc + 1) { // don't want to go beyond our known number of scans (FIXME: danielrh@ is this > or >= )\n            break;\n        }\n        if (progress.ipos < max_byte_coded) {\n            timing_operation_first_byte( 'd' );\n        }\n        // write & expand huffman coded image data\n        unsigned int progress_ipos = progress.ipos;\n        unsigned int progress_scan = scnp.at(progress.scan);\n        unsigned int rstp_progress_rpos = rstp.empty() ? INT_MAX : rstp[ progress.rpos ];\n        const unsigned char mrk = 0xFF; // marker start\n        const unsigned char stv = 0x00; // 0xFF stuff value\n        for ( ; progress_ipos & 0xf; progress_ipos++ ) {\n            if (__builtin_expect(!(progress_ipos < max_byte_coded && (progress_scan == 0 || progress_ipos < progress_scan)), 0)) {\n                break;\n            }\n            uint8_t byte_to_write = local_huff_data[progress_ipos];\n            str_out->write_byte(byte_to_write);\n            // check current byte, stuff if needed\n            if (__builtin_expect(byte_to_write == 0xFF, 0))\n                str_out->write_byte(stv);\n            // insert restart markers if needed\n            if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan)) {\n                    const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                    str_out->write_byte(mrk);\n                    str_out->write_byte(rst);\n                    progress.rpos++; progress.cpos++;\n                    rstp_progress_rpos = rstp.at(progress.rpos);\n                    ++progress.num_rst_markers_this_scan;\n                }\n            }\n        }\n\n        while(true) {\n            if (__builtin_expect(!(progress_ipos + 15 < max_byte_coded && (progress_scan == 0 || progress_ipos + 15 < progress_scan)), 0)) {\n                break;\n            }\n            if ( __builtin_expect(aligned_memchr16ff(local_huff_data + progress_ipos)\n                                  || (progress_ipos <= rstp_progress_rpos\n                                      && progress_ipos + 15 >= rstp_progress_rpos), 0)){\n                // insert restart markers if needed\n                for (int veci = 0 ; veci < 16; ++veci, ++progress_ipos ) {\n                    if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                        uint8_t byte_to_write = local_huff_data[progress_ipos];\n                        str_out->write_byte(byte_to_write);\n                        // check current byte, stuff if needed\n                        if (__builtin_expect(byte_to_write == 0xFF, 0)) {\n                            str_out->write_byte(stv);\n                        }\n                        if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan)) {\n                                const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                                str_out->write_byte(mrk);\n                                str_out->write_byte(rst);\n                                progress.rpos++; progress.cpos++;\n                                rstp_progress_rpos = rstp.at(progress.rpos);\n                                ++progress.num_rst_markers_this_scan;\n                        }\n                    } else {\n                        uint8_t byte_to_write = local_huff_data[progress_ipos];\n                        str_out->write_byte(byte_to_write);\n                        // check current byte, stuff if needed\n                        if (__builtin_expect(byte_to_write == 0xFF, 0)) {\n                            str_out->write_byte(stv);\n                        }\n                    }\n                }\n            } else {\n                str_out->write(local_huff_data + progress_ipos, 16);\n                progress_ipos+=16;\n            }\n        }\n        for ( ; ; progress_ipos++ ) {\n            if (__builtin_expect(!(progress_ipos < max_byte_coded && (progress_scan == 0 || progress_ipos < progress_scan)), 0)) {\n                break;\n            }\n            uint8_t byte_to_write = local_huff_data[progress_ipos];\n            str_out->write_byte(byte_to_write);\n            // check current byte, stuff if needed\n            if (__builtin_expect(byte_to_write == 0xFF, 0))\n                str_out->write_byte(stv);\n            // insert restart markers if needed\n            if (__builtin_expect(progress_ipos == rstp_progress_rpos, 0)) {\n                if (rst_cnt_ok(progress.scan, progress.num_rst_markers_this_scan )) {\n                    const unsigned char rst = 0xD0 + ( progress.cpos & 7);\n                    str_out->write_byte(mrk);\n                    str_out->write_byte(rst);\n                    progress.rpos++; progress.cpos++;\n                    rstp_progress_rpos = rstp.at(progress.rpos);\n                    ++progress.num_rst_markers_this_scan;\n                }\n            }\n        }\n        progress.ipos = progress_ipos;\n        if (scnp.at(progress.scan) == 0 && !flush) {\n            return STREAMING_NEED_DATA;\n        }\n        if (progress.ipos >= max_byte_coded && progress.ipos != scnp.at(progress.scan) && !flush) {\n            return STREAMING_NEED_DATA;\n        }\n        // insert false rst markers at end if needed\n        if (progress.scan - 1 < rst_err.size()) {\n            while ( rst_err.at(progress.scan - 1) > 0 ) {\n                const unsigned char rst = 0xD0 + ( progress.cpos & 7 );\n                str_out->write_byte(mrk);\n                str_out->write_byte(rst);\n                progress.cpos++;    rst_err.at(progress.scan - 1)--;\n            }\n        }\n        progress.num_rst_markers_this_scan = 0;\n        progress.within_scan = false;\n        // proceed with next scan\n        progress.scan++;\n        if(str_out->has_reached_bound()) {\n            check_decompression_memory_bound_ok();\n            break;\n        }\n    }\n\n    // write EOI (now EOI is stored in garbage of at least 2 bytes)\n    // this guarantees that we can stop the write in time.\n    // if it used too much memory\n    // str_out->write( EOI, 1, 2 );\n    str_out->set_bound(max_file_size);\n    check_decompression_memory_bound_ok();\n    // write garbage if needed\n    if ( grbs > 0 )\n        str_out->write( grbgdata, grbs );\n    check_decompression_memory_bound_ok();\n    str_out->flush();\n\n    // errormessage if write error\n    if ( str_out->chkerr() ) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return STREAMING_ERROR;\n    }\n    // get filesize\n\n    jpgfilesize = str_out->getsize();\n    // get filesize\n    if (ujg_base_in) {\n        ujgfilesize = ujg_base_in->getsize();\n    } else {\n        ujgfilesize = 4096 * 1024;\n    }\n#ifndef _WIN32\n    //FIXME\n    if (!g_use_seccomp) {\n        clock_t final = clock();\n        struct timeval fin = {0,0};\n        gettimeofday(&fin,NULL);\n        double begin = current_operation_begin.tv_sec + (double)current_operation_begin.tv_usec / 1000000.;\n        double end = fin.tv_sec + (double)fin.tv_usec / 1000000.;\n        double first_byte = current_operation_first_byte.tv_sec + (double)current_operation_first_byte.tv_usec / 1000000.;\n        double begin_to_end = end - begin;\n        double begin_to_first_byte = begin_to_end;\n        if (current_operation_first_byte.tv_sec != 0) { // if we were successful\n            begin_to_first_byte = first_byte - begin;\n        }\n\n        fprintf(stderr, \"TIMING (new method): %f to first byte %f total\\n\",\n                begin_to_first_byte,\n                begin_to_end);\n        (void)final;\n/*\n        fprintf(stderr, \"TIMING (recode): %f to first byte %f total\\n\",\n                (double)(post_byte - pre_byte)/(double)CLOCKS_PER_SEC,\n                (final - pre_byte)/(double)CLOCKS_PER_SEC);\n        fprintf(stderr, \"TIMING(overall): %f to first byte %f total\\n\",\n                (post_byte - overall_start)/(double)CLOCKS_PER_SEC,\n                (final - overall_start)/(double)CLOCKS_PER_SEC);\n*/\n        fprintf(stderr, \"Read took: %f\\n\",\n                (read_done - overall_start)/(double)CLOCKS_PER_SEC);\n    }\n#endif\n    return STREAMING_SUCCESS;\n\n}\n\n\n\n\n/* -----------------------------------------------\n    JPEG decoding routine\n    ----------------------------------------------- */\n\nbool decode_jpeg(const std::vector<std::pair<uint32_t, uint32_t> > & huff_input_offsets,\n                 std::vector<ThreadHandoff>*luma_row_offset_return)\n{\n    abitreader* huffr; // bitwise reader for image data\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // current position in header\n\n    int lastdc[ 4 ] = {0, 0, 0, 0}; // last dc for each component\n    Sirikata::Aligned256Array1d<int16_t,64> block; // store block for coeffs\n    int peobrun; // previous eobrun\n    unsigned int eobrun; // run of eobs\n    int rstw; // restart wait counter\n\n    int cmp, bpos, dpos;\n    int mcu = 0, sub, csc;\n    int eob, sta;\n    bool is_baseline = true;\n    max_cmp = 0; // the maximum component in a truncated image\n    max_bpos = 0; // the maximum band in a truncated image\n    memset(max_dpos, 0, sizeof(max_dpos)); // the maximum dpos in a truncated image\n    max_sah = 0; // the maximum bit in a truncated image\n\n    // open huffman coded image data for input in abitreader\n    huffr = new abitreader( huffdata, hufs );\n    // preset count of scans\n    scnc = 0;\n\n    // JPEG decompression loop\n    while ( true )\n    {\n        // seek till start-of-scan, parse only DHT, DRI and SOS\n        for ( type = 0x00; type != 0xDA; ) {\n            if ( 3 + ( uint64_t ) hpos >= hdrs ) break;\n            type = hdrdata[ hpos + 1 ];\n            len = 2 + B_SHORT( hdrdata[ hpos + 2 ], hdrdata[ hpos + 3 ] );\n            if ( ( type == 0xC4 ) || ( type == 0xDA ) || ( type == 0xDD ) ) {\n                std::vector<unsigned char> over_data;\n                unsigned char * hdr_seg_data = NULL;\n                if ((uint64_t)hpos + (uint64_t)len > (uint64_t)hdrs) {\n                    over_data.insert(over_data.end(), &hdrdata[hpos], &hdrdata[hpos] + (hdrs - hpos));\n                    over_data.resize(len);\n                    hdr_seg_data = &over_data[0];\n                } else {\n                    hdr_seg_data = &( hdrdata[ hpos ] );\n                }\n                if ( !parse_jfif_jpg( type, len, len, hdr_seg_data ) ) {\n                    delete huffr;\n                    return false;\n                }\n            }\n            hpos += len;\n        }\n\n        // get out if last marker segment type was not SOS\n        if ( type != 0xDA ) break;\n\n        // check if huffman tables are available\n        for ( csc = 0; csc < cs_cmpc; csc++ ) {\n            cmp = cs_cmp[ csc ];\n            if ( (( jpegtype == 1 || (( cs_cmpc > 1 || cs_to == 0 ) && cs_sah == 0 )) && htset[ 0 ][ cmpnfo[cmp].huffdc ] == 0 ) || \n                 ( jpegtype == 1 && htset[ 1 ][ cmpnfo[cmp].huffdc ] == 0 ) ||\n                 ( cs_cmpc == 1 && cs_to > 0 && cs_sah == 0 && htset[ 1 ][ cmpnfo[cmp].huffac ] == 0 ) ) {\n                fprintf( stderr, \"huffman table missing in scan%i\", scnc );\n                delete huffr;\n                errorlevel.store(2);\n                return false;\n            }\n        }\n\n\n        // intial variables set for decoding\n        cmp  = cs_cmp[ 0 ];\n        csc  = 0;\n        mcu  = 0;\n        sub  = 0;\n        dpos = 0;\n        if (!huffr->eof) {\n            max_bpos = std::max(max_bpos, cs_to);\n            // FIXME: not sure why only first bit of cs_sah is examined but 4 bits of it are stored\n            max_sah = std::max(max_sah, std::max(cs_sal,cs_sah));\n            for (int i = 0; i < cs_cmpc; ++i) {\n                max_cmp = std::max(max_cmp, cs_cmp[i]);\n            }\n        }\n/*\n        // startup\n        luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                     huff_input_offsets,\n                                                                     mcu / mcuh,\n                                                                     lastdc,\n                                                                     cmpnfo[0].bcv / mcuv));\n*/\n        bool do_handoff_print = true;\n        // JPEG imagedata decoding routines\n        while ( true )\n        {\n            // (re)set last DCs for diff coding\n            lastdc[ 0 ] = 0;\n            lastdc[ 1 ] = 0;\n            lastdc[ 2 ] = 0;\n            lastdc[ 3 ] = 0;\n\n            // (re)set status\n            sta = 0;\n\n            // (re)set eobrun\n            eobrun  = 0;\n            peobrun = 0;\n\n            // (re)set rst wait counter\n            rstw = rsti;\n            if (cs_cmpc != colldata.get_num_components()) {\n                if (!g_allow_progressive) {\n                    custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n                } else {\n                    is_baseline = false;\n                }\n            }\n\n            if (jpegtype != 1) {\n                if (!g_allow_progressive) {\n                    custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n                } else {\n                    is_baseline = false;\n                }\n            }\n            // decoding for interleaved data\n            if ( cs_cmpc > 1 )\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential interleaved decoding <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         mcu / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n\n                        if(!huffr->eof) {\n                            max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block read\n                        }\n                        // decode block\n                        eob = decode_block_seq( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                            block.begin() );\n                        if ( eob > 1 && !block[ eob - 1 ] ) {\n                            fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                            errorlevel.store(1);\n                        }\n\n                        // fix dc\n                        block[ 0 ] += lastdc[ cmp ];\n                        lastdc[ cmp ] = block[ 0 ];\n\n                        AlignedBlock&aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n\n                        // copy to colldata\n                        for ( bpos = 0; bpos < eob; bpos++ ) {\n                            aligned_block.mutable_coefficients_zigzag(bpos) = block[ bpos ];\n                        }\n                        // check for errors, proceed if no error encountered\n                        int old_mcu = mcu;\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (mcu % mcuh == 0 && old_mcu !=  mcu) {\n                            do_handoff_print = true;\n                            //fprintf(stderr, \"ROW %d\\n\", (int)row_handoff.size());\n                            \n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else if ( cs_sah == 0 ) {\n                    // ---> progressive interleaved DC decoding <---\n                    // ---> succesive approximation first stage <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         mcu / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        sta = decode_dc_prg_fs( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            block.begin() );\n\n                        // fix dc for diff coding\n                        colldata.set((BlockType)cmp,0,dpos) = block[0] + lastdc[ cmp ];\n                        \n                        uint16_t u_last_dc = lastdc[ cmp ] = colldata.set((BlockType)cmp,0,dpos);\n                        u_last_dc <<= cs_sal; // lastdc might be negative--this avoids UB\n                        // bitshift for succesive approximation\n                        colldata.set((BlockType)cmp,0,dpos) = u_last_dc;\n\n                        // next mcupos if no error happened\n                        int old_mcu = mcu;\n                        if ( sta != -1 ) {\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        }\n                        if (mcu % mcuh == 0 && old_mcu !=  mcu) {\n                            do_handoff_print = true;\n                            //fprintf(stderr, \"ROW %d\\n\", (int)row_handoff.size());\n                            \n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else {\n                    // ---> progressive interleaved DC decoding <---\n                    // ---> succesive approximation later stage <---\n                    while ( sta == 0 ) {\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        // decode next bit\n                        sta = decode_dc_prg_sa( huffr,\n                            block.begin() );\n\n                        // shift in next bit\n                        colldata.set((BlockType)cmp,0,dpos) += block[0] << cs_sal;\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n            }\n            else // decoding for non interleaved data\n            {\n                if ( jpegtype == 1 ) {\n                    int vmul = cmpnfo[0].bcv / mcuv;\n                    int hmul = cmpnfo[0].bch / mcuh;\n                    // ---> sequential non interleaved decoding <---\n                    while ( sta == 0 ) {\n                        if (do_handoff_print) {\n                            luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                         huff_input_offsets,\n                                                                                         (dpos/(hmul * vmul)) / mcuh,\n                                                                                         lastdc,\n                                                                                         cmpnfo[0].bcv / mcuv));\n                            do_handoff_print = false;\n                        }\n                        if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                        // decode block\n                        eob = decode_block_seq( huffr,\n                            &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                            block.begin() );\n                        if ( eob > 1 && !block[ eob - 1 ] ) {\n                            fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                            errorlevel.store(1);\n                        }\n                        // fix dc\n                        block[ 0 ] += lastdc[ cmp ];\n                        lastdc[ cmp ] = block[ 0 ];\n\n                        // copy to colldata\n                        AlignedBlock& aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                        for ( bpos = 0; bpos < eob; bpos++ ) {\n                            aligned_block.mutable_coefficients_zigzag(bpos) = block[ bpos ];\n                        }\n                        \n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcuposn( &cmp, &dpos, &rstw);\n                        mcu = dpos / (hmul * vmul);\n                        if (cmp == 0 && (mcu % mcuh == 0) && (dpos %(hmul *vmul) == 0)) {\n                            do_handoff_print = true;\n\n                        }\n                        if(huffr->eof) {\n                            sta = 2;\n                            break;\n                        }\n\n                    }\n                }\n                else if ( cs_to == 0 ) {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved DC decoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            if (do_handoff_print) {\n                                luma_row_offset_return->push_back(crystallize_thread_handoff(huffr,\n                                                                                             huff_input_offsets,\n                                                                                             dpos / cmpnfo[cmp].bch,\n                                                                                             lastdc,\n                                                                                             cmpnfo[0].bcv / mcuv));\n                                do_handoff_print = false;\n                            }\n\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            sta = decode_dc_prg_fs( huffr,\n                                &(htrees[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                block.begin() );\n\n                            // fix dc for diff coding\n                            colldata.set((BlockType)cmp,0,dpos) = block[0] + lastdc[ cmp ];\n                            lastdc[ cmp ] = colldata.set((BlockType)cmp,0,dpos);\n\n                            // bitshift for succesive approximation\n                            colldata.set((BlockType)cmp,0,dpos) <<= cs_sal;\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (cmp == 0 && dpos % cmpnfo[cmp].bch == 0) {\n                                do_handoff_print = true;\n                            }\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved DC decoding <---\n                        // ---> succesive approximation later stage <---\n                        while( sta == 0 ) {\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            // decode next bit\n                            sta = decode_dc_prg_sa( huffr,\n                                block.begin() );\n\n                            // shift in next bit\n                            colldata.set((BlockType)cmp,0,dpos) += block[0] << cs_sal;\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                }\n                else {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved AC decoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                            // decode block\n                            eob = decode_ac_prg_fs( huffr,\n                                                    &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                    block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for non optimal coding\n                            if ( ( eob == cs_from ) && ( eobrun > 0 ) &&\n                                ( peobrun > 0 ) && ( peobrun <\n                                hcodes[ 1 ][ cmpnfo[cmp].huffac ].max_eobrun - 1 ) ) {\n                                fprintf( stderr,\n                                    \"reconstruction of non optimal coding not supported\" );\n                                errorlevel.store(1);\n                            }\n                            AlignedBlock &aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                            // copy to colldata\n                            for ( bpos = cs_from; bpos < eob; bpos++ ) {\n                                uint16_t block_bpos = block[ bpos ];\n                                block_bpos <<= cs_sal; // prevents UB since block_bpos could be negative\n                                aligned_block.mutable_coefficients_zigzag(bpos) = block_bpos;\n                            }\n                            // check for errors\n                            if ( eob < 0 ) sta = -1;\n                            else sta = skip_eobrun( &cmp, &dpos, &rstw, &eobrun );\n\n                            // proceed only if no error encountered\n                            if ( sta == 0 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved AC decoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            // copy from colldata\n                            AlignedBlock &aligned_block = colldata.mutable_block((BlockType)cmp, dpos);\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] = aligned_block.coefficients_zigzag(bpos);\n                            }\n                            if ( eobrun == 0 ) {\n                                if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                                // decode block (long routine)\n                                eob = decode_ac_prg_sa( huffr,\n                                                        &(htrees[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                        block.begin(), &eobrun, cs_from, cs_to );\n\n                                // check for non optimal coding\n                                if ( ( eob == cs_from ) && ( eobrun > 0 ) &&\n                                    ( peobrun > 0 ) && ( peobrun <\n                                    hcodes[ 1 ][ cmpnfo[cmp].huffac ].max_eobrun - 1 ) ) {\n                                    fprintf( stderr,\n                                        \"reconstruction of non optimal coding not supported\" );\n                                    errorlevel.store(1);\n                                }\n\n                            }\n                            else {\n                                if(!huffr->eof) max_dpos[cmp] = std::max(dpos, max_dpos[cmp]); // record the max block serialized\n                                // decode block (short routine)\n                                eob = decode_eobrun_sa( huffr,\n                                                        block.begin(), &eobrun, cs_from, cs_to );\n                                if ( eob > 1 && !block[ eob - 1 ] ) {\n                                    fprintf( stderr, \"cannot encode image with eob after last 0\" );\n                                    errorlevel.store(1);\n                                }\n                            }\n                            // store eobrun\n                            peobrun = eobrun;\n                            // copy back to colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                uint16_t block_bpos = block[ bpos ];\n                                block_bpos <<= cs_sal;\n                                aligned_block.mutable_coefficients_zigzag(bpos) += block_bpos;\n                            }\n                            // proceed only if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if(huffr->eof) {\n                                sta = 2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            // unpad huffman reader / check padbit\n            if ( padbit != -1 ) {\n                if ( padbit != huffr->unpad( padbit ) ) {\n                    fprintf( stderr, \"inconsistent use of padbits\" );\n                    padbit = 1;\n                    errorlevel.store(1);\n                }\n            }\n            else {\n                padbit = huffr->unpad( padbit );\n            }\n            // evaluate status\n            if ( sta == -1 ) { // status -1 means error\n                fprintf( stderr, \"decode error in scan%i / mcu%i\",\n                    scnc, ( cs_cmpc > 1 ) ? mcu : dpos );\n                delete huffr;\n                errorlevel.store(2);\n                return false;\n            }\n            else if ( sta == 2 ) { // status 2/3 means done\n                scnc++; // increment scan counter\n                break; // leave decoding loop, everything is done here\n            }\n            // else if ( sta == 1 ); // status 1 means restart - so stay in the loop\n        }\n    }\n    if (early_eof_encountered) {\n        colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n    }\n    luma_row_offset_return->push_back(crystallize_thread_handoff(huffr, huff_input_offsets, (uint16_t)(mcu / mcuh), lastdc, cmpnfo[0].bcv / mcuv));\n    for (size_t i = 1; i < luma_row_offset_return->size(); ++i) {\n        if ((*luma_row_offset_return)[i].luma_y_start < \n            (*luma_row_offset_return)[i-1].luma_y_end) {\n            (*luma_row_offset_return)[i].luma_y_start = (*luma_row_offset_return)[i-1].luma_y_end;\n        }\n    }\n    // check for unneeded data\n    if ( !huffr->eof ) {\n        fprintf( stderr, \"unneeded data found after coded image data\" );\n        errorlevel.store(1);\n    }\n\n    // clean up\n    delete( huffr );\n\n    if (is_baseline) {\n        g_allow_progressive = false;\n    }\n    return true;\n}\n\n\n/* -----------------------------------------------\n    JPEG encoding routine\n    ----------------------------------------------- */\n\nbool recode_jpeg( void )\n{\n    if (!g_use_seccomp) {\n        pre_byte = clock();\n    }\n    abitwriter*  huffw; // bitwise writer for image data\n    abytewriter* storw; // bytewise writer for storage of correction bits\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // current position in header\n\n    int lastdc[ 4 ]; // last dc for each component\n    Sirikata::Aligned256Array1d<int16_t, 64> block; // store block for coeffs\n    unsigned int eobrun; // run of eobs\n    int rstw; // restart wait counter\n\n    int cmp, bpos, dpos;\n    int mcu, sub, csc;\n    int eob, sta;\n    int tmp;\n\n    // open huffman coded image data in abitwriter\n    huffw = new abitwriter( ABIT_WRITER_PRELOAD, max_file_size);\n    huffw->fillbit = padbit;\n\n    // init storage writer\n    storw = new abytewriter( ABIT_WRITER_PRELOAD);\n\n    // preset count of scans and restarts\n    scnc = 0;\n    rstc = 0;\n    MergeJpegProgress streaming_progress;\n\n    // JPEG decompression loop\n    while ( true )\n    {\n        // seek till start-of-scan, parse only DHT, DRI and SOS\n        for ( type = 0x00; type != 0xDA; ) {\n            if ( hpos >= hdrs ) break;\n            type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0;\n            len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n            if ( ( type == 0xC4 ) || ( type == 0xDA ) || ( type == 0xDD ) ) {\n                if ( !parse_jfif_jpg( type, len, len > hdrs - hpos ? hdrs - hpos : len, &( hdrdata[ hpos ] ) ) ) {\n                    delete huffw;\n                    delete storw;\n                    return false;\n                }\n                int max_scan = 0;\n                for (int i = 0; i < cmpc; ++i) {\n                    max_scan = std::max(max_scan, cmpnfo[i].bcv);\n                }\n                rstp.reserve(max_scan);\n                scnp.reserve(max_scan);\n                hpos += len;\n            }\n            else {\n                hpos += len;\n                continue;\n            }\n        }\n\n        // get out if last marker segment type was not SOS\n        if ( type != 0xDA ) break;\n\n\n        // (re)alloc scan positons array\n        while ((int)scnp.size() < scnc + 2) {\n            scnp.push_back(0);\n        }\n\n        // (re)alloc restart marker positons array if needed\n        if ( rsti > 0 ) {\n            tmp = rstc + ( ( cs_cmpc > 1 ) ?\n                ( mcuc / rsti ) : ( cmpnfo[ cs_cmp[ 0 ] ].bc / rsti ) );\n            while ((int)rstp.size() <= tmp ) {\n                rstp.push_back((unsigned int) -1 );\n            }\n        }\n\n        // intial variables set for encoding\n        cmp  = cs_cmp[ 0 ];\n        csc  = 0;\n        mcu  = 0;\n        sub  = 0;\n        dpos = 0;\n\n        // store scan position\n        scnp.at(scnc) = huffw->getpos();\n        scnp.at(scnc + 1) = 0; // danielrh@ avoid uninitialized memory when doing progressive writeout\n        bool first_pass = true;\n        // JPEG imagedata encoding routines\n        while ( true )\n        {\n            // (re)set last DCs for diff coding\n            lastdc[ 0 ] = 0;\n            lastdc[ 1 ] = 0;\n            lastdc[ 2 ] = 0;\n            lastdc[ 3 ] = 0;\n\n            // (re)set status\n            sta = 0;\n\n            // (re)set eobrun\n            eobrun = 0;\n\n            // (re)set rst wait counter\n            rstw = rsti;\n            if (cs_cmpc != colldata.get_num_components() && !g_allow_progressive) {\n                custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n            }\n            if (jpegtype != 1 && !g_allow_progressive) {\n                custom_exit(ExitCode::PROGRESSIVE_UNSUPPORTED);\n            }\n            if ((jpegtype != 1 || cs_cmpc != colldata.get_num_components())\n                && colldata.is_memory_optimized(0)\n                && first_pass) {\n                colldata.init(cmpnfo, cmpc, mcuh, mcuv, false);\n            }\n            first_pass = false;\n            // encoding for interleaved data\n            if ( cs_cmpc > 1 )\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential interleaved encoding <---\n                    while ( sta == 0 ) {\n                        // copy from colldata\n                        const AlignedBlock &aligned_block = colldata.block((BlockType)cmp, dpos);\n                        //fprintf(stderr, \"Reading from cmp(%d) dpos %d\\n\", cmp, dpos);\n                        for ( bpos = 0; bpos < 64; bpos++ ) {\n                            block[bpos] = aligned_block.coefficients_zigzag(bpos);\n                        }\n                        int16_t dc = block[0];\n                        // diff coding for dc\n                        block[ 0 ] -= lastdc[ cmp ];\n                        lastdc[ cmp ] = dc;\n\n                        // encode block\n                        eob = encode_block_seq( huffw,\n                                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                block.begin() );\n\n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else if ( cs_sah == 0 ) {\n                    // ---> progressive interleaved DC encoding <---\n                    // ---> succesive approximation first stage <---\n                    while ( sta == 0 ) {\n                        // diff coding & bitshifting for dc\n                        tmp = colldata.at((BlockType)cmp , 0 , dpos ) >> cs_sal;\n                        block[ 0 ] = tmp - lastdc[ cmp ];\n                        lastdc[ cmp ] = tmp;\n\n                        // encode dc\n                        sta = encode_dc_prg_fs( huffw,\n                                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                block.begin() );\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else {\n                    // ---> progressive interleaved DC encoding <---\n                    // ---> succesive approximation later stage <---\n                    while ( sta == 0 ) {\n                        // fetch bit from current bitplane\n                        block[ 0 ] = BITN( colldata.at((BlockType)cmp , 0 , dpos ), cs_sal );\n\n                        // encode dc correction bit\n                        sta = encode_dc_prg_sa( huffw, block.begin() );\n\n                        // next mcupos if no error happened\n                        if ( sta != -1 )\n                            sta = next_mcupos( &mcu, &cmp, &csc, &sub, &dpos, &rstw, cs_cmpc);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n\n                    }\n                }\n            }\n            else // encoding for non interleaved data\n            {\n                if ( jpegtype == 1 ) {\n                    // ---> sequential non interleaved encoding <---\n                    while ( sta == 0 ) {\n                        const AlignedBlock& aligned_block = colldata.block((BlockType)cmp, dpos);\n                        // copy from colldata\n                        int16_t dc = block[ 0 ] = aligned_block.dc();\n                        for ( bpos = 1; bpos < 64; bpos++ )\n                            block[ bpos ] = aligned_block.coefficients_zigzag(bpos);\n\n                        // diff coding for dc\n                        block[ 0 ] -= lastdc[ cmp ];\n                        lastdc[ cmp ] = dc;\n\n                        // encode block\n                        eob = encode_block_seq( huffw,\n                            &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                block.begin() );\n\n                        // check for errors, proceed if no error encountered\n                        if ( eob < 0 ) sta = -1;\n                        else sta = next_mcuposn( &cmp, &dpos, &rstw);\n                        if (sta == 0 && huffw->no_remainder()) {\n                            merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n\n                    }\n                }\n                else if ( cs_to == 0 ) {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved DC encoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            // diff coding & bitshifting for dc\n                            tmp = colldata.at((BlockType)cmp , 0 , dpos ) >> cs_sal;\n                            block[ 0 ] = tmp - lastdc[ cmp ];\n                            lastdc[ cmp ] = tmp;\n\n                            // encode dc\n                            sta = encode_dc_prg_fs( huffw,\n                                &(hcodes[ 0 ][ cmpnfo[cmp].huffdc ]),\n                                                    block.begin() );\n\n                            // check for errors, increment dpos otherwise\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n                    }\n                    else {\n                        // ---> progressive non interleaved DC encoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            // fetch bit from current bitplane\n                            block[ 0 ] = BITN( colldata.at((BlockType)cmp , 0 , dpos ), cs_sal );\n\n                            // encode dc correction bit\n                            sta = encode_dc_prg_sa( huffw, block.begin() );\n\n                            // next mcupos if no error happened\n                            if ( sta != -1 )\n                                sta = next_mcuposn( &cmp, &dpos, &rstw );\n                        }\n                        if (str_out->has_exceeded_bound()) {\n                            sta = 2;\n                        }\n                    }\n                }\n                else {\n                    if ( cs_sah == 0 ) {\n                        // ---> progressive non interleaved AC encoding <---\n                        // ---> succesive approximation first stage <---\n                        while ( sta == 0 ) {\n                            const AlignedBlock& aligned_block = colldata.block((BlockType)cmp, dpos);\n                            // copy from colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] =\n                                    FDIV2( aligned_block.coefficients_zigzag(bpos), cs_sal );\n                            }\n                            // encode block\n                            eob = encode_ac_prg_fs( huffw,\n                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                                    block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for errors, proceed if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n\n                        // encode remaining eobrun\n                        encode_eobrun( huffw,\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                            &eobrun );\n\n                    }\n                    else {\n                        // ---> progressive non interleaved AC encoding <---\n                        // ---> succesive approximation later stage <---\n                        while ( sta == 0 ) {\n                            const AlignedBlock& aligned_block= colldata.block((BlockType)cmp, dpos);\n                            // copy from colldata\n                            for ( bpos = cs_from; bpos <= cs_to; bpos++ ) {\n                                block[ bpos ] =\n                                    FDIV2( aligned_block.coefficients_zigzag(bpos), cs_sal );\n                            }\n                            // encode block\n                            eob = encode_ac_prg_sa( huffw, storw,\n                                &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                                block.begin(), &eobrun, cs_from, cs_to );\n\n                            // check for errors, proceed if no error encountered\n                            if ( eob < 0 ) sta = -1;\n                            else sta = next_mcuposn( &cmp, &dpos, &rstw );\n                            if (sta == 0 && huffw->no_remainder()) {\n                                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n                            }\n                            if (str_out->has_exceeded_bound()) {\n                                sta = 2;\n                            }\n\n                        }\n\n                        // encode remaining eobrun\n                        encode_eobrun( huffw,\n                            &(hcodes[ 1 ][ cmpnfo[cmp].huffac ]),\n                            &eobrun );\n\n                        // encode remaining correction bits\n                        encode_crbits( huffw, storw );\n                    }\n                }\n            }\n\n            // pad huffman writer\n            huffw->pad( padbit );\n\n            // evaluate status\n            if ( sta == -1 ) { // status -1 means error\n                fprintf( stderr, \"encode error in scan%i / mcu%i\",\n                    scnc, ( cs_cmpc > 1 ) ? mcu : dpos );\n                delete huffw;\n                errorlevel.store(2);\n                return false;\n            }\n            else if ( sta == 2 ) { // status 2 means done\n                scnc++; // increment scan counter\n                break; // leave decoding loop, everything is done here\n            }\n            else if ( sta == 1 ) { // status 1 means restart\n                if ( rsti > 0 ) // store rstp & stay in the loop\n                    rstp.at(rstc++) = huffw->getpos() - 1;\n            }\n            huffw->flush_no_pad();\n            dev_assert(huffw->no_remainder() && \"this should have been padded\");\n            if (huffw->no_remainder()) {\n                merge_jpeg_streaming(&streaming_progress, huffw->peekptr(), huffw->getpos(), false);\n            }\n        }\n    }\n\n    // safety check for error in huffwriter\n    if ( huffw->error ) {\n        delete huffw;\n        fprintf( stderr, MEM_ERRMSG );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // get data into huffdata\n    huffdata = huffw->getptr();\n    hufs = huffw->getpos();\n    always_assert(huffw->no_remainder() && \"this should have been padded\");\n    merge_jpeg_streaming(&streaming_progress, huffdata, hufs, true);\n    if (!fast_exit) {\n        delete huffw;\n\n        // remove storage writer\n        delete storw;\n    }\n    // store last scan & restart positions\n    if (scnc >= scnp.size()) {\n        delete huffw;\n        fprintf( stderr, MEM_ERRMSG );\n        errorlevel.store(2);\n        return false;\n    }\n    scnp.at(scnc) = hufs;\n    if ( !rstp.empty() )\n        rstp.at(rstc) = hufs;\n\n\n    return true;\n}\n\n\n\n\n/* -----------------------------------------------\n    checks range of values, error if out of bounds\n    ----------------------------------------------- */\n\nbool check_value_range( void )\n{\n    int bad_cmp = 0, bad_bpos = 0, bad_dpos = 0;\n    bool bad_colldata = false;\n    // out of range should never happen with unmodified JPEGs\n    for (int cmp = 0; cmp < cmpc && cmp < 4; cmp++ ) {\n        int absmax[64];\n        for (int bpos = 0; bpos < 64; bpos++ ) {\n            absmax[zigzag_to_aligned.at(bpos)] = MAX_V( cmp, bpos );\n        }\n        for (int dpos = 0; dpos < cmpnfo[cmp].bc && dpos <= max_dpos[cmp] ; dpos++ ) {\n            const int16_t * raw_data = colldata.block_nosync((BlockType)cmp, dpos).raw_data();\n            for (int aligned_pos = 0; aligned_pos < 64; ++aligned_pos, ++raw_data) {\n                if ((*raw_data) > absmax[aligned_pos] ||\n                    (*raw_data) < -absmax[aligned_pos]) {\n                    int bpos = aligned_to_zigzag.at(aligned_pos);\n                    if (!early_eof_encountered) {\n                        fprintf( stderr, \"value out of range error: cmp%i, frq%i, val %i, max %i\",\n                             cmp, bpos, colldata.at_nosync((BlockType)cmp,bpos,dpos), absmax[aligned_pos] );\n                        errorlevel.store(2);\n                        return false;\n                    }\n                    bad_cmp = cmp;\n                    bad_bpos = bpos;\n                    bad_dpos = dpos;\n                    colldata.set((BlockType)bad_cmp, bad_bpos, bad_dpos) = 0; // zero this puppy out\n                    bad_colldata = true;\n                }\n            }\n        }\n    }\n    if (bad_colldata) {\n        colldata.set((BlockType)bad_cmp, bad_bpos, bad_dpos) = 0; // zero this puppy out\n    }\n    return true;\n}\n\n\nclass ThreadHandoffSegmentCompare {\npublic: bool operator() (const ThreadHandoff &a,\n                         const ThreadHandoff &b) const {\n    return a.segment_size < b.segment_size;\n}\n};\n\n/* -----------------------------------------------\n    write uncompressed JPEG file\n    ----------------------------------------------- */\nbool write_ujpg(std::vector<ThreadHandoff> row_thread_handoffs,\n                std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> >*jpeg_file_raw_bytes)\n{\n    unsigned char ujpg_mrk[ 64 ];\n    bool has_lepton_entropy_coding = (ofiletype == LEPTON || filetype == LEPTON );\n    Sirikata::JpegError err = Sirikata::JpegError::nil();\n\n    if (!has_lepton_entropy_coding) {\n        // UJG-Header\n        err = ujg_out->Write( ujg_header, 2 ).second;\n    } else {\n        // lepton-Header\n        err = ujg_out->Write( lepton_header, 2 ).second;\n    }\n    // store version number\n    ujpg_mrk[ 0 ] = ujgversion;\n    ujg_out->Write( ujpg_mrk, 1 );\n\n    // discard meta information from header if needed\n    if ( disc_meta )\n        if ( !rebuild_header_jpg() )\n            return false;\n    if (start_byte) {\n        std::vector<ThreadHandoff> local_row_thread_handoffs;\n        for (std::vector<ThreadHandoff>::iterator i = row_thread_handoffs.begin(),\n                 ie = row_thread_handoffs.end(); i != ie; ++i) {\n            auto j = i;\n            ++j;\n            if ((j == ie || i->segment_size >= start_byte)\n                && (max_file_size == 0 || i->segment_size <= max_file_size + start_byte)) {\n                local_row_thread_handoffs.push_back(*i);\n                //fprintf(stderr, \"OK: %d (%d %d)\\n\", i->segment_size, i->luma_y_start, i->luma_y_end);\n            } else {\n                //fprintf(stderr, \"XX: %d (%d %d)\\n\", i->segment_size, i->luma_y_start, i->luma_y_end);\n            }\n        }\n        row_thread_handoffs.swap(local_row_thread_handoffs);\n    }\n    if (start_byte) {\n        always_assert(jpeg_file_raw_bytes);\n    }\n    if (start_byte && jpeg_file_raw_bytes && !row_thread_handoffs.empty()) { // FIXME: respect jpeg_embedding?\n        if (row_thread_handoffs[0].segment_size >= start_byte) {\n            prefix_grbs = row_thread_handoffs[0].segment_size - start_byte;\n            if (row_thread_handoffs.size() > 1) {\n                if (prefix_grbs) {\n                    --prefix_grbs; //FIXME why is this ?!\n                }\n            }\n        } else {\n            prefix_grbs = 0;\n            custom_exit(ExitCode::ONLY_GARBAGE_NO_JPEG);\n        }\n        if (prefix_grbs > 0) {\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            always_assert(jpeg_file_raw_bytes->size() >= (size_t)prefix_grbs + start_byte);\n            memcpy(prefix_grbgdata,\n                   &(*jpeg_file_raw_bytes)[start_byte],\n                   std::min((size_t)prefix_grbs,\n                            jpeg_file_raw_bytes->size() - start_byte));\n        } else {\n            prefix_grbgdata = aligned_alloc(1); // so it's nonnull\n            prefix_grbgdata[0] = 0;\n        }\n    }\n    Sirikata::MemReadWriter mrw((Sirikata::JpegAllocator<uint8_t>()));\n#if 0\n    for (uint32_t i = 0; i < row_thread_handoffs.size() ; ++ i) {\n        fprintf(stderr,\n                \"Row [%d - %d], %d size %d overhang byte %d num overhang bits %d  dc %d %d %d\\n\",\n                (int)row_thread_handoffs[i].luma_y_start,\n                (int)row_thread_handoffs[i].luma_y_end,\n                (int)i,\n                (int)row_thread_handoffs[i].segment_size,\n                (int)row_thread_handoffs[i].overhang_byte,\n                (int)row_thread_handoffs[i].num_overhang_bits,\n                (int)row_thread_handoffs[i].last_dc[0],\n                (int)row_thread_handoffs[i].last_dc[1],\n                (int)row_thread_handoffs[i].last_dc[2]);\n    }\n#endif\n    uint32_t framebuffer_byte_size = row_thread_handoffs.back().segment_size - row_thread_handoffs.front().segment_size;\n    uint32_t num_rows = row_thread_handoffs.size();\n    NUM_THREADS = std::min(NUM_THREADS, (unsigned int)max_encode_threads);\n    if (num_rows / 2 < NUM_THREADS) {\n        unsigned int desired_count = std::max((unsigned int)num_rows / 2,\n                                              (unsigned int)min_encode_threads);\n        NUM_THREADS = std::min(std::max(desired_count, 1U), (unsigned int)NUM_THREADS);\n    }\n    if (framebuffer_byte_size < 125000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 1U), (unsigned int)NUM_THREADS);\n    } else if (framebuffer_byte_size < 250000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 2U), (unsigned int)NUM_THREADS);\n    } else if (framebuffer_byte_size < 500000) {\n        NUM_THREADS = std::min(std::max(min_encode_threads, 4U), (unsigned int)NUM_THREADS);\n    }\n    //fprintf(stderr, \"Byte size %d num_rows %d Using num threads %u\\n\", framebuffer_byte_size, num_rows, NUM_THREADS);\n    std::vector<ThreadHandoff> selected_splits(NUM_THREADS);\n    std::vector<int> split_indices(NUM_THREADS);\n    for (uint32_t i = 0; g_even_thread_split == false && i < NUM_THREADS - 1 ; ++ i) {\n        ThreadHandoff desired_handoff = row_thread_handoffs.back();\n        if(max_file_size && max_file_size + start_byte < desired_handoff.segment_size) {\n            desired_handoff.segment_size += row_thread_handoffs.front().segment_size;\n        }\n        desired_handoff.segment_size -= row_thread_handoffs.front().segment_size;\n        \n        desired_handoff.segment_size *= (i + 1);\n        desired_handoff.segment_size /= NUM_THREADS;\n        desired_handoff.segment_size += row_thread_handoffs.front().segment_size;\n        auto split = std::lower_bound(row_thread_handoffs.begin() + 1, row_thread_handoffs.end(),\n                                      desired_handoff,\n                                      ThreadHandoffSegmentCompare());\n        if (split == row_thread_handoffs.begin() && split != row_thread_handoffs.end()) {\n            //++split;\n        } else if (split != row_thread_handoffs.begin() + 1) {\n            --split;\n        }\n        split_indices[i] = split - row_thread_handoffs.begin();\n    }\n    for (uint32_t i = 0; g_even_thread_split && i < NUM_THREADS - 1 ; ++ i) {\n        split_indices[i] = row_thread_handoffs.size() * (i + 1) / NUM_THREADS;\n    }\n    for (uint32_t index = 0; index < NUM_THREADS - 1 ; ++ index) {\n        if (split_indices[index] == split_indices[index + 1]) {\n            for (uint32_t i = 0; i < NUM_THREADS - 1 ; ++ i) {\n                split_indices[i] = (i + 1) * row_thread_handoffs.size() / NUM_THREADS;\n            }\n            break;\n        }\n    }\n    split_indices[NUM_THREADS - 1] = row_thread_handoffs.size() - 1;\n    size_t last_split_index = 0;\n    for (size_t i = 0; i < selected_splits.size(); ++i) {\n        size_t beginning_of_range = last_split_index;\n        size_t end_of_range = split_indices[i];\n        //fprintf(stderr, \"Beginning %ld end %ld\\n\", beginning_of_range, end_of_range);\n        last_split_index = end_of_range;\n        always_assert( end_of_range < row_thread_handoffs.size() );\n        selected_splits[i] = row_thread_handoffs[ end_of_range ] - row_thread_handoffs[ beginning_of_range ];\n        if (i + 1 == selected_splits.size() && row_thread_handoffs[ end_of_range ].num_overhang_bits) {\n            ++selected_splits[i].segment_size; // need room for that last byte to hold the overhang byte\n        }\n#if 0\n        fprintf(stderr, \"%d->%d) %d - %d {%ld}\\n\", selected_splits[i].luma_y_start,\n                selected_splits[i].luma_y_end, \n                row_thread_handoffs[ beginning_of_range ].segment_size,\n                row_thread_handoffs[ end_of_range ].segment_size, row_thread_handoffs.size());\n#endif\n/*\n        if (i + 1 == selected_splits.size()) {\n            int tmp = selected_splits[i].segment_size;\n            selected_splits[i].segment_size = jpgfilesize - row_thread_handoffs[ beginning_of_range ].segment_size;\n            fprintf(stderr, \"Split size was %x and is %x - %x = %x\\n\", tmp, jpgfilesize, row_thread_handoffs[ beginning_of_range ].segment_size, selected_splits[i].segment_size);\n        }\n*/\n    }\n#if 0\n    for (uint32_t i = 0; i < selected_splits.size() ; ++ i) {\n        fprintf(stderr,\n                \"Row [%d - %d] %d size %d overhang byte %d num overhang bits %d  dc %d %d %d\\n\",\n                (int)selected_splits[i].luma_y_start,\n                (int)selected_splits[i].luma_y_end,\n\n                (int)i,\n                (int)selected_splits[i].segment_size,\n                (int)selected_splits[i].overhang_byte,\n                (int)selected_splits[i].num_overhang_bits,\n                (int)selected_splits[i].last_dc[0],\n                (int)selected_splits[i].last_dc[1],\n                (int)selected_splits[i].last_dc[2]);\n    }\n#endif\n\n    always_assert(start_byte||!selected_splits[0].luma_y_start);\n    // write header to file\n    // marker: \"HDR\" + [size of header]\n    unsigned char hdr_mrk[] = {'H', 'D', 'R'};\n    err = mrw.Write( hdr_mrk, sizeof(hdr_mrk) ).second;\n    uint32toLE(hdrs, ujpg_mrk);\n    err = mrw.Write( ujpg_mrk, 4).second;\n    // data: data from header\n    mrw.Write( hdrdata, hdrs );\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // marker: P0D\"\n    unsigned char pad_mrk[] = {'P', '0', 'D'};\n    err = mrw.Write( pad_mrk, sizeof(pad_mrk) ).second;\n    // data: padbit\n    err = mrw.Write( (unsigned char*) &padbit, 1 ).second;\n\n    // write luma splits\n    unsigned char luma_mrk[1] = {'H'};\n    err = mrw.Write( luma_mrk, sizeof(luma_mrk) ).second;\n    // data: serialized luma splits\n    auto serialized_splits = ThreadHandoff::serialize(&selected_splits[0], selected_splits.size());\n    err = mrw.Write(&serialized_splits[0], serialized_splits.size()).second;\n\n    if (!rst_cnt.empty()) {\n        unsigned char frs_mrk[] = {'C', 'R', 'S'};\n        err = mrw.Write( frs_mrk, 3 ).second;\n        uint32toLE((uint32_t)rst_cnt.size(), ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4).second;\n        for (size_t i = 0; i < rst_cnt.size(); ++i) {\n            uint32toLE((uint32_t)rst_cnt.at(i), ujpg_mrk);\n            err = mrw.Write( ujpg_mrk, 4).second;\n        }\n    }\n    // write number of false set RST markers per scan (if available) to file\n    if (!rst_err.empty()) {\n        // marker: \"FRS\" + [number of scans]\n        unsigned char frs_mrk[] = {'F', 'R', 'S'};\n        err = mrw.Write( frs_mrk, 3 ).second;\n        uint32toLE((uint32_t)rst_err.size(), ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4).second;\n        // data: numbers of false set markers\n        err = mrw.Write( rst_err.data(), rst_err.size() ).second;\n    }\n    if (early_eof_encountered) {\n        unsigned char early_eof[] = {'E', 'E', 'E'};\n        err = mrw.Write( early_eof, sizeof(early_eof) ).second;\n        uint32toLE(max_cmp, ujpg_mrk);\n        uint32toLE(max_bpos, ujpg_mrk + 4);\n        uint32toLE(max_sah, ujpg_mrk + 8);\n        uint32toLE(max_dpos[0], ujpg_mrk + 12);\n        uint32toLE(max_dpos[1], ujpg_mrk + 16);\n        uint32toLE(max_dpos[2], ujpg_mrk + 20);\n        uint32toLE(max_dpos[3], ujpg_mrk + 24);\n        err = mrw.Write(ujpg_mrk, 28).second;\n    }\n    // write garbage (data including and after EOI) (if any) to file\n    if ( prefix_grbs > 0 || prefix_grbgdata != NULL) {\n        // marker: \"GRB\" + [size of garbage]\n        unsigned char grb_mrk[] = {'P', 'G', embedded_jpeg ? (unsigned char)'E': (unsigned char)'R'};\n        err = mrw.Write( grb_mrk, sizeof(grb_mrk) ).second;\n        uint32toLE(prefix_grbs, ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4 ).second;\n        // data: garbage data\n        err = mrw.Write( prefix_grbgdata, prefix_grbs ).second;\n    }\n    // write garbage (data including and after EOI) (if any) to file\n    if ( grbs > 0 ) {\n        // marker: \"GRB\" + [size of garbage]\n        unsigned char grb_mrk[] = {'G', 'R', 'B'};\n        err = mrw.Write( grb_mrk, sizeof(grb_mrk) ).second;\n        uint32toLE(grbs, ujpg_mrk);\n        err = mrw.Write( ujpg_mrk, 4 ).second;\n        // data: garbage data\n        err = mrw.Write( grbgdata, grbs ).second;\n    }\n    if (mrw.buffer().size() > 1024 * 1024) {\n        //custom_exit(ExitCode::HEADER_TOO_LARGE);\n    }\n    std::vector<uint8_t, Sirikata::JpegAllocator<uint8_t> > compressed_header;\n    if (ujgversion == 1) {\n        compressed_header =\n            Sirikata::ZlibDecoderCompressionWriter::Compress(mrw.buffer().data(),\n                                                             mrw.buffer().size(),\n                                                             Sirikata::JpegAllocator<uint8_t>());\n    } else {\n        compressed_header = Sirikata::BrotliCodec::Compress(mrw.buffer().data(),\n                                                            mrw.buffer().size(),\n                                                            Sirikata::JpegAllocator<uint8_t>());\n    }\n    write_byte_bill(Billing::HEADER, false, 2 + hdrs + prefix_grbs + grbs);\n    static_assert(MAX_NUM_THREADS <= 255, \"We only have a single byte for num threads\");\n    always_assert(NUM_THREADS <= 255);\n    unsigned char zed[] = {'\\0'};\n    if (start_byte != 0) {\n        zed[0] = (unsigned char)'Y';\n    } else if (g_allow_progressive) {\n        zed[0] = (unsigned char)'X';\n    } else {\n        zed[0] = (unsigned char)'Z';\n    }\n    err =  ujg_out->Write(zed, sizeof(zed)).second;\n    unsigned char num_threads[] = {(unsigned char)NUM_THREADS};\n    err =  ujg_out->Write(num_threads, sizeof(num_threads)).second;\n    unsigned char zero3[3] = {};\n    err =  ujg_out->Write(zero3, sizeof(zero3)).second;\n    unsigned char git_revision[12] = {0}; // we only have 12 chars in the header for this\n    hex_to_bin(git_revision, GIT_REVISION, sizeof(git_revision));\n    err = ujg_out->Write(git_revision, sizeof(git_revision) ).second;\n    uint32toLE(jpgfilesize - start_byte, ujpg_mrk);\n    err = ujg_out->Write( ujpg_mrk, 4).second;\n    write_byte_bill(Billing::HEADER, true, 24);\n    uint32toLE((uint32_t)compressed_header.size(), ujpg_mrk);\n    err = ujg_out->Write( ujpg_mrk, 4).second;\n    write_byte_bill(Billing::HEADER, true, 4);\n    auto err2 = ujg_out->Write(compressed_header.data(),\n                               compressed_header.size());\n    write_byte_bill(Billing::HEADER, true, compressed_header.size());\n    zlib_hdrs = compressed_header.size();\n    if (err != Sirikata::JpegError::nil() || err2.second != Sirikata::JpegError::nil()) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return false;\n    }\n    unsigned char cmp_mrk[] = {'C', 'M', 'P'};\n    err = ujg_out->Write( cmp_mrk, sizeof(cmp_mrk) ).second;\n    write_byte_bill(Billing::HEADER, true, 3);\n    while (g_encoder->encode_chunk(&colldata, ujg_out,\n                                   &selected_splits[0], selected_splits.size()) == CODING_PARTIAL) {\n    }\n    \n    // errormessage if write error\n    if ( err != Sirikata::JpegError::nil() ) {\n        fprintf( stderr, \"write error, possibly drive is full\" );\n        errorlevel.store(2);\n        return false;\n    }\n\n    // get filesize, if avail\n    if (ujg_out) {\n        ujgfilesize = ujg_out->getsize();\n    }\n\n\n    return true;\n}\n\n\n/* -----------------------------------------------\n    read uncompressed JPEG file\n    ----------------------------------------------- */\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\nvoid mem_nop (void *opaque, void *ptr){\n\n}\nvoid * mem_init_nop(size_t prealloc_size, uint8_t align){\n    return NULL;\n}\nvoid* mem_realloc_nop(void * ptr, size_t size, size_t *actualSize, unsigned int movable, void *opaque){\n    return NULL;\n}\n#endif\n\nSirikata::MemReadWriter *header_reader = NULL;\n\nbool read_ujpg( void )\n{\n    using namespace IOUtil;\n    using namespace Sirikata;\n//    colldata.start_decoder_worker_thread(std::bind(&simple_decoder, &colldata, str_in));\n    unsigned char ujpg_mrk[ 64 ];\n    // this is where we will enable seccomp, before reading user data\n    write_byte_bill(Billing::HEADER, true, 24); // for the fixed header\n\n    str_out->call_size_callback(max_file_size);\n    uint32_t compressed_header_size = 0;\n    if (ReadFull(str_in, ujpg_mrk, 4) != 4) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    write_byte_bill(Billing::HEADER, true, 4);\n\n    compressed_header_size = LEtoUint32(ujpg_mrk);\n    if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {\n        always_assert(false && \"Only support images < 128 megs\");\n        return false; // bool too big\n    }\n    bool pending_header_reads = false;\n    if (header_reader == NULL) {\n        std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);\n        IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());\n        header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));\n        {\n            if (ujgversion == 1) {\n                JpegAllocator<uint8_t> no_free_allocator;\n#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)\n                no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,\n                                                         16,\n                                                         &mem_init_nop,\n                                                         &MemMgrAllocatorMalloc,\n                                                         &mem_nop,\n                                                         &mem_realloc_nop,\n                                                         &MemMgrAllocatorMsize);\n#endif\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),\n                                                                         compressed_header_buffer.size(),\n                                                                         no_free_allocator,\n                                                                         max_file_size + 2048));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);\n            } else {\n                std::pair<std::vector<uint8_t,\n                                      Sirikata::JpegAllocator<uint8_t> >,\n                          JpegError> uncompressed_header_buffer(\n                              Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),\n                                                                compressed_header_buffer.size(),\n                                                                JpegAllocator<uint8_t>(),\n                                                                ((size_t)max_file_size) * 2 + 128 * 1024 * 1024));\n                if (uncompressed_header_buffer.second) {\n                    always_assert(false && \"Data not properly zlib coded\");\n                    return false;\n                }\n                zlib_hdrs = compressed_header_buffer.size();\n                header_reader->SwapIn(uncompressed_header_buffer.first, 0);            \n            }\n        }\n        write_byte_bill(Billing::HEADER,\n                        true,\n                        compressed_header_buffer.size());\n    } else {\n        always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");\n    }\n    grbs = sizeof(EOI);\n    grbgdata = EOI; // if we don't have any garbage, assume FFD9 EOI\n    // read header from file\n    ReadFull(header_reader, ujpg_mrk, 3 ) ;\n    // check marker\n    if ( memcmp( ujpg_mrk, \"HDR\", 3 ) == 0 ) {\n        // read size of header, alloc memory\n        ReadFull(header_reader, ujpg_mrk, 4 );\n        hdrs = LEtoUint32(ujpg_mrk);\n        hdrdata = (unsigned char*) aligned_alloc(hdrs);\n        memset(hdrdata, 0, hdrs);\n        if ( hdrdata == NULL ) {\n            fprintf( stderr, MEM_ERRMSG );\n            errorlevel.store(2);\n            return false;\n        }\n        // read hdrdata\n        ReadFull(header_reader, hdrdata, hdrs );\n    }\n    else {\n        fprintf( stderr, \"HDR marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;\n    // parse header for image-info\n    if ( !setup_imginfo_jpg(memory_optimized_image) )\n        return false;\n\n    // beginning here: recovery information (needed for exact JPEG recovery)\n\n    // read padbit information from file\n    ReadFull(header_reader, ujpg_mrk, 3 );\n    // check marker\n    if ( memcmp( ujpg_mrk, \"P0D\", 3 ) == 0 ) {\n        // This is a more nuanced pad byte that can have different values per bit\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n    }\n    else if ( memcmp( ujpg_mrk, \"PAD\", 3 ) == 0 ) {\n        // this is a single pad bit that is implied to have all the same values\n        header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );\n        if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {\n            while (write(2,\n                        \"Legacy Padbit must be 0, 1 or -1\\n\",\n                         strlen(\"Legacy Padbit must be 0, 1 or -1\\n\")) < 0\n                   && errno == EINTR) {\n            }\n            custom_exit(ExitCode::STREAM_INCONSISTENT);\n        }\n        if (padbit == 1) {\n            padbit = 0x7f; // all 6 bits set\n        }\n    }\n    else {\n        fprintf( stderr, \"PAD marker not found\" );\n        errorlevel.store(2);\n        return false;\n    }\n    std::vector<ThreadHandoff> thread_handoff;\n    // read further recovery information if any\n    while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {\n        // check marker\n        if ( memcmp( ujpg_mrk, \"CRS\", 3 ) == 0 ) {\n            rst_cnt_set = true;\n            ReadFull(header_reader, ujpg_mrk, 4);\n            rst_cnt.resize(LEtoUint32(ujpg_mrk));\n            for (size_t i = 0; i < rst_cnt.size(); ++i) {\n                ReadFull(header_reader, ujpg_mrk, 4);\n                rst_cnt.at(i) = LEtoUint32(ujpg_mrk);\n            }\n        } else if ( memcmp( ujpg_mrk, \"HHX\", 2 ) == 0 ) { // only look at first two bytes\n            size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;\n            if(to_alloc) {\n                std::vector<unsigned char> data(to_alloc);\n                data[0] = ujpg_mrk[1];\n                data[1] = ujpg_mrk[2];\n                ReadFull(header_reader, &data[2], to_alloc - 2);\n                thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);\n            }\n        } else if ( memcmp( ujpg_mrk, \"FRS\", 3 ) == 0 ) {\n            // read number of false set RST markers per scan from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            scnc = LEtoUint32(ujpg_mrk);\n            \n            rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);\n            // read data\n            ReadFull(header_reader, rst_err.data(), scnc );\n        }\n        else if ( memcmp( ujpg_mrk, \"GRB\", 3 ) == 0 ) {\n            // read garbage (data after end of JPG) from file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            grbs = LEtoUint32(ujpg_mrk);\n            grbgdata = aligned_alloc(grbs);\n            memset(grbgdata, 0, sizeof(grbs));\n            if ( grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, grbgdata, grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"PGR\", 3 ) == 0 || memcmp( ujpg_mrk, \"PGE\", 3 ) == 0 ) {\n            // read prefix garbage (data before beginning of JPG) from file\n            if (ujpg_mrk[2] == 'E') {\n                // embedded jpeg: full header required\n                embedded_jpeg = true;\n            }\n            ReadFull(header_reader, ujpg_mrk, 4);\n            prefix_grbs = LEtoUint32(ujpg_mrk);\n            prefix_grbgdata = aligned_alloc(prefix_grbs);\n            memset(prefix_grbgdata, 0, sizeof(prefix_grbs));\n            if ( prefix_grbgdata == NULL ) {\n                fprintf( stderr, MEM_ERRMSG );\n                errorlevel.store(2);\n                return false;\n            }\n            // read garbage data\n            ReadFull(header_reader, prefix_grbgdata, prefix_grbs );\n        }\n        else if ( memcmp( ujpg_mrk, \"SIZ\", 3 ) == 0 ) {\n            // full size of the original file\n            ReadFull(header_reader, ujpg_mrk, 4);\n            max_file_size = LEtoUint32(ujpg_mrk);\n        }\n        else if ( memcmp( ujpg_mrk, \"EEE\", 3) == 0) {\n            ReadFull(header_reader, ujpg_mrk, 28);\n            max_cmp = LEtoUint32(ujpg_mrk);\n            max_bpos = LEtoUint32(ujpg_mrk + 4);\n            max_sah = LEtoUint32(ujpg_mrk + 8);\n            max_dpos[0] = LEtoUint32(ujpg_mrk + 12);\n            max_dpos[1] = LEtoUint32(ujpg_mrk + 16);\n            max_dpos[2] = LEtoUint32(ujpg_mrk + 20);\n            max_dpos[3] = LEtoUint32(ujpg_mrk + 24);\n            early_eof_encountered = true;\n            colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);\n        }\n        else {\n            if (memcmp(ujpg_mrk, \"CNT\", 3) == 0 ) {\n                pending_header_reads = true;\n                break;\n            } else if (memcmp(ujpg_mrk, \"CMP\", 3) == 0 ) {\n                break;\n            } else {\n                fprintf( stderr, \"unknown data found\" );\n                errorlevel.store(2);\n            }\n            return false;\n        }\n    }\n    if (!pending_header_reads) {\n        delete header_reader;\n        header_reader = NULL;\n    }\n    write_byte_bill(Billing::HEADER,\n                    false,\n                    2 + hdrs + prefix_grbs + grbs);\n\n    ReadFull(str_in, ujpg_mrk, 3 ) ;\n    write_byte_bill(Billing::HEADER, true, 3);\n\n    write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS); // trailing vpx_encode bits\n    write_byte_bill(Billing::HEADER, true, 4); //trailing size\n\n    if (memcmp(ujpg_mrk, \"CMP\", 3) != 0) {\n        always_assert(false && \"CMP must be present (uncompressed) in the file or CNT continue marker\");\n        return false; // not a JPG\n    }\n    colldata.signal_worker_should_begin();\n    g_decoder->initialize(str_in, thread_handoff);\n    colldata.start_decoder(g_decoder);\n    return true;\n}\n\n\n/* -----------------------------------------------\n    set each variable to its initial value\n    ----------------------------------------------- */\n\nbool reset_buffers( void )\n{\n    int cmp, bpos;\n    int i;\n\n\n    // -- free buffers --\n\n    // free buffers & set pointers NULL\n    if ( hdrdata  != NULL ) aligned_dealloc ( hdrdata );\n    if ( huffdata != NULL ) aligned_dealloc ( huffdata );\n    if ( grbgdata != NULL && grbgdata != EOI ) aligned_dealloc ( grbgdata );\n    rst_err.clear();\n    rstp.resize(0);\n    scnp.resize(0);\n    hdrdata   = NULL;\n    huffdata  = NULL;\n    grbgdata  = NULL;\n\n    // free image arrays\n    colldata.reset();\n\n\n    // -- set variables --\n\n    // preset componentinfo\n    for ( cmp = 0; cmp < 4; cmp++ ) {\n        cmpnfo[ cmp ].sfv = -1;\n        cmpnfo[ cmp ].sfh = -1;\n        cmpnfo[ cmp ].mbs = -1;\n        cmpnfo[ cmp ].bcv = -1;\n        cmpnfo[ cmp ].bch = -1;\n        cmpnfo[ cmp ].bc  = -1;\n        cmpnfo[ cmp ].ncv = -1;\n        cmpnfo[ cmp ].nch = -1;\n        cmpnfo[ cmp ].nc  = -1;\n        cmpnfo[ cmp ].sid = -1;\n        cmpnfo[ cmp ].jid = -1;\n        cmpnfo[ cmp ].qtable = NULL;\n        cmpnfo[ cmp ].huffdc = -1;\n        cmpnfo[ cmp ].huffac = -1;\n    }\n\n    // preset imgwidth / imgheight / component count\n    imgwidth  = 0;\n    imgheight = 0;\n    cmpc      = 0;\n\n    // preset mcu info variables / restart interval\n    sfhm      = 0;\n    sfvm      = 0;\n    mcuc      = 0;\n    mcuh      = 0;\n    mcuv      = 0;\n    rsti      = 0;\n    max_file_size = 0; // this file isn't truncated\n    // reset quantization / huffman tables\n    for ( i = 0; i < 4; i++ ) {\n        htset[ 0 ][ i ] = 0;\n        htset[ 1 ][ i ] = 0;\n        for ( bpos = 0; bpos < 64; bpos++ )\n            qtables[ i ][ bpos ] = 0;\n    }\n\n    // preset jpegtype\n    jpegtype  = 0;\n\n    // reset padbit\n    padbit = -1;\n\n    return true;\n}\n\n/* ----------------------- End of main functions -------------------------- */\n\n/* ----------------------- Begin of JPEG specific functions -------------------------- */\n\n\n/* -----------------------------------------------\n    Parses header for imageinfo\n    ----------------------------------------------- */\nbool setup_imginfo_jpg(bool only_allocate_two_image_rows)\n{\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // position in header\n\n    int cmp;\n\n    // header parser loop\n    while ( hpos < hdrs ) {\n        type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ] : 0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] : 0);\n        // do not parse DHT & DRI\n        if ( ( type != 0xDA ) && ( type != 0xC4 ) && ( type != 0xDD ) ) {\n            if ( !parse_jfif_jpg( type, len, hdrs-hpos, &( hdrdata[ hpos ] ) ) )\n                return false;\n        }\n        hpos += len;\n    }\n\n    // check if information is complete\n    if ( cmpc == 0 ) {\n        fprintf( stderr, \"header contains incomplete information\" );\n        errorlevel.store(2);\n        return false;\n    }\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( ( cmpnfo[cmp].sfv == 0 ) ||\n             ( cmpnfo[cmp].sfh == 0 ) ||\n             ( cmpnfo[cmp].qtable == NULL ) ||\n             ( cmpnfo[cmp].qtable[0] == 0 ) ||\n             ( jpegtype == 0 ) ) {\n            fprintf( stderr, \"header information is incomplete\" );\n            errorlevel.store(2);\n            return false;\n        }\n    }\n        \n    // do all remaining component info calculations\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        if ( cmpnfo[ cmp ].sfh > sfhm ) sfhm = cmpnfo[ cmp ].sfh;\n        if ( cmpnfo[ cmp ].sfv > sfvm ) sfvm = cmpnfo[ cmp ].sfv;\n    }\n    mcuv = ( int ) ceil( (float) imgheight / (float) ( 8 * sfhm ) );\n    mcuh = ( int ) ceil( (float) imgwidth  / (float) ( 8 * sfvm ) );\n    mcuc  = mcuv * mcuh;\n    int maxChromaWidth = 0;\n    int maxChromaHeight = 0;\n    int maxLumaWidth = 0;\n    int maxLumaHeight = 0;\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        cmpnfo[ cmp ].mbs = cmpnfo[ cmp ].sfv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bcv = mcuv * cmpnfo[ cmp ].sfh;\n        cmpnfo[ cmp ].bch = mcuh * cmpnfo[ cmp ].sfv;\n        cmpnfo[ cmp ].bc  = cmpnfo[ cmp ].bcv * cmpnfo[ cmp ].bch;\n        cmpnfo[ cmp ].ncv = ( int ) ceil( (float) imgheight *\n                            ( (float) cmpnfo[ cmp ].sfh / ( 8.0 * sfhm ) ) );\n        cmpnfo[ cmp ].nch = ( int ) ceil( (float) imgwidth *\n                            ( (float) cmpnfo[ cmp ].sfv / ( 8.0 * sfvm ) ) );\n        cmpnfo[ cmp ].nc  = cmpnfo[ cmp ].ncv * cmpnfo[ cmp ].nch;\n        cmpnfo[cmp].check_valid_value_range();\n        if (cmp == 0) {\n            maxLumaWidth = cmpnfo[ cmp ].bch * 8;\n            maxLumaHeight = cmpnfo[ cmp ].bcv * 8;\n        } else {\n            if (maxChromaWidth < cmpnfo[ cmp ].bch * 8) {\n                maxChromaWidth = cmpnfo[ cmp ].bch * 8;\n            }\n            if (maxChromaHeight < cmpnfo[ cmp ].bcv * 8) {\n                maxChromaHeight = cmpnfo[ cmp ].bcv * 8;\n            }\n        }\n    }\n    LeptonDebug::setupDebugData(maxLumaWidth, maxLumaHeight,\n                                maxChromaWidth, maxChromaHeight);\n\n    // decide components' statistical ids\n    if ( cmpc <= 3 ) {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = cmp;\n    }\n    else {\n        for ( cmp = 0; cmp < cmpc; cmp++ ) cmpnfo[ cmp ].sid = 0;\n    }\n    size_t start_allocated = Sirikata::memmgr_size_allocated();\n    // alloc memory for further operations\n    colldata.init(cmpnfo, cmpc, mcuh, mcuv, jpegtype == 1 && only_allocate_two_image_rows);\n    size_t end_allocated = Sirikata::memmgr_size_allocated();\n    total_framebuffer_allocated = end_allocated - start_allocated;\n    return true;\n}\n\n\n/* -----------------------------------------------\n    Parse routines for JFIF segments\n    ----------------------------------------------- */\nbool parse_jfif_jpg( unsigned char type, unsigned int len, unsigned int alloc_len, unsigned char* segment )\n{\n    unsigned int hpos = 4; // current position in segment, start after segment header\n    int lval, rval; // temporary variables\n    int skip;\n    int cmp;\n    int i;\n\n\n    switch ( type )\n    {\n        case 0xC4: // DHT segment\n            // build huffman trees & codes\n            while ( hpos < len ) {\n                lval = LBITS( hpos < alloc_len ? segment[ hpos ] : 0, 4 );\n                rval = RBITS( hpos < alloc_len ? segment[ hpos ]: 0, 4 );\n                if ( ((lval < 0) || (lval >= 2)) || ((rval < 0) || (rval >= 4)) )\n                    break;\n\n                hpos++;\n                // build huffman codes & trees\n                if (!build_huffcodes( &(segment[ hpos + 0 ]), alloc_len > hpos ? alloc_len - hpos : 0,\n                                      &(segment[ hpos + 16 ]),  alloc_len > hpos + 16 ? alloc_len - hpos - 16 : 0,\n                                      &(hcodes[ lval ][ rval ]), &(htrees[ lval ][ rval ]) )) {\n                    errorlevel.store(2);\n                    return false;\n                }\n                htset[ lval ][ rval ] = 1;\n\n                skip = 16;\n                for ( i = 0; i < 16; i++ )\n                    skip += ( int ) (hpos + i < alloc_len ? segment[ hpos + i ] : 0);\n                hpos += skip;\n            }\n\n            if ( hpos != len ) {\n                // if we get here, something went wrong\n                fprintf( stderr, \"size mismatch in dht marker\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xDB: // DQT segment\n            // copy quantization tables to internal memory\n            while ( hpos < len ) {\n                lval = LBITS( hpos < alloc_len ? segment[ hpos ] :  0, 4 );\n                rval = RBITS( hpos < alloc_len ? segment[ hpos ] : 0, 4 );\n                if ( (lval < 0) || (lval >= 2) ) break;\n                if ( (rval < 0) || (rval >= 4) ) break;\n                hpos++;\n                if ( lval == 0 ) { // 8 bit precision\n                    for ( i = 0; i < 64; i++ ) {\n                        qtables[ rval ][ i ] = ( unsigned short ) (hpos + i < alloc_len ? segment[ hpos + i ] : 0);\n                        if ( qtables[ rval ][ i ] == 0 ) break;\n                    }\n                    hpos += 64;\n                }\n                else { // 16 bit precision\n                    for ( i = 0; i < 64; i++ ) {\n                        qtables[ rval ][ i ] =\n                            B_SHORT( (hpos + (2*i)< alloc_len ? segment[ hpos + (2*i) ] : 0), (hpos + 2*i+1 < alloc_len?segment[ hpos + (2*i) + 1 ]:0) );\n                        if ( qtables[ rval ][ i ] == 0 ) break;\n                    }\n                    hpos += 128;\n                }\n            }\n\n            if ( hpos != len ) {\n                // if we get here, something went wrong\n                fprintf( stderr, \"size mismatch in dqt marker\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xDD: // DRI segment\n            // define restart interval\n          rsti = B_SHORT( hpos < alloc_len ? segment[ hpos ]:0, hpos +1 < alloc_len ?segment[ hpos + 1 ]:0 );\n            return true;\n\n        case 0xDA: // SOS segment\n            // prepare next scan\n            cs_cmpc = hpos < alloc_len ? segment[ hpos ] : 0;\n            if ( cs_cmpc > cmpc ) {\n                fprintf( stderr, \"%i components in scan, only %i are allowed\",\n                            cs_cmpc, cmpc );\n                errorlevel.store(2);\n                return false;\n            }\n            hpos++;\n            for ( i = 0; i < cs_cmpc; i++ ) {\n                for ( cmp = 0; ( (hpos < alloc_len ? segment[ hpos ]:0) != cmpnfo[ cmp ].jid ) && ( cmp < cmpc ); cmp++ );\n                if ( cmp == cmpc ) {\n                    fprintf( stderr, \"component id mismatch in start-of-scan\" );\n                    errorlevel.store(2);\n                    return false;\n                }\n                cs_cmp[ i ] = cmp;\n                cmpnfo[ cmp ].huffdc = LBITS( hpos + 1< alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                cmpnfo[ cmp ].huffac = RBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                if ( ( cmpnfo[ cmp ].huffdc < 0 ) || ( cmpnfo[ cmp ].huffdc >= 4 ) ||\n                     ( cmpnfo[ cmp ].huffac < 0 ) || ( cmpnfo[ cmp ].huffac >= 4 ) ) {\n                    fprintf( stderr, \"huffman table number mismatch\" );\n                    errorlevel.store(2);\n                    return false;\n                }\n                hpos += 2;\n            }\n            cs_from = hpos < alloc_len ? segment[ hpos + 0 ]:0;\n            cs_to   = hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0;\n            cs_sah  = LBITS( hpos + 2 < alloc_len ? segment[ hpos + 2 ]:0, 4 );\n            cs_sal  = RBITS( hpos +2  <  alloc_len ? segment[ hpos + 2 ]:0, 4 );\n            // check for errors\n            if ( ( cs_from > cs_to ) || ( cs_from > 63 ) || ( cs_to > 63 ) ) {\n                fprintf( stderr, \"spectral selection parameter out of range\" );\n                errorlevel.store(2);\n                return false;\n            }\n            if ( ( cs_sah >= 12 ) || ( cs_sal >= 12 ) ) {\n                fprintf( stderr, \"successive approximation parameter out of range\" );\n                errorlevel.store(2);\n                return false;\n            }\n            return true;\n\n        case 0xC0: // SOF0 segment\n            // coding process: baseline DCT\n\n        case 0xC1: // SOF1 segment\n            // coding process: extended sequential DCT\n\n        case 0xC2: // SOF2 segment\n            // coding process: progressive DCT\n\n            // set JPEG coding type\n            if ( type == 0xC2 )\n                jpegtype = 2;\n            else\n                jpegtype = 1;\n\n            // check data precision, only 8 bit is allowed\n            lval = hpos < alloc_len ? segment[ hpos ]:0;\n            if ( lval != 8 ) {\n                fprintf( stderr, \"%i bit data precision is not supported\", lval );\n                errorlevel.store(2);\n                return false;\n            }\n\n            // image size, height & component count\n            imgheight = B_SHORT( hpos +  1  < alloc_len ? segment[ hpos + 1 ]:0, hpos +  2 < alloc_len ?segment[ hpos + 2 ] :0);\n            imgwidth  = B_SHORT( hpos + 3 < alloc_len ?segment[ hpos + 3 ]:0, hpos + 4 < alloc_len ?segment[ hpos + 4 ]:0 );\n            cmpc      = hpos + 5 < alloc_len ?  segment[ hpos + 5 ]:0;\n            if ( cmpc > 4 ) {\n                cmpc = 4;\n                fprintf( stderr, \"image has %i components, max 4 are supported\", cmpc );\n                errorlevel.store(2);\n                return false;\n            }\n            hpos += 6;\n            // components contained in image\n            for ( cmp = 0; cmp < cmpc; cmp++ ) {\n                cmpnfo[ cmp ].jid = hpos < alloc_len ? segment[ hpos ]:0;\n                cmpnfo[ cmp ].sfv = LBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                cmpnfo[ cmp ].sfh = RBITS( hpos + 1 < alloc_len ? segment[ hpos + 1 ]:0, 4 );\n                if (cmpnfo[ cmp ].sfv > 4\n                    || cmpnfo[ cmp ].sfh > 4) {\n                    custom_exit(ExitCode::SAMPLING_BEYOND_FOUR_UNSUPPORTED);\n                }\n#ifndef ALLOW_3_OR_4_SCALING_FACTOR\n                if (cmpnfo[ cmp ].sfv > 2\n                    || cmpnfo[ cmp ].sfh > 2) {\n                    custom_exit(ExitCode::SAMPLING_BEYOND_TWO_UNSUPPORTED);\n                }\n#endif\n                uint32_t quantization_table_value = hpos + 2 < alloc_len ? segment[ hpos + 2 ]:0;\n                if (quantization_table_value >= qtables.size()) {\n                    errorlevel.store(2);\n                    return false;\n                }\n                cmpnfo[ cmp ].qtable = qtables[quantization_table_value].begin();\n                hpos += 3;\n            }\n    \n            return true;\n\n        case 0xC3: // SOF3 segment\n            // coding process: lossless sequential\n            fprintf( stderr, \"sof3 marker found, image is coded lossless\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC5: // SOF5 segment\n            // coding process: differential sequential DCT\n            fprintf( stderr, \"sof5 marker found, image is coded diff. sequential\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC6: // SOF6 segment\n            // coding process: differential progressive DCT\n            fprintf( stderr, \"sof6 marker found, image is coded diff. progressive\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xC7: // SOF7 segment\n            // coding process: differential lossless\n            fprintf( stderr, \"sof7 marker found, image is coded diff. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xC9: // SOF9 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof9 marker found, image is coded arithm. sequential\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCA: // SOF10 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof10 marker found, image is coded arithm. progressive\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCB: // SOF11 segment\n            // coding process: arithmetic extended sequential DCT\n            fprintf( stderr, \"sof11 marker found, image is coded arithm. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCD: // SOF13 segment\n            // coding process: arithmetic differntial sequential DCT\n            fprintf( stderr, \"sof13 marker found, image is coded arithm. diff. sequential\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xCE: // SOF14 segment\n            // coding process: arithmetic differential progressive DCT\n            fprintf( stderr, \"sof14 marker found, image is coded arithm. diff. progressive\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xCF: // SOF15 segment\n            // coding process: arithmetic differntial lossless\n            fprintf( stderr, \"sof15 marker found, image is coded arithm. diff. lossless\" );\n            errorlevel.store(2);\n            return false;\n    \n        case 0xE0: // APP0 segment\n        case 0xE1: // APP1 segment\n        case 0xE2: // APP2 segment\n        case 0xE3: // APP3 segment\n        case 0xE4: // APP4 segment\n        case 0xE5: // APP5 segment\n        case 0xE6: // APP6 segment\n        case 0xE7: // APP7 segment\n        case 0xE8: // APP8 segment\n        case 0xE9: // APP9 segment\n        case 0xEA: // APP10 segment\n        case 0xEB: // APP11 segment\n        case 0xEC: // APP12segment\n        case 0xED: // APP13 segment\n        case 0xEE: // APP14 segment\n        case 0xEF: // APP15 segment\n        case 0xFE: // COM segment\n            // do nothing - return true\n            return true;\n    \n        case 0xD0: // RST0 segment\n        case 0xD1: // RST1segment\n        case 0xD2: // RST2 segment\n        case 0xD3: // RST3 segment\n        case 0xD4: // RST4 segment\n        case 0xD5: // RST5 segment\n        case 0xD6: // RST6 segment\n        case 0xD7: // RST7 segment\n            // return errormessage - RST is out of place here\n            fprintf( stderr, \"rst marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xD8: // SOI segment\n            // return errormessage - start-of-image is out of place here\n            fprintf( stderr, \"soi marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n\n        case 0xD9: // EOI segment\n            // return errormessage - end-of-image is out of place here\n            fprintf( stderr, \"eoi marker found out of place\" );\n            errorlevel.store(2);\n            return false;\n    \n        default: // unknown marker segment\n            // return warning\n            fprintf( stderr, \"unknown marker found: FF %2X\", type );\n            errorlevel.store(1);\n            return true;\n    }\n}\n\n\n/* -----------------------------------------------\n    JFIF header rebuilding routine\n    ----------------------------------------------- */\nbool rebuild_header_jpg( void )\n{\n    abytewriter* hdrw; // new header writer\n\n    unsigned char  type = 0x00; // type of current marker segment\n    uint32_t   len  = 0; // length of current marker segment\n    uint32_t   hpos = 0; // position in header\n\n\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n\n    // header parser loop\n    while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) {\n        type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n        // discard any unneeded meta info\n        if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) ||\n             ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) ||\n             ( type == 0xDD ) ) {\n            uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos;\n            hdrw->write_n( &(hdrdata[ hpos ]), to_copy);\n            if (to_copy <  len) {\n                for (uint32_t i = 0;i <to_copy -len;++i) {\n                    uint8_t zero = 0;\n                    hdrw->write_n(&zero, 1);\n                }\n            }\n        }\n        hpos += len;\n    }\n\n    // replace current header with the new one\n    custom_free( hdrdata );\n    hdrdata = hdrw->getptr_aligned();\n    hdrs    = hdrw->getpos();\n    delete( hdrw );\n\n\n    return true;\n}\n\n/* -----------------------------------------------\n    sequential block decoding routine\n    ----------------------------------------------- */\nint decode_block_seq( abitreader* huffr, huffTree* dctree, huffTree* actree, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = 64;\n    int bpos;\n    int hc;\n\n\n    // decode dc\n    hc = next_huffcode( huffr, dctree, Billing::EXP0_DC, Billing::EXPN_DC);\n    if ( hc < 0 ) return -1; // return error\n    else s = ( unsigned char ) hc;\n    n = huffr->read( s );\n    if (s) {\n        write_bit_bill(Billing::RES_DC, false, s - 1);\n        write_bit_bill(Billing::SIGN_DC, false, 1);\n    }\n    block[ 0 ] = DEVLI( s, n );\n    bool eof_fixup = false;\n    // decode ac\n    for ( bpos = 1; bpos < 64; )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n        // analyse code\n        if ( hc > 0 ) {\n            z = LBITS( hc, 4 );\n            s = RBITS( hc, 4 );\n            n = huffr->read( s );\n            if (s) {\n                write_bit_bill(is_edge(bpos) ? Billing::RES_EDGE : Billing::RES_7x7, false, s - 1);\n                write_bit_bill(is_edge(bpos) ? Billing::SIGN_EDGE : Billing::SIGN_7x7, false, 1);\n            }\n            if ( ( z + bpos ) >= 64 ) {\n                eof_fixup = true;\n                break;\n            }\n            while ( z > 0 ) { // write zeroes\n                block[ bpos++ ] = 0;\n                z--;\n            }\n            block[ bpos++ ] = ( short ) DEVLI( s, n ); // decode cvli\n        }\n        else if ( hc == 0 ) { // EOB\n            eob = bpos;\n            // while( bpos < 64 ) // fill remaining block with zeroes\n            //    block[ bpos++ ] = 0;\n            break;\n        }\n        else {\n            return -1; // return error\n        }\n    }\n    if (eof_fixup) {\n        always_assert(huffr->eof && \"If 0run is longer than the block must be truncated\");\n        for(;bpos < eob; ++bpos) {\n            block[bpos] = 0;\n        }\n        if (eob) {\n            block[eob - 1] = 1; // set the value to something matching the EOB\n        }\n    }\n    // return position of eob\n    return eob;\n}\n\n\n\n/* -----------------------------------------------\n    progressive DC decoding routine\n    ----------------------------------------------- */\nint decode_dc_prg_fs( abitreader* huffr, huffTree* dctree, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    int hc;\n\n\n    // decode dc\n    hc = next_huffcode( huffr, dctree, Billing::EXP0_DC, Billing::EXPN_DC);\n    if ( hc < 0 ) return -1; // return error\n    else s = ( unsigned char ) hc;\n    n = huffr->read( s );\n    block[ 0 ] = DEVLI( s, n );\n\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive DC encoding routine\n    ----------------------------------------------- */\nint encode_dc_prg_fs( abitwriter* huffw, huffCodes* dctbl, short* block )\n{\n    unsigned short n;\n    unsigned char  s;\n    int tmp;\n\n\n    // encode DC\n    tmp = block[ 0 ];\n    s = uint16bit_length(ABS(tmp));\n    n = ENVLI( s, tmp );\n    huffw->write( dctbl->cval[ s ], dctbl->clen[ s ] );\n    huffw->write( n, s );\n\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive AC decoding routine\n    ----------------------------------------------- */\nint decode_ac_prg_fs( abitreader* huffr, huffTree* actree, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = to + 1;\n    int bpos;\n    int hc;\n    int l;\n    int r;\n\n\n    // check eobrun\n    if ( (*eobrun) > 0 ) {\n        for ( bpos = from; bpos <= to; ++bpos)\n            block[ bpos ] = 0;\n        (*eobrun)--;\n        return from;\n    }\n\n    // decode ac\n    for ( bpos = from; bpos <= to; )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n        if ( hc < 0 ) return -1;\n        l = LBITS( hc, 4 );\n        r = RBITS( hc, 4 );\n        // analyse code\n        if ( ( l == 15 ) || ( r > 0 ) ) { // decode run/level combination\n            z = l;\n            s = r;\n            n = huffr->read( s );\n            if ( ( z + bpos ) > to )\n                return -1; // run is to long\n            while ( z > 0 ) { // write zeroes\n                block[ bpos++ ] = 0;\n                z--;\n            }\n            block[ bpos++ ] = ( short ) DEVLI( s, n ); // decode cvli\n        }\n        else { // decode eobrun\n            eob = bpos;\n            s = l;\n            n = huffr->read( s );\n            (*eobrun) = E_DEVLI( s, n );\n            // while( bpos <= to ) // fill remaining block with zeroes\n            //    block[ bpos++ ] = 0;\n            (*eobrun)--; // decrement eobrun ( for this one )\n            break;\n        }\n    }\n\n\n    // return position of eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    progressive AC encoding routine\n    ----------------------------------------------- */\nint encode_ac_prg_fs( abitwriter* huffw, huffCodes* actbl, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int bpos;\n    int hc;\n    int tmp;\n\n    // encode AC\n    z = 0;\n    for ( bpos = from; bpos <= to; bpos++ )\n    {\n        // if nonzero is encountered\n        tmp = block[ bpos ];\n        if ( tmp != 0 ) {\n            // encode eobrun\n            encode_eobrun( huffw, actbl, eobrun );\n            // write remaining zeroes\n            while ( z >= 16 ) {\n                huffw->write( actbl->cval[ 0xF0 ], actbl->clen[ 0xF0 ] );\n                z -= 16;\n            }\n            // vli encode\n            s = nonzero_bit_length(ABS(tmp));\n            n = ENVLI( s, tmp);\n            hc = ( ( z << 4 ) + s );\n            // write to huffman writer\n            huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n            huffw->write( n, s );\n            // reset zeroes\n            z = 0;\n        }\n        else { // increment zero counter\n            z++;\n        }\n    }\n\n    // check eob, increment eobrun if needed\n    if ( z > 0 ) {\n        (*eobrun)++;\n        // check eobrun, encode if needed\n        if ( (*eobrun) == actbl->max_eobrun )\n            encode_eobrun( huffw, actbl, eobrun );\n        return 1 + to - z;\n    }\n    else {\n        return 1 + to;\n    }\n}\n\n\n/* -----------------------------------------------\n    progressive DC SA decoding routine\n    ----------------------------------------------- */\nint decode_dc_prg_sa( abitreader* huffr, short* block )\n{\n    // decode next bit of dc coefficient\n    block[ 0 ] = huffr->read( 1 );\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive DC SA encoding routine\n    ----------------------------------------------- */\nint encode_dc_prg_sa( abitwriter* huffw, short* block )\n{\n    // enocode next bit of dc coefficient\n    huffw->write( block[ 0 ], 1 );\n\n    // return 0 if everything is ok\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    progressive AC SA decoding routine\n    ----------------------------------------------- */\nint decode_ac_prg_sa( abitreader* huffr, huffTree* actree, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    signed char    z;\n    signed char    v;\n    int bpos = from;\n    int eob = to;\n    int hc;\n    int l;\n    int r;\n\n\n    // decode AC succesive approximation bits\n    if ( (*eobrun) == 0 )\n    while ( bpos <= to )\n    {\n        // decode next\n        hc = next_huffcode( huffr, actree,\n                            is_edge(bpos) ? Billing::BITMAP_EDGE : Billing::BITMAP_7x7,\n                            is_edge(bpos) ? Billing::EXPN_EDGE : Billing::EXPN_7x7);\n\n        if ( hc < 0 ) return -1;\n        l = LBITS( hc, 4 );\n        r = RBITS( hc, 4 );\n        // analyse code\n        if ( ( l == 15 ) || ( r > 0 ) ) { // decode run/level combination\n            z = l;\n            s = r;\n            if ( s == 0 ) v = 0;\n            else if ( s == 1 ) {\n                n = huffr->read( 1 );\n                v = ( n == 0 ) ? -1 : 1; // fast decode vli\n            }\n            else return -1; // decoding error\n            // write zeroes / write correction bits\n            while ( true ) {\n                if ( block[ bpos ] == 0 ) { // skip zeroes / write value\n                    if ( z > 0 ) z--;\n                    else {\n                        block[ bpos++ ] = v;\n                        break;\n                    }\n                }\n                else { // read correction bit\n                    n = huffr->read( 1 );\n                    block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n                }\n                if ( bpos++ >= to ) return -1; // error check            \n            }\n        }\n        else { // decode eobrun\n            eob = bpos;\n            s = l;\n            n = huffr->read( s );\n            (*eobrun) = E_DEVLI( s, n );\n            break;\n        }\n    }\n\n    // read after eob correction bits\n    if ( (*eobrun) > 0 ) {\n        for ( ; bpos <= to; bpos++ ) {\n            if ( block[ bpos ] != 0 ) {\n                n = huffr->read( 1 );\n                block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n            }\n        }\n        // decrement eobrun\n        (*eobrun)--;\n    }\n\n    // return eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    progressive AC SA encoding routine\n    ----------------------------------------------- */\nint encode_ac_prg_sa( abitwriter* huffw, abytewriter* storw, huffCodes* actbl, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    unsigned char  s;\n    unsigned char  z;\n    int eob = from;\n    int bpos;\n    int hc;\n    int tmp;\n\n    // check if block contains any newly nonzero coefficients and find out position of eob\n    for ( bpos = to; bpos >= from; bpos-- )    {\n        if ( ( block[ bpos ] == 1 ) || ( block[ bpos ] == -1 ) ) {\n            eob = bpos + 1;\n            break;\n        }\n    }\n\n    // encode eobrun if needed\n    if ( ( eob > from ) && ( (*eobrun) > 0 ) ) {\n        encode_eobrun( huffw, actbl, eobrun );\n        encode_crbits( huffw, storw );\n    }\n\n    // encode AC\n    z = 0;\n    for ( bpos = from; bpos < eob; bpos++ )\n    {\n        tmp = block[ bpos ];\n        // if zero is encountered\n        if ( tmp == 0 ) {\n            z++; // increment zero counter\n            if ( z == 16 ) { // write zeroes if needed\n                huffw->write( actbl->cval[ 0xF0 ], actbl->clen[ 0xF0 ] );\n                encode_crbits( huffw, storw );\n                z = 0;\n            }\n        }\n        // if nonzero is encountered\n        else if ( ( tmp == 1 ) || ( tmp == -1 ) ) {\n            // vli encode\n            s = nonzero_bit_length(ABS(tmp));\n            n = ENVLI( s, tmp );\n            hc = ( ( z << 4 ) + s );\n            // write to huffman writer\n            huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n            huffw->write( n, s );\n            // write correction bits\n            encode_crbits( huffw, storw );\n            // reset zeroes\n            z = 0;\n        }\n        else { // store correction bits\n            n = block[ bpos ] & 0x1;\n            storw->write( n );\n        }\n    }\n\n    // fast processing after eob\n    for ( ;bpos <= to; bpos++ )\n    {\n        if ( block[ bpos ] != 0 ) { // store correction bits\n            n = block[ bpos ] & 0x1;\n            storw->write( n );\n        }\n    }\n\n    // check eob, increment eobrun if needed\n    if ( eob <= to ) {\n        (*eobrun)++;\n        // check eobrun, encode if needed\n        if ( (*eobrun) == actbl->max_eobrun ) {\n            encode_eobrun( huffw, actbl, eobrun );\n            encode_crbits( huffw, storw );\n        }\n    }\n\n    // return eob\n    return eob;\n}\n\n\n/* -----------------------------------------------\n    run of EOB SA decoding routine\n    ----------------------------------------------- */\nint decode_eobrun_sa( abitreader* huffr, short* block, unsigned int* eobrun, int from, int to )\n{\n    unsigned short n;\n    int bpos;\n\n\n    // fast eobrun decoding routine for succesive approximation\n    for ( bpos = from; bpos <= to; bpos++ ) {\n        if ( block[ bpos ] != 0 ) {\n            n = huffr->read( 1 );\n            block[ bpos ] = ( block[ bpos ] > 0 ) ? n : -n;\n        }\n    }\n\n    // decrement eobrun\n    (*eobrun)--;\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    run of EOB encoding routine\n    ----------------------------------------------- */\nint encode_eobrun( abitwriter* huffw, huffCodes* actbl, unsigned int* eobrun )\n{\n    unsigned short n;\n    unsigned int  s;\n    int hc;\n\n\n    if ( (*eobrun) > 0 ) {\n        while ( (*eobrun) > actbl->max_eobrun ) {\n            huffw->write( actbl->cval[ 0xE0 ], actbl->clen[ 0xE0 ] );\n            huffw->write( E_ENVLI( 14, 32767 ), 14 );\n            (*eobrun) -= actbl->max_eobrun;\n        }\n        s = uint16bit_length((*eobrun));\n        dev_assert(s && \"actbl->max_eobrun needs to be > 0\");\n        if (s) s--;\n        n = E_ENVLI( s, (*eobrun) );\n        hc = ( s << 4 );\n        huffw->write( actbl->cval[ hc ], actbl->clen[ hc ] );\n        huffw->write( n, s );\n        (*eobrun) = 0;\n    }\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    correction bits encoding routine\n    ----------------------------------------------- */\nint encode_crbits( abitwriter* huffw, abytewriter* storw )\n{\n    unsigned char* data;\n    int len;\n    int i;\n\n\n    // peek into data from abytewriter\n    len = storw->getpos();\n    if ( len == 0 ) return 0;\n    data = storw->peekptr_aligned();\n\n    // write bits to huffwriter\n    for ( i = 0; i < len; i++ )\n        huffw->write( data[ i ], 1 );\n\n    // reset abytewriter, discard data\n    storw->reset();\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    returns next code (from huffman-tree & -data)\n    ----------------------------------------------- */\nint next_huffcode( abitreader *huffw, huffTree *ctree, Billing min_bill, Billing max_bill)\n{\n    int node = 0;\n\n\n    while ( node < 256 ) {\n#if defined(ENABLE_BILLING) || !defined(NDEBUG)\n        write_bit_bill(min_bill, false, 1);\n        if (min_bill != max_bill) {\n            min_bill = (Billing)((int)min_bill + 1);\n        }\n#endif\n        node = ( huffw->read( 1 ) == 1 ) ?\n                ctree->r[ node ] : ctree->l[ node ];\n        if ( node == 0 ) break;\n    }\n\n    return ( node - 256 );\n}\n\n\n\n/* -----------------------------------------------\n    calculates next position (non interleaved)\n    ----------------------------------------------- */\nint next_mcuposn( int* cmp, int* dpos, int* rstw )\n{\n    // increment position\n    (*dpos)++;\n\n    // fix for non interleaved mcu - horizontal\n    if ( cmpnfo[(*cmp)].bch != cmpnfo[(*cmp)].nch ) {\n        if ( (*dpos) % cmpnfo[(*cmp)].bch == cmpnfo[(*cmp)].nch )\n            (*dpos) += ( cmpnfo[(*cmp)].bch - cmpnfo[(*cmp)].nch );\n    }\n\n    // fix for non interleaved mcu - vertical\n    if ( cmpnfo[(*cmp)].bcv != cmpnfo[(*cmp)].ncv ) {\n        if ( (*dpos) / cmpnfo[(*cmp)].bch == cmpnfo[(*cmp)].ncv )\n            (*dpos) = cmpnfo[(*cmp)].bc;\n    }\n\n    // check position\n    if ( (*dpos) >= cmpnfo[(*cmp)].bc ) return 2;\n    else if ( rsti > 0 )\n        if ( --(*rstw) == 0 ) return 1;\n\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    skips the eobrun, calculates next position\n    ----------------------------------------------- */\nint skip_eobrun( int* cmp, int* dpos, int* rstw, unsigned int* eobrun )\n{\n    if ( (*eobrun) > 0 ) // error check for eobrun\n    {\n        // compare rst wait counter if needed\n        if ( rsti > 0 ) {\n            if ( (int)(*eobrun) > (*rstw) )\n                return -1;\n            else\n                (*rstw) -= (*eobrun);\n        }\n\n        // fix for non interleaved mcu - horizontal\n        if ( cmpnfo[(*cmp)].bch != cmpnfo[(*cmp)].nch ) {\n            (*dpos) += ( ( ( (*dpos) % cmpnfo[(*cmp)].bch ) + (*eobrun) ) /\n                        cmpnfo[(*cmp)].nch ) * ( cmpnfo[(*cmp)].bch - cmpnfo[(*cmp)].nch );\n        }\n\n        // fix for non interleaved mcu - vertical\n        if ( cmpnfo[(*cmp)].bcv != cmpnfo[(*cmp)].ncv ) {\n            if ( (*dpos) / cmpnfo[(*cmp)].bch >= cmpnfo[(*cmp)].ncv )\n                (*dpos) += ( cmpnfo[(*cmp)].bcv - cmpnfo[(*cmp)].ncv ) *\n                        cmpnfo[(*cmp)].bch;\n        }\n\n        // skip blocks\n        (*dpos) += (*eobrun);\n\n        // reset eobrun\n        (*eobrun) = 0;\n\n        // check position\n        if ( (*dpos) == cmpnfo[(*cmp)].bc ) return 2;\n        else if ( (*dpos) > cmpnfo[(*cmp)].bc ) return -1;\n        else if ( rsti > 0 )\n            if ( (*rstw) == 0 ) return 1;\n    }\n\n    return 0;\n}\n\n\n/* -----------------------------------------------\n    creates huffman-codes & -trees from dht-data\n    ----------------------------------------------- */\nbool build_huffcodes( unsigned char *clen, uint32_t clenlen, unsigned char *cval, uint32_t cvallen, huffCodes *hc, huffTree *ht )\n{\n    int nextfree;\n    int code;\n    int node;\n    int i, j, k;\n\n\n    // fill with zeroes\n    memset( hc->clen, 0, 256 * sizeof( short ) );\n    memset( hc->cval, 0, 256 * sizeof( short ) );\n    memset( ht->l, 0, 256 * sizeof( short ) );\n    memset( ht->r, 0, 256 * sizeof( short ) );\n\n    // 1st part -> build huffman codes\n\n    // creating huffman-codes\n    k = 0;\n    code = 0;\n\n    // symbol-value of code is its position in the table\n    for( i = 0; i < 16; i++ ) {\n        uint32_t clen_index = i & 0xff;\n        for( j = 0; j < (int) (clen_index < clenlen ? clen[clen_index] : 0); j++ ) {\n            uint32_t cval_index = k&0xff;\n            uint8_t cval_val= cval_index < cvallen ? cval[cval_index] : 0;\n            hc->clen[ (int) cval_val&0xff] = 1 + i;\n            hc->cval[ (int) cval_val&0xff] = code;\n\n            k++;\n            code++;\n        }\n        code = code << 1;\n    }\n\n    // find out eobrun max value\n    hc->max_eobrun = 0;\n    for ( i = 14; i >= 0; i-- ) {\n        if ( hc->clen[(i << 4) & 255] > 0 ) {\n            hc->max_eobrun = ( 2 << i ) - 1;\n            break;\n        }\n    }\n\n    // 2nd -> part use codes to build the coding tree\n\n    // initial value for next free place\n    nextfree = 1;\n    const char * huffman_no_space = \"Huffman table out of space\\n\";\n    // work through every code creating links between the nodes (represented through ints)\n    for ( i = 0; i < 256; i++ )    {\n        // (re)set current node\n        node = 0;\n        // go through each code & store path\n        for ( j = hc->clen[i] - 1; j > 0; j-- ) {\n            if (node <= 0xff) {\n                if ( BITN( hc->cval[i], j ) == 1 ) {\n                    if ( ht->r[node] == 0 ) {\n                         ht->r[node] = nextfree++;\n                    }\n                    node = ht->r[node];\n                }\n                else {\n                    if ( ht->l[node] == 0 ) {\n                        ht->l[node] = nextfree++;\n                    }\n                    node = ht->l[node];\n                }\n            } else {\n                while(write(2, huffman_no_space, strlen(huffman_no_space)) == -1 && errno == EINTR) {}\n                if (filetype == JPEG) {\n                    return false;\n                }\n            }\n        }\n        if (node <= 0xff) {\n            // last link is number of targetvalue + 256\n            if ( hc->clen[i] > 0 ) {\n                if ( BITN( hc->cval[i], 0 ) == 1 ) {\n                    ht->r[node] = i + 256;\n                } else {\n                    ht->l[node] = i + 256;\n                }\n            }\n        } else {\n            while(write(2, huffman_no_space, strlen(huffman_no_space)) == -1 && errno == EINTR) {}\n            if (filetype == JPEG) {\n                return false; // we accept any .lep file that was encoded this way\n            }\n        }\n    }\n    return true;\n}\n\n/* ----------------------- End of JPEG specific functions -------------------------- */\n\n/* ----------------------- Begin of developers functions -------------------------- */\n\n\n\n\n\n/* -----------------------------------------------\n    Writes info to textfile\n    ----------------------------------------------- */\nbool write_info( void )\n{\n    FILE* fp;\n    const char* fn = \"stdout\";\n\n    unsigned char  type = 0x00; // type of current marker segment\n    unsigned int   len  = 0; // length of current marker segment\n    unsigned int   hpos = 0; // position in header\n\n    int cmp, bpos;\n    int i;\n\n\n    // open file for output\n    fp = stdout;\n    if ( fp == NULL ){\n        fprintf( stderr, FWR_ERRMSG, fn);\n        errorlevel.store(2);\n        return false;\n    }\n\n    // info about image\n    fprintf( fp, \"<Infofile for JPEG image:>\\n\\n\\n\");\n    fprintf( fp, \"coding process: %s\\n\", ( jpegtype == 1 ) ? \"sequential\" : \"progressive\" );\n    // fprintf( fp, \"no of scans: %i\\n\", scnc );\n    fprintf( fp, \"imageheight: %i / imagewidth: %i\\n\", imgheight, imgwidth );\n    fprintf( fp, \"component count: %i\\n\", cmpc );\n    fprintf( fp, \"mcu count: %i/%i/%i (all/v/h)\\n\\n\", mcuc, mcuv, mcuh );\n\n    // info about header\n    fprintf( fp, \"\\nfile header structure:\\n\" );\n    fprintf( fp, \" type  length   hpos\\n\" );\n    // header parser loop\n    for ( hpos = 0; hpos < hdrs; hpos += len ) {\n        type = hpos + 1 < hdrs ? hdrdata[ hpos + 1 ] : 0 ;\n        len = 2 + B_SHORT( hpos  + 2 < hdrs ? hdrdata[ hpos + 2 ] : 0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] : 0);\n        fprintf( fp, \" FF%2X  %6i %6i\\n\", type, len, hpos );\n    }\n    fprintf( fp, \" _END       0 %6i\\n\", hpos );\n    fprintf( fp, \"\\n\" );\n\n    // info about components\n    for ( cmp = 0; cmp < cmpc; cmp++ ) {\n        fprintf( fp, \"\\n\" );\n        fprintf( fp, \"component number %i ->\\n\", cmp );\n        fprintf( fp, \"sample factors: %i/%i (v/h)\\n\", cmpnfo[cmp].sfv, cmpnfo[cmp].sfh );\n        fprintf( fp, \"blocks per mcu: %i\\n\", cmpnfo[cmp].mbs );\n        fprintf( fp, \"block count (mcu): %i/%i/%i (all/v/h)\\n\",\n            cmpnfo[cmp].bc, cmpnfo[cmp].bcv, cmpnfo[cmp].bch );\n        fprintf( fp, \"block count (sng): %i/%i/%i (all/v/h)\\n\",\n            cmpnfo[cmp].nc, cmpnfo[cmp].ncv, cmpnfo[cmp].nch );\n        fprintf( fp, \"quantiser table ->\" );\n        for ( i = 0; i < 64; i++ ) {\n            bpos = zigzag[ i ];\n            if ( ( i % 8 ) == 0 ) fprintf( fp, \"\\n\" );\n            fprintf( fp, \"%4i, \", QUANT( cmp, bpos ) );\n        }\n        fprintf( fp, \"\\n\" );\n        fprintf( fp, \"maximum values ->\" );\n        for ( i = 0; i < 64; i++ ) {\n            bpos = zigzag[ i ];\n            if ( ( i % 8 ) == 0 ) fprintf( fp, \"\\n\" );\n            fprintf( fp, \"%4i, \", MAX_V( cmp, bpos ) );\n        }\n        fprintf( fp, \"\\n\\n\" );\n    }\n\n\n    fclose( fp );\n\n\n    return true;\n}\n\n/* ----------------------- End of developers functions -------------------------- */\n\n/* ----------------------- End of file -------------------------- */\n"], "filenames": ["src/lepton/jpgcoder.cc"], "buggy_code_start_loc": [4166], "buggy_code_end_loc": [4167], "fixing_code_start_loc": [4166], "fixing_code_end_loc": [4167], "type": "CWE-190", "message": "read_ujpg in jpgcoder.cc in Dropbox Lepton 1.2.1 allows attackers to cause a denial-of-service (application runtime crash because of an integer overflow) via a crafted file.", "other": {"cve": {"id": "CVE-2018-20820", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-23T14:29:00.367", "lastModified": "2019-04-24T20:16:18.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "read_ujpg in jpgcoder.cc in Dropbox Lepton 1.2.1 allows attackers to cause a denial-of-service (application runtime crash because of an integer overflow) via a crafted file."}, {"lang": "es", "value": "En read_ujpg en jpgcoder.cc en Dropbox Lepton versi\u00f3n 1.2.1 hay una vulnerabilidad que permite a los atacantes provocar una denegaci\u00f3n de servicio (bloqueo de tiempo de ejecuci\u00f3n de la aplicaci\u00f3n debido a un desbordamiento de enteros) por medio de un archivo creado"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropbox:lepton:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "6DCDBF54-A4B3-4D67-A014-6ECC38D58621"}]}]}], "references": [{"url": "https://github.com/dropbox/lepton/commit/6a5ceefac1162783fffd9506a3de39c85c725761", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropbox/lepton/issues/111", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dropbox/lepton/commit/6a5ceefac1162783fffd9506a3de39c85c725761"}}