{"buggy_code": ["#include \"jsi.h\"\n#include \"jscompile.h\"\n#include \"jsvalue.h\"\n#include \"jsrun.h\"\n\n#include \"utf.h\"\n\nstatic void jsR_run(js_State *J, js_Function *F);\n\n/* Push values on stack */\n\n#define STACK (J->stack)\n#define TOP (J->top)\n#define BOT (J->bot)\n\nstatic void js_stackoverflow(js_State *J)\n{\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = \"stack overflow\";\n\t++TOP;\n\tjs_throw(J);\n}\n\nstatic void js_outofmemory(js_State *J)\n{\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = \"out of memory\";\n\t++TOP;\n\tjs_throw(J);\n}\n\nvoid *js_malloc(js_State *J, int size)\n{\n\tvoid *ptr = J->alloc(J->actx, NULL, size);\n\tif (!ptr)\n\t\tjs_outofmemory(J);\n\treturn ptr;\n}\n\nvoid *js_realloc(js_State *J, void *ptr, int size)\n{\n\tptr = J->alloc(J->actx, ptr, size);\n\tif (!ptr)\n\t\tjs_outofmemory(J);\n\treturn ptr;\n}\n\nchar *js_strdup(js_State *J, const char *s)\n{\n\tint n = strlen(s) + 1;\n\tchar *p = js_malloc(J, n);\n\tmemcpy(p, s, n);\n\treturn p;\n}\n\nvoid js_free(js_State *J, void *ptr)\n{\n\tJ->alloc(J->actx, ptr, 0);\n}\n\njs_String *jsV_newmemstring(js_State *J, const char *s, int n)\n{\n\tjs_String *v = js_malloc(J, soffsetof(js_String, p) + n + 1);\n\tmemcpy(v->p, s, n);\n\tv->p[n] = 0;\n\tv->gcmark = 0;\n\tv->gcnext = J->gcstr;\n\tJ->gcstr = v;\n\t++J->gccounter;\n\treturn v;\n}\n\n#define CHECKSTACK(n) if (TOP + n >= JS_STACKSIZE) js_stackoverflow(J)\n\nvoid js_pushvalue(js_State *J, js_Value v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = v;\n\t++TOP;\n}\n\nvoid js_pushundefined(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TUNDEFINED;\n\t++TOP;\n}\n\nvoid js_pushnull(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TNULL;\n\t++TOP;\n}\n\nvoid js_pushboolean(js_State *J, int v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TBOOLEAN;\n\tSTACK[TOP].u.boolean = !!v;\n\t++TOP;\n}\n\nvoid js_pushnumber(js_State *J, double v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TNUMBER;\n\tSTACK[TOP].u.number = v;\n\t++TOP;\n}\n\nvoid js_pushstring(js_State *J, const char *v)\n{\n\tint n = strlen(v);\n\tCHECKSTACK(1);\n\tif (n <= soffsetof(js_Value, type)) {\n\t\tchar *s = STACK[TOP].u.shrstr;\n\t\twhile (n--) *s++ = *v++;\n\t\t*s = 0;\n\t\tSTACK[TOP].type = JS_TSHRSTR;\n\t} else {\n\t\tSTACK[TOP].type = JS_TMEMSTR;\n\t\tSTACK[TOP].u.memstr = jsV_newmemstring(J, v, n);\n\t}\n\t++TOP;\n}\n\nvoid js_pushlstring(js_State *J, const char *v, int n)\n{\n\tCHECKSTACK(1);\n\tif (n <= soffsetof(js_Value, type)) {\n\t\tchar *s = STACK[TOP].u.shrstr;\n\t\twhile (n--) *s++ = *v++;\n\t\t*s = 0;\n\t\tSTACK[TOP].type = JS_TSHRSTR;\n\t} else {\n\t\tSTACK[TOP].type = JS_TMEMSTR;\n\t\tSTACK[TOP].u.memstr = jsV_newmemstring(J, v, n);\n\t}\n\t++TOP;\n}\n\nvoid js_pushliteral(js_State *J, const char *v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = v;\n\t++TOP;\n}\n\nvoid js_pushobject(js_State *J, js_Object *v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TOBJECT;\n\tSTACK[TOP].u.object = v;\n\t++TOP;\n}\n\nvoid js_pushglobal(js_State *J)\n{\n\tjs_pushobject(J, J->G);\n}\n\nvoid js_currentfunction(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[BOT-1];\n\t++TOP;\n}\n\n/* Read values from stack */\n\nstatic js_Value *stackidx(js_State *J, int idx)\n{\n\tstatic js_Value undefined = { {0}, {0}, JS_TUNDEFINED };\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < 0 || idx >= TOP)\n\t\treturn &undefined;\n\treturn STACK + idx;\n}\n\njs_Value *js_tovalue(js_State *J, int idx)\n{\n\treturn stackidx(J, idx);\n}\n\nint js_isdefined(js_State *J, int idx) { return stackidx(J, idx)->type != JS_TUNDEFINED; }\nint js_isundefined(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TUNDEFINED; }\nint js_isnull(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TNULL; }\nint js_isboolean(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TBOOLEAN; }\nint js_isnumber(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TNUMBER; }\nint js_isstring(js_State *J, int idx) { enum js_Type t = stackidx(J, idx)->type; return t == JS_TSHRSTR || t == JS_TLITSTR || t == JS_TMEMSTR; }\nint js_isprimitive(js_State *J, int idx) { return stackidx(J, idx)->type != JS_TOBJECT; }\nint js_isobject(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TOBJECT; }\nint js_iscoercible(js_State *J, int idx) { js_Value *v = stackidx(J, idx); return v->type != JS_TUNDEFINED && v->type != JS_TNULL; }\n\nint js_iscallable(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT)\n\t\treturn v->u.object->type == JS_CFUNCTION ||\n\t\t\tv->u.object->type == JS_CSCRIPT ||\n\t\t\tv->u.object->type == JS_CCFUNCTION;\n\treturn 0;\n}\n\nint js_isarray(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CARRAY;\n}\n\nint js_isregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP;\n}\n\nint js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}\n\nint js_iserror(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CERROR;\n}\n\nconst char *js_typeof(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tswitch (v->type) {\n\tdefault:\n\tcase JS_TSHRSTR: return \"string\";\n\tcase JS_TUNDEFINED: return \"undefined\";\n\tcase JS_TNULL: return \"object\";\n\tcase JS_TBOOLEAN: return \"boolean\";\n\tcase JS_TNUMBER: return \"number\";\n\tcase JS_TLITSTR: return \"string\";\n\tcase JS_TMEMSTR: return \"string\";\n\tcase JS_TOBJECT:\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn \"function\";\n\t\treturn \"object\";\n\t}\n}\n\nint js_type(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tswitch (v->type) {\n\tdefault:\n\tcase JS_TSHRSTR: return JS_ISSTRING;\n\tcase JS_TUNDEFINED: return JS_ISUNDEFINED;\n\tcase JS_TNULL: return JS_ISNULL;\n\tcase JS_TBOOLEAN: return JS_ISBOOLEAN;\n\tcase JS_TNUMBER: return JS_ISNUMBER;\n\tcase JS_TLITSTR: return JS_ISSTRING;\n\tcase JS_TMEMSTR: return JS_ISSTRING;\n\tcase JS_TOBJECT:\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn JS_ISFUNCTION;\n\t\treturn JS_ISOBJECT;\n\t}\n}\n\nint js_toboolean(js_State *J, int idx)\n{\n\treturn jsV_toboolean(J, stackidx(J, idx));\n}\n\ndouble js_tonumber(js_State *J, int idx)\n{\n\treturn jsV_tonumber(J, stackidx(J, idx));\n}\n\nint js_tointeger(js_State *J, int idx)\n{\n\treturn jsV_numbertointeger(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nint js_toint32(js_State *J, int idx)\n{\n\treturn jsV_numbertoint32(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nunsigned int js_touint32(js_State *J, int idx)\n{\n\treturn jsV_numbertouint32(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nshort js_toint16(js_State *J, int idx)\n{\n\treturn jsV_numbertoint16(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nunsigned short js_touint16(js_State *J, int idx)\n{\n\treturn jsV_numbertouint16(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nconst char *js_tostring(js_State *J, int idx)\n{\n\treturn jsV_tostring(J, stackidx(J, idx));\n}\n\njs_Object *js_toobject(js_State *J, int idx)\n{\n\treturn jsV_toobject(J, stackidx(J, idx));\n}\n\nvoid js_toprimitive(js_State *J, int idx, int hint)\n{\n\tjsV_toprimitive(J, stackidx(J, idx), hint);\n}\n\njs_Regexp *js_toregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP)\n\t\treturn &v->u.object->u.r;\n\tjs_typeerror(J, \"not a regexp\");\n}\n\nvoid *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}\n\nstatic js_Object *jsR_tofunction(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TUNDEFINED || v->type == JS_TNULL)\n\t\treturn NULL;\n\tif (v->type == JS_TOBJECT)\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn v->u.object;\n\tjs_typeerror(J, \"not a function\");\n}\n\n/* Stack manipulation */\n\nint js_gettop(js_State *J)\n{\n\treturn TOP - BOT;\n}\n\nvoid js_pop(js_State *J, int n)\n{\n\tTOP -= n;\n\tif (TOP < BOT) {\n\t\tTOP = BOT;\n\t\tjs_error(J, \"stack underflow!\");\n\t}\n}\n\nvoid js_remove(js_State *J, int idx)\n{\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < BOT || idx >= TOP)\n\t\tjs_error(J, \"stack error!\");\n\tfor (;idx < TOP - 1; ++idx)\n\t\tSTACK[idx] = STACK[idx+1];\n\t--TOP;\n}\n\nvoid js_insert(js_State *J, int idx)\n{\n\tjs_error(J, \"not implemented yet\");\n}\n\nvoid js_replace(js_State* J, int idx)\n{\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < BOT || idx >= TOP)\n\t\tjs_error(J, \"stack error!\");\n\tSTACK[idx] = STACK[--TOP];\n}\n\nvoid js_copy(js_State *J, int idx)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = *stackidx(J, idx);\n\t++TOP;\n}\n\nvoid js_dup(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[TOP-1];\n\t++TOP;\n}\n\nvoid js_dup2(js_State *J)\n{\n\tCHECKSTACK(2);\n\tSTACK[TOP] = STACK[TOP-2];\n\tSTACK[TOP+1] = STACK[TOP-1];\n\tTOP += 2;\n}\n\nvoid js_rot2(js_State *J)\n{\n\t/* A B -> B A */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B (B) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A A */\n\tSTACK[TOP-2] = tmp;\t\t/* B A */\n}\n\nvoid js_rot3(js_State *J)\n{\n\t/* A B C -> C A B */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B C (C) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A B B */\n\tSTACK[TOP-2] = STACK[TOP-3];\t/* A A B */\n\tSTACK[TOP-3] = tmp;\t\t/* C A B */\n}\n\nvoid js_rot4(js_State *J)\n{\n\t/* A B C D -> D A B C */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B C D (D) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A B C C */\n\tSTACK[TOP-2] = STACK[TOP-3];\t/* A B B C */\n\tSTACK[TOP-3] = STACK[TOP-4];\t/* A A B C */\n\tSTACK[TOP-4] = tmp;\t\t/* D A B C */\n}\n\nvoid js_rot2pop1(js_State *J)\n{\n\t/* A B -> B */\n\tSTACK[TOP-2] = STACK[TOP-1];\n\t--TOP;\n}\n\nvoid js_rot3pop2(js_State *J)\n{\n\t/* A B C -> C */\n\tSTACK[TOP-3] = STACK[TOP-1];\n\tTOP -= 2;\n}\n\nvoid js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}\n\n/* Property access that takes care of attributes and getters/setters */\n\nint js_isarrayindex(js_State *J, const char *p, int *idx)\n{\n\tint n = 0;\n\n\t/* check for empty string */\n\tif (p[0] == 0)\n\t\treturn 0;\n\n\t/* check for '0' and integers with leading zero */\n\tif (p[0] == '0')\n\t\treturn (p[1] == 0) ? *idx = 0, 1 : 0;\n\n\twhile (*p) {\n\t\tint c = *p++;\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tif (n >= INT_MAX / 10)\n\t\t\t\treturn 0;\n\t\t\tn = n * 10 + (c - '0');\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn *idx = n, 1;\n}\n\nstatic void js_pushrune(js_State *J, Rune rune)\n{\n\tchar buf[UTFmax + 1];\n\tif (rune >= 0) {\n\t\tbuf[runetochar(buf, &rune)] = 0;\n\t\tjs_pushstring(J, buf);\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n}\n\nstatic int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void jsR_getproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tif (!jsR_hasproperty(J, obj, name))\n\t\tjs_pushundefined(J);\n}\n\nstatic void jsR_setproperty(js_State *J, js_Object *obj, const char *name, int transient)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen || newlen < 0)\n\t\t\t\tjs_rangeerror(J, \"invalid array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\n\t/* First try to find a setter in prototype chain */\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref) {\n\t\tif (ref->setter) {\n\t\t\tjs_pushobject(J, ref->setter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_pushvalue(J, *value);\n\t\t\tjs_call(J, 1);\n\t\t\tjs_pop(J, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (J->strict)\n\t\t\t\tif (ref->getter)\n\t\t\t\t\tjs_typeerror(J, \"setting property '%s' that only has a getter\", name);\n\t\t\tif (ref->atts & JS_READONLY)\n\t\t\t\tgoto readonly;\n\t\t}\n\t}\n\n\t/* Property not found on this object, so create one */\n\tif (!ref || !own) {\n\t\tif (transient) {\n\t\t\tif (J->strict)\n\t\t\t\tjs_typeerror(J, \"cannot create property '%s' on transient object\", name);\n\t\t\treturn;\n\t\t}\n\t\tref = jsV_setproperty(J, obj, name);\n\t}\n\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\n\treturn;\n\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}\n\nstatic void jsR_defproperty(js_State *J, js_Object *obj, const char *name,\n\tint atts, js_Value *value, js_Object *getter, js_Object *setter,\n\tint throw)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) goto readonly;\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\n\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (value) {\n\t\t\tif (!(ref->atts & JS_READONLY))\n\t\t\t\tref->value = *value;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n\t\t}\n\t\tif (getter) {\n\t\t\tif (!(ref->atts & JS_DONTCONF))\n\t\t\t\tref->getter = getter;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t}\n\t\tif (setter) {\n\t\t\tif (!(ref->atts & JS_DONTCONF))\n\t\t\t\tref->setter = setter;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t}\n\t\tref->atts |= atts;\n\t}\n\n\treturn;\n\nreadonly:\n\tif (J->strict || throw)\n\t\tjs_typeerror(J, \"'%s' is read-only or non-configurable\", name);\n}\n\nstatic int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\n\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}\n\n/* Registry, global and object property accessors */\n\nconst char *js_ref(js_State *J)\n{\n\tjs_Value *v = stackidx(J, -1);\n\tconst char *s;\n\tchar buf[32];\n\tswitch (v->type) {\n\tcase JS_TUNDEFINED: s = \"_Undefined\"; break;\n\tcase JS_TNULL: s = \"_Null\"; break;\n\tcase JS_TBOOLEAN:\n\t\ts = v->u.boolean ? \"_True\" : \"_False\";\n\t\tbreak;\n\tcase JS_TOBJECT:\n\t\tsprintf(buf, \"%p\", (void*)v->u.object);\n\t\ts = js_intern(J, buf);\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf, \"%d\", J->nextref++);\n\t\ts = js_intern(J, buf);\n\t\tbreak;\n\t}\n\tjs_setregistry(J, s);\n\treturn s;\n}\n\nvoid js_unref(js_State *J, const char *ref)\n{\n\tjs_delregistry(J, ref);\n}\n\nvoid js_getregistry(js_State *J, const char *name)\n{\n\tjsR_getproperty(J, J->R, name);\n}\n\nvoid js_setregistry(js_State *J, const char *name)\n{\n\tjsR_setproperty(J, J->R, name, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_delregistry(js_State *J, const char *name)\n{\n\tjsR_delproperty(J, J->R, name);\n}\n\nvoid js_getglobal(js_State *J, const char *name)\n{\n\tjsR_getproperty(J, J->G, name);\n}\n\nvoid js_setglobal(js_State *J, const char *name)\n{\n\tjsR_setproperty(J, J->G, name, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_defglobal(js_State *J, const char *name, int atts)\n{\n\tjsR_defproperty(J, J->G, name, atts, stackidx(J, -1), NULL, NULL, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_delglobal(js_State *J, const char *name)\n{\n\tjsR_delproperty(J, J->G, name);\n}\n\nvoid js_getproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_getproperty(J, js_toobject(J, idx), name);\n}\n\nvoid js_setproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_setproperty(J, js_toobject(J, idx), name, !js_isobject(J, idx));\n\tjs_pop(J, 1);\n}\n\nvoid js_defproperty(js_State *J, int idx, const char *name, int atts)\n{\n\tjsR_defproperty(J, js_toobject(J, idx), name, atts, stackidx(J, -1), NULL, NULL, 1);\n\tjs_pop(J, 1);\n}\n\nvoid js_delproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_delproperty(J, js_toobject(J, idx), name);\n}\n\nvoid js_defaccessor(js_State *J, int idx, const char *name, int atts)\n{\n\tjsR_defproperty(J, js_toobject(J, idx), name, atts, NULL, jsR_tofunction(J, -2), jsR_tofunction(J, -1), 1);\n\tjs_pop(J, 2);\n}\n\nint js_hasproperty(js_State *J, int idx, const char *name)\n{\n\treturn jsR_hasproperty(J, js_toobject(J, idx), name);\n}\n\n/* Iterator */\n\nvoid js_pushiterator(js_State *J, int idx, int own)\n{\n\tjs_pushobject(J, jsV_newiterator(J, js_toobject(J, idx), own));\n}\n\nconst char *js_nextiterator(js_State *J, int idx)\n{\n\treturn jsV_nextiterator(J, js_toobject(J, idx));\n}\n\n/* Environment records */\n\njs_Environment *jsR_newenvironment(js_State *J, js_Object *vars, js_Environment *outer)\n{\n\tjs_Environment *E = js_malloc(J, sizeof *E);\n\tE->gcmark = 0;\n\tE->gcnext = J->gcenv;\n\tJ->gcenv = E;\n\t++J->gccounter;\n\n\tE->outer = outer;\n\tE->variables = vars;\n\treturn E;\n}\n\nstatic void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL, 0);\n}\n\nstatic int js_hasvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->getter) {\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\t\tjs_pushobject(J, E->variables);\n\t\t\t\tjs_call(J, 0);\n\t\t\t} else {\n\t\t\t\tjs_pushvalue(J, ref->value);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\treturn 0;\n}\n\nstatic void js_setvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->setter) {\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\t\tjs_pushobject(J, E->variables);\n\t\t\t\tjs_copy(J, -3);\n\t\t\t\tjs_call(J, 1);\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ref->atts & JS_READONLY))\n\t\t\t\tref->value = *stackidx(J, -1);\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n\t\t\treturn;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\tif (J->strict)\n\t\tjs_referenceerror(J, \"assignment to undeclared variable '%s'\", name);\n\tjsR_setproperty(J, J->G, name, 0);\n}\n\nstatic int js_delvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getownproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->atts & JS_DONTCONF) {\n\t\t\t\tif (J->strict)\n\t\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjsV_delproperty(J, E->variables, name);\n\t\t\treturn 1;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\treturn jsR_delproperty(J, J->G, name);\n}\n\n/* Function calls */\n\nstatic void jsR_savescope(js_State *J, js_Environment *newE)\n{\n\tif (J->envtop + 1 >= JS_ENVLIMIT)\n\t\tjs_stackoverflow(J);\n\tJ->envstack[J->envtop++] = J->E;\n\tJ->E = newE;\n}\n\nstatic void jsR_restorescope(js_State *J)\n{\n\tJ->E = J->envstack[--J->envtop];\n}\n\nstatic void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tjsR_savescope(J, scope);\n\n\tif (n > F->numparams) {\n\t\tjs_pop(J, n - F->numparams);\n\t\tn = F->numparams;\n\t}\n\n\tfor (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n\nstatic void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\n\tjsR_savescope(J, scope);\n\n\tif (F->arguments) {\n\t\tjs_newarguments(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\n\tfor (i = 0; i < n && i < F->numparams; ++i)\n\t\tjs_initvar(J, F->vartab[i], i + 1);\n\tjs_pop(J, n);\n\n\tfor (; i < F->varlen; ++i) {\n\t\tjs_pushundefined(J);\n\t\tjs_initvar(J, F->vartab[i], -1);\n\t\tjs_pop(J, 1);\n\t}\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n\nstatic void jsR_callscript(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tif (scope)\n\t\tjsR_savescope(J, scope);\n\n\t/* scripts take no arguments */\n\tjs_pop(J, n);\n\n\tfor (i = 0; i < F->varlen; ++i) {\n\t\t/* Bug 701886: don't redefine existing vars in eval/scripts */\n\t\tif (!js_hasvar(J, F->vartab[i])) {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tif (scope)\n\t\tjsR_restorescope(J);\n}\n\nstatic void jsR_callcfunction(js_State *J, int n, int min, js_CFunction F)\n{\n\tint i;\n\tjs_Value v;\n\n\tfor (i = n; i < min; ++i)\n\t\tjs_pushundefined(J);\n\n\tF(J);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n}\n\nstatic void jsR_pushtrace(js_State *J, const char *name, const char *file, int line)\n{\n\tif (J->tracetop + 1 == JS_ENVLIMIT)\n\t\tjs_error(J, \"call stack overflow\");\n\t++J->tracetop;\n\tJ->trace[J->tracetop].name = name;\n\tJ->trace[J->tracetop].file = file;\n\tJ->trace[J->tracetop].line = line;\n}\n\nvoid js_call(js_State *J, int n)\n{\n\tjs_Object *obj;\n\tint savebot;\n\n\tif (!js_iscallable(J, -n-2))\n\t\tjs_typeerror(J, \"%s is not callable\", js_typeof(J, -n-2));\n\n\tobj = js_toobject(J, -n-2);\n\n\tsavebot = BOT;\n\tBOT = TOP - n - 1;\n\n\tif (obj->type == JS_CFUNCTION) {\n\t\tjsR_pushtrace(J, obj->u.f.function->name, obj->u.f.function->filename, obj->u.f.function->line);\n\t\tif (obj->u.f.function->lightweight)\n\t\t\tjsR_calllwfunction(J, n, obj->u.f.function, obj->u.f.scope);\n\t\telse\n\t\t\tjsR_callfunction(J, n, obj->u.f.function, obj->u.f.scope);\n\t\t--J->tracetop;\n\t} else if (obj->type == JS_CSCRIPT) {\n\t\tjsR_pushtrace(J, obj->u.f.function->name, obj->u.f.function->filename, obj->u.f.function->line);\n\t\tjsR_callscript(J, n, obj->u.f.function, obj->u.f.scope);\n\t\t--J->tracetop;\n\t} else if (obj->type == JS_CCFUNCTION) {\n\t\tjsR_pushtrace(J, obj->u.c.name, \"native\", 0);\n\t\tjsR_callcfunction(J, n, obj->u.c.length, obj->u.c.function);\n\t\t--J->tracetop;\n\t}\n\n\tBOT = savebot;\n}\n\nvoid js_construct(js_State *J, int n)\n{\n\tjs_Object *obj;\n\tjs_Object *prototype;\n\tjs_Object *newobj;\n\n\tif (!js_iscallable(J, -n-1))\n\t\tjs_typeerror(J, \"%s is not callable\", js_typeof(J, -n-1));\n\n\tobj = js_toobject(J, -n-1);\n\n\t/* built-in constructors create their own objects, give them a 'null' this */\n\tif (obj->type == JS_CCFUNCTION && obj->u.c.constructor) {\n\t\tint savebot = BOT;\n\t\tjs_pushnull(J);\n\t\tif (n > 0)\n\t\t\tjs_rot(J, n + 1);\n\t\tBOT = TOP - n - 1;\n\n\t\tjsR_pushtrace(J, obj->u.c.name, \"native\", 0);\n\t\tjsR_callcfunction(J, n, obj->u.c.length, obj->u.c.constructor);\n\t\t--J->tracetop;\n\n\t\tBOT = savebot;\n\t\treturn;\n\t}\n\n\t/* extract the function object's prototype property */\n\tjs_getproperty(J, -n - 1, \"prototype\");\n\tif (js_isobject(J, -1))\n\t\tprototype = js_toobject(J, -1);\n\telse\n\t\tprototype = J->Object_prototype;\n\tjs_pop(J, 1);\n\n\t/* create a new object with above prototype, and shift it into the 'this' slot */\n\tnewobj = jsV_newobject(J, JS_COBJECT, prototype);\n\tjs_pushobject(J, newobj);\n\tif (n > 0)\n\t\tjs_rot(J, n + 1);\n\n\t/* call the function */\n\tjs_call(J, n);\n\n\t/* if result is not an object, return the original object we created */\n\tif (!js_isobject(J, -1)) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushobject(J, newobj);\n\t}\n}\n\nvoid js_eval(js_State *J)\n{\n\tif (!js_isstring(J, -1))\n\t\treturn;\n\tjs_loadeval(J, \"(eval)\", js_tostring(J, -1));\n\tjs_rot2pop1(J);\n\tjs_copy(J, 0); /* copy 'this' */\n\tjs_call(J, 0);\n}\n\nint js_pconstruct(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\t/* clean up the stack to only hold the error object */\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_construct(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}\n\nint js_pcall(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\t/* clean up the stack to only hold the error object */\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_call(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}\n\n/* Exceptions */\n\nvoid *js_savetrypc(js_State *J, js_Instruction *pc)\n{\n\tif (J->trytop == JS_TRYLIMIT)\n\t\tjs_error(J, \"try: exception stack overflow\");\n\tJ->trybuf[J->trytop].E = J->E;\n\tJ->trybuf[J->trytop].envtop = J->envtop;\n\tJ->trybuf[J->trytop].tracetop = J->tracetop;\n\tJ->trybuf[J->trytop].top = J->top;\n\tJ->trybuf[J->trytop].bot = J->bot;\n\tJ->trybuf[J->trytop].strict = J->strict;\n\tJ->trybuf[J->trytop].pc = pc;\n\treturn J->trybuf[J->trytop++].buf;\n}\n\nvoid *js_savetry(js_State *J)\n{\n\tif (J->trytop == JS_TRYLIMIT)\n\t\tjs_error(J, \"try: exception stack overflow\");\n\tJ->trybuf[J->trytop].E = J->E;\n\tJ->trybuf[J->trytop].envtop = J->envtop;\n\tJ->trybuf[J->trytop].tracetop = J->tracetop;\n\tJ->trybuf[J->trytop].top = J->top;\n\tJ->trybuf[J->trytop].bot = J->bot;\n\tJ->trybuf[J->trytop].strict = J->strict;\n\tJ->trybuf[J->trytop].pc = NULL;\n\treturn J->trybuf[J->trytop++].buf;\n}\n\nvoid js_endtry(js_State *J)\n{\n\tif (J->trytop == 0)\n\t\tjs_error(J, \"endtry: exception stack underflow\");\n\t--J->trytop;\n}\n\nvoid js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tJ->strict = J->trybuf[J->trytop].strict;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}\n\n/* Main interpreter loop */\n\nstatic void jsR_dumpstack(js_State *J)\n{\n\tint i;\n\tprintf(\"stack {\\n\");\n\tfor (i = 0; i < TOP; ++i) {\n\t\tputchar(i == BOT ? '>' : ' ');\n\t\tprintf(\"%4d: \", i);\n\t\tjs_dumpvalue(J, STACK[i]);\n\t\tputchar('\\n');\n\t}\n\tprintf(\"}\\n\");\n}\n\nstatic void jsR_dumpenvironment(js_State *J, js_Environment *E, int d)\n{\n\tprintf(\"scope %d \", d);\n\tjs_dumpobject(J, E->variables);\n\tif (E->outer)\n\t\tjsR_dumpenvironment(J, E->outer, d+1);\n}\n\nvoid js_stacktrace(js_State *J)\n{\n\tint n;\n\tprintf(\"stack trace:\\n\");\n\tfor (n = J->tracetop; n >= 0; --n) {\n\t\tconst char *name = J->trace[n].name;\n\t\tconst char *file = J->trace[n].file;\n\t\tint line = J->trace[n].line;\n\t\tif (line > 0) {\n\t\t\tif (name[0])\n\t\t\t\tprintf(\"\\tat %s (%s:%d)\\n\", name, file, line);\n\t\t\telse\n\t\t\t\tprintf(\"\\tat %s:%d\\n\", file, line);\n\t\t} else\n\t\t\tprintf(\"\\tat %s (%s)\\n\", name, file);\n\t}\n}\n\nvoid js_trap(js_State *J, int pc)\n{\n\tif (pc > 0) {\n\t\tjs_Function *F = STACK[BOT-1].u.object->u.f.function;\n\t\tprintf(\"trap at %d in function \", pc);\n\t\tjsC_dumpfunction(J, F);\n\t}\n\tjsR_dumpstack(J);\n\tjsR_dumpenvironment(J, J->E, 0);\n\tjs_stacktrace(J);\n}\n\nstatic void jsR_run(js_State *J, js_Function *F)\n{\n\tjs_Function **FT = F->funtab;\n\tconst char **VT = F->vartab-1;\n\tint lightweight = F->lightweight;\n\tjs_Instruction *pcstart = F->code;\n\tjs_Instruction *pc = F->code;\n\tenum js_OpCode opcode;\n\tint offset;\n\tint savestrict;\n\n\tconst char *str;\n\tjs_Object *obj;\n\tdouble x, y;\n\tunsigned int ux, uy;\n\tint ix, iy, okay;\n\tint b;\n\tint transient;\n\n\tsavestrict = J->strict;\n\tJ->strict = F->strict;\n\n#define READSTRING() \\\n\tmemcpy(&str, pc, sizeof(str)); \\\n\tpc += sizeof(str) / sizeof(*pc)\n\n\twhile (1) {\n\t\tif (J->gccounter > J->gcthresh)\n\t\t\tjs_gc(J, 0);\n\n\t\tJ->trace[J->tracetop].line = *pc++;\n\n\t\topcode = *pc++;\n\n\t\tswitch (opcode) {\n\t\tcase OP_POP: js_pop(J, 1); break;\n\t\tcase OP_DUP: js_dup(J); break;\n\t\tcase OP_DUP2: js_dup2(J); break;\n\t\tcase OP_ROT2: js_rot2(J); break;\n\t\tcase OP_ROT3: js_rot3(J); break;\n\t\tcase OP_ROT4: js_rot4(J); break;\n\n\t\tcase OP_INTEGER:\n\t\t\tjs_pushnumber(J, *pc++ - 32768);\n\t\t\tbreak;\n\n\t\tcase OP_NUMBER:\n\t\t\tmemcpy(&x, pc, sizeof(x));\n\t\t\tpc += sizeof(x) / sizeof(*pc);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_STRING:\n\t\t\tREADSTRING();\n\t\t\tjs_pushliteral(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_CLOSURE: js_newfunction(J, FT[*pc++], J->E); break;\n\t\tcase OP_NEWOBJECT: js_newobject(J); break;\n\t\tcase OP_NEWARRAY: js_newarray(J); break;\n\t\tcase OP_NEWREGEXP:\n\t\t\tREADSTRING();\n\t\t\tjs_newregexp(J, str, *pc++);\n\t\t\tbreak;\n\n\t\tcase OP_UNDEF: js_pushundefined(J); break;\n\t\tcase OP_NULL: js_pushnull(J); break;\n\t\tcase OP_TRUE: js_pushboolean(J, 1); break;\n\t\tcase OP_FALSE: js_pushboolean(J, 0); break;\n\n\t\tcase OP_THIS:\n\t\t\tif (J->strict) {\n\t\t\t\tjs_copy(J, 0);\n\t\t\t} else {\n\t\t\t\tif (js_iscoercible(J, 0))\n\t\t\t\t\tjs_copy(J, 0);\n\t\t\t\telse\n\t\t\t\t\tjs_pushglobal(J);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_CURRENT:\n\t\t\tjs_currentfunction(J);\n\t\t\tbreak;\n\n\t\tcase OP_GETLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\tCHECKSTACK(1);\n\t\t\t\tSTACK[TOP++] = STACK[BOT + *pc++];\n\t\t\t} else {\n\t\t\t\tstr = VT[*pc++];\n\t\t\t\tif (!js_hasvar(J, str))\n\t\t\t\t\tjs_referenceerror(J, \"'%s' is not defined\", str);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_SETLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\tSTACK[BOT + *pc++] = STACK[TOP-1];\n\t\t\t} else {\n\t\t\t\tjs_setvar(J, VT[*pc++]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_DELLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\t++pc;\n\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t} else {\n\t\t\t\tb = js_delvar(J, VT[*pc++]);\n\t\t\t\tjs_pushboolean(J, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_GETVAR:\n\t\t\tREADSTRING();\n\t\t\tif (!js_hasvar(J, str))\n\t\t\t\tjs_referenceerror(J, \"'%s' is not defined\", str);\n\t\t\tbreak;\n\n\t\tcase OP_HASVAR:\n\t\t\tREADSTRING();\n\t\t\tif (!js_hasvar(J, str))\n\t\t\t\tjs_pushundefined(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETVAR:\n\t\t\tREADSTRING();\n\t\t\tjs_setvar(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_DELVAR:\n\t\t\tREADSTRING();\n\t\t\tb = js_delvar(J, str);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_IN:\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tif (!js_isobject(J, -1))\n\t\t\t\tjs_typeerror(J, \"operand to 'in' is not an object\");\n\t\t\tb = js_hasproperty(J, -1, str);\n\t\t\tjs_pop(J, 2 + b);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_INITARRAY:\n\t\t\tjs_setindex(J, -2, js_getlength(J, -2));\n\t\t\tbreak;\n\n\t\tcase OP_INITPROP:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_setproperty(J, obj, str, 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_INITGETTER:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_defproperty(J, obj, str, 0, NULL, jsR_tofunction(J, -1), NULL, 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_INITSETTER:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_defproperty(J, obj, str, 0, NULL, NULL, jsR_tofunction(J, -1), 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_GETPROP:\n\t\t\tstr = js_tostring(J, -1);\n\t\t\tobj = js_toobject(J, -2);\n\t\t\tjsR_getproperty(J, obj, str);\n\t\t\tjs_rot3pop2(J);\n\t\t\tbreak;\n\n\t\tcase OP_GETPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tjsR_getproperty(J, obj, str);\n\t\t\tjs_rot2pop1(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETPROP:\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tobj = js_toobject(J, -3);\n\t\t\ttransient = !js_isobject(J, -3);\n\t\t\tjsR_setproperty(J, obj, str, transient);\n\t\t\tjs_rot3pop2(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -2);\n\t\t\ttransient = !js_isobject(J, -2);\n\t\t\tjsR_setproperty(J, obj, str, transient);\n\t\t\tjs_rot2pop1(J);\n\t\t\tbreak;\n\n\t\tcase OP_DELPROP:\n\t\t\tstr = js_tostring(J, -1);\n\t\t\tobj = js_toobject(J, -2);\n\t\t\tb = jsR_delproperty(J, obj, str);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_DELPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tb = jsR_delproperty(J, obj, str);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_ITERATOR:\n\t\t\tif (js_iscoercible(J, -1)) {\n\t\t\t\tobj = jsV_newiterator(J, js_toobject(J, -1), 0);\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\tjs_pushobject(J, obj);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_NEXTITER:\n\t\t\tif (js_isobject(J, -1)) {\n\t\t\t\tobj = js_toobject(J, -1);\n\t\t\t\tstr = jsV_nextiterator(J, obj);\n\t\t\t\tif (str) {\n\t\t\t\t\tjs_pushliteral(J, str);\n\t\t\t\t\tjs_pushboolean(J, 1);\n\t\t\t\t} else {\n\t\t\t\t\tjs_pop(J, 1);\n\t\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* Function calls */\n\n\t\tcase OP_EVAL:\n\t\t\tjs_eval(J);\n\t\t\tbreak;\n\n\t\tcase OP_CALL:\n\t\t\tjs_call(J, *pc++);\n\t\t\tbreak;\n\n\t\tcase OP_NEW:\n\t\t\tjs_construct(J, *pc++);\n\t\t\tbreak;\n\n\t\t/* Unary operators */\n\n\t\tcase OP_TYPEOF:\n\t\t\tstr = js_typeof(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushliteral(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_POS:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_NEG:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, -x);\n\t\t\tbreak;\n\n\t\tcase OP_BITNOT:\n\t\t\tix = js_toint32(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, ~ix);\n\t\t\tbreak;\n\n\t\tcase OP_LOGNOT:\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushboolean(J, !b);\n\t\t\tbreak;\n\n\t\tcase OP_INC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x + 1);\n\t\t\tbreak;\n\n\t\tcase OP_DEC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x - 1);\n\t\t\tbreak;\n\n\t\tcase OP_POSTINC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x + 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_POSTDEC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x - 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\t/* Multiplicative operators */\n\n\t\tcase OP_MUL:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x * y);\n\t\t\tbreak;\n\n\t\tcase OP_DIV:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x / y);\n\t\t\tbreak;\n\n\t\tcase OP_MOD:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, fmod(x, y));\n\t\t\tbreak;\n\n\t\t/* Additive operators */\n\n\t\tcase OP_ADD:\n\t\t\tjs_concat(J);\n\t\t\tbreak;\n\n\t\tcase OP_SUB:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x - y);\n\t\t\tbreak;\n\n\t\t/* Shift operators */\n\n\t\tcase OP_SHL:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix << (uy & 0x1F));\n\t\t\tbreak;\n\n\t\tcase OP_SHR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix >> (uy & 0x1F));\n\t\t\tbreak;\n\n\t\tcase OP_USHR:\n\t\t\tux = js_touint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ux >> (uy & 0x1F));\n\t\t\tbreak;\n\n\t\t/* Relational operators */\n\n\t\tcase OP_LT: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b < 0); break;\n\t\tcase OP_GT: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b > 0); break;\n\t\tcase OP_LE: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b <= 0); break;\n\t\tcase OP_GE: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b >= 0); break;\n\n\t\tcase OP_INSTANCEOF:\n\t\t\tb = js_instanceof(J);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\t/* Equality */\n\n\t\tcase OP_EQ: b = js_equal(J); js_pop(J, 2); js_pushboolean(J, b); break;\n\t\tcase OP_NE: b = js_equal(J); js_pop(J, 2); js_pushboolean(J, !b); break;\n\t\tcase OP_STRICTEQ: b = js_strictequal(J); js_pop(J, 2); js_pushboolean(J, b); break;\n\t\tcase OP_STRICTNE: b = js_strictequal(J); js_pop(J, 2); js_pushboolean(J, !b); break;\n\n\t\tcase OP_JCASE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_strictequal(J);\n\t\t\tif (b) {\n\t\t\t\tjs_pop(J, 2);\n\t\t\t\tpc = pcstart + offset;\n\t\t\t} else {\n\t\t\t\tjs_pop(J, 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* Binary bitwise operators */\n\n\t\tcase OP_BITAND:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix & iy);\n\t\t\tbreak;\n\n\t\tcase OP_BITXOR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix ^ iy);\n\t\t\tbreak;\n\n\t\tcase OP_BITOR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix | iy);\n\t\t\tbreak;\n\n\t\t/* Try and Catch */\n\n\t\tcase OP_THROW:\n\t\t\tjs_throw(J);\n\n\t\tcase OP_TRY:\n\t\t\toffset = *pc++;\n\t\t\tif (js_trypc(J, pc)) {\n\t\t\t\tpc = J->trybuf[J->trytop].pc;\n\t\t\t} else {\n\t\t\t\tpc = pcstart + offset;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_ENDTRY:\n\t\t\tjs_endtry(J);\n\t\t\tbreak;\n\n\t\tcase OP_CATCH:\n\t\t\tREADSTRING();\n\t\t\tobj = jsV_newobject(J, JS_COBJECT, NULL);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_rot2(J);\n\t\t\tjs_setproperty(J, -2, str);\n\t\t\tJ->E = jsR_newenvironment(J, obj, J->E);\n\t\t\tjs_pop(J, 1);\n\t\t\tbreak;\n\n\t\tcase OP_ENDCATCH:\n\t\t\tJ->E = J->E->outer;\n\t\t\tbreak;\n\n\t\t/* With */\n\n\t\tcase OP_WITH:\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tJ->E = jsR_newenvironment(J, obj, J->E);\n\t\t\tjs_pop(J, 1);\n\t\t\tbreak;\n\n\t\tcase OP_ENDWITH:\n\t\t\tJ->E = J->E->outer;\n\t\t\tbreak;\n\n\t\t/* Branching */\n\n\t\tcase OP_DEBUGGER:\n\t\t\tjs_trap(J, (int)(pc - pcstart) - 1);\n\t\t\tbreak;\n\n\t\tcase OP_JUMP:\n\t\t\tpc = pcstart + *pc;\n\t\t\tbreak;\n\n\t\tcase OP_JTRUE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tif (b)\n\t\t\t\tpc = pcstart + offset;\n\t\t\tbreak;\n\n\t\tcase OP_JFALSE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tif (!b)\n\t\t\t\tpc = pcstart + offset;\n\t\t\tbreak;\n\n\t\tcase OP_RETURN:\n\t\t\tJ->strict = savestrict;\n\t\t\treturn;\n\t\t}\n\t}\n}\n"], "fixing_code": ["#include \"jsi.h\"\n#include \"jscompile.h\"\n#include \"jsvalue.h\"\n#include \"jsrun.h\"\n\n#include \"utf.h\"\n\nstatic void jsR_run(js_State *J, js_Function *F);\n\n/* Push values on stack */\n\n#define STACK (J->stack)\n#define TOP (J->top)\n#define BOT (J->bot)\n\nstatic void js_stackoverflow(js_State *J)\n{\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = \"stack overflow\";\n\t++TOP;\n\tjs_throw(J);\n}\n\nstatic void js_outofmemory(js_State *J)\n{\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = \"out of memory\";\n\t++TOP;\n\tjs_throw(J);\n}\n\nvoid *js_malloc(js_State *J, int size)\n{\n\tvoid *ptr = J->alloc(J->actx, NULL, size);\n\tif (!ptr)\n\t\tjs_outofmemory(J);\n\treturn ptr;\n}\n\nvoid *js_realloc(js_State *J, void *ptr, int size)\n{\n\tptr = J->alloc(J->actx, ptr, size);\n\tif (!ptr)\n\t\tjs_outofmemory(J);\n\treturn ptr;\n}\n\nchar *js_strdup(js_State *J, const char *s)\n{\n\tint n = strlen(s) + 1;\n\tchar *p = js_malloc(J, n);\n\tmemcpy(p, s, n);\n\treturn p;\n}\n\nvoid js_free(js_State *J, void *ptr)\n{\n\tJ->alloc(J->actx, ptr, 0);\n}\n\njs_String *jsV_newmemstring(js_State *J, const char *s, int n)\n{\n\tjs_String *v = js_malloc(J, soffsetof(js_String, p) + n + 1);\n\tmemcpy(v->p, s, n);\n\tv->p[n] = 0;\n\tv->gcmark = 0;\n\tv->gcnext = J->gcstr;\n\tJ->gcstr = v;\n\t++J->gccounter;\n\treturn v;\n}\n\n#define CHECKSTACK(n) if (TOP + n >= JS_STACKSIZE) js_stackoverflow(J)\n\nvoid js_pushvalue(js_State *J, js_Value v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = v;\n\t++TOP;\n}\n\nvoid js_pushundefined(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TUNDEFINED;\n\t++TOP;\n}\n\nvoid js_pushnull(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TNULL;\n\t++TOP;\n}\n\nvoid js_pushboolean(js_State *J, int v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TBOOLEAN;\n\tSTACK[TOP].u.boolean = !!v;\n\t++TOP;\n}\n\nvoid js_pushnumber(js_State *J, double v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TNUMBER;\n\tSTACK[TOP].u.number = v;\n\t++TOP;\n}\n\nvoid js_pushstring(js_State *J, const char *v)\n{\n\tint n = strlen(v);\n\tCHECKSTACK(1);\n\tif (n <= soffsetof(js_Value, type)) {\n\t\tchar *s = STACK[TOP].u.shrstr;\n\t\twhile (n--) *s++ = *v++;\n\t\t*s = 0;\n\t\tSTACK[TOP].type = JS_TSHRSTR;\n\t} else {\n\t\tSTACK[TOP].type = JS_TMEMSTR;\n\t\tSTACK[TOP].u.memstr = jsV_newmemstring(J, v, n);\n\t}\n\t++TOP;\n}\n\nvoid js_pushlstring(js_State *J, const char *v, int n)\n{\n\tCHECKSTACK(1);\n\tif (n <= soffsetof(js_Value, type)) {\n\t\tchar *s = STACK[TOP].u.shrstr;\n\t\twhile (n--) *s++ = *v++;\n\t\t*s = 0;\n\t\tSTACK[TOP].type = JS_TSHRSTR;\n\t} else {\n\t\tSTACK[TOP].type = JS_TMEMSTR;\n\t\tSTACK[TOP].u.memstr = jsV_newmemstring(J, v, n);\n\t}\n\t++TOP;\n}\n\nvoid js_pushliteral(js_State *J, const char *v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = v;\n\t++TOP;\n}\n\nvoid js_pushobject(js_State *J, js_Object *v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TOBJECT;\n\tSTACK[TOP].u.object = v;\n\t++TOP;\n}\n\nvoid js_pushglobal(js_State *J)\n{\n\tjs_pushobject(J, J->G);\n}\n\nvoid js_currentfunction(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[BOT-1];\n\t++TOP;\n}\n\n/* Read values from stack */\n\nstatic js_Value *stackidx(js_State *J, int idx)\n{\n\tstatic js_Value undefined = { {0}, {0}, JS_TUNDEFINED };\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < 0 || idx >= TOP)\n\t\treturn &undefined;\n\treturn STACK + idx;\n}\n\njs_Value *js_tovalue(js_State *J, int idx)\n{\n\treturn stackidx(J, idx);\n}\n\nint js_isdefined(js_State *J, int idx) { return stackidx(J, idx)->type != JS_TUNDEFINED; }\nint js_isundefined(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TUNDEFINED; }\nint js_isnull(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TNULL; }\nint js_isboolean(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TBOOLEAN; }\nint js_isnumber(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TNUMBER; }\nint js_isstring(js_State *J, int idx) { enum js_Type t = stackidx(J, idx)->type; return t == JS_TSHRSTR || t == JS_TLITSTR || t == JS_TMEMSTR; }\nint js_isprimitive(js_State *J, int idx) { return stackidx(J, idx)->type != JS_TOBJECT; }\nint js_isobject(js_State *J, int idx) { return stackidx(J, idx)->type == JS_TOBJECT; }\nint js_iscoercible(js_State *J, int idx) { js_Value *v = stackidx(J, idx); return v->type != JS_TUNDEFINED && v->type != JS_TNULL; }\n\nint js_iscallable(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT)\n\t\treturn v->u.object->type == JS_CFUNCTION ||\n\t\t\tv->u.object->type == JS_CSCRIPT ||\n\t\t\tv->u.object->type == JS_CCFUNCTION;\n\treturn 0;\n}\n\nint js_isarray(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CARRAY;\n}\n\nint js_isregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP;\n}\n\nint js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}\n\nint js_iserror(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CERROR;\n}\n\nconst char *js_typeof(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tswitch (v->type) {\n\tdefault:\n\tcase JS_TSHRSTR: return \"string\";\n\tcase JS_TUNDEFINED: return \"undefined\";\n\tcase JS_TNULL: return \"object\";\n\tcase JS_TBOOLEAN: return \"boolean\";\n\tcase JS_TNUMBER: return \"number\";\n\tcase JS_TLITSTR: return \"string\";\n\tcase JS_TMEMSTR: return \"string\";\n\tcase JS_TOBJECT:\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn \"function\";\n\t\treturn \"object\";\n\t}\n}\n\nint js_type(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tswitch (v->type) {\n\tdefault:\n\tcase JS_TSHRSTR: return JS_ISSTRING;\n\tcase JS_TUNDEFINED: return JS_ISUNDEFINED;\n\tcase JS_TNULL: return JS_ISNULL;\n\tcase JS_TBOOLEAN: return JS_ISBOOLEAN;\n\tcase JS_TNUMBER: return JS_ISNUMBER;\n\tcase JS_TLITSTR: return JS_ISSTRING;\n\tcase JS_TMEMSTR: return JS_ISSTRING;\n\tcase JS_TOBJECT:\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn JS_ISFUNCTION;\n\t\treturn JS_ISOBJECT;\n\t}\n}\n\nint js_toboolean(js_State *J, int idx)\n{\n\treturn jsV_toboolean(J, stackidx(J, idx));\n}\n\ndouble js_tonumber(js_State *J, int idx)\n{\n\treturn jsV_tonumber(J, stackidx(J, idx));\n}\n\nint js_tointeger(js_State *J, int idx)\n{\n\treturn jsV_numbertointeger(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nint js_toint32(js_State *J, int idx)\n{\n\treturn jsV_numbertoint32(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nunsigned int js_touint32(js_State *J, int idx)\n{\n\treturn jsV_numbertouint32(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nshort js_toint16(js_State *J, int idx)\n{\n\treturn jsV_numbertoint16(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nunsigned short js_touint16(js_State *J, int idx)\n{\n\treturn jsV_numbertouint16(jsV_tonumber(J, stackidx(J, idx)));\n}\n\nconst char *js_tostring(js_State *J, int idx)\n{\n\treturn jsV_tostring(J, stackidx(J, idx));\n}\n\njs_Object *js_toobject(js_State *J, int idx)\n{\n\treturn jsV_toobject(J, stackidx(J, idx));\n}\n\nvoid js_toprimitive(js_State *J, int idx, int hint)\n{\n\tjsV_toprimitive(J, stackidx(J, idx), hint);\n}\n\njs_Regexp *js_toregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP)\n\t\treturn &v->u.object->u.r;\n\tjs_typeerror(J, \"not a regexp\");\n}\n\nvoid *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}\n\nstatic js_Object *jsR_tofunction(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TUNDEFINED || v->type == JS_TNULL)\n\t\treturn NULL;\n\tif (v->type == JS_TOBJECT)\n\t\tif (v->u.object->type == JS_CFUNCTION || v->u.object->type == JS_CCFUNCTION)\n\t\t\treturn v->u.object;\n\tjs_typeerror(J, \"not a function\");\n}\n\n/* Stack manipulation */\n\nint js_gettop(js_State *J)\n{\n\treturn TOP - BOT;\n}\n\nvoid js_pop(js_State *J, int n)\n{\n\tTOP -= n;\n\tif (TOP < BOT) {\n\t\tTOP = BOT;\n\t\tjs_error(J, \"stack underflow!\");\n\t}\n}\n\nvoid js_remove(js_State *J, int idx)\n{\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < BOT || idx >= TOP)\n\t\tjs_error(J, \"stack error!\");\n\tfor (;idx < TOP - 1; ++idx)\n\t\tSTACK[idx] = STACK[idx+1];\n\t--TOP;\n}\n\nvoid js_insert(js_State *J, int idx)\n{\n\tjs_error(J, \"not implemented yet\");\n}\n\nvoid js_replace(js_State* J, int idx)\n{\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < BOT || idx >= TOP)\n\t\tjs_error(J, \"stack error!\");\n\tSTACK[idx] = STACK[--TOP];\n}\n\nvoid js_copy(js_State *J, int idx)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = *stackidx(J, idx);\n\t++TOP;\n}\n\nvoid js_dup(js_State *J)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP] = STACK[TOP-1];\n\t++TOP;\n}\n\nvoid js_dup2(js_State *J)\n{\n\tCHECKSTACK(2);\n\tSTACK[TOP] = STACK[TOP-2];\n\tSTACK[TOP+1] = STACK[TOP-1];\n\tTOP += 2;\n}\n\nvoid js_rot2(js_State *J)\n{\n\t/* A B -> B A */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B (B) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A A */\n\tSTACK[TOP-2] = tmp;\t\t/* B A */\n}\n\nvoid js_rot3(js_State *J)\n{\n\t/* A B C -> C A B */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B C (C) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A B B */\n\tSTACK[TOP-2] = STACK[TOP-3];\t/* A A B */\n\tSTACK[TOP-3] = tmp;\t\t/* C A B */\n}\n\nvoid js_rot4(js_State *J)\n{\n\t/* A B C D -> D A B C */\n\tjs_Value tmp = STACK[TOP-1];\t/* A B C D (D) */\n\tSTACK[TOP-1] = STACK[TOP-2];\t/* A B C C */\n\tSTACK[TOP-2] = STACK[TOP-3];\t/* A B B C */\n\tSTACK[TOP-3] = STACK[TOP-4];\t/* A A B C */\n\tSTACK[TOP-4] = tmp;\t\t/* D A B C */\n}\n\nvoid js_rot2pop1(js_State *J)\n{\n\t/* A B -> B */\n\tSTACK[TOP-2] = STACK[TOP-1];\n\t--TOP;\n}\n\nvoid js_rot3pop2(js_State *J)\n{\n\t/* A B C -> C */\n\tSTACK[TOP-3] = STACK[TOP-1];\n\tTOP -= 2;\n}\n\nvoid js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}\n\n/* Property access that takes care of attributes and getters/setters */\n\nint js_isarrayindex(js_State *J, const char *p, int *idx)\n{\n\tint n = 0;\n\n\t/* check for empty string */\n\tif (p[0] == 0)\n\t\treturn 0;\n\n\t/* check for '0' and integers with leading zero */\n\tif (p[0] == '0')\n\t\treturn (p[1] == 0) ? *idx = 0, 1 : 0;\n\n\twhile (*p) {\n\t\tint c = *p++;\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tif (n >= INT_MAX / 10)\n\t\t\t\treturn 0;\n\t\t\tn = n * 10 + (c - '0');\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn *idx = n, 1;\n}\n\nstatic void js_pushrune(js_State *J, Rune rune)\n{\n\tchar buf[UTFmax + 1];\n\tif (rune >= 0) {\n\t\tbuf[runetochar(buf, &rune)] = 0;\n\t\tjs_pushstring(J, buf);\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n}\n\nstatic int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushstring(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void jsR_getproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tif (!jsR_hasproperty(J, obj, name))\n\t\tjs_pushundefined(J);\n}\n\nstatic void jsR_setproperty(js_State *J, js_Object *obj, const char *name, int transient)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen || newlen < 0)\n\t\t\t\tjs_rangeerror(J, \"invalid array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\n\t/* First try to find a setter in prototype chain */\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref) {\n\t\tif (ref->setter) {\n\t\t\tjs_pushobject(J, ref->setter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_pushvalue(J, *value);\n\t\t\tjs_call(J, 1);\n\t\t\tjs_pop(J, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (J->strict)\n\t\t\t\tif (ref->getter)\n\t\t\t\t\tjs_typeerror(J, \"setting property '%s' that only has a getter\", name);\n\t\t\tif (ref->atts & JS_READONLY)\n\t\t\t\tgoto readonly;\n\t\t}\n\t}\n\n\t/* Property not found on this object, so create one */\n\tif (!ref || !own) {\n\t\tif (transient) {\n\t\t\tif (J->strict)\n\t\t\t\tjs_typeerror(J, \"cannot create property '%s' on transient object\", name);\n\t\t\treturn;\n\t\t}\n\t\tref = jsV_setproperty(J, obj, name);\n\t}\n\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\n\treturn;\n\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}\n\nstatic void jsR_defproperty(js_State *J, js_Object *obj, const char *name,\n\tint atts, js_Value *value, js_Object *getter, js_Object *setter,\n\tint throw)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) goto readonly;\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\n\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (value) {\n\t\t\tif (!(ref->atts & JS_READONLY))\n\t\t\t\tref->value = *value;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n\t\t}\n\t\tif (getter) {\n\t\t\tif (!(ref->atts & JS_DONTCONF))\n\t\t\t\tref->getter = getter;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t}\n\t\tif (setter) {\n\t\t\tif (!(ref->atts & JS_DONTCONF))\n\t\t\t\tref->setter = setter;\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t}\n\t\tref->atts |= atts;\n\t}\n\n\treturn;\n\nreadonly:\n\tif (J->strict || throw)\n\t\tjs_typeerror(J, \"'%s' is read-only or non-configurable\", name);\n}\n\nstatic int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= 0 && k < obj->u.s.length)\n\t\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\n\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}\n\n/* Registry, global and object property accessors */\n\nconst char *js_ref(js_State *J)\n{\n\tjs_Value *v = stackidx(J, -1);\n\tconst char *s;\n\tchar buf[32];\n\tswitch (v->type) {\n\tcase JS_TUNDEFINED: s = \"_Undefined\"; break;\n\tcase JS_TNULL: s = \"_Null\"; break;\n\tcase JS_TBOOLEAN:\n\t\ts = v->u.boolean ? \"_True\" : \"_False\";\n\t\tbreak;\n\tcase JS_TOBJECT:\n\t\tsprintf(buf, \"%p\", (void*)v->u.object);\n\t\ts = js_intern(J, buf);\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf, \"%d\", J->nextref++);\n\t\ts = js_intern(J, buf);\n\t\tbreak;\n\t}\n\tjs_setregistry(J, s);\n\treturn s;\n}\n\nvoid js_unref(js_State *J, const char *ref)\n{\n\tjs_delregistry(J, ref);\n}\n\nvoid js_getregistry(js_State *J, const char *name)\n{\n\tjsR_getproperty(J, J->R, name);\n}\n\nvoid js_setregistry(js_State *J, const char *name)\n{\n\tjsR_setproperty(J, J->R, name, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_delregistry(js_State *J, const char *name)\n{\n\tjsR_delproperty(J, J->R, name);\n}\n\nvoid js_getglobal(js_State *J, const char *name)\n{\n\tjsR_getproperty(J, J->G, name);\n}\n\nvoid js_setglobal(js_State *J, const char *name)\n{\n\tjsR_setproperty(J, J->G, name, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_defglobal(js_State *J, const char *name, int atts)\n{\n\tjsR_defproperty(J, J->G, name, atts, stackidx(J, -1), NULL, NULL, 0);\n\tjs_pop(J, 1);\n}\n\nvoid js_delglobal(js_State *J, const char *name)\n{\n\tjsR_delproperty(J, J->G, name);\n}\n\nvoid js_getproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_getproperty(J, js_toobject(J, idx), name);\n}\n\nvoid js_setproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_setproperty(J, js_toobject(J, idx), name, !js_isobject(J, idx));\n\tjs_pop(J, 1);\n}\n\nvoid js_defproperty(js_State *J, int idx, const char *name, int atts)\n{\n\tjsR_defproperty(J, js_toobject(J, idx), name, atts, stackidx(J, -1), NULL, NULL, 1);\n\tjs_pop(J, 1);\n}\n\nvoid js_delproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_delproperty(J, js_toobject(J, idx), name);\n}\n\nvoid js_defaccessor(js_State *J, int idx, const char *name, int atts)\n{\n\tjsR_defproperty(J, js_toobject(J, idx), name, atts, NULL, jsR_tofunction(J, -2), jsR_tofunction(J, -1), 1);\n\tjs_pop(J, 2);\n}\n\nint js_hasproperty(js_State *J, int idx, const char *name)\n{\n\treturn jsR_hasproperty(J, js_toobject(J, idx), name);\n}\n\n/* Iterator */\n\nvoid js_pushiterator(js_State *J, int idx, int own)\n{\n\tjs_pushobject(J, jsV_newiterator(J, js_toobject(J, idx), own));\n}\n\nconst char *js_nextiterator(js_State *J, int idx)\n{\n\treturn jsV_nextiterator(J, js_toobject(J, idx));\n}\n\n/* Environment records */\n\njs_Environment *jsR_newenvironment(js_State *J, js_Object *vars, js_Environment *outer)\n{\n\tjs_Environment *E = js_malloc(J, sizeof *E);\n\tE->gcmark = 0;\n\tE->gcnext = J->gcenv;\n\tJ->gcenv = E;\n\t++J->gccounter;\n\n\tE->outer = outer;\n\tE->variables = vars;\n\treturn E;\n}\n\nstatic void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL, 0);\n}\n\nstatic int js_hasvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->getter) {\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\t\tjs_pushobject(J, E->variables);\n\t\t\t\tjs_call(J, 0);\n\t\t\t} else {\n\t\t\t\tjs_pushvalue(J, ref->value);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\treturn 0;\n}\n\nstatic void js_setvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->setter) {\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\t\tjs_pushobject(J, E->variables);\n\t\t\t\tjs_copy(J, -3);\n\t\t\t\tjs_call(J, 1);\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ref->atts & JS_READONLY))\n\t\t\t\tref->value = *stackidx(J, -1);\n\t\t\telse if (J->strict)\n\t\t\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n\t\t\treturn;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\tif (J->strict)\n\t\tjs_referenceerror(J, \"assignment to undeclared variable '%s'\", name);\n\tjsR_setproperty(J, J->G, name, 0);\n}\n\nstatic int js_delvar(js_State *J, const char *name)\n{\n\tjs_Environment *E = J->E;\n\tdo {\n\t\tjs_Property *ref = jsV_getownproperty(J, E->variables, name);\n\t\tif (ref) {\n\t\t\tif (ref->atts & JS_DONTCONF) {\n\t\t\t\tif (J->strict)\n\t\t\t\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjsV_delproperty(J, E->variables, name);\n\t\t\treturn 1;\n\t\t}\n\t\tE = E->outer;\n\t} while (E);\n\treturn jsR_delproperty(J, J->G, name);\n}\n\n/* Function calls */\n\nstatic void jsR_savescope(js_State *J, js_Environment *newE)\n{\n\tif (J->envtop + 1 >= JS_ENVLIMIT)\n\t\tjs_stackoverflow(J);\n\tJ->envstack[J->envtop++] = J->E;\n\tJ->E = newE;\n}\n\nstatic void jsR_restorescope(js_State *J)\n{\n\tJ->E = J->envstack[--J->envtop];\n}\n\nstatic void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tjsR_savescope(J, scope);\n\n\tif (n > F->numparams) {\n\t\tjs_pop(J, n - F->numparams);\n\t\tn = F->numparams;\n\t}\n\n\tfor (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n\nstatic void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\n\tjsR_savescope(J, scope);\n\n\tif (F->arguments) {\n\t\tjs_newarguments(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\n\tfor (i = 0; i < n && i < F->numparams; ++i)\n\t\tjs_initvar(J, F->vartab[i], i + 1);\n\tjs_pop(J, n);\n\n\tfor (; i < F->varlen; ++i) {\n\t\tjs_pushundefined(J);\n\t\tjs_initvar(J, F->vartab[i], -1);\n\t\tjs_pop(J, 1);\n\t}\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}\n\nstatic void jsR_callscript(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tif (scope)\n\t\tjsR_savescope(J, scope);\n\n\t/* scripts take no arguments */\n\tjs_pop(J, n);\n\n\tfor (i = 0; i < F->varlen; ++i) {\n\t\t/* Bug 701886: don't redefine existing vars in eval/scripts */\n\t\tif (!js_hasvar(J, F->vartab[i])) {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n\n\tif (scope)\n\t\tjsR_restorescope(J);\n}\n\nstatic void jsR_callcfunction(js_State *J, int n, int min, js_CFunction F)\n{\n\tint i;\n\tjs_Value v;\n\n\tfor (i = n; i < min; ++i)\n\t\tjs_pushundefined(J);\n\n\tF(J);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; /* clear stack */\n\tjs_pushvalue(J, v);\n}\n\nstatic void jsR_pushtrace(js_State *J, const char *name, const char *file, int line)\n{\n\tif (J->tracetop + 1 == JS_ENVLIMIT)\n\t\tjs_error(J, \"call stack overflow\");\n\t++J->tracetop;\n\tJ->trace[J->tracetop].name = name;\n\tJ->trace[J->tracetop].file = file;\n\tJ->trace[J->tracetop].line = line;\n}\n\nvoid js_call(js_State *J, int n)\n{\n\tjs_Object *obj;\n\tint savebot;\n\n\tif (!js_iscallable(J, -n-2))\n\t\tjs_typeerror(J, \"%s is not callable\", js_typeof(J, -n-2));\n\n\tobj = js_toobject(J, -n-2);\n\n\tsavebot = BOT;\n\tBOT = TOP - n - 1;\n\n\tif (obj->type == JS_CFUNCTION) {\n\t\tjsR_pushtrace(J, obj->u.f.function->name, obj->u.f.function->filename, obj->u.f.function->line);\n\t\tif (obj->u.f.function->lightweight)\n\t\t\tjsR_calllwfunction(J, n, obj->u.f.function, obj->u.f.scope);\n\t\telse\n\t\t\tjsR_callfunction(J, n, obj->u.f.function, obj->u.f.scope);\n\t\t--J->tracetop;\n\t} else if (obj->type == JS_CSCRIPT) {\n\t\tjsR_pushtrace(J, obj->u.f.function->name, obj->u.f.function->filename, obj->u.f.function->line);\n\t\tjsR_callscript(J, n, obj->u.f.function, obj->u.f.scope);\n\t\t--J->tracetop;\n\t} else if (obj->type == JS_CCFUNCTION) {\n\t\tjsR_pushtrace(J, obj->u.c.name, \"native\", 0);\n\t\tjsR_callcfunction(J, n, obj->u.c.length, obj->u.c.function);\n\t\t--J->tracetop;\n\t}\n\n\tBOT = savebot;\n}\n\nvoid js_construct(js_State *J, int n)\n{\n\tjs_Object *obj;\n\tjs_Object *prototype;\n\tjs_Object *newobj;\n\n\tif (!js_iscallable(J, -n-1))\n\t\tjs_typeerror(J, \"%s is not callable\", js_typeof(J, -n-1));\n\n\tobj = js_toobject(J, -n-1);\n\n\t/* built-in constructors create their own objects, give them a 'null' this */\n\tif (obj->type == JS_CCFUNCTION && obj->u.c.constructor) {\n\t\tint savebot = BOT;\n\t\tjs_pushnull(J);\n\t\tif (n > 0)\n\t\t\tjs_rot(J, n + 1);\n\t\tBOT = TOP - n - 1;\n\n\t\tjsR_pushtrace(J, obj->u.c.name, \"native\", 0);\n\t\tjsR_callcfunction(J, n, obj->u.c.length, obj->u.c.constructor);\n\t\t--J->tracetop;\n\n\t\tBOT = savebot;\n\t\treturn;\n\t}\n\n\t/* extract the function object's prototype property */\n\tjs_getproperty(J, -n - 1, \"prototype\");\n\tif (js_isobject(J, -1))\n\t\tprototype = js_toobject(J, -1);\n\telse\n\t\tprototype = J->Object_prototype;\n\tjs_pop(J, 1);\n\n\t/* create a new object with above prototype, and shift it into the 'this' slot */\n\tnewobj = jsV_newobject(J, JS_COBJECT, prototype);\n\tjs_pushobject(J, newobj);\n\tif (n > 0)\n\t\tjs_rot(J, n + 1);\n\n\t/* call the function */\n\tjs_call(J, n);\n\n\t/* if result is not an object, return the original object we created */\n\tif (!js_isobject(J, -1)) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushobject(J, newobj);\n\t}\n}\n\nvoid js_eval(js_State *J)\n{\n\tif (!js_isstring(J, -1))\n\t\treturn;\n\tjs_loadeval(J, \"(eval)\", js_tostring(J, -1));\n\tjs_rot2pop1(J);\n\tjs_copy(J, 0); /* copy 'this' */\n\tjs_call(J, 0);\n}\n\nint js_pconstruct(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\t/* clean up the stack to only hold the error object */\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_construct(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}\n\nint js_pcall(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\t/* clean up the stack to only hold the error object */\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_call(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}\n\n/* Exceptions */\n\nvoid *js_savetrypc(js_State *J, js_Instruction *pc)\n{\n\tif (J->trytop == JS_TRYLIMIT)\n\t\tjs_error(J, \"try: exception stack overflow\");\n\tJ->trybuf[J->trytop].E = J->E;\n\tJ->trybuf[J->trytop].envtop = J->envtop;\n\tJ->trybuf[J->trytop].tracetop = J->tracetop;\n\tJ->trybuf[J->trytop].top = J->top;\n\tJ->trybuf[J->trytop].bot = J->bot;\n\tJ->trybuf[J->trytop].strict = J->strict;\n\tJ->trybuf[J->trytop].pc = pc;\n\treturn J->trybuf[J->trytop++].buf;\n}\n\nvoid *js_savetry(js_State *J)\n{\n\tif (J->trytop == JS_TRYLIMIT)\n\t\tjs_error(J, \"try: exception stack overflow\");\n\tJ->trybuf[J->trytop].E = J->E;\n\tJ->trybuf[J->trytop].envtop = J->envtop;\n\tJ->trybuf[J->trytop].tracetop = J->tracetop;\n\tJ->trybuf[J->trytop].top = J->top;\n\tJ->trybuf[J->trytop].bot = J->bot;\n\tJ->trybuf[J->trytop].strict = J->strict;\n\tJ->trybuf[J->trytop].pc = NULL;\n\treturn J->trybuf[J->trytop++].buf;\n}\n\nvoid js_endtry(js_State *J)\n{\n\tif (J->trytop == 0)\n\t\tjs_error(J, \"endtry: exception stack underflow\");\n\t--J->trytop;\n}\n\nvoid js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tJ->strict = J->trybuf[J->trytop].strict;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}\n\n/* Main interpreter loop */\n\nstatic void jsR_dumpstack(js_State *J)\n{\n\tint i;\n\tprintf(\"stack {\\n\");\n\tfor (i = 0; i < TOP; ++i) {\n\t\tputchar(i == BOT ? '>' : ' ');\n\t\tprintf(\"%4d: \", i);\n\t\tjs_dumpvalue(J, STACK[i]);\n\t\tputchar('\\n');\n\t}\n\tprintf(\"}\\n\");\n}\n\nstatic void jsR_dumpenvironment(js_State *J, js_Environment *E, int d)\n{\n\tprintf(\"scope %d \", d);\n\tjs_dumpobject(J, E->variables);\n\tif (E->outer)\n\t\tjsR_dumpenvironment(J, E->outer, d+1);\n}\n\nvoid js_stacktrace(js_State *J)\n{\n\tint n;\n\tprintf(\"stack trace:\\n\");\n\tfor (n = J->tracetop; n >= 0; --n) {\n\t\tconst char *name = J->trace[n].name;\n\t\tconst char *file = J->trace[n].file;\n\t\tint line = J->trace[n].line;\n\t\tif (line > 0) {\n\t\t\tif (name[0])\n\t\t\t\tprintf(\"\\tat %s (%s:%d)\\n\", name, file, line);\n\t\t\telse\n\t\t\t\tprintf(\"\\tat %s:%d\\n\", file, line);\n\t\t} else\n\t\t\tprintf(\"\\tat %s (%s)\\n\", name, file);\n\t}\n}\n\nvoid js_trap(js_State *J, int pc)\n{\n\tif (pc > 0) {\n\t\tjs_Function *F = STACK[BOT-1].u.object->u.f.function;\n\t\tprintf(\"trap at %d in function \", pc);\n\t\tjsC_dumpfunction(J, F);\n\t}\n\tjsR_dumpstack(J);\n\tjsR_dumpenvironment(J, J->E, 0);\n\tjs_stacktrace(J);\n}\n\nstatic void jsR_run(js_State *J, js_Function *F)\n{\n\tjs_Function **FT = F->funtab;\n\tconst char **VT = F->vartab-1;\n\tint lightweight = F->lightweight;\n\tjs_Instruction *pcstart = F->code;\n\tjs_Instruction *pc = F->code;\n\tenum js_OpCode opcode;\n\tint offset;\n\tint savestrict;\n\n\tconst char *str;\n\tjs_Object *obj;\n\tdouble x, y;\n\tunsigned int ux, uy;\n\tint ix, iy, okay;\n\tint b;\n\tint transient;\n\n\tsavestrict = J->strict;\n\tJ->strict = F->strict;\n\n#define READSTRING() \\\n\tmemcpy(&str, pc, sizeof(str)); \\\n\tpc += sizeof(str) / sizeof(*pc)\n\n\twhile (1) {\n\t\tif (J->gccounter > J->gcthresh)\n\t\t\tjs_gc(J, 0);\n\n\t\tJ->trace[J->tracetop].line = *pc++;\n\n\t\topcode = *pc++;\n\n\t\tswitch (opcode) {\n\t\tcase OP_POP: js_pop(J, 1); break;\n\t\tcase OP_DUP: js_dup(J); break;\n\t\tcase OP_DUP2: js_dup2(J); break;\n\t\tcase OP_ROT2: js_rot2(J); break;\n\t\tcase OP_ROT3: js_rot3(J); break;\n\t\tcase OP_ROT4: js_rot4(J); break;\n\n\t\tcase OP_INTEGER:\n\t\t\tjs_pushnumber(J, *pc++ - 32768);\n\t\t\tbreak;\n\n\t\tcase OP_NUMBER:\n\t\t\tmemcpy(&x, pc, sizeof(x));\n\t\t\tpc += sizeof(x) / sizeof(*pc);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_STRING:\n\t\t\tREADSTRING();\n\t\t\tjs_pushliteral(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_CLOSURE: js_newfunction(J, FT[*pc++], J->E); break;\n\t\tcase OP_NEWOBJECT: js_newobject(J); break;\n\t\tcase OP_NEWARRAY: js_newarray(J); break;\n\t\tcase OP_NEWREGEXP:\n\t\t\tREADSTRING();\n\t\t\tjs_newregexp(J, str, *pc++);\n\t\t\tbreak;\n\n\t\tcase OP_UNDEF: js_pushundefined(J); break;\n\t\tcase OP_NULL: js_pushnull(J); break;\n\t\tcase OP_TRUE: js_pushboolean(J, 1); break;\n\t\tcase OP_FALSE: js_pushboolean(J, 0); break;\n\n\t\tcase OP_THIS:\n\t\t\tif (J->strict) {\n\t\t\t\tjs_copy(J, 0);\n\t\t\t} else {\n\t\t\t\tif (js_iscoercible(J, 0))\n\t\t\t\t\tjs_copy(J, 0);\n\t\t\t\telse\n\t\t\t\t\tjs_pushglobal(J);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_CURRENT:\n\t\t\tjs_currentfunction(J);\n\t\t\tbreak;\n\n\t\tcase OP_GETLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\tCHECKSTACK(1);\n\t\t\t\tSTACK[TOP++] = STACK[BOT + *pc++];\n\t\t\t} else {\n\t\t\t\tstr = VT[*pc++];\n\t\t\t\tif (!js_hasvar(J, str))\n\t\t\t\t\tjs_referenceerror(J, \"'%s' is not defined\", str);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_SETLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\tSTACK[BOT + *pc++] = STACK[TOP-1];\n\t\t\t} else {\n\t\t\t\tjs_setvar(J, VT[*pc++]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_DELLOCAL:\n\t\t\tif (lightweight) {\n\t\t\t\t++pc;\n\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t} else {\n\t\t\t\tb = js_delvar(J, VT[*pc++]);\n\t\t\t\tjs_pushboolean(J, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_GETVAR:\n\t\t\tREADSTRING();\n\t\t\tif (!js_hasvar(J, str))\n\t\t\t\tjs_referenceerror(J, \"'%s' is not defined\", str);\n\t\t\tbreak;\n\n\t\tcase OP_HASVAR:\n\t\t\tREADSTRING();\n\t\t\tif (!js_hasvar(J, str))\n\t\t\t\tjs_pushundefined(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETVAR:\n\t\t\tREADSTRING();\n\t\t\tjs_setvar(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_DELVAR:\n\t\t\tREADSTRING();\n\t\t\tb = js_delvar(J, str);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_IN:\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tif (!js_isobject(J, -1))\n\t\t\t\tjs_typeerror(J, \"operand to 'in' is not an object\");\n\t\t\tb = js_hasproperty(J, -1, str);\n\t\t\tjs_pop(J, 2 + b);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_INITARRAY:\n\t\t\tjs_setindex(J, -2, js_getlength(J, -2));\n\t\t\tbreak;\n\n\t\tcase OP_INITPROP:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_setproperty(J, obj, str, 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_INITGETTER:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_defproperty(J, obj, str, 0, NULL, jsR_tofunction(J, -1), NULL, 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_INITSETTER:\n\t\t\tobj = js_toobject(J, -3);\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tjsR_defproperty(J, obj, str, 0, NULL, NULL, jsR_tofunction(J, -1), 0);\n\t\t\tjs_pop(J, 2);\n\t\t\tbreak;\n\n\t\tcase OP_GETPROP:\n\t\t\tstr = js_tostring(J, -1);\n\t\t\tobj = js_toobject(J, -2);\n\t\t\tjsR_getproperty(J, obj, str);\n\t\t\tjs_rot3pop2(J);\n\t\t\tbreak;\n\n\t\tcase OP_GETPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tjsR_getproperty(J, obj, str);\n\t\t\tjs_rot2pop1(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETPROP:\n\t\t\tstr = js_tostring(J, -2);\n\t\t\tobj = js_toobject(J, -3);\n\t\t\ttransient = !js_isobject(J, -3);\n\t\t\tjsR_setproperty(J, obj, str, transient);\n\t\t\tjs_rot3pop2(J);\n\t\t\tbreak;\n\n\t\tcase OP_SETPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -2);\n\t\t\ttransient = !js_isobject(J, -2);\n\t\t\tjsR_setproperty(J, obj, str, transient);\n\t\t\tjs_rot2pop1(J);\n\t\t\tbreak;\n\n\t\tcase OP_DELPROP:\n\t\t\tstr = js_tostring(J, -1);\n\t\t\tobj = js_toobject(J, -2);\n\t\t\tb = jsR_delproperty(J, obj, str);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_DELPROP_S:\n\t\t\tREADSTRING();\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tb = jsR_delproperty(J, obj, str);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\tcase OP_ITERATOR:\n\t\t\tif (js_iscoercible(J, -1)) {\n\t\t\t\tobj = jsV_newiterator(J, js_toobject(J, -1), 0);\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\tjs_pushobject(J, obj);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_NEXTITER:\n\t\t\tif (js_isobject(J, -1)) {\n\t\t\t\tobj = js_toobject(J, -1);\n\t\t\t\tstr = jsV_nextiterator(J, obj);\n\t\t\t\tif (str) {\n\t\t\t\t\tjs_pushliteral(J, str);\n\t\t\t\t\tjs_pushboolean(J, 1);\n\t\t\t\t} else {\n\t\t\t\t\tjs_pop(J, 1);\n\t\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjs_pop(J, 1);\n\t\t\t\tjs_pushboolean(J, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* Function calls */\n\n\t\tcase OP_EVAL:\n\t\t\tjs_eval(J);\n\t\t\tbreak;\n\n\t\tcase OP_CALL:\n\t\t\tjs_call(J, *pc++);\n\t\t\tbreak;\n\n\t\tcase OP_NEW:\n\t\t\tjs_construct(J, *pc++);\n\t\t\tbreak;\n\n\t\t/* Unary operators */\n\n\t\tcase OP_TYPEOF:\n\t\t\tstr = js_typeof(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushliteral(J, str);\n\t\t\tbreak;\n\n\t\tcase OP_POS:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_NEG:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, -x);\n\t\t\tbreak;\n\n\t\tcase OP_BITNOT:\n\t\t\tix = js_toint32(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, ~ix);\n\t\t\tbreak;\n\n\t\tcase OP_LOGNOT:\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushboolean(J, !b);\n\t\t\tbreak;\n\n\t\tcase OP_INC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x + 1);\n\t\t\tbreak;\n\n\t\tcase OP_DEC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x - 1);\n\t\t\tbreak;\n\n\t\tcase OP_POSTINC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x + 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\tcase OP_POSTDEC:\n\t\t\tx = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tjs_pushnumber(J, x - 1);\n\t\t\tjs_pushnumber(J, x);\n\t\t\tbreak;\n\n\t\t/* Multiplicative operators */\n\n\t\tcase OP_MUL:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x * y);\n\t\t\tbreak;\n\n\t\tcase OP_DIV:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x / y);\n\t\t\tbreak;\n\n\t\tcase OP_MOD:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, fmod(x, y));\n\t\t\tbreak;\n\n\t\t/* Additive operators */\n\n\t\tcase OP_ADD:\n\t\t\tjs_concat(J);\n\t\t\tbreak;\n\n\t\tcase OP_SUB:\n\t\t\tx = js_tonumber(J, -2);\n\t\t\ty = js_tonumber(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, x - y);\n\t\t\tbreak;\n\n\t\t/* Shift operators */\n\n\t\tcase OP_SHL:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix << (uy & 0x1F));\n\t\t\tbreak;\n\n\t\tcase OP_SHR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix >> (uy & 0x1F));\n\t\t\tbreak;\n\n\t\tcase OP_USHR:\n\t\t\tux = js_touint32(J, -2);\n\t\t\tuy = js_touint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ux >> (uy & 0x1F));\n\t\t\tbreak;\n\n\t\t/* Relational operators */\n\n\t\tcase OP_LT: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b < 0); break;\n\t\tcase OP_GT: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b > 0); break;\n\t\tcase OP_LE: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b <= 0); break;\n\t\tcase OP_GE: b = js_compare(J, &okay); js_pop(J, 2); js_pushboolean(J, okay && b >= 0); break;\n\n\t\tcase OP_INSTANCEOF:\n\t\t\tb = js_instanceof(J);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushboolean(J, b);\n\t\t\tbreak;\n\n\t\t/* Equality */\n\n\t\tcase OP_EQ: b = js_equal(J); js_pop(J, 2); js_pushboolean(J, b); break;\n\t\tcase OP_NE: b = js_equal(J); js_pop(J, 2); js_pushboolean(J, !b); break;\n\t\tcase OP_STRICTEQ: b = js_strictequal(J); js_pop(J, 2); js_pushboolean(J, b); break;\n\t\tcase OP_STRICTNE: b = js_strictequal(J); js_pop(J, 2); js_pushboolean(J, !b); break;\n\n\t\tcase OP_JCASE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_strictequal(J);\n\t\t\tif (b) {\n\t\t\t\tjs_pop(J, 2);\n\t\t\t\tpc = pcstart + offset;\n\t\t\t} else {\n\t\t\t\tjs_pop(J, 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* Binary bitwise operators */\n\n\t\tcase OP_BITAND:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix & iy);\n\t\t\tbreak;\n\n\t\tcase OP_BITXOR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix ^ iy);\n\t\t\tbreak;\n\n\t\tcase OP_BITOR:\n\t\t\tix = js_toint32(J, -2);\n\t\t\tiy = js_toint32(J, -1);\n\t\t\tjs_pop(J, 2);\n\t\t\tjs_pushnumber(J, ix | iy);\n\t\t\tbreak;\n\n\t\t/* Try and Catch */\n\n\t\tcase OP_THROW:\n\t\t\tjs_throw(J);\n\n\t\tcase OP_TRY:\n\t\t\toffset = *pc++;\n\t\t\tif (js_trypc(J, pc)) {\n\t\t\t\tpc = J->trybuf[J->trytop].pc;\n\t\t\t} else {\n\t\t\t\tpc = pcstart + offset;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_ENDTRY:\n\t\t\tjs_endtry(J);\n\t\t\tbreak;\n\n\t\tcase OP_CATCH:\n\t\t\tREADSTRING();\n\t\t\tobj = jsV_newobject(J, JS_COBJECT, NULL);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_rot2(J);\n\t\t\tjs_setproperty(J, -2, str);\n\t\t\tJ->E = jsR_newenvironment(J, obj, J->E);\n\t\t\tjs_pop(J, 1);\n\t\t\tbreak;\n\n\t\tcase OP_ENDCATCH:\n\t\t\tJ->E = J->E->outer;\n\t\t\tbreak;\n\n\t\t/* With */\n\n\t\tcase OP_WITH:\n\t\t\tobj = js_toobject(J, -1);\n\t\t\tJ->E = jsR_newenvironment(J, obj, J->E);\n\t\t\tjs_pop(J, 1);\n\t\t\tbreak;\n\n\t\tcase OP_ENDWITH:\n\t\t\tJ->E = J->E->outer;\n\t\t\tbreak;\n\n\t\t/* Branching */\n\n\t\tcase OP_DEBUGGER:\n\t\t\tjs_trap(J, (int)(pc - pcstart) - 1);\n\t\t\tbreak;\n\n\t\tcase OP_JUMP:\n\t\t\tpc = pcstart + *pc;\n\t\t\tbreak;\n\n\t\tcase OP_JTRUE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tif (b)\n\t\t\t\tpc = pcstart + offset;\n\t\t\tbreak;\n\n\t\tcase OP_JFALSE:\n\t\t\toffset = *pc++;\n\t\t\tb = js_toboolean(J, -1);\n\t\t\tjs_pop(J, 1);\n\t\t\tif (!b)\n\t\t\t\tpc = pcstart + offset;\n\t\t\tbreak;\n\n\t\tcase OP_RETURN:\n\t\t\tJ->strict = savestrict;\n\t\t\treturn;\n\t\t}\n\t}\n}\n"], "filenames": ["jsrun.c"], "buggy_code_start_loc": [525], "buggy_code_end_loc": [526], "fixing_code_start_loc": [525], "fixing_code_end_loc": [526], "type": "CWE-416", "message": "In MuJS before version 1.1.2, a use-after-free flaw in the regexp source property access may cause denial of service.\n\n", "other": {"cve": {"id": "CVE-2021-33796", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-07-07T18:15:09.430", "lastModified": "2023-07-13T18:40:16.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In MuJS before version 1.1.2, a use-after-free flaw in the regexp source property access may cause denial of service.\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mujs:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.2", "matchCriteriaId": "81684136-544E-49E9-94B6-1C758DFE16E4"}]}]}], "references": [{"url": "https://github.com/ccxvii/mujs/commit/7ef066a3bb95bf83e7c5be50d859e62e58fe8515", "source": "patrick@puiterwijk.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/ccxvii/mujs/commit/7ef066a3bb95bf83e7c5be50d859e62e58fe8515"}}