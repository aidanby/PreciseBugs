{"buggy_code": ["/*  vcf.c -- VCF/BCF API functions.\n\n    Copyright (C) 2012, 2013 Broad Institute.\n    Copyright (C) 2012-2020 Genome Research Ltd.\n    Portions copyright (C) 2014 Intel Corporation.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h\n#include <config.h>\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <errno.h>\n\n#include \"htslib/vcf.h\"\n#include \"htslib/bgzf.h\"\n#include \"htslib/tbx.h\"\n#include \"htslib/hfile.h\"\n#include \"hts_internal.h\"\n#include \"htslib/hts_endian.h\"\n#include \"htslib/khash_str2int.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n\n#include \"htslib/khash.h\"\nKHASH_MAP_INIT_STR(vdict, bcf_idinfo_t)\ntypedef khash_t(vdict) vdict_t;\n\n#include \"htslib/kseq.h\"\nHTSLIB_EXPORT\nuint32_t bcf_float_missing    = 0x7F800001;\n\nHTSLIB_EXPORT\nuint32_t bcf_float_vector_end = 0x7F800002;\n\nHTSLIB_EXPORT\nuint8_t bcf_type_shift[] = { 0, 0, 1, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic bcf_idinfo_t bcf_idinfo_def = { .info = { 15, 15, 15 }, .hrec = { NULL, NULL, NULL}, .id = -1 };\n\n/*\n    Partial support for 64-bit POS and Number=1 INFO tags.\n    Notes:\n     - the support for 64-bit values is motivated by POS and INFO/END for large genomes\n     - the use of 64-bit values does not conform to the specification\n     - cannot output 64-bit BCF and if it does, it is not compatible with anything\n     - experimental, use at your risk\n*/\n#ifdef VCF_ALLOW_INT64\n    #define BCF_MAX_BT_INT64 (0x7fffffffffffffff)       /* INT64_MAX, for internal use only */\n    #define BCF_MIN_BT_INT64 -9223372036854775800LL     /* INT64_MIN + 8, for internal use only */\n#endif\n\n#define BCF_IS_64BIT (1<<30)\n\n\nstatic char *find_chrom_header_line(char *s)\n{\n    char *nl;\n    if (strncmp(s, \"#CHROM\\t\", 7) == 0) return s;\n    else if ((nl = strstr(s, \"\\n#CHROM\\t\")) != NULL) return nl+1;\n    else return NULL;\n}\n\n/*************************\n *** VCF header parser ***\n *************************/\n\nstatic int bcf_hdr_add_sample_len(bcf_hdr_t *h, const char *s, size_t len)\n{\n    if ( !s ) return 0;\n    if (len == 0) len = strlen(s);\n\n    const char *ss = s;\n    while ( *ss && isspace_c(*ss) && ss - s < len) ss++;\n    if ( !*ss || ss - s == len)\n    {\n        hts_log_error(\"Empty sample name: trailing spaces/tabs in the header line?\");\n        return -1;\n    }\n\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_SAMPLE];\n    int ret;\n    char *sdup = malloc(len + 1);\n    if (!sdup) return -1;\n    memcpy(sdup, s, len);\n    sdup[len] = 0;\n\n    // Ensure space is available in h->samples\n    size_t n = kh_size(d);\n    char **new_samples = realloc(h->samples, sizeof(char*) * (n + 1));\n    if (!new_samples) {\n        free(sdup);\n        return -1;\n    }\n    h->samples = new_samples;\n\n    int k = kh_put(vdict, d, sdup, &ret);\n    if (ret < 0) {\n        free(sdup);\n        return -1;\n    }\n    if (ret) { // absent\n        kh_val(d, k) = bcf_idinfo_def;\n        kh_val(d, k).id = n;\n    } else {\n        hts_log_error(\"Duplicated sample name '%s'\", s);\n        free(sdup);\n        return -1;\n    }\n    h->samples[n] = sdup;\n    h->dirty = 1;\n    return 0;\n}\n\nint bcf_hdr_add_sample(bcf_hdr_t *h, const char *s)\n{\n    return bcf_hdr_add_sample_len(h, s, 0);\n}\n\nint HTS_RESULT_USED bcf_hdr_parse_sample_line(bcf_hdr_t *h, const char *str)\n{\n    int ret = 0;\n    int i = 0;\n    const char *p, *q;\n    // add samples\n    for (p = q = str;; ++q) {\n        if (*q > '\\n') continue;\n        if (++i > 9) {\n            if ( bcf_hdr_add_sample_len(h, p, q - p) < 0 ) ret = -1;\n        }\n        if (*q == 0 || *q == '\\n' || ret < 0) break;\n        p = q + 1;\n    }\n\n    return ret;\n}\n\nint bcf_hdr_sync(bcf_hdr_t *h)\n{\n    int i;\n    for (i = 0; i < 3; i++)\n    {\n        vdict_t *d = (vdict_t*)h->dict[i];\n        khint_t k;\n        if ( h->n[i] < kh_size(d) )\n        {\n            bcf_idpair_t *new_idpair;\n            // this should be true only for i=2, BCF_DT_SAMPLE\n            new_idpair = (bcf_idpair_t*) realloc(h->id[i], kh_size(d)*sizeof(bcf_idpair_t));\n            if (!new_idpair) return -1;\n            h->n[i] = kh_size(d);\n            h->id[i] = new_idpair;\n        }\n        for (k=kh_begin(d); k<kh_end(d); k++)\n        {\n            if (!kh_exist(d,k)) continue;\n            h->id[i][kh_val(d,k).id].key = kh_key(d,k);\n            h->id[i][kh_val(d,k).id].val = &kh_val(d,k);\n        }\n    }\n    h->dirty = 0;\n    return 0;\n}\n\nvoid bcf_hrec_destroy(bcf_hrec_t *hrec)\n{\n    if (!hrec) return;\n    free(hrec->key);\n    if ( hrec->value ) free(hrec->value);\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        free(hrec->keys[i]);\n        free(hrec->vals[i]);\n    }\n    free(hrec->keys);\n    free(hrec->vals);\n    free(hrec);\n}\n\n// Copies all fields except IDX.\nbcf_hrec_t *bcf_hrec_dup(bcf_hrec_t *hrec)\n{\n    int save_errno;\n    bcf_hrec_t *out = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));\n    if (!out) return NULL;\n\n    out->type = hrec->type;\n    if ( hrec->key ) {\n        out->key = strdup(hrec->key);\n        if (!out->key) goto fail;\n    }\n    if ( hrec->value ) {\n        out->value = strdup(hrec->value);\n        if (!out->value) goto fail;\n    }\n    out->nkeys = hrec->nkeys;\n    out->keys = (char**) malloc(sizeof(char*)*hrec->nkeys);\n    if (!out->keys) goto fail;\n    out->vals = (char**) malloc(sizeof(char*)*hrec->nkeys);\n    if (!out->vals) goto fail;\n    int i, j = 0;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        if ( hrec->keys[i] && !strcmp(\"IDX\",hrec->keys[i]) ) continue;\n        if ( hrec->keys[i] ) {\n            out->keys[j] = strdup(hrec->keys[i]);\n            if (!out->keys[j]) goto fail;\n        }\n        if ( hrec->vals[i] ) {\n            out->vals[j] = strdup(hrec->vals[i]);\n            if (!out->vals[j]) goto fail;\n        }\n        j++;\n    }\n    if ( i!=j ) out->nkeys -= i-j;   // IDX was omitted\n    return out;\n\n fail:\n    save_errno = errno;\n    hts_log_error(\"%s\", strerror(errno));\n    bcf_hrec_destroy(out);\n    errno = save_errno;\n    return NULL;\n}\n\nvoid bcf_hrec_debug(FILE *fp, bcf_hrec_t *hrec)\n{\n    fprintf(fp, \"key=[%s] value=[%s]\", hrec->key, hrec->value?hrec->value:\"\");\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n        fprintf(fp, \"\\t[%s]=[%s]\", hrec->keys[i],hrec->vals[i]);\n    fprintf(fp, \"\\n\");\n}\n\nvoid bcf_header_debug(bcf_hdr_t *hdr)\n{\n    int i, j;\n    for (i=0; i<hdr->nhrec; i++)\n    {\n        if ( !hdr->hrec[i]->value )\n        {\n            fprintf(stderr, \"##%s=<\", hdr->hrec[i]->key);\n            fprintf(stderr,\"%s=%s\", hdr->hrec[i]->keys[0], hdr->hrec[i]->vals[0]);\n            for (j=1; j<hdr->hrec[i]->nkeys; j++)\n                fprintf(stderr,\",%s=%s\", hdr->hrec[i]->keys[j], hdr->hrec[i]->vals[j]);\n            fprintf(stderr,\">\\n\");\n        }\n        else\n            fprintf(stderr,\"##%s=%s\\n\", hdr->hrec[i]->key,hdr->hrec[i]->value);\n    }\n}\n\nint bcf_hrec_add_key(bcf_hrec_t *hrec, const char *str, size_t len)\n{\n    char **tmp;\n    size_t n = hrec->nkeys + 1;\n    assert(len > 0 && len < SIZE_MAX);\n    tmp = realloc(hrec->keys, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->keys = tmp;\n    tmp = realloc(hrec->vals, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->vals = tmp;\n\n    hrec->keys[hrec->nkeys] = (char*) malloc((len+1)*sizeof(char));\n    if (!hrec->keys[hrec->nkeys]) return -1;\n    memcpy(hrec->keys[hrec->nkeys],str,len);\n    hrec->keys[hrec->nkeys][len] = 0;\n    hrec->vals[hrec->nkeys] = NULL;\n    hrec->nkeys = n;\n    return 0;\n}\n\nint bcf_hrec_set_val(bcf_hrec_t *hrec, int i, const char *str, size_t len, int is_quoted)\n{\n    if ( hrec->vals[i] ) {\n        free(hrec->vals[i]);\n        hrec->vals[i] = NULL;\n    }\n    if ( !str ) return 0;\n    if ( is_quoted )\n    {\n        if (len >= SIZE_MAX - 3) {\n            errno = ENOMEM;\n            return -1;\n        }\n        hrec->vals[i] = (char*) malloc((len+3)*sizeof(char));\n        if (!hrec->vals[i]) return -1;\n        hrec->vals[i][0] = '\"';\n        memcpy(&hrec->vals[i][1],str,len);\n        hrec->vals[i][len+1] = '\"';\n        hrec->vals[i][len+2] = 0;\n    }\n    else\n    {\n        if (len == SIZE_MAX) {\n            errno = ENOMEM;\n            return -1;\n        }\n        hrec->vals[i] = (char*) malloc((len+1)*sizeof(char));\n        if (!hrec->vals[i]) return -1;\n        memcpy(hrec->vals[i],str,len);\n        hrec->vals[i][len] = 0;\n    }\n    return 0;\n}\n\nint hrec_add_idx(bcf_hrec_t *hrec, int idx)\n{\n    int n = hrec->nkeys + 1;\n    char **tmp = (char**) realloc(hrec->keys, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->keys = tmp;\n\n    tmp = (char**) realloc(hrec->vals, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->vals = tmp;\n\n    hrec->keys[hrec->nkeys] = strdup(\"IDX\");\n    if (!hrec->keys[hrec->nkeys]) return -1;\n\n    kstring_t str = {0,0,0};\n    if (kputw(idx, &str) < 0) {\n        free(hrec->keys[hrec->nkeys]);\n        return -1;\n    }\n    hrec->vals[hrec->nkeys] = str.s;\n    hrec->nkeys = n;\n    return 0;\n}\n\nint bcf_hrec_find_key(bcf_hrec_t *hrec, const char *key)\n{\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n        if ( !strcasecmp(key,hrec->keys[i]) ) return i;\n    return -1;\n}\n\nstatic inline int is_escaped(const char *min, const char *str)\n{\n    int n = 0;\n    while ( --str>=min && *str=='\\\\' ) n++;\n    return n%2;\n}\n\nbcf_hrec_t *bcf_hdr_parse_line(const bcf_hdr_t *h, const char *line, int *len)\n{\n    const char *p = line;\n    if (p[0] != '#' || p[1] != '#') { *len = 0; return NULL; }\n    p += 2;\n\n    const char *q = p;\n    while ( *q && *q!='=' && *q != '\\n' ) q++;\n    ptrdiff_t n = q-p;\n    if ( *q!='=' || !n ) { *len = q-line+1; return NULL; } // wrong format\n\n    bcf_hrec_t *hrec = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));\n    if (!hrec) return NULL;\n    hrec->key = (char*) malloc(sizeof(char)*(n+1));\n    if (!hrec->key) goto fail;\n    memcpy(hrec->key,p,n);\n    hrec->key[n] = 0;\n\n    p = ++q;\n    if ( *p!='<' ) // generic field, e.g. ##samtoolsVersion=0.1.18-r579\n    {\n        while ( *q && *q!='\\n' ) q++;\n        hrec->value = (char*) malloc((q-p+1)*sizeof(char));\n        if (!hrec->value) goto fail;\n        memcpy(hrec->value, p, q-p);\n        hrec->value[q-p] = 0;\n        *len = q - line + (*q ? 1 : 0); // Skip \\n but not \\0\n        return hrec;\n    }\n\n    // structured line, e.g.\n    // ##INFO=<ID=PV1,Number=1,Type=Float,Description=\"P-value for baseQ bias\">\n    // ##PEDIGREE=<Name_0=G0-ID,Name_1=G1-ID,Name_3=GN-ID>\n    int nopen = 1;\n    while ( *q && *q!='\\n' && nopen>0 )\n    {\n        p = ++q;\n        while ( *q && *q==' ' ) { p++; q++; }\n        // ^[A-Za-z_][0-9A-Za-z_.]*$\n        if (p==q && *q && (isalpha_c(*q) || *q=='_'))\n        {\n            q++;\n            while ( *q && (isalnum_c(*q) || *q=='_' || *q=='.') ) q++;\n        }\n        n = q-p;\n        int m = 0;\n        while ( *q && *q==' ' ) { q++; m++; }\n        if ( *q!='=' || !n )\n        {\n            // wrong format\n            while ( *q && *q!='\\n' ) q++;\n            hts_log_error(\"Could not parse the header line: \\\"%.*s\\\"\",\n                (int) (q - line), line);\n            *len = q - line + (*q ? 1 : 0);\n            bcf_hrec_destroy(hrec);\n            return NULL;\n        }\n        if (bcf_hrec_add_key(hrec, p, q-p-m) < 0) goto fail;\n        p = ++q;\n        while ( *q && *q==' ' ) { p++; q++; }\n        int quoted = *p=='\"' ? 1 : 0;\n        if ( quoted ) p++, q++;\n        while ( *q && *q != '\\n' )\n        {\n            if ( quoted ) { if ( *q=='\"' && !is_escaped(p,q) ) break; }\n            else\n            {\n                if ( *q=='<' ) nopen++;\n                if ( *q=='>' ) nopen--;\n                if ( !nopen ) break;\n                if ( *q==',' && nopen==1 ) break;\n            }\n            q++;\n        }\n        const char *r = q;\n        while ( r > p && r[-1] == ' ' ) r--;\n        if (bcf_hrec_set_val(hrec, hrec->nkeys-1, p, r-p, quoted) < 0)\n            goto fail;\n        if ( quoted && *q=='\"' ) q++;\n        if ( *q=='>' ) { nopen--; q++; }\n    }\n\n    // Skip to end of line\n    int nonspace = 0;\n    p = q;\n    while ( *q && *q!='\\n' ) { nonspace |= !isspace_c(*q); q++; }\n    if (nonspace) {\n        hts_log_warning(\"Dropped trailing junk from header line '%.*s'\", (int) (q - line), line);\n    }\n\n    *len = q - line + (*q ? 1 : 0);\n    return hrec;\n\n fail:\n    bcf_hrec_destroy(hrec);\n    return NULL;\n}\n\nstatic int bcf_hdr_set_idx(bcf_hdr_t *hdr, int dict_type, const char *tag, bcf_idinfo_t *idinfo)\n{\n    size_t new_n;\n\n    // If available, preserve existing IDX\n    if ( idinfo->id==-1 )\n        idinfo->id = hdr->n[dict_type];\n    else if ( idinfo->id < hdr->n[dict_type] && hdr->id[dict_type][idinfo->id].key )\n    {\n        hts_log_error(\"Conflicting IDX=%d lines in the header dictionary, the new tag is %s\",\n            idinfo->id, tag);\n        errno = EINVAL;\n        return -1;\n    }\n\n    new_n = idinfo->id >= hdr->n[dict_type] ? idinfo->id+1 : hdr->n[dict_type];\n    if (hts_resize(bcf_idpair_t, new_n, &hdr->m[dict_type],\n                   &hdr->id[dict_type], HTS_RESIZE_CLEAR)) {\n        return -1;\n    }\n    hdr->n[dict_type] = new_n;\n\n    // NB: the next kh_put call can invalidate the idinfo pointer, therefore\n    // we leave it unassigned here. It must be set explicitly in bcf_hdr_sync.\n    hdr->id[dict_type][idinfo->id].key = tag;\n\n    return 0;\n}\n\n// returns: 1 when hdr needs to be synced, -1 on error, 0 otherwise\nstatic int bcf_hdr_register_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)\n{\n    // contig\n    int i, ret, replacing = 0;\n    khint_t k;\n    char *str = NULL;\n\n    if ( !strcmp(hrec->key, \"contig\") )\n    {\n        hts_pos_t len = 0;\n        hrec->type = BCF_HL_CTG;\n\n        // Get the contig ID ($str) and length ($j)\n        i = bcf_hrec_find_key(hrec,\"length\");\n        if ( i<0 ) len = 0;\n        else {\n            char *end = hrec->vals[i];\n            len = strtoll(hrec->vals[i], &end, 10);\n            if (end == hrec->vals[i] || len < 0) return 0;\n        }\n\n        i = bcf_hrec_find_key(hrec,\"ID\");\n        if ( i<0 ) return 0;\n        str = strdup(hrec->vals[i]);\n        if (!str) return -1;\n\n        // Register in the dictionary\n        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_CTG];\n        khint_t k = kh_get(vdict, d, str);\n        if ( k != kh_end(d) ) { // already present\n            free(str); str=NULL;\n            if (kh_val(d, k).hrec[0] != NULL) // and not removed\n                return 0;\n            replacing = 1;\n        } else {\n            k = kh_put(vdict, d, str, &ret);\n            if (ret < 0) { free(str); return -1; }\n        }\n\n        int idx = bcf_hrec_find_key(hrec,\"IDX\");\n        if ( idx!=-1 )\n        {\n            char *tmp = hrec->vals[idx];\n            idx = strtol(hrec->vals[idx], &tmp, 10);\n            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)\n            {\n                if (!replacing) {\n                    kh_del(vdict, d, k);\n                    free(str);\n                }\n                hts_log_warning(\"Error parsing the IDX tag, skipping\");\n                return 0;\n            }\n        }\n\n        kh_val(d, k) = bcf_idinfo_def;\n        kh_val(d, k).id = idx;\n        kh_val(d, k).info[0] = len;\n        kh_val(d, k).hrec[0] = hrec;\n        if (bcf_hdr_set_idx(hdr, BCF_DT_CTG, kh_key(d,k), &kh_val(d,k)) < 0) {\n            if (!replacing) {\n                kh_del(vdict, d, k);\n                free(str);\n            }\n            return -1;\n        }\n        if ( idx==-1 ) {\n            if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {\n               return -1;\n            }\n        }\n\n        return 1;\n    }\n\n    if ( !strcmp(hrec->key, \"INFO\") ) hrec->type = BCF_HL_INFO;\n    else if ( !strcmp(hrec->key, \"FILTER\") ) hrec->type = BCF_HL_FLT;\n    else if ( !strcmp(hrec->key, \"FORMAT\") ) hrec->type = BCF_HL_FMT;\n    else if ( hrec->nkeys>0 ) { hrec->type = BCF_HL_STR; return 1; }\n    else return 0;\n\n    // INFO/FILTER/FORMAT\n    char *id = NULL;\n    uint32_t type = UINT32_MAX, var = UINT32_MAX;\n    int num = -1, idx = -1;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        if ( !strcmp(hrec->keys[i], \"ID\") ) id = hrec->vals[i];\n        else if ( !strcmp(hrec->keys[i], \"IDX\") )\n        {\n            char *tmp = hrec->vals[i];\n            idx = strtol(hrec->vals[i], &tmp, 10);\n            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)\n            {\n                hts_log_warning(\"Error parsing the IDX tag, skipping\");\n                return 0;\n            }\n        }\n        else if ( !strcmp(hrec->keys[i], \"Type\") )\n        {\n            if ( !strcmp(hrec->vals[i], \"Integer\") ) type = BCF_HT_INT;\n            else if ( !strcmp(hrec->vals[i], \"Float\") ) type = BCF_HT_REAL;\n            else if ( !strcmp(hrec->vals[i], \"String\") ) type = BCF_HT_STR;\n            else if ( !strcmp(hrec->vals[i], \"Character\") ) type = BCF_HT_STR;\n            else if ( !strcmp(hrec->vals[i], \"Flag\") ) type = BCF_HT_FLAG;\n            else\n            {\n                hts_log_warning(\"The type \\\"%s\\\" is not supported, assuming \\\"String\\\"\", hrec->vals[i]);\n                type = BCF_HT_STR;\n            }\n        }\n        else if ( !strcmp(hrec->keys[i], \"Number\") )\n        {\n            if ( !strcmp(hrec->vals[i],\"A\") ) var = BCF_VL_A;\n            else if ( !strcmp(hrec->vals[i],\"R\") ) var = BCF_VL_R;\n            else if ( !strcmp(hrec->vals[i],\"G\") ) var = BCF_VL_G;\n            else if ( !strcmp(hrec->vals[i],\".\") ) var = BCF_VL_VAR;\n            else\n            {\n                sscanf(hrec->vals[i],\"%d\",&num);\n                var = BCF_VL_FIXED;\n            }\n            if (var != BCF_VL_FIXED) num = 0xfffff;\n        }\n    }\n    if (hrec->type == BCF_HL_INFO || hrec->type == BCF_HL_FMT) {\n        if (type == -1) {\n            hts_log_warning(\"%s %s field has no Type defined. Assuming String\",\n                *hrec->key == 'I' ? \"An\" : \"A\", hrec->key);\n            type = BCF_HT_STR;\n        }\n        if (var == -1) {\n            hts_log_warning(\"%s %s field has no Number defined. Assuming '.'\",\n                *hrec->key == 'I' ? \"An\" : \"A\", hrec->key);\n            var = BCF_VL_VAR;\n        }\n    }\n    uint32_t info = ((((uint32_t)num) & 0xfffff)<<12 |\n                     (var & 0xf) << 8 |\n                     (type & 0xf) << 4 |\n                     (((uint32_t) hrec->type) & 0xf));\n\n    if ( !id ) return 0;\n    str = strdup(id);\n    if (!str) return -1;\n\n    vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_ID];\n    k = kh_get(vdict, d, str);\n    if ( k != kh_end(d) )\n    {\n        // already present\n        free(str);\n        if ( kh_val(d, k).hrec[info&0xf] ) return 0;\n        kh_val(d, k).info[info&0xf] = info;\n        kh_val(d, k).hrec[info&0xf] = hrec;\n        if ( idx==-1 ) {\n            if (hrec_add_idx(hrec, kh_val(d, k).id) < 0) {\n                return -1;\n            }\n        }\n        return 1;\n    }\n    k = kh_put(vdict, d, str, &ret);\n    if (ret < 0) {\n        free(str);\n        return -1;\n    }\n    kh_val(d, k) = bcf_idinfo_def;\n    kh_val(d, k).info[info&0xf] = info;\n    kh_val(d, k).hrec[info&0xf] = hrec;\n    kh_val(d, k).id = idx;\n    if (bcf_hdr_set_idx(hdr, BCF_DT_ID, kh_key(d,k), &kh_val(d,k)) < 0) {\n        kh_del(vdict, d, k);\n        free(str);\n        return -1;\n    }\n    if ( idx==-1 ) {\n        if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\nint bcf_hdr_add_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)\n{\n    int res;\n    if ( !hrec ) return 0;\n\n    hrec->type = BCF_HL_GEN;\n    res = bcf_hdr_register_hrec(hdr,hrec);\n    if (res < 0) return -1;\n    if ( !res )\n    {\n        // If one of the hashed field, then it is already present\n        if ( hrec->type != BCF_HL_GEN )\n        {\n            bcf_hrec_destroy(hrec);\n            return 0;\n        }\n\n        // Is one of the generic fields and already present?\n        int i;\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=BCF_HL_GEN ) continue;\n            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hrec->key,\"fileformat\") ) break;\n            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hdr->hrec[i]->value,hrec->value) ) break;\n        }\n        if ( i<hdr->nhrec )\n        {\n            bcf_hrec_destroy(hrec);\n            return 0;\n        }\n    }\n\n    // New record, needs to be added\n    int n = hdr->nhrec + 1;\n    bcf_hrec_t **new_hrec = realloc(hdr->hrec, n*sizeof(bcf_hrec_t*));\n    if (!new_hrec) return -1;\n    hdr->hrec = new_hrec;\n    hdr->hrec[hdr->nhrec] = hrec;\n    hdr->dirty = 1;\n    hdr->nhrec = n;\n\n    return hrec->type==BCF_HL_GEN ? 0 : 1;\n}\n\n/*\n *  Note that while querying of FLT,INFO,FMT,CTG lines is fast (the keys are hashed),\n *  the STR,GEN lines are searched for linearly in a linked list of all header lines.\n *  This may become a problem for VCFs with huge headers, we might need to build a\n *  dictionary for these lines as well.\n */\nbcf_hrec_t *bcf_hdr_get_hrec(const bcf_hdr_t *hdr, int type, const char *key, const char *value, const char *str_class)\n{\n    int i;\n    if ( type==BCF_HL_GEN )\n    {\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=type ) continue;\n            if ( strcmp(hdr->hrec[i]->key,key) ) continue;\n            if ( !value || !strcmp(hdr->hrec[i]->value,value) ) return hdr->hrec[i];\n        }\n        return NULL;\n    }\n    else if ( type==BCF_HL_STR )\n    {\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=type ) continue;\n            if ( strcmp(hdr->hrec[i]->key,str_class) ) continue;\n            int j = bcf_hrec_find_key(hdr->hrec[i],key);\n            if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],value) ) return hdr->hrec[i];\n        }\n        return NULL;\n    }\n    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n    khint_t k = kh_get(vdict, d, value);\n    if ( k == kh_end(d) ) return NULL;\n    return kh_val(d, k).hrec[type==BCF_HL_CTG?0:type];\n}\n\nvoid bcf_hdr_check_sanity(bcf_hdr_t *hdr)\n{\n    static int PL_warned = 0, GL_warned = 0;\n\n    if ( !PL_warned )\n    {\n        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, \"PL\");\n        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )\n        {\n            hts_log_warning(\"PL should be declared as Number=G\");\n            PL_warned = 1;\n        }\n    }\n    if ( !GL_warned )\n    {\n        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, \"GL\");\n        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )\n        {\n            hts_log_warning(\"GL should be declared as Number=G\");\n            GL_warned = 1;\n        }\n    }\n}\n\nint bcf_hdr_parse(bcf_hdr_t *hdr, char *htxt)\n{\n    int len, done = 0;\n    char *p = htxt;\n\n    // Check sanity: \"fileformat\" string must come as first\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,p,&len);\n    if ( !hrec || !hrec->key || strcasecmp(hrec->key,\"fileformat\") )\n        hts_log_warning(\"The first line should be ##fileformat; is the VCF/BCF header broken?\");\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n        bcf_hrec_destroy(hrec);\n        return -1;\n    }\n\n    // The filter PASS must appear first in the dictionary\n    hrec = bcf_hdr_parse_line(hdr,\"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\",&len);\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n        bcf_hrec_destroy(hrec);\n        return -1;\n    }\n\n    // Parse the whole header\n    do {\n        while (NULL != (hrec = bcf_hdr_parse_line(hdr, p, &len))) {\n            if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n                bcf_hrec_destroy(hrec);\n                return -1;\n            }\n            p += len;\n        }\n\n        // Next should be the sample line.  If not, it was a malformed\n        // header, in which case print a warning and skip (many VCF\n        // operations do not really care about a few malformed lines).\n        // In the future we may want to add a strict mode that errors in\n        // this case.\n        if ( strncmp(\"#CHROM\\tPOS\",p,10) != 0 ) {\n            char *eol = strchr(p, '\\n');\n            if (*p != '\\0') {\n                hts_log_warning(\"Could not parse header line: %.*s\",\n                    eol ? (int)(eol - p) : INT_MAX, p);\n            }\n            if (eol) {\n                p = eol + 1; // Try from the next line.\n            } else {\n                done = -1; // No more lines left, give up.\n            }\n        } else {\n            done = 1; // Sample line found\n        }\n    } while (!done);\n\n    if (done < 0) {\n        // No sample line is fatal.\n        hts_log_error(\"Could not parse the header, sample line not found\");\n        return -1;\n    }\n\n    if (bcf_hdr_parse_sample_line(hdr,p) < 0)\n        return -1;\n    if (bcf_hdr_sync(hdr) < 0)\n        return -1;\n    bcf_hdr_check_sanity(hdr);\n    return 0;\n}\n\nint bcf_hdr_append(bcf_hdr_t *hdr, const char *line)\n{\n    int len;\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr, (char*) line, &len);\n    if ( !hrec ) return -1;\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0)\n        return -1;\n    return 0;\n}\n\nvoid bcf_hdr_remove(bcf_hdr_t *hdr, int type, const char *key)\n{\n    int i = 0;\n    bcf_hrec_t *hrec;\n    if ( !key )\n    {\n        while ( i<hdr->nhrec )\n        {\n            if ( hdr->hrec[i]->type!=type ) { i++; continue; }\n            hrec = hdr->hrec[i];\n\n            if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )\n            {\n                int j = bcf_hrec_find_key(hdr->hrec[i], \"ID\");\n                if ( j>=0 )\n                {\n                    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n                    khint_t k = kh_get(vdict, d, hdr->hrec[i]->vals[j]);\n                    kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;\n                }\n            }\n\n            hdr->dirty = 1;\n            hdr->nhrec--;\n            if ( i < hdr->nhrec )\n                memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));\n            bcf_hrec_destroy(hrec);\n        }\n        return;\n    }\n    while (1)\n    {\n        if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )\n        {\n            hrec = bcf_hdr_get_hrec(hdr, type, \"ID\", key, NULL);\n            if ( !hrec ) return;\n\n            for (i=0; i<hdr->nhrec; i++)\n                if ( hdr->hrec[i]==hrec ) break;\n            assert( i<hdr->nhrec );\n\n            vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n            khint_t k = kh_get(vdict, d, key);\n            kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;\n        }\n        else\n        {\n            for (i=0; i<hdr->nhrec; i++)\n            {\n                if ( hdr->hrec[i]->type!=type ) continue;\n                if ( type==BCF_HL_GEN )\n                {\n                    if ( !strcmp(hdr->hrec[i]->key,key) ) break;\n                }\n                else\n                {\n                    // not all structured lines have ID, we could be more sophisticated as in bcf_hdr_get_hrec()\n                    int j = bcf_hrec_find_key(hdr->hrec[i], \"ID\");\n                    if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],key) ) break;\n                }\n            }\n            if ( i==hdr->nhrec ) return;\n            hrec = hdr->hrec[i];\n        }\n\n        hdr->nhrec--;\n        if ( i < hdr->nhrec )\n            memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));\n        bcf_hrec_destroy(hrec);\n        hdr->dirty = 1;\n    }\n}\n\nint bcf_hdr_printf(bcf_hdr_t *hdr, const char *fmt, ...)\n{\n    char tmp[256], *line = tmp;\n    va_list ap;\n    va_start(ap, fmt);\n    int n = vsnprintf(line, sizeof(tmp), fmt, ap);\n    va_end(ap);\n\n    if (n >= sizeof(tmp)) {\n        n++; // For trailing NUL\n        line = (char*)malloc(n);\n        if (!line)\n            return -1;\n\n        va_start(ap, fmt);\n        vsnprintf(line, n, fmt, ap);\n        va_end(ap);\n    }\n\n    int ret = bcf_hdr_append(hdr, line);\n\n    if (line != tmp) free(line);\n    return ret;\n}\n\n\n/**********************\n *** BCF header I/O ***\n **********************/\n\nconst char *bcf_hdr_get_version(const bcf_hdr_t *hdr)\n{\n    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, \"fileformat\", NULL, NULL);\n    if ( !hrec )\n    {\n        hts_log_warning(\"No version string found, assuming VCFv4.2\");\n        return \"VCFv4.2\";\n    }\n    return hrec->value;\n}\n\nint bcf_hdr_set_version(bcf_hdr_t *hdr, const char *version)\n{\n    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, \"fileformat\", NULL, NULL);\n    if ( !hrec )\n    {\n        int len;\n        kstring_t str = {0,0,0};\n        ksprintf(&str,\"##fileformat=%s\", version);\n        hrec = bcf_hdr_parse_line(hdr, str.s, &len);\n        free(str.s);\n    }\n    else\n    {\n        free(hrec->value);\n        hrec->value = strdup(version);\n    }\n    hdr->dirty = 1;\n    return 0; // FIXME: check for errs in this function (return < 0 if so)\n}\n\nbcf_hdr_t *bcf_hdr_init(const char *mode)\n{\n    int i;\n    bcf_hdr_t *h;\n    h = (bcf_hdr_t*)calloc(1, sizeof(bcf_hdr_t));\n    if (!h) return NULL;\n    for (i = 0; i < 3; ++i)\n        if ((h->dict[i] = kh_init(vdict)) == NULL) goto fail;\n    if ( strchr(mode,'w') )\n    {\n        bcf_hdr_append(h, \"##fileformat=VCFv4.2\");\n        // The filter PASS must appear first in the dictionary\n        bcf_hdr_append(h, \"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\");\n    }\n    return h;\n\n fail:\n    for (i = 0; i < 3; ++i)\n        kh_destroy(vdict, h->dict[i]);\n    free(h);\n    return NULL;\n}\n\nvoid bcf_hdr_destroy(bcf_hdr_t *h)\n{\n    int i;\n    khint_t k;\n    if (!h) return;\n    for (i = 0; i < 3; ++i) {\n        vdict_t *d = (vdict_t*)h->dict[i];\n        if (d == 0) continue;\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        free(h->id[i]);\n    }\n    for (i=0; i<h->nhrec; i++)\n        bcf_hrec_destroy(h->hrec[i]);\n    if (h->nhrec) free(h->hrec);\n    if (h->samples) free(h->samples);\n    free(h->keep_samples);\n    free(h->transl[0]); free(h->transl[1]);\n    free(h->mem.s);\n    free(h);\n}\n\nbcf_hdr_t *bcf_hdr_read(htsFile *hfp)\n{\n    if (hfp->format.format == vcf)\n        return vcf_hdr_read(hfp);\n    if (hfp->format.format != bcf) {\n        hts_log_error(\"Input is not detected as bcf or vcf format\");\n        return NULL;\n    }\n\n    assert(hfp->is_bgzf);\n\n    BGZF *fp = hfp->fp.bgzf;\n    uint8_t magic[5];\n    bcf_hdr_t *h;\n    h = bcf_hdr_init(\"r\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    if (bgzf_read(fp, magic, 5) != 5)\n    {\n        hts_log_error(\"Failed to read the header (reading BCF in text mode?)\");\n        bcf_hdr_destroy(h);\n        return NULL;\n    }\n    if (strncmp((char*)magic, \"BCF\\2\\2\", 5) != 0)\n    {\n        if (!strncmp((char*)magic, \"BCF\", 3))\n            hts_log_error(\"Invalid BCF2 magic string: only BCFv2.2 is supported\");\n        else\n            hts_log_error(\"Invalid BCF2 magic string\");\n        bcf_hdr_destroy(h);\n        return NULL;\n    }\n    uint8_t buf[4];\n    size_t hlen;\n    char *htxt = NULL;\n    if (bgzf_read(fp, buf, 4) != 4) goto fail;\n    hlen = buf[0] | (buf[1] << 8) | (buf[2] << 16) | ((size_t) buf[3] << 24);\n    if (hlen >= SIZE_MAX) { errno = ENOMEM; goto fail; }\n    htxt = (char*)malloc(hlen + 1);\n    if (!htxt) goto fail;\n    if (bgzf_read(fp, htxt, hlen) != hlen) goto fail;\n    htxt[hlen] = '\\0'; // Ensure htxt is terminated\n    if ( bcf_hdr_parse(h, htxt) < 0 ) goto fail;\n    free(htxt);\n    return h;\n fail:\n    hts_log_error(\"Failed to read BCF header\");\n    free(htxt);\n    bcf_hdr_destroy(h);\n    return NULL;\n}\n\nint bcf_hdr_write(htsFile *hfp, bcf_hdr_t *h)\n{\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    if ( h->dirty ) {\n        if (bcf_hdr_sync(h) < 0) return -1;\n    }\n    hfp->format.category = variant_data;\n    if (hfp->format.format == vcf || hfp->format.format == text_format) {\n        hfp->format.format = vcf;\n        return vcf_hdr_write(hfp, h);\n    }\n\n    if (hfp->format.format == binary_format)\n        hfp->format.format = bcf;\n\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(h, 1, &htxt);\n    kputc('\\0', &htxt); // include the \\0 byte\n\n    BGZF *fp = hfp->fp.bgzf;\n    if ( bgzf_write(fp, \"BCF\\2\\2\", 5) !=5 ) return -1;\n    uint8_t hlen[4];\n    u32_to_le(htxt.l, hlen);\n    if ( bgzf_write(fp, hlen, 4) !=4 ) return -1;\n    if ( bgzf_write(fp, htxt.s, htxt.l) != htxt.l ) return -1;\n\n    free(htxt.s);\n    return 0;\n}\n\n/********************\n *** BCF site I/O ***\n ********************/\n\nbcf1_t *bcf_init()\n{\n    bcf1_t *v;\n    v = (bcf1_t*)calloc(1, sizeof(bcf1_t));\n    return v;\n}\n\nvoid bcf_clear(bcf1_t *v)\n{\n    int i;\n    for (i=0; i<v->d.m_info; i++)\n    {\n        if ( v->d.info[i].vptr_free )\n        {\n            free(v->d.info[i].vptr - v->d.info[i].vptr_off);\n            v->d.info[i].vptr_free = 0;\n        }\n    }\n    for (i=0; i<v->d.m_fmt; i++)\n    {\n        if ( v->d.fmt[i].p_free )\n        {\n            free(v->d.fmt[i].p - v->d.fmt[i].p_off);\n            v->d.fmt[i].p_free = 0;\n        }\n    }\n    v->rid = v->pos = v->rlen = v->unpacked = 0;\n    bcf_float_set_missing(v->qual);\n    v->n_info = v->n_allele = v->n_fmt = v->n_sample = 0;\n    v->shared.l = v->indiv.l = 0;\n    v->d.var_type = -1;\n    v->d.shared_dirty = 0;\n    v->d.indiv_dirty  = 0;\n    v->d.n_flt = 0;\n    v->errcode = 0;\n    if (v->d.m_als) v->d.als[0] = 0;\n    if (v->d.m_id) v->d.id[0] = 0;\n}\n\nvoid bcf_empty(bcf1_t *v)\n{\n    bcf_clear1(v);\n    free(v->d.id);\n    free(v->d.als);\n    free(v->d.allele); free(v->d.flt); free(v->d.info); free(v->d.fmt);\n    if (v->d.var ) free(v->d.var);\n    free(v->shared.s); free(v->indiv.s);\n    memset(&v->d,0,sizeof(v->d));\n    memset(&v->shared,0,sizeof(v->shared));\n    memset(&v->indiv,0,sizeof(v->indiv));\n}\n\nvoid bcf_destroy(bcf1_t *v)\n{\n    if (!v) return;\n    bcf_empty1(v);\n    free(v);\n}\n\nstatic inline int bcf_read1_core(BGZF *fp, bcf1_t *v)\n{\n    uint8_t x[32];\n    ssize_t ret;\n    uint32_t shared_len, indiv_len;\n    if ((ret = bgzf_read(fp, x, 32)) != 32) {\n        if (ret == 0) return -1;\n        return -2;\n    }\n    bcf_clear1(v);\n    shared_len = le_to_u32(x);\n    if (shared_len < 24) return -2;\n    shared_len -= 24; // to exclude six 32-bit integers\n    if (ks_resize(&v->shared, shared_len) != 0) return -2;\n    indiv_len = le_to_u32(x + 4);\n    if (ks_resize(&v->indiv, indiv_len) != 0) return -2;\n    v->rid  = le_to_i32(x + 8);\n    v->pos  = le_to_u32(x + 12);\n    v->rlen = le_to_i32(x + 16);\n    v->qual = le_to_float(x + 20);\n    v->n_info = le_to_u16(x + 24);\n    v->n_allele = le_to_u16(x + 26);\n    v->n_sample = le_to_u32(x + 28) & 0xffffff;\n    v->n_fmt = x[31];\n    v->shared.l = shared_len;\n    v->indiv.l = indiv_len;\n    // silent fix of broken BCFs produced by earlier versions of bcf_subset, prior to and including bd6ed8b4\n    if ( (!v->indiv.l || !v->n_sample) && v->n_fmt ) v->n_fmt = 0;\n\n    if (bgzf_read(fp, v->shared.s, v->shared.l) != v->shared.l) return -2;\n    if (bgzf_read(fp, v->indiv.s, v->indiv.l) != v->indiv.l) return -2;\n    return 0;\n}\n\n#define bit_array_size(n) ((n)/8+1)\n#define bit_array_set(a,i)   ((a)[(i)/8] |=   1 << ((i)%8))\n#define bit_array_clear(a,i) ((a)[(i)/8] &= ~(1 << ((i)%8)))\n#define bit_array_test(a,i)  ((a)[(i)/8] &   (1 << ((i)%8)))\n\nstatic int bcf_dec_typed_int1_safe(uint8_t *p, uint8_t *end, uint8_t **q,\n                                   int32_t *val) {\n    uint32_t t;\n    if (end - p < 2) return -1;\n    t = *p++ & 0xf;\n    /* Use if .. else if ... else instead of switch to force order.  Assumption\n       is that small integers are more frequent than big ones. */\n    if (t == BCF_BT_INT8) {\n        *q = p + 1;\n        *val = *(int8_t *) p;\n    } else if (t == BCF_BT_INT16) {\n        if (end - p < 2) return -1;\n        *q = p + 2;\n        *val = le_to_i16(p);\n    } else if (t == BCF_BT_INT32) {\n        if (end - p < 4) return -1;\n        *q = p + 4;\n        *val = le_to_i32(p);\n#ifdef VCF_ALLOW_INT64\n    } else if (t == BCF_BT_INT64) {\n        // This case should never happen because there should be no 64-bit BCFs\n        // at all, definitely not coming from htslib\n        if (end - p < 8) return -1;\n        *q = p + 8;\n        *val = le_to_i64(p);\n#endif\n    } else {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int bcf_dec_size_safe(uint8_t *p, uint8_t *end, uint8_t **q,\n                             int *num, int *type) {\n    int r;\n    if (p >= end) return -1;\n    *type = *p & 0xf;\n    if (*p>>4 != 15) {\n        *q = p + 1;\n        *num = *p >> 4;\n        return 0;\n    }\n    r = bcf_dec_typed_int1_safe(p + 1, end, q, num);\n    if (r) return r;\n    return *num >= 0 ? 0 : -1;\n}\n\nstatic const char *get_type_name(int type) {\n    const char *types[9] = {\n        \"null\", \"int (8-bit)\", \"int (16 bit)\", \"int (32 bit)\",\n        \"unknown\", \"float\", \"unknown\", \"char\", \"unknown\"\n    };\n    int t = (type >= 0 && type < 8) ? type : 8;\n    return types[t];\n}\n\nstatic int bcf_record_check(const bcf_hdr_t *hdr, bcf1_t *rec) {\n    uint8_t *ptr, *end;\n    size_t bytes;\n    uint32_t err = 0;\n    int type = 0;\n    int num  = 0;\n    int reflen = 0;\n    uint32_t i, reports;\n    const uint32_t is_integer = ((1 << BCF_BT_INT8)  |\n                                 (1 << BCF_BT_INT16) |\n#ifdef VCF_ALLOW_INT64\n                                 (1 << BCF_BT_INT64) |\n#endif\n                                 (1 << BCF_BT_INT32));\n    const uint32_t is_valid_type = (is_integer          |\n                                    (1 << BCF_BT_NULL)  |\n                                    (1 << BCF_BT_FLOAT) |\n                                    (1 << BCF_BT_CHAR));\n    int32_t max_id = hdr ? hdr->n[BCF_DT_ID] : 0;\n\n    // Check for valid contig ID\n    if (rec->rid < 0\n        || (hdr && (rec->rid >= hdr->n[BCF_DT_CTG]\n                    || hdr->id[BCF_DT_CTG][rec->rid].key == NULL))) {\n        hts_log_warning(\"Bad BCF record at %\"PRIhts_pos\": Invalid %s id %d\", rec->pos+1, \"CONTIG\", rec->rid);\n        err |= BCF_ERR_CTG_INVALID;\n    }\n\n    // Check ID\n    ptr = (uint8_t *) rec->shared.s;\n    end = ptr + rec->shared.l;\n    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n    if (type != BCF_BT_CHAR) {\n        hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"ID\", type, get_type_name(type));\n        err |= BCF_ERR_TAG_INVALID;\n    }\n    bytes = (size_t) num << bcf_type_shift[type];\n    if (end - ptr < bytes) goto bad_shared;\n    ptr += bytes;\n\n    // Check REF and ALT\n    reports = 0;\n    for (i = 0; i < rec->n_allele; i++) {\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n        if (type != BCF_BT_CHAR) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"REF/ALT\", type, get_type_name(type));\n            err |= BCF_ERR_CHAR;\n        }\n        if (i == 0) reflen = num;\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (end - ptr < bytes) goto bad_shared;\n        ptr += bytes;\n    }\n\n    // Check FILTER\n    reports = 0;\n    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n    if (num > 0) {\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (((1 << type) & is_integer) == 0) {\n            hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FILTER\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n            if (end - ptr < bytes) goto bad_shared;\n            ptr += bytes;\n        } else {\n            if (end - ptr < bytes) goto bad_shared;\n            for (i = 0; i < num; i++) {\n                int32_t key = bcf_dec_int1(ptr, type, &ptr);\n                if (key < 0\n                    || (hdr && (key >= max_id\n                                || hdr->id[BCF_DT_ID][key].key == NULL))) {\n                    if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                        hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FILTER\", key);\n                    err |= BCF_ERR_TAG_UNDEF;\n                }\n            }\n        }\n    }\n\n    // Check INFO\n    reports = 0;\n    for (i = 0; i < rec->n_info; i++) {\n        int32_t key = -1;\n        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_shared;\n        if (key < 0 || (hdr && (key >= max_id\n                                || hdr->id[BCF_DT_ID][key].key == NULL))) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"INFO\", key);\n            err |= BCF_ERR_TAG_UNDEF;\n        }\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n        if (((1 << type) & is_valid_type) == 0) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"INFO\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n        }\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (end - ptr < bytes) goto bad_shared;\n        ptr += bytes;\n    }\n\n    // Check FORMAT and individual information\n    ptr = (uint8_t *) rec->indiv.s;\n    end = ptr + rec->indiv.l;\n    reports = 0;\n    for (i = 0; i < rec->n_fmt; i++) {\n        int32_t key = -1;\n        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_indiv;\n        if (key < 0\n            || (hdr && (key >= max_id\n                        || hdr->id[BCF_DT_ID][key].key == NULL))) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FORMAT\", key);\n            err |= BCF_ERR_TAG_UNDEF;\n        }\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_indiv;\n        if (((1 << type) & is_valid_type) == 0) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FORMAT\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n        }\n        bytes = ((size_t) num << bcf_type_shift[type]) * rec->n_sample;\n        if (end - ptr < bytes) goto bad_indiv;\n        ptr += bytes;\n    }\n\n    if (!err && rec->rlen < 0) {\n        // Treat bad rlen as a warning instead of an error, and try to\n        // fix up by using the length of the stored REF allele.\n        static int warned = 0;\n        if (!warned) {\n            hts_log_warning(\"BCF record at %s:%\"PRIhts_pos\" has invalid RLEN (%\"PRIhts_pos\"). \"\n                            \"Only one invalid RLEN will be reported.\",\n                            bcf_seqname_safe(hdr,rec), rec->pos+1, rec->rlen);\n            warned = 1;\n        }\n        rec->rlen = reflen >= 0 ? reflen : 0;\n    }\n\n    rec->errcode |= err;\n\n    return err ? -2 : 0; // Return -2 so bcf_read() reports an error\n\n bad_shared:\n    hts_log_error(\"Bad BCF record at %s:%\"PRIhts_pos\" - shared section malformed or too short\", bcf_seqname_safe(hdr,rec), rec->pos+1);\n    return -2;\n\n bad_indiv:\n    hts_log_error(\"Bad BCF record at %s:%\"PRIhts_pos\" - individuals section malformed or too short\", bcf_seqname_safe(hdr,rec), rec->pos+1);\n    return -2;\n}\n\nstatic inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt);\nint bcf_subset_format(const bcf_hdr_t *hdr, bcf1_t *rec)\n{\n    if ( !hdr->keep_samples ) return 0;\n    if ( !bcf_hdr_nsamples(hdr) )\n    {\n        rec->indiv.l = rec->n_sample = 0;\n        return 0;\n    }\n\n    int i, j;\n    uint8_t *ptr = (uint8_t*)rec->indiv.s, *dst = NULL, *src;\n    bcf_dec_t *dec = &rec->d;\n    hts_expand(bcf_fmt_t, rec->n_fmt, dec->m_fmt, dec->fmt);\n    for (i=0; i<dec->m_fmt; ++i) dec->fmt[i].p_free = 0;\n\n    for (i=0; i<rec->n_fmt; i++)\n    {\n        ptr = bcf_unpack_fmt_core1(ptr, rec->n_sample, &dec->fmt[i]);\n        src = dec->fmt[i].p - dec->fmt[i].size;\n        if ( dst )\n        {\n            memmove(dec->fmt[i-1].p + dec->fmt[i-1].p_len, dec->fmt[i].p - dec->fmt[i].p_off, dec->fmt[i].p_off);\n            dec->fmt[i].p = dec->fmt[i-1].p + dec->fmt[i-1].p_len + dec->fmt[i].p_off;\n        }\n        dst = dec->fmt[i].p;\n        for (j=0; j<hdr->nsamples_ori; j++)\n        {\n            src += dec->fmt[i].size;\n            if ( !bit_array_test(hdr->keep_samples,j) ) continue;\n            memmove(dst, src, dec->fmt[i].size);\n            dst += dec->fmt[i].size;\n        }\n        rec->indiv.l -= dec->fmt[i].p_len - (dst - dec->fmt[i].p);\n        dec->fmt[i].p_len = dst - dec->fmt[i].p;\n    }\n    rec->unpacked |= BCF_UN_FMT;\n\n    rec->n_sample = bcf_hdr_nsamples(hdr);\n    return 0;\n}\n\nint bcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    if (fp->format.format == vcf) return vcf_read(fp,h,v);\n    int ret = bcf_read1_core(fp->fp.bgzf, v);\n    if (ret == 0) ret = bcf_record_check(h, v);\n    if ( ret!=0 || !h->keep_samples ) return ret;\n    return bcf_subset_format(h,v);\n}\n\nint bcf_readrec(BGZF *fp, void *null, void *vv, int *tid, hts_pos_t *beg, hts_pos_t *end)\n{\n    bcf1_t *v = (bcf1_t *) vv;\n    int ret = bcf_read1_core(fp, v);\n    if (ret == 0) ret = bcf_record_check(NULL, v);\n    if (ret  >= 0)\n        *tid = v->rid, *beg = v->pos, *end = v->pos + v->rlen;\n    return ret;\n}\n\nstatic inline int bcf1_sync_id(bcf1_t *line, kstring_t *str)\n{\n    // single typed string\n    if ( line->d.id && strcmp(line->d.id, \".\") ) {\n        return bcf_enc_vchar(str, strlen(line->d.id), line->d.id);\n    } else {\n        return bcf_enc_size(str, 0, BCF_BT_CHAR);\n    }\n}\nstatic inline int bcf1_sync_alleles(bcf1_t *line, kstring_t *str)\n{\n    // list of typed strings\n    int i;\n    for (i=0; i<line->n_allele; i++) {\n        if (bcf_enc_vchar(str, strlen(line->d.allele[i]), line->d.allele[i]) < 0)\n            return -1;\n    }\n    if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);\n    return 0;\n}\nstatic inline int bcf1_sync_filter(bcf1_t *line, kstring_t *str)\n{\n    // typed vector of integers\n    if ( line->d.n_flt ) {\n        return bcf_enc_vint(str, line->d.n_flt, line->d.flt, -1);\n    } else {\n        return bcf_enc_vint(str, 0, 0, -1);\n    }\n}\n\nstatic inline int bcf1_sync_info(bcf1_t *line, kstring_t *str)\n{\n    // pairs of typed vectors\n    int i, irm = -1, e = 0;\n    for (i=0; i<line->n_info; i++)\n    {\n        bcf_info_t *info = &line->d.info[i];\n        if ( !info->vptr )\n        {\n            // marked for removal\n            if ( irm < 0 ) irm = i;\n            continue;\n        }\n        e |= kputsn_(info->vptr - info->vptr_off, info->vptr_len + info->vptr_off, str) < 0;\n        if ( irm >=0 )\n        {\n            bcf_info_t tmp = line->d.info[irm]; line->d.info[irm] = line->d.info[i]; line->d.info[i] = tmp;\n            while ( irm<=i && line->d.info[irm].vptr ) irm++;\n        }\n    }\n    if ( irm>=0 ) line->n_info = irm;\n    return e == 0 ? 0 : -1;\n}\n\nstatic int bcf1_sync(bcf1_t *line)\n{\n    char *shared_ori = line->shared.s;\n    size_t prev_len;\n\n    kstring_t tmp = {0,0,0};\n    if ( !line->shared.l )\n    {\n        // New line created via API, BCF data blocks do not exist. Get it ready for BCF output\n        tmp = line->shared;\n        bcf1_sync_id(line, &tmp);\n        line->unpack_size[0] = tmp.l; prev_len = tmp.l;\n\n        bcf1_sync_alleles(line, &tmp);\n        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;\n\n        bcf1_sync_filter(line, &tmp);\n        line->unpack_size[2] = tmp.l - prev_len;\n\n        bcf1_sync_info(line, &tmp);\n        line->shared = tmp;\n    }\n    else if ( line->d.shared_dirty )\n    {\n        // The line was edited, update the BCF data block.\n\n        if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line,BCF_UN_STR);\n\n        // ptr_ori points to the original unchanged BCF data.\n        uint8_t *ptr_ori = (uint8_t *) line->shared.s;\n\n        // ID: single typed string\n        if ( line->d.shared_dirty & BCF1_DIRTY_ID )\n            bcf1_sync_id(line, &tmp);\n        else\n            kputsn_(ptr_ori, line->unpack_size[0], &tmp);\n        ptr_ori += line->unpack_size[0];\n        line->unpack_size[0] = tmp.l; prev_len = tmp.l;\n\n        // REF+ALT: list of typed strings\n        if ( line->d.shared_dirty & BCF1_DIRTY_ALS )\n            bcf1_sync_alleles(line, &tmp);\n        else\n        {\n            kputsn_(ptr_ori, line->unpack_size[1], &tmp);\n            if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);\n        }\n        ptr_ori += line->unpack_size[1];\n        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;\n\n        if ( line->unpacked & BCF_UN_FLT )\n        {\n            // FILTER: typed vector of integers\n            if ( line->d.shared_dirty & BCF1_DIRTY_FLT )\n                bcf1_sync_filter(line, &tmp);\n            else if ( line->d.n_flt )\n                kputsn_(ptr_ori, line->unpack_size[2], &tmp);\n            else\n                bcf_enc_vint(&tmp, 0, 0, -1);\n            ptr_ori += line->unpack_size[2];\n            line->unpack_size[2] = tmp.l - prev_len;\n\n            if ( line->unpacked & BCF_UN_INFO )\n            {\n                // INFO: pairs of typed vectors\n                if ( line->d.shared_dirty & BCF1_DIRTY_INF )\n                {\n                    bcf1_sync_info(line, &tmp);\n                    ptr_ori = (uint8_t*)line->shared.s + line->shared.l;\n                }\n            }\n        }\n\n        int size = line->shared.l - (size_t)ptr_ori + (size_t)line->shared.s;\n        if ( size ) kputsn_(ptr_ori, size, &tmp);\n\n        free(line->shared.s);\n        line->shared = tmp;\n    }\n    if ( line->shared.s != shared_ori && line->unpacked & BCF_UN_INFO )\n    {\n        // Reallocated line->shared.s block invalidated line->d.info[].vptr pointers\n        size_t off_new = line->unpack_size[0] + line->unpack_size[1] + line->unpack_size[2];\n        int i;\n        for (i=0; i<line->n_info; i++)\n        {\n            uint8_t *vptr_free = line->d.info[i].vptr_free ? line->d.info[i].vptr - line->d.info[i].vptr_off : NULL;\n            line->d.info[i].vptr = (uint8_t*) line->shared.s + off_new + line->d.info[i].vptr_off;\n            off_new += line->d.info[i].vptr_len + line->d.info[i].vptr_off;\n            if ( vptr_free )\n            {\n                free(vptr_free);\n                line->d.info[i].vptr_free = 0;\n            }\n        }\n    }\n\n    if ( line->n_sample && line->n_fmt && (!line->indiv.l || line->d.indiv_dirty) )\n    {\n        // The genotype fields changed or are not present\n        tmp.l = tmp.m = 0; tmp.s = NULL;\n        int i, irm = -1;\n        for (i=0; i<line->n_fmt; i++)\n        {\n            bcf_fmt_t *fmt = &line->d.fmt[i];\n            if ( !fmt->p )\n            {\n                // marked for removal\n                if ( irm < 0 ) irm = i;\n                continue;\n            }\n            kputsn_(fmt->p - fmt->p_off, fmt->p_len + fmt->p_off, &tmp);\n            if ( irm >=0 )\n            {\n                bcf_fmt_t tfmt = line->d.fmt[irm]; line->d.fmt[irm] = line->d.fmt[i]; line->d.fmt[i] = tfmt;\n                while ( irm<=i && line->d.fmt[irm].p ) irm++;\n            }\n\n        }\n        if ( irm>=0 ) line->n_fmt = irm;\n        free(line->indiv.s);\n        line->indiv = tmp;\n\n        // Reallocated line->indiv.s block invalidated line->d.fmt[].p pointers\n        size_t off_new = 0;\n        for (i=0; i<line->n_fmt; i++)\n        {\n            uint8_t *p_free = line->d.fmt[i].p_free ? line->d.fmt[i].p - line->d.fmt[i].p_off : NULL;\n            line->d.fmt[i].p = (uint8_t*) line->indiv.s + off_new + line->d.fmt[i].p_off;\n            off_new += line->d.fmt[i].p_len + line->d.fmt[i].p_off;\n            if ( p_free )\n            {\n                free(p_free);\n                line->d.fmt[i].p_free = 0;\n            }\n        }\n    }\n    if ( !line->n_sample ) line->n_fmt = 0;\n    line->d.shared_dirty = line->d.indiv_dirty = 0;\n    return 0;\n}\n\nbcf1_t *bcf_copy(bcf1_t *dst, bcf1_t *src)\n{\n    bcf1_sync(src);\n\n    bcf_clear(dst);\n    dst->rid  = src->rid;\n    dst->pos  = src->pos;\n    dst->rlen = src->rlen;\n    dst->qual = src->qual;\n    dst->n_info = src->n_info; dst->n_allele = src->n_allele;\n    dst->n_fmt = src->n_fmt; dst->n_sample = src->n_sample;\n\n    if ( dst->shared.m < src->shared.l )\n    {\n        dst->shared.s = (char*) realloc(dst->shared.s, src->shared.l);\n        dst->shared.m = src->shared.l;\n    }\n    dst->shared.l = src->shared.l;\n    memcpy(dst->shared.s,src->shared.s,dst->shared.l);\n\n    if ( dst->indiv.m < src->indiv.l )\n    {\n        dst->indiv.s = (char*) realloc(dst->indiv.s, src->indiv.l);\n        dst->indiv.m = src->indiv.l;\n    }\n    dst->indiv.l = src->indiv.l;\n    memcpy(dst->indiv.s,src->indiv.s,dst->indiv.l);\n\n    return dst;\n}\nbcf1_t *bcf_dup(bcf1_t *src)\n{\n    bcf1_t *out = bcf_init1();\n    return bcf_copy(out, src);\n}\n\nint bcf_write(htsFile *hfp, bcf_hdr_t *h, bcf1_t *v)\n{\n    if ( h->dirty ) {\n        if (bcf_hdr_sync(h) < 0) return -1;\n    }\n    if ( bcf_hdr_nsamples(h)!=v->n_sample )\n    {\n        hts_log_error(\"Broken VCF record, the number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n        return -1;\n    }\n\n    if ( hfp->format.format == vcf || hfp->format.format == text_format )\n        return vcf_write(hfp,h,v);\n\n    if ( v->errcode )\n    {\n        // vcf_parse1() encountered a new contig or tag, undeclared in the\n        // header.  At this point, the header must have been printed,\n        // proceeding would lead to a broken BCF file. Errors must be checked\n        // and cleared by the caller before we can proceed.\n        hts_log_error(\"Unchecked error (%d) at %s:%\"PRIhts_pos, v->errcode, bcf_seqname_safe(h,v), v->pos+1);\n        return -1;\n    }\n    bcf1_sync(v);   // check if the BCF record was modified\n\n    if ( v->unpacked & BCF_IS_64BIT )\n    {\n        hts_log_error(\"Data at %s:%\"PRIhts_pos\" contains 64-bit values not representable in BCF. Please use VCF instead\", bcf_seqname_safe(h,v), v->pos+1);\n        return -1;\n    }\n\n    BGZF *fp = hfp->fp.bgzf;\n    uint8_t x[32];\n    u32_to_le(v->shared.l + 24, x); // to include six 32-bit integers\n    u32_to_le(v->indiv.l, x + 4);\n    i32_to_le(v->rid, x + 8);\n    u32_to_le(v->pos, x + 12);\n    u32_to_le(v->rlen, x + 16);\n    float_to_le(v->qual, x + 20);\n    u16_to_le(v->n_info, x + 24);\n    u16_to_le(v->n_allele, x + 26);\n    u32_to_le((uint32_t)v->n_fmt<<24 | (v->n_sample & 0xffffff), x + 28);\n    if ( bgzf_write(fp, x, 32) != 32 ) return -1;\n    if ( bgzf_write(fp, v->shared.s, v->shared.l) != v->shared.l ) return -1;\n    if ( bgzf_write(fp, v->indiv.s, v->indiv.l) != v->indiv.l ) return -1;\n\n    if (hfp->idx) {\n        if (hts_idx_push(hfp->idx, v->rid, v->pos, v->pos + v->rlen, bgzf_tell(fp), 1) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n/**********************\n *** VCF header I/O ***\n **********************/\n\nstatic int add_missing_contig_hrec(bcf_hdr_t *h, const char *name) {\n    bcf_hrec_t *hrec = calloc(1, sizeof(bcf_hrec_t));\n    int save_errno;\n    if (!hrec) goto fail;\n\n    hrec->key = strdup(\"contig\");\n    if (!hrec->key) goto fail;\n\n    if (bcf_hrec_add_key(hrec, \"ID\", strlen(\"ID\")) < 0) goto fail;\n    if (bcf_hrec_set_val(hrec, hrec->nkeys-1, name, strlen(name), 0) < 0)\n        goto fail;\n    if (bcf_hdr_add_hrec(h, hrec) < 0)\n        goto fail;\n    return 0;\n\n fail:\n    save_errno = errno;\n    hts_log_error(\"%s\", strerror(errno));\n    if (hrec) bcf_hrec_destroy(hrec);\n    errno = save_errno;\n    return -1;\n}\n\nbcf_hdr_t *vcf_hdr_read(htsFile *fp)\n{\n    kstring_t txt, *s = &fp->line;\n    int ret;\n    bcf_hdr_t *h;\n    tbx_t *idx = NULL;\n    const char **names = NULL;\n    h = bcf_hdr_init(\"r\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    txt.l = txt.m = 0; txt.s = 0;\n    while ((ret = hts_getline(fp, KS_SEP_LINE, s)) >= 0) {\n        int e = 0;\n        if (s->l == 0) continue;\n        if (s->s[0] != '#') {\n            hts_log_error(\"No sample line\");\n            goto error;\n        }\n        if (s->s[1] != '#' && fp->fn_aux) { // insert contigs here\n            kstring_t tmp = { 0, 0, NULL };\n            hFILE *f = hopen(fp->fn_aux, \"r\");\n            if (f == NULL) {\n                hts_log_error(\"Couldn't open \\\"%s\\\"\", fp->fn_aux);\n                goto error;\n            }\n            while (tmp.l = 0, kgetline(&tmp, (kgets_func *) hgets, f) >= 0) {\n                char *tab = strchr(tmp.s, '\\t');\n                if (tab == NULL) continue;\n                e |= (kputs(\"##contig=<ID=\", &txt) < 0);\n                e |= (kputsn(tmp.s, tab - tmp.s, &txt) < 0);\n                e |= (kputs(\",length=\", &txt) < 0);\n                e |= (kputl(atol(tab), &txt) < 0);\n                e |= (kputsn(\">\\n\", 2, &txt) < 0);\n            }\n            free(tmp.s);\n            if (hclose(f) != 0) {\n                hts_log_error(\"Error on closing %s\", fp->fn_aux);\n                goto error;\n            }\n            if (e) goto error;\n        }\n        if (kputsn(s->s, s->l, &txt) < 0) goto error;\n        if (kputc('\\n', &txt) < 0) goto error;\n        if (s->s[1] != '#') break;\n    }\n    if ( ret < -1 ) goto error;\n    if ( !txt.s )\n    {\n        hts_log_error(\"Could not read the header\");\n        goto error;\n    }\n    if ( bcf_hdr_parse(h, txt.s) < 0 ) goto error;\n\n    // check tabix index, are all contigs listed in the header? add the missing ones\n    idx = tbx_index_load3(fp->fn, NULL, HTS_IDX_SAVE_REMOTE|HTS_IDX_SILENT_FAIL);\n    if ( idx )\n    {\n        int i, n, need_sync = 0;\n        names = tbx_seqnames(idx, &n);\n        if (!names) goto error;\n        for (i=0; i<n; i++)\n        {\n            bcf_hrec_t *hrec = bcf_hdr_get_hrec(h, BCF_HL_CTG, \"ID\", (char*) names[i], NULL);\n            if ( hrec ) continue;\n            if (add_missing_contig_hrec(h, names[i]) < 0) goto error;\n            need_sync = 1;\n        }\n        if ( need_sync ) {\n            if (bcf_hdr_sync(h) < 0) goto error;\n        }\n        free(names);\n        tbx_destroy(idx);\n    }\n    free(txt.s);\n    return h;\n\n error:\n    if (idx) tbx_destroy(idx);\n    free(names);\n    free(txt.s);\n    if (h) bcf_hdr_destroy(h);\n    return NULL;\n}\n\nint bcf_hdr_set(bcf_hdr_t *hdr, const char *fname)\n{\n    int i = 0, n = 0, save_errno;\n    char **lines = hts_readlines(fname, &n);\n    if ( !lines ) return 1;\n    for (i=0; i<n-1; i++)\n    {\n        int k;\n        bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,lines[i],&k);\n        if (!hrec) goto fail;\n        if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n            bcf_hrec_destroy(hrec);\n            goto fail;\n        }\n        free(lines[i]);\n        lines[i] = NULL;\n    }\n    if (bcf_hdr_parse_sample_line(hdr, lines[n-1]) < 0) goto fail;\n    if (bcf_hdr_sync(hdr) < 0) goto fail;\n    free(lines[n-1]);\n    free(lines);\n    return 0;\n\n fail:\n    save_errno = errno;\n    for (; i < n; i++)\n        free(lines[i]);\n    free(lines);\n    errno = save_errno;\n    return 1;\n}\n\nstatic int _bcf_hrec_format(const bcf_hrec_t *hrec, int is_bcf, kstring_t *str)\n{\n    uint32_t e = 0;\n    if ( !hrec->value )\n    {\n        int j, nout = 0;\n        e |= ksprintf(str, \"##%s=<\", hrec->key) < 0;\n        for (j=0; j<hrec->nkeys; j++)\n        {\n            // do not output IDX if output is VCF\n            if ( !is_bcf && !strcmp(\"IDX\",hrec->keys[j]) ) continue;\n            if ( nout ) e |= kputc(',',str) < 0;\n            e |= ksprintf(str,\"%s=%s\", hrec->keys[j], hrec->vals[j]) < 0;\n            nout++;\n        }\n        e |= ksprintf(str,\">\\n\") < 0;\n    }\n    else\n        e |= ksprintf(str,\"##%s=%s\\n\", hrec->key,hrec->value) < 0;\n\n    return e == 0 ? 0 : -1;\n}\n\nint bcf_hrec_format(const bcf_hrec_t *hrec, kstring_t *str)\n{\n    return _bcf_hrec_format(hrec,0,str);\n}\n\nint bcf_hdr_format(const bcf_hdr_t *hdr, int is_bcf, kstring_t *str)\n{\n    int i;\n    for (i=0; i<hdr->nhrec; i++)\n        _bcf_hrec_format(hdr->hrec[i], is_bcf, str);\n\n    ksprintf(str, \"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\");\n    if ( bcf_hdr_nsamples(hdr) )\n    {\n        ksprintf(str, \"\\tFORMAT\");\n        for (i=0; i<bcf_hdr_nsamples(hdr); i++)\n            ksprintf(str, \"\\t%s\", hdr->samples[i]);\n    }\n    ksprintf(str, \"\\n\");\n\n    return 0;\n}\n\nchar *bcf_hdr_fmt_text(const bcf_hdr_t *hdr, int is_bcf, int *len)\n{\n    kstring_t txt = {0,0,0};\n    bcf_hdr_format(hdr, is_bcf, &txt);\n    if ( len ) *len = txt.l;\n    return txt.s;\n}\n\nconst char **bcf_hdr_seqnames(const bcf_hdr_t *h, int *n)\n{\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];\n    int tid, m = kh_size(d);\n    const char **names = (const char**) calloc(m,sizeof(const char*));\n    khint_t k;\n    for (k=kh_begin(d); k<kh_end(d); k++)\n    {\n        if ( !kh_exist(d,k) ) continue;\n        tid = kh_val(d,k).id;\n        assert( tid<m );\n        names[tid] = kh_key(d,k);\n    }\n    // sanity check: there should be no gaps\n    for (tid=0; tid<m; tid++)\n        assert(names[tid]);\n    *n = m;\n    return names;\n}\n\nint vcf_hdr_write(htsFile *fp, const bcf_hdr_t *h)\n{\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(h, 0, &htxt);\n    while (htxt.l && htxt.s[htxt.l-1] == '\\0') --htxt.l; // kill trailing zeros\n    int ret;\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, htxt.s, htxt.l);\n    else\n        ret = hwrite(fp->fp.hfile, htxt.s, htxt.l);\n    free(htxt.s);\n    return ret<0 ? -1 : 0;\n}\n\n/***********************\n *** Typed value I/O ***\n ***********************/\n\nint bcf_enc_vint(kstring_t *s, int n, int32_t *a, int wsize)\n{\n    int32_t max = INT32_MIN, min = INT32_MAX;\n    int i;\n    if (n <= 0) bcf_enc_size(s, 0, BCF_BT_NULL);\n    else if (n == 1) bcf_enc_int1(s, a[0]);\n    else {\n        if (wsize <= 0) wsize = n;\n        for (i = 0; i < n; ++i) {\n            if (a[i] == bcf_int32_missing || a[i] == bcf_int32_vector_end ) continue;\n            if (max < a[i]) max = a[i];\n            if (min > a[i]) min = a[i];\n        }\n        if (max <= BCF_MAX_BT_INT8 && min >= BCF_MIN_BT_INT8) {\n            bcf_enc_size(s, wsize, BCF_BT_INT8);\n            for (i = 0; i < n; ++i)\n                if ( a[i]==bcf_int32_vector_end ) kputc(bcf_int8_vector_end, s);\n                else if ( a[i]==bcf_int32_missing ) kputc(bcf_int8_missing, s);\n                else kputc(a[i], s);\n        } else if (max <= BCF_MAX_BT_INT16 && min >= BCF_MIN_BT_INT16) {\n            uint8_t *p;\n            bcf_enc_size(s, wsize, BCF_BT_INT16);\n            ks_resize(s, s->l + n * sizeof(int16_t));\n            p = (uint8_t *) s->s + s->l;\n            for (i = 0; i < n; ++i)\n            {\n                int16_t x;\n                if ( a[i]==bcf_int32_vector_end ) x = bcf_int16_vector_end;\n                else if ( a[i]==bcf_int32_missing ) x = bcf_int16_missing;\n                else x = a[i];\n                i16_to_le(x, p);\n                p += sizeof(int16_t);\n            }\n            s->l += n * sizeof(int16_t);\n        } else {\n            uint8_t *p;\n            bcf_enc_size(s, wsize, BCF_BT_INT32);\n            ks_resize(s, s->l + n * sizeof(int32_t));\n            p = (uint8_t *) s->s + s->l;\n            for (i = 0; i < n; ++i) {\n                i32_to_le(a[i], p);\n                p += sizeof(int32_t);\n            }\n            s->l += n * sizeof(int32_t);\n        }\n    }\n\n    return 0; // FIXME: check for errs in this function\n}\n\n#ifdef VCF_ALLOW_INT64\nstatic int bcf_enc_long1(kstring_t *s, int64_t x) {\n    uint32_t e = 0;\n    if (x <= BCF_MAX_BT_INT32 && x >= BCF_MIN_BT_INT32)\n        return bcf_enc_int1(s, x);\n    if (x == bcf_int64_vector_end) {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT8);\n        e |= kputc(bcf_int8_vector_end, s) < 0;\n    } else if (x == bcf_int64_missing) {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT8);\n        e |= kputc(bcf_int8_missing, s) < 0;\n    } else {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT64);\n        e |= ks_expand(s, 8);\n        if (e == 0) { u64_to_le(x, (uint8_t *) s->s + s->l); s->l += 8; }\n    }\n    return e == 0 ? 0 : -1;\n}\n#endif\n\nstatic inline int serialize_float_array(kstring_t *s, size_t n, const float *a) {\n    uint8_t *p;\n    size_t i;\n    size_t bytes = n * sizeof(float);\n\n    if (bytes / sizeof(float) != n) return -1;\n    if (ks_resize(s, s->l + bytes) < 0) return -1;\n\n    p = (uint8_t *) s->s + s->l;\n    for (i = 0; i < n; i++) {\n        float_to_le(a[i], p);\n        p += sizeof(float);\n    }\n    s->l += bytes;\n\n    return 0;\n}\n\nint bcf_enc_vfloat(kstring_t *s, int n, float *a)\n{\n    assert(n >= 0);\n    bcf_enc_size(s, n, BCF_BT_FLOAT);\n    serialize_float_array(s, n, a);\n    return 0; // FIXME: check for errs in this function\n}\n\nint bcf_enc_vchar(kstring_t *s, int l, const char *a)\n{\n    bcf_enc_size(s, l, BCF_BT_CHAR);\n    kputsn(a, l, s);\n    return 0; // FIXME: check for errs in this function\n}\n\nint bcf_fmt_array(kstring_t *s, int n, int type, void *data)\n{\n    int j = 0;\n    uint32_t e = 0;\n    if (n == 0) {\n        return kputc('.', s) >= 0 ? 0 : -1;\n    }\n    if (type == BCF_BT_CHAR)\n    {\n        char *p = (char*)data;\n        for (j = 0; j < n && *p; ++j, ++p)\n        {\n            if ( *p==bcf_str_missing ) e |= kputc('.', s) < 0;\n            else e |= kputc(*p, s) < 0;\n        }\n    }\n    else\n    {\n        #define BRANCH(type_t, convert, is_missing, is_vector_end, kprint) { \\\n            uint8_t *p = (uint8_t *) data; \\\n            for (j=0; j<n; j++, p += sizeof(type_t))    \\\n            { \\\n                type_t v = convert(p); \\\n                if ( is_vector_end ) break; \\\n                if ( j ) kputc(',', s); \\\n                if ( is_missing ) kputc('.', s); \\\n                else e |= kprint < 0; \\\n            } \\\n        }\n        switch (type) {\n            case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, v==bcf_int8_missing,  v==bcf_int8_vector_end,  kputw(v, s)); break;\n            case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, v==bcf_int16_missing, v==bcf_int16_vector_end, kputw(v, s)); break;\n            case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, v==bcf_int32_missing, v==bcf_int32_vector_end, kputw(v, s)); break;\n            case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, v==bcf_float_missing, v==bcf_float_vector_end, kputd(le_to_float(p), s)); break;\n            default: hts_log_error(\"Unexpected type %d\", type); exit(1); break;\n        }\n        #undef BRANCH\n    }\n    return e == 0 ? 0 : -1;\n}\n\nuint8_t *bcf_fmt_sized_array(kstring_t *s, uint8_t *ptr)\n{\n    int x, type;\n    x = bcf_dec_size(ptr, &ptr, &type);\n    bcf_fmt_array(s, x, type, ptr);\n    return ptr + (x << bcf_type_shift[type]);\n}\n\n/********************\n *** VCF site I/O ***\n ********************/\n\ntypedef struct {\n    int key, max_m, size, offset;\n    uint32_t is_gt:1, max_g:31;\n    uint32_t max_l;\n    uint32_t y;\n    uint8_t *buf;\n} fmt_aux_t;\n\nstatic inline int align_mem(kstring_t *s)\n{\n    int e = 0;\n    if (s->l&7) {\n        uint64_t zero = 0;\n        e = kputsn((char*)&zero, 8 - (s->l&7), s) < 0;\n    }\n    return e == 0 ? 0 : -1;\n}\n\n// p,q is the start and the end of the FORMAT field\n#define MAX_N_FMT 255   /* Limited by size of bcf1_t n_fmt field */\nstatic int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)\n{\n    if ( !bcf_hdr_nsamples(h) ) return 0;\n\n    static int extreme_val_warned = 0;\n    char *r, *t;\n    int j, l, m, g, overflow = 0;\n    khint_t k;\n    ks_tokaux_t aux1;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    kstring_t *mem = (kstring_t*)&h->mem;\n    fmt_aux_t fmt[MAX_N_FMT];\n    mem->l = 0;\n\n    char *end = s->s + s->l;\n    if ( q>=end )\n    {\n        hts_log_error(\"FORMAT column with no sample columns starting at %s:%\"PRIhts_pos\"\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n\n    v->n_fmt = 0;\n    if ( p[0]=='.' && p[1]==0 ) // FORMAT field is empty \".\"\n    {\n        v->n_sample = bcf_hdr_nsamples(h);\n        return 0;\n    }\n\n    // get format information from the dictionary\n    for (j = 0, t = kstrtok(p, \":\", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {\n        if (j >= MAX_N_FMT) {\n            v->errcode |= BCF_ERR_LIMITS;\n            hts_log_error(\"FORMAT column at %s:%\"PRIhts_pos\" lists more identifiers than htslib can handle\",\n                bcf_seqname_safe(h,v), v->pos+1);\n            return -1;\n        }\n\n        *(char*)aux1.p = 0;\n        k = kh_get(vdict, d, t);\n        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {\n            if ( t[0]=='.' && t[1]==0 )\n            {\n                hts_log_error(\"Invalid FORMAT tag name '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n            hts_log_warning(\"FORMAT '%s' at %s:%\"PRIhts_pos\" is not defined in the header, assuming Type=String\", t, bcf_seqname_safe(h,v), v->pos+1);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", t);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n\n            k = kh_get(vdict, d, t);\n            v->errcode = BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for FORMAT '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n        }\n        fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;\n        fmt[j].key = kh_val(d, k).id;\n        fmt[j].is_gt = !strcmp(t, \"GT\");\n        fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT];\n        v->n_fmt++;\n    }\n    // compute max\n    int n_sample_ori = -1;\n    r = q + 1;  // r: position in the format string\n    l = 0, m = g = 1, v->n_sample = 0;  // m: max vector size, l: max field len, g: max number of alleles\n    while ( r<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *r!='\\t' && r<end ) r++;\n                if ( *r=='\\t' ) { *r = 0; r++; }\n                continue;\n            }\n        }\n\n        // collect fmt stats: max vector size, length, number of alleles\n        j = 0;  // j-th format field\n        fmt_aux_t *f = fmt;\n        for (;;) {\n            switch (*r) {\n            case ',':\n                m++;\n                break;\n\n            case '|':\n            case '/':\n                if (f->is_gt) g++;\n                break;\n\n            case '\\t':\n                *r = 0; // fall through\n\n            case '\\0':\n            case ':':\n                if (f->max_m < m) f->max_m = m;\n                if (f->max_l < l) f->max_l = l;\n                if (f->is_gt && f->max_g < g) f->max_g = g;\n                l = 0, m = g = 1;\n                if ( *r==':' ) {\n                    j++; f++;\n                    if ( j>=v->n_fmt ) {\n                        hts_log_error(\"Incorrect number of FORMAT fields at %s:%\"PRIhts_pos\"\",\n                                      h->id[BCF_DT_CTG][v->rid].key, v->pos+1);\n                        v->errcode |= BCF_ERR_NCOLS;\n                        return -1;\n                    }\n                } else goto end_for;\n                break;\n            }\n            if ( r>=end ) break;\n            r++; l++;\n        }\n    end_for:\n        v->n_sample++;\n        if ( v->n_sample == bcf_hdr_nsamples(h) ) break;\n        r++;\n    }\n\n    // allocate memory for arrays\n    for (j = 0; j < v->n_fmt; ++j) {\n        fmt_aux_t *f = &fmt[j];\n        if ( !f->max_m ) f->max_m = 1;  // omitted trailing format field\n        if ((f->y>>4&0xf) == BCF_HT_STR) {\n            f->size = f->is_gt? f->max_g << 2 : f->max_l;\n        } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {\n            f->size = f->max_m << 2;\n        } else\n        {\n            hts_log_error(\"The format type %d at %s:%\"PRIhts_pos\" is currently not supported\", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n        if (align_mem(mem) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        f->offset = mem->l;\n\n        // Limit the total memory to ~2Gb per VCF row.  This should mean\n        // malformed VCF data is less likely to take excessive memory and/or\n        // time.\n        if (v->n_sample * (uint64_t)f->size > INT_MAX) {\n            hts_log_error(\"Excessive memory required by FORMAT fields at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        mem->l += v->n_sample * f->size;\n    }\n    for (j = 0; j < v->n_fmt; ++j)\n        fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset;\n    // fill the sample fields; at beginning of the loop, t points to the first char of a format\n    n_sample_ori = -1;\n    t = q + 1; m = 0;   // m: sample id\n    while ( t<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *t && t<end ) t++;\n                t++;\n                continue;\n            }\n        }\n        if ( m == bcf_hdr_nsamples(h) ) break;\n\n        j = 0; // j-th format field, m-th sample\n        while ( t < end )\n        {\n            fmt_aux_t *z = &fmt[j++];\n            if (!z->buf) {\n                hts_log_error(\"Memory allocation failure for FORMAT field type %d at %s:%\"PRIhts_pos,\n                              z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_LIMITS;\n                return -1;\n            }\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) { // genotypes\n                    int32_t is_phased = 0;\n                    uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);\n                    uint32_t unreadable = 0;\n                    uint32_t max = 0;\n                    overflow = 0;\n                    for (l = 0;; ++t) {\n                        if (*t == '.') {\n                            ++t, x[l++] = is_phased;\n                        } else {\n                            char *tt = t;\n                            uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);\n                            unreadable |= tt == t;\n                            if (max < val) max = val;\n                            x[l++] = (val + 1) << 1 | is_phased;\n                        }\n                        is_phased = (*t == '|');\n                        if (*t != '|' && *t != '/') break;\n                    }\n                    // Possibly check max against v->n_allele instead?\n                    if (overflow || max > (INT32_MAX >> 1) - 1) {\n                        hts_log_error(\"Couldn't read GT data: value too large at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if (unreadable) {\n                        hts_log_error(\"Couldn't read GT data: value not a number or '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if ( !l ) x[l++] = 0;   // An empty field, insert missing value\n                    for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;\n                    for (; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.') {\n                        x[l++] = bcf_int32_missing, ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                        if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                        {\n                            if ( !extreme_val_warned )\n                            {\n                                hts_log_warning(\"Extreme FORMAT/%s value encountered and set to missing at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1);\n                                extreme_val_warned = 1;\n                            }\n                            tmp_val = bcf_int32_missing;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) x[l++] = bcf_int32_missing;\n                for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.' && !isdigit_c(t[1])) {\n                        bcf_float_set_missing(x[l++]), ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        float tmp_val = hts_str2dbl(t, &te, &overflow);\n                        if ( (te==t || overflow) && !extreme_val_warned )\n                        {\n                            hts_log_warning(\"Extreme FORMAT/%s value encountered at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1);\n                            extreme_val_warned = 1;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) bcf_float_set_missing(x[l++]);    // An empty field, insert missing value\n                for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            } else {\n                hts_log_error(\"Unknown FORMAT field type %d at %s:%\"PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n\n            if (*t == '\\0') {\n                break;\n            }\n            else if (*t == ':') {\n                t++;\n            }\n            else {\n                char buffer[8];\n                hts_log_error(\"Invalid character %s in '%s' FORMAT field at %s:%\"PRIhts_pos\"\",\n                    hts_strprint(buffer, sizeof buffer, '\\'', t, 1),\n                    h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_CHAR;\n                return -1;\n            }\n        }\n\n        for (; j < v->n_fmt; ++j) { // fill end-of-vector values\n            fmt_aux_t *z = &fmt[j];\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) {\n                    int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                    if (z->size) x[0] = bcf_int32_missing;\n                    for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    if ( z->size ) x[0] = '.';\n                    for (l = 1; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                x[0] = bcf_int32_missing;\n                for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                bcf_float_set_missing(x[0]);\n                for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            }\n        }\n\n        m++; t++;\n    }\n\n    // write individual genotype information\n    kstring_t *str = &v->indiv;\n    int i;\n    if (v->n_sample > 0) {\n        for (i = 0; i < v->n_fmt; ++i) {\n            fmt_aux_t *z = &fmt[i];\n            bcf_enc_int1(str, z->key);\n            if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {\n                bcf_enc_size(str, z->size, BCF_BT_CHAR);\n                kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);\n            } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {\n                bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);\n            } else {\n                bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);\n                if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,\n                                          (float *) z->buf) != 0) {\n                    v->errcode |= BCF_ERR_LIMITS;\n                    hts_log_error(\"Out of memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                    return -1;\n                }\n            }\n        }\n    }\n\n    if ( v->n_sample!=bcf_hdr_nsamples(h) )\n    {\n        hts_log_error(\"Number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n    if ( v->indiv.l > 0xffffffff )\n    {\n        hts_log_error(\"The FORMAT at %s:%\"PRIhts_pos\" is too long\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_LIMITS;\n\n        // Error recovery: return -1 if this is a critical error or 0 if we want to ignore the FORMAT and proceed\n        v->n_fmt = 0;\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic khint_t fix_chromosome(const bcf_hdr_t *h, vdict_t *d, const char *p) {\n    // Simple error recovery for chromosomes not defined in the header. It will not help when VCF header has\n    // been already printed, but will enable tools like vcfcheck to proceed.\n\n    kstring_t tmp = {0,0,0};\n    khint_t k;\n    int l;\n    ksprintf(&tmp, \"##contig=<ID=%s>\", p);\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n    free(tmp.s);\n    int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n    if (res < 0) bcf_hrec_destroy(hrec);\n    if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n    k = kh_get(vdict, d, p);\n\n    return k;\n}\n\nstatic int vcf_parse_filter(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {\n    int i, n_flt = 1, max_n_flt = 0;\n    char *r, *t;\n    int32_t *a_flt = NULL;\n    ks_tokaux_t aux1;\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    // count the number of filters\n    if (*(q-1) == ';') *(q-1) = 0;\n    for (r = p; *r; ++r)\n        if (*r == ';') ++n_flt;\n    if (n_flt > max_n_flt) {\n        a_flt = malloc(n_flt * sizeof(*a_flt));\n        if (!a_flt) {\n            hts_log_error(\"Could not allocate memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS; // No appropriate code?\n            return -1;\n        }\n        max_n_flt = n_flt;\n    }\n    // add filters\n    for (t = kstrtok(p, \";\", &aux1), i = 0; t; t = kstrtok(0, 0, &aux1)) {\n        *(char*)aux1.p = 0;\n        k = kh_get(vdict, d, t);\n        if (k == kh_end(d))\n        {\n            // Simple error recovery for FILTERs not defined in the header. It will not help when VCF header has\n            // been already printed, but will enable tools like vcfcheck to proceed.\n            hts_log_warning(\"FILTER '%s' is not defined in the header\", t);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##FILTER=<ID=%s,Description=\\\"Dummy\\\">\", t);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n            k = kh_get(vdict, d, t);\n            v->errcode |= BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for FILTER '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                free(a_flt);\n                return -1;\n            }\n        }\n        a_flt[i++] = kh_val(d, k).id;\n    }\n\n    bcf_enc_vint(str, n_flt, a_flt, -1);\n    free(a_flt);\n\n    return 0;\n}\n\nstatic int vcf_parse_info(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {\n    static int extreme_int_warned = 0, negative_rlen_warned = 0;\n    int max_n_val = 0, overflow = 0;\n    char *r, *key;\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    int32_t *a_val = NULL;\n\n    v->n_info = 0;\n    if (*(q-1) == ';') *(q-1) = 0;\n    for (r = key = p;; ++r) {\n        int c;\n        char *val, *end;\n        if (*r != ';' && *r != '=' && *r != 0) continue;\n        if (v->n_info == UINT16_MAX) {\n            hts_log_error(\"Too many INFO entries at %s:%\"PRIhts_pos,\n                          bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        val = end = 0;\n        c = *r; *r = 0;\n        if (c == '=') {\n            val = r + 1;\n            for (end = val; *end != ';' && *end != 0; ++end);\n            c = *end; *end = 0;\n        } else end = r;\n        if ( !*key ) { if (c==0) break; r = end; key = r + 1; continue; }  // faulty VCF, \";;\" in the INFO\n        k = kh_get(vdict, d, key);\n        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_INFO] == 15)\n        {\n            hts_log_warning(\"INFO '%s' is not defined in the header, assuming Type=String\", key);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##INFO=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", key);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n            k = kh_get(vdict, d, key);\n            v->errcode = BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for INFO '%s' at %s:%\"PRIhts_pos, key, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n        }\n        uint32_t y = kh_val(d, k).info[BCF_HL_INFO];\n        ++v->n_info;\n        bcf_enc_int1(str, kh_val(d, k).id);\n        if (val == 0) {\n            bcf_enc_size(str, 0, BCF_BT_NULL);\n        } else if ((y>>4&0xf) == BCF_HT_FLAG || (y>>4&0xf) == BCF_HT_STR) { // if Flag has a value, treat it as a string\n            bcf_enc_vchar(str, end - val, val);\n        } else { // int/float value/array\n            int i, n_val;\n            char *t, *te;\n            for (t = val, n_val = 1; *t; ++t) // count the number of values\n                if (*t == ',') ++n_val;\n            // Check both int and float size in one step for simplicity\n            if (n_val > max_n_val) {\n                int32_t *a_tmp = (int32_t *)realloc(a_val, n_val * sizeof(*a_val));\n                if (!a_tmp) {\n                    hts_log_error(\"Could not allocate memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                    v->errcode |= BCF_ERR_LIMITS; // No appropriate code?\n                    return -1;\n                }\n                a_val = a_tmp;\n                max_n_val = n_val;\n            }\n            if ((y>>4&0xf) == BCF_HT_INT) {\n                i = 0, t = val;\n                int64_t val1;\n                int is_int64 = 0;\n#ifdef VCF_ALLOW_INT64\n                if ( n_val==1 )\n                {\n                    overflow = 0;\n                    long long int tmp_val = hts_str2int(val, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                    if ( te==val ) tmp_val = bcf_int32_missing;\n                    else if ( overflow || tmp_val<BCF_MIN_BT_INT64 || tmp_val>BCF_MAX_BT_INT64 )\n                    {\n                        if ( !extreme_int_warned )\n                        {\n                            hts_log_warning(\"Extreme INFO/%s value encountered and set to missing at %s:%\"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);\n                            extreme_int_warned = 1;\n                        }\n                        tmp_val = bcf_int32_missing;\n                    }\n                    else\n                        is_int64 = 1;\n                    val1 = tmp_val;\n                    t = te;\n                    i = 1;  // this is just to avoid adding another nested block...\n                }\n#endif\n                for (; i < n_val; ++i, ++t)\n                {\n                    overflow = 0;\n                    long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                    if ( te==t ) tmp_val = bcf_int32_missing;\n                    else if ( overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                    {\n                        if ( !extreme_int_warned )\n                        {\n                            hts_log_warning(\"Extreme INFO/%s value encountered and set to missing at %s:%\"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);\n                            extreme_int_warned = 1;\n                        }\n                        tmp_val = bcf_int32_missing;\n                    }\n                    a_val[i] = tmp_val;\n                    for (t = te; *t && *t != ','; t++);\n                }\n                if (n_val == 1) {\n#ifdef VCF_ALLOW_INT64\n                    if ( is_int64 )\n                    {\n                        v->unpacked |= BCF_IS_64BIT;\n                        bcf_enc_long1(str, val1);\n                    }\n                    else\n                        bcf_enc_int1(str, (int32_t)val1);\n#else\n                    val1 = a_val[0];\n                    bcf_enc_int1(str, (int32_t)val1);\n#endif\n                } else {\n                    bcf_enc_vint(str, n_val, a_val, -1);\n                }\n                if (n_val==1 && (val1!=bcf_int32_missing || is_int64) && strcmp(key, \"END\") == 0)\n                {\n                    if ( val1 <= v->pos )\n                    {\n                        if ( !negative_rlen_warned )\n                        {\n                            hts_log_warning(\"INFO/END=%\"PRIhts_pos\" is smaller than POS at %s:%\"PRIhts_pos,val1,bcf_seqname_safe(h,v),v->pos+1);\n                            negative_rlen_warned = 1;\n                        }\n                    }\n                    else\n                        v->rlen = val1 - v->pos;\n                }\n            } else if ((y>>4&0xf) == BCF_HT_REAL) {\n                float *val_f = (float *)a_val;\n                for (i = 0, t = val; i < n_val; ++i, ++t)\n                {\n                    overflow = 0;\n                    val_f[i] = hts_str2dbl(t, &te, &overflow);\n                    if ( te==t || overflow ) // conversion failed\n                        bcf_float_set_missing(val_f[i]);\n                    for (t = te; *t && *t != ','; t++);\n                }\n                bcf_enc_vfloat(str, n_val, val_f);\n            }\n        }\n        if (c == 0) break;\n        r = end;\n        key = r + 1;\n    }\n\n    free(a_val);\n    return 0;\n}\n\nint vcf_parse(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int i = 0, ret = -2, overflow = 0;\n    char *p, *q, *r, *t;\n    kstring_t *str;\n    khint_t k;\n    ks_tokaux_t aux;\n\n    if (!s || !h || !v || !(s->s))\n        return ret;\n\n    // Assumed in lots of places, but we may as well spot this early\n    assert(sizeof(float) == sizeof(int32_t));\n\n    bcf_clear1(v);\n    str = &v->shared;\n    memset(&aux, 0, sizeof(ks_tokaux_t));\n    for (p = kstrtok(s->s, \"\\t\", &aux), i = 0; p; p = kstrtok(0, 0, &aux), ++i) {\n        q = (char*)aux.p;\n        *q = 0;\n        if (i == 0) { // CHROM\n            vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];\n            k = kh_get(vdict, d, p);\n            if (k == kh_end(d))\n            {\n                hts_log_warning(\"Contig '%s' is not defined in the header. (Quick workaround: index the file with tabix.)\", p);\n                v->errcode = BCF_ERR_CTG_UNDEF;\n                if ((k = fix_chromosome(h, d, p)) == kh_end(d)) {\n                    hts_log_error(\"Could not add dummy header for contig '%s'\", p);\n                    v->errcode |= BCF_ERR_CTG_INVALID;\n                    goto err;\n                }\n            }\n            v->rid = kh_val(d, k).id;\n        } else if (i == 1) { // POS\n            overflow = 0;\n            v->pos = hts_str2uint(p, &p, 63, &overflow);\n            if (overflow) {\n                hts_log_error(\"Position value '%s' is too large\", p);\n                goto err;\n            } else {\n                v->pos -= 1;\n            }\n            if (v->pos >= INT32_MAX)\n                v->unpacked |= BCF_IS_64BIT;\n        } else if (i == 2) { // ID\n            if (strcmp(p, \".\")) bcf_enc_vchar(str, q - p, p);\n            else bcf_enc_size(str, 0, BCF_BT_CHAR);\n        } else if (i == 3) { // REF\n            bcf_enc_vchar(str, q - p, p);\n            v->n_allele = 1, v->rlen = q - p;\n        } else if (i == 4) { // ALT\n            if (strcmp(p, \".\")) {\n                for (r = t = p;; ++r) {\n                    if (*r == ',' || *r == 0) {\n                        if (v->n_allele == UINT16_MAX) {\n                            hts_log_error(\"Too many ALT alleles at %s:%\"PRIhts_pos,\n                                          bcf_seqname_safe(h,v), v->pos+1);\n                            v->errcode |= BCF_ERR_LIMITS;\n                            goto err;\n                        }\n                        bcf_enc_vchar(str, r - t, t);\n                        t = r + 1;\n                        ++v->n_allele;\n                    }\n                    if (r == q) break;\n                }\n            }\n        } else if (i == 5) { // QUAL\n            if (strcmp(p, \".\")) v->qual = atof(p);\n            else bcf_float_set_missing(v->qual);\n            if ( v->max_unpack && !(v->max_unpack>>1) ) goto end; // BCF_UN_STR\n        } else if (i == 6) { // FILTER\n            if (strcmp(p, \".\")) {\n                if (vcf_parse_filter(str, h, v, p, q)) goto err;\n            } else bcf_enc_vint(str, 0, 0, -1);\n            if ( v->max_unpack && !(v->max_unpack>>2) ) goto end; // BCF_UN_FLT\n        } else if (i == 7) { // INFO\n            if (strcmp(p, \".\")) {\n                if (vcf_parse_info(str, h, v, p, q)) goto err;\n            }\n            if ( v->max_unpack && !(v->max_unpack>>3) ) goto end;\n        } else if (i == 8) {// FORMAT\n            return vcf_parse_format(s, h, v, p, q) == 0 ? 0 : -2;\n        }\n    }\n\n end:\n    ret = 0;\n\n err:\n    return ret;\n}\n\nint vcf_open_mode(char *mode, const char *fn, const char *format)\n{\n    if (format == NULL) {\n        // Try to pick a format based on the filename extension\n        char extension[HTS_MAX_EXT_LEN];\n        if (find_file_extension(fn, extension) < 0) return -1;\n        return vcf_open_mode(mode, fn, extension);\n    }\n    else if (strcasecmp(format, \"bcf\") == 0) strcpy(mode, \"b\");\n    else if (strcasecmp(format, \"vcf\") == 0) strcpy(mode, \"\");\n    else if (strcasecmp(format, \"vcf.gz\") == 0 || strcasecmp(format, \"vcf.bgz\") == 0) strcpy(mode, \"z\");\n    else return -1;\n\n    return 0;\n}\n\nint vcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int ret;\n    ret = hts_getline(fp, KS_SEP_LINE, &fp->line);\n    if (ret < 0) return ret;\n    return vcf_parse1(&fp->line, h, v);\n}\n\nstatic inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt)\n{\n    uint8_t *ptr_start = ptr;\n    fmt->id = bcf_dec_typed_int1(ptr, &ptr);\n    fmt->n = bcf_dec_size(ptr, &ptr, &fmt->type);\n    fmt->size = fmt->n << bcf_type_shift[fmt->type];\n    fmt->p = ptr;\n    fmt->p_off  = ptr - ptr_start;\n    fmt->p_free = 0;\n    ptr += n_sample * fmt->size;\n    fmt->p_len = ptr - fmt->p;\n    return ptr;\n}\n\nstatic inline uint8_t *bcf_unpack_info_core1(uint8_t *ptr, bcf_info_t *info)\n{\n    uint8_t *ptr_start = ptr;\n    info->key = bcf_dec_typed_int1(ptr, &ptr);\n    info->len = bcf_dec_size(ptr, &ptr, &info->type);\n    info->vptr = ptr;\n    info->vptr_off  = ptr - ptr_start;\n    info->vptr_free = 0;\n    info->v1.i = 0;\n    if (info->len == 1) {\n        if (info->type == BCF_BT_INT8 || info->type == BCF_BT_CHAR) info->v1.i = *(int8_t*)ptr;\n        else if (info->type == BCF_BT_INT32) info->v1.i = le_to_i32(ptr);\n        else if (info->type == BCF_BT_FLOAT) info->v1.f = le_to_float(ptr);\n        else if (info->type == BCF_BT_INT16) info->v1.i = le_to_i16(ptr);\n        else if (info->type == BCF_BT_INT64) info->v1.i = le_to_i64(ptr);\n    }\n    ptr += info->len << bcf_type_shift[info->type];\n    info->vptr_len = ptr - info->vptr;\n    return ptr;\n}\n\nint bcf_unpack(bcf1_t *b, int which)\n{\n    if ( !b->shared.l ) return 0; // Building a new BCF record from scratch\n    uint8_t *ptr = (uint8_t*)b->shared.s, *ptr_ori;\n    int i;\n    bcf_dec_t *d = &b->d;\n    if (which & BCF_UN_FLT) which |= BCF_UN_STR;\n    if (which & BCF_UN_INFO) which |= BCF_UN_SHR;\n    if ((which&BCF_UN_STR) && !(b->unpacked&BCF_UN_STR))\n    {\n        kstring_t tmp;\n\n        // ID\n        tmp.l = 0; tmp.s = d->id; tmp.m = d->m_id;\n        ptr_ori = ptr;\n        ptr = bcf_fmt_sized_array(&tmp, ptr);\n        b->unpack_size[0] = ptr - ptr_ori;\n        kputc('\\0', &tmp);\n        d->id = tmp.s; d->m_id = tmp.m;\n\n        // REF and ALT are in a single block (d->als) and d->alleles are pointers into this block\n        hts_expand(char*, b->n_allele, d->m_allele, d->allele); // NM: hts_expand() is a macro\n        tmp.l = 0; tmp.s = d->als; tmp.m = d->m_als;\n        ptr_ori = ptr;\n        char *o = \"\";\n        for (i = 0; i < b->n_allele; ++i) {\n            d->allele[i] = o + tmp.l;\n            ptr = bcf_fmt_sized_array(&tmp, ptr);\n            kputc('\\0', &tmp);\n        }\n        b->unpack_size[1] = ptr - ptr_ori;\n        d->als = tmp.s; d->m_als = tmp.m;\n\n        for (i = 0; i < b->n_allele; ++i)\n            d->allele[i] = d->als + (d->allele[i]-o);\n        b->unpacked |= BCF_UN_STR;\n    }\n    if ((which&BCF_UN_FLT) && !(b->unpacked&BCF_UN_FLT)) { // FILTER\n        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1];\n        ptr_ori = ptr;\n        if (*ptr>>4) {\n            int type;\n            d->n_flt = bcf_dec_size(ptr, &ptr, &type);\n            hts_expand(int, d->n_flt, d->m_flt, d->flt);\n            for (i = 0; i < d->n_flt; ++i)\n                d->flt[i] = bcf_dec_int1(ptr, type, &ptr);\n        } else ++ptr, d->n_flt = 0;\n        b->unpack_size[2] = ptr - ptr_ori;\n        b->unpacked |= BCF_UN_FLT;\n    }\n    if ((which&BCF_UN_INFO) && !(b->unpacked&BCF_UN_INFO)) { // INFO\n        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1] + b->unpack_size[2];\n        hts_expand(bcf_info_t, b->n_info, d->m_info, d->info);\n        for (i = 0; i < d->m_info; ++i) d->info[i].vptr_free = 0;\n        for (i = 0; i < b->n_info; ++i)\n            ptr = bcf_unpack_info_core1(ptr, &d->info[i]);\n        b->unpacked |= BCF_UN_INFO;\n    }\n    if ((which&BCF_UN_FMT) && b->n_sample && !(b->unpacked&BCF_UN_FMT)) { // FORMAT\n        ptr = (uint8_t*)b->indiv.s;\n        hts_expand(bcf_fmt_t, b->n_fmt, d->m_fmt, d->fmt);\n        for (i = 0; i < d->m_fmt; ++i) d->fmt[i].p_free = 0;\n        for (i = 0; i < b->n_fmt; ++i)\n            ptr = bcf_unpack_fmt_core1(ptr, b->n_sample, &d->fmt[i]);\n        b->unpacked |= BCF_UN_FMT;\n    }\n    return 0;\n}\n\nint vcf_format(const bcf_hdr_t *h, const bcf1_t *v, kstring_t *s)\n{\n    int i;\n    int32_t max_dt_id = h->n[BCF_DT_ID];\n    const char *chrom = bcf_seqname(h, v);\n    if (!chrom) {\n        hts_log_error(\"Invalid BCF, CONTIG id=%d not present in the header\",\n                      v->rid);\n        errno = EINVAL;\n        return -1;\n    }\n    bcf_unpack((bcf1_t*)v, BCF_UN_ALL);\n    kputs(chrom, s); // CHROM\n    kputc('\\t', s); kputll(v->pos + 1, s); // POS\n    kputc('\\t', s); kputs(v->d.id ? v->d.id : \".\", s); // ID\n    kputc('\\t', s); // REF\n    if (v->n_allele > 0) kputs(v->d.allele[0], s);\n    else kputc('.', s);\n    kputc('\\t', s); // ALT\n    if (v->n_allele > 1) {\n        for (i = 1; i < v->n_allele; ++i) {\n            if (i > 1) kputc(',', s);\n            kputs(v->d.allele[i], s);\n        }\n    } else kputc('.', s);\n    kputc('\\t', s); // QUAL\n    if ( bcf_float_is_missing(v->qual) ) kputc('.', s); // QUAL\n    else kputd(v->qual, s);\n    kputc('\\t', s); // FILTER\n    if (v->d.n_flt) {\n        for (i = 0; i < v->d.n_flt; ++i) {\n            int32_t idx = v->d.flt[i];\n            if (idx < 0 || idx >= max_dt_id\n                || h->id[BCF_DT_ID][idx].key == NULL) {\n                hts_log_error(\"Invalid BCF, the FILTER tag id=%d at %s:%\"PRIhts_pos\" not present in the header\",\n                              idx, bcf_seqname_safe(h, v), v->pos + 1);\n                errno = EINVAL;\n                return -1;\n            }\n            if (i) kputc(';', s);\n            kputs(h->id[BCF_DT_ID][idx].key, s);\n        }\n    } else kputc('.', s);\n    kputc('\\t', s); // INFO\n    if (v->n_info) {\n        int first = 1;\n        for (i = 0; i < v->n_info; ++i) {\n            bcf_info_t *z = &v->d.info[i];\n            if ( !z->vptr ) continue;\n            if ( !first ) kputc(';', s);\n            first = 0;\n            if (z->key < 0 || z->key >= max_dt_id\n                || h->id[BCF_DT_ID][z->key].key == NULL) {\n                hts_log_error(\"Invalid BCF, the INFO tag id=%d is %s at %s:%\"PRIhts_pos,\n                              z->key,\n                              z->key < 0 ? \"negative\"\n                              : (z->key >= max_dt_id ? \"too large\" : \"not present in the header\"),\n                              bcf_seqname_safe(h, v), v->pos+1);\n                errno = EINVAL;\n                return -1;\n            }\n            kputs(h->id[BCF_DT_ID][z->key].key, s);\n            if (z->len <= 0) continue;\n            kputc('=', s);\n            if (z->len == 1)\n            {\n                switch (z->type)\n                {\n                    case BCF_BT_INT8:  if ( z->v1.i==bcf_int8_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT16: if ( z->v1.i==bcf_int16_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT32: if ( z->v1.i==bcf_int32_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT64: if ( z->v1.i==bcf_int64_missing ) kputc('.', s); else kputll(z->v1.i, s); break;\n                    case BCF_BT_FLOAT: if ( bcf_float_is_missing(z->v1.f) ) kputc('.', s); else kputd(z->v1.f, s); break;\n                    case BCF_BT_CHAR:  kputc(z->v1.i, s); break;\n                    default:\n                        hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, z->type, bcf_seqname_safe(h, v), v->pos+1);\n                        errno = EINVAL;\n                        return -1;\n                }\n            }\n            else bcf_fmt_array(s, z->len, z->type, z->vptr);\n        }\n        if ( first ) kputc('.', s);\n    } else kputc('.', s);\n    // FORMAT and individual information\n    if (v->n_sample)\n    {\n        int i,j;\n        if ( v->n_fmt)\n        {\n            int gt_i = -1;\n            bcf_fmt_t *fmt = v->d.fmt;\n            int first = 1;\n            for (i = 0; i < (int)v->n_fmt; ++i) {\n                if ( !fmt[i].p ) continue;\n                kputc(!first ? ':' : '\\t', s); first = 0;\n                if (fmt[i].id < 0 || fmt[i].id >= max_dt_id\n                    || h->id[BCF_DT_ID][fmt[i].id].key == NULL) //!bcf_hdr_idinfo_exists(h,BCF_HL_FMT,fmt[i].id) )\n                {\n                    hts_log_error(\"Invalid BCF, the FORMAT tag id=%d at %s:%\"PRIhts_pos\" not present in the header\", fmt[i].id, bcf_seqname_safe(h, v), v->pos+1);\n                    errno = EINVAL;\n                    return -1;\n                }\n                kputs(h->id[BCF_DT_ID][fmt[i].id].key, s);\n                if (strcmp(h->id[BCF_DT_ID][fmt[i].id].key, \"GT\") == 0) gt_i = i;\n            }\n            if ( first ) kputs(\"\\t.\", s);\n            for (j = 0; j < v->n_sample; ++j) {\n                kputc('\\t', s);\n                first = 1;\n                for (i = 0; i < (int)v->n_fmt; ++i) {\n                    bcf_fmt_t *f = &fmt[i];\n                    if ( !f->p ) continue;\n                    if (!first) kputc(':', s);\n                    first = 0;\n                    if (gt_i == i)\n                        bcf_format_gt(f,j,s);\n                    else\n                        bcf_fmt_array(s, f->n, f->type, f->p + j * (size_t)f->size);\n                }\n                if ( first ) kputc('.', s);\n            }\n        }\n        else\n            for (j=0; j<=v->n_sample; j++)\n                kputs(\"\\t.\", s);\n    }\n    kputc('\\n', s);\n    return 0;\n}\n\nint vcf_write_line(htsFile *fp, kstring_t *line)\n{\n    int ret;\n    if ( line->s[line->l-1]!='\\n' ) kputc('\\n',line);\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, line->s, line->l);\n    else\n        ret = hwrite(fp->fp.hfile, line->s, line->l);\n    return ret==line->l ? 0 : -1;\n}\n\nint vcf_write(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int ret;\n    fp->line.l = 0;\n    if (vcf_format1(h, v, &fp->line) != 0)\n        return -1;\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l);\n    else\n        ret = hwrite(fp->fp.hfile, fp->line.s, fp->line.l);\n\n    if (fp->idx) {\n        int tid;\n        if ((tid = hts_idx_tbi_name(fp->idx, v->rid, bcf_seqname_safe(h, v))) < 0)\n            return -1;\n\n        if (hts_idx_push(fp->idx, tid, v->pos, v->pos + v->rlen, bgzf_tell(fp->fp.bgzf), 1) < 0)\n            return -1;\n    }\n\n    return ret==fp->line.l ? 0 : -1;\n}\n\n/************************\n * Data access routines *\n ************************/\n\nint bcf_hdr_id2int(const bcf_hdr_t *h, int which, const char *id)\n{\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[which];\n    k = kh_get(vdict, d, id);\n    return k == kh_end(d)? -1 : kh_val(d, k).id;\n}\n\n\n/********************\n *** BCF indexing ***\n ********************/\n\n// Calculate number of index levels given min_shift and the header contig\n// list.  Also returns number of contigs in *nids_out.\nstatic int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,\n                               int starting_n_lvls, int *nids_out)\n{\n    int n_lvls, i, nids = 0;\n    int64_t max_len = 0, s;\n\n    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)\n    {\n        if ( !h->id[BCF_DT_CTG][i].val ) continue;\n        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )\n            max_len = h->id[BCF_DT_CTG][i].val->info[0];\n        nids++;\n    }\n    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.\n    max_len += 256;\n    s = 1LL << (min_shift + starting_n_lvls * 3);\n    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);\n\n    if (nids_out) *nids_out = nids;\n    return n_lvls;\n}\n\nhts_idx_t *bcf_index(htsFile *fp, int min_shift)\n{\n    int n_lvls;\n    bcf1_t *b = NULL;\n    hts_idx_t *idx = NULL;\n    bcf_hdr_t *h;\n    int r;\n    h = bcf_hdr_read(fp);\n    if ( !h ) return NULL;\n    int nids = 0;\n    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);\n    idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!idx) goto fail;\n    b = bcf_init1();\n    if (!b) goto fail;\n    while ((r = bcf_read1(fp,h, b)) >= 0) {\n        int ret;\n        ret = hts_idx_push(idx, b->rid, b->pos, b->pos + b->rlen, bgzf_tell(fp->fp.bgzf), 1);\n        if (ret < 0) goto fail;\n    }\n    if (r < -1) goto fail;\n    hts_idx_finish(idx, bgzf_tell(fp->fp.bgzf));\n    bcf_destroy1(b);\n    bcf_hdr_destroy(h);\n    return idx;\n\n fail:\n    hts_idx_destroy(idx);\n    bcf_destroy1(b);\n    bcf_hdr_destroy(h);\n    return NULL;\n}\n\nhts_idx_t *bcf_index_load2(const char *fn, const char *fnidx)\n{\n    return fnidx? hts_idx_load2(fn, fnidx) : bcf_index_load(fn);\n}\n\nhts_idx_t *bcf_index_load3(const char *fn, const char *fnidx, int flags)\n{\n    return hts_idx_load3(fn, fnidx, HTS_FMT_CSI, flags);\n}\n\nint bcf_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads)\n{\n    htsFile *fp;\n    hts_idx_t *idx;\n    tbx_t *tbx;\n    int ret;\n    if ((fp = hts_open(fn, \"rb\")) == 0) return -2;\n    if (n_threads)\n        hts_set_threads(fp, n_threads);\n    if ( fp->format.compression!=bgzf ) { hts_close(fp); return -3; }\n    switch (fp->format.format) {\n        case bcf:\n            if (!min_shift) {\n                hts_log_error(\"TBI indices for BCF files are not supported\");\n                ret = -1;\n            } else {\n                idx = bcf_index(fp, min_shift);\n                if (idx) {\n                    ret = hts_idx_save_as(idx, fn, fnidx, HTS_FMT_CSI);\n                    if (ret < 0) ret = -4;\n                    hts_idx_destroy(idx);\n                }\n                else ret = -1;\n            }\n            break;\n\n        case vcf:\n            tbx = tbx_index(hts_get_bgzfp(fp), min_shift, &tbx_conf_vcf);\n            if (tbx) {\n                ret = hts_idx_save_as(tbx->idx, fn, fnidx, min_shift > 0 ? HTS_FMT_CSI : HTS_FMT_TBI);\n                if (ret < 0) ret = -4;\n                tbx_destroy(tbx);\n            }\n            else ret = -1;\n            break;\n\n        default:\n            ret = -3;\n            break;\n    }\n    hts_close(fp);\n    return ret;\n}\n\nint bcf_index_build2(const char *fn, const char *fnidx, int min_shift)\n{\n    return bcf_index_build3(fn, fnidx, min_shift, 0);\n}\n\nint bcf_index_build(const char *fn, int min_shift)\n{\n    return bcf_index_build3(fn, NULL, min_shift, 0);\n}\n\n// Initialise fp->idx for the current format type.\n// This must be called after the header has been written but no other data.\nstatic int vcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {\n    int n_lvls, fmt;\n\n    if (min_shift == 0) {\n        min_shift = 14;\n        n_lvls = 5;\n        fmt = HTS_FMT_TBI;\n    } else {\n        // Set initial n_lvls to match tbx_index()\n        int starting_n_lvls = (TBX_MAX_SHIFT - min_shift + 2) / 3;\n        // Increase if necessary\n        n_lvls = idx_calc_n_lvls_ids(h, min_shift, starting_n_lvls, NULL);\n        fmt = HTS_FMT_CSI;\n    }\n\n    fp->idx = hts_idx_init(0, fmt, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!fp->idx) return -1;\n\n    // Tabix meta data, added even in CSI for VCF\n    uint8_t conf[4*7];\n    u32_to_le(TBX_VCF, conf+0);  // fmt\n    u32_to_le(1,       conf+4);  // name col\n    u32_to_le(2,       conf+8);  // beg col\n    u32_to_le(0,       conf+12); // end col\n    u32_to_le('#',     conf+16); // comment\n    u32_to_le(0,       conf+20); // n.skip\n    u32_to_le(0,       conf+24); // ref name len\n    if (hts_idx_set_meta(fp->idx, sizeof(conf)*sizeof(*conf), (uint8_t *)conf, 1) < 0) {\n        hts_idx_destroy(fp->idx);\n        fp->idx = NULL;\n        return -1;\n    }\n    fp->fnidx = fnidx;\n\n    return 0;\n}\n\n// Initialise fp->idx for the current format type.\n// This must be called after the header has been written but no other data.\nint bcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {\n    int n_lvls, nids = 0;\n\n    if (fp->format.format == vcf)\n        return vcf_idx_init(fp, h, min_shift, fnidx);\n\n    if (!min_shift)\n        min_shift = 14;\n\n    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);\n\n    fp->idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!fp->idx) return -1;\n    fp->fnidx = fnidx;\n\n    return 0;\n}\n\n// Finishes an index. Call afer the last record has been written.\n// Returns 0 on success, <0 on failure.\n//\n// NB: same format as SAM/BAM as it uses bgzf.\nint bcf_idx_save(htsFile *fp) {\n    return sam_idx_save(fp);\n}\n\n/*****************\n *** Utilities ***\n *****************/\n\nint bcf_hdr_combine(bcf_hdr_t *dst, const bcf_hdr_t *src)\n{\n    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;\n    for (i=0; i<src->nhrec; i++)\n    {\n        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )\n        {\n            int j;\n            for (j=0; j<ndst_ori; j++)\n            {\n                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;\n\n                // Checking only the key part of generic lines, otherwise\n                // the VCFs are too verbose. Should we perhaps add a flag\n                // to bcf_hdr_combine() and make this optional?\n                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;\n            }\n            if ( j>=ndst_ori ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return -1;\n                need_sync += res;\n            }\n        }\n        else if ( src->hrec[i]->type==BCF_HL_STR )\n        {\n            // NB: we are ignoring fields without ID\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            if ( j>=0 )\n            {\n                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], src->hrec[i]->key);\n                if ( !rec ) {\n                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                    if (res < 0) return -1;\n                    need_sync += res;\n                }\n            }\n        }\n        else\n        {\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            assert( j>=0 ); // this should always be true for valid VCFs\n\n            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], NULL);\n            if ( !rec ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return -1;\n                need_sync += res;\n            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )\n            {\n                // Check that both records are of the same type. The bcf_hdr_id2length\n                // macro cannot be used here because dst header is not synced yet.\n                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];\n                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];\n                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);\n                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);\n                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different lengths\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different types\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n            }\n        }\n    }\n    if ( need_sync ) {\n        if (bcf_hdr_sync(dst) < 0) return -1;\n    }\n    return ret;\n}\n\nbcf_hdr_t *bcf_hdr_merge(bcf_hdr_t *dst, const bcf_hdr_t *src)\n{\n    if ( !dst )\n    {\n        // this will effectively strip existing IDX attributes from src to become dst\n        dst = bcf_hdr_init(\"r\");\n        kstring_t htxt = {0,0,0};\n        bcf_hdr_format(src, 0, &htxt);\n        if ( bcf_hdr_parse(dst, htxt.s) < 0 ) {\n            bcf_hdr_destroy(dst);\n            dst = NULL;\n        }\n        free(htxt.s);\n        return dst;\n    }\n\n    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;\n    for (i=0; i<src->nhrec; i++)\n    {\n        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )\n        {\n            int j;\n            for (j=0; j<ndst_ori; j++)\n            {\n                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;\n\n                // Checking only the key part of generic lines, otherwise\n                // the VCFs are too verbose. Should we perhaps add a flag\n                // to bcf_hdr_combine() and make this optional?\n                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;\n            }\n            if ( j>=ndst_ori ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return NULL;\n                need_sync += res;\n            }\n        }\n        else if ( src->hrec[i]->type==BCF_HL_STR )\n        {\n            // NB: we are ignoring fields without ID\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            if ( j>=0 )\n            {\n                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], src->hrec[i]->key);\n                if ( !rec ) {\n                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                    if (res < 0) return NULL;\n                    need_sync += res;\n                }\n            }\n        }\n        else\n        {\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            assert( j>=0 ); // this should always be true for valid VCFs\n\n            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], NULL);\n            if ( !rec ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return NULL;\n                need_sync += res;\n            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )\n            {\n                // Check that both records are of the same type. The bcf_hdr_id2length\n                // macro cannot be used here because dst header is not synced yet.\n                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];\n                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];\n                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);\n                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);\n                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different lengths\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different types\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n            }\n        }\n    }\n    if ( need_sync ) {\n        if (bcf_hdr_sync(dst) < 0) return NULL;\n    }\n    return dst;\n}\n\nint bcf_translate(const bcf_hdr_t *dst_hdr, bcf_hdr_t *src_hdr, bcf1_t *line)\n{\n    int i;\n    if ( line->errcode )\n    {\n        hts_log_error(\"Unchecked error (%d) at %s:%\"PRIhts_pos\", exiting\", line->errcode, bcf_seqname_safe(src_hdr,line), line->pos+1);\n        exit(1);\n    }\n    if ( src_hdr->ntransl==-1 ) return 0;    // no need to translate, all tags have the same id\n    if ( !src_hdr->ntransl )  // called for the first time, see what needs translating\n    {\n        int dict;\n        for (dict=0; dict<2; dict++)    // BCF_DT_ID and BCF_DT_CTG\n        {\n            src_hdr->transl[dict] = (int*) malloc(src_hdr->n[dict]*sizeof(int));\n            for (i=0; i<src_hdr->n[dict]; i++)\n            {\n                if ( !src_hdr->id[dict][i].key ) // gap left after removed BCF header lines\n                {\n                    src_hdr->transl[dict][i] = -1;\n                    continue;\n                }\n                src_hdr->transl[dict][i] = bcf_hdr_id2int(dst_hdr,dict,src_hdr->id[dict][i].key);\n                if ( src_hdr->transl[dict][i]!=-1 && i!=src_hdr->transl[dict][i] ) src_hdr->ntransl++;\n            }\n        }\n        if ( !src_hdr->ntransl )\n        {\n            free(src_hdr->transl[0]); src_hdr->transl[0] = NULL;\n            free(src_hdr->transl[1]); src_hdr->transl[1] = NULL;\n            src_hdr->ntransl = -1;\n        }\n        if ( src_hdr->ntransl==-1 ) return 0;\n    }\n    bcf_unpack(line,BCF_UN_ALL);\n\n    // CHROM\n    if ( src_hdr->transl[BCF_DT_CTG][line->rid] >=0 ) line->rid = src_hdr->transl[BCF_DT_CTG][line->rid];\n\n    // FILTER\n    for (i=0; i<line->d.n_flt; i++)\n    {\n        int src_id = line->d.flt[i];\n        if ( src_hdr->transl[BCF_DT_ID][src_id] >=0 )\n            line->d.flt[i] = src_hdr->transl[BCF_DT_ID][src_id];\n        line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    }\n\n    // INFO\n    for (i=0; i<line->n_info; i++)\n    {\n        int src_id = line->d.info[i].key;\n        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];\n        if ( dst_id<0 ) continue;\n        line->d.info[i].key = dst_id;\n        if ( !line->d.info[i].vptr ) continue;  // skip deleted\n        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        if ( src_size==dst_size )   // can overwrite\n        {\n            uint8_t *vptr = line->d.info[i].vptr - line->d.info[i].vptr_off;\n            if ( dst_size==BCF_BT_INT8 ) { vptr[1] = (uint8_t)dst_id; }\n            else if ( dst_size==BCF_BT_INT16 ) { *(uint16_t*)vptr = (uint16_t)dst_id; }\n            else { *(uint32_t*)vptr = (uint32_t)dst_id; }\n        }\n        else    // must realloc\n        {\n            bcf_info_t *info = &line->d.info[i];\n            kstring_t str = {0,0,0};\n            bcf_enc_int1(&str, dst_id);\n            bcf_enc_size(&str, info->len,info->type);\n            uint32_t vptr_off = str.l;\n            kputsn((char*)info->vptr, info->vptr_len, &str);\n            if( info->vptr_free ) free(info->vptr - info->vptr_off);\n            info->vptr_off = vptr_off;\n            info->vptr = (uint8_t*)str.s + info->vptr_off;\n            info->vptr_free = 1;\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n        }\n    }\n\n    // FORMAT\n    for (i=0; i<line->n_fmt; i++)\n    {\n        int src_id = line->d.fmt[i].id;\n        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];\n        if ( dst_id<0 ) continue;\n        line->d.fmt[i].id = dst_id;\n        if( !line->d.fmt[i].p ) continue;  // skip deleted\n        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        if ( src_size==dst_size )   // can overwrite\n        {\n            uint8_t *p = line->d.fmt[i].p - line->d.fmt[i].p_off;    // pointer to the vector size (4bits) and BT type (4bits)\n            if ( dst_size==BCF_BT_INT8 ) { p[1] = dst_id; }\n            else if ( dst_size==BCF_BT_INT16 ) { i16_to_le(dst_id, p + 1); }\n            else { i32_to_le(dst_id, p + 1); }\n        }\n        else    // must realloc\n        {\n            bcf_fmt_t *fmt = &line->d.fmt[i];\n            kstring_t str = {0,0,0};\n            bcf_enc_int1(&str, dst_id);\n            bcf_enc_size(&str, fmt->n, fmt->type);\n            uint32_t p_off = str.l;\n            kputsn((char*)fmt->p, fmt->p_len, &str);\n            if( fmt->p_free ) free(fmt->p - fmt->p_off);\n            fmt->p_off = p_off;\n            fmt->p = (uint8_t*)str.s + fmt->p_off;\n            fmt->p_free = 1;\n            line->d.indiv_dirty = 1;\n        }\n    }\n    return 0;\n}\n\nbcf_hdr_t *bcf_hdr_dup(const bcf_hdr_t *hdr)\n{\n    bcf_hdr_t *hout = bcf_hdr_init(\"r\");\n    if (!hout) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(hdr, 1, &htxt);\n    if ( bcf_hdr_parse(hout, htxt.s) < 0 ) {\n        bcf_hdr_destroy(hout);\n        hout = NULL;\n    }\n    free(htxt.s);\n    return hout;\n}\n\nbcf_hdr_t *bcf_hdr_subset(const bcf_hdr_t *h0, int n, char *const* samples, int *imap)\n{\n    void *names_hash = khash_str2int_init();\n    kstring_t htxt = {0,0,0};\n    kstring_t str = {0,0,0};\n    bcf_hdr_t *h = bcf_hdr_init(\"w\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        khash_str2int_destroy(names_hash);\n        return NULL;\n    }\n    bcf_hdr_format(h0, 1, &htxt);\n    bcf_hdr_set_version(h,bcf_hdr_get_version(h0));\n    int j;\n    for (j=0; j<n; j++) imap[j] = -1;\n    if ( bcf_hdr_nsamples(h0) > 0) {\n        char *p = find_chrom_header_line(htxt.s);\n        int i = 0, end = n? 8 : 7;\n        while ((p = strchr(p, '\\t')) != 0 && i < end) ++i, ++p;\n        if (i != end) {\n            free(h); free(str.s);\n            return 0; // malformated header\n        }\n        kputsn(htxt.s, p - htxt.s, &str);\n        for (i = 0; i < n; ++i) {\n            if ( khash_str2int_has_key(names_hash,samples[i]) )\n            {\n                hts_log_error(\"Duplicate sample name \\\"%s\\\"\", samples[i]);\n                free(str.s);\n                free(htxt.s);\n                khash_str2int_destroy(names_hash);\n                bcf_hdr_destroy(h);\n                return NULL;\n            }\n            imap[i] = bcf_hdr_id2int(h0, BCF_DT_SAMPLE, samples[i]);\n            if (imap[i] < 0) continue;\n            kputc('\\t', &str);\n            kputs(samples[i], &str);\n            khash_str2int_inc(names_hash,samples[i]);\n        }\n    } else kputsn(htxt.s, htxt.l, &str);\n    while (str.l && (!str.s[str.l-1] || str.s[str.l-1]=='\\n') ) str.l--; // kill trailing zeros and newlines\n    kputc('\\n',&str);\n    if ( bcf_hdr_parse(h, str.s) < 0 ) {\n        bcf_hdr_destroy(h);\n        h = NULL;\n    }\n    free(str.s);\n    free(htxt.s);\n    khash_str2int_destroy(names_hash);\n    return h;\n}\n\nint bcf_hdr_set_samples(bcf_hdr_t *hdr, const char *samples, int is_file)\n{\n    if ( samples && !strcmp(\"-\",samples) ) return 0;            // keep all samples\n\n    int i, narr = bit_array_size(bcf_hdr_nsamples(hdr));\n    hdr->keep_samples = (uint8_t*) calloc(narr,1);\n    if (!hdr->keep_samples) return -1;\n\n    hdr->nsamples_ori = bcf_hdr_nsamples(hdr);\n    if ( !samples )\n    {\n        // exclude all samples\n        khint_t k;\n        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE], *new_dict;\n        new_dict = kh_init(vdict);\n        if (!new_dict) return -1;\n\n        bcf_hdr_nsamples(hdr) = 0;\n\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        hdr->dict[BCF_DT_SAMPLE] = new_dict;\n        if (bcf_hdr_sync(hdr) < 0) return -1;\n\n        return 0;\n    }\n\n    if ( samples[0]=='^' )\n        for (i=0; i<bcf_hdr_nsamples(hdr); i++) bit_array_set(hdr->keep_samples,i);\n\n    int idx, n, ret = 0;\n    char **smpls = hts_readlist(samples[0]=='^'?samples+1:samples, is_file, &n);\n    if ( !smpls ) return -1;\n    for (i=0; i<n; i++)\n    {\n        idx = bcf_hdr_id2int(hdr,BCF_DT_SAMPLE,smpls[i]);\n        if ( idx<0 )\n        {\n            if ( !ret ) ret = i+1;\n            continue;\n        }\n        assert( idx<bcf_hdr_nsamples(hdr) );\n        if (  samples[0]=='^' )\n            bit_array_clear(hdr->keep_samples, idx);\n        else\n            bit_array_set(hdr->keep_samples, idx);\n    }\n    for (i=0; i<n; i++) free(smpls[i]);\n    free(smpls);\n\n    bcf_hdr_nsamples(hdr) = 0;\n    for (i=0; i<hdr->nsamples_ori; i++)\n        if ( bit_array_test(hdr->keep_samples,i) ) bcf_hdr_nsamples(hdr)++;\n\n    if ( !bcf_hdr_nsamples(hdr) ) { free(hdr->keep_samples); hdr->keep_samples=NULL; }\n    else\n    {\n        // Make new list and dictionary with desired samples\n        char **samples = (char**) malloc(sizeof(char*)*bcf_hdr_nsamples(hdr));\n        vdict_t *new_dict, *d;\n        int k, res;\n        if (!samples) return -1;\n\n        new_dict = kh_init(vdict);\n        if (!new_dict) {\n            free(samples);\n            return -1;\n        }\n        idx = 0;\n        for (i=0; i<hdr->nsamples_ori; i++) {\n            if ( bit_array_test(hdr->keep_samples,i) ) {\n                samples[idx] = hdr->samples[i];\n                k = kh_put(vdict, new_dict, hdr->samples[i], &res);\n                if (res < 0) {\n                    free(samples);\n                    kh_destroy(vdict, new_dict);\n                    return -1;\n                }\n                kh_val(new_dict, k) = bcf_idinfo_def;\n                kh_val(new_dict, k).id = idx;\n                idx++;\n            }\n        }\n\n        // Delete desired samples from old dictionary, so we don't free them\n        d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE];\n        for (i=0; i < idx; i++) {\n            int k = kh_get(vdict, d, samples[i]);\n            if (k < kh_end(d)) kh_del(vdict, d, k);\n        }\n\n        // Free everything else\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        hdr->dict[BCF_DT_SAMPLE] = new_dict;\n\n        free(hdr->samples);\n        hdr->samples = samples;\n\n        if (bcf_hdr_sync(hdr) < 0)\n            return -1;\n    }\n\n    return ret;\n}\n\nint bcf_subset(const bcf_hdr_t *h, bcf1_t *v, int n, int *imap)\n{\n    kstring_t ind;\n    ind.s = 0; ind.l = ind.m = 0;\n    if (n) {\n        bcf_fmt_t fmt[MAX_N_FMT];\n        int i, j;\n        uint8_t *ptr = (uint8_t*)v->indiv.s;\n        for (i = 0; i < v->n_fmt; ++i)\n            ptr = bcf_unpack_fmt_core1(ptr, v->n_sample, &fmt[i]);\n        for (i = 0; i < (int)v->n_fmt; ++i) {\n            bcf_fmt_t *f = &fmt[i];\n            bcf_enc_int1(&ind, f->id);\n            bcf_enc_size(&ind, f->n, f->type);\n            for (j = 0; j < n; ++j)\n                if (imap[j] >= 0) kputsn((char*)(f->p + imap[j] * f->size), f->size, &ind);\n        }\n        for (i = j = 0; j < n; ++j) if (imap[j] >= 0) ++i;\n        v->n_sample = i;\n    } else v->n_sample = 0;\n    if ( !v->n_sample ) v->n_fmt = 0;\n    free(v->indiv.s);\n    v->indiv = ind;\n    v->unpacked &= ~BCF_UN_FMT;    // only BCF is ready for output, VCF will need to unpack again\n    return 0;\n}\n\nint bcf_is_snp(bcf1_t *v)\n{\n    int i;\n    bcf_unpack(v, BCF_UN_STR);\n    for (i = 0; i < v->n_allele; ++i)\n    {\n        if ( v->d.allele[i][1]==0 && v->d.allele[i][0]!='*' ) continue;\n\n        // mpileup's <X> allele, see also below. This is not completely satisfactory,\n        // a general library is here narrowly tailored to fit samtools.\n        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='X' && v->d.allele[i][2]=='>' ) continue;\n        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='*' && v->d.allele[i][2]=='>' ) continue;\n\n        break;\n    }\n    return i == v->n_allele;\n}\n\nstatic void bcf_set_variant_type(const char *ref, const char *alt, variant_t *var)\n{\n    if ( *alt == '*' && !alt[1] ) { var->n = 0; var->type = VCF_OVERLAP; return; }  // overlapping variant\n\n    // The most frequent case\n    if ( !ref[1] && !alt[1] )\n    {\n        if ( *alt == '.' || *ref==*alt ) { var->n = 0; var->type = VCF_REF; return; }\n        if ( *alt == 'X' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant\n        var->n = 1; var->type = VCF_SNP; return;\n    }\n    if ( alt[0]=='<' )\n    {\n        if ( alt[1]=='X' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant\n        if ( alt[1]=='*' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }\n        if ( !strcmp(\"NON_REF>\",alt+1) ) { var->n = 0; var->type = VCF_REF; return; }\n        var->type = VCF_OTHER;\n        return;\n    }\n\n    const char *r = ref, *a = alt;\n    while (*r && *a && toupper_c(*r)==toupper_c(*a) ) { r++; a++; }     // unfortunately, matching REF,ALT case is not guaranteed\n\n    if ( *a && !*r )\n    {\n        if ( *a==']' || *a=='[' ) { var->type = VCF_BND; return; }\n        while ( *a ) a++;\n        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;\n    }\n    else if ( *r && !*a )\n    {\n        while ( *r ) r++;\n        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;\n    }\n    else if ( !*r && !*a )\n    {\n        var->n = 0; var->type = VCF_REF; return;\n    }\n\n    const char *re = r, *ae = a;\n    while ( re[1] ) re++;\n    while ( ae[1] ) ae++;\n    while ( re>r && ae>a && toupper_c(*re)==toupper_c(*ae) ) { re--; ae--; }\n    if ( ae==a )\n    {\n        if ( re==r ) { var->n = 1; var->type = VCF_SNP; return; }\n        var->n = -(re-r);\n        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }\n        var->type = VCF_OTHER; return;\n    }\n    else if ( re==r )\n    {\n        var->n = ae-a;\n        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }\n        var->type = VCF_OTHER; return;\n    }\n\n    var->type = ( re-r == ae-a ) ? VCF_MNP : VCF_OTHER;\n    var->n = ( re-r > ae-a ) ? -(re-r+1) : ae-a+1;\n\n    // should do also complex events, SVs, etc...\n}\n\nstatic int bcf_set_variant_types(bcf1_t *b)\n{\n    if ( !(b->unpacked & BCF_UN_STR) ) bcf_unpack(b, BCF_UN_STR);\n    bcf_dec_t *d = &b->d;\n    if ( d->n_var < b->n_allele )\n    {\n        d->var = (variant_t *) realloc(d->var, sizeof(variant_t)*b->n_allele);\n        d->n_var = b->n_allele;\n    }\n    int i;\n    b->d.var_type = 0;\n    d->var[0].type = VCF_REF;\n    d->var[0].n    = 0;\n    for (i=1; i<b->n_allele; i++)\n    {\n        bcf_set_variant_type(d->allele[0],d->allele[i], &d->var[i]);\n        b->d.var_type |= d->var[i].type;\n        //fprintf(stderr,\"[set_variant_type] %d   %s %s -> %d %d .. %d\\n\", b->pos+1,d->allele[0],d->allele[i],d->var[i].type,d->var[i].n, b->d.var_type);\n    }\n    return 0;\n}\n\nint bcf_get_variant_types(bcf1_t *rec)\n{\n    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);\n    return rec->d.var_type;\n}\nint bcf_get_variant_type(bcf1_t *rec, int ith_allele)\n{\n    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);\n    return rec->d.var[ith_allele].type;\n}\n\nint bcf_update_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)\n{\n    static int negative_rlen_warned = 0;\n    int is_end_tag;\n\n    // Is the field already present?\n    int i, inf_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,inf_id) ) return -1;    // No such INFO field in the header\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n\n    is_end_tag = strcmp(key, \"END\") == 0;\n\n    for (i=0; i<line->n_info; i++)\n        if ( inf_id==line->d.info[i].key ) break;\n    bcf_info_t *inf = i==line->n_info ? NULL : &line->d.info[i];\n\n    if ( !n || (type==BCF_HT_STR && !values) )\n    {\n        if ( n==0 && is_end_tag )\n            line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;\n        if ( inf )\n        {\n            // Mark the tag for removal, free existing memory if necessary\n            if ( inf->vptr_free )\n            {\n                free(inf->vptr - inf->vptr_off);\n                inf->vptr_free = 0;\n            }\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n            inf->vptr = NULL;\n            inf->vptr_off = inf->vptr_len = 0;\n        }\n        return 0;\n    }\n\n    if (is_end_tag)\n    {\n        if (n != 1)\n        {\n            hts_log_error(\"END info tag should only have one value at %s:%\"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);\n            line->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n        if (type != BCF_HT_INT && type != BCF_HT_LONG)\n        {\n            hts_log_error(\"Wrong type (%d) for END info tag at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n            line->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n    }\n\n    // Encode the values and determine the size required to accommodate the values\n    kstring_t str = {0,0,0};\n    bcf_enc_int1(&str, inf_id);\n    if ( type==BCF_HT_INT )\n        bcf_enc_vint(&str, n, (int32_t*)values, -1);\n    else if ( type==BCF_HT_REAL )\n        bcf_enc_vfloat(&str, n, (float*)values);\n    else if ( type==BCF_HT_FLAG || type==BCF_HT_STR )\n    {\n        if ( values==NULL )\n            bcf_enc_size(&str, 0, BCF_BT_NULL);\n        else\n            bcf_enc_vchar(&str, strlen((char*)values), (char*)values);\n    }\n#ifdef VCF_ALLOW_INT64\n    else if ( type==BCF_HT_LONG )\n    {\n        if (n != 1) {\n            hts_log_error(\"Only storing a single BCF_HT_LONG value is supported at %s:%\"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);\n            abort();\n        }\n        bcf_enc_long1(&str, *(int64_t *) values);\n    }\n#endif\n    else\n    {\n        hts_log_error(\"The type %d not implemented yet at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n        abort();\n    }\n\n    // Is the INFO tag already present\n    if ( inf )\n    {\n        // Is it big enough to accommodate new block?\n        if ( str.l <= inf->vptr_len + inf->vptr_off )\n        {\n            if ( str.l != inf->vptr_len + inf->vptr_off ) line->d.shared_dirty |= BCF1_DIRTY_INF;\n            uint8_t *ptr = inf->vptr - inf->vptr_off;\n            memcpy(ptr, str.s, str.l);\n            free(str.s);\n            int vptr_free = inf->vptr_free;\n            bcf_unpack_info_core1(ptr, inf);\n            inf->vptr_free = vptr_free;\n        }\n        else\n        {\n            if ( inf->vptr_free )\n                free(inf->vptr - inf->vptr_off);\n            bcf_unpack_info_core1((uint8_t*)str.s, inf);\n            inf->vptr_free = 1;\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n        }\n    }\n    else\n    {\n        // The tag is not present, create new one\n        line->n_info++;\n        hts_expand0(bcf_info_t, line->n_info, line->d.m_info , line->d.info);\n        inf = &line->d.info[line->n_info-1];\n        bcf_unpack_info_core1((uint8_t*)str.s, inf);\n        inf->vptr_free = 1;\n        line->d.shared_dirty |= BCF1_DIRTY_INF;\n    }\n    line->unpacked |= BCF_UN_INFO;\n\n   if ( n==1 && is_end_tag) {\n        hts_pos_t end = type == BCF_HT_INT ? *(int32_t *) values : *(int64_t *) values;\n        if ( (type == BCF_HT_INT && end!=bcf_int32_missing) || (type == BCF_HT_LONG && end!=bcf_int64_missing) )\n        {\n            if ( end <= line->pos )\n            {\n                if ( !negative_rlen_warned )\n                {\n                    hts_log_warning(\"INFO/END=%\"PRIhts_pos\" is smaller than POS at %s:%\"PRIhts_pos,end,bcf_seqname_safe(hdr,line),line->pos+1);\n                    negative_rlen_warned = 1;\n                }\n                line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;\n            }\n            else\n                line->rlen = end - line->pos;\n        }\n    }\n    return 0;\n}\n\nint bcf_update_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const char **values, int n)\n{\n    if ( !n )\n        return bcf_update_format(hdr,line,key,NULL,0,BCF_HT_STR);\n\n    int i, max_len = 0;\n    for (i=0; i<n; i++)\n    {\n        int len = strlen(values[i]);\n        if ( len > max_len ) max_len = len;\n    }\n    char *out = (char*) malloc(max_len*n);\n    if ( !out ) return -2;\n    for (i=0; i<n; i++)\n    {\n        char *dst = out+i*max_len;\n        const char *src = values[i];\n        int j = 0;\n        while ( src[j] ) { dst[j] = src[j]; j++; }\n        for (; j<max_len; j++) dst[j] = 0;\n    }\n    int ret = bcf_update_format(hdr,line,key,out,max_len*n,BCF_HT_STR);\n    free(out);\n    return ret;\n}\n\nint bcf_update_format(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)\n{\n    // Is the field already present?\n    int i, fmt_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,fmt_id) )\n    {\n        if ( !n ) return 0;\n        return -1;  // the key not present in the header\n    }\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==fmt_id ) break;\n    bcf_fmt_t *fmt = i==line->n_fmt ? NULL : &line->d.fmt[i];\n\n    if ( !n )\n    {\n        if ( fmt )\n        {\n            // Mark the tag for removal, free existing memory if necessary\n            if ( fmt->p_free )\n            {\n                free(fmt->p - fmt->p_off);\n                fmt->p_free = 0;\n            }\n            line->d.indiv_dirty = 1;\n            fmt->p = NULL;\n        }\n        return 0;\n    }\n\n    line->n_sample = bcf_hdr_nsamples(hdr);\n    int nps = n / line->n_sample;  // number of values per sample\n    assert( nps && nps*line->n_sample==n );     // must be divisible by n_sample\n\n    // Encode the values and determine the size required to accommodate the values\n    kstring_t str = {0,0,0};\n    bcf_enc_int1(&str, fmt_id);\n    assert(values != NULL);\n    if ( type==BCF_HT_INT )\n        bcf_enc_vint(&str, n, (int32_t*)values, nps);\n    else if ( type==BCF_HT_REAL )\n    {\n        bcf_enc_size(&str, nps, BCF_BT_FLOAT);\n        serialize_float_array(&str, nps*line->n_sample, (float *) values);\n    }\n    else if ( type==BCF_HT_STR )\n    {\n        bcf_enc_size(&str, nps, BCF_BT_CHAR);\n        kputsn((char*)values, nps*line->n_sample, &str);\n    }\n    else\n    {\n        hts_log_error(\"The type %d not implemented yet at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n        abort();\n    }\n\n    if ( !fmt )\n    {\n        // Not present, new format field\n        line->n_fmt++;\n        hts_expand0(bcf_fmt_t, line->n_fmt, line->d.m_fmt, line->d.fmt);\n\n        // Special case: VCF specification requires that GT is always first\n        if ( line->n_fmt > 1 && key[0]=='G' && key[1]=='T' && !key[2] )\n        {\n            for (i=line->n_fmt-1; i>0; i--)\n                line->d.fmt[i] = line->d.fmt[i-1];\n            fmt = &line->d.fmt[0];\n        }\n        else\n            fmt = &line->d.fmt[line->n_fmt-1];\n        bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);\n        line->d.indiv_dirty = 1;\n        fmt->p_free = 1;\n    }\n    else\n    {\n        // The tag is already present, check if it is big enough to accomodate the new block\n        if ( str.l <= fmt->p_len + fmt->p_off )\n        {\n            // good, the block is big enough\n            if ( str.l != fmt->p_len + fmt->p_off ) line->d.indiv_dirty = 1;\n            uint8_t *ptr = fmt->p - fmt->p_off;\n            memcpy(ptr, str.s, str.l);\n            free(str.s);\n            int p_free = fmt->p_free;\n            bcf_unpack_fmt_core1(ptr, line->n_sample, fmt);\n            fmt->p_free = p_free;\n        }\n        else\n        {\n            if ( fmt->p_free )\n                free(fmt->p - fmt->p_off);\n            bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);\n            fmt->p_free = 1;\n            line->d.indiv_dirty = 1;\n        }\n    }\n    line->unpacked |= BCF_UN_FMT;\n    return 0;\n}\n\n\nint bcf_update_filter(const bcf_hdr_t *hdr, bcf1_t *line, int *flt_ids, int n)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    line->d.n_flt = n;\n    if ( !n ) return 0;\n    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);\n    int i;\n    for (i=0; i<n; i++)\n        line->d.flt[i] = flt_ids[i];\n    return 0;\n}\n\nint bcf_add_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( flt_id==line->d.flt[i] ) break;\n    if ( i<line->d.n_flt ) return 0;    // this filter is already set\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    if ( flt_id==0 )    // set to PASS\n        line->d.n_flt = 1;\n    else if ( line->d.n_flt==1 && line->d.flt[0]==0 )\n        line->d.n_flt = 1;\n    else\n        line->d.n_flt++;\n    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);\n    line->d.flt[line->d.n_flt-1] = flt_id;\n    return 1;\n}\nint bcf_remove_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id, int pass)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( flt_id==line->d.flt[i] ) break;\n    if ( i==line->d.n_flt ) return 0;   // the filter is not present\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    if ( i!=line->d.n_flt-1 ) memmove(line->d.flt+i,line->d.flt+i+1,(line->d.n_flt-i-1)*sizeof(*line->d.flt));\n    line->d.n_flt--;\n    if ( !line->d.n_flt && pass ) bcf_add_filter(hdr,line,0);\n    return 0;\n}\n\nint bcf_has_filter(const bcf_hdr_t *hdr, bcf1_t *line, char *filter)\n{\n    if ( filter[0]=='.' && !filter[1] ) filter = \"PASS\";\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, filter);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FLT,id) ) return -1;  // not defined in the header\n\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    if ( id==0 && !line->d.n_flt) return 1; // PASS\n\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( line->d.flt[i]==id ) return 1;\n    return 0;\n}\n\nstatic inline int _bcf1_sync_alleles(const bcf_hdr_t *hdr, bcf1_t *line, int nals)\n{\n    line->d.shared_dirty |= BCF1_DIRTY_ALS;\n\n    line->n_allele = nals;\n    hts_expand(char*, line->n_allele, line->d.m_allele, line->d.allele);\n\n    char *als = line->d.als;\n    int n = 0;\n    while (n<nals)\n    {\n        line->d.allele[n] = als;\n        while ( *als ) als++;\n        als++;\n        n++;\n    }\n\n    // Update REF length. Note that END is 1-based while line->pos 0-based\n    bcf_info_t *end_info = bcf_get_info(hdr,line,\"END\");\n    if ( end_info )\n    {\n        if ( end_info->type==BCF_HT_INT && end_info->v1.i==bcf_int32_missing ) end_info = NULL;\n        else if ( end_info->type==BCF_HT_LONG && end_info->v1.i==bcf_int64_missing ) end_info = NULL;\n    }\n    if ( end_info && end_info->v1.i > line->pos )\n        line->rlen = end_info->v1.i - line->pos;\n    else if ( nals > 0 )\n        line->rlen = strlen(line->d.allele[0]);\n    else\n        line->rlen = 0;\n\n    return 0;\n}\nint bcf_update_alleles(const bcf_hdr_t *hdr, bcf1_t *line, const char **alleles, int nals)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp = {0,0,0};\n    char *free_old = NULL;\n\n    // If the supplied alleles are not pointers to line->d.als, the existing block can be reused.\n    int i;\n    for (i=0; i<nals; i++)\n        if ( alleles[i]>=line->d.als && alleles[i]<line->d.als+line->d.m_als ) break;\n    if ( i==nals )\n    {\n        // all alleles point elsewhere, reuse the existing block\n        tmp.l = 0; tmp.s = line->d.als; tmp.m = line->d.m_als;\n    }\n    else\n        free_old = line->d.als;\n\n    for (i=0; i<nals; i++)\n    {\n        kputs(alleles[i], &tmp);\n        kputc(0, &tmp);\n    }\n    line->d.als = tmp.s; line->d.m_als = tmp.m;\n    free(free_old);\n    return _bcf1_sync_alleles(hdr,line,nals);\n}\n\nint bcf_update_alleles_str(const bcf_hdr_t *hdr, bcf1_t *line, const char *alleles_string)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.als; tmp.m = line->d.m_als;\n    kputs(alleles_string, &tmp);\n    line->d.als = tmp.s; line->d.m_als = tmp.m;\n\n    int nals = 1;\n    char *t = line->d.als;\n    while (*t)\n    {\n        if ( *t==',' ) { *t = 0; nals++; }\n        t++;\n    }\n    return _bcf1_sync_alleles(hdr, line, nals);\n}\n\nint bcf_update_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;\n    if ( id )\n        kputs(id, &tmp);\n    else\n        kputs(\".\", &tmp);\n    line->d.id = tmp.s; line->d.m_id = tmp.m;\n    line->d.shared_dirty |= BCF1_DIRTY_ID;\n    return 0;\n}\n\nint bcf_add_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)\n{\n    if ( !id ) return 0;\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;\n\n    int len = strlen(id);\n    char *dst = line->d.id;\n    while ( *dst && (dst=strstr(dst,id)) )\n    {\n        if ( dst[len]!=0 && dst[len]!=';' ) dst++;              // a prefix, not a match\n        else if ( dst==line->d.id || dst[-1]==';' ) return 0;   // already present\n        dst++;  // a suffix, not a match\n    }\n    if ( line->d.id && (line->d.id[0]!='.' || line->d.id[1]) )\n    {\n        tmp.l = strlen(line->d.id);\n        kputc(';',&tmp);\n    }\n    kputs(id,&tmp);\n\n    line->d.id = tmp.s; line->d.m_id = tmp.m;\n    line->d.shared_dirty |= BCF1_DIRTY_ID;\n    return 0;\n\n}\n\nbcf_fmt_t *bcf_get_fmt(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)\n{\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) ) return NULL;   // no such FMT field in the header\n    return bcf_get_fmt_id(line, id);\n}\n\nbcf_info_t *bcf_get_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)\n{\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,id) ) return NULL;   // no such INFO field in the header\n    return bcf_get_info_id(line, id);\n}\n\nbcf_fmt_t *bcf_get_fmt_id(bcf1_t *line, const int id)\n{\n    int i;\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n    for (i=0; i<line->n_fmt; i++)\n    {\n        if ( line->d.fmt[i].id==id ) return &line->d.fmt[i];\n    }\n    return NULL;\n}\n\nbcf_info_t *bcf_get_info_id(bcf1_t *line, const int id)\n{\n    int i;\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n    for (i=0; i<line->n_info; i++)\n    {\n        if ( line->d.info[i].key==id ) return &line->d.info[i];\n    }\n    return NULL;\n}\n\n\nint bcf_get_info_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)\n{\n    int i, ret = -4, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,tag_id) ) return -1;    // no such INFO field in the header\n    if ( bcf_hdr_id2type(hdr,BCF_HL_INFO,tag_id)!=(type & 0xff) ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n\n    for (i=0; i<line->n_info; i++)\n        if ( line->d.info[i].key==tag_id ) break;\n    if ( i==line->n_info ) return ( type==BCF_HT_FLAG ) ? 0 : -3;       // the tag is not present in this record\n    if ( type==BCF_HT_FLAG ) return 1;\n\n    bcf_info_t *info = &line->d.info[i];\n    if ( !info->vptr ) return -3;           // the tag was marked for removal\n    if ( type==BCF_HT_STR )\n    {\n        if ( *ndst < info->len+1 )\n        {\n            *ndst = info->len + 1;\n            *dst  = realloc(*dst, *ndst);\n        }\n        memcpy(*dst,info->vptr,info->len);\n        ((uint8_t*)*dst)[info->len] = 0;\n        return info->len;\n    }\n\n    // Make sure the buffer is big enough\n    int size1;\n    switch (type) {\n        case BCF_HT_INT:  size1 = sizeof(int32_t); break;\n        case BCF_HT_LONG: size1 = sizeof(int64_t); break;\n        case BCF_HT_REAL: size1 = sizeof(float); break;\n        default:\n            hts_log_error(\"Unexpected output type %d at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n            return -2;\n    }\n    if ( *ndst < info->len )\n    {\n        *ndst = info->len;\n        *dst  = realloc(*dst, *ndst * size1);\n    }\n\n    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_regular, out_type_t) do { \\\n        out_type_t *tmp = (out_type_t *) *dst; \\\n        int j; \\\n        for (j=0; j<info->len; j++) \\\n        { \\\n            type_t p = convert(info->vptr + j * sizeof(type_t)); \\\n            if ( is_vector_end ) break; \\\n            if ( is_missing ) set_missing; \\\n            else set_regular; \\\n            tmp++; \\\n        } \\\n        ret = j; \\\n    } while (0)\n    switch (info->type) {\n        case BCF_BT_INT8:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int64_missing, *tmp=p, int64_t);\n            } else {\n                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=p, int32_t);\n            }\n            break;\n        case BCF_BT_INT16:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t);\n            } else {\n                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t);\n            }\n            break;\n        case BCF_BT_INT32:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t); break;\n            } else {\n                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t); break;\n            }\n        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set(tmp, p), float); break;\n        default: hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, info->type, bcf_seqname_safe(hdr,line), line->pos+1); return -2;\n    }\n    #undef BRANCH\n    return ret;  // set by BRANCH\n}\n\nint bcf_get_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, char ***dst, int *ndst)\n{\n    int i,tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header\n    if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==tag_id ) break;\n    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record\n    bcf_fmt_t *fmt = &line->d.fmt[i];\n    if ( !fmt->p ) return -3;                                      // the tag was marked for removal\n\n    int nsmpl = bcf_hdr_nsamples(hdr);\n    if ( !*dst )\n    {\n        *dst = (char**) malloc(sizeof(char*)*nsmpl);\n        if ( !*dst ) return -4;     // could not alloc\n        (*dst)[0] = NULL;\n    }\n    int n = (fmt->n+1)*nsmpl;\n    if ( *ndst < n )\n    {\n        (*dst)[0] = realloc((*dst)[0], n);\n        if ( !(*dst)[0] ) return -4;    // could not alloc\n        *ndst = n;\n    }\n    for (i=0; i<nsmpl; i++)\n    {\n        uint8_t *src = fmt->p + i*fmt->n;\n        uint8_t *tmp = (uint8_t*)(*dst)[0] + i*(fmt->n+1);\n        memcpy(tmp,src,fmt->n);\n        tmp[fmt->n] = 0;\n        (*dst)[i] = (char*) tmp;\n    }\n    return n;\n}\n\nint bcf_get_format_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)\n{\n    int i,j, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header\n    if ( tag[0]=='G' && tag[1]=='T' && tag[2]==0 )\n    {\n        // Ugly: GT field is considered to be a string by the VCF header but BCF represents it as INT.\n        if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;\n    }\n    else if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=type ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==tag_id ) break;\n    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record\n    bcf_fmt_t *fmt = &line->d.fmt[i];\n    if ( !fmt->p ) return -3;                                      // the tag was marked for removal\n\n    if ( type==BCF_HT_STR )\n    {\n        int n = fmt->n*bcf_hdr_nsamples(hdr);\n        if ( *ndst < n )\n        {\n            *dst  = realloc(*dst, n);\n            if ( !*dst ) return -4;     // could not alloc\n            *ndst = n;\n        }\n        memcpy(*dst,fmt->p,n);\n        return n;\n    }\n\n    // Make sure the buffer is big enough\n    int nsmpl = bcf_hdr_nsamples(hdr);\n    int size1 = type==BCF_HT_INT ? sizeof(int32_t) : sizeof(float);\n    if ( *ndst < fmt->n*nsmpl )\n    {\n        *ndst = fmt->n*nsmpl;\n        *dst  = realloc(*dst, *ndst*size1);\n        if ( !*dst ) return -4;     // could not alloc\n    }\n\n    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_vector_end, set_regular, out_type_t) { \\\n        out_type_t *tmp = (out_type_t *) *dst; \\\n        uint8_t *fmt_p = fmt->p; \\\n        for (i=0; i<nsmpl; i++) \\\n        { \\\n            for (j=0; j<fmt->n; j++) \\\n            { \\\n                type_t p = convert(fmt_p + j * sizeof(type_t)); \\\n                if ( is_missing ) set_missing; \\\n                else if ( is_vector_end ) { set_vector_end; break; } \\\n                else set_regular; \\\n                tmp++; \\\n            } \\\n            for (; j<fmt->n; j++) { set_vector_end; tmp++; } \\\n            fmt_p += fmt->size; \\\n        } \\\n    }\n    switch (fmt->type) {\n        case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set_vector_end(*tmp), bcf_float_set(tmp, p), float); break;\n        default: hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, fmt->type, bcf_seqname_safe(hdr,line), line->pos+1); exit(1);\n    }\n    #undef BRANCH\n    return nsmpl*fmt->n;\n}\n"], "fixing_code": ["/*  vcf.c -- VCF/BCF API functions.\n\n    Copyright (C) 2012, 2013 Broad Institute.\n    Copyright (C) 2012-2020 Genome Research Ltd.\n    Portions copyright (C) 2014 Intel Corporation.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h\n#include <config.h>\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <errno.h>\n\n#include \"htslib/vcf.h\"\n#include \"htslib/bgzf.h\"\n#include \"htslib/tbx.h\"\n#include \"htslib/hfile.h\"\n#include \"hts_internal.h\"\n#include \"htslib/hts_endian.h\"\n#include \"htslib/khash_str2int.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n\n#include \"htslib/khash.h\"\nKHASH_MAP_INIT_STR(vdict, bcf_idinfo_t)\ntypedef khash_t(vdict) vdict_t;\n\n#include \"htslib/kseq.h\"\nHTSLIB_EXPORT\nuint32_t bcf_float_missing    = 0x7F800001;\n\nHTSLIB_EXPORT\nuint32_t bcf_float_vector_end = 0x7F800002;\n\nHTSLIB_EXPORT\nuint8_t bcf_type_shift[] = { 0, 0, 1, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic bcf_idinfo_t bcf_idinfo_def = { .info = { 15, 15, 15 }, .hrec = { NULL, NULL, NULL}, .id = -1 };\n\n/*\n    Partial support for 64-bit POS and Number=1 INFO tags.\n    Notes:\n     - the support for 64-bit values is motivated by POS and INFO/END for large genomes\n     - the use of 64-bit values does not conform to the specification\n     - cannot output 64-bit BCF and if it does, it is not compatible with anything\n     - experimental, use at your risk\n*/\n#ifdef VCF_ALLOW_INT64\n    #define BCF_MAX_BT_INT64 (0x7fffffffffffffff)       /* INT64_MAX, for internal use only */\n    #define BCF_MIN_BT_INT64 -9223372036854775800LL     /* INT64_MIN + 8, for internal use only */\n#endif\n\n#define BCF_IS_64BIT (1<<30)\n\n\nstatic char *find_chrom_header_line(char *s)\n{\n    char *nl;\n    if (strncmp(s, \"#CHROM\\t\", 7) == 0) return s;\n    else if ((nl = strstr(s, \"\\n#CHROM\\t\")) != NULL) return nl+1;\n    else return NULL;\n}\n\n/*************************\n *** VCF header parser ***\n *************************/\n\nstatic int bcf_hdr_add_sample_len(bcf_hdr_t *h, const char *s, size_t len)\n{\n    if ( !s ) return 0;\n    if (len == 0) len = strlen(s);\n\n    const char *ss = s;\n    while ( *ss && isspace_c(*ss) && ss - s < len) ss++;\n    if ( !*ss || ss - s == len)\n    {\n        hts_log_error(\"Empty sample name: trailing spaces/tabs in the header line?\");\n        return -1;\n    }\n\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_SAMPLE];\n    int ret;\n    char *sdup = malloc(len + 1);\n    if (!sdup) return -1;\n    memcpy(sdup, s, len);\n    sdup[len] = 0;\n\n    // Ensure space is available in h->samples\n    size_t n = kh_size(d);\n    char **new_samples = realloc(h->samples, sizeof(char*) * (n + 1));\n    if (!new_samples) {\n        free(sdup);\n        return -1;\n    }\n    h->samples = new_samples;\n\n    int k = kh_put(vdict, d, sdup, &ret);\n    if (ret < 0) {\n        free(sdup);\n        return -1;\n    }\n    if (ret) { // absent\n        kh_val(d, k) = bcf_idinfo_def;\n        kh_val(d, k).id = n;\n    } else {\n        hts_log_error(\"Duplicated sample name '%s'\", s);\n        free(sdup);\n        return -1;\n    }\n    h->samples[n] = sdup;\n    h->dirty = 1;\n    return 0;\n}\n\nint bcf_hdr_add_sample(bcf_hdr_t *h, const char *s)\n{\n    return bcf_hdr_add_sample_len(h, s, 0);\n}\n\nint HTS_RESULT_USED bcf_hdr_parse_sample_line(bcf_hdr_t *h, const char *str)\n{\n    int ret = 0;\n    int i = 0;\n    const char *p, *q;\n    // add samples\n    for (p = q = str;; ++q) {\n        if (*q > '\\n') continue;\n        if (++i > 9) {\n            if ( bcf_hdr_add_sample_len(h, p, q - p) < 0 ) ret = -1;\n        }\n        if (*q == 0 || *q == '\\n' || ret < 0) break;\n        p = q + 1;\n    }\n\n    return ret;\n}\n\nint bcf_hdr_sync(bcf_hdr_t *h)\n{\n    int i;\n    for (i = 0; i < 3; i++)\n    {\n        vdict_t *d = (vdict_t*)h->dict[i];\n        khint_t k;\n        if ( h->n[i] < kh_size(d) )\n        {\n            bcf_idpair_t *new_idpair;\n            // this should be true only for i=2, BCF_DT_SAMPLE\n            new_idpair = (bcf_idpair_t*) realloc(h->id[i], kh_size(d)*sizeof(bcf_idpair_t));\n            if (!new_idpair) return -1;\n            h->n[i] = kh_size(d);\n            h->id[i] = new_idpair;\n        }\n        for (k=kh_begin(d); k<kh_end(d); k++)\n        {\n            if (!kh_exist(d,k)) continue;\n            h->id[i][kh_val(d,k).id].key = kh_key(d,k);\n            h->id[i][kh_val(d,k).id].val = &kh_val(d,k);\n        }\n    }\n    h->dirty = 0;\n    return 0;\n}\n\nvoid bcf_hrec_destroy(bcf_hrec_t *hrec)\n{\n    if (!hrec) return;\n    free(hrec->key);\n    if ( hrec->value ) free(hrec->value);\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        free(hrec->keys[i]);\n        free(hrec->vals[i]);\n    }\n    free(hrec->keys);\n    free(hrec->vals);\n    free(hrec);\n}\n\n// Copies all fields except IDX.\nbcf_hrec_t *bcf_hrec_dup(bcf_hrec_t *hrec)\n{\n    int save_errno;\n    bcf_hrec_t *out = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));\n    if (!out) return NULL;\n\n    out->type = hrec->type;\n    if ( hrec->key ) {\n        out->key = strdup(hrec->key);\n        if (!out->key) goto fail;\n    }\n    if ( hrec->value ) {\n        out->value = strdup(hrec->value);\n        if (!out->value) goto fail;\n    }\n    out->nkeys = hrec->nkeys;\n    out->keys = (char**) malloc(sizeof(char*)*hrec->nkeys);\n    if (!out->keys) goto fail;\n    out->vals = (char**) malloc(sizeof(char*)*hrec->nkeys);\n    if (!out->vals) goto fail;\n    int i, j = 0;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        if ( hrec->keys[i] && !strcmp(\"IDX\",hrec->keys[i]) ) continue;\n        if ( hrec->keys[i] ) {\n            out->keys[j] = strdup(hrec->keys[i]);\n            if (!out->keys[j]) goto fail;\n        }\n        if ( hrec->vals[i] ) {\n            out->vals[j] = strdup(hrec->vals[i]);\n            if (!out->vals[j]) goto fail;\n        }\n        j++;\n    }\n    if ( i!=j ) out->nkeys -= i-j;   // IDX was omitted\n    return out;\n\n fail:\n    save_errno = errno;\n    hts_log_error(\"%s\", strerror(errno));\n    bcf_hrec_destroy(out);\n    errno = save_errno;\n    return NULL;\n}\n\nvoid bcf_hrec_debug(FILE *fp, bcf_hrec_t *hrec)\n{\n    fprintf(fp, \"key=[%s] value=[%s]\", hrec->key, hrec->value?hrec->value:\"\");\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n        fprintf(fp, \"\\t[%s]=[%s]\", hrec->keys[i],hrec->vals[i]);\n    fprintf(fp, \"\\n\");\n}\n\nvoid bcf_header_debug(bcf_hdr_t *hdr)\n{\n    int i, j;\n    for (i=0; i<hdr->nhrec; i++)\n    {\n        if ( !hdr->hrec[i]->value )\n        {\n            fprintf(stderr, \"##%s=<\", hdr->hrec[i]->key);\n            fprintf(stderr,\"%s=%s\", hdr->hrec[i]->keys[0], hdr->hrec[i]->vals[0]);\n            for (j=1; j<hdr->hrec[i]->nkeys; j++)\n                fprintf(stderr,\",%s=%s\", hdr->hrec[i]->keys[j], hdr->hrec[i]->vals[j]);\n            fprintf(stderr,\">\\n\");\n        }\n        else\n            fprintf(stderr,\"##%s=%s\\n\", hdr->hrec[i]->key,hdr->hrec[i]->value);\n    }\n}\n\nint bcf_hrec_add_key(bcf_hrec_t *hrec, const char *str, size_t len)\n{\n    char **tmp;\n    size_t n = hrec->nkeys + 1;\n    assert(len > 0 && len < SIZE_MAX);\n    tmp = realloc(hrec->keys, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->keys = tmp;\n    tmp = realloc(hrec->vals, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->vals = tmp;\n\n    hrec->keys[hrec->nkeys] = (char*) malloc((len+1)*sizeof(char));\n    if (!hrec->keys[hrec->nkeys]) return -1;\n    memcpy(hrec->keys[hrec->nkeys],str,len);\n    hrec->keys[hrec->nkeys][len] = 0;\n    hrec->vals[hrec->nkeys] = NULL;\n    hrec->nkeys = n;\n    return 0;\n}\n\nint bcf_hrec_set_val(bcf_hrec_t *hrec, int i, const char *str, size_t len, int is_quoted)\n{\n    if ( hrec->vals[i] ) {\n        free(hrec->vals[i]);\n        hrec->vals[i] = NULL;\n    }\n    if ( !str ) return 0;\n    if ( is_quoted )\n    {\n        if (len >= SIZE_MAX - 3) {\n            errno = ENOMEM;\n            return -1;\n        }\n        hrec->vals[i] = (char*) malloc((len+3)*sizeof(char));\n        if (!hrec->vals[i]) return -1;\n        hrec->vals[i][0] = '\"';\n        memcpy(&hrec->vals[i][1],str,len);\n        hrec->vals[i][len+1] = '\"';\n        hrec->vals[i][len+2] = 0;\n    }\n    else\n    {\n        if (len == SIZE_MAX) {\n            errno = ENOMEM;\n            return -1;\n        }\n        hrec->vals[i] = (char*) malloc((len+1)*sizeof(char));\n        if (!hrec->vals[i]) return -1;\n        memcpy(hrec->vals[i],str,len);\n        hrec->vals[i][len] = 0;\n    }\n    return 0;\n}\n\nint hrec_add_idx(bcf_hrec_t *hrec, int idx)\n{\n    int n = hrec->nkeys + 1;\n    char **tmp = (char**) realloc(hrec->keys, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->keys = tmp;\n\n    tmp = (char**) realloc(hrec->vals, sizeof(char*)*n);\n    if (!tmp) return -1;\n    hrec->vals = tmp;\n\n    hrec->keys[hrec->nkeys] = strdup(\"IDX\");\n    if (!hrec->keys[hrec->nkeys]) return -1;\n\n    kstring_t str = {0,0,0};\n    if (kputw(idx, &str) < 0) {\n        free(hrec->keys[hrec->nkeys]);\n        return -1;\n    }\n    hrec->vals[hrec->nkeys] = str.s;\n    hrec->nkeys = n;\n    return 0;\n}\n\nint bcf_hrec_find_key(bcf_hrec_t *hrec, const char *key)\n{\n    int i;\n    for (i=0; i<hrec->nkeys; i++)\n        if ( !strcasecmp(key,hrec->keys[i]) ) return i;\n    return -1;\n}\n\nstatic inline int is_escaped(const char *min, const char *str)\n{\n    int n = 0;\n    while ( --str>=min && *str=='\\\\' ) n++;\n    return n%2;\n}\n\nbcf_hrec_t *bcf_hdr_parse_line(const bcf_hdr_t *h, const char *line, int *len)\n{\n    const char *p = line;\n    if (p[0] != '#' || p[1] != '#') { *len = 0; return NULL; }\n    p += 2;\n\n    const char *q = p;\n    while ( *q && *q!='=' && *q != '\\n' ) q++;\n    ptrdiff_t n = q-p;\n    if ( *q!='=' || !n ) { *len = q-line+1; return NULL; } // wrong format\n\n    bcf_hrec_t *hrec = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));\n    if (!hrec) return NULL;\n    hrec->key = (char*) malloc(sizeof(char)*(n+1));\n    if (!hrec->key) goto fail;\n    memcpy(hrec->key,p,n);\n    hrec->key[n] = 0;\n\n    p = ++q;\n    if ( *p!='<' ) // generic field, e.g. ##samtoolsVersion=0.1.18-r579\n    {\n        while ( *q && *q!='\\n' ) q++;\n        hrec->value = (char*) malloc((q-p+1)*sizeof(char));\n        if (!hrec->value) goto fail;\n        memcpy(hrec->value, p, q-p);\n        hrec->value[q-p] = 0;\n        *len = q - line + (*q ? 1 : 0); // Skip \\n but not \\0\n        return hrec;\n    }\n\n    // structured line, e.g.\n    // ##INFO=<ID=PV1,Number=1,Type=Float,Description=\"P-value for baseQ bias\">\n    // ##PEDIGREE=<Name_0=G0-ID,Name_1=G1-ID,Name_3=GN-ID>\n    int nopen = 1;\n    while ( *q && *q!='\\n' && nopen>0 )\n    {\n        p = ++q;\n        while ( *q && *q==' ' ) { p++; q++; }\n        // ^[A-Za-z_][0-9A-Za-z_.]*$\n        if (p==q && *q && (isalpha_c(*q) || *q=='_'))\n        {\n            q++;\n            while ( *q && (isalnum_c(*q) || *q=='_' || *q=='.') ) q++;\n        }\n        n = q-p;\n        int m = 0;\n        while ( *q && *q==' ' ) { q++; m++; }\n        if ( *q!='=' || !n )\n        {\n            // wrong format\n            while ( *q && *q!='\\n' ) q++;\n            hts_log_error(\"Could not parse the header line: \\\"%.*s\\\"\",\n                (int) (q - line), line);\n            *len = q - line + (*q ? 1 : 0);\n            bcf_hrec_destroy(hrec);\n            return NULL;\n        }\n        if (bcf_hrec_add_key(hrec, p, q-p-m) < 0) goto fail;\n        p = ++q;\n        while ( *q && *q==' ' ) { p++; q++; }\n        int quoted = *p=='\"' ? 1 : 0;\n        if ( quoted ) p++, q++;\n        while ( *q && *q != '\\n' )\n        {\n            if ( quoted ) { if ( *q=='\"' && !is_escaped(p,q) ) break; }\n            else\n            {\n                if ( *q=='<' ) nopen++;\n                if ( *q=='>' ) nopen--;\n                if ( !nopen ) break;\n                if ( *q==',' && nopen==1 ) break;\n            }\n            q++;\n        }\n        const char *r = q;\n        while ( r > p && r[-1] == ' ' ) r--;\n        if (bcf_hrec_set_val(hrec, hrec->nkeys-1, p, r-p, quoted) < 0)\n            goto fail;\n        if ( quoted && *q=='\"' ) q++;\n        if ( *q=='>' ) { nopen--; q++; }\n    }\n\n    // Skip to end of line\n    int nonspace = 0;\n    p = q;\n    while ( *q && *q!='\\n' ) { nonspace |= !isspace_c(*q); q++; }\n    if (nonspace) {\n        hts_log_warning(\"Dropped trailing junk from header line '%.*s'\", (int) (q - line), line);\n    }\n\n    *len = q - line + (*q ? 1 : 0);\n    return hrec;\n\n fail:\n    bcf_hrec_destroy(hrec);\n    return NULL;\n}\n\nstatic int bcf_hdr_set_idx(bcf_hdr_t *hdr, int dict_type, const char *tag, bcf_idinfo_t *idinfo)\n{\n    size_t new_n;\n\n    // If available, preserve existing IDX\n    if ( idinfo->id==-1 )\n        idinfo->id = hdr->n[dict_type];\n    else if ( idinfo->id < hdr->n[dict_type] && hdr->id[dict_type][idinfo->id].key )\n    {\n        hts_log_error(\"Conflicting IDX=%d lines in the header dictionary, the new tag is %s\",\n            idinfo->id, tag);\n        errno = EINVAL;\n        return -1;\n    }\n\n    new_n = idinfo->id >= hdr->n[dict_type] ? idinfo->id+1 : hdr->n[dict_type];\n    if (hts_resize(bcf_idpair_t, new_n, &hdr->m[dict_type],\n                   &hdr->id[dict_type], HTS_RESIZE_CLEAR)) {\n        return -1;\n    }\n    hdr->n[dict_type] = new_n;\n\n    // NB: the next kh_put call can invalidate the idinfo pointer, therefore\n    // we leave it unassigned here. It must be set explicitly in bcf_hdr_sync.\n    hdr->id[dict_type][idinfo->id].key = tag;\n\n    return 0;\n}\n\n// returns: 1 when hdr needs to be synced, -1 on error, 0 otherwise\nstatic int bcf_hdr_register_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)\n{\n    // contig\n    int i, ret, replacing = 0;\n    khint_t k;\n    char *str = NULL;\n\n    if ( !strcmp(hrec->key, \"contig\") )\n    {\n        hts_pos_t len = 0;\n        hrec->type = BCF_HL_CTG;\n\n        // Get the contig ID ($str) and length ($j)\n        i = bcf_hrec_find_key(hrec,\"length\");\n        if ( i<0 ) len = 0;\n        else {\n            char *end = hrec->vals[i];\n            len = strtoll(hrec->vals[i], &end, 10);\n            if (end == hrec->vals[i] || len < 0) return 0;\n        }\n\n        i = bcf_hrec_find_key(hrec,\"ID\");\n        if ( i<0 ) return 0;\n        str = strdup(hrec->vals[i]);\n        if (!str) return -1;\n\n        // Register in the dictionary\n        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_CTG];\n        khint_t k = kh_get(vdict, d, str);\n        if ( k != kh_end(d) ) { // already present\n            free(str); str=NULL;\n            if (kh_val(d, k).hrec[0] != NULL) // and not removed\n                return 0;\n            replacing = 1;\n        } else {\n            k = kh_put(vdict, d, str, &ret);\n            if (ret < 0) { free(str); return -1; }\n        }\n\n        int idx = bcf_hrec_find_key(hrec,\"IDX\");\n        if ( idx!=-1 )\n        {\n            char *tmp = hrec->vals[idx];\n            idx = strtol(hrec->vals[idx], &tmp, 10);\n            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)\n            {\n                if (!replacing) {\n                    kh_del(vdict, d, k);\n                    free(str);\n                }\n                hts_log_warning(\"Error parsing the IDX tag, skipping\");\n                return 0;\n            }\n        }\n\n        kh_val(d, k) = bcf_idinfo_def;\n        kh_val(d, k).id = idx;\n        kh_val(d, k).info[0] = len;\n        kh_val(d, k).hrec[0] = hrec;\n        if (bcf_hdr_set_idx(hdr, BCF_DT_CTG, kh_key(d,k), &kh_val(d,k)) < 0) {\n            if (!replacing) {\n                kh_del(vdict, d, k);\n                free(str);\n            }\n            return -1;\n        }\n        if ( idx==-1 ) {\n            if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {\n               return -1;\n            }\n        }\n\n        return 1;\n    }\n\n    if ( !strcmp(hrec->key, \"INFO\") ) hrec->type = BCF_HL_INFO;\n    else if ( !strcmp(hrec->key, \"FILTER\") ) hrec->type = BCF_HL_FLT;\n    else if ( !strcmp(hrec->key, \"FORMAT\") ) hrec->type = BCF_HL_FMT;\n    else if ( hrec->nkeys>0 ) { hrec->type = BCF_HL_STR; return 1; }\n    else return 0;\n\n    // INFO/FILTER/FORMAT\n    char *id = NULL;\n    uint32_t type = UINT32_MAX, var = UINT32_MAX;\n    int num = -1, idx = -1;\n    for (i=0; i<hrec->nkeys; i++)\n    {\n        if ( !strcmp(hrec->keys[i], \"ID\") ) id = hrec->vals[i];\n        else if ( !strcmp(hrec->keys[i], \"IDX\") )\n        {\n            char *tmp = hrec->vals[i];\n            idx = strtol(hrec->vals[i], &tmp, 10);\n            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)\n            {\n                hts_log_warning(\"Error parsing the IDX tag, skipping\");\n                return 0;\n            }\n        }\n        else if ( !strcmp(hrec->keys[i], \"Type\") )\n        {\n            if ( !strcmp(hrec->vals[i], \"Integer\") ) type = BCF_HT_INT;\n            else if ( !strcmp(hrec->vals[i], \"Float\") ) type = BCF_HT_REAL;\n            else if ( !strcmp(hrec->vals[i], \"String\") ) type = BCF_HT_STR;\n            else if ( !strcmp(hrec->vals[i], \"Character\") ) type = BCF_HT_STR;\n            else if ( !strcmp(hrec->vals[i], \"Flag\") ) type = BCF_HT_FLAG;\n            else\n            {\n                hts_log_warning(\"The type \\\"%s\\\" is not supported, assuming \\\"String\\\"\", hrec->vals[i]);\n                type = BCF_HT_STR;\n            }\n        }\n        else if ( !strcmp(hrec->keys[i], \"Number\") )\n        {\n            if ( !strcmp(hrec->vals[i],\"A\") ) var = BCF_VL_A;\n            else if ( !strcmp(hrec->vals[i],\"R\") ) var = BCF_VL_R;\n            else if ( !strcmp(hrec->vals[i],\"G\") ) var = BCF_VL_G;\n            else if ( !strcmp(hrec->vals[i],\".\") ) var = BCF_VL_VAR;\n            else\n            {\n                sscanf(hrec->vals[i],\"%d\",&num);\n                var = BCF_VL_FIXED;\n            }\n            if (var != BCF_VL_FIXED) num = 0xfffff;\n        }\n    }\n    if (hrec->type == BCF_HL_INFO || hrec->type == BCF_HL_FMT) {\n        if (type == -1) {\n            hts_log_warning(\"%s %s field has no Type defined. Assuming String\",\n                *hrec->key == 'I' ? \"An\" : \"A\", hrec->key);\n            type = BCF_HT_STR;\n        }\n        if (var == -1) {\n            hts_log_warning(\"%s %s field has no Number defined. Assuming '.'\",\n                *hrec->key == 'I' ? \"An\" : \"A\", hrec->key);\n            var = BCF_VL_VAR;\n        }\n    }\n    uint32_t info = ((((uint32_t)num) & 0xfffff)<<12 |\n                     (var & 0xf) << 8 |\n                     (type & 0xf) << 4 |\n                     (((uint32_t) hrec->type) & 0xf));\n\n    if ( !id ) return 0;\n    str = strdup(id);\n    if (!str) return -1;\n\n    vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_ID];\n    k = kh_get(vdict, d, str);\n    if ( k != kh_end(d) )\n    {\n        // already present\n        free(str);\n        if ( kh_val(d, k).hrec[info&0xf] ) return 0;\n        kh_val(d, k).info[info&0xf] = info;\n        kh_val(d, k).hrec[info&0xf] = hrec;\n        if ( idx==-1 ) {\n            if (hrec_add_idx(hrec, kh_val(d, k).id) < 0) {\n                return -1;\n            }\n        }\n        return 1;\n    }\n    k = kh_put(vdict, d, str, &ret);\n    if (ret < 0) {\n        free(str);\n        return -1;\n    }\n    kh_val(d, k) = bcf_idinfo_def;\n    kh_val(d, k).info[info&0xf] = info;\n    kh_val(d, k).hrec[info&0xf] = hrec;\n    kh_val(d, k).id = idx;\n    if (bcf_hdr_set_idx(hdr, BCF_DT_ID, kh_key(d,k), &kh_val(d,k)) < 0) {\n        kh_del(vdict, d, k);\n        free(str);\n        return -1;\n    }\n    if ( idx==-1 ) {\n        if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\nint bcf_hdr_add_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)\n{\n    int res;\n    if ( !hrec ) return 0;\n\n    hrec->type = BCF_HL_GEN;\n    res = bcf_hdr_register_hrec(hdr,hrec);\n    if (res < 0) return -1;\n    if ( !res )\n    {\n        // If one of the hashed field, then it is already present\n        if ( hrec->type != BCF_HL_GEN )\n        {\n            bcf_hrec_destroy(hrec);\n            return 0;\n        }\n\n        // Is one of the generic fields and already present?\n        int i;\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=BCF_HL_GEN ) continue;\n            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hrec->key,\"fileformat\") ) break;\n            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hdr->hrec[i]->value,hrec->value) ) break;\n        }\n        if ( i<hdr->nhrec )\n        {\n            bcf_hrec_destroy(hrec);\n            return 0;\n        }\n    }\n\n    // New record, needs to be added\n    int n = hdr->nhrec + 1;\n    bcf_hrec_t **new_hrec = realloc(hdr->hrec, n*sizeof(bcf_hrec_t*));\n    if (!new_hrec) return -1;\n    hdr->hrec = new_hrec;\n    hdr->hrec[hdr->nhrec] = hrec;\n    hdr->dirty = 1;\n    hdr->nhrec = n;\n\n    return hrec->type==BCF_HL_GEN ? 0 : 1;\n}\n\n/*\n *  Note that while querying of FLT,INFO,FMT,CTG lines is fast (the keys are hashed),\n *  the STR,GEN lines are searched for linearly in a linked list of all header lines.\n *  This may become a problem for VCFs with huge headers, we might need to build a\n *  dictionary for these lines as well.\n */\nbcf_hrec_t *bcf_hdr_get_hrec(const bcf_hdr_t *hdr, int type, const char *key, const char *value, const char *str_class)\n{\n    int i;\n    if ( type==BCF_HL_GEN )\n    {\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=type ) continue;\n            if ( strcmp(hdr->hrec[i]->key,key) ) continue;\n            if ( !value || !strcmp(hdr->hrec[i]->value,value) ) return hdr->hrec[i];\n        }\n        return NULL;\n    }\n    else if ( type==BCF_HL_STR )\n    {\n        for (i=0; i<hdr->nhrec; i++)\n        {\n            if ( hdr->hrec[i]->type!=type ) continue;\n            if ( strcmp(hdr->hrec[i]->key,str_class) ) continue;\n            int j = bcf_hrec_find_key(hdr->hrec[i],key);\n            if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],value) ) return hdr->hrec[i];\n        }\n        return NULL;\n    }\n    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n    khint_t k = kh_get(vdict, d, value);\n    if ( k == kh_end(d) ) return NULL;\n    return kh_val(d, k).hrec[type==BCF_HL_CTG?0:type];\n}\n\nvoid bcf_hdr_check_sanity(bcf_hdr_t *hdr)\n{\n    static int PL_warned = 0, GL_warned = 0;\n\n    if ( !PL_warned )\n    {\n        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, \"PL\");\n        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )\n        {\n            hts_log_warning(\"PL should be declared as Number=G\");\n            PL_warned = 1;\n        }\n    }\n    if ( !GL_warned )\n    {\n        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, \"GL\");\n        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )\n        {\n            hts_log_warning(\"GL should be declared as Number=G\");\n            GL_warned = 1;\n        }\n    }\n}\n\nint bcf_hdr_parse(bcf_hdr_t *hdr, char *htxt)\n{\n    int len, done = 0;\n    char *p = htxt;\n\n    // Check sanity: \"fileformat\" string must come as first\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,p,&len);\n    if ( !hrec || !hrec->key || strcasecmp(hrec->key,\"fileformat\") )\n        hts_log_warning(\"The first line should be ##fileformat; is the VCF/BCF header broken?\");\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n        bcf_hrec_destroy(hrec);\n        return -1;\n    }\n\n    // The filter PASS must appear first in the dictionary\n    hrec = bcf_hdr_parse_line(hdr,\"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\",&len);\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n        bcf_hrec_destroy(hrec);\n        return -1;\n    }\n\n    // Parse the whole header\n    do {\n        while (NULL != (hrec = bcf_hdr_parse_line(hdr, p, &len))) {\n            if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n                bcf_hrec_destroy(hrec);\n                return -1;\n            }\n            p += len;\n        }\n\n        // Next should be the sample line.  If not, it was a malformed\n        // header, in which case print a warning and skip (many VCF\n        // operations do not really care about a few malformed lines).\n        // In the future we may want to add a strict mode that errors in\n        // this case.\n        if ( strncmp(\"#CHROM\\tPOS\",p,10) != 0 ) {\n            char *eol = strchr(p, '\\n');\n            if (*p != '\\0') {\n                hts_log_warning(\"Could not parse header line: %.*s\",\n                    eol ? (int)(eol - p) : INT_MAX, p);\n            }\n            if (eol) {\n                p = eol + 1; // Try from the next line.\n            } else {\n                done = -1; // No more lines left, give up.\n            }\n        } else {\n            done = 1; // Sample line found\n        }\n    } while (!done);\n\n    if (done < 0) {\n        // No sample line is fatal.\n        hts_log_error(\"Could not parse the header, sample line not found\");\n        return -1;\n    }\n\n    if (bcf_hdr_parse_sample_line(hdr,p) < 0)\n        return -1;\n    if (bcf_hdr_sync(hdr) < 0)\n        return -1;\n    bcf_hdr_check_sanity(hdr);\n    return 0;\n}\n\nint bcf_hdr_append(bcf_hdr_t *hdr, const char *line)\n{\n    int len;\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr, (char*) line, &len);\n    if ( !hrec ) return -1;\n    if (bcf_hdr_add_hrec(hdr, hrec) < 0)\n        return -1;\n    return 0;\n}\n\nvoid bcf_hdr_remove(bcf_hdr_t *hdr, int type, const char *key)\n{\n    int i = 0;\n    bcf_hrec_t *hrec;\n    if ( !key )\n    {\n        while ( i<hdr->nhrec )\n        {\n            if ( hdr->hrec[i]->type!=type ) { i++; continue; }\n            hrec = hdr->hrec[i];\n\n            if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )\n            {\n                int j = bcf_hrec_find_key(hdr->hrec[i], \"ID\");\n                if ( j>=0 )\n                {\n                    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n                    khint_t k = kh_get(vdict, d, hdr->hrec[i]->vals[j]);\n                    kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;\n                }\n            }\n\n            hdr->dirty = 1;\n            hdr->nhrec--;\n            if ( i < hdr->nhrec )\n                memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));\n            bcf_hrec_destroy(hrec);\n        }\n        return;\n    }\n    while (1)\n    {\n        if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )\n        {\n            hrec = bcf_hdr_get_hrec(hdr, type, \"ID\", key, NULL);\n            if ( !hrec ) return;\n\n            for (i=0; i<hdr->nhrec; i++)\n                if ( hdr->hrec[i]==hrec ) break;\n            assert( i<hdr->nhrec );\n\n            vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];\n            khint_t k = kh_get(vdict, d, key);\n            kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;\n        }\n        else\n        {\n            for (i=0; i<hdr->nhrec; i++)\n            {\n                if ( hdr->hrec[i]->type!=type ) continue;\n                if ( type==BCF_HL_GEN )\n                {\n                    if ( !strcmp(hdr->hrec[i]->key,key) ) break;\n                }\n                else\n                {\n                    // not all structured lines have ID, we could be more sophisticated as in bcf_hdr_get_hrec()\n                    int j = bcf_hrec_find_key(hdr->hrec[i], \"ID\");\n                    if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],key) ) break;\n                }\n            }\n            if ( i==hdr->nhrec ) return;\n            hrec = hdr->hrec[i];\n        }\n\n        hdr->nhrec--;\n        if ( i < hdr->nhrec )\n            memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));\n        bcf_hrec_destroy(hrec);\n        hdr->dirty = 1;\n    }\n}\n\nint bcf_hdr_printf(bcf_hdr_t *hdr, const char *fmt, ...)\n{\n    char tmp[256], *line = tmp;\n    va_list ap;\n    va_start(ap, fmt);\n    int n = vsnprintf(line, sizeof(tmp), fmt, ap);\n    va_end(ap);\n\n    if (n >= sizeof(tmp)) {\n        n++; // For trailing NUL\n        line = (char*)malloc(n);\n        if (!line)\n            return -1;\n\n        va_start(ap, fmt);\n        vsnprintf(line, n, fmt, ap);\n        va_end(ap);\n    }\n\n    int ret = bcf_hdr_append(hdr, line);\n\n    if (line != tmp) free(line);\n    return ret;\n}\n\n\n/**********************\n *** BCF header I/O ***\n **********************/\n\nconst char *bcf_hdr_get_version(const bcf_hdr_t *hdr)\n{\n    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, \"fileformat\", NULL, NULL);\n    if ( !hrec )\n    {\n        hts_log_warning(\"No version string found, assuming VCFv4.2\");\n        return \"VCFv4.2\";\n    }\n    return hrec->value;\n}\n\nint bcf_hdr_set_version(bcf_hdr_t *hdr, const char *version)\n{\n    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, \"fileformat\", NULL, NULL);\n    if ( !hrec )\n    {\n        int len;\n        kstring_t str = {0,0,0};\n        ksprintf(&str,\"##fileformat=%s\", version);\n        hrec = bcf_hdr_parse_line(hdr, str.s, &len);\n        free(str.s);\n    }\n    else\n    {\n        free(hrec->value);\n        hrec->value = strdup(version);\n    }\n    hdr->dirty = 1;\n    return 0; // FIXME: check for errs in this function (return < 0 if so)\n}\n\nbcf_hdr_t *bcf_hdr_init(const char *mode)\n{\n    int i;\n    bcf_hdr_t *h;\n    h = (bcf_hdr_t*)calloc(1, sizeof(bcf_hdr_t));\n    if (!h) return NULL;\n    for (i = 0; i < 3; ++i)\n        if ((h->dict[i] = kh_init(vdict)) == NULL) goto fail;\n    if ( strchr(mode,'w') )\n    {\n        bcf_hdr_append(h, \"##fileformat=VCFv4.2\");\n        // The filter PASS must appear first in the dictionary\n        bcf_hdr_append(h, \"##FILTER=<ID=PASS,Description=\\\"All filters passed\\\">\");\n    }\n    return h;\n\n fail:\n    for (i = 0; i < 3; ++i)\n        kh_destroy(vdict, h->dict[i]);\n    free(h);\n    return NULL;\n}\n\nvoid bcf_hdr_destroy(bcf_hdr_t *h)\n{\n    int i;\n    khint_t k;\n    if (!h) return;\n    for (i = 0; i < 3; ++i) {\n        vdict_t *d = (vdict_t*)h->dict[i];\n        if (d == 0) continue;\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        free(h->id[i]);\n    }\n    for (i=0; i<h->nhrec; i++)\n        bcf_hrec_destroy(h->hrec[i]);\n    if (h->nhrec) free(h->hrec);\n    if (h->samples) free(h->samples);\n    free(h->keep_samples);\n    free(h->transl[0]); free(h->transl[1]);\n    free(h->mem.s);\n    free(h);\n}\n\nbcf_hdr_t *bcf_hdr_read(htsFile *hfp)\n{\n    if (hfp->format.format == vcf)\n        return vcf_hdr_read(hfp);\n    if (hfp->format.format != bcf) {\n        hts_log_error(\"Input is not detected as bcf or vcf format\");\n        return NULL;\n    }\n\n    assert(hfp->is_bgzf);\n\n    BGZF *fp = hfp->fp.bgzf;\n    uint8_t magic[5];\n    bcf_hdr_t *h;\n    h = bcf_hdr_init(\"r\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    if (bgzf_read(fp, magic, 5) != 5)\n    {\n        hts_log_error(\"Failed to read the header (reading BCF in text mode?)\");\n        bcf_hdr_destroy(h);\n        return NULL;\n    }\n    if (strncmp((char*)magic, \"BCF\\2\\2\", 5) != 0)\n    {\n        if (!strncmp((char*)magic, \"BCF\", 3))\n            hts_log_error(\"Invalid BCF2 magic string: only BCFv2.2 is supported\");\n        else\n            hts_log_error(\"Invalid BCF2 magic string\");\n        bcf_hdr_destroy(h);\n        return NULL;\n    }\n    uint8_t buf[4];\n    size_t hlen;\n    char *htxt = NULL;\n    if (bgzf_read(fp, buf, 4) != 4) goto fail;\n    hlen = buf[0] | (buf[1] << 8) | (buf[2] << 16) | ((size_t) buf[3] << 24);\n    if (hlen >= SIZE_MAX) { errno = ENOMEM; goto fail; }\n    htxt = (char*)malloc(hlen + 1);\n    if (!htxt) goto fail;\n    if (bgzf_read(fp, htxt, hlen) != hlen) goto fail;\n    htxt[hlen] = '\\0'; // Ensure htxt is terminated\n    if ( bcf_hdr_parse(h, htxt) < 0 ) goto fail;\n    free(htxt);\n    return h;\n fail:\n    hts_log_error(\"Failed to read BCF header\");\n    free(htxt);\n    bcf_hdr_destroy(h);\n    return NULL;\n}\n\nint bcf_hdr_write(htsFile *hfp, bcf_hdr_t *h)\n{\n    if (!h) {\n        errno = EINVAL;\n        return -1;\n    }\n    if ( h->dirty ) {\n        if (bcf_hdr_sync(h) < 0) return -1;\n    }\n    hfp->format.category = variant_data;\n    if (hfp->format.format == vcf || hfp->format.format == text_format) {\n        hfp->format.format = vcf;\n        return vcf_hdr_write(hfp, h);\n    }\n\n    if (hfp->format.format == binary_format)\n        hfp->format.format = bcf;\n\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(h, 1, &htxt);\n    kputc('\\0', &htxt); // include the \\0 byte\n\n    BGZF *fp = hfp->fp.bgzf;\n    if ( bgzf_write(fp, \"BCF\\2\\2\", 5) !=5 ) return -1;\n    uint8_t hlen[4];\n    u32_to_le(htxt.l, hlen);\n    if ( bgzf_write(fp, hlen, 4) !=4 ) return -1;\n    if ( bgzf_write(fp, htxt.s, htxt.l) != htxt.l ) return -1;\n\n    free(htxt.s);\n    return 0;\n}\n\n/********************\n *** BCF site I/O ***\n ********************/\n\nbcf1_t *bcf_init()\n{\n    bcf1_t *v;\n    v = (bcf1_t*)calloc(1, sizeof(bcf1_t));\n    return v;\n}\n\nvoid bcf_clear(bcf1_t *v)\n{\n    int i;\n    for (i=0; i<v->d.m_info; i++)\n    {\n        if ( v->d.info[i].vptr_free )\n        {\n            free(v->d.info[i].vptr - v->d.info[i].vptr_off);\n            v->d.info[i].vptr_free = 0;\n        }\n    }\n    for (i=0; i<v->d.m_fmt; i++)\n    {\n        if ( v->d.fmt[i].p_free )\n        {\n            free(v->d.fmt[i].p - v->d.fmt[i].p_off);\n            v->d.fmt[i].p_free = 0;\n        }\n    }\n    v->rid = v->pos = v->rlen = v->unpacked = 0;\n    bcf_float_set_missing(v->qual);\n    v->n_info = v->n_allele = v->n_fmt = v->n_sample = 0;\n    v->shared.l = v->indiv.l = 0;\n    v->d.var_type = -1;\n    v->d.shared_dirty = 0;\n    v->d.indiv_dirty  = 0;\n    v->d.n_flt = 0;\n    v->errcode = 0;\n    if (v->d.m_als) v->d.als[0] = 0;\n    if (v->d.m_id) v->d.id[0] = 0;\n}\n\nvoid bcf_empty(bcf1_t *v)\n{\n    bcf_clear1(v);\n    free(v->d.id);\n    free(v->d.als);\n    free(v->d.allele); free(v->d.flt); free(v->d.info); free(v->d.fmt);\n    if (v->d.var ) free(v->d.var);\n    free(v->shared.s); free(v->indiv.s);\n    memset(&v->d,0,sizeof(v->d));\n    memset(&v->shared,0,sizeof(v->shared));\n    memset(&v->indiv,0,sizeof(v->indiv));\n}\n\nvoid bcf_destroy(bcf1_t *v)\n{\n    if (!v) return;\n    bcf_empty1(v);\n    free(v);\n}\n\nstatic inline int bcf_read1_core(BGZF *fp, bcf1_t *v)\n{\n    uint8_t x[32];\n    ssize_t ret;\n    uint32_t shared_len, indiv_len;\n    if ((ret = bgzf_read(fp, x, 32)) != 32) {\n        if (ret == 0) return -1;\n        return -2;\n    }\n    bcf_clear1(v);\n    shared_len = le_to_u32(x);\n    if (shared_len < 24) return -2;\n    shared_len -= 24; // to exclude six 32-bit integers\n    if (ks_resize(&v->shared, shared_len) != 0) return -2;\n    indiv_len = le_to_u32(x + 4);\n    if (ks_resize(&v->indiv, indiv_len) != 0) return -2;\n    v->rid  = le_to_i32(x + 8);\n    v->pos  = le_to_u32(x + 12);\n    v->rlen = le_to_i32(x + 16);\n    v->qual = le_to_float(x + 20);\n    v->n_info = le_to_u16(x + 24);\n    v->n_allele = le_to_u16(x + 26);\n    v->n_sample = le_to_u32(x + 28) & 0xffffff;\n    v->n_fmt = x[31];\n    v->shared.l = shared_len;\n    v->indiv.l = indiv_len;\n    // silent fix of broken BCFs produced by earlier versions of bcf_subset, prior to and including bd6ed8b4\n    if ( (!v->indiv.l || !v->n_sample) && v->n_fmt ) v->n_fmt = 0;\n\n    if (bgzf_read(fp, v->shared.s, v->shared.l) != v->shared.l) return -2;\n    if (bgzf_read(fp, v->indiv.s, v->indiv.l) != v->indiv.l) return -2;\n    return 0;\n}\n\n#define bit_array_size(n) ((n)/8+1)\n#define bit_array_set(a,i)   ((a)[(i)/8] |=   1 << ((i)%8))\n#define bit_array_clear(a,i) ((a)[(i)/8] &= ~(1 << ((i)%8)))\n#define bit_array_test(a,i)  ((a)[(i)/8] &   (1 << ((i)%8)))\n\nstatic int bcf_dec_typed_int1_safe(uint8_t *p, uint8_t *end, uint8_t **q,\n                                   int32_t *val) {\n    uint32_t t;\n    if (end - p < 2) return -1;\n    t = *p++ & 0xf;\n    /* Use if .. else if ... else instead of switch to force order.  Assumption\n       is that small integers are more frequent than big ones. */\n    if (t == BCF_BT_INT8) {\n        *q = p + 1;\n        *val = *(int8_t *) p;\n    } else if (t == BCF_BT_INT16) {\n        if (end - p < 2) return -1;\n        *q = p + 2;\n        *val = le_to_i16(p);\n    } else if (t == BCF_BT_INT32) {\n        if (end - p < 4) return -1;\n        *q = p + 4;\n        *val = le_to_i32(p);\n#ifdef VCF_ALLOW_INT64\n    } else if (t == BCF_BT_INT64) {\n        // This case should never happen because there should be no 64-bit BCFs\n        // at all, definitely not coming from htslib\n        if (end - p < 8) return -1;\n        *q = p + 8;\n        *val = le_to_i64(p);\n#endif\n    } else {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int bcf_dec_size_safe(uint8_t *p, uint8_t *end, uint8_t **q,\n                             int *num, int *type) {\n    int r;\n    if (p >= end) return -1;\n    *type = *p & 0xf;\n    if (*p>>4 != 15) {\n        *q = p + 1;\n        *num = *p >> 4;\n        return 0;\n    }\n    r = bcf_dec_typed_int1_safe(p + 1, end, q, num);\n    if (r) return r;\n    return *num >= 0 ? 0 : -1;\n}\n\nstatic const char *get_type_name(int type) {\n    const char *types[9] = {\n        \"null\", \"int (8-bit)\", \"int (16 bit)\", \"int (32 bit)\",\n        \"unknown\", \"float\", \"unknown\", \"char\", \"unknown\"\n    };\n    int t = (type >= 0 && type < 8) ? type : 8;\n    return types[t];\n}\n\nstatic int bcf_record_check(const bcf_hdr_t *hdr, bcf1_t *rec) {\n    uint8_t *ptr, *end;\n    size_t bytes;\n    uint32_t err = 0;\n    int type = 0;\n    int num  = 0;\n    int reflen = 0;\n    uint32_t i, reports;\n    const uint32_t is_integer = ((1 << BCF_BT_INT8)  |\n                                 (1 << BCF_BT_INT16) |\n#ifdef VCF_ALLOW_INT64\n                                 (1 << BCF_BT_INT64) |\n#endif\n                                 (1 << BCF_BT_INT32));\n    const uint32_t is_valid_type = (is_integer          |\n                                    (1 << BCF_BT_NULL)  |\n                                    (1 << BCF_BT_FLOAT) |\n                                    (1 << BCF_BT_CHAR));\n    int32_t max_id = hdr ? hdr->n[BCF_DT_ID] : 0;\n\n    // Check for valid contig ID\n    if (rec->rid < 0\n        || (hdr && (rec->rid >= hdr->n[BCF_DT_CTG]\n                    || hdr->id[BCF_DT_CTG][rec->rid].key == NULL))) {\n        hts_log_warning(\"Bad BCF record at %\"PRIhts_pos\": Invalid %s id %d\", rec->pos+1, \"CONTIG\", rec->rid);\n        err |= BCF_ERR_CTG_INVALID;\n    }\n\n    // Check ID\n    ptr = (uint8_t *) rec->shared.s;\n    end = ptr + rec->shared.l;\n    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n    if (type != BCF_BT_CHAR) {\n        hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"ID\", type, get_type_name(type));\n        err |= BCF_ERR_TAG_INVALID;\n    }\n    bytes = (size_t) num << bcf_type_shift[type];\n    if (end - ptr < bytes) goto bad_shared;\n    ptr += bytes;\n\n    // Check REF and ALT\n    reports = 0;\n    for (i = 0; i < rec->n_allele; i++) {\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n        if (type != BCF_BT_CHAR) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"REF/ALT\", type, get_type_name(type));\n            err |= BCF_ERR_CHAR;\n        }\n        if (i == 0) reflen = num;\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (end - ptr < bytes) goto bad_shared;\n        ptr += bytes;\n    }\n\n    // Check FILTER\n    reports = 0;\n    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n    if (num > 0) {\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (((1 << type) & is_integer) == 0) {\n            hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FILTER\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n            if (end - ptr < bytes) goto bad_shared;\n            ptr += bytes;\n        } else {\n            if (end - ptr < bytes) goto bad_shared;\n            for (i = 0; i < num; i++) {\n                int32_t key = bcf_dec_int1(ptr, type, &ptr);\n                if (key < 0\n                    || (hdr && (key >= max_id\n                                || hdr->id[BCF_DT_ID][key].key == NULL))) {\n                    if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                        hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FILTER\", key);\n                    err |= BCF_ERR_TAG_UNDEF;\n                }\n            }\n        }\n    }\n\n    // Check INFO\n    reports = 0;\n    for (i = 0; i < rec->n_info; i++) {\n        int32_t key = -1;\n        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_shared;\n        if (key < 0 || (hdr && (key >= max_id\n                                || hdr->id[BCF_DT_ID][key].key == NULL))) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"INFO\", key);\n            err |= BCF_ERR_TAG_UNDEF;\n        }\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;\n        if (((1 << type) & is_valid_type) == 0) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"INFO\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n        }\n        bytes = (size_t) num << bcf_type_shift[type];\n        if (end - ptr < bytes) goto bad_shared;\n        ptr += bytes;\n    }\n\n    // Check FORMAT and individual information\n    ptr = (uint8_t *) rec->indiv.s;\n    end = ptr + rec->indiv.l;\n    reports = 0;\n    for (i = 0; i < rec->n_fmt; i++) {\n        int32_t key = -1;\n        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_indiv;\n        if (key < 0\n            || (hdr && (key >= max_id\n                        || hdr->id[BCF_DT_ID][key].key == NULL))) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s id %d\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FORMAT\", key);\n            err |= BCF_ERR_TAG_UNDEF;\n        }\n        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_indiv;\n        if (((1 << type) & is_valid_type) == 0) {\n            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)\n                hts_log_warning(\"Bad BCF record at %s:%\"PRIhts_pos\": Invalid %s type %d (%s)\", bcf_seqname_safe(hdr,rec), rec->pos+1, \"FORMAT\", type, get_type_name(type));\n            err |= BCF_ERR_TAG_INVALID;\n        }\n        bytes = ((size_t) num << bcf_type_shift[type]) * rec->n_sample;\n        if (end - ptr < bytes) goto bad_indiv;\n        ptr += bytes;\n    }\n\n    if (!err && rec->rlen < 0) {\n        // Treat bad rlen as a warning instead of an error, and try to\n        // fix up by using the length of the stored REF allele.\n        static int warned = 0;\n        if (!warned) {\n            hts_log_warning(\"BCF record at %s:%\"PRIhts_pos\" has invalid RLEN (%\"PRIhts_pos\"). \"\n                            \"Only one invalid RLEN will be reported.\",\n                            bcf_seqname_safe(hdr,rec), rec->pos+1, rec->rlen);\n            warned = 1;\n        }\n        rec->rlen = reflen >= 0 ? reflen : 0;\n    }\n\n    rec->errcode |= err;\n\n    return err ? -2 : 0; // Return -2 so bcf_read() reports an error\n\n bad_shared:\n    hts_log_error(\"Bad BCF record at %s:%\"PRIhts_pos\" - shared section malformed or too short\", bcf_seqname_safe(hdr,rec), rec->pos+1);\n    return -2;\n\n bad_indiv:\n    hts_log_error(\"Bad BCF record at %s:%\"PRIhts_pos\" - individuals section malformed or too short\", bcf_seqname_safe(hdr,rec), rec->pos+1);\n    return -2;\n}\n\nstatic inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt);\nint bcf_subset_format(const bcf_hdr_t *hdr, bcf1_t *rec)\n{\n    if ( !hdr->keep_samples ) return 0;\n    if ( !bcf_hdr_nsamples(hdr) )\n    {\n        rec->indiv.l = rec->n_sample = 0;\n        return 0;\n    }\n\n    int i, j;\n    uint8_t *ptr = (uint8_t*)rec->indiv.s, *dst = NULL, *src;\n    bcf_dec_t *dec = &rec->d;\n    hts_expand(bcf_fmt_t, rec->n_fmt, dec->m_fmt, dec->fmt);\n    for (i=0; i<dec->m_fmt; ++i) dec->fmt[i].p_free = 0;\n\n    for (i=0; i<rec->n_fmt; i++)\n    {\n        ptr = bcf_unpack_fmt_core1(ptr, rec->n_sample, &dec->fmt[i]);\n        src = dec->fmt[i].p - dec->fmt[i].size;\n        if ( dst )\n        {\n            memmove(dec->fmt[i-1].p + dec->fmt[i-1].p_len, dec->fmt[i].p - dec->fmt[i].p_off, dec->fmt[i].p_off);\n            dec->fmt[i].p = dec->fmt[i-1].p + dec->fmt[i-1].p_len + dec->fmt[i].p_off;\n        }\n        dst = dec->fmt[i].p;\n        for (j=0; j<hdr->nsamples_ori; j++)\n        {\n            src += dec->fmt[i].size;\n            if ( !bit_array_test(hdr->keep_samples,j) ) continue;\n            memmove(dst, src, dec->fmt[i].size);\n            dst += dec->fmt[i].size;\n        }\n        rec->indiv.l -= dec->fmt[i].p_len - (dst - dec->fmt[i].p);\n        dec->fmt[i].p_len = dst - dec->fmt[i].p;\n    }\n    rec->unpacked |= BCF_UN_FMT;\n\n    rec->n_sample = bcf_hdr_nsamples(hdr);\n    return 0;\n}\n\nint bcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    if (fp->format.format == vcf) return vcf_read(fp,h,v);\n    int ret = bcf_read1_core(fp->fp.bgzf, v);\n    if (ret == 0) ret = bcf_record_check(h, v);\n    if ( ret!=0 || !h->keep_samples ) return ret;\n    return bcf_subset_format(h,v);\n}\n\nint bcf_readrec(BGZF *fp, void *null, void *vv, int *tid, hts_pos_t *beg, hts_pos_t *end)\n{\n    bcf1_t *v = (bcf1_t *) vv;\n    int ret = bcf_read1_core(fp, v);\n    if (ret == 0) ret = bcf_record_check(NULL, v);\n    if (ret  >= 0)\n        *tid = v->rid, *beg = v->pos, *end = v->pos + v->rlen;\n    return ret;\n}\n\nstatic inline int bcf1_sync_id(bcf1_t *line, kstring_t *str)\n{\n    // single typed string\n    if ( line->d.id && strcmp(line->d.id, \".\") ) {\n        return bcf_enc_vchar(str, strlen(line->d.id), line->d.id);\n    } else {\n        return bcf_enc_size(str, 0, BCF_BT_CHAR);\n    }\n}\nstatic inline int bcf1_sync_alleles(bcf1_t *line, kstring_t *str)\n{\n    // list of typed strings\n    int i;\n    for (i=0; i<line->n_allele; i++) {\n        if (bcf_enc_vchar(str, strlen(line->d.allele[i]), line->d.allele[i]) < 0)\n            return -1;\n    }\n    if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);\n    return 0;\n}\nstatic inline int bcf1_sync_filter(bcf1_t *line, kstring_t *str)\n{\n    // typed vector of integers\n    if ( line->d.n_flt ) {\n        return bcf_enc_vint(str, line->d.n_flt, line->d.flt, -1);\n    } else {\n        return bcf_enc_vint(str, 0, 0, -1);\n    }\n}\n\nstatic inline int bcf1_sync_info(bcf1_t *line, kstring_t *str)\n{\n    // pairs of typed vectors\n    int i, irm = -1, e = 0;\n    for (i=0; i<line->n_info; i++)\n    {\n        bcf_info_t *info = &line->d.info[i];\n        if ( !info->vptr )\n        {\n            // marked for removal\n            if ( irm < 0 ) irm = i;\n            continue;\n        }\n        e |= kputsn_(info->vptr - info->vptr_off, info->vptr_len + info->vptr_off, str) < 0;\n        if ( irm >=0 )\n        {\n            bcf_info_t tmp = line->d.info[irm]; line->d.info[irm] = line->d.info[i]; line->d.info[i] = tmp;\n            while ( irm<=i && line->d.info[irm].vptr ) irm++;\n        }\n    }\n    if ( irm>=0 ) line->n_info = irm;\n    return e == 0 ? 0 : -1;\n}\n\nstatic int bcf1_sync(bcf1_t *line)\n{\n    char *shared_ori = line->shared.s;\n    size_t prev_len;\n\n    kstring_t tmp = {0,0,0};\n    if ( !line->shared.l )\n    {\n        // New line created via API, BCF data blocks do not exist. Get it ready for BCF output\n        tmp = line->shared;\n        bcf1_sync_id(line, &tmp);\n        line->unpack_size[0] = tmp.l; prev_len = tmp.l;\n\n        bcf1_sync_alleles(line, &tmp);\n        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;\n\n        bcf1_sync_filter(line, &tmp);\n        line->unpack_size[2] = tmp.l - prev_len;\n\n        bcf1_sync_info(line, &tmp);\n        line->shared = tmp;\n    }\n    else if ( line->d.shared_dirty )\n    {\n        // The line was edited, update the BCF data block.\n\n        if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line,BCF_UN_STR);\n\n        // ptr_ori points to the original unchanged BCF data.\n        uint8_t *ptr_ori = (uint8_t *) line->shared.s;\n\n        // ID: single typed string\n        if ( line->d.shared_dirty & BCF1_DIRTY_ID )\n            bcf1_sync_id(line, &tmp);\n        else\n            kputsn_(ptr_ori, line->unpack_size[0], &tmp);\n        ptr_ori += line->unpack_size[0];\n        line->unpack_size[0] = tmp.l; prev_len = tmp.l;\n\n        // REF+ALT: list of typed strings\n        if ( line->d.shared_dirty & BCF1_DIRTY_ALS )\n            bcf1_sync_alleles(line, &tmp);\n        else\n        {\n            kputsn_(ptr_ori, line->unpack_size[1], &tmp);\n            if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);\n        }\n        ptr_ori += line->unpack_size[1];\n        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;\n\n        if ( line->unpacked & BCF_UN_FLT )\n        {\n            // FILTER: typed vector of integers\n            if ( line->d.shared_dirty & BCF1_DIRTY_FLT )\n                bcf1_sync_filter(line, &tmp);\n            else if ( line->d.n_flt )\n                kputsn_(ptr_ori, line->unpack_size[2], &tmp);\n            else\n                bcf_enc_vint(&tmp, 0, 0, -1);\n            ptr_ori += line->unpack_size[2];\n            line->unpack_size[2] = tmp.l - prev_len;\n\n            if ( line->unpacked & BCF_UN_INFO )\n            {\n                // INFO: pairs of typed vectors\n                if ( line->d.shared_dirty & BCF1_DIRTY_INF )\n                {\n                    bcf1_sync_info(line, &tmp);\n                    ptr_ori = (uint8_t*)line->shared.s + line->shared.l;\n                }\n            }\n        }\n\n        int size = line->shared.l - (size_t)ptr_ori + (size_t)line->shared.s;\n        if ( size ) kputsn_(ptr_ori, size, &tmp);\n\n        free(line->shared.s);\n        line->shared = tmp;\n    }\n    if ( line->shared.s != shared_ori && line->unpacked & BCF_UN_INFO )\n    {\n        // Reallocated line->shared.s block invalidated line->d.info[].vptr pointers\n        size_t off_new = line->unpack_size[0] + line->unpack_size[1] + line->unpack_size[2];\n        int i;\n        for (i=0; i<line->n_info; i++)\n        {\n            uint8_t *vptr_free = line->d.info[i].vptr_free ? line->d.info[i].vptr - line->d.info[i].vptr_off : NULL;\n            line->d.info[i].vptr = (uint8_t*) line->shared.s + off_new + line->d.info[i].vptr_off;\n            off_new += line->d.info[i].vptr_len + line->d.info[i].vptr_off;\n            if ( vptr_free )\n            {\n                free(vptr_free);\n                line->d.info[i].vptr_free = 0;\n            }\n        }\n    }\n\n    if ( line->n_sample && line->n_fmt && (!line->indiv.l || line->d.indiv_dirty) )\n    {\n        // The genotype fields changed or are not present\n        tmp.l = tmp.m = 0; tmp.s = NULL;\n        int i, irm = -1;\n        for (i=0; i<line->n_fmt; i++)\n        {\n            bcf_fmt_t *fmt = &line->d.fmt[i];\n            if ( !fmt->p )\n            {\n                // marked for removal\n                if ( irm < 0 ) irm = i;\n                continue;\n            }\n            kputsn_(fmt->p - fmt->p_off, fmt->p_len + fmt->p_off, &tmp);\n            if ( irm >=0 )\n            {\n                bcf_fmt_t tfmt = line->d.fmt[irm]; line->d.fmt[irm] = line->d.fmt[i]; line->d.fmt[i] = tfmt;\n                while ( irm<=i && line->d.fmt[irm].p ) irm++;\n            }\n\n        }\n        if ( irm>=0 ) line->n_fmt = irm;\n        free(line->indiv.s);\n        line->indiv = tmp;\n\n        // Reallocated line->indiv.s block invalidated line->d.fmt[].p pointers\n        size_t off_new = 0;\n        for (i=0; i<line->n_fmt; i++)\n        {\n            uint8_t *p_free = line->d.fmt[i].p_free ? line->d.fmt[i].p - line->d.fmt[i].p_off : NULL;\n            line->d.fmt[i].p = (uint8_t*) line->indiv.s + off_new + line->d.fmt[i].p_off;\n            off_new += line->d.fmt[i].p_len + line->d.fmt[i].p_off;\n            if ( p_free )\n            {\n                free(p_free);\n                line->d.fmt[i].p_free = 0;\n            }\n        }\n    }\n    if ( !line->n_sample ) line->n_fmt = 0;\n    line->d.shared_dirty = line->d.indiv_dirty = 0;\n    return 0;\n}\n\nbcf1_t *bcf_copy(bcf1_t *dst, bcf1_t *src)\n{\n    bcf1_sync(src);\n\n    bcf_clear(dst);\n    dst->rid  = src->rid;\n    dst->pos  = src->pos;\n    dst->rlen = src->rlen;\n    dst->qual = src->qual;\n    dst->n_info = src->n_info; dst->n_allele = src->n_allele;\n    dst->n_fmt = src->n_fmt; dst->n_sample = src->n_sample;\n\n    if ( dst->shared.m < src->shared.l )\n    {\n        dst->shared.s = (char*) realloc(dst->shared.s, src->shared.l);\n        dst->shared.m = src->shared.l;\n    }\n    dst->shared.l = src->shared.l;\n    memcpy(dst->shared.s,src->shared.s,dst->shared.l);\n\n    if ( dst->indiv.m < src->indiv.l )\n    {\n        dst->indiv.s = (char*) realloc(dst->indiv.s, src->indiv.l);\n        dst->indiv.m = src->indiv.l;\n    }\n    dst->indiv.l = src->indiv.l;\n    memcpy(dst->indiv.s,src->indiv.s,dst->indiv.l);\n\n    return dst;\n}\nbcf1_t *bcf_dup(bcf1_t *src)\n{\n    bcf1_t *out = bcf_init1();\n    return bcf_copy(out, src);\n}\n\nint bcf_write(htsFile *hfp, bcf_hdr_t *h, bcf1_t *v)\n{\n    if ( h->dirty ) {\n        if (bcf_hdr_sync(h) < 0) return -1;\n    }\n    if ( bcf_hdr_nsamples(h)!=v->n_sample )\n    {\n        hts_log_error(\"Broken VCF record, the number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n        return -1;\n    }\n\n    if ( hfp->format.format == vcf || hfp->format.format == text_format )\n        return vcf_write(hfp,h,v);\n\n    if ( v->errcode )\n    {\n        // vcf_parse1() encountered a new contig or tag, undeclared in the\n        // header.  At this point, the header must have been printed,\n        // proceeding would lead to a broken BCF file. Errors must be checked\n        // and cleared by the caller before we can proceed.\n        hts_log_error(\"Unchecked error (%d) at %s:%\"PRIhts_pos, v->errcode, bcf_seqname_safe(h,v), v->pos+1);\n        return -1;\n    }\n    bcf1_sync(v);   // check if the BCF record was modified\n\n    if ( v->unpacked & BCF_IS_64BIT )\n    {\n        hts_log_error(\"Data at %s:%\"PRIhts_pos\" contains 64-bit values not representable in BCF. Please use VCF instead\", bcf_seqname_safe(h,v), v->pos+1);\n        return -1;\n    }\n\n    BGZF *fp = hfp->fp.bgzf;\n    uint8_t x[32];\n    u32_to_le(v->shared.l + 24, x); // to include six 32-bit integers\n    u32_to_le(v->indiv.l, x + 4);\n    i32_to_le(v->rid, x + 8);\n    u32_to_le(v->pos, x + 12);\n    u32_to_le(v->rlen, x + 16);\n    float_to_le(v->qual, x + 20);\n    u16_to_le(v->n_info, x + 24);\n    u16_to_le(v->n_allele, x + 26);\n    u32_to_le((uint32_t)v->n_fmt<<24 | (v->n_sample & 0xffffff), x + 28);\n    if ( bgzf_write(fp, x, 32) != 32 ) return -1;\n    if ( bgzf_write(fp, v->shared.s, v->shared.l) != v->shared.l ) return -1;\n    if ( bgzf_write(fp, v->indiv.s, v->indiv.l) != v->indiv.l ) return -1;\n\n    if (hfp->idx) {\n        if (hts_idx_push(hfp->idx, v->rid, v->pos, v->pos + v->rlen, bgzf_tell(fp), 1) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n/**********************\n *** VCF header I/O ***\n **********************/\n\nstatic int add_missing_contig_hrec(bcf_hdr_t *h, const char *name) {\n    bcf_hrec_t *hrec = calloc(1, sizeof(bcf_hrec_t));\n    int save_errno;\n    if (!hrec) goto fail;\n\n    hrec->key = strdup(\"contig\");\n    if (!hrec->key) goto fail;\n\n    if (bcf_hrec_add_key(hrec, \"ID\", strlen(\"ID\")) < 0) goto fail;\n    if (bcf_hrec_set_val(hrec, hrec->nkeys-1, name, strlen(name), 0) < 0)\n        goto fail;\n    if (bcf_hdr_add_hrec(h, hrec) < 0)\n        goto fail;\n    return 0;\n\n fail:\n    save_errno = errno;\n    hts_log_error(\"%s\", strerror(errno));\n    if (hrec) bcf_hrec_destroy(hrec);\n    errno = save_errno;\n    return -1;\n}\n\nbcf_hdr_t *vcf_hdr_read(htsFile *fp)\n{\n    kstring_t txt, *s = &fp->line;\n    int ret;\n    bcf_hdr_t *h;\n    tbx_t *idx = NULL;\n    const char **names = NULL;\n    h = bcf_hdr_init(\"r\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    txt.l = txt.m = 0; txt.s = 0;\n    while ((ret = hts_getline(fp, KS_SEP_LINE, s)) >= 0) {\n        int e = 0;\n        if (s->l == 0) continue;\n        if (s->s[0] != '#') {\n            hts_log_error(\"No sample line\");\n            goto error;\n        }\n        if (s->s[1] != '#' && fp->fn_aux) { // insert contigs here\n            kstring_t tmp = { 0, 0, NULL };\n            hFILE *f = hopen(fp->fn_aux, \"r\");\n            if (f == NULL) {\n                hts_log_error(\"Couldn't open \\\"%s\\\"\", fp->fn_aux);\n                goto error;\n            }\n            while (tmp.l = 0, kgetline(&tmp, (kgets_func *) hgets, f) >= 0) {\n                char *tab = strchr(tmp.s, '\\t');\n                if (tab == NULL) continue;\n                e |= (kputs(\"##contig=<ID=\", &txt) < 0);\n                e |= (kputsn(tmp.s, tab - tmp.s, &txt) < 0);\n                e |= (kputs(\",length=\", &txt) < 0);\n                e |= (kputl(atol(tab), &txt) < 0);\n                e |= (kputsn(\">\\n\", 2, &txt) < 0);\n            }\n            free(tmp.s);\n            if (hclose(f) != 0) {\n                hts_log_error(\"Error on closing %s\", fp->fn_aux);\n                goto error;\n            }\n            if (e) goto error;\n        }\n        if (kputsn(s->s, s->l, &txt) < 0) goto error;\n        if (kputc('\\n', &txt) < 0) goto error;\n        if (s->s[1] != '#') break;\n    }\n    if ( ret < -1 ) goto error;\n    if ( !txt.s )\n    {\n        hts_log_error(\"Could not read the header\");\n        goto error;\n    }\n    if ( bcf_hdr_parse(h, txt.s) < 0 ) goto error;\n\n    // check tabix index, are all contigs listed in the header? add the missing ones\n    idx = tbx_index_load3(fp->fn, NULL, HTS_IDX_SAVE_REMOTE|HTS_IDX_SILENT_FAIL);\n    if ( idx )\n    {\n        int i, n, need_sync = 0;\n        names = tbx_seqnames(idx, &n);\n        if (!names) goto error;\n        for (i=0; i<n; i++)\n        {\n            bcf_hrec_t *hrec = bcf_hdr_get_hrec(h, BCF_HL_CTG, \"ID\", (char*) names[i], NULL);\n            if ( hrec ) continue;\n            if (add_missing_contig_hrec(h, names[i]) < 0) goto error;\n            need_sync = 1;\n        }\n        if ( need_sync ) {\n            if (bcf_hdr_sync(h) < 0) goto error;\n        }\n        free(names);\n        tbx_destroy(idx);\n    }\n    free(txt.s);\n    return h;\n\n error:\n    if (idx) tbx_destroy(idx);\n    free(names);\n    free(txt.s);\n    if (h) bcf_hdr_destroy(h);\n    return NULL;\n}\n\nint bcf_hdr_set(bcf_hdr_t *hdr, const char *fname)\n{\n    int i = 0, n = 0, save_errno;\n    char **lines = hts_readlines(fname, &n);\n    if ( !lines ) return 1;\n    for (i=0; i<n-1; i++)\n    {\n        int k;\n        bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,lines[i],&k);\n        if (!hrec) goto fail;\n        if (bcf_hdr_add_hrec(hdr, hrec) < 0) {\n            bcf_hrec_destroy(hrec);\n            goto fail;\n        }\n        free(lines[i]);\n        lines[i] = NULL;\n    }\n    if (bcf_hdr_parse_sample_line(hdr, lines[n-1]) < 0) goto fail;\n    if (bcf_hdr_sync(hdr) < 0) goto fail;\n    free(lines[n-1]);\n    free(lines);\n    return 0;\n\n fail:\n    save_errno = errno;\n    for (; i < n; i++)\n        free(lines[i]);\n    free(lines);\n    errno = save_errno;\n    return 1;\n}\n\nstatic int _bcf_hrec_format(const bcf_hrec_t *hrec, int is_bcf, kstring_t *str)\n{\n    uint32_t e = 0;\n    if ( !hrec->value )\n    {\n        int j, nout = 0;\n        e |= ksprintf(str, \"##%s=<\", hrec->key) < 0;\n        for (j=0; j<hrec->nkeys; j++)\n        {\n            // do not output IDX if output is VCF\n            if ( !is_bcf && !strcmp(\"IDX\",hrec->keys[j]) ) continue;\n            if ( nout ) e |= kputc(',',str) < 0;\n            e |= ksprintf(str,\"%s=%s\", hrec->keys[j], hrec->vals[j]) < 0;\n            nout++;\n        }\n        e |= ksprintf(str,\">\\n\") < 0;\n    }\n    else\n        e |= ksprintf(str,\"##%s=%s\\n\", hrec->key,hrec->value) < 0;\n\n    return e == 0 ? 0 : -1;\n}\n\nint bcf_hrec_format(const bcf_hrec_t *hrec, kstring_t *str)\n{\n    return _bcf_hrec_format(hrec,0,str);\n}\n\nint bcf_hdr_format(const bcf_hdr_t *hdr, int is_bcf, kstring_t *str)\n{\n    int i;\n    for (i=0; i<hdr->nhrec; i++)\n        _bcf_hrec_format(hdr->hrec[i], is_bcf, str);\n\n    ksprintf(str, \"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\");\n    if ( bcf_hdr_nsamples(hdr) )\n    {\n        ksprintf(str, \"\\tFORMAT\");\n        for (i=0; i<bcf_hdr_nsamples(hdr); i++)\n            ksprintf(str, \"\\t%s\", hdr->samples[i]);\n    }\n    ksprintf(str, \"\\n\");\n\n    return 0;\n}\n\nchar *bcf_hdr_fmt_text(const bcf_hdr_t *hdr, int is_bcf, int *len)\n{\n    kstring_t txt = {0,0,0};\n    bcf_hdr_format(hdr, is_bcf, &txt);\n    if ( len ) *len = txt.l;\n    return txt.s;\n}\n\nconst char **bcf_hdr_seqnames(const bcf_hdr_t *h, int *n)\n{\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];\n    int tid, m = kh_size(d);\n    const char **names = (const char**) calloc(m,sizeof(const char*));\n    khint_t k;\n    for (k=kh_begin(d); k<kh_end(d); k++)\n    {\n        if ( !kh_exist(d,k) ) continue;\n        tid = kh_val(d,k).id;\n        assert( tid<m );\n        names[tid] = kh_key(d,k);\n    }\n    // sanity check: there should be no gaps\n    for (tid=0; tid<m; tid++)\n        assert(names[tid]);\n    *n = m;\n    return names;\n}\n\nint vcf_hdr_write(htsFile *fp, const bcf_hdr_t *h)\n{\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(h, 0, &htxt);\n    while (htxt.l && htxt.s[htxt.l-1] == '\\0') --htxt.l; // kill trailing zeros\n    int ret;\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, htxt.s, htxt.l);\n    else\n        ret = hwrite(fp->fp.hfile, htxt.s, htxt.l);\n    free(htxt.s);\n    return ret<0 ? -1 : 0;\n}\n\n/***********************\n *** Typed value I/O ***\n ***********************/\n\nint bcf_enc_vint(kstring_t *s, int n, int32_t *a, int wsize)\n{\n    int32_t max = INT32_MIN, min = INT32_MAX;\n    int i;\n    if (n <= 0) bcf_enc_size(s, 0, BCF_BT_NULL);\n    else if (n == 1) bcf_enc_int1(s, a[0]);\n    else {\n        if (wsize <= 0) wsize = n;\n        for (i = 0; i < n; ++i) {\n            if (a[i] == bcf_int32_missing || a[i] == bcf_int32_vector_end ) continue;\n            if (max < a[i]) max = a[i];\n            if (min > a[i]) min = a[i];\n        }\n        if (max <= BCF_MAX_BT_INT8 && min >= BCF_MIN_BT_INT8) {\n            bcf_enc_size(s, wsize, BCF_BT_INT8);\n            for (i = 0; i < n; ++i)\n                if ( a[i]==bcf_int32_vector_end ) kputc(bcf_int8_vector_end, s);\n                else if ( a[i]==bcf_int32_missing ) kputc(bcf_int8_missing, s);\n                else kputc(a[i], s);\n        } else if (max <= BCF_MAX_BT_INT16 && min >= BCF_MIN_BT_INT16) {\n            uint8_t *p;\n            bcf_enc_size(s, wsize, BCF_BT_INT16);\n            ks_resize(s, s->l + n * sizeof(int16_t));\n            p = (uint8_t *) s->s + s->l;\n            for (i = 0; i < n; ++i)\n            {\n                int16_t x;\n                if ( a[i]==bcf_int32_vector_end ) x = bcf_int16_vector_end;\n                else if ( a[i]==bcf_int32_missing ) x = bcf_int16_missing;\n                else x = a[i];\n                i16_to_le(x, p);\n                p += sizeof(int16_t);\n            }\n            s->l += n * sizeof(int16_t);\n        } else {\n            uint8_t *p;\n            bcf_enc_size(s, wsize, BCF_BT_INT32);\n            ks_resize(s, s->l + n * sizeof(int32_t));\n            p = (uint8_t *) s->s + s->l;\n            for (i = 0; i < n; ++i) {\n                i32_to_le(a[i], p);\n                p += sizeof(int32_t);\n            }\n            s->l += n * sizeof(int32_t);\n        }\n    }\n\n    return 0; // FIXME: check for errs in this function\n}\n\n#ifdef VCF_ALLOW_INT64\nstatic int bcf_enc_long1(kstring_t *s, int64_t x) {\n    uint32_t e = 0;\n    if (x <= BCF_MAX_BT_INT32 && x >= BCF_MIN_BT_INT32)\n        return bcf_enc_int1(s, x);\n    if (x == bcf_int64_vector_end) {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT8);\n        e |= kputc(bcf_int8_vector_end, s) < 0;\n    } else if (x == bcf_int64_missing) {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT8);\n        e |= kputc(bcf_int8_missing, s) < 0;\n    } else {\n        e |= bcf_enc_size(s, 1, BCF_BT_INT64);\n        e |= ks_expand(s, 8);\n        if (e == 0) { u64_to_le(x, (uint8_t *) s->s + s->l); s->l += 8; }\n    }\n    return e == 0 ? 0 : -1;\n}\n#endif\n\nstatic inline int serialize_float_array(kstring_t *s, size_t n, const float *a) {\n    uint8_t *p;\n    size_t i;\n    size_t bytes = n * sizeof(float);\n\n    if (bytes / sizeof(float) != n) return -1;\n    if (ks_resize(s, s->l + bytes) < 0) return -1;\n\n    p = (uint8_t *) s->s + s->l;\n    for (i = 0; i < n; i++) {\n        float_to_le(a[i], p);\n        p += sizeof(float);\n    }\n    s->l += bytes;\n\n    return 0;\n}\n\nint bcf_enc_vfloat(kstring_t *s, int n, float *a)\n{\n    assert(n >= 0);\n    bcf_enc_size(s, n, BCF_BT_FLOAT);\n    serialize_float_array(s, n, a);\n    return 0; // FIXME: check for errs in this function\n}\n\nint bcf_enc_vchar(kstring_t *s, int l, const char *a)\n{\n    bcf_enc_size(s, l, BCF_BT_CHAR);\n    kputsn(a, l, s);\n    return 0; // FIXME: check for errs in this function\n}\n\nint bcf_fmt_array(kstring_t *s, int n, int type, void *data)\n{\n    int j = 0;\n    uint32_t e = 0;\n    if (n == 0) {\n        return kputc('.', s) >= 0 ? 0 : -1;\n    }\n    if (type == BCF_BT_CHAR)\n    {\n        char *p = (char*)data;\n        for (j = 0; j < n && *p; ++j, ++p)\n        {\n            if ( *p==bcf_str_missing ) e |= kputc('.', s) < 0;\n            else e |= kputc(*p, s) < 0;\n        }\n    }\n    else\n    {\n        #define BRANCH(type_t, convert, is_missing, is_vector_end, kprint) { \\\n            uint8_t *p = (uint8_t *) data; \\\n            for (j=0; j<n; j++, p += sizeof(type_t))    \\\n            { \\\n                type_t v = convert(p); \\\n                if ( is_vector_end ) break; \\\n                if ( j ) kputc(',', s); \\\n                if ( is_missing ) kputc('.', s); \\\n                else e |= kprint < 0; \\\n            } \\\n        }\n        switch (type) {\n            case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, v==bcf_int8_missing,  v==bcf_int8_vector_end,  kputw(v, s)); break;\n            case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, v==bcf_int16_missing, v==bcf_int16_vector_end, kputw(v, s)); break;\n            case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, v==bcf_int32_missing, v==bcf_int32_vector_end, kputw(v, s)); break;\n            case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, v==bcf_float_missing, v==bcf_float_vector_end, kputd(le_to_float(p), s)); break;\n            default: hts_log_error(\"Unexpected type %d\", type); exit(1); break;\n        }\n        #undef BRANCH\n    }\n    return e == 0 ? 0 : -1;\n}\n\nuint8_t *bcf_fmt_sized_array(kstring_t *s, uint8_t *ptr)\n{\n    int x, type;\n    x = bcf_dec_size(ptr, &ptr, &type);\n    bcf_fmt_array(s, x, type, ptr);\n    return ptr + (x << bcf_type_shift[type]);\n}\n\n/********************\n *** VCF site I/O ***\n ********************/\n\ntypedef struct {\n    int key, max_m, size, offset;\n    uint32_t is_gt:1, max_g:31;\n    uint32_t max_l;\n    uint32_t y;\n    uint8_t *buf;\n} fmt_aux_t;\n\nstatic inline int align_mem(kstring_t *s)\n{\n    int e = 0;\n    if (s->l&7) {\n        uint64_t zero = 0;\n        e = kputsn((char*)&zero, 8 - (s->l&7), s) < 0;\n    }\n    return e == 0 ? 0 : -1;\n}\n\n// p,q is the start and the end of the FORMAT field\n#define MAX_N_FMT 255   /* Limited by size of bcf1_t n_fmt field */\nstatic int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)\n{\n    if ( !bcf_hdr_nsamples(h) ) return 0;\n\n    static int extreme_val_warned = 0;\n    char *r, *t;\n    int j, l, m, g, overflow = 0;\n    khint_t k;\n    ks_tokaux_t aux1;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    kstring_t *mem = (kstring_t*)&h->mem;\n    fmt_aux_t fmt[MAX_N_FMT];\n    mem->l = 0;\n\n    char *end = s->s + s->l;\n    if ( q>=end )\n    {\n        hts_log_error(\"FORMAT column with no sample columns starting at %s:%\"PRIhts_pos\"\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n\n    v->n_fmt = 0;\n    if ( p[0]=='.' && p[1]==0 ) // FORMAT field is empty \".\"\n    {\n        v->n_sample = bcf_hdr_nsamples(h);\n        return 0;\n    }\n\n    // get format information from the dictionary\n    for (j = 0, t = kstrtok(p, \":\", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {\n        if (j >= MAX_N_FMT) {\n            v->errcode |= BCF_ERR_LIMITS;\n            hts_log_error(\"FORMAT column at %s:%\"PRIhts_pos\" lists more identifiers than htslib can handle\",\n                bcf_seqname_safe(h,v), v->pos+1);\n            return -1;\n        }\n\n        *(char*)aux1.p = 0;\n        k = kh_get(vdict, d, t);\n        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {\n            if ( t[0]=='.' && t[1]==0 )\n            {\n                hts_log_error(\"Invalid FORMAT tag name '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n            hts_log_warning(\"FORMAT '%s' at %s:%\"PRIhts_pos\" is not defined in the header, assuming Type=String\", t, bcf_seqname_safe(h,v), v->pos+1);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", t);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n\n            k = kh_get(vdict, d, t);\n            v->errcode = BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for FORMAT '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n        }\n        fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;\n        fmt[j].key = kh_val(d, k).id;\n        fmt[j].is_gt = !strcmp(t, \"GT\");\n        fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT];\n        v->n_fmt++;\n    }\n    // compute max\n    int n_sample_ori = -1;\n    r = q + 1;  // r: position in the format string\n    l = 0, m = g = 1, v->n_sample = 0;  // m: max vector size, l: max field len, g: max number of alleles\n    while ( r<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *r!='\\t' && r<end ) r++;\n                if ( *r=='\\t' ) { *r = 0; r++; }\n                continue;\n            }\n        }\n\n        // collect fmt stats: max vector size, length, number of alleles\n        j = 0;  // j-th format field\n        fmt_aux_t *f = fmt;\n        for (;;) {\n            switch (*r) {\n            case ',':\n                m++;\n                break;\n\n            case '|':\n            case '/':\n                if (f->is_gt) g++;\n                break;\n\n            case '\\t':\n                *r = 0; // fall through\n\n            case '\\0':\n            case ':':\n                if (f->max_m < m) f->max_m = m;\n                if (f->max_l < l) f->max_l = l;\n                if (f->is_gt && f->max_g < g) f->max_g = g;\n                l = 0, m = g = 1;\n                if ( *r==':' ) {\n                    j++; f++;\n                    if ( j>=v->n_fmt ) {\n                        hts_log_error(\"Incorrect number of FORMAT fields at %s:%\"PRIhts_pos\"\",\n                                      h->id[BCF_DT_CTG][v->rid].key, v->pos+1);\n                        v->errcode |= BCF_ERR_NCOLS;\n                        return -1;\n                    }\n                } else goto end_for;\n                break;\n            }\n            if ( r>=end ) break;\n            r++; l++;\n        }\n    end_for:\n        v->n_sample++;\n        if ( v->n_sample == bcf_hdr_nsamples(h) ) break;\n        r++;\n    }\n\n    // allocate memory for arrays\n    for (j = 0; j < v->n_fmt; ++j) {\n        fmt_aux_t *f = &fmt[j];\n        if ( !f->max_m ) f->max_m = 1;  // omitted trailing format field\n        if ((f->y>>4&0xf) == BCF_HT_STR) {\n            f->size = f->is_gt? f->max_g << 2 : f->max_l;\n        } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {\n            f->size = f->max_m << 2;\n        } else\n        {\n            hts_log_error(\"The format type %d at %s:%\"PRIhts_pos\" is currently not supported\", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n        if (align_mem(mem) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n\n        // Limit the total memory to ~2Gb per VCF row.  This should mean\n        // malformed VCF data is less likely to take excessive memory and/or\n        // time.\n        if ((uint64_t) mem->l + v->n_sample * (uint64_t)f->size > INT_MAX) {\n            hts_log_error(\"Excessive memory required by FORMAT fields at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n\n        f->offset = mem->l;\n        if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {\n            hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        mem->l += v->n_sample * f->size;\n    }\n    for (j = 0; j < v->n_fmt; ++j)\n        fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset;\n    // fill the sample fields; at beginning of the loop, t points to the first char of a format\n    n_sample_ori = -1;\n    t = q + 1; m = 0;   // m: sample id\n    while ( t<end )\n    {\n        // can we skip some samples?\n        if ( h->keep_samples )\n        {\n            n_sample_ori++;\n            if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n            {\n                while ( *t && t<end ) t++;\n                t++;\n                continue;\n            }\n        }\n        if ( m == bcf_hdr_nsamples(h) ) break;\n\n        j = 0; // j-th format field, m-th sample\n        while ( t < end )\n        {\n            fmt_aux_t *z = &fmt[j++];\n            if (!z->buf) {\n                hts_log_error(\"Memory allocation failure for FORMAT field type %d at %s:%\"PRIhts_pos,\n                              z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_LIMITS;\n                return -1;\n            }\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) { // genotypes\n                    int32_t is_phased = 0;\n                    uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);\n                    uint32_t unreadable = 0;\n                    uint32_t max = 0;\n                    overflow = 0;\n                    for (l = 0;; ++t) {\n                        if (*t == '.') {\n                            ++t, x[l++] = is_phased;\n                        } else {\n                            char *tt = t;\n                            uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);\n                            unreadable |= tt == t;\n                            if (max < val) max = val;\n                            x[l++] = (val + 1) << 1 | is_phased;\n                        }\n                        is_phased = (*t == '|');\n                        if (*t != '|' && *t != '/') break;\n                    }\n                    // Possibly check max against v->n_allele instead?\n                    if (overflow || max > (INT32_MAX >> 1) - 1) {\n                        hts_log_error(\"Couldn't read GT data: value too large at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if (unreadable) {\n                        hts_log_error(\"Couldn't read GT data: value not a number or '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                        return -1;\n                    }\n                    if ( !l ) x[l++] = 0;   // An empty field, insert missing value\n                    for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;\n                    for (; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.') {\n                        x[l++] = bcf_int32_missing, ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                        if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                        {\n                            if ( !extreme_val_warned )\n                            {\n                                hts_log_warning(\"Extreme FORMAT/%s value encountered and set to missing at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1);\n                                extreme_val_warned = 1;\n                            }\n                            tmp_val = bcf_int32_missing;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) x[l++] = bcf_int32_missing;\n                for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                for (l = 0;; ++t) {\n                    if (*t == '.' && !isdigit_c(t[1])) {\n                        bcf_float_set_missing(x[l++]), ++t; // ++t to skip \".\"\n                    } else {\n                        overflow = 0;\n                        char *te;\n                        float tmp_val = hts_str2dbl(t, &te, &overflow);\n                        if ( (te==t || overflow) && !extreme_val_warned )\n                        {\n                            hts_log_warning(\"Extreme FORMAT/%s value encountered at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1);\n                            extreme_val_warned = 1;\n                        }\n                        x[l++] = tmp_val;\n                        t = te;\n                    }\n                    if (*t != ',') break;\n                }\n                if ( !l ) bcf_float_set_missing(x[l++]);    // An empty field, insert missing value\n                for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            } else {\n                hts_log_error(\"Unknown FORMAT field type %d at %s:%\"PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n\n            if (*t == '\\0') {\n                break;\n            }\n            else if (*t == ':') {\n                t++;\n            }\n            else {\n                char buffer[8];\n                hts_log_error(\"Invalid character %s in '%s' FORMAT field at %s:%\"PRIhts_pos\"\",\n                    hts_strprint(buffer, sizeof buffer, '\\'', t, 1),\n                    h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_CHAR;\n                return -1;\n            }\n        }\n\n        for (; j < v->n_fmt; ++j) { // fill end-of-vector values\n            fmt_aux_t *z = &fmt[j];\n            if ((z->y>>4&0xf) == BCF_HT_STR) {\n                if (z->is_gt) {\n                    int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                    if (z->size) x[0] = bcf_int32_missing;\n                    for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                } else {\n                    char *x = (char*)z->buf + z->size * (size_t)m;\n                    if ( z->size ) x[0] = '.';\n                    for (l = 1; l < z->size; ++l) x[l] = 0;\n                }\n            } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                x[0] = bcf_int32_missing;\n                for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                float *x = (float*)(z->buf + z->size * (size_t)m);\n                bcf_float_set_missing(x[0]);\n                for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n            }\n        }\n\n        m++; t++;\n    }\n\n    // write individual genotype information\n    kstring_t *str = &v->indiv;\n    int i;\n    if (v->n_sample > 0) {\n        for (i = 0; i < v->n_fmt; ++i) {\n            fmt_aux_t *z = &fmt[i];\n            bcf_enc_int1(str, z->key);\n            if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {\n                bcf_enc_size(str, z->size, BCF_BT_CHAR);\n                kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);\n            } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {\n                bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);\n            } else {\n                bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);\n                if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,\n                                          (float *) z->buf) != 0) {\n                    v->errcode |= BCF_ERR_LIMITS;\n                    hts_log_error(\"Out of memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                    return -1;\n                }\n            }\n        }\n    }\n\n    if ( v->n_sample!=bcf_hdr_nsamples(h) )\n    {\n        hts_log_error(\"Number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n        v->errcode |= BCF_ERR_NCOLS;\n        return -1;\n    }\n    if ( v->indiv.l > 0xffffffff )\n    {\n        hts_log_error(\"The FORMAT at %s:%\"PRIhts_pos\" is too long\", bcf_seqname_safe(h,v), v->pos+1);\n        v->errcode |= BCF_ERR_LIMITS;\n\n        // Error recovery: return -1 if this is a critical error or 0 if we want to ignore the FORMAT and proceed\n        v->n_fmt = 0;\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic khint_t fix_chromosome(const bcf_hdr_t *h, vdict_t *d, const char *p) {\n    // Simple error recovery for chromosomes not defined in the header. It will not help when VCF header has\n    // been already printed, but will enable tools like vcfcheck to proceed.\n\n    kstring_t tmp = {0,0,0};\n    khint_t k;\n    int l;\n    ksprintf(&tmp, \"##contig=<ID=%s>\", p);\n    bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n    free(tmp.s);\n    int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n    if (res < 0) bcf_hrec_destroy(hrec);\n    if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n    k = kh_get(vdict, d, p);\n\n    return k;\n}\n\nstatic int vcf_parse_filter(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {\n    int i, n_flt = 1, max_n_flt = 0;\n    char *r, *t;\n    int32_t *a_flt = NULL;\n    ks_tokaux_t aux1;\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    // count the number of filters\n    if (*(q-1) == ';') *(q-1) = 0;\n    for (r = p; *r; ++r)\n        if (*r == ';') ++n_flt;\n    if (n_flt > max_n_flt) {\n        a_flt = malloc(n_flt * sizeof(*a_flt));\n        if (!a_flt) {\n            hts_log_error(\"Could not allocate memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS; // No appropriate code?\n            return -1;\n        }\n        max_n_flt = n_flt;\n    }\n    // add filters\n    for (t = kstrtok(p, \";\", &aux1), i = 0; t; t = kstrtok(0, 0, &aux1)) {\n        *(char*)aux1.p = 0;\n        k = kh_get(vdict, d, t);\n        if (k == kh_end(d))\n        {\n            // Simple error recovery for FILTERs not defined in the header. It will not help when VCF header has\n            // been already printed, but will enable tools like vcfcheck to proceed.\n            hts_log_warning(\"FILTER '%s' is not defined in the header\", t);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##FILTER=<ID=%s,Description=\\\"Dummy\\\">\", t);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n            k = kh_get(vdict, d, t);\n            v->errcode |= BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for FILTER '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                free(a_flt);\n                return -1;\n            }\n        }\n        a_flt[i++] = kh_val(d, k).id;\n    }\n\n    bcf_enc_vint(str, n_flt, a_flt, -1);\n    free(a_flt);\n\n    return 0;\n}\n\nstatic int vcf_parse_info(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {\n    static int extreme_int_warned = 0, negative_rlen_warned = 0;\n    int max_n_val = 0, overflow = 0;\n    char *r, *key;\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n    int32_t *a_val = NULL;\n\n    v->n_info = 0;\n    if (*(q-1) == ';') *(q-1) = 0;\n    for (r = key = p;; ++r) {\n        int c;\n        char *val, *end;\n        if (*r != ';' && *r != '=' && *r != 0) continue;\n        if (v->n_info == UINT16_MAX) {\n            hts_log_error(\"Too many INFO entries at %s:%\"PRIhts_pos,\n                          bcf_seqname_safe(h,v), v->pos+1);\n            v->errcode |= BCF_ERR_LIMITS;\n            return -1;\n        }\n        val = end = 0;\n        c = *r; *r = 0;\n        if (c == '=') {\n            val = r + 1;\n            for (end = val; *end != ';' && *end != 0; ++end);\n            c = *end; *end = 0;\n        } else end = r;\n        if ( !*key ) { if (c==0) break; r = end; key = r + 1; continue; }  // faulty VCF, \";;\" in the INFO\n        k = kh_get(vdict, d, key);\n        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_INFO] == 15)\n        {\n            hts_log_warning(\"INFO '%s' is not defined in the header, assuming Type=String\", key);\n            kstring_t tmp = {0,0,0};\n            int l;\n            ksprintf(&tmp, \"##INFO=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", key);\n            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n            free(tmp.s);\n            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n            if (res < 0) bcf_hrec_destroy(hrec);\n            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n            k = kh_get(vdict, d, key);\n            v->errcode = BCF_ERR_TAG_UNDEF;\n            if (res || k == kh_end(d)) {\n                hts_log_error(\"Could not add dummy header for INFO '%s' at %s:%\"PRIhts_pos, key, bcf_seqname_safe(h,v), v->pos+1);\n                v->errcode |= BCF_ERR_TAG_INVALID;\n                return -1;\n            }\n        }\n        uint32_t y = kh_val(d, k).info[BCF_HL_INFO];\n        ++v->n_info;\n        bcf_enc_int1(str, kh_val(d, k).id);\n        if (val == 0) {\n            bcf_enc_size(str, 0, BCF_BT_NULL);\n        } else if ((y>>4&0xf) == BCF_HT_FLAG || (y>>4&0xf) == BCF_HT_STR) { // if Flag has a value, treat it as a string\n            bcf_enc_vchar(str, end - val, val);\n        } else { // int/float value/array\n            int i, n_val;\n            char *t, *te;\n            for (t = val, n_val = 1; *t; ++t) // count the number of values\n                if (*t == ',') ++n_val;\n            // Check both int and float size in one step for simplicity\n            if (n_val > max_n_val) {\n                int32_t *a_tmp = (int32_t *)realloc(a_val, n_val * sizeof(*a_val));\n                if (!a_tmp) {\n                    hts_log_error(\"Could not allocate memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                    v->errcode |= BCF_ERR_LIMITS; // No appropriate code?\n                    return -1;\n                }\n                a_val = a_tmp;\n                max_n_val = n_val;\n            }\n            if ((y>>4&0xf) == BCF_HT_INT) {\n                i = 0, t = val;\n                int64_t val1;\n                int is_int64 = 0;\n#ifdef VCF_ALLOW_INT64\n                if ( n_val==1 )\n                {\n                    overflow = 0;\n                    long long int tmp_val = hts_str2int(val, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                    if ( te==val ) tmp_val = bcf_int32_missing;\n                    else if ( overflow || tmp_val<BCF_MIN_BT_INT64 || tmp_val>BCF_MAX_BT_INT64 )\n                    {\n                        if ( !extreme_int_warned )\n                        {\n                            hts_log_warning(\"Extreme INFO/%s value encountered and set to missing at %s:%\"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);\n                            extreme_int_warned = 1;\n                        }\n                        tmp_val = bcf_int32_missing;\n                    }\n                    else\n                        is_int64 = 1;\n                    val1 = tmp_val;\n                    t = te;\n                    i = 1;  // this is just to avoid adding another nested block...\n                }\n#endif\n                for (; i < n_val; ++i, ++t)\n                {\n                    overflow = 0;\n                    long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                    if ( te==t ) tmp_val = bcf_int32_missing;\n                    else if ( overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                    {\n                        if ( !extreme_int_warned )\n                        {\n                            hts_log_warning(\"Extreme INFO/%s value encountered and set to missing at %s:%\"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);\n                            extreme_int_warned = 1;\n                        }\n                        tmp_val = bcf_int32_missing;\n                    }\n                    a_val[i] = tmp_val;\n                    for (t = te; *t && *t != ','; t++);\n                }\n                if (n_val == 1) {\n#ifdef VCF_ALLOW_INT64\n                    if ( is_int64 )\n                    {\n                        v->unpacked |= BCF_IS_64BIT;\n                        bcf_enc_long1(str, val1);\n                    }\n                    else\n                        bcf_enc_int1(str, (int32_t)val1);\n#else\n                    val1 = a_val[0];\n                    bcf_enc_int1(str, (int32_t)val1);\n#endif\n                } else {\n                    bcf_enc_vint(str, n_val, a_val, -1);\n                }\n                if (n_val==1 && (val1!=bcf_int32_missing || is_int64) && strcmp(key, \"END\") == 0)\n                {\n                    if ( val1 <= v->pos )\n                    {\n                        if ( !negative_rlen_warned )\n                        {\n                            hts_log_warning(\"INFO/END=%\"PRIhts_pos\" is smaller than POS at %s:%\"PRIhts_pos,val1,bcf_seqname_safe(h,v),v->pos+1);\n                            negative_rlen_warned = 1;\n                        }\n                    }\n                    else\n                        v->rlen = val1 - v->pos;\n                }\n            } else if ((y>>4&0xf) == BCF_HT_REAL) {\n                float *val_f = (float *)a_val;\n                for (i = 0, t = val; i < n_val; ++i, ++t)\n                {\n                    overflow = 0;\n                    val_f[i] = hts_str2dbl(t, &te, &overflow);\n                    if ( te==t || overflow ) // conversion failed\n                        bcf_float_set_missing(val_f[i]);\n                    for (t = te; *t && *t != ','; t++);\n                }\n                bcf_enc_vfloat(str, n_val, val_f);\n            }\n        }\n        if (c == 0) break;\n        r = end;\n        key = r + 1;\n    }\n\n    free(a_val);\n    return 0;\n}\n\nint vcf_parse(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int i = 0, ret = -2, overflow = 0;\n    char *p, *q, *r, *t;\n    kstring_t *str;\n    khint_t k;\n    ks_tokaux_t aux;\n\n    if (!s || !h || !v || !(s->s))\n        return ret;\n\n    // Assumed in lots of places, but we may as well spot this early\n    assert(sizeof(float) == sizeof(int32_t));\n\n    bcf_clear1(v);\n    str = &v->shared;\n    memset(&aux, 0, sizeof(ks_tokaux_t));\n    for (p = kstrtok(s->s, \"\\t\", &aux), i = 0; p; p = kstrtok(0, 0, &aux), ++i) {\n        q = (char*)aux.p;\n        *q = 0;\n        if (i == 0) { // CHROM\n            vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];\n            k = kh_get(vdict, d, p);\n            if (k == kh_end(d))\n            {\n                hts_log_warning(\"Contig '%s' is not defined in the header. (Quick workaround: index the file with tabix.)\", p);\n                v->errcode = BCF_ERR_CTG_UNDEF;\n                if ((k = fix_chromosome(h, d, p)) == kh_end(d)) {\n                    hts_log_error(\"Could not add dummy header for contig '%s'\", p);\n                    v->errcode |= BCF_ERR_CTG_INVALID;\n                    goto err;\n                }\n            }\n            v->rid = kh_val(d, k).id;\n        } else if (i == 1) { // POS\n            overflow = 0;\n            v->pos = hts_str2uint(p, &p, 63, &overflow);\n            if (overflow) {\n                hts_log_error(\"Position value '%s' is too large\", p);\n                goto err;\n            } else {\n                v->pos -= 1;\n            }\n            if (v->pos >= INT32_MAX)\n                v->unpacked |= BCF_IS_64BIT;\n        } else if (i == 2) { // ID\n            if (strcmp(p, \".\")) bcf_enc_vchar(str, q - p, p);\n            else bcf_enc_size(str, 0, BCF_BT_CHAR);\n        } else if (i == 3) { // REF\n            bcf_enc_vchar(str, q - p, p);\n            v->n_allele = 1, v->rlen = q - p;\n        } else if (i == 4) { // ALT\n            if (strcmp(p, \".\")) {\n                for (r = t = p;; ++r) {\n                    if (*r == ',' || *r == 0) {\n                        if (v->n_allele == UINT16_MAX) {\n                            hts_log_error(\"Too many ALT alleles at %s:%\"PRIhts_pos,\n                                          bcf_seqname_safe(h,v), v->pos+1);\n                            v->errcode |= BCF_ERR_LIMITS;\n                            goto err;\n                        }\n                        bcf_enc_vchar(str, r - t, t);\n                        t = r + 1;\n                        ++v->n_allele;\n                    }\n                    if (r == q) break;\n                }\n            }\n        } else if (i == 5) { // QUAL\n            if (strcmp(p, \".\")) v->qual = atof(p);\n            else bcf_float_set_missing(v->qual);\n            if ( v->max_unpack && !(v->max_unpack>>1) ) goto end; // BCF_UN_STR\n        } else if (i == 6) { // FILTER\n            if (strcmp(p, \".\")) {\n                if (vcf_parse_filter(str, h, v, p, q)) goto err;\n            } else bcf_enc_vint(str, 0, 0, -1);\n            if ( v->max_unpack && !(v->max_unpack>>2) ) goto end; // BCF_UN_FLT\n        } else if (i == 7) { // INFO\n            if (strcmp(p, \".\")) {\n                if (vcf_parse_info(str, h, v, p, q)) goto err;\n            }\n            if ( v->max_unpack && !(v->max_unpack>>3) ) goto end;\n        } else if (i == 8) {// FORMAT\n            return vcf_parse_format(s, h, v, p, q) == 0 ? 0 : -2;\n        }\n    }\n\n end:\n    ret = 0;\n\n err:\n    return ret;\n}\n\nint vcf_open_mode(char *mode, const char *fn, const char *format)\n{\n    if (format == NULL) {\n        // Try to pick a format based on the filename extension\n        char extension[HTS_MAX_EXT_LEN];\n        if (find_file_extension(fn, extension) < 0) return -1;\n        return vcf_open_mode(mode, fn, extension);\n    }\n    else if (strcasecmp(format, \"bcf\") == 0) strcpy(mode, \"b\");\n    else if (strcasecmp(format, \"vcf\") == 0) strcpy(mode, \"\");\n    else if (strcasecmp(format, \"vcf.gz\") == 0 || strcasecmp(format, \"vcf.bgz\") == 0) strcpy(mode, \"z\");\n    else return -1;\n\n    return 0;\n}\n\nint vcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int ret;\n    ret = hts_getline(fp, KS_SEP_LINE, &fp->line);\n    if (ret < 0) return ret;\n    return vcf_parse1(&fp->line, h, v);\n}\n\nstatic inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt)\n{\n    uint8_t *ptr_start = ptr;\n    fmt->id = bcf_dec_typed_int1(ptr, &ptr);\n    fmt->n = bcf_dec_size(ptr, &ptr, &fmt->type);\n    fmt->size = fmt->n << bcf_type_shift[fmt->type];\n    fmt->p = ptr;\n    fmt->p_off  = ptr - ptr_start;\n    fmt->p_free = 0;\n    ptr += n_sample * fmt->size;\n    fmt->p_len = ptr - fmt->p;\n    return ptr;\n}\n\nstatic inline uint8_t *bcf_unpack_info_core1(uint8_t *ptr, bcf_info_t *info)\n{\n    uint8_t *ptr_start = ptr;\n    info->key = bcf_dec_typed_int1(ptr, &ptr);\n    info->len = bcf_dec_size(ptr, &ptr, &info->type);\n    info->vptr = ptr;\n    info->vptr_off  = ptr - ptr_start;\n    info->vptr_free = 0;\n    info->v1.i = 0;\n    if (info->len == 1) {\n        if (info->type == BCF_BT_INT8 || info->type == BCF_BT_CHAR) info->v1.i = *(int8_t*)ptr;\n        else if (info->type == BCF_BT_INT32) info->v1.i = le_to_i32(ptr);\n        else if (info->type == BCF_BT_FLOAT) info->v1.f = le_to_float(ptr);\n        else if (info->type == BCF_BT_INT16) info->v1.i = le_to_i16(ptr);\n        else if (info->type == BCF_BT_INT64) info->v1.i = le_to_i64(ptr);\n    }\n    ptr += info->len << bcf_type_shift[info->type];\n    info->vptr_len = ptr - info->vptr;\n    return ptr;\n}\n\nint bcf_unpack(bcf1_t *b, int which)\n{\n    if ( !b->shared.l ) return 0; // Building a new BCF record from scratch\n    uint8_t *ptr = (uint8_t*)b->shared.s, *ptr_ori;\n    int i;\n    bcf_dec_t *d = &b->d;\n    if (which & BCF_UN_FLT) which |= BCF_UN_STR;\n    if (which & BCF_UN_INFO) which |= BCF_UN_SHR;\n    if ((which&BCF_UN_STR) && !(b->unpacked&BCF_UN_STR))\n    {\n        kstring_t tmp;\n\n        // ID\n        tmp.l = 0; tmp.s = d->id; tmp.m = d->m_id;\n        ptr_ori = ptr;\n        ptr = bcf_fmt_sized_array(&tmp, ptr);\n        b->unpack_size[0] = ptr - ptr_ori;\n        kputc('\\0', &tmp);\n        d->id = tmp.s; d->m_id = tmp.m;\n\n        // REF and ALT are in a single block (d->als) and d->alleles are pointers into this block\n        hts_expand(char*, b->n_allele, d->m_allele, d->allele); // NM: hts_expand() is a macro\n        tmp.l = 0; tmp.s = d->als; tmp.m = d->m_als;\n        ptr_ori = ptr;\n        char *o = \"\";\n        for (i = 0; i < b->n_allele; ++i) {\n            d->allele[i] = o + tmp.l;\n            ptr = bcf_fmt_sized_array(&tmp, ptr);\n            kputc('\\0', &tmp);\n        }\n        b->unpack_size[1] = ptr - ptr_ori;\n        d->als = tmp.s; d->m_als = tmp.m;\n\n        for (i = 0; i < b->n_allele; ++i)\n            d->allele[i] = d->als + (d->allele[i]-o);\n        b->unpacked |= BCF_UN_STR;\n    }\n    if ((which&BCF_UN_FLT) && !(b->unpacked&BCF_UN_FLT)) { // FILTER\n        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1];\n        ptr_ori = ptr;\n        if (*ptr>>4) {\n            int type;\n            d->n_flt = bcf_dec_size(ptr, &ptr, &type);\n            hts_expand(int, d->n_flt, d->m_flt, d->flt);\n            for (i = 0; i < d->n_flt; ++i)\n                d->flt[i] = bcf_dec_int1(ptr, type, &ptr);\n        } else ++ptr, d->n_flt = 0;\n        b->unpack_size[2] = ptr - ptr_ori;\n        b->unpacked |= BCF_UN_FLT;\n    }\n    if ((which&BCF_UN_INFO) && !(b->unpacked&BCF_UN_INFO)) { // INFO\n        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1] + b->unpack_size[2];\n        hts_expand(bcf_info_t, b->n_info, d->m_info, d->info);\n        for (i = 0; i < d->m_info; ++i) d->info[i].vptr_free = 0;\n        for (i = 0; i < b->n_info; ++i)\n            ptr = bcf_unpack_info_core1(ptr, &d->info[i]);\n        b->unpacked |= BCF_UN_INFO;\n    }\n    if ((which&BCF_UN_FMT) && b->n_sample && !(b->unpacked&BCF_UN_FMT)) { // FORMAT\n        ptr = (uint8_t*)b->indiv.s;\n        hts_expand(bcf_fmt_t, b->n_fmt, d->m_fmt, d->fmt);\n        for (i = 0; i < d->m_fmt; ++i) d->fmt[i].p_free = 0;\n        for (i = 0; i < b->n_fmt; ++i)\n            ptr = bcf_unpack_fmt_core1(ptr, b->n_sample, &d->fmt[i]);\n        b->unpacked |= BCF_UN_FMT;\n    }\n    return 0;\n}\n\nint vcf_format(const bcf_hdr_t *h, const bcf1_t *v, kstring_t *s)\n{\n    int i;\n    int32_t max_dt_id = h->n[BCF_DT_ID];\n    const char *chrom = bcf_seqname(h, v);\n    if (!chrom) {\n        hts_log_error(\"Invalid BCF, CONTIG id=%d not present in the header\",\n                      v->rid);\n        errno = EINVAL;\n        return -1;\n    }\n    bcf_unpack((bcf1_t*)v, BCF_UN_ALL);\n    kputs(chrom, s); // CHROM\n    kputc('\\t', s); kputll(v->pos + 1, s); // POS\n    kputc('\\t', s); kputs(v->d.id ? v->d.id : \".\", s); // ID\n    kputc('\\t', s); // REF\n    if (v->n_allele > 0) kputs(v->d.allele[0], s);\n    else kputc('.', s);\n    kputc('\\t', s); // ALT\n    if (v->n_allele > 1) {\n        for (i = 1; i < v->n_allele; ++i) {\n            if (i > 1) kputc(',', s);\n            kputs(v->d.allele[i], s);\n        }\n    } else kputc('.', s);\n    kputc('\\t', s); // QUAL\n    if ( bcf_float_is_missing(v->qual) ) kputc('.', s); // QUAL\n    else kputd(v->qual, s);\n    kputc('\\t', s); // FILTER\n    if (v->d.n_flt) {\n        for (i = 0; i < v->d.n_flt; ++i) {\n            int32_t idx = v->d.flt[i];\n            if (idx < 0 || idx >= max_dt_id\n                || h->id[BCF_DT_ID][idx].key == NULL) {\n                hts_log_error(\"Invalid BCF, the FILTER tag id=%d at %s:%\"PRIhts_pos\" not present in the header\",\n                              idx, bcf_seqname_safe(h, v), v->pos + 1);\n                errno = EINVAL;\n                return -1;\n            }\n            if (i) kputc(';', s);\n            kputs(h->id[BCF_DT_ID][idx].key, s);\n        }\n    } else kputc('.', s);\n    kputc('\\t', s); // INFO\n    if (v->n_info) {\n        int first = 1;\n        for (i = 0; i < v->n_info; ++i) {\n            bcf_info_t *z = &v->d.info[i];\n            if ( !z->vptr ) continue;\n            if ( !first ) kputc(';', s);\n            first = 0;\n            if (z->key < 0 || z->key >= max_dt_id\n                || h->id[BCF_DT_ID][z->key].key == NULL) {\n                hts_log_error(\"Invalid BCF, the INFO tag id=%d is %s at %s:%\"PRIhts_pos,\n                              z->key,\n                              z->key < 0 ? \"negative\"\n                              : (z->key >= max_dt_id ? \"too large\" : \"not present in the header\"),\n                              bcf_seqname_safe(h, v), v->pos+1);\n                errno = EINVAL;\n                return -1;\n            }\n            kputs(h->id[BCF_DT_ID][z->key].key, s);\n            if (z->len <= 0) continue;\n            kputc('=', s);\n            if (z->len == 1)\n            {\n                switch (z->type)\n                {\n                    case BCF_BT_INT8:  if ( z->v1.i==bcf_int8_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT16: if ( z->v1.i==bcf_int16_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT32: if ( z->v1.i==bcf_int32_missing ) kputc('.', s); else kputw(z->v1.i, s); break;\n                    case BCF_BT_INT64: if ( z->v1.i==bcf_int64_missing ) kputc('.', s); else kputll(z->v1.i, s); break;\n                    case BCF_BT_FLOAT: if ( bcf_float_is_missing(z->v1.f) ) kputc('.', s); else kputd(z->v1.f, s); break;\n                    case BCF_BT_CHAR:  kputc(z->v1.i, s); break;\n                    default:\n                        hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, z->type, bcf_seqname_safe(h, v), v->pos+1);\n                        errno = EINVAL;\n                        return -1;\n                }\n            }\n            else bcf_fmt_array(s, z->len, z->type, z->vptr);\n        }\n        if ( first ) kputc('.', s);\n    } else kputc('.', s);\n    // FORMAT and individual information\n    if (v->n_sample)\n    {\n        int i,j;\n        if ( v->n_fmt)\n        {\n            int gt_i = -1;\n            bcf_fmt_t *fmt = v->d.fmt;\n            int first = 1;\n            for (i = 0; i < (int)v->n_fmt; ++i) {\n                if ( !fmt[i].p ) continue;\n                kputc(!first ? ':' : '\\t', s); first = 0;\n                if (fmt[i].id < 0 || fmt[i].id >= max_dt_id\n                    || h->id[BCF_DT_ID][fmt[i].id].key == NULL) //!bcf_hdr_idinfo_exists(h,BCF_HL_FMT,fmt[i].id) )\n                {\n                    hts_log_error(\"Invalid BCF, the FORMAT tag id=%d at %s:%\"PRIhts_pos\" not present in the header\", fmt[i].id, bcf_seqname_safe(h, v), v->pos+1);\n                    errno = EINVAL;\n                    return -1;\n                }\n                kputs(h->id[BCF_DT_ID][fmt[i].id].key, s);\n                if (strcmp(h->id[BCF_DT_ID][fmt[i].id].key, \"GT\") == 0) gt_i = i;\n            }\n            if ( first ) kputs(\"\\t.\", s);\n            for (j = 0; j < v->n_sample; ++j) {\n                kputc('\\t', s);\n                first = 1;\n                for (i = 0; i < (int)v->n_fmt; ++i) {\n                    bcf_fmt_t *f = &fmt[i];\n                    if ( !f->p ) continue;\n                    if (!first) kputc(':', s);\n                    first = 0;\n                    if (gt_i == i)\n                        bcf_format_gt(f,j,s);\n                    else\n                        bcf_fmt_array(s, f->n, f->type, f->p + j * (size_t)f->size);\n                }\n                if ( first ) kputc('.', s);\n            }\n        }\n        else\n            for (j=0; j<=v->n_sample; j++)\n                kputs(\"\\t.\", s);\n    }\n    kputc('\\n', s);\n    return 0;\n}\n\nint vcf_write_line(htsFile *fp, kstring_t *line)\n{\n    int ret;\n    if ( line->s[line->l-1]!='\\n' ) kputc('\\n',line);\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, line->s, line->l);\n    else\n        ret = hwrite(fp->fp.hfile, line->s, line->l);\n    return ret==line->l ? 0 : -1;\n}\n\nint vcf_write(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)\n{\n    int ret;\n    fp->line.l = 0;\n    if (vcf_format1(h, v, &fp->line) != 0)\n        return -1;\n    if ( fp->format.compression!=no_compression )\n        ret = bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l);\n    else\n        ret = hwrite(fp->fp.hfile, fp->line.s, fp->line.l);\n\n    if (fp->idx) {\n        int tid;\n        if ((tid = hts_idx_tbi_name(fp->idx, v->rid, bcf_seqname_safe(h, v))) < 0)\n            return -1;\n\n        if (hts_idx_push(fp->idx, tid, v->pos, v->pos + v->rlen, bgzf_tell(fp->fp.bgzf), 1) < 0)\n            return -1;\n    }\n\n    return ret==fp->line.l ? 0 : -1;\n}\n\n/************************\n * Data access routines *\n ************************/\n\nint bcf_hdr_id2int(const bcf_hdr_t *h, int which, const char *id)\n{\n    khint_t k;\n    vdict_t *d = (vdict_t*)h->dict[which];\n    k = kh_get(vdict, d, id);\n    return k == kh_end(d)? -1 : kh_val(d, k).id;\n}\n\n\n/********************\n *** BCF indexing ***\n ********************/\n\n// Calculate number of index levels given min_shift and the header contig\n// list.  Also returns number of contigs in *nids_out.\nstatic int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,\n                               int starting_n_lvls, int *nids_out)\n{\n    int n_lvls, i, nids = 0;\n    int64_t max_len = 0, s;\n\n    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)\n    {\n        if ( !h->id[BCF_DT_CTG][i].val ) continue;\n        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )\n            max_len = h->id[BCF_DT_CTG][i].val->info[0];\n        nids++;\n    }\n    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.\n    max_len += 256;\n    s = 1LL << (min_shift + starting_n_lvls * 3);\n    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);\n\n    if (nids_out) *nids_out = nids;\n    return n_lvls;\n}\n\nhts_idx_t *bcf_index(htsFile *fp, int min_shift)\n{\n    int n_lvls;\n    bcf1_t *b = NULL;\n    hts_idx_t *idx = NULL;\n    bcf_hdr_t *h;\n    int r;\n    h = bcf_hdr_read(fp);\n    if ( !h ) return NULL;\n    int nids = 0;\n    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);\n    idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!idx) goto fail;\n    b = bcf_init1();\n    if (!b) goto fail;\n    while ((r = bcf_read1(fp,h, b)) >= 0) {\n        int ret;\n        ret = hts_idx_push(idx, b->rid, b->pos, b->pos + b->rlen, bgzf_tell(fp->fp.bgzf), 1);\n        if (ret < 0) goto fail;\n    }\n    if (r < -1) goto fail;\n    hts_idx_finish(idx, bgzf_tell(fp->fp.bgzf));\n    bcf_destroy1(b);\n    bcf_hdr_destroy(h);\n    return idx;\n\n fail:\n    hts_idx_destroy(idx);\n    bcf_destroy1(b);\n    bcf_hdr_destroy(h);\n    return NULL;\n}\n\nhts_idx_t *bcf_index_load2(const char *fn, const char *fnidx)\n{\n    return fnidx? hts_idx_load2(fn, fnidx) : bcf_index_load(fn);\n}\n\nhts_idx_t *bcf_index_load3(const char *fn, const char *fnidx, int flags)\n{\n    return hts_idx_load3(fn, fnidx, HTS_FMT_CSI, flags);\n}\n\nint bcf_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads)\n{\n    htsFile *fp;\n    hts_idx_t *idx;\n    tbx_t *tbx;\n    int ret;\n    if ((fp = hts_open(fn, \"rb\")) == 0) return -2;\n    if (n_threads)\n        hts_set_threads(fp, n_threads);\n    if ( fp->format.compression!=bgzf ) { hts_close(fp); return -3; }\n    switch (fp->format.format) {\n        case bcf:\n            if (!min_shift) {\n                hts_log_error(\"TBI indices for BCF files are not supported\");\n                ret = -1;\n            } else {\n                idx = bcf_index(fp, min_shift);\n                if (idx) {\n                    ret = hts_idx_save_as(idx, fn, fnidx, HTS_FMT_CSI);\n                    if (ret < 0) ret = -4;\n                    hts_idx_destroy(idx);\n                }\n                else ret = -1;\n            }\n            break;\n\n        case vcf:\n            tbx = tbx_index(hts_get_bgzfp(fp), min_shift, &tbx_conf_vcf);\n            if (tbx) {\n                ret = hts_idx_save_as(tbx->idx, fn, fnidx, min_shift > 0 ? HTS_FMT_CSI : HTS_FMT_TBI);\n                if (ret < 0) ret = -4;\n                tbx_destroy(tbx);\n            }\n            else ret = -1;\n            break;\n\n        default:\n            ret = -3;\n            break;\n    }\n    hts_close(fp);\n    return ret;\n}\n\nint bcf_index_build2(const char *fn, const char *fnidx, int min_shift)\n{\n    return bcf_index_build3(fn, fnidx, min_shift, 0);\n}\n\nint bcf_index_build(const char *fn, int min_shift)\n{\n    return bcf_index_build3(fn, NULL, min_shift, 0);\n}\n\n// Initialise fp->idx for the current format type.\n// This must be called after the header has been written but no other data.\nstatic int vcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {\n    int n_lvls, fmt;\n\n    if (min_shift == 0) {\n        min_shift = 14;\n        n_lvls = 5;\n        fmt = HTS_FMT_TBI;\n    } else {\n        // Set initial n_lvls to match tbx_index()\n        int starting_n_lvls = (TBX_MAX_SHIFT - min_shift + 2) / 3;\n        // Increase if necessary\n        n_lvls = idx_calc_n_lvls_ids(h, min_shift, starting_n_lvls, NULL);\n        fmt = HTS_FMT_CSI;\n    }\n\n    fp->idx = hts_idx_init(0, fmt, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!fp->idx) return -1;\n\n    // Tabix meta data, added even in CSI for VCF\n    uint8_t conf[4*7];\n    u32_to_le(TBX_VCF, conf+0);  // fmt\n    u32_to_le(1,       conf+4);  // name col\n    u32_to_le(2,       conf+8);  // beg col\n    u32_to_le(0,       conf+12); // end col\n    u32_to_le('#',     conf+16); // comment\n    u32_to_le(0,       conf+20); // n.skip\n    u32_to_le(0,       conf+24); // ref name len\n    if (hts_idx_set_meta(fp->idx, sizeof(conf)*sizeof(*conf), (uint8_t *)conf, 1) < 0) {\n        hts_idx_destroy(fp->idx);\n        fp->idx = NULL;\n        return -1;\n    }\n    fp->fnidx = fnidx;\n\n    return 0;\n}\n\n// Initialise fp->idx for the current format type.\n// This must be called after the header has been written but no other data.\nint bcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {\n    int n_lvls, nids = 0;\n\n    if (fp->format.format == vcf)\n        return vcf_idx_init(fp, h, min_shift, fnidx);\n\n    if (!min_shift)\n        min_shift = 14;\n\n    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);\n\n    fp->idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);\n    if (!fp->idx) return -1;\n    fp->fnidx = fnidx;\n\n    return 0;\n}\n\n// Finishes an index. Call afer the last record has been written.\n// Returns 0 on success, <0 on failure.\n//\n// NB: same format as SAM/BAM as it uses bgzf.\nint bcf_idx_save(htsFile *fp) {\n    return sam_idx_save(fp);\n}\n\n/*****************\n *** Utilities ***\n *****************/\n\nint bcf_hdr_combine(bcf_hdr_t *dst, const bcf_hdr_t *src)\n{\n    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;\n    for (i=0; i<src->nhrec; i++)\n    {\n        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )\n        {\n            int j;\n            for (j=0; j<ndst_ori; j++)\n            {\n                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;\n\n                // Checking only the key part of generic lines, otherwise\n                // the VCFs are too verbose. Should we perhaps add a flag\n                // to bcf_hdr_combine() and make this optional?\n                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;\n            }\n            if ( j>=ndst_ori ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return -1;\n                need_sync += res;\n            }\n        }\n        else if ( src->hrec[i]->type==BCF_HL_STR )\n        {\n            // NB: we are ignoring fields without ID\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            if ( j>=0 )\n            {\n                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], src->hrec[i]->key);\n                if ( !rec ) {\n                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                    if (res < 0) return -1;\n                    need_sync += res;\n                }\n            }\n        }\n        else\n        {\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            assert( j>=0 ); // this should always be true for valid VCFs\n\n            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], NULL);\n            if ( !rec ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return -1;\n                need_sync += res;\n            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )\n            {\n                // Check that both records are of the same type. The bcf_hdr_id2length\n                // macro cannot be used here because dst header is not synced yet.\n                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];\n                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];\n                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);\n                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);\n                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different lengths\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different types\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n            }\n        }\n    }\n    if ( need_sync ) {\n        if (bcf_hdr_sync(dst) < 0) return -1;\n    }\n    return ret;\n}\n\nbcf_hdr_t *bcf_hdr_merge(bcf_hdr_t *dst, const bcf_hdr_t *src)\n{\n    if ( !dst )\n    {\n        // this will effectively strip existing IDX attributes from src to become dst\n        dst = bcf_hdr_init(\"r\");\n        kstring_t htxt = {0,0,0};\n        bcf_hdr_format(src, 0, &htxt);\n        if ( bcf_hdr_parse(dst, htxt.s) < 0 ) {\n            bcf_hdr_destroy(dst);\n            dst = NULL;\n        }\n        free(htxt.s);\n        return dst;\n    }\n\n    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;\n    for (i=0; i<src->nhrec; i++)\n    {\n        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )\n        {\n            int j;\n            for (j=0; j<ndst_ori; j++)\n            {\n                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;\n\n                // Checking only the key part of generic lines, otherwise\n                // the VCFs are too verbose. Should we perhaps add a flag\n                // to bcf_hdr_combine() and make this optional?\n                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;\n            }\n            if ( j>=ndst_ori ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return NULL;\n                need_sync += res;\n            }\n        }\n        else if ( src->hrec[i]->type==BCF_HL_STR )\n        {\n            // NB: we are ignoring fields without ID\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            if ( j>=0 )\n            {\n                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], src->hrec[i]->key);\n                if ( !rec ) {\n                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                    if (res < 0) return NULL;\n                    need_sync += res;\n                }\n            }\n        }\n        else\n        {\n            int j = bcf_hrec_find_key(src->hrec[i],\"ID\");\n            assert( j>=0 ); // this should always be true for valid VCFs\n\n            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, \"ID\", src->hrec[i]->vals[j], NULL);\n            if ( !rec ) {\n                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));\n                if (res < 0) return NULL;\n                need_sync += res;\n            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )\n            {\n                // Check that both records are of the same type. The bcf_hdr_id2length\n                // macro cannot be used here because dst header is not synced yet.\n                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];\n                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];\n                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);\n                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);\n                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different lengths\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )\n                {\n                    hts_log_warning(\"Trying to combine \\\"%s\\\" tag definitions of different types\",\n                        src->hrec[i]->vals[0]);\n                    ret |= 1;\n                }\n            }\n        }\n    }\n    if ( need_sync ) {\n        if (bcf_hdr_sync(dst) < 0) return NULL;\n    }\n    return dst;\n}\n\nint bcf_translate(const bcf_hdr_t *dst_hdr, bcf_hdr_t *src_hdr, bcf1_t *line)\n{\n    int i;\n    if ( line->errcode )\n    {\n        hts_log_error(\"Unchecked error (%d) at %s:%\"PRIhts_pos\", exiting\", line->errcode, bcf_seqname_safe(src_hdr,line), line->pos+1);\n        exit(1);\n    }\n    if ( src_hdr->ntransl==-1 ) return 0;    // no need to translate, all tags have the same id\n    if ( !src_hdr->ntransl )  // called for the first time, see what needs translating\n    {\n        int dict;\n        for (dict=0; dict<2; dict++)    // BCF_DT_ID and BCF_DT_CTG\n        {\n            src_hdr->transl[dict] = (int*) malloc(src_hdr->n[dict]*sizeof(int));\n            for (i=0; i<src_hdr->n[dict]; i++)\n            {\n                if ( !src_hdr->id[dict][i].key ) // gap left after removed BCF header lines\n                {\n                    src_hdr->transl[dict][i] = -1;\n                    continue;\n                }\n                src_hdr->transl[dict][i] = bcf_hdr_id2int(dst_hdr,dict,src_hdr->id[dict][i].key);\n                if ( src_hdr->transl[dict][i]!=-1 && i!=src_hdr->transl[dict][i] ) src_hdr->ntransl++;\n            }\n        }\n        if ( !src_hdr->ntransl )\n        {\n            free(src_hdr->transl[0]); src_hdr->transl[0] = NULL;\n            free(src_hdr->transl[1]); src_hdr->transl[1] = NULL;\n            src_hdr->ntransl = -1;\n        }\n        if ( src_hdr->ntransl==-1 ) return 0;\n    }\n    bcf_unpack(line,BCF_UN_ALL);\n\n    // CHROM\n    if ( src_hdr->transl[BCF_DT_CTG][line->rid] >=0 ) line->rid = src_hdr->transl[BCF_DT_CTG][line->rid];\n\n    // FILTER\n    for (i=0; i<line->d.n_flt; i++)\n    {\n        int src_id = line->d.flt[i];\n        if ( src_hdr->transl[BCF_DT_ID][src_id] >=0 )\n            line->d.flt[i] = src_hdr->transl[BCF_DT_ID][src_id];\n        line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    }\n\n    // INFO\n    for (i=0; i<line->n_info; i++)\n    {\n        int src_id = line->d.info[i].key;\n        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];\n        if ( dst_id<0 ) continue;\n        line->d.info[i].key = dst_id;\n        if ( !line->d.info[i].vptr ) continue;  // skip deleted\n        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        if ( src_size==dst_size )   // can overwrite\n        {\n            uint8_t *vptr = line->d.info[i].vptr - line->d.info[i].vptr_off;\n            if ( dst_size==BCF_BT_INT8 ) { vptr[1] = (uint8_t)dst_id; }\n            else if ( dst_size==BCF_BT_INT16 ) { *(uint16_t*)vptr = (uint16_t)dst_id; }\n            else { *(uint32_t*)vptr = (uint32_t)dst_id; }\n        }\n        else    // must realloc\n        {\n            bcf_info_t *info = &line->d.info[i];\n            kstring_t str = {0,0,0};\n            bcf_enc_int1(&str, dst_id);\n            bcf_enc_size(&str, info->len,info->type);\n            uint32_t vptr_off = str.l;\n            kputsn((char*)info->vptr, info->vptr_len, &str);\n            if( info->vptr_free ) free(info->vptr - info->vptr_off);\n            info->vptr_off = vptr_off;\n            info->vptr = (uint8_t*)str.s + info->vptr_off;\n            info->vptr_free = 1;\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n        }\n    }\n\n    // FORMAT\n    for (i=0; i<line->n_fmt; i++)\n    {\n        int src_id = line->d.fmt[i].id;\n        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];\n        if ( dst_id<0 ) continue;\n        line->d.fmt[i].id = dst_id;\n        if( !line->d.fmt[i].p ) continue;  // skip deleted\n        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;\n        if ( src_size==dst_size )   // can overwrite\n        {\n            uint8_t *p = line->d.fmt[i].p - line->d.fmt[i].p_off;    // pointer to the vector size (4bits) and BT type (4bits)\n            if ( dst_size==BCF_BT_INT8 ) { p[1] = dst_id; }\n            else if ( dst_size==BCF_BT_INT16 ) { i16_to_le(dst_id, p + 1); }\n            else { i32_to_le(dst_id, p + 1); }\n        }\n        else    // must realloc\n        {\n            bcf_fmt_t *fmt = &line->d.fmt[i];\n            kstring_t str = {0,0,0};\n            bcf_enc_int1(&str, dst_id);\n            bcf_enc_size(&str, fmt->n, fmt->type);\n            uint32_t p_off = str.l;\n            kputsn((char*)fmt->p, fmt->p_len, &str);\n            if( fmt->p_free ) free(fmt->p - fmt->p_off);\n            fmt->p_off = p_off;\n            fmt->p = (uint8_t*)str.s + fmt->p_off;\n            fmt->p_free = 1;\n            line->d.indiv_dirty = 1;\n        }\n    }\n    return 0;\n}\n\nbcf_hdr_t *bcf_hdr_dup(const bcf_hdr_t *hdr)\n{\n    bcf_hdr_t *hout = bcf_hdr_init(\"r\");\n    if (!hout) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        return NULL;\n    }\n    kstring_t htxt = {0,0,0};\n    bcf_hdr_format(hdr, 1, &htxt);\n    if ( bcf_hdr_parse(hout, htxt.s) < 0 ) {\n        bcf_hdr_destroy(hout);\n        hout = NULL;\n    }\n    free(htxt.s);\n    return hout;\n}\n\nbcf_hdr_t *bcf_hdr_subset(const bcf_hdr_t *h0, int n, char *const* samples, int *imap)\n{\n    void *names_hash = khash_str2int_init();\n    kstring_t htxt = {0,0,0};\n    kstring_t str = {0,0,0};\n    bcf_hdr_t *h = bcf_hdr_init(\"w\");\n    if (!h) {\n        hts_log_error(\"Failed to allocate bcf header\");\n        khash_str2int_destroy(names_hash);\n        return NULL;\n    }\n    bcf_hdr_format(h0, 1, &htxt);\n    bcf_hdr_set_version(h,bcf_hdr_get_version(h0));\n    int j;\n    for (j=0; j<n; j++) imap[j] = -1;\n    if ( bcf_hdr_nsamples(h0) > 0) {\n        char *p = find_chrom_header_line(htxt.s);\n        int i = 0, end = n? 8 : 7;\n        while ((p = strchr(p, '\\t')) != 0 && i < end) ++i, ++p;\n        if (i != end) {\n            free(h); free(str.s);\n            return 0; // malformated header\n        }\n        kputsn(htxt.s, p - htxt.s, &str);\n        for (i = 0; i < n; ++i) {\n            if ( khash_str2int_has_key(names_hash,samples[i]) )\n            {\n                hts_log_error(\"Duplicate sample name \\\"%s\\\"\", samples[i]);\n                free(str.s);\n                free(htxt.s);\n                khash_str2int_destroy(names_hash);\n                bcf_hdr_destroy(h);\n                return NULL;\n            }\n            imap[i] = bcf_hdr_id2int(h0, BCF_DT_SAMPLE, samples[i]);\n            if (imap[i] < 0) continue;\n            kputc('\\t', &str);\n            kputs(samples[i], &str);\n            khash_str2int_inc(names_hash,samples[i]);\n        }\n    } else kputsn(htxt.s, htxt.l, &str);\n    while (str.l && (!str.s[str.l-1] || str.s[str.l-1]=='\\n') ) str.l--; // kill trailing zeros and newlines\n    kputc('\\n',&str);\n    if ( bcf_hdr_parse(h, str.s) < 0 ) {\n        bcf_hdr_destroy(h);\n        h = NULL;\n    }\n    free(str.s);\n    free(htxt.s);\n    khash_str2int_destroy(names_hash);\n    return h;\n}\n\nint bcf_hdr_set_samples(bcf_hdr_t *hdr, const char *samples, int is_file)\n{\n    if ( samples && !strcmp(\"-\",samples) ) return 0;            // keep all samples\n\n    int i, narr = bit_array_size(bcf_hdr_nsamples(hdr));\n    hdr->keep_samples = (uint8_t*) calloc(narr,1);\n    if (!hdr->keep_samples) return -1;\n\n    hdr->nsamples_ori = bcf_hdr_nsamples(hdr);\n    if ( !samples )\n    {\n        // exclude all samples\n        khint_t k;\n        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE], *new_dict;\n        new_dict = kh_init(vdict);\n        if (!new_dict) return -1;\n\n        bcf_hdr_nsamples(hdr) = 0;\n\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        hdr->dict[BCF_DT_SAMPLE] = new_dict;\n        if (bcf_hdr_sync(hdr) < 0) return -1;\n\n        return 0;\n    }\n\n    if ( samples[0]=='^' )\n        for (i=0; i<bcf_hdr_nsamples(hdr); i++) bit_array_set(hdr->keep_samples,i);\n\n    int idx, n, ret = 0;\n    char **smpls = hts_readlist(samples[0]=='^'?samples+1:samples, is_file, &n);\n    if ( !smpls ) return -1;\n    for (i=0; i<n; i++)\n    {\n        idx = bcf_hdr_id2int(hdr,BCF_DT_SAMPLE,smpls[i]);\n        if ( idx<0 )\n        {\n            if ( !ret ) ret = i+1;\n            continue;\n        }\n        assert( idx<bcf_hdr_nsamples(hdr) );\n        if (  samples[0]=='^' )\n            bit_array_clear(hdr->keep_samples, idx);\n        else\n            bit_array_set(hdr->keep_samples, idx);\n    }\n    for (i=0; i<n; i++) free(smpls[i]);\n    free(smpls);\n\n    bcf_hdr_nsamples(hdr) = 0;\n    for (i=0; i<hdr->nsamples_ori; i++)\n        if ( bit_array_test(hdr->keep_samples,i) ) bcf_hdr_nsamples(hdr)++;\n\n    if ( !bcf_hdr_nsamples(hdr) ) { free(hdr->keep_samples); hdr->keep_samples=NULL; }\n    else\n    {\n        // Make new list and dictionary with desired samples\n        char **samples = (char**) malloc(sizeof(char*)*bcf_hdr_nsamples(hdr));\n        vdict_t *new_dict, *d;\n        int k, res;\n        if (!samples) return -1;\n\n        new_dict = kh_init(vdict);\n        if (!new_dict) {\n            free(samples);\n            return -1;\n        }\n        idx = 0;\n        for (i=0; i<hdr->nsamples_ori; i++) {\n            if ( bit_array_test(hdr->keep_samples,i) ) {\n                samples[idx] = hdr->samples[i];\n                k = kh_put(vdict, new_dict, hdr->samples[i], &res);\n                if (res < 0) {\n                    free(samples);\n                    kh_destroy(vdict, new_dict);\n                    return -1;\n                }\n                kh_val(new_dict, k) = bcf_idinfo_def;\n                kh_val(new_dict, k).id = idx;\n                idx++;\n            }\n        }\n\n        // Delete desired samples from old dictionary, so we don't free them\n        d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE];\n        for (i=0; i < idx; i++) {\n            int k = kh_get(vdict, d, samples[i]);\n            if (k < kh_end(d)) kh_del(vdict, d, k);\n        }\n\n        // Free everything else\n        for (k = kh_begin(d); k != kh_end(d); ++k)\n            if (kh_exist(d, k)) free((char*)kh_key(d, k));\n        kh_destroy(vdict, d);\n        hdr->dict[BCF_DT_SAMPLE] = new_dict;\n\n        free(hdr->samples);\n        hdr->samples = samples;\n\n        if (bcf_hdr_sync(hdr) < 0)\n            return -1;\n    }\n\n    return ret;\n}\n\nint bcf_subset(const bcf_hdr_t *h, bcf1_t *v, int n, int *imap)\n{\n    kstring_t ind;\n    ind.s = 0; ind.l = ind.m = 0;\n    if (n) {\n        bcf_fmt_t fmt[MAX_N_FMT];\n        int i, j;\n        uint8_t *ptr = (uint8_t*)v->indiv.s;\n        for (i = 0; i < v->n_fmt; ++i)\n            ptr = bcf_unpack_fmt_core1(ptr, v->n_sample, &fmt[i]);\n        for (i = 0; i < (int)v->n_fmt; ++i) {\n            bcf_fmt_t *f = &fmt[i];\n            bcf_enc_int1(&ind, f->id);\n            bcf_enc_size(&ind, f->n, f->type);\n            for (j = 0; j < n; ++j)\n                if (imap[j] >= 0) kputsn((char*)(f->p + imap[j] * f->size), f->size, &ind);\n        }\n        for (i = j = 0; j < n; ++j) if (imap[j] >= 0) ++i;\n        v->n_sample = i;\n    } else v->n_sample = 0;\n    if ( !v->n_sample ) v->n_fmt = 0;\n    free(v->indiv.s);\n    v->indiv = ind;\n    v->unpacked &= ~BCF_UN_FMT;    // only BCF is ready for output, VCF will need to unpack again\n    return 0;\n}\n\nint bcf_is_snp(bcf1_t *v)\n{\n    int i;\n    bcf_unpack(v, BCF_UN_STR);\n    for (i = 0; i < v->n_allele; ++i)\n    {\n        if ( v->d.allele[i][1]==0 && v->d.allele[i][0]!='*' ) continue;\n\n        // mpileup's <X> allele, see also below. This is not completely satisfactory,\n        // a general library is here narrowly tailored to fit samtools.\n        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='X' && v->d.allele[i][2]=='>' ) continue;\n        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='*' && v->d.allele[i][2]=='>' ) continue;\n\n        break;\n    }\n    return i == v->n_allele;\n}\n\nstatic void bcf_set_variant_type(const char *ref, const char *alt, variant_t *var)\n{\n    if ( *alt == '*' && !alt[1] ) { var->n = 0; var->type = VCF_OVERLAP; return; }  // overlapping variant\n\n    // The most frequent case\n    if ( !ref[1] && !alt[1] )\n    {\n        if ( *alt == '.' || *ref==*alt ) { var->n = 0; var->type = VCF_REF; return; }\n        if ( *alt == 'X' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant\n        var->n = 1; var->type = VCF_SNP; return;\n    }\n    if ( alt[0]=='<' )\n    {\n        if ( alt[1]=='X' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant\n        if ( alt[1]=='*' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }\n        if ( !strcmp(\"NON_REF>\",alt+1) ) { var->n = 0; var->type = VCF_REF; return; }\n        var->type = VCF_OTHER;\n        return;\n    }\n\n    const char *r = ref, *a = alt;\n    while (*r && *a && toupper_c(*r)==toupper_c(*a) ) { r++; a++; }     // unfortunately, matching REF,ALT case is not guaranteed\n\n    if ( *a && !*r )\n    {\n        if ( *a==']' || *a=='[' ) { var->type = VCF_BND; return; }\n        while ( *a ) a++;\n        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;\n    }\n    else if ( *r && !*a )\n    {\n        while ( *r ) r++;\n        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;\n    }\n    else if ( !*r && !*a )\n    {\n        var->n = 0; var->type = VCF_REF; return;\n    }\n\n    const char *re = r, *ae = a;\n    while ( re[1] ) re++;\n    while ( ae[1] ) ae++;\n    while ( re>r && ae>a && toupper_c(*re)==toupper_c(*ae) ) { re--; ae--; }\n    if ( ae==a )\n    {\n        if ( re==r ) { var->n = 1; var->type = VCF_SNP; return; }\n        var->n = -(re-r);\n        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }\n        var->type = VCF_OTHER; return;\n    }\n    else if ( re==r )\n    {\n        var->n = ae-a;\n        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }\n        var->type = VCF_OTHER; return;\n    }\n\n    var->type = ( re-r == ae-a ) ? VCF_MNP : VCF_OTHER;\n    var->n = ( re-r > ae-a ) ? -(re-r+1) : ae-a+1;\n\n    // should do also complex events, SVs, etc...\n}\n\nstatic int bcf_set_variant_types(bcf1_t *b)\n{\n    if ( !(b->unpacked & BCF_UN_STR) ) bcf_unpack(b, BCF_UN_STR);\n    bcf_dec_t *d = &b->d;\n    if ( d->n_var < b->n_allele )\n    {\n        d->var = (variant_t *) realloc(d->var, sizeof(variant_t)*b->n_allele);\n        d->n_var = b->n_allele;\n    }\n    int i;\n    b->d.var_type = 0;\n    d->var[0].type = VCF_REF;\n    d->var[0].n    = 0;\n    for (i=1; i<b->n_allele; i++)\n    {\n        bcf_set_variant_type(d->allele[0],d->allele[i], &d->var[i]);\n        b->d.var_type |= d->var[i].type;\n        //fprintf(stderr,\"[set_variant_type] %d   %s %s -> %d %d .. %d\\n\", b->pos+1,d->allele[0],d->allele[i],d->var[i].type,d->var[i].n, b->d.var_type);\n    }\n    return 0;\n}\n\nint bcf_get_variant_types(bcf1_t *rec)\n{\n    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);\n    return rec->d.var_type;\n}\nint bcf_get_variant_type(bcf1_t *rec, int ith_allele)\n{\n    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);\n    return rec->d.var[ith_allele].type;\n}\n\nint bcf_update_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)\n{\n    static int negative_rlen_warned = 0;\n    int is_end_tag;\n\n    // Is the field already present?\n    int i, inf_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,inf_id) ) return -1;    // No such INFO field in the header\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n\n    is_end_tag = strcmp(key, \"END\") == 0;\n\n    for (i=0; i<line->n_info; i++)\n        if ( inf_id==line->d.info[i].key ) break;\n    bcf_info_t *inf = i==line->n_info ? NULL : &line->d.info[i];\n\n    if ( !n || (type==BCF_HT_STR && !values) )\n    {\n        if ( n==0 && is_end_tag )\n            line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;\n        if ( inf )\n        {\n            // Mark the tag for removal, free existing memory if necessary\n            if ( inf->vptr_free )\n            {\n                free(inf->vptr - inf->vptr_off);\n                inf->vptr_free = 0;\n            }\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n            inf->vptr = NULL;\n            inf->vptr_off = inf->vptr_len = 0;\n        }\n        return 0;\n    }\n\n    if (is_end_tag)\n    {\n        if (n != 1)\n        {\n            hts_log_error(\"END info tag should only have one value at %s:%\"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);\n            line->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n        if (type != BCF_HT_INT && type != BCF_HT_LONG)\n        {\n            hts_log_error(\"Wrong type (%d) for END info tag at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n            line->errcode |= BCF_ERR_TAG_INVALID;\n            return -1;\n        }\n    }\n\n    // Encode the values and determine the size required to accommodate the values\n    kstring_t str = {0,0,0};\n    bcf_enc_int1(&str, inf_id);\n    if ( type==BCF_HT_INT )\n        bcf_enc_vint(&str, n, (int32_t*)values, -1);\n    else if ( type==BCF_HT_REAL )\n        bcf_enc_vfloat(&str, n, (float*)values);\n    else if ( type==BCF_HT_FLAG || type==BCF_HT_STR )\n    {\n        if ( values==NULL )\n            bcf_enc_size(&str, 0, BCF_BT_NULL);\n        else\n            bcf_enc_vchar(&str, strlen((char*)values), (char*)values);\n    }\n#ifdef VCF_ALLOW_INT64\n    else if ( type==BCF_HT_LONG )\n    {\n        if (n != 1) {\n            hts_log_error(\"Only storing a single BCF_HT_LONG value is supported at %s:%\"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);\n            abort();\n        }\n        bcf_enc_long1(&str, *(int64_t *) values);\n    }\n#endif\n    else\n    {\n        hts_log_error(\"The type %d not implemented yet at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n        abort();\n    }\n\n    // Is the INFO tag already present\n    if ( inf )\n    {\n        // Is it big enough to accommodate new block?\n        if ( str.l <= inf->vptr_len + inf->vptr_off )\n        {\n            if ( str.l != inf->vptr_len + inf->vptr_off ) line->d.shared_dirty |= BCF1_DIRTY_INF;\n            uint8_t *ptr = inf->vptr - inf->vptr_off;\n            memcpy(ptr, str.s, str.l);\n            free(str.s);\n            int vptr_free = inf->vptr_free;\n            bcf_unpack_info_core1(ptr, inf);\n            inf->vptr_free = vptr_free;\n        }\n        else\n        {\n            if ( inf->vptr_free )\n                free(inf->vptr - inf->vptr_off);\n            bcf_unpack_info_core1((uint8_t*)str.s, inf);\n            inf->vptr_free = 1;\n            line->d.shared_dirty |= BCF1_DIRTY_INF;\n        }\n    }\n    else\n    {\n        // The tag is not present, create new one\n        line->n_info++;\n        hts_expand0(bcf_info_t, line->n_info, line->d.m_info , line->d.info);\n        inf = &line->d.info[line->n_info-1];\n        bcf_unpack_info_core1((uint8_t*)str.s, inf);\n        inf->vptr_free = 1;\n        line->d.shared_dirty |= BCF1_DIRTY_INF;\n    }\n    line->unpacked |= BCF_UN_INFO;\n\n   if ( n==1 && is_end_tag) {\n        hts_pos_t end = type == BCF_HT_INT ? *(int32_t *) values : *(int64_t *) values;\n        if ( (type == BCF_HT_INT && end!=bcf_int32_missing) || (type == BCF_HT_LONG && end!=bcf_int64_missing) )\n        {\n            if ( end <= line->pos )\n            {\n                if ( !negative_rlen_warned )\n                {\n                    hts_log_warning(\"INFO/END=%\"PRIhts_pos\" is smaller than POS at %s:%\"PRIhts_pos,end,bcf_seqname_safe(hdr,line),line->pos+1);\n                    negative_rlen_warned = 1;\n                }\n                line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;\n            }\n            else\n                line->rlen = end - line->pos;\n        }\n    }\n    return 0;\n}\n\nint bcf_update_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const char **values, int n)\n{\n    if ( !n )\n        return bcf_update_format(hdr,line,key,NULL,0,BCF_HT_STR);\n\n    int i, max_len = 0;\n    for (i=0; i<n; i++)\n    {\n        int len = strlen(values[i]);\n        if ( len > max_len ) max_len = len;\n    }\n    char *out = (char*) malloc(max_len*n);\n    if ( !out ) return -2;\n    for (i=0; i<n; i++)\n    {\n        char *dst = out+i*max_len;\n        const char *src = values[i];\n        int j = 0;\n        while ( src[j] ) { dst[j] = src[j]; j++; }\n        for (; j<max_len; j++) dst[j] = 0;\n    }\n    int ret = bcf_update_format(hdr,line,key,out,max_len*n,BCF_HT_STR);\n    free(out);\n    return ret;\n}\n\nint bcf_update_format(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)\n{\n    // Is the field already present?\n    int i, fmt_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,fmt_id) )\n    {\n        if ( !n ) return 0;\n        return -1;  // the key not present in the header\n    }\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==fmt_id ) break;\n    bcf_fmt_t *fmt = i==line->n_fmt ? NULL : &line->d.fmt[i];\n\n    if ( !n )\n    {\n        if ( fmt )\n        {\n            // Mark the tag for removal, free existing memory if necessary\n            if ( fmt->p_free )\n            {\n                free(fmt->p - fmt->p_off);\n                fmt->p_free = 0;\n            }\n            line->d.indiv_dirty = 1;\n            fmt->p = NULL;\n        }\n        return 0;\n    }\n\n    line->n_sample = bcf_hdr_nsamples(hdr);\n    int nps = n / line->n_sample;  // number of values per sample\n    assert( nps && nps*line->n_sample==n );     // must be divisible by n_sample\n\n    // Encode the values and determine the size required to accommodate the values\n    kstring_t str = {0,0,0};\n    bcf_enc_int1(&str, fmt_id);\n    assert(values != NULL);\n    if ( type==BCF_HT_INT )\n        bcf_enc_vint(&str, n, (int32_t*)values, nps);\n    else if ( type==BCF_HT_REAL )\n    {\n        bcf_enc_size(&str, nps, BCF_BT_FLOAT);\n        serialize_float_array(&str, nps*line->n_sample, (float *) values);\n    }\n    else if ( type==BCF_HT_STR )\n    {\n        bcf_enc_size(&str, nps, BCF_BT_CHAR);\n        kputsn((char*)values, nps*line->n_sample, &str);\n    }\n    else\n    {\n        hts_log_error(\"The type %d not implemented yet at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n        abort();\n    }\n\n    if ( !fmt )\n    {\n        // Not present, new format field\n        line->n_fmt++;\n        hts_expand0(bcf_fmt_t, line->n_fmt, line->d.m_fmt, line->d.fmt);\n\n        // Special case: VCF specification requires that GT is always first\n        if ( line->n_fmt > 1 && key[0]=='G' && key[1]=='T' && !key[2] )\n        {\n            for (i=line->n_fmt-1; i>0; i--)\n                line->d.fmt[i] = line->d.fmt[i-1];\n            fmt = &line->d.fmt[0];\n        }\n        else\n            fmt = &line->d.fmt[line->n_fmt-1];\n        bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);\n        line->d.indiv_dirty = 1;\n        fmt->p_free = 1;\n    }\n    else\n    {\n        // The tag is already present, check if it is big enough to accomodate the new block\n        if ( str.l <= fmt->p_len + fmt->p_off )\n        {\n            // good, the block is big enough\n            if ( str.l != fmt->p_len + fmt->p_off ) line->d.indiv_dirty = 1;\n            uint8_t *ptr = fmt->p - fmt->p_off;\n            memcpy(ptr, str.s, str.l);\n            free(str.s);\n            int p_free = fmt->p_free;\n            bcf_unpack_fmt_core1(ptr, line->n_sample, fmt);\n            fmt->p_free = p_free;\n        }\n        else\n        {\n            if ( fmt->p_free )\n                free(fmt->p - fmt->p_off);\n            bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);\n            fmt->p_free = 1;\n            line->d.indiv_dirty = 1;\n        }\n    }\n    line->unpacked |= BCF_UN_FMT;\n    return 0;\n}\n\n\nint bcf_update_filter(const bcf_hdr_t *hdr, bcf1_t *line, int *flt_ids, int n)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    line->d.n_flt = n;\n    if ( !n ) return 0;\n    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);\n    int i;\n    for (i=0; i<n; i++)\n        line->d.flt[i] = flt_ids[i];\n    return 0;\n}\n\nint bcf_add_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( flt_id==line->d.flt[i] ) break;\n    if ( i<line->d.n_flt ) return 0;    // this filter is already set\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    if ( flt_id==0 )    // set to PASS\n        line->d.n_flt = 1;\n    else if ( line->d.n_flt==1 && line->d.flt[0]==0 )\n        line->d.n_flt = 1;\n    else\n        line->d.n_flt++;\n    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);\n    line->d.flt[line->d.n_flt-1] = flt_id;\n    return 1;\n}\nint bcf_remove_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id, int pass)\n{\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( flt_id==line->d.flt[i] ) break;\n    if ( i==line->d.n_flt ) return 0;   // the filter is not present\n    line->d.shared_dirty |= BCF1_DIRTY_FLT;\n    if ( i!=line->d.n_flt-1 ) memmove(line->d.flt+i,line->d.flt+i+1,(line->d.n_flt-i-1)*sizeof(*line->d.flt));\n    line->d.n_flt--;\n    if ( !line->d.n_flt && pass ) bcf_add_filter(hdr,line,0);\n    return 0;\n}\n\nint bcf_has_filter(const bcf_hdr_t *hdr, bcf1_t *line, char *filter)\n{\n    if ( filter[0]=='.' && !filter[1] ) filter = \"PASS\";\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, filter);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FLT,id) ) return -1;  // not defined in the header\n\n    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);\n    if ( id==0 && !line->d.n_flt) return 1; // PASS\n\n    int i;\n    for (i=0; i<line->d.n_flt; i++)\n        if ( line->d.flt[i]==id ) return 1;\n    return 0;\n}\n\nstatic inline int _bcf1_sync_alleles(const bcf_hdr_t *hdr, bcf1_t *line, int nals)\n{\n    line->d.shared_dirty |= BCF1_DIRTY_ALS;\n\n    line->n_allele = nals;\n    hts_expand(char*, line->n_allele, line->d.m_allele, line->d.allele);\n\n    char *als = line->d.als;\n    int n = 0;\n    while (n<nals)\n    {\n        line->d.allele[n] = als;\n        while ( *als ) als++;\n        als++;\n        n++;\n    }\n\n    // Update REF length. Note that END is 1-based while line->pos 0-based\n    bcf_info_t *end_info = bcf_get_info(hdr,line,\"END\");\n    if ( end_info )\n    {\n        if ( end_info->type==BCF_HT_INT && end_info->v1.i==bcf_int32_missing ) end_info = NULL;\n        else if ( end_info->type==BCF_HT_LONG && end_info->v1.i==bcf_int64_missing ) end_info = NULL;\n    }\n    if ( end_info && end_info->v1.i > line->pos )\n        line->rlen = end_info->v1.i - line->pos;\n    else if ( nals > 0 )\n        line->rlen = strlen(line->d.allele[0]);\n    else\n        line->rlen = 0;\n\n    return 0;\n}\nint bcf_update_alleles(const bcf_hdr_t *hdr, bcf1_t *line, const char **alleles, int nals)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp = {0,0,0};\n    char *free_old = NULL;\n\n    // If the supplied alleles are not pointers to line->d.als, the existing block can be reused.\n    int i;\n    for (i=0; i<nals; i++)\n        if ( alleles[i]>=line->d.als && alleles[i]<line->d.als+line->d.m_als ) break;\n    if ( i==nals )\n    {\n        // all alleles point elsewhere, reuse the existing block\n        tmp.l = 0; tmp.s = line->d.als; tmp.m = line->d.m_als;\n    }\n    else\n        free_old = line->d.als;\n\n    for (i=0; i<nals; i++)\n    {\n        kputs(alleles[i], &tmp);\n        kputc(0, &tmp);\n    }\n    line->d.als = tmp.s; line->d.m_als = tmp.m;\n    free(free_old);\n    return _bcf1_sync_alleles(hdr,line,nals);\n}\n\nint bcf_update_alleles_str(const bcf_hdr_t *hdr, bcf1_t *line, const char *alleles_string)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.als; tmp.m = line->d.m_als;\n    kputs(alleles_string, &tmp);\n    line->d.als = tmp.s; line->d.m_als = tmp.m;\n\n    int nals = 1;\n    char *t = line->d.als;\n    while (*t)\n    {\n        if ( *t==',' ) { *t = 0; nals++; }\n        t++;\n    }\n    return _bcf1_sync_alleles(hdr, line, nals);\n}\n\nint bcf_update_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)\n{\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;\n    if ( id )\n        kputs(id, &tmp);\n    else\n        kputs(\".\", &tmp);\n    line->d.id = tmp.s; line->d.m_id = tmp.m;\n    line->d.shared_dirty |= BCF1_DIRTY_ID;\n    return 0;\n}\n\nint bcf_add_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)\n{\n    if ( !id ) return 0;\n    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);\n\n    kstring_t tmp;\n    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;\n\n    int len = strlen(id);\n    char *dst = line->d.id;\n    while ( *dst && (dst=strstr(dst,id)) )\n    {\n        if ( dst[len]!=0 && dst[len]!=';' ) dst++;              // a prefix, not a match\n        else if ( dst==line->d.id || dst[-1]==';' ) return 0;   // already present\n        dst++;  // a suffix, not a match\n    }\n    if ( line->d.id && (line->d.id[0]!='.' || line->d.id[1]) )\n    {\n        tmp.l = strlen(line->d.id);\n        kputc(';',&tmp);\n    }\n    kputs(id,&tmp);\n\n    line->d.id = tmp.s; line->d.m_id = tmp.m;\n    line->d.shared_dirty |= BCF1_DIRTY_ID;\n    return 0;\n\n}\n\nbcf_fmt_t *bcf_get_fmt(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)\n{\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) ) return NULL;   // no such FMT field in the header\n    return bcf_get_fmt_id(line, id);\n}\n\nbcf_info_t *bcf_get_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)\n{\n    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,id) ) return NULL;   // no such INFO field in the header\n    return bcf_get_info_id(line, id);\n}\n\nbcf_fmt_t *bcf_get_fmt_id(bcf1_t *line, const int id)\n{\n    int i;\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n    for (i=0; i<line->n_fmt; i++)\n    {\n        if ( line->d.fmt[i].id==id ) return &line->d.fmt[i];\n    }\n    return NULL;\n}\n\nbcf_info_t *bcf_get_info_id(bcf1_t *line, const int id)\n{\n    int i;\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n    for (i=0; i<line->n_info; i++)\n    {\n        if ( line->d.info[i].key==id ) return &line->d.info[i];\n    }\n    return NULL;\n}\n\n\nint bcf_get_info_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)\n{\n    int i, ret = -4, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,tag_id) ) return -1;    // no such INFO field in the header\n    if ( bcf_hdr_id2type(hdr,BCF_HL_INFO,tag_id)!=(type & 0xff) ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);\n\n    for (i=0; i<line->n_info; i++)\n        if ( line->d.info[i].key==tag_id ) break;\n    if ( i==line->n_info ) return ( type==BCF_HT_FLAG ) ? 0 : -3;       // the tag is not present in this record\n    if ( type==BCF_HT_FLAG ) return 1;\n\n    bcf_info_t *info = &line->d.info[i];\n    if ( !info->vptr ) return -3;           // the tag was marked for removal\n    if ( type==BCF_HT_STR )\n    {\n        if ( *ndst < info->len+1 )\n        {\n            *ndst = info->len + 1;\n            *dst  = realloc(*dst, *ndst);\n        }\n        memcpy(*dst,info->vptr,info->len);\n        ((uint8_t*)*dst)[info->len] = 0;\n        return info->len;\n    }\n\n    // Make sure the buffer is big enough\n    int size1;\n    switch (type) {\n        case BCF_HT_INT:  size1 = sizeof(int32_t); break;\n        case BCF_HT_LONG: size1 = sizeof(int64_t); break;\n        case BCF_HT_REAL: size1 = sizeof(float); break;\n        default:\n            hts_log_error(\"Unexpected output type %d at %s:%\"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);\n            return -2;\n    }\n    if ( *ndst < info->len )\n    {\n        *ndst = info->len;\n        *dst  = realloc(*dst, *ndst * size1);\n    }\n\n    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_regular, out_type_t) do { \\\n        out_type_t *tmp = (out_type_t *) *dst; \\\n        int j; \\\n        for (j=0; j<info->len; j++) \\\n        { \\\n            type_t p = convert(info->vptr + j * sizeof(type_t)); \\\n            if ( is_vector_end ) break; \\\n            if ( is_missing ) set_missing; \\\n            else set_regular; \\\n            tmp++; \\\n        } \\\n        ret = j; \\\n    } while (0)\n    switch (info->type) {\n        case BCF_BT_INT8:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int64_missing, *tmp=p, int64_t);\n            } else {\n                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=p, int32_t);\n            }\n            break;\n        case BCF_BT_INT16:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t);\n            } else {\n                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t);\n            }\n            break;\n        case BCF_BT_INT32:\n            if (type == BCF_HT_LONG) {\n                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t); break;\n            } else {\n                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t); break;\n            }\n        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set(tmp, p), float); break;\n        default: hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, info->type, bcf_seqname_safe(hdr,line), line->pos+1); return -2;\n    }\n    #undef BRANCH\n    return ret;  // set by BRANCH\n}\n\nint bcf_get_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, char ***dst, int *ndst)\n{\n    int i,tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header\n    if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==tag_id ) break;\n    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record\n    bcf_fmt_t *fmt = &line->d.fmt[i];\n    if ( !fmt->p ) return -3;                                      // the tag was marked for removal\n\n    int nsmpl = bcf_hdr_nsamples(hdr);\n    if ( !*dst )\n    {\n        *dst = (char**) malloc(sizeof(char*)*nsmpl);\n        if ( !*dst ) return -4;     // could not alloc\n        (*dst)[0] = NULL;\n    }\n    int n = (fmt->n+1)*nsmpl;\n    if ( *ndst < n )\n    {\n        (*dst)[0] = realloc((*dst)[0], n);\n        if ( !(*dst)[0] ) return -4;    // could not alloc\n        *ndst = n;\n    }\n    for (i=0; i<nsmpl; i++)\n    {\n        uint8_t *src = fmt->p + i*fmt->n;\n        uint8_t *tmp = (uint8_t*)(*dst)[0] + i*(fmt->n+1);\n        memcpy(tmp,src,fmt->n);\n        tmp[fmt->n] = 0;\n        (*dst)[i] = (char*) tmp;\n    }\n    return n;\n}\n\nint bcf_get_format_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)\n{\n    int i,j, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);\n    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header\n    if ( tag[0]=='G' && tag[1]=='T' && tag[2]==0 )\n    {\n        // Ugly: GT field is considered to be a string by the VCF header but BCF represents it as INT.\n        if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;\n    }\n    else if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=type ) return -2;     // expected different type\n\n    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);\n\n    for (i=0; i<line->n_fmt; i++)\n        if ( line->d.fmt[i].id==tag_id ) break;\n    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record\n    bcf_fmt_t *fmt = &line->d.fmt[i];\n    if ( !fmt->p ) return -3;                                      // the tag was marked for removal\n\n    if ( type==BCF_HT_STR )\n    {\n        int n = fmt->n*bcf_hdr_nsamples(hdr);\n        if ( *ndst < n )\n        {\n            *dst  = realloc(*dst, n);\n            if ( !*dst ) return -4;     // could not alloc\n            *ndst = n;\n        }\n        memcpy(*dst,fmt->p,n);\n        return n;\n    }\n\n    // Make sure the buffer is big enough\n    int nsmpl = bcf_hdr_nsamples(hdr);\n    int size1 = type==BCF_HT_INT ? sizeof(int32_t) : sizeof(float);\n    if ( *ndst < fmt->n*nsmpl )\n    {\n        *ndst = fmt->n*nsmpl;\n        *dst  = realloc(*dst, *ndst*size1);\n        if ( !*dst ) return -4;     // could not alloc\n    }\n\n    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_vector_end, set_regular, out_type_t) { \\\n        out_type_t *tmp = (out_type_t *) *dst; \\\n        uint8_t *fmt_p = fmt->p; \\\n        for (i=0; i<nsmpl; i++) \\\n        { \\\n            for (j=0; j<fmt->n; j++) \\\n            { \\\n                type_t p = convert(fmt_p + j * sizeof(type_t)); \\\n                if ( is_missing ) set_missing; \\\n                else if ( is_vector_end ) { set_vector_end; break; } \\\n                else set_regular; \\\n                tmp++; \\\n            } \\\n            for (; j<fmt->n; j++) { set_vector_end; tmp++; } \\\n            fmt_p += fmt->size; \\\n        } \\\n    }\n    switch (fmt->type) {\n        case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;\n        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set_vector_end(*tmp), bcf_float_set(tmp, p), float); break;\n        default: hts_log_error(\"Unexpected type %d at %s:%\"PRIhts_pos, fmt->type, bcf_seqname_safe(hdr,line), line->pos+1); exit(1);\n    }\n    #undef BRANCH\n    return nsmpl*fmt->n;\n}\n"], "filenames": ["vcf.c"], "buggy_code_start_loc": [2357], "buggy_code_end_loc": [2366], "fixing_code_start_loc": [2356], "fixing_code_end_loc": [2368], "type": "CWE-787", "message": "HTSlib through 1.10.2 allows out-of-bounds write access in vcf_parse_format (called from vcf_parse and vcf_read).", "other": {"cve": {"id": "CVE-2020-36403", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:07.893", "lastModified": "2023-02-03T18:51:51.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HTSlib through 1.10.2 allows out-of-bounds write access in vcf_parse_format (called from vcf_parse and vcf_read)."}, {"lang": "es", "value": "HTSlib hasta la versi\u00f3n 1.10.2 permite el acceso de escritura fuera de los l\u00edmites en vcf_parse_format (llamado desde vcf_parse y vcf_read)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htslib:htslib:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.10.2", "matchCriteriaId": "CBCAF911-0256-41E0-8400-939862BB3FE5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24097", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/htslib/OSV-2020-955.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/samtools/htslib/commit/dcd4b7304941a8832fba2d0fc4c1e716e7a4e72c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/samtools/htslib/pull/1447", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/samtools/htslib/commit/dcd4b7304941a8832fba2d0fc4c1e716e7a4e72c"}}