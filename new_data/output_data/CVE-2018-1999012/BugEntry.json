{"buggy_code": ["/*\n * TechnoTrend PVA (.pva) demuxer\n * Copyright (c) 2007, 2008 Ivo van Poorten\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"mpeg.h\"\n\n#define PVA_MAX_PAYLOAD_LENGTH  0x17f8\n#define PVA_VIDEO_PAYLOAD       0x01\n#define PVA_AUDIO_PAYLOAD       0x02\n#define PVA_MAGIC               (('A' << 8) + 'V')\n\ntypedef struct PVAContext {\n    int continue_pes;\n} PVAContext;\n\nstatic int pva_check(const uint8_t *p) {\n    int length = AV_RB16(p + 6);\n    if (AV_RB16(p) != PVA_MAGIC || !p[2] || p[2] > 2 || p[4] != 0x55 ||\n        (p[5] & 0xe0) || length > PVA_MAX_PAYLOAD_LENGTH)\n        return -1;\n    return length + 8;\n}\n\nstatic int pva_probe(AVProbeData * pd) {\n    const unsigned char *buf = pd->buf;\n    int len = pva_check(buf);\n\n    if (len < 0)\n        return 0;\n\n    if (pd->buf_size >= len + 8 &&\n        pva_check(buf + len) >= 0)\n        return AVPROBE_SCORE_EXTENSION;\n\n    return AVPROBE_SCORE_MAX / 4;\n}\n\nstatic int pva_read_header(AVFormatContext *s) {\n    AVStream *st;\n\n    if (!(st = avformat_new_stream(s, NULL)))\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_MPEG2VIDEO;\n    st->need_parsing      = AVSTREAM_PARSE_FULL;\n    avpriv_set_pts_info(st, 32, 1, 90000);\n    av_add_index_entry(st, 0, 0, 0, 0, AVINDEX_KEYFRAME);\n\n    if (!(st = avformat_new_stream(s, NULL)))\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id   = AV_CODEC_ID_MP2;\n    st->need_parsing      = AVSTREAM_PARSE_FULL;\n    avpriv_set_pts_info(st, 33, 1, 90000);\n    av_add_index_entry(st, 0, 0, 0, 0, AVINDEX_KEYFRAME);\n\n    /* the parameters will be extracted from the compressed bitstream */\n    return 0;\n}\n\n#define pva_log if (read_packet) av_log\n\nstatic int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n            pes_flags              = avio_rb16(pb);\n            pes_header_data_length = avio_r8(pb);\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                          \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}\n\nstatic int pva_read_packet(AVFormatContext *s, AVPacket *pkt) {\n    AVIOContext *pb = s->pb;\n    int64_t pva_pts;\n    int ret, length, streamid;\n\n    if (read_part_of_packet(s, &pva_pts, &length, &streamid, 1) < 0 ||\n       (ret = av_get_packet(pb, pkt, length)) <= 0)\n        return AVERROR(EIO);\n\n    pkt->stream_index = streamid - 1;\n    pkt->pts = pva_pts;\n\n    return ret;\n}\n\nstatic int64_t pva_read_timestamp(struct AVFormatContext *s, int stream_index,\n                                          int64_t *pos, int64_t pos_limit) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int length, streamid;\n    int64_t res = AV_NOPTS_VALUE;\n\n    pos_limit = FFMIN(*pos+PVA_MAX_PAYLOAD_LENGTH*8, (uint64_t)*pos+pos_limit);\n\n    while (*pos < pos_limit) {\n        res = AV_NOPTS_VALUE;\n        avio_seek(pb, *pos, SEEK_SET);\n\n        pvactx->continue_pes = 0;\n        if (read_part_of_packet(s, &res, &length, &streamid, 0)) {\n            (*pos)++;\n            continue;\n        }\n        if (streamid - 1 != stream_index || res == AV_NOPTS_VALUE) {\n            *pos = avio_tell(pb) + length;\n            continue;\n        }\n        break;\n    }\n\n    pvactx->continue_pes = 0;\n    return res;\n}\n\nAVInputFormat ff_pva_demuxer = {\n    .name           = \"pva\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"TechnoTrend PVA\"),\n    .priv_data_size = sizeof(PVAContext),\n    .read_probe     = pva_probe,\n    .read_header    = pva_read_header,\n    .read_packet    = pva_read_packet,\n    .read_timestamp = pva_read_timestamp,\n};\n"], "fixing_code": ["/*\n * TechnoTrend PVA (.pva) demuxer\n * Copyright (c) 2007, 2008 Ivo van Poorten\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"mpeg.h\"\n\n#define PVA_MAX_PAYLOAD_LENGTH  0x17f8\n#define PVA_VIDEO_PAYLOAD       0x01\n#define PVA_AUDIO_PAYLOAD       0x02\n#define PVA_MAGIC               (('A' << 8) + 'V')\n\ntypedef struct PVAContext {\n    int continue_pes;\n} PVAContext;\n\nstatic int pva_check(const uint8_t *p) {\n    int length = AV_RB16(p + 6);\n    if (AV_RB16(p) != PVA_MAGIC || !p[2] || p[2] > 2 || p[4] != 0x55 ||\n        (p[5] & 0xe0) || length > PVA_MAX_PAYLOAD_LENGTH)\n        return -1;\n    return length + 8;\n}\n\nstatic int pva_probe(AVProbeData * pd) {\n    const unsigned char *buf = pd->buf;\n    int len = pva_check(buf);\n\n    if (len < 0)\n        return 0;\n\n    if (pd->buf_size >= len + 8 &&\n        pva_check(buf + len) >= 0)\n        return AVPROBE_SCORE_EXTENSION;\n\n    return AVPROBE_SCORE_MAX / 4;\n}\n\nstatic int pva_read_header(AVFormatContext *s) {\n    AVStream *st;\n\n    if (!(st = avformat_new_stream(s, NULL)))\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_MPEG2VIDEO;\n    st->need_parsing      = AVSTREAM_PARSE_FULL;\n    avpriv_set_pts_info(st, 32, 1, 90000);\n    av_add_index_entry(st, 0, 0, 0, 0, AVINDEX_KEYFRAME);\n\n    if (!(st = avformat_new_stream(s, NULL)))\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id   = AV_CODEC_ID_MP2;\n    st->need_parsing      = AVSTREAM_PARSE_FULL;\n    avpriv_set_pts_info(st, 33, 1, 90000);\n    av_add_index_entry(st, 0, 0, 0, 0, AVINDEX_KEYFRAME);\n\n    /* the parameters will be extracted from the compressed bitstream */\n    return 0;\n}\n\n#define pva_log if (read_packet) av_log\n\nstatic int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n            pes_flags              = avio_rb16(pb);\n            pes_header_data_length = avio_r8(pb);\n\n            if (avio_feof(pb)) {\n                return AVERROR_EOF;\n            }\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                          \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}\n\nstatic int pva_read_packet(AVFormatContext *s, AVPacket *pkt) {\n    AVIOContext *pb = s->pb;\n    int64_t pva_pts;\n    int ret, length, streamid;\n\n    if (read_part_of_packet(s, &pva_pts, &length, &streamid, 1) < 0 ||\n       (ret = av_get_packet(pb, pkt, length)) <= 0)\n        return AVERROR(EIO);\n\n    pkt->stream_index = streamid - 1;\n    pkt->pts = pva_pts;\n\n    return ret;\n}\n\nstatic int64_t pva_read_timestamp(struct AVFormatContext *s, int stream_index,\n                                          int64_t *pos, int64_t pos_limit) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int length, streamid;\n    int64_t res = AV_NOPTS_VALUE;\n\n    pos_limit = FFMIN(*pos+PVA_MAX_PAYLOAD_LENGTH*8, (uint64_t)*pos+pos_limit);\n\n    while (*pos < pos_limit) {\n        res = AV_NOPTS_VALUE;\n        avio_seek(pb, *pos, SEEK_SET);\n\n        pvactx->continue_pes = 0;\n        if (read_part_of_packet(s, &res, &length, &streamid, 0)) {\n            (*pos)++;\n            continue;\n        }\n        if (streamid - 1 != stream_index || res == AV_NOPTS_VALUE) {\n            *pos = avio_tell(pb) + length;\n            continue;\n        }\n        break;\n    }\n\n    pvactx->continue_pes = 0;\n    return res;\n}\n\nAVInputFormat ff_pva_demuxer = {\n    .name           = \"pva\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"TechnoTrend PVA\"),\n    .priv_data_size = sizeof(PVAContext),\n    .read_probe     = pva_probe,\n    .read_header    = pva_read_header,\n    .read_packet    = pva_read_packet,\n    .read_timestamp = pva_read_timestamp,\n};\n"], "filenames": ["libavformat/pva.c"], "buggy_code_start_loc": [136], "buggy_code_end_loc": [136], "fixing_code_start_loc": [137], "fixing_code_end_loc": [141], "type": "CWE-835", "message": "FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.", "other": {"cve": {"id": "CVE-2018-1999012", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-23T15:29:00.393", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later."}, {"lang": "es", "value": "FFmpeg antes del commit con ID 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contiene una vulnerabilidad CWE-835: bucle infinito en el demuxer de formato pva que puede resultar en una vulnerabilidad que permite que los atacantes consuman una cantidad de recursos excesiva, como la CPU y la RAM. Este ataque parece ser explotable mediante un archivo PVA especialmente manipulado que debe proporcionarse como entrada. La vulnerabilidad parece haber sido solucionada en 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.1", "matchCriteriaId": "9B915B68-D7F0-4B61-9DA0-000EE6AE9A51"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104896", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00041.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1"}}