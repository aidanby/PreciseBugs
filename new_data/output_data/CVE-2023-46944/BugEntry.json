{"buggy_code": ["import type { ChildProcess, SpawnOptions } from 'child_process';\nimport { spawn } from 'child_process';\nimport { accessSync } from 'fs';\nimport * as process from 'process';\nimport type { CancellationToken, OutputChannel } from 'vscode';\nimport { Uri, window, workspace } from 'vscode';\nimport { hrtime } from '@env/hrtime';\nimport type { CoreConfiguration } from '../../../constants';\nimport { GlyphChars } from '../../../constants';\nimport type { GitCommandOptions, GitSpawnOptions } from '../../../git/commandOptions';\nimport { GitErrorHandling } from '../../../git/commandOptions';\nimport { StashPushError, StashPushErrorReason } from '../../../git/errors';\nimport type { GitDiffFilter } from '../../../git/models/diff';\nimport { isUncommitted, isUncommittedStaged, shortenRevision } from '../../../git/models/reference';\nimport type { GitUser } from '../../../git/models/user';\nimport { GitBranchParser } from '../../../git/parsers/branchParser';\nimport { GitLogParser } from '../../../git/parsers/logParser';\nimport { GitReflogParser } from '../../../git/parsers/reflogParser';\nimport { GitTagParser } from '../../../git/parsers/tagParser';\nimport { splitAt } from '../../../system/array';\nimport { configuration } from '../../../system/configuration';\nimport { log } from '../../../system/decorators/log';\nimport { join } from '../../../system/iterable';\nimport { Logger } from '../../../system/logger';\nimport { LogLevel, slowCallWarningThreshold } from '../../../system/logger.constants';\nimport { getLogScope } from '../../../system/logger.scope';\nimport { dirname, isAbsolute, isFolderGlob, joinPaths, normalizePath, splitPath } from '../../../system/path';\nimport { equalsIgnoreCase, getDurationMilliseconds } from '../../../system/string';\nimport { getEditorCommand } from '../../../system/utils';\nimport { compare, fromString } from '../../../system/version';\nimport { ensureGitTerminal } from '../../../terminal';\nimport { isWindows } from '../platform';\nimport type { GitLocation } from './locator';\nimport type { RunOptions } from './shell';\nimport { fsExists, getWindowsShortPath, run, RunError } from './shell';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyObj = Object.freeze({});\nconst emptyStr = '';\n\nconst gitBranchDefaultConfigs = Object.freeze(['-c', 'color.branch=false']);\nconst gitDiffDefaultConfigs = Object.freeze(['-c', 'color.diff=false']);\nexport const gitLogDefaultConfigs = Object.freeze(['-c', 'log.showSignature=false']);\nexport const gitLogDefaultConfigsWithFiles = Object.freeze([\n\t'-c',\n\t'log.showSignature=false',\n\t'-c',\n\t'diff.renameLimit=0',\n]);\nconst gitStatusDefaultConfigs = Object.freeze(['-c', 'color.status=false']);\n\nexport const maxGitCliLength = 30000;\n\nconst textDecoder = new TextDecoder('utf8');\n\n// This is a root sha of all git repo's if using sha1\nconst rootSha = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\n\nexport const GitErrors = {\n\tbadRevision: /bad revision '(.*?)'/i,\n\tnoFastForward: /\\(non-fast-forward\\)/i,\n\tnoMergeBase: /no merge base/i,\n\tnotAValidObjectName: /Not a valid object name/i,\n\tinvalidLineCount: /file .+? has only \\d+ lines/i,\n\tuncommittedChanges: /contains modified or untracked files/i,\n\talreadyExists: /already exists/i,\n\talreadyCheckedOut: /already checked out/i,\n\tmainWorkingTree: /is a main working tree/i,\n};\n\nconst GitWarnings = {\n\tnotARepository: /Not a git repository/i,\n\toutsideRepository: /is outside repository/i,\n\tnoPath: /no such path/i,\n\tnoCommits: /does not have any commits/i,\n\tnotFound: /Path '.*?' does not exist in/i,\n\tfoundButNotInRevision: /Path '.*?' exists on disk, but not in/i,\n\theadNotABranch: /HEAD does not point to a branch/i,\n\tnoUpstream: /no upstream configured for branch '(.*?)'/i,\n\tunknownRevision:\n\t\t/ambiguous argument '.*?': unknown revision or path not in the working tree|not stored as a remote-tracking branch/i,\n\tmustRunInWorkTree: /this operation must be run in a work tree/i,\n\tpatchWithConflicts: /Applied patch to '.*?' with conflicts/i,\n\tnoRemoteRepositorySpecified: /No remote repository specified\\./i,\n\tremoteConnectionError: /Could not read from remote repository/i,\n\tnotAGitCommand: /'.+' is not a git command/i,\n};\n\nfunction defaultExceptionHandler(ex: Error, cwd: string | undefined, start?: [number, number]): string {\n\tconst msg = ex.message || ex.toString();\n\tif (msg != null && msg.length !== 0) {\n\t\tfor (const warning of Object.values(GitWarnings)) {\n\t\t\tif (warning.test(msg)) {\n\t\t\t\tconst duration = start !== undefined ? ` [${getDurationMilliseconds(start)}ms]` : '';\n\t\t\t\tLogger.warn(\n\t\t\t\t\t`[${cwd}] Git ${msg\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)}${duration}`,\n\t\t\t\t);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\tconst match = GitErrors.badRevision.exec(msg);\n\t\tif (match != null) {\n\t\t\tconst [, ref] = match;\n\n\t\t\t// Since looking up a ref with ^3 (e.g. looking for untracked files in a stash) can error on some versions of git just ignore it\n\t\t\tif (ref?.endsWith('^3')) return '';\n\t\t}\n\t}\n\n\tthrow ex;\n}\n\ntype ExitCodeOnlyGitCommandOptions = GitCommandOptions & { exitCodeOnly: true };\n\nexport class Git {\n\t/** Map of running git commands -- avoids running duplicate overlaping commands */\n\tprivate readonly pendingCommands = new Map<string, Promise<string | Buffer>>();\n\n\tasync git(options: ExitCodeOnlyGitCommandOptions, ...args: any[]): Promise<number>;\n\tasync git<T extends string | Buffer>(options: GitCommandOptions, ...args: any[]): Promise<T>;\n\tasync git<T extends string | Buffer>(options: GitCommandOptions, ...args: any[]): Promise<T> {\n\t\tconst start = hrtime();\n\n\t\tconst { configs, correlationKey, errors: errorHandling, encoding, ...opts } = options;\n\n\t\tconst runOpts: RunOptions = {\n\t\t\t...opts,\n\t\t\tencoding: (encoding ?? 'utf8') === 'utf8' ? 'utf8' : 'buffer',\n\t\t\t// Adds GCM environment variables to avoid any possible credential issues -- from https://github.com/Microsoft/vscode/issues/26573#issuecomment-338686581\n\t\t\t// Shouldn't *really* be needed but better safe than sorry\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\t...(options.env ?? emptyObj),\n\t\t\t\tGCM_INTERACTIVE: 'NEVER',\n\t\t\t\tGCM_PRESERVE_CREDS: 'TRUE',\n\t\t\t\tLC_ALL: 'C',\n\t\t\t},\n\t\t};\n\n\t\tconst gitCommand = `[${runOpts.cwd}] git ${args.join(' ')}`;\n\n\t\tconst command = `${correlationKey !== undefined ? `${correlationKey}:` : ''}${gitCommand}`;\n\n\t\tlet waiting;\n\t\tlet promise = this.pendingCommands.get(command);\n\t\tif (promise === undefined) {\n\t\t\twaiting = false;\n\n\t\t\t// Fixes https://github.com/gitkraken/vscode-gitlens/issues/73 & https://github.com/gitkraken/vscode-gitlens/issues/161\n\t\t\t// See https://stackoverflow.com/questions/4144417/how-to-handle-asian-characters-in-file-names-in-git-on-os-x\n\t\t\targs.unshift(\n\t\t\t\t'-c',\n\t\t\t\t'core.quotepath=false',\n\t\t\t\t'-c',\n\t\t\t\t'color.ui=false',\n\t\t\t\t...(configs != null ? configs : emptyArray),\n\t\t\t);\n\n\t\t\tif (process.platform === 'win32') {\n\t\t\t\targs.unshift('-c', 'core.longpaths=true');\n\t\t\t}\n\n\t\t\tpromise = run<T>(await this.path(), args, encoding ?? 'utf8', runOpts);\n\n\t\t\tthis.pendingCommands.set(command, promise);\n\t\t} else {\n\t\t\twaiting = true;\n\t\t\tLogger.debug(`[GIT  ] ${gitCommand} ${GlyphChars.Dot} waiting...`);\n\t\t}\n\n\t\tlet exception: Error | undefined;\n\t\ttry {\n\t\t\treturn (await promise) as T;\n\t\t} catch (ex) {\n\t\t\texception = ex;\n\n\t\t\tswitch (errorHandling) {\n\t\t\t\tcase GitErrorHandling.Ignore:\n\t\t\t\t\texception = undefined;\n\t\t\t\t\treturn '' as T;\n\n\t\t\t\tcase GitErrorHandling.Throw:\n\t\t\t\t\tthrow ex;\n\n\t\t\t\tdefault: {\n\t\t\t\t\tconst result = defaultExceptionHandler(ex, options.cwd, start);\n\t\t\t\t\texception = undefined;\n\t\t\t\t\treturn result as T;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.pendingCommands.delete(command);\n\n\t\t\tconst duration = getDurationMilliseconds(start);\n\t\t\tconst slow = duration > slowCallWarningThreshold;\n\t\t\tconst status =\n\t\t\t\tslow || waiting\n\t\t\t\t\t? ` (${slow ? `slow${waiting ? ', waiting' : ''}` : ''}${waiting ? 'waiting' : ''})`\n\t\t\t\t\t: '';\n\n\t\t\tif (exception != null) {\n\t\t\t\tLogger.error(\n\t\t\t\t\t'',\n\t\t\t\t\t`[GIT  ] ${gitCommand} ${GlyphChars.Dot} ${(exception.message || String(exception) || '')\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)} [${duration}ms]${status}`,\n\t\t\t\t);\n\t\t\t} else if (slow) {\n\t\t\t\tLogger.warn(`[GIT  ] ${gitCommand} [*${duration}ms]${status}`);\n\t\t\t} else {\n\t\t\t\tLogger.log(`[GIT  ] ${gitCommand} [${duration}ms]${status}`);\n\t\t\t}\n\t\t\tthis.logGitCommand(\n\t\t\t\t`${gitCommand}${exception != null ? ` ${GlyphChars.Dot} FAILED` : ''}${waiting ? ' (waited)' : ''}`,\n\t\t\t\tduration,\n\t\t\t\texception,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync gitSpawn(options: GitSpawnOptions, ...args: any[]): Promise<ChildProcess> {\n\t\tconst start = hrtime();\n\n\t\tconst { cancellation, configs, stdin, stdinEncoding, ...opts } = options;\n\n\t\tconst spawnOpts: SpawnOptions = {\n\t\t\t// Unless provided, ignore stdin and leave default streams for stdout and stderr\n\t\t\tstdio: [stdin ? 'pipe' : 'ignore', null, null],\n\t\t\t...opts,\n\t\t\t// Adds GCM environment variables to avoid any possible credential issues -- from https://github.com/Microsoft/vscode/issues/26573#issuecomment-338686581\n\t\t\t// Shouldn't *really* be needed but better safe than sorry\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\t...(options.env ?? emptyObj),\n\t\t\t\tGCM_INTERACTIVE: 'NEVER',\n\t\t\t\tGCM_PRESERVE_CREDS: 'TRUE',\n\t\t\t\tLC_ALL: 'C',\n\t\t\t},\n\t\t};\n\n\t\tconst gitCommand = `[${spawnOpts.cwd as string}] git ${args.join(' ')}`;\n\n\t\t// Fixes https://github.com/gitkraken/vscode-gitlens/issues/73 & https://github.com/gitkraken/vscode-gitlens/issues/161\n\t\t// See https://stackoverflow.com/questions/4144417/how-to-handle-asian-characters-in-file-names-in-git-on-os-x\n\t\targs.unshift(\n\t\t\t'-c',\n\t\t\t'core.quotepath=false',\n\t\t\t'-c',\n\t\t\t'color.ui=false',\n\t\t\t...(configs !== undefined ? configs : emptyArray),\n\t\t);\n\n\t\tif (process.platform === 'win32') {\n\t\t\targs.unshift('-c', 'core.longpaths=true');\n\t\t}\n\n\t\tif (cancellation) {\n\t\t\tconst controller = new AbortController();\n\t\t\tspawnOpts.signal = controller.signal;\n\t\t\tcancellation.onCancellationRequested(() => controller.abort());\n\t\t}\n\n\t\tconst proc = spawn(await this.path(), args, spawnOpts);\n\t\tif (stdin) {\n\t\t\tproc.stdin?.end(stdin, (stdinEncoding ?? 'utf8') as BufferEncoding);\n\t\t}\n\n\t\tlet exception: Error | undefined;\n\t\tproc.once('error', e => (exception = e));\n\t\tproc.once('exit', () => {\n\t\t\tconst duration = getDurationMilliseconds(start);\n\t\t\tconst slow = duration > slowCallWarningThreshold;\n\t\t\tconst status = slow ? ' (slow)' : '';\n\n\t\t\tif (exception != null) {\n\t\t\t\tLogger.error(\n\t\t\t\t\t'',\n\t\t\t\t\t`[SGIT ] ${gitCommand} ${GlyphChars.Dot} ${(exception.message || String(exception) || '')\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)} [${duration}ms]${status}`,\n\t\t\t\t);\n\t\t\t} else if (slow) {\n\t\t\t\tLogger.warn(`[SGIT ] ${gitCommand} [*${duration}ms]${status}`);\n\t\t\t} else {\n\t\t\t\tLogger.log(`[SGIT ] ${gitCommand} [${duration}ms]${status}`);\n\t\t\t}\n\t\t\tthis.logGitCommand(\n\t\t\t\t`${gitCommand}${exception != null ? ` ${GlyphChars.Dot} FAILED` : ''}`,\n\t\t\t\tduration,\n\t\t\t\texception,\n\t\t\t);\n\t\t});\n\t\treturn proc;\n\t}\n\n\tprivate _gitLocation: GitLocation | undefined;\n\tprivate _gitLocationPromise: Promise<GitLocation> | undefined;\n\tprivate async getLocation(): Promise<GitLocation> {\n\t\tif (this._gitLocation == null) {\n\t\t\tif (this._gitLocationPromise == null) {\n\t\t\t\tthis._gitLocationPromise = this._gitLocator();\n\t\t\t}\n\t\t\tthis._gitLocation = await this._gitLocationPromise;\n\t\t}\n\t\treturn this._gitLocation;\n\t}\n\n\tprivate _gitLocator!: () => Promise<GitLocation>;\n\tsetLocator(locator: () => Promise<GitLocation>): void {\n\t\tthis._gitLocator = locator;\n\t\tthis._gitLocationPromise = undefined;\n\t\tthis._gitLocation = undefined;\n\t}\n\n\tasync path(): Promise<string> {\n\t\treturn (await this.getLocation()).path;\n\t}\n\n\tasync version(): Promise<string> {\n\t\treturn (await this.getLocation()).version;\n\t}\n\n\tasync isAtLeastVersion(minimum: string): Promise<boolean> {\n\t\tconst result = compare(fromString(await this.version()), fromString(minimum));\n\t\treturn result !== -1;\n\t}\n\n\tmaybeIsAtLeastVersion(minimum: string): boolean | undefined {\n\t\treturn this._gitLocation != null\n\t\t\t? compare(fromString(this._gitLocation.version), fromString(minimum)) !== -1\n\t\t\t: undefined;\n\t}\n\n\t// Git commands\n\n\tadd(repoPath: string | undefined, pathspec: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'add', '-A', '--', pathspec);\n\t}\n\n\tapply(repoPath: string | undefined, patch: string, options: { allowConflicts?: boolean } = {}) {\n\t\tconst params = ['apply', '--whitespace=warn'];\n\t\tif (options.allowConflicts) {\n\t\t\tparams.push('-3');\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath, stdin: patch }, ...params);\n\t}\n\n\tprivate readonly ignoreRevsFileMap = new Map<string, boolean>();\n\n\tasync blame(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tref?: string,\n\t\toptions: { args?: string[] | null; ignoreWhitespace?: boolean; startLine?: number; endLine?: number } = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['blame', '--root', '--incremental'];\n\n\t\tif (options.ignoreWhitespace) {\n\t\t\tparams.push('-w');\n\t\t}\n\t\tif (options.startLine != null && options.endLine != null) {\n\t\t\tparams.push(`-L ${options.startLine},${options.endLine}`);\n\t\t}\n\t\tif (options.args != null) {\n\t\t\tparams.push(...options.args);\n\t\t}\n\n\t\t// Ensure the version of Git supports the --ignore-revs-file flag, otherwise the blame will fail\n\t\tlet supportsIgnoreRevsFile = this.maybeIsAtLeastVersion('2.23');\n\t\tif (supportsIgnoreRevsFile === undefined) {\n\t\t\tsupportsIgnoreRevsFile = await this.isAtLeastVersion('2.23');\n\t\t}\n\n\t\tconst ignoreRevsIndex = params.indexOf('--ignore-revs-file');\n\n\t\tif (supportsIgnoreRevsFile) {\n\t\t\tlet ignoreRevsFile;\n\t\t\tif (ignoreRevsIndex !== -1) {\n\t\t\t\tignoreRevsFile = params[ignoreRevsIndex + 1];\n\t\t\t\tif (!isAbsolute(ignoreRevsFile)) {\n\t\t\t\t\tignoreRevsFile = joinPaths(root, ignoreRevsFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tignoreRevsFile = joinPaths(root, '.git-blame-ignore-revs');\n\t\t\t}\n\n\t\t\tconst exists = this.ignoreRevsFileMap.get(ignoreRevsFile);\n\t\t\tif (exists !== undefined) {\n\t\t\t\tsupportsIgnoreRevsFile = exists;\n\t\t\t} else {\n\t\t\t\t// Ensure the specified --ignore-revs-file exists, otherwise the blame will fail\n\t\t\t\ttry {\n\t\t\t\t\tsupportsIgnoreRevsFile = await fsExists(ignoreRevsFile);\n\t\t\t\t} catch {\n\t\t\t\t\tsupportsIgnoreRevsFile = false;\n\t\t\t\t}\n\n\t\t\t\tthis.ignoreRevsFileMap.set(ignoreRevsFile, supportsIgnoreRevsFile);\n\t\t\t}\n\t\t}\n\n\t\tif (!supportsIgnoreRevsFile && ignoreRevsIndex !== -1) {\n\t\t\tparams.splice(ignoreRevsIndex, 2);\n\t\t} else if (supportsIgnoreRevsFile && ignoreRevsIndex === -1) {\n\t\t\tparams.push('--ignore-revs-file', '.git-blame-ignore-revs');\n\t\t}\n\n\t\tlet stdin;\n\t\tif (ref) {\n\t\t\tif (isUncommittedStaged(ref)) {\n\t\t\t\t// Pipe the blame contents to stdin\n\t\t\t\tparams.push('--contents', '-');\n\n\t\t\t\t// Get the file contents for the staged version using `:`\n\t\t\t\tstdin = await this.show<string>(repoPath, fileName, ':');\n\t\t\t} else {\n\t\t\t\tparams.push(ref);\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: root, stdin: stdin }, ...params, '--', file);\n\t}\n\n\tblame__contents(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tcontents: string,\n\t\toptions: {\n\t\t\targs?: string[] | null;\n\t\t\tcorrelationKey?: string;\n\t\t\tignoreWhitespace?: boolean;\n\t\t\tstartLine?: number;\n\t\t\tendLine?: number;\n\t\t} = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['blame', '--root', '--incremental'];\n\n\t\tif (options.ignoreWhitespace) {\n\t\t\tparams.push('-w');\n\t\t}\n\t\tif (options.startLine != null && options.endLine != null) {\n\t\t\tparams.push(`-L ${options.startLine},${options.endLine}`);\n\t\t}\n\t\tif (options.args != null) {\n\t\t\tparams.push(...options.args);\n\t\t}\n\n\t\t// Pipe the blame contents to stdin\n\t\tparams.push('--contents', '-');\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: root, stdin: contents, correlationKey: options.correlationKey },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfile,\n\t\t);\n\t}\n\n\tbranch__containsOrPointsAt(\n\t\trepoPath: string,\n\t\tref: string,\n\t\t{\n\t\t\tmode = 'contains',\n\t\t\tname = undefined,\n\t\t\tremotes = false,\n\t\t}: { mode?: 'contains' | 'pointsAt'; name?: string; remotes?: boolean } = {},\n\t) {\n\t\tconst params = ['branch'];\n\t\tif (remotes) {\n\t\t\tparams.push('-r');\n\t\t}\n\t\tparams.push(mode === 'pointsAt' ? `--points-at=${ref}` : `--contains=${ref}`, '--format=%(refname:short)');\n\t\tif (name != null) {\n\t\t\tparams.push(name);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitBranchDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t);\n\t}\n\n\tcheck_ignore(repoPath: string, ...files: string[]) {\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore, stdin: files.join('\\0') },\n\t\t\t'check-ignore',\n\t\t\t'-z',\n\t\t\t'--stdin',\n\t\t);\n\t}\n\n\tcheck_mailmap(repoPath: string, author: string) {\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'check-mailmap', author);\n\t}\n\n\tasync check_ref_format(ref: string, repoPath?: string, options: { branch?: boolean } = { branch: true }) {\n\t\tconst params = ['check-ref-format'];\n\t\tif (options.branch) {\n\t\t\tparams.push('--branch');\n\t\t} else {\n\t\t\tparams.push('--normalize');\n\t\t}\n\n\t\ttry {\n\t\t\tconst data = await this.git<string>(\n\t\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Throw },\n\t\t\t\t...params,\n\t\t\t\tref,\n\t\t\t);\n\t\t\treturn Boolean(data.trim());\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcheckout(repoPath: string, ref: string, { createBranch, path }: { createBranch?: string; path?: string } = {}) {\n\t\tconst params = ['checkout'];\n\t\tif (createBranch) {\n\t\t\tparams.push('-b', createBranch, ref, '--');\n\t\t} else {\n\t\t\tparams.push(ref, '--');\n\n\t\t\tif (path) {\n\t\t\t\t[path, repoPath] = splitPath(path, repoPath, true);\n\n\t\t\t\tparams.push(path);\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tasync config__get(key: string, repoPath?: string, options?: { local?: boolean }) {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Ignore, local: options?.local },\n\t\t\t'config',\n\t\t\t'--get',\n\t\t\tkey,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync config__get_regex(pattern: string, repoPath?: string, options?: { local?: boolean }) {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Ignore, local: options?.local },\n\t\t\t'config',\n\t\t\t'--get-regex',\n\t\t\tpattern,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync config__set(key: string, value: string | undefined, repoPath?: string) {\n\t\tconst params = ['config', '--local'];\n\t\tif (value == null) {\n\t\t\tparams.push('--unset', key);\n\t\t} else {\n\t\t\tparams.push(key, value);\n\t\t}\n\t\tawait this.git<string>({ cwd: repoPath ?? '', local: true }, ...params);\n\t}\n\n\tasync diff(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions: {\n\t\t\tencoding?: string;\n\t\t\tfilters?: GitDiffFilter[];\n\t\t\tlinesOfContext?: number;\n\t\t\trenames?: boolean;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t} = {},\n\t): Promise<string> {\n\t\tconst params = ['diff', '--no-ext-diff', '--minimal'];\n\n\t\tif (options.linesOfContext != null) {\n\t\t\tparams.push(`-U${options.linesOfContext}`);\n\t\t}\n\n\t\tif (options.renames) {\n\t\t\tparams.push(`-M${options.similarityThreshold == null ? '' : `${options.similarityThreshold}%`}`);\n\t\t}\n\n\t\tif (options.filters != null && options.filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${options.filters.join('')}`);\n\t\t}\n\n\t\tif (ref1) {\n\t\t\t// <sha>^3 signals an untracked file in a stash and if we are trying to find its parent, use the root sha\n\t\t\tif (ref1.endsWith('^3^')) {\n\t\t\t\tref1 = rootSha;\n\t\t\t}\n\t\t\tparams.push(isUncommittedStaged(ref1) ? '--staged' : ref1);\n\t\t}\n\t\tif (ref2) {\n\t\t\tparams.push(isUncommittedStaged(ref2) ? '--staged' : ref2);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.git<string>(\n\t\t\t\t{\n\t\t\t\t\tcwd: repoPath,\n\t\t\t\t\tconfigs: gitDiffDefaultConfigs,\n\t\t\t\t\tencoding: options.encoding,\n\t\t\t\t},\n\t\t\t\t...params,\n\t\t\t\t'--',\n\t\t\t\tfileName,\n\t\t\t);\n\t\t} catch (ex) {\n\t\t\tconst match = GitErrors.badRevision.exec(ex.message);\n\t\t\tif (match !== null) {\n\t\t\t\tconst [, ref] = match;\n\n\t\t\t\t// If the bad ref is trying to find a parent ref, assume we hit to the last commit, so try again using the root sha\n\t\t\t\tif (ref === ref1 && ref != null && ref.endsWith('^')) {\n\t\t\t\t\treturn this.diff(repoPath, fileName, rootSha, ref2, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tasync diff2(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tconfigs?: readonly string[];\n\t\t\terrors?: GitErrorHandling;\n\t\t\tstdin?: string;\n\t\t},\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t\terrors: options?.errors,\n\t\t\t\tstdin: options?.stdin,\n\t\t\t},\n\t\t\t'diff',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t...args,\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tasync diff__contents(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string,\n\t\tcontents: string,\n\t\toptions: { encoding?: string; filters?: GitDiffFilter[]; similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst params = [\n\t\t\t'diff',\n\t\t\t`-M${options.similarityThreshold == null ? '' : `${options.similarityThreshold}%`}`,\n\t\t\t'--no-ext-diff',\n\t\t\t'-U0',\n\t\t\t'--minimal',\n\t\t];\n\n\t\tif (options.filters != null && options.filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${options.filters.join('')}`);\n\t\t}\n\n\t\t// // <sha>^3 signals an untracked file in a stash and if we are trying to find its parent, use the root sha\n\t\t// if (ref.endsWith('^3^')) {\n\t\t// \tref = rootSha;\n\t\t// }\n\t\t// params.push(isUncommittedStaged(ref) ? '--staged' : ref);\n\n\t\tparams.push('--no-index');\n\n\t\ttry {\n\t\t\treturn await this.git<string>(\n\t\t\t\t{\n\t\t\t\t\tcwd: repoPath,\n\t\t\t\t\tconfigs: gitDiffDefaultConfigs,\n\t\t\t\t\tencoding: options.encoding,\n\t\t\t\t\tstdin: contents,\n\t\t\t\t},\n\t\t\t\t...params,\n\t\t\t\t'--',\n\t\t\t\tfileName,\n\t\t\t\t// Pipe the contents to stdin\n\t\t\t\t'-',\n\t\t\t);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RunError && ex.stdout) {\n\t\t\t\treturn ex.stdout;\n\t\t\t}\n\n\t\t\tconst match = GitErrors.badRevision.exec(ex.message);\n\t\t\tif (match !== null) {\n\t\t\t\tconst [, matchedRef] = match;\n\n\t\t\t\t// If the bad ref is trying to find a parent ref, assume we hit to the last commit, so try again using the root sha\n\t\t\t\tif (matchedRef === ref && matchedRef != null && matchedRef.endsWith('^')) {\n\t\t\t\t\treturn this.diff__contents(repoPath, fileName, rootSha, contents, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tdiff__name_status(\n\t\trepoPath: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\t{ filters, similarityThreshold }: { filters?: GitDiffFilter[]; similarityThreshold?: number | null } = {},\n\t) {\n\t\tconst params = [\n\t\t\t'diff',\n\t\t\t'--name-status',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'--no-ext-diff',\n\t\t\t'-z',\n\t\t];\n\t\tif (filters != null && filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${filters.join('')}`);\n\t\t}\n\t\tif (ref1) {\n\t\t\tparams.push(ref1);\n\t\t}\n\t\tif (ref2) {\n\t\t\tparams.push(ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitDiffDefaultConfigs }, ...params, '--');\n\t}\n\n\tasync diff__shortstat(repoPath: string, ref?: string) {\n\t\tconst params = ['diff', '--shortstat', '--no-ext-diff'];\n\t\tif (ref) {\n\t\t\tparams.push(ref);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.git<string>({ cwd: repoPath, configs: gitDiffDefaultConfigs }, ...params, '--');\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (GitErrors.noMergeBase.test(msg)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tdifftool(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\ttool: string,\n\t\toptions: { ref1?: string; ref2?: string; staged?: boolean } = {},\n\t) {\n\t\tconst params = ['difftool', '--no-prompt', `--tool=${tool}`];\n\t\tif (options.staged) {\n\t\t\tparams.push('--staged');\n\t\t}\n\t\tif (options.ref1) {\n\t\t\tparams.push(options.ref1);\n\t\t}\n\t\tif (options.ref2) {\n\t\t\tparams.push(options.ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, '--', fileName);\n\t}\n\n\tdifftool__dir_diff(repoPath: string, tool: string, ref1: string, ref2?: string) {\n\t\tconst params = ['difftool', '--dir-diff', `--tool=${tool}`, ref1];\n\t\tif (ref2) {\n\t\t\tparams.push(ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tasync fetch(\n\t\trepoPath: string,\n\t\toptions:\n\t\t\t| { all?: boolean; branch?: undefined; prune?: boolean; remote?: string }\n\t\t\t| {\n\t\t\t\t\tall?: undefined;\n\t\t\t\t\tbranch: string;\n\t\t\t\t\tprune?: undefined;\n\t\t\t\t\tpull?: boolean;\n\t\t\t\t\tremote: string;\n\t\t\t\t\tupstream: string;\n\t\t\t  } = {},\n\t): Promise<void> {\n\t\tconst params = ['fetch'];\n\n\t\tif (options.prune) {\n\t\t\tparams.push('--prune');\n\t\t}\n\n\t\tif (options.branch && options.remote) {\n\t\t\tif (options.upstream && options.pull) {\n\t\t\t\tparams.push('-u', options.remote, `${options.upstream}:${options.branch}`);\n\n\t\t\t\ttry {\n\t\t\t\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t\t\tif (GitErrors.noFastForward.test(msg)) {\n\t\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t\t`Unable to pull the '${options.branch}' branch, as it can't be fast-forwarded.`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams.push(\n\t\t\t\t\toptions.remote,\n\t\t\t\t\toptions.upstream\n\t\t\t\t\t\t? `${options.upstream}:refs/remotes/${options.remote}/${options.branch}`\n\t\t\t\t\t\t: options.branch,\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (options.remote) {\n\t\t\tparams.push(options.remote);\n\t\t} else if (options.all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t}\n\n\tfor_each_ref__branch(repoPath: string, options: { all: boolean } = { all: false }) {\n\t\tconst params = ['for-each-ref', `--format=${GitBranchParser.defaultFormat}`, 'refs/heads'];\n\t\tif (options.all) {\n\t\t\tparams.push('refs/remotes');\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tlog(\n\t\trepoPath: string,\n\t\tref: string | undefined,\n\t\t{\n\t\t\tall,\n\t\t\targsOrFormat,\n\t\t\tauthors,\n\t\t\tlimit,\n\t\t\tmerges,\n\t\t\tordering,\n\t\t\tsimilarityThreshold,\n\t\t\tsince,\n\t\t\tuntil,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\targsOrFormat?: string | string[];\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t\tsince?: number | string;\n\t\t\tuntil?: number | string;\n\t\t},\n\t) {\n\t\tif (argsOrFormat == null) {\n\t\t\targsOrFormat = ['--name-status', `--format=${all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`];\n\t\t}\n\n\t\tif (typeof argsOrFormat === 'string') {\n\t\t\targsOrFormat = [`--format=${argsOrFormat}`];\n\t\t}\n\n\t\tconst params = [\n\t\t\t'log',\n\t\t\t...argsOrFormat,\n\t\t\t'--full-history',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'-m',\n\t\t];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (limit) {\n\t\t\tparams.push(`-n${limit + 1}`);\n\t\t}\n\n\t\tif (since) {\n\t\t\tparams.push(`--since=\"${since}\"`);\n\t\t}\n\n\t\tif (until) {\n\t\t\tparams.push(`--until=\"${until}\"`);\n\t\t}\n\n\t\tif (!merges) {\n\t\t\tparams.push('--first-parent');\n\t\t}\n\n\t\tif (authors != null && authors.length !== 0) {\n\t\t\tif (!params.includes('--use-mailmap')) {\n\t\t\t\tparams.push('--use-mailmap');\n\t\t\t}\n\t\t\tparams.push(...authors.map(a => `--author=^${a.name} <${a.email}>$`));\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all', '--single-worktree');\n\t\t}\n\n\t\tif (ref && !isUncommittedStaged(ref)) {\n\t\t\tparams.push(ref);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigsWithFiles }, ...params, '--');\n\t}\n\n\tlog2(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tconfigs?: readonly string[];\n\t\t\tref?: string;\n\t\t\terrors?: GitErrorHandling;\n\t\t\tstdin?: string;\n\t\t},\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t\terrors: options?.errors,\n\t\t\t\tstdin: options?.stdin,\n\t\t\t},\n\t\t\t'log',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t...args,\n\t\t\t...(options?.ref && !isUncommittedStaged(options.ref) ? [options.ref] : emptyArray),\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tasync logStreamTo(\n\t\trepoPath: string,\n\t\tsha: string,\n\t\tlimit: number,\n\t\toptions?: { configs?: readonly string[]; stdin?: string },\n\t\t...args: string[]\n\t): Promise<[data: string[], count: number]> {\n\t\tconst params = ['log', ...args];\n\t\tif (options?.stdin) {\n\t\t\tparams.push('--stdin');\n\t\t}\n\n\t\tconst proc = await this.gitSpawn(\n\t\t\t{ cwd: repoPath, configs: options?.configs ?? gitLogDefaultConfigs, stdin: options?.stdin },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\tconst shaRegex = getShaInLogRegex(sha);\n\n\t\tlet found = false;\n\t\tlet count = 0;\n\n\t\treturn new Promise<[data: string[], count: number]>((resolve, reject) => {\n\t\t\tconst errData: string[] = [];\n\t\t\tconst data: string[] = [];\n\n\t\t\tfunction onErrData(s: string) {\n\t\t\t\terrData.push(s);\n\t\t\t}\n\n\t\t\tfunction onError(e: Error) {\n\t\t\t\treject(e);\n\t\t\t}\n\n\t\t\tfunction onExit(exitCode: number) {\n\t\t\t\tif (exitCode !== 0) {\n\t\t\t\t\treject(new Error(errData.join('')));\n\t\t\t\t}\n\n\t\t\t\tresolve([data, count]);\n\t\t\t}\n\n\t\t\tfunction onData(s: string) {\n\t\t\t\tdata.push(s);\n\t\t\t\t// eslint-disable-next-line no-control-regex\n\t\t\t\tcount += s.match(/(?:^\\x00*|\\x00\\x00)[0-9a-f]{40}\\x00/g)?.length ?? 0;\n\n\t\t\t\tif (!found && shaRegex.test(s)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\t// Buffer a bit past the sha we are looking for\n\t\t\t\t\tif (count > limit) {\n\t\t\t\t\t\tlimit = count + 50;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found || count <= limit) return;\n\n\t\t\t\tproc.removeListener('exit', onExit);\n\t\t\t\tproc.removeListener('error', onError);\n\t\t\t\tproc.stdout!.removeListener('data', onData);\n\t\t\t\tproc.stderr!.removeListener('data', onErrData);\n\t\t\t\tproc.kill();\n\n\t\t\t\tresolve([data, count]);\n\t\t\t}\n\n\t\t\tproc.on('error', onError);\n\t\t\tproc.on('exit', onExit);\n\n\t\t\tproc.stdout!.setEncoding('utf8');\n\t\t\tproc.stdout!.on('data', onData);\n\n\t\t\tproc.stderr!.setEncoding('utf8');\n\t\t\tproc.stderr!.on('data', onErrData);\n\t\t});\n\t}\n\n\tlog__file(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string | undefined,\n\t\t{\n\t\t\tall,\n\t\t\targsOrFormat,\n\t\t\t// TODO@eamodio remove this in favor of argsOrFormat\n\t\t\tfileMode = 'full',\n\t\t\tfilters,\n\t\t\tfirstParent = false,\n\t\t\tlimit,\n\t\t\tordering,\n\t\t\trenames = true,\n\t\t\treverse = false,\n\t\t\tsince,\n\t\t\tskip,\n\t\t\tstartLine,\n\t\t\tendLine,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\targsOrFormat?: string | string[];\n\t\t\t// TODO@eamodio remove this in favor of argsOrFormat\n\t\t\tfileMode?: 'full' | 'simple' | 'none';\n\t\t\tfilters?: GitDiffFilter[];\n\t\t\tfirstParent?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t\tstartLine?: number;\n\t\t\tendLine?: number;\n\t\t} = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tif (argsOrFormat == null) {\n\t\t\targsOrFormat = [`--format=${all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`];\n\t\t}\n\n\t\tif (typeof argsOrFormat === 'string') {\n\t\t\targsOrFormat = [`--format=${argsOrFormat}`];\n\t\t}\n\n\t\tconst params = ['log', ...argsOrFormat];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (limit && !reverse) {\n\t\t\tparams.push(`-n${limit + 1}`);\n\t\t}\n\n\t\tif (skip) {\n\t\t\tparams.push(`--skip=${skip}`);\n\t\t}\n\n\t\tif (since) {\n\t\t\tparams.push(`--since=\"${since}\"`);\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all', '--single-worktree');\n\t\t}\n\n\t\t// Can't allow rename detection (`--follow`) if `all` or a `startLine` is specified\n\t\tif (renames && (all || startLine != null)) {\n\t\t\trenames = false;\n\t\t}\n\n\t\tparams.push(renames ? '--follow' : '-m');\n\t\tif (/*renames ||*/ firstParent) {\n\t\t\tparams.push('--first-parent');\n\t\t\t// In Git >= 2.29.0 `--first-parent` implies `-m`, so lets include it for consistency\n\t\t\tif (renames) {\n\t\t\t\tparams.push('-m');\n\t\t\t}\n\t\t}\n\n\t\tif (filters != null && filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${filters.join('')}`);\n\t\t}\n\n\t\tif (fileMode !== 'none') {\n\t\t\tif (startLine == null) {\n\t\t\t\t// If this is the log of a folder, use `--name-status` to match non-file logs (for parsing)\n\t\t\t\tif (fileMode === 'simple' || isFolderGlob(file)) {\n\t\t\t\t\tparams.push('--name-status');\n\t\t\t\t} else {\n\t\t\t\t\tparams.push('--numstat', '--summary');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Don't include `--name-status`, `--numstat`, or `--summary` because they aren't supported with `-L`\n\t\t\t\tparams.push(`-L ${startLine},${endLine == null ? startLine : endLine}:${file}`);\n\t\t\t}\n\t\t}\n\n\t\tif (ref && !isUncommittedStaged(ref)) {\n\t\t\t// If we are reversing, we must add a range (with HEAD) because we are using --ancestry-path for better reverse walking\n\t\t\tif (reverse) {\n\t\t\t\tparams.push('--reverse', '--ancestry-path', `${ref}..HEAD`);\n\t\t\t} else {\n\t\t\t\tparams.push(ref);\n\t\t\t}\n\t\t}\n\n\t\t// Don't specify a file spec when using a line number (so say the git docs)\n\t\tif (startLine == null) {\n\t\t\tparams.push('--', file);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: root, configs: gitLogDefaultConfigs }, ...params);\n\t}\n\n\tasync log__file_recent(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\toptions?: {\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t\tcancellation?: CancellationToken;\n\t\t},\n\t) {\n\t\tconst params = [\n\t\t\t'log',\n\t\t\t`-M${options?.similarityThreshold == null ? '' : `${options?.similarityThreshold}%`}`,\n\t\t\t'-n1',\n\t\t\t'--format=%H',\n\t\t];\n\n\t\tif (options?.ordering) {\n\t\t\tparams.push(`--${options?.ordering}-order`);\n\t\t}\n\n\t\tif (options?.ref) {\n\t\t\tparams.push(options?.ref);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tcwd: repoPath,\n\t\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\t\terrors: GitErrorHandling.Ignore,\n\t\t\t},\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__find_object(\n\t\trepoPath: string,\n\t\tobjectId: string,\n\t\tref: string,\n\t\tordering: 'date' | 'author-date' | 'topo' | null,\n\t\tfile?: string,\n\t\tcancellation?: CancellationToken,\n\t) {\n\t\tconst params = ['log', '-n1', '--no-renames', '--format=%H', `--find-object=${objectId}`, ref];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (file) {\n\t\t\tparams.push('--', file);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{\n\t\t\t\tcancellation: cancellation,\n\t\t\t\tcwd: repoPath,\n\t\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\t\terrors: GitErrorHandling.Ignore,\n\t\t\t},\n\t\t\t...params,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__recent(repoPath: string, ordering?: 'date' | 'author-date' | 'topo' | null) {\n\t\tconst params = ['log', '-n1', '--format=%H'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitLogDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__recent_committerdate(repoPath: string, ordering?: 'date' | 'author-date' | 'topo' | null) {\n\t\tconst params = ['log', '-n1', '--format=%ct'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitLogDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tlog__search(\n\t\trepoPath: string,\n\t\tsearch: string[] = emptyArray,\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t\tshas?: Set<string>;\n\t\t\tstdin?: string;\n\t\t},\n\t) {\n\t\tif (options?.shas != null) {\n\t\t\tconst stdin = join(options.shas, '\\n');\n\t\t\treturn this.git<string>(\n\t\t\t\t{ cwd: repoPath, stdin: stdin },\n\t\t\t\t'show',\n\t\t\t\t'--stdin',\n\t\t\t\t'--name-status',\n\t\t\t\t`--format=${GitLogParser.defaultFormat}`,\n\t\t\t\t'--use-mailmap',\n\t\t\t);\n\t\t}\n\n\t\tlet files;\n\t\t[search, files] = splitAt(search, search.indexOf('--'));\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: ['-C', repoPath, ...gitLogDefaultConfigs], stdin: options?.stdin },\n\t\t\t'log',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t'--name-status',\n\t\t\t`--format=${GitLogParser.defaultFormat}`,\n\t\t\t'--use-mailmap',\n\t\t\t...search,\n\t\t\t...(options?.ordering ? [`--${options.ordering}-order`] : emptyArray),\n\t\t\t...(options?.limit ? [`-n${options.limit + 1}`] : emptyArray),\n\t\t\t...(options?.skip ? [`--skip=${options.skip}`] : emptyArray),\n\t\t\t...files,\n\t\t);\n\t}\n\n\t//  log__shortstat(repoPath: string, options: { ref?: string }) {\n\t//     const params = ['log', '--shortstat', '--oneline'];\n\t//     if (options.ref && !isUncommittedStaged(options.ref)) {\n\t//         params.push(options.ref);\n\t//     }\n\t//     return this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigs }, ...params, '--');\n\t// }\n\n\tasync ls_files(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\t{ ref, untracked }: { ref?: string; untracked?: boolean } = {},\n\t): Promise<string | undefined> {\n\t\tconst params = ['ls-files'];\n\t\tif (ref && !isUncommitted(ref)) {\n\t\t\tparams.push(`--with-tree=${ref}`);\n\t\t}\n\n\t\tif (!ref && untracked) {\n\t\t\tparams.push('-o');\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tls_remote(repoPath: string, remote: string, ref?: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'ls-remote', remote, ref);\n\t}\n\n\tls_remote__HEAD(repoPath: string, remote: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'ls-remote', '--symref', remote, 'HEAD');\n\t}\n\n\tasync ls_tree(repoPath: string, ref: string, path?: string) {\n\t\tconst params = ['ls-tree'];\n\t\tif (path) {\n\t\t\tparams.push('-l', ref, '--', path);\n\t\t} else {\n\t\t\tparams.push('-lrt', ref, '--');\n\t\t}\n\t\tconst data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, ...params);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tmerge_base(repoPath: string, ref1: string, ref2: string, options?: { forkPoint?: boolean }) {\n\t\tconst params = ['merge-base'];\n\t\tif (options?.forkPoint) {\n\t\t\tparams.push('--fork-point');\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, ref1, ref2);\n\t}\n\n\tasync merge_base__is_ancestor(repoPath: string, ref1: string, ref2: string): Promise<boolean> {\n\t\tconst params = ['merge-base', '--is-ancestor'];\n\t\tconst exitCode = await this.git({ cwd: repoPath, exitCodeOnly: true }, ...params, ref1, ref2);\n\t\treturn exitCode === 0;\n\t}\n\n\treflog(\n\t\trepoPath: string,\n\t\t{\n\t\t\tall,\n\t\t\tbranch,\n\t\t\tlimit,\n\t\t\tordering,\n\t\t\tskip,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t} = {},\n\t): Promise<string> {\n\t\tconst params = ['log', '--walk-reflogs', `--format=${GitReflogParser.defaultFormat}`, '--date=iso8601'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tif (limit) {\n\t\t\tparams.push(`-n${limit}`);\n\t\t}\n\n\t\tif (skip) {\n\t\t\tparams.push(`--skip=${skip}`);\n\t\t}\n\n\t\tif (branch) {\n\t\t\tparams.push(branch);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigs }, ...params, '--');\n\t}\n\n\tremote(repoPath: string): Promise<string> {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', '-v');\n\t}\n\n\tremote__add(repoPath: string, name: string, url: string, options?: { fetch?: boolean }) {\n\t\tconst params = ['remote', 'add'];\n\t\tif (options?.fetch) {\n\t\t\tparams.push('-f');\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, name, url);\n\t}\n\n\tremote__prune(repoPath: string, name: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'prune', name);\n\t}\n\n\tremote__remove(repoPath: string, name: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'remove', name);\n\t}\n\n\tremote__get_url(repoPath: string, remote: string): Promise<string> {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'get-url', remote);\n\t}\n\n\treset(repoPath: string | undefined, fileName: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'reset', '-q', '--', fileName);\n\t}\n\n\tasync rev_list(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { all?: boolean; maxParents?: number },\n\t): Promise<string[] | undefined> {\n\t\tconst params = ['rev-list'];\n\t\tif (options?.all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tif (options?.maxParents != null) {\n\t\t\tparams.push(`--max-parents=${options.maxParents}`);\n\t\t}\n\n\t\tconst rawData = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\tref,\n\t\t\t'--',\n\t\t);\n\t\tconst data = rawData.trim().split('\\n');\n\t\tif (data.length === 0) return undefined;\n\n\t\treturn data;\n\t}\n\n\tasync rev_list__count(repoPath: string, ref: string, all?: boolean): Promise<number | undefined> {\n\t\tconst params = ['rev-list', '--count'];\n\t\tif (all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tlet data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, ...params, ref, '--');\n\t\tdata = data.trim();\n\t\tif (data.length === 0) return undefined;\n\n\t\tconst result = parseInt(data, 10);\n\t\treturn isNaN(result) ? undefined : result;\n\t}\n\n\tasync rev_list__left_right(\n\t\trepoPath: string,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t'rev-list',\n\t\t\t'--left-right',\n\t\t\t'--count',\n\t\t\t...refs,\n\t\t\t'--',\n\t\t);\n\t\tif (data.length === 0) return undefined;\n\n\t\tconst parts = data.split('\\t');\n\t\tif (parts.length !== 2) return undefined;\n\n\t\tconst [ahead, behind] = parts;\n\t\tconst result = {\n\t\t\tahead: parseInt(ahead, 10),\n\t\t\tbehind: parseInt(behind, 10),\n\t\t};\n\n\t\tif (isNaN(result.ahead) || isNaN(result.behind)) return undefined;\n\n\t\treturn result;\n\t}\n\n\tasync rev_parse(repoPath: string, ref: string): Promise<string | undefined> {\n\t\tconst data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'rev-parse', ref);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync rev_parse__currentBranch(\n\t\trepoPath: string,\n\t\tordering: 'date' | 'author-date' | 'topo' | null,\n\t): Promise<[string, string | undefined] | undefined> {\n\t\ttry {\n\t\t\tconst data = await this.git<string>(\n\t\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Throw },\n\t\t\t\t'rev-parse',\n\t\t\t\t'--abbrev-ref',\n\t\t\t\t'--symbolic-full-name',\n\t\t\t\t'@',\n\t\t\t\t'@{u}',\n\t\t\t\t'--',\n\t\t\t);\n\t\t\treturn [data, undefined];\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (GitErrors.badRevision.test(msg) || GitWarnings.noUpstream.test(msg)) {\n\t\t\t\tif (ex.stdout != null && ex.stdout.length !== 0) {\n\t\t\t\t\treturn [ex.stdout, undefined];\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.symbolic_ref(repoPath, 'HEAD');\n\t\t\t\t\tif (data != null) return [data.trim(), undefined];\n\t\t\t\t} catch {}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.symbolic_ref(repoPath, 'refs/remotes/origin/HEAD');\n\t\t\t\t\tif (data != null) return [data.trim().substr('origin/'.length), undefined];\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (/is not a symbolic ref/.test(ex.stderr)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst data = await this.ls_remote__HEAD(repoPath, 'origin');\n\t\t\t\t\t\t\tif (data != null) {\n\t\t\t\t\t\t\t\tconst match = /ref:\\s(\\S+)\\s+HEAD/m.exec(data);\n\t\t\t\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\t\t\t\tconst [, branch] = match;\n\t\t\t\t\t\t\t\t\treturn [branch.substr('refs/heads/'.length), undefined];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst defaultBranch = (await this.config__get('init.defaultBranch', repoPath)) ?? 'main';\n\t\t\t\tconst branchConfig = await this.config__get_regex(`branch\\\\.${defaultBranch}\\\\.+`, repoPath, {\n\t\t\t\t\tlocal: true,\n\t\t\t\t});\n\n\t\t\t\tlet remote;\n\t\t\t\tlet remoteBranch;\n\n\t\t\t\tif (branchConfig) {\n\t\t\t\t\tlet match = /^branch\\..+\\.remote\\s(.+)$/m.exec(branchConfig);\n\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\tremote = match[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tmatch = /^branch\\..+\\.merge\\srefs\\/heads\\/(.+)$/m.exec(branchConfig);\n\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\tremoteBranch = match[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [`${defaultBranch}${remote && remoteBranch ? `\\n${remote}/${remoteBranch}` : ''}`, undefined];\n\t\t\t}\n\n\t\t\tif (GitWarnings.headNotABranch.test(msg)) {\n\t\t\t\tconst sha = await this.log__recent(repoPath, ordering);\n\t\t\t\tif (sha === undefined) return undefined;\n\n\t\t\t\treturn [`(HEAD detached at ${shortenRevision(sha)})`, sha];\n\t\t\t}\n\n\t\t\tdefaultExceptionHandler(ex, repoPath);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync rev_parse__git_dir(cwd: string): Promise<{ path: string; commonPath?: string } | undefined> {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t'rev-parse',\n\t\t\t'--git-dir',\n\t\t\t'--git-common-dir',\n\t\t);\n\t\tif (data.length === 0) return undefined;\n\n\t\t// Keep trailing spaces which are part of the directory name\n\t\tlet [dotGitPath, commonDotGitPath] = data.split('\\n').map(r => r.trimStart());\n\n\t\t// Make sure to normalize: https://github.com/git-for-windows/git/issues/2478\n\n\t\tif (!isAbsolute(dotGitPath)) {\n\t\t\tdotGitPath = joinPaths(cwd, dotGitPath);\n\t\t}\n\t\tdotGitPath = normalizePath(dotGitPath);\n\n\t\tif (commonDotGitPath) {\n\t\t\tif (!isAbsolute(commonDotGitPath)) {\n\t\t\t\tcommonDotGitPath = joinPaths(cwd, commonDotGitPath);\n\t\t\t}\n\t\t\tcommonDotGitPath = normalizePath(commonDotGitPath);\n\n\t\t\treturn { path: dotGitPath, commonPath: commonDotGitPath !== dotGitPath ? commonDotGitPath : undefined };\n\t\t}\n\n\t\treturn { path: dotGitPath };\n\t}\n\n\tasync rev_parse__show_toplevel(cwd: string): Promise<[safe: true, repoPath: string] | [safe: false] | []> {\n\t\tlet data;\n\n\t\tif (!workspace.isTrusted) {\n\t\t\t// Check if the folder is a bare clone: if it has a file named HEAD && `rev-parse --show-cdup` is empty\n\t\t\ttry {\n\t\t\t\taccessSync(joinPaths(cwd, 'HEAD'));\n\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Throw, configs: ['-C', cwd] },\n\t\t\t\t\t'rev-parse',\n\t\t\t\t\t'--show-cdup',\n\t\t\t\t);\n\t\t\t\tif (data.trim() === '') {\n\t\t\t\t\tLogger.log(`Skipping (untrusted workspace); bare clone repository detected in '${cwd}'`);\n\t\t\t\t\treturn emptyArray as [];\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// If this throw, we should be good to open the repo (e.g. HEAD doesn't exist)\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tdata = await this.git<string>({ cwd: cwd, errors: GitErrorHandling.Throw }, 'rev-parse', '--show-toplevel');\n\t\t\t// Make sure to normalize: https://github.com/git-for-windows/git/issues/2478\n\t\t\t// Keep trailing spaces which are part of the directory name\n\t\t\treturn data.length === 0\n\t\t\t\t? (emptyArray as [])\n\t\t\t\t: [true, normalizePath(data.trimStart().replace(/[\\r|\\n]+$/, ''))];\n\t\t} catch (ex) {\n\t\t\tconst unsafeMatch =\n\t\t\t\t/^fatal: detected dubious ownership in repository at '([^']+)'[\\s\\S]*git config --global --add safe\\.directory '?([^'\\n]+)'?$/m.exec(\n\t\t\t\t\tex.stderr,\n\t\t\t\t);\n\t\t\tif (unsafeMatch?.length === 3) {\n\t\t\t\tLogger.log(\n\t\t\t\t\t`Skipping; unsafe repository detected in '${unsafeMatch[1]}'; run 'git config --global --add safe.directory ${unsafeMatch[2]}' to allow it`,\n\t\t\t\t);\n\t\t\t\treturn [false];\n\t\t\t}\n\n\t\t\tconst inDotGit = /this operation must be run in a work tree/.test(ex.stderr);\n\t\t\t// Check if we are in a bare clone\n\t\t\tif (inDotGit && workspace.isTrusted) {\n\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t\t\t'rev-parse',\n\t\t\t\t\t'--is-bare-repository',\n\t\t\t\t);\n\t\t\t\tif (data.trim() === 'true') {\n\t\t\t\t\t// If we are in a bare clone, then the common dir is the git dir\n\t\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t\t\t\t'rev-parse',\n\t\t\t\t\t\t'--git-common-dir',\n\t\t\t\t\t);\n\t\t\t\t\tdata = data.trim();\n\t\t\t\t\tif (data.length) {\n\t\t\t\t\t\treturn [true, normalizePath((data === '.' ? cwd : data).trimStart().replace(/[\\r|\\n]+$/, ''))];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inDotGit || ex.code === 'ENOENT') {\n\t\t\t\t// If the `cwd` doesn't exist, walk backward to see if any parent folder exists\n\t\t\t\tlet exists = inDotGit ? false : await fsExists(cwd);\n\t\t\t\tif (!exists) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tconst parent = dirname(cwd);\n\t\t\t\t\t\tif (parent === cwd || parent.length === 0) return emptyArray as [];\n\n\t\t\t\t\t\tcwd = parent;\n\t\t\t\t\t\texists = await fsExists(cwd);\n\t\t\t\t\t} while (!exists);\n\n\t\t\t\t\treturn this.rev_parse__show_toplevel(cwd);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn emptyArray as [];\n\t\t}\n\t}\n\n\tasync rev_parse__verify(repoPath: string, ref: string, fileName?: string): Promise<string | undefined> {\n\t\tconst params = ['rev-parse', '--verify'];\n\n\t\tif (await this.isAtLeastVersion('2.30')) {\n\t\t\tparams.push('--end-of-options');\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\tfileName ? `${ref}:./${fileName}` : `${ref}^{commit}`,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync show<TOut extends string | Buffer>(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tref: string,\n\t\toptions: {\n\t\t\tencoding?: 'binary' | 'ascii' | 'utf8' | 'utf16le' | 'ucs2' | 'base64' | 'latin1' | 'hex' | 'buffer';\n\t\t} = {},\n\t): Promise<TOut | undefined> {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tif (isUncommittedStaged(ref)) {\n\t\t\tref = ':';\n\t\t}\n\t\tif (isUncommitted(ref)) throw new Error(`ref=${ref} is uncommitted`);\n\n\t\tconst opts: GitCommandOptions = {\n\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\tcwd: root,\n\t\t\tencoding: options.encoding ?? 'utf8',\n\t\t\terrors: GitErrorHandling.Throw,\n\t\t};\n\t\tconst args = ref.endsWith(':') ? `${ref}./${file}` : `${ref}:./${file}`;\n\n\t\ttry {\n\t\t\tconst data = await this.git<TOut>(opts, 'show', '--textconv', args, '--');\n\t\t\treturn data;\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (ref === ':' && GitErrors.badRevision.test(msg)) {\n\t\t\t\treturn this.show<TOut>(repoPath, fileName, 'HEAD:', options);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tGitErrors.badRevision.test(msg) ||\n\t\t\t\tGitWarnings.notFound.test(msg) ||\n\t\t\t\tGitWarnings.foundButNotInRevision.test(msg)\n\t\t\t) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn defaultExceptionHandler(ex, opts.cwd) as TOut;\n\t\t}\n\t}\n\n\tshow2(\n\t\trepoPath: string,\n\t\toptions?: { cancellation?: CancellationToken; configs?: readonly string[] },\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t},\n\t\t\t'show',\n\t\t\t...args,\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tshow__diff(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string,\n\t\toriginalFileName?: string,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t) {\n\t\tconst params = [\n\t\t\t'show',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'--format=',\n\t\t\t'--minimal',\n\t\t\t'-U0',\n\t\t\tref,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t];\n\t\tif (originalFileName != null && originalFileName.length !== 0) {\n\t\t\tparams.push(originalFileName);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tshow__name_status(repoPath: string, fileName: string, ref: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'show', '--name-status', '--format=', '-z', ref, '--', fileName);\n\t}\n\n\tshow_ref__tags(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'show-ref', '--tags');\n\t}\n\n\tstash__apply(repoPath: string, stashName: string, deleteAfter: boolean): Promise<string | undefined> {\n\t\tif (!stashName) return Promise.resolve(undefined);\n\t\treturn this.git<string>({ cwd: repoPath }, 'stash', deleteAfter ? 'pop' : 'apply', stashName);\n\t}\n\n\tasync stash__rename(repoPath: string, stashName: string, ref: string, message: string, stashOnRef?: string) {\n\t\tawait this.stash__delete(repoPath, stashName, ref);\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath },\n\t\t\t'stash',\n\t\t\t'store',\n\t\t\t'-m',\n\t\t\tstashOnRef ? `On ${stashOnRef}: ${message}` : message,\n\t\t\tref,\n\t\t);\n\t}\n\n\tasync stash__delete(repoPath: string, stashName: string, ref?: string) {\n\t\tif (!stashName) return undefined;\n\n\t\tif (ref) {\n\t\t\tconst stashRef = await this.git<string>(\n\t\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t\t'show',\n\t\t\t\t'--format=%H',\n\t\t\t\t'--no-patch',\n\t\t\t\tstashName,\n\t\t\t);\n\t\t\tif (stashRef?.trim() !== ref) {\n\t\t\t\tthrow new Error('Unable to delete stash; mismatch with stash number');\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, 'stash', 'drop', stashName);\n\t}\n\n\tstash__list(\n\t\trepoPath: string,\n\t\t{ args, similarityThreshold }: { args?: string[]; similarityThreshold?: number | null },\n\t) {\n\t\tif (args == null) {\n\t\t\targs = ['--name-status'];\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath },\n\t\t\t'stash',\n\t\t\t'list',\n\t\t\t...args,\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t);\n\t}\n\n\tasync stash__push(\n\t\trepoPath: string,\n\t\tmessage?: string,\n\t\t{\n\t\t\tincludeUntracked,\n\t\t\tkeepIndex,\n\t\t\tonlyStaged,\n\t\t\tpathspecs,\n\t\t\tstdin,\n\t\t}: {\n\t\t\tincludeUntracked?: boolean;\n\t\t\tkeepIndex?: boolean;\n\t\t\tonlyStaged?: boolean;\n\t\t\tpathspecs?: string[];\n\t\t\tstdin?: boolean;\n\t\t} = {},\n\t): Promise<void> {\n\t\tconst params = ['stash', 'push'];\n\n\t\tif (includeUntracked || (pathspecs != null && pathspecs.length !== 0)) {\n\t\t\tparams.push('-u');\n\t\t}\n\n\t\tif (keepIndex) {\n\t\t\tparams.push('-k');\n\t\t}\n\n\t\tif (onlyStaged) {\n\t\t\tif (await this.isAtLeastVersion('2.35')) {\n\t\t\t\tparams.push('--staged');\n\t\t\t} else {\n\t\t\t\tthrow new Error('Git version 2.35 or higher is required for --staged');\n\t\t\t}\n\t\t}\n\n\t\tif (message) {\n\t\t\tparams.push('-m', message);\n\t\t}\n\n\t\tif (stdin && pathspecs != null && pathspecs.length !== 0) {\n\t\t\tvoid (await this.git<string>(\n\t\t\t\t{ cwd: repoPath, stdin: pathspecs.join('\\0') },\n\t\t\t\t...params,\n\t\t\t\t'--pathspec-from-file=-',\n\t\t\t\t'--pathspec-file-nul',\n\t\t\t));\n\n\t\t\treturn;\n\t\t}\n\n\t\tparams.push('--');\n\t\tif (pathspecs != null && pathspecs.length !== 0) {\n\t\t\tparams.push(...pathspecs);\n\t\t}\n\n\t\ttry {\n\t\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t\t} catch (ex) {\n\t\t\tif (\n\t\t\t\tex instanceof RunError &&\n\t\t\t\tex.stdout.includes('Saved working directory and index state') &&\n\t\t\t\tex.stderr.includes('Cannot remove worktree changes')\n\t\t\t) {\n\t\t\t\tthrow new StashPushError(StashPushErrorReason.ConflictingStagedAndUnstagedLines);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tasync status(\n\t\trepoPath: string,\n\t\tporcelainVersion: number = 1,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst params = [\n\t\t\t'status',\n\t\t\tporcelainVersion >= 2 ? `--porcelain=v${porcelainVersion}` : '--porcelain',\n\t\t\t'--branch',\n\t\t\t'-u',\n\t\t];\n\t\tif (await this.isAtLeastVersion('2.18')) {\n\t\t\tparams.push(`--find-renames${similarityThreshold == null ? '' : `=${similarityThreshold}%`}`);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitStatusDefaultConfigs, env: { GIT_OPTIONAL_LOCKS: '0' } },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\t}\n\n\tasync status__file(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tporcelainVersion: number = 1,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['status', porcelainVersion >= 2 ? `--porcelain=v${porcelainVersion}` : '--porcelain'];\n\t\tif (await this.isAtLeastVersion('2.18')) {\n\t\t\tparams.push(`--find-renames${similarityThreshold == null ? '' : `=${similarityThreshold}%`}`);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: root, configs: gitStatusDefaultConfigs, env: { GIT_OPTIONAL_LOCKS: '0' } },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfile,\n\t\t);\n\t}\n\n\tsymbolic_ref(repoPath: string, ref: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'symbolic-ref', '--short', ref);\n\t}\n\n\ttag(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'tag', '-l', `--format=${GitTagParser.defaultFormat}`);\n\t}\n\n\tworktree__add(\n\t\trepoPath: string,\n\t\tpath: string,\n\t\t{\n\t\t\tcommitish,\n\t\t\tcreateBranch,\n\t\t\tdetach,\n\t\t\tforce,\n\t\t}: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean } = {},\n\t) {\n\t\tconst params = ['worktree', 'add'];\n\t\tif (force) {\n\t\t\tparams.push('--force');\n\t\t}\n\t\tif (createBranch) {\n\t\t\tparams.push('-b', createBranch);\n\t\t}\n\t\tif (detach) {\n\t\t\tparams.push('--detach');\n\t\t}\n\t\tparams.push(path);\n\t\tif (commitish) {\n\t\t\tparams.push(commitish);\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tworktree__list(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'worktree', 'list', '--porcelain');\n\t}\n\n\tworktree__remove(repoPath: string, worktree: string, { force }: { force?: boolean } = {}) {\n\t\tconst params = ['worktree', 'remove'];\n\t\tif (force) {\n\t\t\tparams.push('--force');\n\t\t}\n\t\tparams.push(worktree);\n\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Throw }, ...params);\n\t}\n\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpaths: string[],\n\t\toptions?: { numeric?: false; throw?: boolean; trim?: boolean },\n\t): Promise<string | undefined>;\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpath: string[],\n\t\toptions?: { numeric: true; throw?: boolean; trim?: boolean },\n\t): Promise<number | undefined>;\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpathParts: string[],\n\t\toptions?: { numeric?: boolean; throw?: boolean; trim?: boolean },\n\t): Promise<string | number | undefined> {\n\t\ttry {\n\t\t\tconst bytes = await workspace.fs.readFile(Uri.file(joinPaths(repoPath, '.git', ...pathParts)));\n\t\t\tlet contents = textDecoder.decode(bytes);\n\t\t\tcontents = options?.trim ?? true ? contents.trim() : contents;\n\n\t\t\tif (options?.numeric) {\n\t\t\t\tconst number = Number.parseInt(contents, 10);\n\t\t\t\treturn isNaN(number) ? undefined : number;\n\t\t\t}\n\n\t\t\treturn contents;\n\t\t} catch (ex) {\n\t\t\tif (options?.throw) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\t@log()\n\tasync runGitCommandViaTerminal(cwd: string, command: string, args: string[], options?: { execute?: boolean }) {\n\t\tconst scope = getLogScope();\n\n\t\tconst location = await this.getLocation();\n\t\tconst git = normalizePath(location.path ?? 'git');\n\n\t\tconst coreEditorConfig = configuration.get('terminal.overrideGitEditor')\n\t\t\t? `-c \"core.editor=${getEditorCommand()}\" `\n\t\t\t: '';\n\n\t\tconst parsedArgs = args.map(arg => (arg.startsWith('#') || /['();$|>&<]/.test(arg) ? `\"${arg}\"` : arg));\n\n\t\tlet text;\n\t\tif (git.includes(' ') && isWindows) {\n\t\t\tlet shortenedPath = await getWindowsShortPath(git);\n\t\t\tLogger.log(scope, `\\u2022 using short Git path '${shortenedPath}' rather than '${git}'`);\n\n\t\t\tif (shortenedPath.includes(' ')) {\n\t\t\t\tconst profile = configuration.getAny<CoreConfiguration, string | null>(\n\t\t\t\t\t'terminal.integrated.defaultProfile.windows',\n\t\t\t\t);\n\t\t\t\tLogger.debug(scope, `\\u2022 short path '${shortenedPath}' contains spaces, profile '${profile}'`);\n\t\t\t\tshortenedPath = `${equalsIgnoreCase(profile, 'powershell') ? '& ' : ''}\"${shortenedPath}\"`;\n\t\t\t}\n\n\t\t\ttext = `${shortenedPath} -C \"${cwd}\" ${coreEditorConfig}${command} ${parsedArgs.join(' ')}`;\n\t\t} else {\n\t\t\ttext = `${git.includes(' ') ? `\"${git}\"` : git} -C \"${cwd}\" ${coreEditorConfig}${command} ${parsedArgs.join(\n\t\t\t\t' ',\n\t\t\t)}`;\n\t\t}\n\n\t\tLogger.log(scope, `\\u2022 '${text}'`);\n\t\tthis.logGitCommand(`[TERM] ${text}`, 0);\n\n\t\tconst terminal = ensureGitTerminal();\n\t\tterminal.show(false);\n\t\t// Removing this as this doesn't seem to work on bash\n\t\t// // Sends ansi codes to remove any text on the current input line\n\t\t// terminal.sendText('\\x1b[2K\\x1b', false);\n\t\tterminal.sendText(text, options?.execute ?? false);\n\t}\n\n\tprivate _gitOutput: OutputChannel | undefined;\n\n\tprivate logGitCommand(command: string, duration: number, ex?: Error): void {\n\t\tif (!Logger.enabled(LogLevel.Debug) && !Logger.isDebugging) return;\n\n\t\tconst slow = duration > slowCallWarningThreshold;\n\n\t\tif (Logger.isDebugging) {\n\t\t\tif (ex != null) {\n\t\t\t\tconsole.error(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr, ex);\n\t\t\t} else if (slow) {\n\t\t\t\tconsole.warn(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr);\n\t\t\t} else {\n\t\t\t\tconsole.log(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr);\n\t\t\t}\n\t\t}\n\n\t\tif (this._gitOutput == null) {\n\t\t\tthis._gitOutput = window.createOutputChannel('GitLens (Git)');\n\t\t}\n\t\tthis._gitOutput.appendLine(\n\t\t\t`${Logger.timestamp} [${slow ? '*' : ' '}${duration.toString().padStart(6)}ms] ${command}${\n\t\t\t\tex != null ? `\\n\\n${ex.toString()}` : emptyStr\n\t\t\t}`,\n\t\t);\n\t}\n}\n\nexport function getShaInLogRegex(sha: string) {\n\treturn new RegExp(`(?:^\\x00*|\\x00\\x00)${sha}\\x00`);\n}\n", "import { readdir, realpath } from 'fs';\nimport { homedir, hostname, userInfo } from 'os';\nimport { resolve as resolvePath } from 'path';\nimport { env as process_env } from 'process';\nimport type { CancellationToken, Event, TextDocument, WorkspaceFolder } from 'vscode';\nimport { Disposable, env, EventEmitter, extensions, FileType, Range, Uri, window, workspace } from 'vscode';\nimport { md5 } from '@env/crypto';\nimport { fetch, getProxyAgent } from '@env/fetch';\nimport { hrtime } from '@env/hrtime';\nimport { isLinux, isWindows } from '@env/platform';\nimport type {\n\tAPI as BuiltInGitApi,\n\tRepository as BuiltInGitRepository,\n\tGitExtension,\n} from '../../../@types/vscode.git';\nimport { getCachedAvatarUri } from '../../../avatars';\nimport type { CoreConfiguration, CoreGitConfiguration } from '../../../constants';\nimport { GlyphChars, Schemes } from '../../../constants';\nimport type { Container } from '../../../container';\nimport { emojify } from '../../../emojis';\nimport { Features } from '../../../features';\nimport { GitErrorHandling } from '../../../git/commandOptions';\nimport {\n\tGitSearchError,\n\tStashApplyError,\n\tStashApplyErrorReason,\n\tWorktreeCreateError,\n\tWorktreeCreateErrorReason,\n\tWorktreeDeleteError,\n\tWorktreeDeleteErrorReason,\n} from '../../../git/errors';\nimport type {\n\tGitCaches,\n\tGitDir,\n\tGitProvider,\n\tGitProviderDescriptor,\n\tNextComparisonUrisResult,\n\tPagedResult,\n\tPreviousComparisonUrisResult,\n\tPreviousLineComparisonUrisResult,\n\tRepositoryCloseEvent,\n\tRepositoryInitWatcher,\n\tRepositoryOpenEvent,\n\tRevisionUriData,\n\tScmRepository,\n} from '../../../git/gitProvider';\nimport { GitProviderId, RepositoryVisibility } from '../../../git/gitProvider';\nimport { encodeGitLensRevisionUriAuthority, GitUri } from '../../../git/gitUri';\nimport type { GitBlame, GitBlameAuthor, GitBlameLine, GitBlameLines } from '../../../git/models/blame';\nimport type { BranchSortOptions } from '../../../git/models/branch';\nimport {\n\tgetBranchId,\n\tgetBranchNameWithoutRemote,\n\tgetRemoteNameFromBranchName,\n\tGitBranch,\n\tisDetachedHead,\n\tsortBranches,\n} from '../../../git/models/branch';\nimport type { GitStashCommit } from '../../../git/models/commit';\nimport { GitCommit, GitCommitIdentity } from '../../../git/models/commit';\nimport { deletedOrMissing, uncommitted, uncommittedStaged } from '../../../git/models/constants';\nimport { GitContributor } from '../../../git/models/contributor';\nimport type { GitDiff, GitDiffFilter, GitDiffHunkLine, GitDiffShortStat } from '../../../git/models/diff';\nimport type { GitFile, GitFileStatus } from '../../../git/models/file';\nimport { GitFileChange } from '../../../git/models/file';\nimport type {\n\tGitGraph,\n\tGitGraphRow,\n\tGitGraphRowContexts,\n\tGitGraphRowHead,\n\tGitGraphRowRemoteHead,\n\tGitGraphRowTag,\n} from '../../../git/models/graph';\nimport { GitGraphRowType } from '../../../git/models/graph';\nimport type { GitLog } from '../../../git/models/log';\nimport type { GitMergeStatus } from '../../../git/models/merge';\nimport type { GitRebaseStatus } from '../../../git/models/rebase';\nimport type { GitBranchReference } from '../../../git/models/reference';\nimport {\n\tcreateReference,\n\tgetReferenceFromBranch,\n\tisBranchReference,\n\tisRevisionRange,\n\tisSha,\n\tisShaLike,\n\tisUncommitted,\n\tisUncommittedStaged,\n\tshortenRevision,\n} from '../../../git/models/reference';\nimport type { GitReflog } from '../../../git/models/reflog';\nimport { getRemoteIconUri, getVisibilityCacheKey, GitRemote } from '../../../git/models/remote';\nimport { RemoteResourceType } from '../../../git/models/remoteResource';\nimport type { RepositoryChangeEvent } from '../../../git/models/repository';\nimport { Repository, RepositoryChange, RepositoryChangeComparisonMode } from '../../../git/models/repository';\nimport type { GitStash } from '../../../git/models/stash';\nimport type { GitStatusFile } from '../../../git/models/status';\nimport { GitStatus } from '../../../git/models/status';\nimport type { GitTag, TagSortOptions } from '../../../git/models/tag';\nimport { getTagId, sortTags } from '../../../git/models/tag';\nimport type { GitTreeEntry } from '../../../git/models/tree';\nimport type { GitUser } from '../../../git/models/user';\nimport { isUserMatch } from '../../../git/models/user';\nimport type { GitWorktree } from '../../../git/models/worktree';\nimport { GitBlameParser } from '../../../git/parsers/blameParser';\nimport { GitBranchParser } from '../../../git/parsers/branchParser';\nimport { GitDiffParser } from '../../../git/parsers/diffParser';\nimport {\n\tcreateLogParserSingle,\n\tcreateLogParserWithFiles,\n\tgetContributorsParser,\n\tgetGraphParser,\n\tgetRefAndDateParser,\n\tgetRefParser,\n\tGitLogParser,\n\tLogType,\n} from '../../../git/parsers/logParser';\nimport { GitReflogParser } from '../../../git/parsers/reflogParser';\nimport { GitRemoteParser } from '../../../git/parsers/remoteParser';\nimport { GitStatusParser } from '../../../git/parsers/statusParser';\nimport { GitTagParser } from '../../../git/parsers/tagParser';\nimport { GitTreeParser } from '../../../git/parsers/treeParser';\nimport { GitWorktreeParser } from '../../../git/parsers/worktreeParser';\nimport type { RemoteProviders } from '../../../git/remotes/remoteProviders';\nimport { getRemoteProviderMatcher, loadRemoteProviders } from '../../../git/remotes/remoteProviders';\nimport type { GitSearch, GitSearchResultData, GitSearchResults, SearchQuery } from '../../../git/search';\nimport { getGitArgsFromSearchQuery, getSearchQueryComparisonKey } from '../../../git/search';\nimport {\n\tshowGenericErrorMessage,\n\tshowGitDisabledErrorMessage,\n\tshowGitInvalidConfigErrorMessage,\n\tshowGitMissingErrorMessage,\n\tshowGitVersionUnsupportedErrorMessage,\n} from '../../../messages';\nimport type {\n\tGraphBranchContextValue,\n\tGraphItemContext,\n\tGraphItemRefContext,\n\tGraphItemRefGroupContext,\n\tGraphTagContextValue,\n} from '../../../plus/webviews/graph/protocol';\nimport { countStringLength, filterMap } from '../../../system/array';\nimport { TimedCancellationSource } from '../../../system/cancellation';\nimport { configuration } from '../../../system/configuration';\nimport { gate } from '../../../system/decorators/gate';\nimport { debug, log } from '../../../system/decorators/log';\nimport { debounce } from '../../../system/function';\nimport { filterMap as filterMapIterable, find, first, join, last, map, some } from '../../../system/iterable';\nimport { Logger } from '../../../system/logger';\nimport type { LogScope } from '../../../system/logger.scope';\nimport { getLogScope } from '../../../system/logger.scope';\nimport {\n\tcommonBaseIndex,\n\tdirname,\n\tgetBestPath,\n\tisAbsolute,\n\tisFolderGlob,\n\tjoinPaths,\n\tmaybeUri,\n\tnormalizePath,\n\trelative,\n\tsplitPath,\n} from '../../../system/path';\nimport type { PromiseOrValue } from '../../../system/promise';\nimport { any, asSettled, getSettledValue } from '../../../system/promise';\nimport { equalsIgnoreCase, getDurationMilliseconds, interpolate, splitSingle } from '../../../system/string';\nimport { PathTrie } from '../../../system/trie';\nimport { compare, fromString } from '../../../system/version';\nimport { serializeWebviewItemContext } from '../../../system/webview';\nimport type { CachedBlame, CachedDiff, CachedLog, TrackedDocument } from '../../../trackers/gitDocumentTracker';\nimport { GitDocumentState } from '../../../trackers/gitDocumentTracker';\nimport type { Git } from './git';\nimport {\n\tgetShaInLogRegex,\n\tGitErrors,\n\tgitLogDefaultConfigs,\n\tgitLogDefaultConfigsWithFiles,\n\tmaxGitCliLength,\n} from './git';\nimport type { GitLocation } from './locator';\nimport { findGitPath, InvalidGitConfigError, UnableToFindGitError } from './locator';\nimport { CancelledRunError, fsExists, RunError } from './shell';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyPromise: Promise<GitBlame | GitDiff | GitLog | undefined> = Promise.resolve(undefined);\nconst emptyPagedResult: PagedResult<any> = Object.freeze({ values: [] });\nconst slash = 47;\n\nconst RepoSearchWarnings = {\n\tdoesNotExist: /no such file or directory/i,\n};\n\nconst driveLetterRegex = /(?<=^\\/?)([a-zA-Z])(?=:\\/)/;\nconst userConfigRegex = /^user\\.(name|email) (.*)$/gm;\nconst mappedAuthorRegex = /(.+)\\s<(.+)>/;\nconst stashSummaryRegex =\n\t/(?:(?:(?<wip>WIP) on|On) (?<onref>[^/](?!.*\\/\\.)(?!.*\\.\\.)(?!.*\\/\\/)(?!.*@\\{)[^\\000-\\037\\177 ~^:?*[\\\\]+[^./]):\\s*)?(?<summary>.*)$/s;\n\nconst reflogCommands = ['merge', 'pull'];\n\ninterface RepositoryInfo {\n\tgitDir?: GitDir;\n\tuser?: GitUser | null;\n}\n\nexport class LocalGitProvider implements GitProvider, Disposable {\n\treadonly descriptor: GitProviderDescriptor = { id: GitProviderId.Git, name: 'Git', virtual: false };\n\treadonly supportedSchemes: Set<string> = new Set([\n\t\tSchemes.File,\n\t\tSchemes.Git,\n\t\tSchemes.GitLens,\n\t\tSchemes.PRs,\n\t\t// DocumentSchemes.Vsls,\n\t]);\n\n\tprivate _onDidChangeRepository = new EventEmitter<RepositoryChangeEvent>();\n\tget onDidChangeRepository(): Event<RepositoryChangeEvent> {\n\t\treturn this._onDidChangeRepository.event;\n\t}\n\n\tprivate _onDidCloseRepository = new EventEmitter<RepositoryCloseEvent>();\n\tget onDidCloseRepository(): Event<RepositoryCloseEvent> {\n\t\treturn this._onDidCloseRepository.event;\n\t}\n\n\tprivate _onDidOpenRepository = new EventEmitter<RepositoryOpenEvent>();\n\tget onDidOpenRepository(): Event<RepositoryOpenEvent> {\n\t\treturn this._onDidOpenRepository.event;\n\t}\n\n\tprivate readonly _branchesCache = new Map<string, Promise<PagedResult<GitBranch>>>();\n\tprivate readonly _contributorsCache = new Map<string, Promise<GitContributor[]>>();\n\tprivate readonly _mergeStatusCache = new Map<string, GitMergeStatus | null>();\n\tprivate readonly _rebaseStatusCache = new Map<string, GitRebaseStatus | null>();\n\tprivate readonly _repoInfoCache = new Map<string, RepositoryInfo>();\n\tprivate readonly _stashesCache = new Map<string, GitStash | null>();\n\tprivate readonly _tagsCache = new Map<string, Promise<PagedResult<GitTag>>>();\n\tprivate readonly _trackedPaths = new PathTrie<PromiseOrValue<[string, string] | undefined>>();\n\n\tprivate _disposables: Disposable[] = [];\n\n\tconstructor(protected readonly container: Container, protected readonly git: Git) {\n\t\tthis.git.setLocator(this.ensureGit.bind(this));\n\n\t\tthis._disposables.push(\n\t\t\tthis.container.events.on('git:cache:reset', e =>\n\t\t\t\te.data.repoPath\n\t\t\t\t\t? this.resetCache(e.data.repoPath, ...(e.data.caches ?? emptyArray))\n\t\t\t\t\t: this.resetCaches(...(e.data.caches ?? emptyArray)),\n\t\t\t),\n\t\t);\n\t}\n\n\tdispose() {\n\t\tDisposable.from(...this._disposables).dispose();\n\t}\n\n\tprivate get useCaching() {\n\t\treturn configuration.get('advanced.caching.enabled');\n\t}\n\n\tprivate onRepositoryChanged(repo: Repository, e: RepositoryChangeEvent) {\n\t\tif (e.changed(RepositoryChange.Config, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._repoInfoCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Heads, RepositoryChange.Remotes, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._branchesCache.delete(repo.path);\n\t\t\tthis._contributorsCache.delete(repo.path);\n\t\t\tthis._contributorsCache.delete(`stats|${repo.path}`);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Index, RepositoryChange.Unknown, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._trackedPaths.clear();\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Merge, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._mergeStatusCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Rebase, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._rebaseStatusCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Stash, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._stashesCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Tags, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._tagsCache.delete(repo.path);\n\t\t}\n\n\t\tthis._onDidChangeRepository.fire(e);\n\t}\n\n\tprivate _gitLocator: Promise<GitLocation> | undefined;\n\tprivate async ensureGit(): Promise<GitLocation> {\n\t\tif (this._gitLocator == null) {\n\t\t\tthis._gitLocator = this.findGit();\n\t\t}\n\n\t\treturn this._gitLocator;\n\t}\n\n\t@log()\n\tprivate async findGit(): Promise<GitLocation> {\n\t\tconst scope = getLogScope();\n\n\t\tif (!configuration.getAny<CoreGitConfiguration, boolean>('git.enabled', null, true)) {\n\t\t\tLogger.log(scope, 'Built-in Git is disabled (\"git.enabled\": false)');\n\t\t\tvoid showGitDisabledErrorMessage();\n\n\t\t\tthrow new UnableToFindGitError();\n\t\t}\n\n\t\tconst scmGitPromise = this.getScmGitApi();\n\n\t\tasync function subscribeToScmOpenCloseRepository(this: LocalGitProvider) {\n\t\t\tconst scmGit = await scmGitPromise;\n\t\t\tif (scmGit == null) return;\n\n\t\t\tthis._disposables.push(\n\t\t\t\t// Since we will get \"close\" events for repos when vscode is shutting down, debounce the event so ensure we aren't shutting down\n\t\t\t\tscmGit.onDidCloseRepository(\n\t\t\t\t\tdebounce(e => {\n\t\t\t\t\t\tif (this.container.deactivating) return;\n\t\t\t\t\t\tthis._onDidCloseRepository.fire({ uri: e.rootUri });\n\t\t\t\t\t}, 1000),\n\t\t\t\t),\n\t\t\t\tscmGit.onDidOpenRepository(e => this._onDidOpenRepository.fire({ uri: e.rootUri })),\n\t\t\t);\n\n\t\t\tfor (const scmRepository of scmGit.repositories) {\n\t\t\t\tthis._onDidOpenRepository.fire({ uri: scmRepository.rootUri });\n\t\t\t}\n\t\t}\n\t\tvoid subscribeToScmOpenCloseRepository.call(this);\n\n\t\tconst potentialGitPaths =\n\t\t\tconfiguration.getAny<CoreGitConfiguration, string | string[]>('git.path') ??\n\t\t\tthis.container.storage.getWorkspace('gitPath');\n\n\t\tconst start = hrtime();\n\n\t\tconst findGitPromise = findGitPath(potentialGitPaths);\n\t\t// Try to use the same git as the built-in vscode git extension, but don't wait for it if we find something faster\n\t\tconst findGitFromSCMPromise = scmGitPromise.then(gitApi => {\n\t\t\tconst path = gitApi?.git.path;\n\t\t\tif (!path) return findGitPromise;\n\n\t\t\tif (potentialGitPaths != null) {\n\t\t\t\tif (typeof potentialGitPaths === 'string') {\n\t\t\t\t\tif (path === potentialGitPaths) return findGitPromise;\n\t\t\t\t} else if (potentialGitPaths.includes(path)) {\n\t\t\t\t\treturn findGitPromise;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn findGitPath(path, false);\n\t\t});\n\n\t\tconst location = await any<GitLocation>(findGitPromise, findGitFromSCMPromise);\n\t\t// Save the found git path, but let things settle first to not impact startup performance\n\t\tsetTimeout(() => void this.container.storage.storeWorkspace('gitPath', location.path), 1000);\n\n\t\tif (scope != null) {\n\t\t\tscope.exitDetails = ` ${GlyphChars.Dot} Git (${location.version}) found in ${\n\t\t\t\tlocation.path === 'git' ? 'PATH' : location.path\n\t\t\t}`;\n\t\t} else {\n\t\t\tLogger.log(\n\t\t\t\tscope,\n\t\t\t\t`Git (${location.version}) found in ${\n\t\t\t\t\tlocation.path === 'git' ? 'PATH' : location.path\n\t\t\t\t} [${getDurationMilliseconds(start)}ms]`,\n\t\t\t);\n\t\t}\n\n\t\t// Warn if git is less than v2.7.2\n\t\tif (compare(fromString(location.version), fromString('2.7.2')) === -1) {\n\t\t\tLogger.log(scope, `Git version (${location.version}) is outdated`);\n\t\t\tvoid showGitVersionUnsupportedErrorMessage(location.version, '2.7.2');\n\t\t}\n\n\t\treturn location;\n\t}\n\n\t@debug({ exit: true })\n\tasync discoverRepositories(uri: Uri): Promise<Repository[]> {\n\t\tif (uri.scheme !== Schemes.File) return [];\n\n\t\ttry {\n\t\t\tconst autoRepositoryDetection =\n\t\t\t\tconfiguration.getAny<CoreGitConfiguration, boolean | 'subFolders' | 'openEditors'>(\n\t\t\t\t\t'git.autoRepositoryDetection',\n\t\t\t\t) ?? true;\n\n\t\t\tconst folder = workspace.getWorkspaceFolder(uri);\n\t\t\tif (folder == null) return [];\n\n\t\t\tvoid (await this.ensureGit());\n\n\t\t\tconst repositories = await this.repositorySearch(\n\t\t\t\tfolder,\n\t\t\t\tautoRepositoryDetection === false || autoRepositoryDetection === 'openEditors' ? 0 : undefined,\n\t\t\t);\n\n\t\t\tif (autoRepositoryDetection === true || autoRepositoryDetection === 'subFolders') {\n\t\t\t\tfor (const repository of repositories) {\n\t\t\t\t\tvoid this.openScmRepository(repository.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repositories.length > 0) {\n\t\t\t\tthis._trackedPaths.clear();\n\t\t\t}\n\n\t\t\treturn repositories;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof InvalidGitConfigError) {\n\t\t\t\tvoid showGitInvalidConfigErrorMessage();\n\t\t\t} else if (ex instanceof UnableToFindGitError) {\n\t\t\t\tvoid showGitMissingErrorMessage();\n\t\t\t} else {\n\t\t\t\tconst msg: string = ex?.message ?? '';\n\t\t\t\tif (msg) {\n\t\t\t\t\tvoid window.showErrorMessage(`Unable to initialize Git; ${msg}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t@debug({ exit: true })\n\topenRepository(\n\t\tfolder: WorkspaceFolder | undefined,\n\t\turi: Uri,\n\t\troot: boolean,\n\t\tsuspended?: boolean,\n\t\tclosed?: boolean,\n\t): Repository[] {\n\t\tif (!closed) {\n\t\t\tvoid this.openScmRepository(uri);\n\t\t}\n\n\t\t// Add a closed (hidden) repository for the canonical version\n\t\tconst canonicalUri = this.toCanonicalMap.get(getBestPath(uri));\n\t\tif (canonicalUri != null) {\n\t\t\treturn [\n\t\t\t\tnew Repository(\n\t\t\t\t\tthis.container,\n\t\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\t\tthis.descriptor,\n\t\t\t\t\tfolder,\n\t\t\t\t\turi,\n\t\t\t\t\troot,\n\t\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\t\tclosed,\n\t\t\t\t\t// canonicalUri,\n\t\t\t\t),\n\t\t\t\tnew Repository(\n\t\t\t\t\tthis.container,\n\t\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\t\tthis.descriptor,\n\t\t\t\t\tfolder,\n\t\t\t\t\tcanonicalUri,\n\t\t\t\t\troot,\n\t\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\t\ttrue,\n\t\t\t\t\t// uri,\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\treturn [\n\t\t\tnew Repository(\n\t\t\t\tthis.container,\n\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\tthis.descriptor,\n\t\t\t\tfolder,\n\t\t\t\turi,\n\t\t\t\troot,\n\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\tclosed,\n\t\t\t),\n\t\t];\n\t}\n\n\t@debug()\n\topenRepositoryInitWatcher(): RepositoryInitWatcher {\n\t\tconst watcher = workspace.createFileSystemWatcher('**/.git', false, true, true);\n\t\treturn {\n\t\t\tonDidCreate: watcher.onDidCreate,\n\t\t\tdispose: () => void watcher.dispose(),\n\t\t};\n\t}\n\n\tprivate _supportedFeatures = new Map<Features, boolean>();\n\tasync supports(feature: Features): Promise<boolean> {\n\t\tlet supported = this._supportedFeatures.get(feature);\n\t\tif (supported != null) return supported;\n\n\t\tswitch (feature) {\n\t\t\tcase Features.Worktrees:\n\t\t\t\tsupported = await this.git.isAtLeastVersion('2.17.0');\n\t\t\t\tthis._supportedFeatures.set(feature, supported);\n\t\t\t\treturn supported;\n\t\t\tcase Features.StashOnlyStaged:\n\t\t\t\tsupported = await this.git.isAtLeastVersion('2.35.0');\n\t\t\t\tthis._supportedFeatures.set(feature, supported);\n\t\t\t\treturn supported;\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t@debug<LocalGitProvider['visibility']>({ exit: r => `returned ${r[0]}` })\n\tasync visibility(repoPath: string): Promise<[visibility: RepositoryVisibility, cacheKey: string | undefined]> {\n\t\tconst remotes = await this.getRemotes(repoPath, { sort: true });\n\t\tif (remotes.length === 0) return [RepositoryVisibility.Local, undefined];\n\n\t\tlet local = true;\n\t\tfor await (const result of asSettled(remotes.map(r => this.getRemoteVisibility(r)))) {\n\t\t\tif (result.status !== 'fulfilled') continue;\n\n\t\t\tif (result.value[0] === RepositoryVisibility.Public) {\n\t\t\t\treturn [RepositoryVisibility.Public, getVisibilityCacheKey(result.value[1])];\n\t\t\t}\n\t\t\tif (result.value[0] !== RepositoryVisibility.Local) {\n\t\t\t\tlocal = false;\n\t\t\t}\n\t\t}\n\n\t\treturn local\n\t\t\t? [RepositoryVisibility.Local, undefined]\n\t\t\t: [RepositoryVisibility.Private, getVisibilityCacheKey(remotes)];\n\t}\n\n\t@debug<LocalGitProvider['getRemoteVisibility']>({ args: { 0: r => r.url }, exit: r => `returned ${r[0]}` })\n\tprivate async getRemoteVisibility(\n\t\tremote: GitRemote,\n\t): Promise<[visibility: RepositoryVisibility, remote: GitRemote]> {\n\t\tconst scope = getLogScope();\n\n\t\tswitch (remote.provider?.id) {\n\t\t\tcase 'github':\n\t\t\tcase 'gitlab':\n\t\t\tcase 'bitbucket':\n\t\t\tcase 'azure-devops':\n\t\t\tcase 'gitea':\n\t\t\tcase 'gerrit':\n\t\t\tcase 'google-source': {\n\t\t\t\tconst url = remote.provider.url({ type: RemoteResourceType.Repo });\n\t\t\t\tif (url == null) return [RepositoryVisibility.Private, remote];\n\n\t\t\t\t// Check if the url returns a 200 status code\n\t\t\t\ttry {\n\t\t\t\t\tconst rsp = await fetch(url, { method: 'HEAD', agent: getProxyAgent() });\n\t\t\t\t\tif (rsp.ok) return [RepositoryVisibility.Public, remote];\n\n\t\t\t\t\tLogger.debug(scope, `Response=${rsp.status}`);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tLogger.error(ex, scope);\n\t\t\t\t}\n\t\t\t\treturn [RepositoryVisibility.Private, remote];\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn maybeUri(remote.url)\n\t\t\t\t\t? [RepositoryVisibility.Private, remote]\n\t\t\t\t\t: [RepositoryVisibility.Local, remote];\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['repositorySearch']>({\n\t\targs: false,\n\t\tsingleLine: true,\n\t\tprefix: (context, folder) => `${context.prefix}(${folder.uri.fsPath})`,\n\t\texit: r => `returned ${r.length} repositories ${r.length !== 0 ? Logger.toLoggable(r) : ''}`,\n\t})\n\tprivate async repositorySearch(folder: WorkspaceFolder, depth?: number): Promise<Repository[]> {\n\t\tconst scope = getLogScope();\n\t\tdepth =\n\t\t\tdepth ??\n\t\t\tconfiguration.get('advanced.repositorySearchDepth', folder.uri) ??\n\t\t\tconfiguration.getAny<CoreGitConfiguration, number>('git.repositoryScanMaxDepth', folder.uri, 1);\n\n\t\tLogger.log(scope, `searching (depth=${depth})...`);\n\n\t\tconst repositories: Repository[] = [];\n\n\t\tlet rootPath;\n\t\tlet canonicalRootPath;\n\n\t\tconst uri = await this.findRepositoryUri(folder.uri, true);\n\t\tif (uri != null) {\n\t\t\trootPath = normalizePath(uri.fsPath);\n\n\t\t\tconst canonicalUri = this.toCanonicalMap.get(getBestPath(uri));\n\t\t\tif (canonicalUri != null) {\n\t\t\t\tcanonicalRootPath = normalizePath(canonicalUri.fsPath);\n\t\t\t}\n\n\t\t\tLogger.log(scope, `found root repository in '${uri.fsPath}'`);\n\t\t\trepositories.push(...this.openRepository(folder, uri, true));\n\t\t}\n\n\t\tif (depth <= 0) return repositories;\n\n\t\t// Get any specified excludes -- this is a total hack, but works for some simple cases and something is better than nothing :)\n\t\tconst excludes = new Set<string>(\n\t\t\tconfiguration.getAny<CoreGitConfiguration, string[]>('git.repositoryScanIgnoredFolders', folder.uri, []),\n\t\t);\n\t\tfor (let [key, value] of Object.entries({\n\t\t\t...configuration.getAny<CoreConfiguration, Record<string, boolean>>('files.exclude', folder.uri, {}),\n\t\t\t...configuration.getAny<CoreConfiguration, Record<string, boolean>>('search.exclude', folder.uri, {}),\n\t\t})) {\n\t\t\tif (!value) continue;\n\t\t\tif (key.includes('*.')) continue;\n\n\t\t\tif (key.startsWith('**/')) {\n\t\t\t\tkey = key.substring(3);\n\t\t\t}\n\t\t\texcludes.add(key);\n\t\t}\n\n\t\tlet repoPaths;\n\t\ttry {\n\t\t\trepoPaths = await this.repositorySearchCore(folder.uri.fsPath, depth, excludes);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (RepoSearchWarnings.doesNotExist.test(msg)) {\n\t\t\t\tLogger.log(scope, `FAILED${msg ? ` Error: ${msg}` : ''}`);\n\t\t\t} else {\n\t\t\t\tLogger.error(ex, scope, 'FAILED');\n\t\t\t}\n\n\t\t\treturn repositories;\n\t\t}\n\n\t\tfor (let p of repoPaths) {\n\t\t\tp = dirname(p);\n\t\t\tconst normalized = normalizePath(p);\n\n\t\t\t// If we are the same as the root, skip it\n\t\t\tif (\n\t\t\t\t(isLinux &&\n\t\t\t\t\t(normalized === rootPath || (canonicalRootPath != null && normalized === canonicalRootPath))) ||\n\t\t\t\tequalsIgnoreCase(normalized, rootPath) ||\n\t\t\t\t(canonicalRootPath != null && equalsIgnoreCase(normalized, canonicalRootPath))\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLogger.log(scope, `searching in '${p}'...`);\n\t\t\tLogger.debug(\n\t\t\t\tscope,\n\t\t\t\t`normalizedRepoPath=${normalized}, rootPath=${rootPath}, canonicalRootPath=${canonicalRootPath}`,\n\t\t\t);\n\n\t\t\tconst rp = await this.findRepositoryUri(Uri.file(p), true);\n\t\t\tif (rp == null) continue;\n\n\t\t\tLogger.log(scope, `found repository in '${rp.fsPath}'`);\n\t\t\trepositories.push(...this.openRepository(folder, rp, false));\n\t\t}\n\n\t\treturn repositories;\n\t}\n\n\t@debug<LocalGitProvider['repositorySearchCore']>({ args: { 2: false, 3: false }, exit: true })\n\tprivate repositorySearchCore(\n\t\troot: string,\n\t\tdepth: number,\n\t\texcludes: Set<string>,\n\t\trepositories: string[] = [],\n\t): Promise<string[]> {\n\t\tconst scope = getLogScope();\n\n\t\treturn new Promise<string[]>((resolve, reject) => {\n\t\t\treaddir(root, { withFileTypes: true }, async (err, files) => {\n\t\t\t\tif (err != null) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (files.length === 0) {\n\t\t\t\t\tresolve(repositories);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdepth--;\n\n\t\t\t\tlet f;\n\t\t\t\tfor (f of files) {\n\t\t\t\t\tif (f.name === '.git') {\n\t\t\t\t\t\trepositories.push(resolvePath(root, f.name));\n\t\t\t\t\t} else if (depth >= 0 && f.isDirectory() && !excludes.has(f.name)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.repositorySearchCore(resolvePath(root, f.name), depth, excludes, repositories);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tLogger.error(ex, scope, 'FAILED');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresolve(repositories);\n\t\t\t});\n\t\t});\n\t}\n\n\tcanHandlePathOrUri(scheme: string, pathOrUri: string | Uri): string | undefined {\n\t\tif (!this.supportedSchemes.has(scheme)) return undefined;\n\t\treturn getBestPath(pathOrUri);\n\t}\n\n\tgetAbsoluteUri(pathOrUri: string | Uri, base: string | Uri): Uri {\n\t\t// Convert the base to a Uri if it isn't one\n\t\tif (typeof base === 'string') {\n\t\t\t// If it looks like a Uri parse it\n\t\t\tif (maybeUri(base)) {\n\t\t\t\tbase = Uri.parse(base, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(base)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t`Unable to get absolute uri between ${\n\t\t\t\t\t\t\ttypeof pathOrUri === 'string' ? pathOrUri : pathOrUri.toString(true)\n\t\t\t\t\t\t} and ${base}; Base path '${base}' must be an absolute path`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Base path '${base}' must be an absolute path`);\n\t\t\t\t}\n\n\t\t\t\tbase = Uri.file(base);\n\t\t\t}\n\t\t}\n\n\t\t// Short-circuit if the path is relative\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tconst normalized = normalizePath(pathOrUri);\n\t\t\tif (!isAbsolute(normalized)) return Uri.joinPath(base, normalized);\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, base);\n\t\treturn Uri.joinPath(base, relativePath);\n\t}\n\n\t@log({ exit: true })\n\tasync getBestRevisionUri(repoPath: string, path: string, ref: string | undefined): Promise<Uri | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\t// TODO@eamodio Align this with isTrackedCore?\n\t\tif (!ref || (isUncommitted(ref) && !isUncommittedStaged(ref))) {\n\t\t\t// Make sure the file exists in the repo\n\t\t\tlet data = await this.git.ls_files(repoPath, path);\n\t\t\tif (data != null) return this.getAbsoluteUri(path, repoPath);\n\n\t\t\t// Check if the file exists untracked\n\t\t\tdata = await this.git.ls_files(repoPath, path, { untracked: true });\n\t\t\tif (data != null) return this.getAbsoluteUri(path, repoPath);\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (isUncommittedStaged(ref)) return this.getScmGitUri(path, repoPath);\n\n\t\treturn this.getRevisionUri(repoPath, path, ref);\n\t}\n\n\tgetRelativePath(pathOrUri: string | Uri, base: string | Uri): string {\n\t\t// Convert the base to a Uri if it isn't one\n\t\tif (typeof base === 'string') {\n\t\t\t// If it looks like a Uri parse it\n\t\t\tif (maybeUri(base)) {\n\t\t\t\tbase = Uri.parse(base, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(base)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t`Unable to get relative path between ${\n\t\t\t\t\t\t\ttypeof pathOrUri === 'string' ? pathOrUri : pathOrUri.toString(true)\n\t\t\t\t\t\t} and ${base}; Base path '${base}' must be an absolute path`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Base path '${base}' must be an absolute path`);\n\t\t\t\t}\n\n\t\t\t\tbase = Uri.file(base);\n\t\t\t}\n\t\t}\n\n\t\t// Convert the path to a Uri if it isn't one\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (maybeUri(pathOrUri)) {\n\t\t\t\tpathOrUri = Uri.parse(pathOrUri, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(pathOrUri)) return normalizePath(pathOrUri);\n\n\t\t\t\tpathOrUri = Uri.file(pathOrUri);\n\t\t\t}\n\t\t}\n\n\t\tconst relativePath = relative(base.fsPath, pathOrUri.fsPath);\n\t\treturn normalizePath(relativePath);\n\t}\n\n\tgetRevisionUri(repoPath: string, path: string, ref: string): Uri {\n\t\tif (isUncommitted(ref)) {\n\t\t\treturn isUncommittedStaged(ref) ? this.getScmGitUri(path, repoPath) : this.getAbsoluteUri(path, repoPath);\n\t\t}\n\n\t\tpath = normalizePath(this.getAbsoluteUri(path, repoPath).fsPath);\n\t\tif (path.charCodeAt(0) !== slash) {\n\t\t\tpath = `/${path}`;\n\t\t}\n\n\t\tconst metadata: RevisionUriData = {\n\t\t\tref: ref,\n\t\t\trepoPath: normalizePath(repoPath),\n\t\t};\n\n\t\tconst uri = Uri.from({\n\t\t\tscheme: Schemes.GitLens,\n\t\t\tauthority: encodeGitLensRevisionUriAuthority(metadata),\n\t\t\tpath: path,\n\t\t\tquery: ref ? JSON.stringify({ ref: shortenRevision(ref) }) : undefined,\n\t\t});\n\t\treturn uri;\n\t}\n\n\t@log({ exit: true })\n\tasync getWorkingUri(repoPath: string, uri: Uri) {\n\t\tlet relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tlet data;\n\t\tlet ref;\n\t\tdo {\n\t\t\tdata = await this.git.ls_files(repoPath, relativePath);\n\t\t\tif (data != null) {\n\t\t\t\trelativePath = splitSingle(data, '\\n')[0];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// TODO: Add caching\n\n\t\t\tconst cfg = configuration.get('advanced');\n\n\t\t\t// Get the most recent commit for this file name\n\t\t\tref = await this.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\tordering: cfg.commitOrdering,\n\t\t\t\tsimilarityThreshold: cfg.similarityThreshold,\n\t\t\t});\n\t\t\tif (ref == null) return undefined;\n\n\t\t\t// Now check if that commit had any renames\n\t\t\tdata = await this.git.log__file(repoPath, '.', ref, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfilters: ['R', 'C', 'D'],\n\t\t\t\tlimit: 1,\n\t\t\t\tordering: cfg.commitOrdering,\n\t\t\t});\n\t\t\tif (data == null || data.length === 0) break;\n\n\t\t\tconst [foundRef, foundFile, foundStatus] = GitLogParser.parseSimpleRenamed(data, relativePath);\n\t\t\tif (foundStatus === 'D' && foundFile != null) return undefined;\n\t\t\tif (foundRef == null || foundFile == null) break;\n\n\t\t\trelativePath = foundFile;\n\t\t} while (true);\n\n\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\treturn (await fsExists(uri.fsPath)) ? uri : undefined;\n\t}\n\n\t@log()\n\tasync addRemote(repoPath: string, name: string, url: string, options?: { fetch?: boolean }): Promise<void> {\n\t\tawait this.git.remote__add(repoPath, name, url, options);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync pruneRemote(repoPath: string, name: string): Promise<void> {\n\t\tawait this.git.remote__prune(repoPath, name);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync removeRemote(repoPath: string, name: string): Promise<void> {\n\t\tawait this.git.remote__remove(repoPath, name);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync applyChangesToWorkingFile(uri: GitUri, ref1?: string, ref2?: string) {\n\t\tconst scope = getLogScope();\n\n\t\tref1 = ref1 ?? uri.sha;\n\t\tif (ref1 == null || uri.repoPath == null) return;\n\n\t\tif (ref2 == null) {\n\t\t\tref2 = ref1;\n\t\t\tref1 = `${ref1}^`;\n\t\t}\n\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\tlet patch;\n\t\ttry {\n\t\t\tpatch = await this.git.diff(root, relativePath, ref1, ref2);\n\t\t\tvoid (await this.git.apply(root, patch));\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (patch && /patch does not apply/i.test(msg)) {\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to apply changes cleanly. Retry and allow conflicts?',\n\t\t\t\t\t{ title: 'Yes' },\n\t\t\t\t\t{ title: 'No', isCloseAffordance: true },\n\t\t\t\t);\n\n\t\t\t\tif (result == null || result.title !== 'Yes') return;\n\n\t\t\t\tif (result.title === 'Yes') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvoid (await this.git.apply(root, patch, { allowConflicts: true }));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// eslint-disable-next-line no-ex-assign\n\t\t\t\t\t\tex = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tvoid showGenericErrorMessage('Unable to apply changes');\n\t\t}\n\t}\n\n\t@log()\n\tasync checkout(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { createBranch?: string } | { path?: string },\n\t): Promise<void> {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tawait this.git.checkout(repoPath, ref, options);\n\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['branches', 'status'] });\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (/overwritten by checkout/i.test(msg)) {\n\t\t\t\tvoid showGenericErrorMessage(\n\t\t\t\t\t`Unable to checkout '${ref}'. Please commit or stash your changes before switching branches`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tvoid showGenericErrorMessage(`Unable to checkout '${ref}'`);\n\t\t}\n\t}\n\n\t@log({ singleLine: true })\n\tprivate resetCache(\n\t\trepoPath: string,\n\t\t...caches: ('branches' | 'contributors' | 'providers' | 'remotes' | 'stashes' | 'status' | 'tags')[]\n\t) {\n\t\tif (caches.length === 0 || caches.includes('branches')) {\n\t\t\tthis._branchesCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('contributors')) {\n\t\t\tthis._contributorsCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('stashes')) {\n\t\t\tthis._stashesCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('status')) {\n\t\t\tthis._mergeStatusCache.delete(repoPath);\n\t\t\tthis._rebaseStatusCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('tags')) {\n\t\t\tthis._tagsCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0) {\n\t\t\tthis._trackedPaths.delete(repoPath);\n\t\t\tthis._repoInfoCache.delete(repoPath);\n\t\t}\n\t}\n\n\t@log({ singleLine: true })\n\tprivate resetCaches(...caches: GitCaches[]) {\n\t\tif (caches.length === 0 || caches.includes('branches')) {\n\t\t\tthis._branchesCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('contributors')) {\n\t\t\tthis._contributorsCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('stashes')) {\n\t\t\tthis._stashesCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('status')) {\n\t\t\tthis._mergeStatusCache.clear();\n\t\t\tthis._rebaseStatusCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('tags')) {\n\t\t\tthis._tagsCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0) {\n\t\t\tthis._trackedPaths.clear();\n\t\t\tthis._repoInfoCache.clear();\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['excludeIgnoredUris']>({ args: { 1: uris => uris.length } })\n\tasync excludeIgnoredUris(repoPath: string, uris: Uri[]): Promise<Uri[]> {\n\t\tconst paths = new Map<string, Uri>(uris.map(u => [normalizePath(u.fsPath), u]));\n\n\t\tconst data = await this.git.check_ignore(repoPath, ...paths.keys());\n\t\tif (data == null) return uris;\n\n\t\tconst ignored = data.split('\\0').filter(<T>(i?: T): i is T => Boolean(i));\n\t\tif (ignored.length === 0) return uris;\n\n\t\tfor (const file of ignored) {\n\t\t\tpaths.delete(file);\n\t\t}\n\n\t\treturn [...paths.values()];\n\t}\n\n\t@gate()\n\t@log()\n\tasync fetch(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; branch?: GitBranchReference; prune?: boolean; pull?: boolean; remote?: string },\n\t): Promise<void> {\n\t\tconst { branch: branchRef, ...opts } = options ?? {};\n\t\tif (isBranchReference(branchRef)) {\n\t\t\tconst repo = this.container.git.getRepository(repoPath);\n\t\t\tconst branch = await repo?.getBranch(branchRef?.name);\n\t\t\tif (!branch?.remote && branch?.upstream == null) return undefined;\n\n\t\t\tawait this.git.fetch(repoPath, {\n\t\t\t\tbranch: branch.getNameWithoutRemote(),\n\t\t\t\tremote: branch.getRemoteName()!,\n\t\t\t\tupstream: branch.getTrackingWithoutRemote()!,\n\t\t\t\tpull: options?.pull,\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.git.fetch(repoPath, opts);\n\t\t}\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath });\n\t}\n\n\tprivate readonly toCanonicalMap = new Map<string, Uri>();\n\tprivate readonly fromCanonicalMap = new Map<string, Uri>();\n\tprotected readonly unsafePaths = new Set<string>();\n\n\t@gate()\n\t@debug()\n\tasync findRepositoryUri(uri: Uri, isDirectory?: boolean): Promise<Uri | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tlet repoPath: string | undefined;\n\t\ttry {\n\t\t\tif (isDirectory == null) {\n\t\t\t\tconst stats = await workspace.fs.stat(uri);\n\t\t\t\tisDirectory = (stats.type & FileType.Directory) === FileType.Directory;\n\t\t\t}\n\n\t\t\t// If the uri isn't a directory, go up one level\n\t\t\tif (!isDirectory) {\n\t\t\t\turi = Uri.joinPath(uri, '..');\n\t\t\t}\n\n\t\t\tlet safe;\n\t\t\t[safe, repoPath] = await this.git.rev_parse__show_toplevel(uri.fsPath);\n\t\t\tif (safe) {\n\t\t\t\tthis.unsafePaths.delete(uri.fsPath);\n\t\t\t} else {\n\t\t\t\tthis.unsafePaths.add(uri.fsPath);\n\t\t\t}\n\t\t\tif (!repoPath) return undefined;\n\n\t\t\tconst repoUri = Uri.file(repoPath);\n\n\t\t\t// On Git 2.25+ if you call `rev-parse --show-toplevel` on a mapped drive, instead of getting the mapped drive path back, you get the UNC path for the mapped drive.\n\t\t\t// So try to normalize it back to the mapped drive path, if possible\n\t\t\tif (isWindows && repoUri.authority.length !== 0 && uri.authority.length === 0) {\n\t\t\t\tconst match = driveLetterRegex.exec(uri.path);\n\t\t\t\tif (match != null) {\n\t\t\t\t\tconst [, letter] = match;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst networkPath = await new Promise<string | undefined>(resolve =>\n\t\t\t\t\t\t\trealpath.native(`${letter}:\\\\`, { encoding: 'utf8' }, (err, resolvedPath) =>\n\t\t\t\t\t\t\t\tresolve(err != null ? undefined : resolvedPath),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (networkPath != null) {\n\t\t\t\t\t\t\trepoPath = normalizePath(\n\t\t\t\t\t\t\t\trepoUri.fsPath.replace(\n\t\t\t\t\t\t\t\t\tnetworkPath,\n\t\t\t\t\t\t\t\t\t`${letter.toLowerCase()}:${networkPath.endsWith('\\\\') ? '\\\\' : ''}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn Uri.file(repoPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t}\n\n\t\t\t\treturn Uri.file(normalizePath(uri.fsPath));\n\t\t\t}\n\n\t\t\t// Check if we are a symlink and if so, use the symlink path (not its resolved path)\n\t\t\t// This is because VS Code will provide document Uris using the symlinked path\n\t\t\tconst canonicalUri = this.toCanonicalMap.get(repoPath);\n\t\t\tif (canonicalUri == null) {\n\t\t\t\tlet symlink;\n\t\t\t\t[repoPath, symlink] = await new Promise<[string, string | undefined]>(resolve => {\n\t\t\t\t\trealpath(uri.fsPath, { encoding: 'utf8' }, (err, resolvedPath) => {\n\t\t\t\t\t\tif (err != null) {\n\t\t\t\t\t\t\tLogger.debug(scope, `fs.realpath failed; repoPath=${repoPath}`);\n\t\t\t\t\t\t\tresolve([repoPath!, undefined]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (equalsIgnoreCase(uri.fsPath, resolvedPath)) {\n\t\t\t\t\t\t\tLogger.debug(scope, `No symlink detected; repoPath=${repoPath}`);\n\t\t\t\t\t\t\tresolve([repoPath!, undefined]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet linkPath = normalizePath(resolvedPath);\n\t\t\t\t\t\tconst index = commonBaseIndex(`${repoPath}/`, `${linkPath}/`, '/');\n\t\t\t\t\t\tconst uriPath = normalizePath(uri.fsPath);\n\t\t\t\t\t\tif (index < linkPath.length - 1) {\n\t\t\t\t\t\t\tlinkPath = uriPath.substring(0, uriPath.length - (linkPath.length - index));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlinkPath = uriPath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t`Symlink detected; repoPath=${repoPath}, path=${uri.fsPath}, resolvedPath=${resolvedPath}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve([repoPath!, linkPath]);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// If we found a symlink, keep track of the mappings\n\t\t\t\tif (symlink != null) {\n\t\t\t\t\tthis.toCanonicalMap.set(repoPath, Uri.file(symlink));\n\t\t\t\t\tthis.fromCanonicalMap.set(symlink, Uri.file(repoPath));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn repoPath ? Uri.file(repoPath) : undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getAheadBehindCommitCount']>({ args: { 1: refs => refs.join(',') } })\n\tgetAheadBehindCommitCount(\n\t\trepoPath: string,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\treturn this.git.rev_list__left_right(repoPath, refs);\n\t}\n\n\t@gate<LocalGitProvider['getBlame']>((u, d) => `${u.toString()}|${d?.isDirty}`)\n\t@log<LocalGitProvider['getBlame']>({ args: { 1: d => d?.isDirty } })\n\tasync getBlame(uri: GitUri, document?: TextDocument | undefined): Promise<GitBlame | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tif (document?.isDirty) return this.getBlameContents(uri, document.getText());\n\n\t\tlet key = 'blame';\n\t\tif (uri.sha != null) {\n\t\t\tkey += `:${uri.sha}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(document ?? uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedBlame = doc.state.getBlame(key);\n\t\t\t\tif (cachedBlame != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedBlame.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getBlameCore(uri, doc, key, scope);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedBlame = {\n\t\t\t\titem: promise as Promise<GitBlame>,\n\t\t\t};\n\t\t\tdoc.state.setBlame(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getBlameCore(\n\t\turi: GitUri,\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitBlame | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(uri);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${uri.fsPath}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame(root, relativePath, uri.sha, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\treturn blame;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected blame errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedBlame = {\n\t\t\t\t\titem: emptyPromise as Promise<GitBlame>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setBlame(key, value);\n\n\t\t\t\tdocument.setBlameFailure();\n\n\t\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getBlameContents']>({ args: { 1: '<contents>' } })\n\tasync getBlameContents(uri: GitUri, contents: string): Promise<GitBlame | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst key = `blame:${md5(contents)}`;\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedBlame = doc.state.getBlame(key);\n\t\t\t\tif (cachedBlame != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: ${key}`);\n\t\t\t\t\treturn cachedBlame.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: ${key}`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getBlameContentsCore(uri, contents, doc, key, scope);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedBlame = {\n\t\t\t\titem: promise as Promise<GitBlame>,\n\t\t\t};\n\t\t\tdoc.state.setBlame(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getBlameContentsCore(\n\t\turi: GitUri,\n\t\tcontents: string,\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitBlame | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(uri);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${uri.fsPath}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame__contents(root, relativePath, contents, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tcorrelationKey: `:${key}`,\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\treturn blame;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected blame errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedBlame = {\n\t\t\t\t\titem: emptyPromise as Promise<GitBlame>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setBlame(key, value);\n\n\t\t\t\tdocument.setBlameFailure();\n\t\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@gate<LocalGitProvider['getBlameForLine']>(\n\t\t(u, l, d, o) => `${u.toString()}|${l}|${d?.isDirty}|${o?.forceSingleLine}`,\n\t)\n\t@log<LocalGitProvider['getBlameForLine']>({ args: { 2: d => d?.isDirty } })\n\tasync getBlameForLine(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tdocument?: TextDocument | undefined,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tif (document?.isDirty) return this.getBlameForLineContents(uri, editorLine, document.getText(), options);\n\n\t\tif (!options?.forceSingleLine && this.useCaching) {\n\t\t\tconst blame = await this.getBlame(uri, document);\n\t\t\tif (blame == null) return undefined;\n\n\t\t\tlet blameLine = blame.lines[editorLine];\n\t\t\tif (blameLine == null) {\n\t\t\t\tif (blame.lines.length !== editorLine) return undefined;\n\t\t\t\tblameLine = blame.lines[editorLine - 1];\n\t\t\t}\n\n\t\t\tconst commit = blame.commits.get(blameLine.sha);\n\t\t\tif (commit == null) return undefined;\n\n\t\t\tconst author = blame.authors.get(commit.author.name)!;\n\t\t\treturn {\n\t\t\t\tauthor: { ...author, lineCount: commit.lines.length },\n\t\t\t\tcommit: commit,\n\t\t\t\tline: blameLine,\n\t\t\t};\n\t\t}\n\n\t\tconst lineToBlame = editorLine + 1;\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame(root, relativePath, uri.sha, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t\tstartLine: lineToBlame,\n\t\t\t\tendLine: lineToBlame,\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\tif (blame == null) return undefined;\n\n\t\t\treturn {\n\t\t\t\tauthor: first(blame.authors.values())!,\n\t\t\t\tcommit: first(blame.commits.values())!,\n\t\t\t\tline: blame.lines[editorLine],\n\t\t\t};\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getBlameForLineContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForLineContents(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tcontents: string,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tif (!options?.forceSingleLine && this.useCaching) {\n\t\t\tconst blame = await this.getBlameContents(uri, contents);\n\t\t\tif (blame == null) return undefined;\n\n\t\t\tlet blameLine = blame.lines[editorLine];\n\t\t\tif (blameLine == null) {\n\t\t\t\tif (blame.lines.length !== editorLine) return undefined;\n\t\t\t\tblameLine = blame.lines[editorLine - 1];\n\t\t\t}\n\n\t\t\tconst commit = blame.commits.get(blameLine.sha);\n\t\t\tif (commit == null) return undefined;\n\n\t\t\tconst author = blame.authors.get(commit.author.name)!;\n\t\t\treturn {\n\t\t\t\tauthor: { ...author, lineCount: commit.lines.length },\n\t\t\t\tcommit: commit,\n\t\t\t\tline: blameLine,\n\t\t\t};\n\t\t}\n\n\t\tconst lineToBlame = editorLine + 1;\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame__contents(root, relativePath, contents, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t\tstartLine: lineToBlame,\n\t\t\t\tendLine: lineToBlame,\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\tif (blame == null) return undefined;\n\n\t\t\treturn {\n\t\t\t\tauthor: first(blame.authors.values())!,\n\t\t\t\tcommit: first(blame.commits.values())!,\n\t\t\t\tline: blame.lines[editorLine],\n\t\t\t};\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getBlameForRange(uri: GitUri, range: Range): Promise<GitBlameLines | undefined> {\n\t\tconst blame = await this.getBlame(uri);\n\t\tif (blame == null) return undefined;\n\n\t\treturn this.getBlameRange(blame, uri, range);\n\t}\n\n\t@log<LocalGitProvider['getBlameForRangeContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForRangeContents(uri: GitUri, range: Range, contents: string): Promise<GitBlameLines | undefined> {\n\t\tconst blame = await this.getBlameContents(uri, contents);\n\t\tif (blame == null) return undefined;\n\n\t\treturn this.getBlameRange(blame, uri, range);\n\t}\n\n\t@log<LocalGitProvider['getBlameRange']>({ args: { 0: '<blame>' } })\n\tgetBlameRange(blame: GitBlame, uri: GitUri, range: Range): GitBlameLines | undefined {\n\t\tif (blame.lines.length === 0) return { allLines: blame.lines, ...blame };\n\n\t\tif (range.start.line === 0 && range.end.line === blame.lines.length - 1) {\n\t\t\treturn { allLines: blame.lines, ...blame };\n\t\t}\n\n\t\tconst lines = blame.lines.slice(range.start.line, range.end.line + 1);\n\t\tconst shas = new Set(lines.map(l => l.sha));\n\n\t\t// ranges are 0-based\n\t\tconst startLine = range.start.line + 1;\n\t\tconst endLine = range.end.line + 1;\n\n\t\tconst authors = new Map<string, GitBlameAuthor>();\n\t\tconst commits = new Map<string, GitCommit>();\n\t\tfor (const c of blame.commits.values()) {\n\t\t\tif (!shas.has(c.sha)) continue;\n\n\t\t\tconst commit = c.with({\n\t\t\t\tlines: c.lines.filter(l => l.line >= startLine && l.line <= endLine),\n\t\t\t});\n\t\t\tcommits.set(c.sha, commit);\n\n\t\t\tlet author = authors.get(commit.author.name);\n\t\t\tif (author == null) {\n\t\t\t\tauthor = {\n\t\t\t\t\tname: commit.author.name,\n\t\t\t\t\tlineCount: 0,\n\t\t\t\t};\n\t\t\t\tauthors.set(author.name, author);\n\t\t\t}\n\n\t\t\tauthor.lineCount += commit.lines.length;\n\t\t}\n\n\t\tconst sortedAuthors = new Map([...authors.entries()].sort((a, b) => b[1].lineCount - a[1].lineCount));\n\n\t\treturn {\n\t\t\trepoPath: uri.repoPath!,\n\t\t\tauthors: sortedAuthors,\n\t\t\tcommits: commits,\n\t\t\tlines: lines,\n\t\t\tallLines: blame.lines,\n\t\t};\n\t}\n\n\t@log()\n\tasync getBranch(repoPath: string): Promise<GitBranch | undefined> {\n\t\tlet {\n\t\t\tvalues: [branch],\n\t\t} = await this.getBranches(repoPath, { filter: b => b.current });\n\t\tif (branch != null) return branch;\n\n\t\tconst commitOrdering = configuration.get('advanced.commitOrdering');\n\n\t\tconst data = await this.git.rev_parse__currentBranch(repoPath, commitOrdering);\n\t\tif (data == null) return undefined;\n\n\t\tconst [name, upstream] = data[0].split('\\n');\n\t\tif (isDetachedHead(name)) {\n\t\t\tconst [rebaseStatus, committerDate] = await Promise.all([\n\t\t\t\tthis.getRebaseStatus(repoPath),\n\n\t\t\t\tthis.git.log__recent_committerdate(repoPath, commitOrdering),\n\t\t\t]);\n\n\t\t\tbranch = new GitBranch(\n\t\t\t\trepoPath,\n\t\t\t\trebaseStatus?.incoming.name ?? name,\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\tcommitterDate != null ? new Date(Number(committerDate) * 1000) : undefined,\n\t\t\t\tdata[1],\n\t\t\t\tupstream ? { name: upstream, missing: false } : undefined,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\trebaseStatus != null,\n\t\t\t);\n\t\t}\n\n\t\treturn branch;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getBranches(\n\t\trepoPath: string | undefined,\n\t\toptions?: {\n\t\t\tcursor?: string;\n\t\t\tfilter?: (b: GitBranch) => boolean;\n\t\t\tsort?: boolean | BranchSortOptions;\n\t\t},\n\t): Promise<PagedResult<GitBranch>> {\n\t\tif (repoPath == null) return emptyPagedResult;\n\n\t\tlet resultsPromise = this.useCaching ? this._branchesCache.get(repoPath) : undefined;\n\t\tif (resultsPromise == null) {\n\t\t\tasync function load(this: LocalGitProvider): Promise<PagedResult<GitBranch>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.git.for_each_ref__branch(repoPath!, { all: true });\n\t\t\t\t\t// If we don't get any data, assume the repo doesn't have any commits yet so check if we have a current branch\n\t\t\t\t\tif (data == null || data.length === 0) {\n\t\t\t\t\t\tlet current;\n\n\t\t\t\t\t\tconst commitOrdering = configuration.get('advanced.commitOrdering');\n\n\t\t\t\t\t\tconst data = await this.git.rev_parse__currentBranch(repoPath!, commitOrdering);\n\t\t\t\t\t\tif (data != null) {\n\t\t\t\t\t\t\tconst [name, upstream] = data[0].split('\\n');\n\t\t\t\t\t\t\tconst [rebaseStatus, committerDate] = await Promise.all([\n\t\t\t\t\t\t\t\tisDetachedHead(name) ? this.getRebaseStatus(repoPath!) : undefined,\n\t\t\t\t\t\t\t\tthis.git.log__recent_committerdate(repoPath!, commitOrdering),\n\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\tcurrent = new GitBranch(\n\t\t\t\t\t\t\t\trepoPath!,\n\t\t\t\t\t\t\t\trebaseStatus?.incoming.name ?? name,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tcommitterDate != null ? new Date(Number(committerDate) * 1000) : undefined,\n\t\t\t\t\t\t\t\tdata[1],\n\t\t\t\t\t\t\t\t{ name: upstream, missing: false },\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trebaseStatus != null,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn current != null ? { values: [current] } : emptyPagedResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { values: GitBranchParser.parse(data, repoPath!) };\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._branchesCache.delete(repoPath!);\n\n\t\t\t\t\treturn emptyPagedResult;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresultsPromise = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tif (options?.cursor == null) {\n\t\t\t\t\tthis._branchesCache.set(repoPath, resultsPromise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet result = await resultsPromise;\n\t\tif (options?.filter != null) {\n\t\t\tresult = {\n\t\t\t\t...result,\n\t\t\t\tvalues: result.values.filter(options.filter),\n\t\t\t};\n\t\t}\n\n\t\tif (options?.sort) {\n\t\t\tsortBranches(result.values, typeof options.sort === 'boolean' ? undefined : options.sort);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@log()\n\tasync getChangedFilesCount(repoPath: string, ref?: string): Promise<GitDiffShortStat | undefined> {\n\t\tconst data = await this.git.diff__shortstat(repoPath, ref);\n\t\tif (!data) return undefined;\n\n\t\treturn GitDiffParser.parseShortStat(data);\n\t}\n\n\t@log()\n\tasync getCommit(repoPath: string, ref: string): Promise<GitCommit | undefined> {\n\t\tconst log = await this.getLog(repoPath, { limit: 2, ref: ref });\n\t\tif (log == null) return undefined;\n\n\t\treturn log.commits.get(ref) ?? first(log.commits.values());\n\t}\n\n\t@log()\n\tasync getCommitBranches(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { branch?: string; commitDate?: Date; mode?: 'contains' | 'pointsAt'; remotes?: boolean },\n\t): Promise<string[]> {\n\t\tif (options?.branch) {\n\t\t\tconst data = await this.git.branch__containsOrPointsAt(repoPath, ref, {\n\t\t\t\tmode: 'contains',\n\t\t\t\tname: options.branch,\n\t\t\t});\n\t\t\tif (!data) return [];\n\n\t\t\treturn [data?.trim()];\n\t\t}\n\n\t\tconst data = await this.git.branch__containsOrPointsAt(repoPath, ref, options);\n\t\tif (!data) return [];\n\n\t\treturn filterMap(data.split('\\n'), b => b.trim() || undefined);\n\t}\n\n\t@log()\n\tgetCommitCount(repoPath: string, ref: string): Promise<number | undefined> {\n\t\treturn this.git.rev_list__count(repoPath, ref);\n\t}\n\n\t@log()\n\tasync getCommitForFile(\n\t\trepoPath: string | undefined,\n\t\turi: Uri,\n\t\toptions?: { ref?: string; firstIfNotFound?: boolean; range?: Range },\n\t): Promise<GitCommit | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\ttry {\n\t\t\tconst log = await this.getLogForFile(root, relativePath, {\n\t\t\t\tlimit: 2,\n\t\t\t\tref: options?.ref,\n\t\t\t\trange: options?.range,\n\t\t\t});\n\t\t\tif (log == null) return undefined;\n\n\t\t\tlet commit;\n\t\t\tif (options?.ref) {\n\t\t\t\tconst commit = log.commits.get(options.ref);\n\t\t\t\tif (commit == null && !options?.firstIfNotFound) {\n\t\t\t\t\t// If the ref isn't a valid sha we will never find it, so let it fall through so we return the first\n\t\t\t\t\tif (isSha(options.ref) || isUncommitted(options.ref)) return undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn commit ?? first(log.commits.values());\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getCommitsForGraph(\n\t\trepoPath: string,\n\t\tasWebviewUri: (uri: Uri) => Uri,\n\t\toptions?: {\n\t\t\tbranch?: string;\n\t\t\tinclude?: { stats?: boolean };\n\t\t\tlimit?: number;\n\t\t\tref?: string;\n\t\t},\n\t): Promise<GitGraph> {\n\t\tconst parser = getGraphParser(options?.include?.stats);\n\t\tconst refParser = getRefParser();\n\n\t\tconst defaultLimit = options?.limit ?? configuration.get('graph.defaultItemLimit') ?? 5000;\n\t\tconst defaultPageLimit = configuration.get('graph.pageItemLimit') ?? 1000;\n\t\tconst ordering = configuration.get('graph.commitOrdering', undefined, 'date');\n\n\t\tconst [refResult, stashResult, branchesResult, remotesResult, currentUserResult] = await Promise.allSettled([\n\t\t\tthis.git.log2(repoPath, undefined, ...refParser.arguments, '-n1', options?.ref ?? 'HEAD'),\n\t\t\tthis.getStash(repoPath),\n\t\t\tthis.getBranches(repoPath),\n\t\t\tthis.getRemotes(repoPath),\n\t\t\tthis.getCurrentUser(repoPath),\n\t\t]);\n\n\t\tconst branches = getSettledValue(branchesResult)?.values;\n\t\tconst branchMap = branches != null ? new Map(branches.map(r => [r.name, r])) : new Map<string, GitBranch>();\n\t\tconst headBranch = branches?.find(b => b.current);\n\t\tconst headRefUpstreamName = headBranch?.upstream?.name;\n\n\t\tconst currentUser = getSettledValue(currentUserResult);\n\n\t\tconst remotes = getSettledValue(remotesResult);\n\t\tconst remoteMap = remotes != null ? new Map(remotes.map(r => [r.name, r])) : new Map<string, GitRemote>();\n\t\tconst selectSha = first(refParser.parse(getSettledValue(refResult) ?? ''));\n\n\t\tconst downstreamMap = new Map<string, string[]>();\n\n\t\tlet stdin: string | undefined;\n\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\tconst stash = getSettledValue(stashResult);\n\t\tif (stash != null && stash.commits.size !== 0) {\n\t\t\tstdin = join(\n\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t'\\n',\n\t\t\t);\n\t\t}\n\n\t\tconst useAvatars = configuration.get('graph.avatars', undefined, true);\n\n\t\tconst avatars = new Map<string, string>();\n\t\tconst ids = new Set<string>();\n\t\tconst reachableFromHEAD = new Set<string>();\n\t\tconst remappedIds = new Map<string, string>();\n\t\tlet total = 0;\n\t\tlet iterations = 0;\n\n\t\tasync function getCommitsForGraphCore(\n\t\t\tthis: LocalGitProvider,\n\t\t\tlimit: number,\n\t\t\tsha?: string,\n\t\t\tcursor?: { sha: string; skip: number },\n\t\t): Promise<GitGraph> {\n\t\t\titerations++;\n\n\t\t\tlet log: string | string[] | undefined;\n\t\t\tlet nextPageLimit = limit;\n\t\t\tlet size;\n\n\t\t\tdo {\n\t\t\t\tconst args = [...parser.arguments, `--${ordering}-order`, '--all'];\n\t\t\t\tif (cursor?.skip) {\n\t\t\t\t\targs.push(`--skip=${cursor.skip}`);\n\t\t\t\t}\n\n\t\t\t\tlet data;\n\t\t\t\tif (sha) {\n\t\t\t\t\t[data, limit] = await this.git.logStreamTo(\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\tsha,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\tstdin ? { stdin: stdin } : undefined,\n\t\t\t\t\t\t...args,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(`-n${nextPageLimit + 1}`);\n\n\t\t\t\t\tdata = await this.git.log2(repoPath, stdin ? { stdin: stdin } : undefined, ...args);\n\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tif (!getShaInLogRegex(cursor.sha).test(data)) {\n\t\t\t\t\t\t\t// If we didn't find any new commits, we must have them all so return that we have everything\n\t\t\t\t\t\t\tif (size === data.length) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\t\t\t\tavatars: avatars,\n\t\t\t\t\t\t\t\t\tids: ids,\n\t\t\t\t\t\t\t\t\tincludes: options?.include,\n\t\t\t\t\t\t\t\t\tbranches: branchMap,\n\t\t\t\t\t\t\t\t\tremotes: remoteMap,\n\t\t\t\t\t\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\t\t\t\t\t\trows: [],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsize = data.length;\n\t\t\t\t\t\t\tnextPageLimit = (nextPageLimit === 0 ? defaultPageLimit : nextPageLimit) * 2;\n\t\t\t\t\t\t\tcursor.skip -= Math.floor(cursor.skip * 0.1);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\tavatars: avatars,\n\t\t\t\t\t\tids: ids,\n\t\t\t\t\t\tincludes: options?.include,\n\t\t\t\t\t\tbranches: branchMap,\n\t\t\t\t\t\tremotes: remoteMap,\n\t\t\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlog = data;\n\t\t\t\tif (limit !== 0) {\n\t\t\t\t\tlimit = nextPageLimit;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t} while (true);\n\n\t\t\tconst rows: GitGraphRow[] = [];\n\n\t\t\tlet avatarUri: Uri | undefined;\n\t\t\tlet avatarUrl: string | undefined;\n\t\t\tlet branch: GitBranch | undefined;\n\t\t\tlet branchId: string;\n\t\t\tlet branchName: string;\n\t\t\tlet context:\n\t\t\t\t| GraphItemRefContext<GraphBranchContextValue>\n\t\t\t\t| GraphItemRefContext<GraphTagContextValue>\n\t\t\t\t| undefined;\n\t\t\tlet contexts: GitGraphRowContexts | undefined;\n\t\t\tlet group;\n\t\t\tlet groupName;\n\t\t\tconst groupedRefs = new Map<\n\t\t\t\tstring,\n\t\t\t\t{ head?: boolean; local?: GitBranchReference; remotes?: GitBranchReference[] }\n\t\t\t>();\n\t\t\tlet head = false;\n\t\t\tlet isCurrentUser = false;\n\t\t\tlet refHead: GitGraphRowHead;\n\t\t\tlet refHeads: GitGraphRowHead[];\n\t\t\tlet refRemoteHead: GitGraphRowRemoteHead;\n\t\t\tlet refRemoteHeads: GitGraphRowRemoteHead[];\n\t\t\tlet refTag: GitGraphRowTag;\n\t\t\tlet refTags: GitGraphRowTag[];\n\t\t\tlet parent: string;\n\t\t\tlet parents: string[];\n\t\t\tlet remote: GitRemote | undefined;\n\t\t\tlet remoteBranchId: string;\n\t\t\tlet remoteName: string;\n\t\t\tlet stashCommit: GitStashCommit | undefined;\n\t\t\tlet tagId: string;\n\t\t\tlet tagName: string;\n\t\t\tlet tip: string;\n\n\t\t\tlet count = 0;\n\n\t\t\tconst commits = parser.parse(log);\n\t\t\tfor (const commit of commits) {\n\t\t\t\tcount++;\n\t\t\t\tif (ids.has(commit.sha)) continue;\n\n\t\t\t\ttotal++;\n\t\t\t\tif (remappedIds.has(commit.sha)) continue;\n\n\t\t\t\tids.add(commit.sha);\n\n\t\t\t\trefHeads = [];\n\t\t\t\trefRemoteHeads = [];\n\t\t\t\trefTags = [];\n\t\t\t\tcontexts = {};\n\t\t\t\thead = false;\n\n\t\t\t\tif (commit.tips) {\n\t\t\t\t\tgroupedRefs.clear();\n\n\t\t\t\t\tfor (tip of commit.tips.split(', ')) {\n\t\t\t\t\t\tif (tip === 'refs/stash') continue;\n\n\t\t\t\t\t\tif (tip.startsWith('tag: ')) {\n\t\t\t\t\t\t\ttagName = tip.substring(5);\n\t\t\t\t\t\t\ttagId = getTagId(repoPath, tagName);\n\t\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\t\twebviewItem: 'gitlens:tag',\n\t\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\t\ttype: 'tag',\n\t\t\t\t\t\t\t\t\tref: createReference(tagName, repoPath, {\n\t\t\t\t\t\t\t\t\t\tid: tagId,\n\t\t\t\t\t\t\t\t\t\trefType: 'tag',\n\t\t\t\t\t\t\t\t\t\tname: tagName,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\trefTag = {\n\t\t\t\t\t\t\t\tid: tagId,\n\t\t\t\t\t\t\t\tname: tagName,\n\t\t\t\t\t\t\t\t// Not currently used, so don't bother looking it up\n\t\t\t\t\t\t\t\tannotated: true,\n\t\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\trefTags.push(refTag);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thead = tip.startsWith('HEAD');\n\t\t\t\t\t\tif (head) {\n\t\t\t\t\t\t\treachableFromHEAD.add(commit.sha);\n\n\t\t\t\t\t\t\tif (tip !== 'HEAD') {\n\t\t\t\t\t\t\t\ttip = tip.substring(8);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoteName = getRemoteNameFromBranchName(tip);\n\t\t\t\t\t\tif (remoteName) {\n\t\t\t\t\t\t\tremote = remoteMap.get(remoteName);\n\t\t\t\t\t\t\tif (remote != null) {\n\t\t\t\t\t\t\t\tbranchName = getBranchNameWithoutRemote(tip);\n\t\t\t\t\t\t\t\tif (branchName === 'HEAD') continue;\n\n\t\t\t\t\t\t\t\tremoteBranchId = getBranchId(repoPath, true, tip);\n\t\t\t\t\t\t\t\tavatarUrl = (\n\t\t\t\t\t\t\t\t\t(useAvatars ? remote.provider?.avatarUri : undefined) ??\n\t\t\t\t\t\t\t\t\tgetRemoteIconUri(this.container, remote, asWebviewUri)\n\t\t\t\t\t\t\t\t)?.toString(true);\n\t\t\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\t\t\twebviewItem: 'gitlens:branch+remote',\n\t\t\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\t\t\ttype: 'branch',\n\t\t\t\t\t\t\t\t\t\tref: createReference(tip, repoPath, {\n\t\t\t\t\t\t\t\t\t\t\tid: remoteBranchId,\n\t\t\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\t\t\t\t\tremote: true,\n\t\t\t\t\t\t\t\t\t\t\tupstream: { name: remote.name, missing: false },\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\trefRemoteHead = {\n\t\t\t\t\t\t\t\t\tid: remoteBranchId,\n\t\t\t\t\t\t\t\t\tname: branchName,\n\t\t\t\t\t\t\t\t\towner: remote.name,\n\t\t\t\t\t\t\t\t\turl: remote.url,\n\t\t\t\t\t\t\t\t\tavatarUrl: avatarUrl,\n\t\t\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\t\t\tcurrent: tip === headRefUpstreamName,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\trefRemoteHeads.push(refRemoteHead);\n\n\t\t\t\t\t\t\t\tgroup = groupedRefs.get(branchName);\n\t\t\t\t\t\t\t\tif (group == null) {\n\t\t\t\t\t\t\t\t\tgroup = { remotes: [] };\n\t\t\t\t\t\t\t\t\tgroupedRefs.set(branchName, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.remotes == null) {\n\t\t\t\t\t\t\t\t\tgroup.remotes = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgroup.remotes.push(context.webviewItemValue.ref);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbranch = branchMap.get(tip);\n\t\t\t\t\t\tbranchId = branch?.id ?? getBranchId(repoPath, false, tip);\n\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\twebviewItem: `gitlens:branch${head ? '+current' : ''}${\n\t\t\t\t\t\t\t\tbranch?.upstream != null ? '+tracking' : ''\n\t\t\t\t\t\t\t}`,\n\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\ttype: 'branch',\n\t\t\t\t\t\t\t\tref: createReference(tip, repoPath, {\n\t\t\t\t\t\t\t\t\tid: branchId,\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t\t\tupstream: branch?.upstream,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\trefHead = {\n\t\t\t\t\t\t\tid: branchId,\n\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\tisCurrentHead: head,\n\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\tupstream:\n\t\t\t\t\t\t\t\tbranch?.upstream != null\n\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\tname: branch.upstream.name,\n\t\t\t\t\t\t\t\t\t\t\tid: getBranchId(repoPath, true, branch.upstream.name),\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t};\n\t\t\t\t\t\trefHeads.push(refHead);\n\t\t\t\t\t\tif (branch?.upstream?.name != null) {\n\t\t\t\t\t\t\t// Add the branch name (tip) to the upstream name entry in the downstreams map\n\t\t\t\t\t\t\tlet downstreams = downstreamMap.get(branch.upstream.name);\n\t\t\t\t\t\t\tif (downstreams == null) {\n\t\t\t\t\t\t\t\tdownstreams = [];\n\t\t\t\t\t\t\t\tdownstreamMap.set(branch.upstream.name, downstreams);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdownstreams.push(tip);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroup = groupedRefs.get(tip);\n\t\t\t\t\t\tif (group == null) {\n\t\t\t\t\t\t\tgroup = {};\n\t\t\t\t\t\t\tgroupedRefs.set(tip, group);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (head) {\n\t\t\t\t\t\t\tgroup.head = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.local = context.webviewItemValue.ref;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ([groupName, group] of groupedRefs) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgroup.remotes != null &&\n\t\t\t\t\t\t\t((group.local != null && group.remotes.length > 0) || group.remotes.length > 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (contexts.refGroups == null) {\n\t\t\t\t\t\t\t\tcontexts.refGroups = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontexts.refGroups[groupName] = serializeWebviewItemContext<GraphItemRefGroupContext>({\n\t\t\t\t\t\t\t\twebviewItemGroup: `gitlens:refGroup${group.head ? '+current' : ''}`,\n\t\t\t\t\t\t\t\twebviewItemGroupValue: {\n\t\t\t\t\t\t\t\t\ttype: 'refGroup',\n\t\t\t\t\t\t\t\t\trefs: group.local != null ? [group.local, ...group.remotes] : group.remotes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstashCommit = stash?.commits.get(commit.sha);\n\n\t\t\t\tparents = commit.parents ? commit.parents.split(' ') : [];\n\t\t\t\tif (reachableFromHEAD.has(commit.sha)) {\n\t\t\t\t\tfor (parent of parents) {\n\t\t\t\t\t\treachableFromHEAD.add(parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the second & third parent, if exists, from each stash commit as it is a Git implementation for the index and untracked files\n\t\t\t\tif (stashCommit != null && parents.length > 1) {\n\t\t\t\t\t// Remap the \"index commit\" (e.g. contains staged files) of the stash\n\t\t\t\t\tremappedIds.set(parents[1], commit.sha);\n\t\t\t\t\t// Remap the \"untracked commit\" (e.g. contains untracked files) of the stash\n\t\t\t\t\tremappedIds.set(parents[2], commit.sha);\n\t\t\t\t\tparents.splice(1, 2);\n\t\t\t\t}\n\n\t\t\t\tif (stashCommit == null && !avatars.has(commit.authorEmail)) {\n\t\t\t\t\tavatarUri = getCachedAvatarUri(commit.authorEmail);\n\t\t\t\t\tif (avatarUri != null) {\n\t\t\t\t\t\tavatars.set(commit.authorEmail, avatarUri.toString(true));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tisCurrentUser = isUserMatch(currentUser, commit.author, commit.authorEmail);\n\n\t\t\t\tif (stashCommit != null) {\n\t\t\t\t\tcontexts.row = serializeWebviewItemContext<GraphItemRefContext>({\n\t\t\t\t\t\twebviewItem: 'gitlens:stash',\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'stash',\n\t\t\t\t\t\t\tref: createReference(commit.sha, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'stash',\n\t\t\t\t\t\t\t\tname: stashCommit.name,\n\t\t\t\t\t\t\t\tnumber: stashCommit.number,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontexts.row = serializeWebviewItemContext<GraphItemRefContext>({\n\t\t\t\t\t\twebviewItem: `gitlens:commit${head ? '+HEAD' : ''}${\n\t\t\t\t\t\t\treachableFromHEAD.has(commit.sha) ? '+current' : ''\n\t\t\t\t\t\t}`,\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'commit',\n\t\t\t\t\t\t\tref: createReference(commit.sha, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'revision',\n\t\t\t\t\t\t\t\tmessage: commit.message,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tcontexts.avatar = serializeWebviewItemContext<GraphItemContext>({\n\t\t\t\t\t\twebviewItem: `gitlens:contributor${isCurrentUser ? '+current' : ''}`,\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'contributor',\n\t\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\t\tname: commit.author,\n\t\t\t\t\t\t\temail: commit.authorEmail,\n\t\t\t\t\t\t\tcurrent: isCurrentUser,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\trows.push({\n\t\t\t\t\tsha: commit.sha,\n\t\t\t\t\tparents: parents,\n\t\t\t\t\tauthor: isCurrentUser ? 'You' : commit.author,\n\t\t\t\t\temail: commit.authorEmail,\n\t\t\t\t\tdate: Number(ordering === 'author-date' ? commit.authorDate : commit.committerDate) * 1000,\n\t\t\t\t\tmessage: emojify(commit.message.trim()),\n\t\t\t\t\t// TODO: review logic for stash, wip, etc\n\t\t\t\t\ttype:\n\t\t\t\t\t\tstashCommit != null\n\t\t\t\t\t\t\t? GitGraphRowType.Stash\n\t\t\t\t\t\t\t: parents.length > 1\n\t\t\t\t\t\t\t? GitGraphRowType.MergeCommit\n\t\t\t\t\t\t\t: GitGraphRowType.Commit,\n\t\t\t\t\theads: refHeads,\n\t\t\t\t\tremotes: refRemoteHeads,\n\t\t\t\t\ttags: refTags,\n\t\t\t\t\tcontexts: contexts,\n\t\t\t\t\tstats: commit.stats,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst startingCursor = cursor?.sha;\n\t\t\tconst lastSha = last(ids);\n\t\t\tcursor =\n\t\t\t\tlastSha != null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsha: lastSha,\n\t\t\t\t\t\t\tskip: total - iterations,\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined;\n\n\t\t\treturn {\n\t\t\t\trepoPath: repoPath,\n\t\t\t\tavatars: avatars,\n\t\t\t\tids: ids,\n\t\t\t\tincludes: options?.include,\n\t\t\t\tremappedIds: remappedIds,\n\t\t\t\tbranches: branchMap,\n\t\t\t\tremotes: remoteMap,\n\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\trows: rows,\n\t\t\t\tid: sha,\n\n\t\t\t\tpaging: {\n\t\t\t\t\tlimit: limit === 0 ? count : limit,\n\t\t\t\t\tstartingCursor: startingCursor,\n\t\t\t\t\thasMore: limit !== 0 && count > limit,\n\t\t\t\t},\n\t\t\t\tmore: async (limit: number, sha?: string): Promise<GitGraph | undefined> =>\n\t\t\t\t\tgetCommitsForGraphCore.call(this, limit, sha, cursor),\n\t\t\t};\n\t\t}\n\n\t\treturn getCommitsForGraphCore.call(this, defaultLimit, selectSha);\n\t}\n\n\tgetConfig(repoPath: string, key: string): Promise<string | undefined> {\n\t\treturn this.git.config__get(key, repoPath);\n\t}\n\n\tsetConfig(repoPath: string, key: string, value: string | undefined): Promise<void> {\n\t\treturn this.git.config__set(key, value, repoPath);\n\t}\n\n\t@log()\n\tasync getContributors(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; ref?: string; stats?: boolean },\n\t): Promise<GitContributor[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst key = options?.stats ? `stats|${repoPath}` : repoPath;\n\n\t\tlet contributors = this.useCaching ? this._contributorsCache.get(key) : undefined;\n\t\tif (contributors == null) {\n\t\t\tasync function load(this: LocalGitProvider) {\n\t\t\t\ttry {\n\t\t\t\t\trepoPath = normalizePath(repoPath);\n\t\t\t\t\tconst currentUser = await this.getCurrentUser(repoPath);\n\t\t\t\t\tconst parser = getContributorsParser(options?.stats);\n\n\t\t\t\t\tconst data = await this.git.log(repoPath, options?.ref, {\n\t\t\t\t\t\tall: options?.all,\n\t\t\t\t\t\targsOrFormat: parser.arguments,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst contributors = new Map<string, GitContributor>();\n\n\t\t\t\t\tconst commits = parser.parse(data);\n\t\t\t\t\tfor (const c of commits) {\n\t\t\t\t\t\tconst key = `${c.author}|${c.email}`;\n\t\t\t\t\t\tlet contributor = contributors.get(key);\n\t\t\t\t\t\tif (contributor == null) {\n\t\t\t\t\t\t\tcontributor = new GitContributor(\n\t\t\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\t\t\tc.author,\n\t\t\t\t\t\t\t\tc.email,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tnew Date(Number(c.date) * 1000),\n\t\t\t\t\t\t\t\tisUserMatch(currentUser, c.author, c.email),\n\t\t\t\t\t\t\t\tc.stats,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontributors.set(key, contributor);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(contributor as PickMutable<GitContributor, 'count'>).count++;\n\t\t\t\t\t\t\tconst date = new Date(Number(c.date) * 1000);\n\t\t\t\t\t\t\tif (date > contributor.date!) {\n\t\t\t\t\t\t\t\t(contributor as PickMutable<GitContributor, 'date'>).date = date;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [...contributors.values()];\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._contributorsCache.delete(key);\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontributors = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._contributorsCache.set(key, contributors);\n\t\t\t}\n\t\t}\n\n\t\treturn contributors;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getCurrentUser(repoPath: string): Promise<GitUser | undefined> {\n\t\tif (!repoPath) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tconst repo = this._repoInfoCache.get(repoPath);\n\n\t\tlet user = repo?.user;\n\t\tif (user != null) return user;\n\t\t// If we found the repo, but no user data was found just return\n\t\tif (user === null) return undefined;\n\n\t\tuser = { name: undefined, email: undefined };\n\n\t\ttry {\n\t\t\tconst data = await this.git.config__get_regex('^user\\\\.', repoPath, { local: true });\n\t\t\tif (data) {\n\t\t\t\tlet key: string;\n\t\t\t\tlet value: string;\n\n\t\t\t\tlet match;\n\t\t\t\tdo {\n\t\t\t\t\tmatch = userConfigRegex.exec(data);\n\t\t\t\t\tif (match == null) break;\n\n\t\t\t\t\t[, key, value] = match;\n\t\t\t\t\t// Stops excessive memory usage -- https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\tuser[key as 'name' | 'email'] = ` ${value}`.substr(1);\n\t\t\t\t} while (true);\n\t\t\t} else {\n\t\t\t\tuser.name =\n\t\t\t\t\tprocess_env.GIT_AUTHOR_NAME || process_env.GIT_COMMITTER_NAME || userInfo()?.username || undefined;\n\t\t\t\tif (!user.name) {\n\t\t\t\t\t// If we found no user data, mark it so we won't bother trying again\n\t\t\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: null });\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tuser.email =\n\t\t\t\t\tprocess_env.GIT_AUTHOR_EMAIL ||\n\t\t\t\t\tprocess_env.GIT_COMMITTER_EMAIL ||\n\t\t\t\t\tprocess_env.EMAIL ||\n\t\t\t\t\t`${user.name}@${hostname()}`;\n\t\t\t}\n\n\t\t\tconst author = `${user.name} <${user.email}>`;\n\t\t\t// Check if there is a mailmap for the current user\n\t\t\tconst mappedAuthor = await this.git.check_mailmap(repoPath, author);\n\t\t\tif (mappedAuthor != null && mappedAuthor.length !== 0 && author !== mappedAuthor) {\n\t\t\t\tconst match = mappedAuthorRegex.exec(mappedAuthor);\n\t\t\t\tif (match != null) {\n\t\t\t\t\t[, user.name, user.email] = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: user });\n\t\t\treturn user;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\n\t\t\t// Mark it so we won't bother trying again\n\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: null });\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDefaultBranchName(repoPath: string | undefined, remote?: string): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tif (!remote) {\n\t\t\ttry {\n\t\t\t\tconst data = await this.git.symbolic_ref(repoPath, 'HEAD');\n\t\t\t\tif (data != null) return data.trim();\n\t\t\t} catch {}\n\t\t}\n\n\t\tremote = remote ?? 'origin';\n\t\ttry {\n\t\t\tconst data = await this.git.ls_remote__HEAD(repoPath, remote);\n\t\t\tif (data == null) return undefined;\n\n\t\t\tconst match = /ref:\\s(\\S+)\\s+HEAD/m.exec(data);\n\t\t\tif (match == null) return undefined;\n\n\t\t\tconst [, branch] = match;\n\t\t\treturn branch.substr('refs/heads/'.length);\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiff(\n\t\trepoPath: string,\n\t\tref1: string,\n\t\tref2?: string,\n\t\toptions?: { includeRawDiff?: boolean },\n\t): Promise<GitDiff | undefined> {\n\t\tlet data;\n\t\tif (ref1 === uncommitted) {\n\t\t\tif (ref2 == null) {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3');\n\t\t\t} else {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', ref2);\n\t\t\t}\n\t\t} else if (ref1 === uncommittedStaged) {\n\t\t\tif (ref2 == null) {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', '--staged');\n\t\t\t} else {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', '--staged', ref2);\n\t\t\t}\n\t\t} else if (ref2 == null) {\n\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', `${ref1}^`, ref1);\n\t\t} else {\n\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', ref1, ref2);\n\t\t}\n\n\t\tif (!data) return undefined;\n\n\t\tconst diff = GitDiffParser.parse(data, options?.includeRawDiff);\n\t\treturn diff;\n\t}\n\n\t@log()\n\tasync getDiffForFile(uri: GitUri, ref1: string | undefined, ref2?: string): Promise<GitDiff | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tlet key = 'diff';\n\t\tif (ref1 != null) {\n\t\t\tkey += `:${ref1}`;\n\t\t}\n\t\tif (ref2 != null) {\n\t\t\tkey += `:${ref2}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedDiff = doc.state.getDiff(key);\n\t\t\t\tif (cachedDiff != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedDiff.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst encoding = await getEncoding(uri);\n\t\tconst promise = this.getDiffForFileCore(\n\t\t\turi.repoPath,\n\t\t\turi.fsPath,\n\t\t\tref1,\n\t\t\tref2,\n\t\t\t{ encoding: encoding },\n\t\t\tdoc,\n\t\t\tkey,\n\t\t\tscope,\n\t\t);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedDiff = {\n\t\t\t\titem: promise as Promise<GitDiff>,\n\t\t\t};\n\t\t\tdoc.state.setDiff(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getDiffForFileCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\tref1: string | undefined,\n\t\tref2: string | undefined,\n\t\toptions: { encoding?: string },\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitDiff | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.diff(root, relativePath, ref1, ref2, {\n\t\t\t\t...options,\n\t\t\t\tfilters: ['M'],\n\t\t\t\tlinesOfContext: 0,\n\t\t\t\trenames: true,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst diff = GitDiffParser.parse(data);\n\t\t\treturn diff;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected diff errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedDiff = {\n\t\t\t\t\titem: emptyPromise as Promise<GitDiff>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setDiff(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitDiff>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getDiffForFileContents']>({ args: { 1: '<contents>' } })\n\tasync getDiffForFileContents(uri: GitUri, ref: string, contents: string): Promise<GitDiff | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst key = `diff:${md5(contents)}`;\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedDiff = doc.state.getDiff(key);\n\t\t\t\tif (cachedDiff != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: ${key}`);\n\t\t\t\t\treturn cachedDiff.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: ${key}`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst encoding = await getEncoding(uri);\n\t\tconst promise = this.getDiffForFileContentsCore(\n\t\t\turi.repoPath,\n\t\t\turi.fsPath,\n\t\t\tref,\n\t\t\tcontents,\n\t\t\t{ encoding: encoding },\n\t\t\tdoc,\n\t\t\tkey,\n\t\t\tscope,\n\t\t);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedDiff = {\n\t\t\t\titem: promise as Promise<GitDiff>,\n\t\t\t};\n\t\t\tdoc.state.setDiff(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getDiffForFileContentsCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\tref: string,\n\t\tcontents: string,\n\t\toptions: { encoding?: string },\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitDiff | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.diff__contents(root, relativePath, ref, contents, {\n\t\t\t\t...options,\n\t\t\t\tfilters: ['M'],\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst diff = GitDiffParser.parse(data);\n\t\t\treturn diff;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected diff errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedDiff = {\n\t\t\t\t\titem: emptyPromise as Promise<GitDiff>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setDiff(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitDiff>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffForLine(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tref1: string | undefined,\n\t\tref2?: string,\n\t): Promise<GitDiffHunkLine | undefined> {\n\t\ttry {\n\t\t\tconst diff = await this.getDiffForFile(uri, ref1, ref2);\n\t\t\tif (diff == null) return undefined;\n\n\t\t\tconst line = editorLine + 1;\n\t\t\tconst hunk = diff.hunks.find(c => c.current.position.start <= line && c.current.position.end >= line);\n\t\t\tif (hunk == null) return undefined;\n\n\t\t\treturn hunk.lines[line - Math.min(hunk.current.position.start, hunk.previous.position.start)];\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffStatus(\n\t\trepoPath: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions?: { filters?: GitDiffFilter[]; similarityThreshold?: number },\n\t): Promise<GitFile[] | undefined> {\n\t\ttry {\n\t\t\tconst data = await this.git.diff__name_status(repoPath, ref1, ref2, {\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t\t...options,\n\t\t\t});\n\t\t\tif (!data) return undefined;\n\n\t\t\tconst files = GitDiffParser.parseNameStatus(data, repoPath);\n\t\t\treturn files == null || files.length === 0 ? undefined : files;\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getFileStatusForCommit(repoPath: string, uri: Uri, ref: string): Promise<GitFile | undefined> {\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return undefined;\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.show__name_status(root, relativePath, ref);\n\t\tif (!data) return undefined;\n\n\t\tconst files = GitDiffParser.parseNameStatus(data, repoPath);\n\t\tif (files == null || files.length === 0) return undefined;\n\n\t\treturn files[0];\n\t}\n\n\t@debug()\n\tasync getGitDir(repoPath: string): Promise<GitDir> {\n\t\tconst repo = this._repoInfoCache.get(repoPath);\n\t\tif (repo?.gitDir != null) return repo.gitDir;\n\n\t\tconst gitDirPaths = await this.git.rev_parse__git_dir(repoPath);\n\n\t\tlet gitDir: GitDir;\n\t\tif (gitDirPaths != null) {\n\t\t\tgitDir = {\n\t\t\t\turi: Uri.file(gitDirPaths.path),\n\t\t\t\tcommonUri: gitDirPaths.commonPath != null ? Uri.file(gitDirPaths.commonPath) : undefined,\n\t\t\t};\n\t\t} else {\n\t\t\tgitDir = {\n\t\t\t\turi: this.getAbsoluteUri('.git', repoPath),\n\t\t\t};\n\t\t}\n\t\tthis._repoInfoCache.set(repoPath, { ...repo, gitDir: gitDir });\n\n\t\treturn gitDir;\n\t}\n\n\t@debug()\n\tasync getLastFetchedTimestamp(repoPath: string): Promise<number | undefined> {\n\t\ttry {\n\t\t\tconst gitDir = await this.getGitDir(repoPath);\n\t\t\tconst stats = await workspace.fs.stat(Uri.joinPath(gitDir.uri, 'FETCH_HEAD'));\n\t\t\t// If the file is empty, assume the fetch failed, and don't update the timestamp\n\t\t\tif (stats.size > 0) return stats.mtime;\n\t\t} catch {}\n\n\t\treturn undefined;\n\t}\n\n\t@log()\n\tasync getLog(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tstatus?: null | 'name-status' | 'numstat' | 'stat';\n\t\t\tsince?: number | string;\n\t\t\tuntil?: number | string;\n\t\t\textraArgs?: string[];\n\t\t\tstdin?: string;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\t\tconst merges = options?.merges == null ? true : options.merges;\n\t\t\tconst ordering = options?.ordering ?? configuration.get('advanced.commitOrdering');\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst args = [\n\t\t\t\t`--format=${options?.all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`,\n\t\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t\t'-m',\n\t\t\t];\n\n\t\t\tif (options?.status !== null) {\n\t\t\t\targs.push(`--${options?.status ?? 'name-status'}`, '--full-history');\n\t\t\t}\n\t\t\tif (options?.all) {\n\t\t\t\targs.push('--all');\n\t\t\t}\n\t\t\tif (!merges) {\n\t\t\t\targs.push('--first-parent');\n\t\t\t}\n\t\t\tif (ordering) {\n\t\t\t\targs.push(`--${ordering}-order`);\n\t\t\t}\n\t\t\tif (options?.authors?.length) {\n\t\t\t\targs.push('--use-mailmap', ...options.authors.map(a => `--author=^${a.name} <${a.email}>$`));\n\t\t\t}\n\n\t\t\tlet hasMoreOverride;\n\n\t\t\tif (options?.since) {\n\t\t\t\thasMoreOverride = true;\n\t\t\t\targs.push(`--since=\"${options.since}\"`);\n\t\t\t}\n\t\t\tif (options?.until) {\n\t\t\t\thasMoreOverride = true;\n\t\t\t\targs.push(`--until=\"${options.until}\"`);\n\t\t\t}\n\t\t\tif (options?.extraArgs?.length) {\n\t\t\t\tif (\n\t\t\t\t\toptions.extraArgs.some(\n\t\t\t\t\t\targ => arg.startsWith('-n') || arg.startsWith('--until=') || arg.startsWith('--since='),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\thasMoreOverride = true;\n\t\t\t\t}\n\t\t\t\targs.push(...options.extraArgs);\n\t\t\t}\n\n\t\t\tif (limit) {\n\t\t\t\thasMoreOverride = undefined;\n\t\t\t\targs.push(`-n${limit + 1}`);\n\t\t\t}\n\n\t\t\tconst data = await this.git.log2(\n\t\t\t\trepoPath,\n\t\t\t\t{ configs: gitLogDefaultConfigsWithFiles, ref: options?.ref, stdin: options?.stdin },\n\t\t\t\t...args,\n\t\t\t);\n\n\t\t\t// const parser = GitLogParser.defaultParser;\n\n\t\t\t// const data = await this.git.log2(repoPath, options?.ref, {\n\t\t\t// \t...options,\n\t\t\t// \t// args: parser.arguments,\n\t\t\t// \tlimit: limit,\n\t\t\t// \tmerges: options?.merges == null ? true : options.merges,\n\t\t\t// \tordering: options?.ordering ?? configuration.get('advanced.commitOrdering'),\n\t\t\t// \tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t// });\n\n\t\t\t// const commits = [];\n\t\t\t// const entries = parser.parse(data);\n\t\t\t// for (const entry of entries) {\n\t\t\t// \tcommits.push(\n\t\t\t// \t\tnew GitCommit2(\n\t\t\t// \t\t\trepoPath,\n\t\t\t// \t\t\tentry.sha,\n\t\t\t// \t\t\tnew GitCommitIdentity(\n\t\t\t// \t\t\t\tentry.author,\n\t\t\t// \t\t\t\tentry.authorEmail,\n\t\t\t// \t\t\t\tnew Date((entry.authorDate as any) * 1000),\n\t\t\t// \t\t\t),\n\t\t\t// \t\t\tnew GitCommitIdentity(\n\t\t\t// \t\t\t\tentry.committer,\n\t\t\t// \t\t\t\tentry.committerEmail,\n\t\t\t// \t\t\t\tnew Date((entry.committerDate as any) * 1000),\n\t\t\t// \t\t\t),\n\t\t\t// \t\t\tentry.message.split('\\n', 1)[0],\n\t\t\t// \t\t\tentry.parents.split(' '),\n\t\t\t// \t\t\tentry.message,\n\t\t\t// \t\t\tentry.files.map(f => new GitFileChange(repoPath, f.path, f.status as any, f.originalPath)),\n\t\t\t// \t\t\t[],\n\t\t\t// \t\t),\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\tLogType.Log,\n\t\t\t\trepoPath,\n\t\t\t\tundefined,\n\t\t\t\toptions?.ref,\n\t\t\t\tawait this.getCurrentUser(repoPath),\n\t\t\t\tlimit,\n\t\t\t\tfalse,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\thasMoreOverride,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tlog.query = (limit: number | undefined) => this.getLog(repoPath, { ...options, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlet opts;\n\t\t\t\t\tif (options != null) {\n\t\t\t\t\t\tlet extraArgs;\n\t\t\t\t\t\t({ extraArgs, ...opts } = options);\n\t\t\t\t\t}\n\t\t\t\t\tlog.more = this.getLogMoreFn(log, opts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getLogRefsOnly(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tauthors?: GitUser[];\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<Set<string> | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\n\t\ttry {\n\t\t\tconst parser = createLogParserSingle('%H');\n\n\t\t\tconst data = await this.git.log(repoPath, options?.ref, {\n\t\t\t\tauthors: options?.authors,\n\t\t\t\targsOrFormat: parser.arguments,\n\t\t\t\tlimit: limit,\n\t\t\t\tmerges: options?.merges == null ? true : options.merges,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t\tsince: options?.since,\n\t\t\t\tordering: options?.ordering ?? configuration.get('advanced.commitOrdering'),\n\t\t\t});\n\n\t\t\tconst commits = new Set(parser.parse(data));\n\t\t\treturn commits;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getLogMoreFn(\n\t\tlog: GitLog,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t},\n\t): (limit: number | { until: string } | undefined) => Promise<GitLog> {\n\t\treturn async (limit: number | { until: string } | undefined) => {\n\t\t\tconst moreUntil = limit != null && typeof limit === 'object' ? limit.until : undefined;\n\t\t\tlet moreLimit = typeof limit === 'number' ? limit : undefined;\n\n\t\t\tif (moreUntil && some(log.commits.values(), c => c.ref === moreUntil)) {\n\t\t\t\treturn log;\n\t\t\t}\n\n\t\t\tmoreLimit = moreLimit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\t// If the log is for a range, then just get everything prior + more\n\t\t\tif (isRevisionRange(log.sha)) {\n\t\t\t\tconst moreLog = await this.getLog(log.repoPath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tlimit: moreLimit === 0 ? 0 : (options?.limit ?? 0) + moreLimit,\n\t\t\t\t});\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\treturn moreLog;\n\t\t\t}\n\n\t\t\tconst lastCommit = last(log.commits.values());\n\t\t\tconst ref = lastCommit?.ref;\n\n\t\t\t// If we were asked for all refs, use the last commit timestamp (plus a second) as a cursor\n\t\t\tlet timestamp: number | undefined;\n\t\t\tif (options?.all) {\n\t\t\t\tconst date = lastCommit?.committer.date;\n\t\t\t\t// Git only allows 1-second precision, so round up to the nearest second\n\t\t\t\ttimestamp = date != null ? Math.ceil(date.getTime() / 1000) + 1 : undefined;\n\t\t\t}\n\n\t\t\tlet moreLogCount;\n\t\t\tlet queryLimit = moreUntil == null ? moreLimit : 0;\n\t\t\tdo {\n\t\t\t\tconst moreLog = await this.getLog(log.repoPath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tlimit: queryLimit,\n\t\t\t\t\t...(timestamp\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tuntil: timestamp,\n\t\t\t\t\t\t\t\textraArgs: ['--boundary'],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: { ref: moreUntil == null ? `${ref}^` : `${moreUntil}^..${ref}^` }),\n\t\t\t\t});\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\tconst currentCount = log.commits.size;\n\t\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\t\tif (currentCount === commits.size && queryLimit !== 0) {\n\t\t\t\t\t// If we didn't find any new commits, we must have them all so return that we have everything\n\t\t\t\t\tif (moreLogCount === moreLog.commits.size) {\n\t\t\t\t\t\treturn { ...log, hasMore: false, more: undefined };\n\t\t\t\t\t}\n\n\t\t\t\t\tmoreLogCount = moreLog.commits.size;\n\t\t\t\t\tqueryLimit = queryLimit * 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (timestamp != null && ref != null && !moreLog.commits.has(ref)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t}\n\n\t\t\t\tconst mergedLog: GitLog = {\n\t\t\t\t\trepoPath: log.repoPath,\n\t\t\t\t\tcommits: commits,\n\t\t\t\t\tsha: log.sha,\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tcount: commits.size,\n\t\t\t\t\tlimit: moreUntil == null ? (log.limit ?? 0) + moreLimit : undefined,\n\t\t\t\t\thasMore: moreUntil == null ? moreLog.hasMore : true,\n\t\t\t\t\tstartingCursor: last(log.commits)?.[0],\n\t\t\t\t\tendingCursor: moreLog.endingCursor,\n\t\t\t\t\tpagedCommits: () => {\n\t\t\t\t\t\t// Remove any duplicates\n\t\t\t\t\t\tfor (const sha of log.commits.keys()) {\n\t\t\t\t\t\t\tmoreLog.commits.delete(sha);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn moreLog.commits;\n\t\t\t\t\t},\n\t\t\t\t\tquery: (limit: number | undefined) => this.getLog(log.repoPath, { ...options, limit: limit }),\n\t\t\t\t};\n\t\t\t\tif (mergedLog.hasMore) {\n\t\t\t\t\tmergedLog.more = this.getLogMoreFn(mergedLog, options);\n\t\t\t\t}\n\n\t\t\t\treturn mergedLog;\n\t\t\t} while (true);\n\t\t};\n\t}\n\n\t@log()\n\tasync getLogForFile(\n\t\trepoPath: string | undefined,\n\t\tpathOrUri: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tcursor?: string;\n\t\t\tforce?: boolean | undefined;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, repoPath);\n\n\t\tif (repoPath != null && repoPath === relativePath) {\n\t\t\tthrow new Error(`File name cannot match the repository path; path=${relativePath}`);\n\t\t}\n\n\t\toptions = { reverse: false, ...options };\n\n\t\tif (options.renames == null) {\n\t\t\toptions.renames = configuration.get('advanced.fileHistoryFollowsRenames');\n\t\t}\n\n\t\tlet key = 'log';\n\t\tif (options.ref != null) {\n\t\t\tkey += `:${options.ref}`;\n\t\t}\n\n\t\tif (options.all == null) {\n\t\t\toptions.all = configuration.get('advanced.fileHistoryShowAllBranches');\n\t\t}\n\t\tif (options.all) {\n\t\t\tkey += ':all';\n\t\t}\n\n\t\toptions.limit = options.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\tif (options.limit) {\n\t\t\tkey += `:n${options.limit}`;\n\t\t}\n\n\t\tif (options.renames) {\n\t\t\tkey += ':follow';\n\t\t}\n\n\t\tif (options.reverse) {\n\t\t\tkey += ':reverse';\n\t\t}\n\n\t\tif (options.since) {\n\t\t\tkey += `:since=${options.since}`;\n\t\t}\n\n\t\tif (options.skip) {\n\t\t\tkey += `:skip${options.skip}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(GitUri.fromFile(relativePath, repoPath, options.ref));\n\t\tif (!options.force && this.useCaching && options.range == null) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedLog = doc.state.getLog(key);\n\t\t\t\tif (cachedLog != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedLog.item;\n\t\t\t\t}\n\n\t\t\t\tif (options.ref != null || options.limit != null) {\n\t\t\t\t\t// Since we are looking for partial log, see if we have the log of the whole file\n\t\t\t\t\tconst cachedLog = doc.state.getLog(\n\t\t\t\t\t\t`log${options.renames ? ':follow' : ''}${options.reverse ? ':reverse' : ''}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (cachedLog != null) {\n\t\t\t\t\t\tif (options.ref == null) {\n\t\t\t\t\t\t\tLogger.debug(scope, `Cache hit: ~'${key}'`);\n\t\t\t\t\t\t\treturn cachedLog.item;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLogger.debug(scope, `Cache ?: '${key}'`);\n\t\t\t\t\t\tlet log = await cachedLog.item;\n\t\t\t\t\t\tif (log != null && !log.hasMore && log.commits.has(options.ref)) {\n\t\t\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\n\t\t\t\t\t\t\t// Create a copy of the log starting at the requested commit\n\t\t\t\t\t\t\tlet skip = true;\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tconst commits = new Map(\n\t\t\t\t\t\t\t\tfilterMapIterable<[string, GitCommit], [string, GitCommit]>(\n\t\t\t\t\t\t\t\t\tlog.commits.entries(),\n\t\t\t\t\t\t\t\t\t([ref, c]) => {\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\tif (ref !== options?.ref) return undefined;\n\t\t\t\t\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\tif (options?.limit != null && i > options.limit) {\n\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\treturn [ref, c];\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst opts = { ...options };\n\t\t\t\t\t\t\tlog = {\n\t\t\t\t\t\t\t\t...log,\n\t\t\t\t\t\t\t\tlimit: options.limit,\n\t\t\t\t\t\t\t\tcount: commits.size,\n\t\t\t\t\t\t\t\tcommits: commits,\n\t\t\t\t\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\t\t\t\t\tthis.getLogForFile(repoPath, pathOrUri, { ...opts, limit: limit }),\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\treturn log;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getLogForFileCore(repoPath, relativePath, options, doc, key, scope);\n\n\t\tif (doc.state != null && options.range == null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedLog = {\n\t\t\t\titem: promise as Promise<GitLog>,\n\t\t\t};\n\t\t\tdoc.state.setLog(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getLogForFileCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\t{\n\t\t\tref,\n\t\t\trange,\n\t\t\t...options\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitLog | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(path, repoPath, ref);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${path}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitLog>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tif (range != null && range.start.line > range.end.line) {\n\t\t\t\trange = new Range(range.end, range.start);\n\t\t\t}\n\n\t\t\tconst data = await this.git.log__file(root, relativePath, ref, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tfirstParent: options.renames,\n\t\t\t\tstartLine: range == null ? undefined : range.start.line + 1,\n\t\t\t\tendLine: range == null ? undefined : range.end.line + 1,\n\t\t\t});\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\t// If this is the log of a folder, parse it as a normal log rather than a file log\n\t\t\t\tisFolderGlob(relativePath) ? LogType.Log : LogType.LogFile,\n\t\t\t\troot,\n\t\t\t\trelativePath,\n\t\t\t\tref,\n\t\t\t\tawait this.getCurrentUser(root),\n\t\t\t\toptions.limit,\n\t\t\t\toptions.reverse ?? false,\n\t\t\t\trange,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tconst opts = { ...options, ref: ref, range: range };\n\t\t\t\tlog.query = (limit: number | undefined) =>\n\t\t\t\t\tthis.getLogForFile(repoPath, path, { ...opts, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlog.more = this.getLogForFileMoreFn(log, path, opts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected log errors\n\t\t\tif (document.state != null && range == null && !options.reverse) {\n\t\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedLog = {\n\t\t\t\t\titem: emptyPromise as Promise<GitLog>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setLog(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitLog>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getLogForFileMoreFn(\n\t\tlog: GitLog,\n\t\trelativePath: string,\n\t\toptions: {\n\t\t\tall?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t},\n\t): (limit: number | { until: string } | undefined) => Promise<GitLog> {\n\t\treturn async (limit: number | { until: string } | undefined) => {\n\t\t\tconst moreUntil = limit != null && typeof limit === 'object' ? limit.until : undefined;\n\t\t\tlet moreLimit = typeof limit === 'number' ? limit : undefined;\n\n\t\t\tif (moreUntil && some(log.commits.values(), c => c.ref === moreUntil)) {\n\t\t\t\treturn log;\n\t\t\t}\n\n\t\t\tmoreLimit = moreLimit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\tconst ref = last(log.commits.values())?.ref;\n\t\t\tconst moreLog = await this.getLogForFile(log.repoPath, relativePath, {\n\t\t\t\t...options,\n\t\t\t\tlimit: moreUntil == null ? moreLimit : 0,\n\t\t\t\tref: options.all ? undefined : moreUntil == null ? `${ref}^` : `${moreUntil}^..${ref}^`,\n\t\t\t\tskip: options.all ? log.count : undefined,\n\t\t\t});\n\t\t\t// If we can't find any more, assume we have everything\n\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\tconst mergedLog: GitLog = {\n\t\t\t\trepoPath: log.repoPath,\n\t\t\t\tcommits: commits,\n\t\t\t\tsha: log.sha,\n\t\t\t\trange: log.range,\n\t\t\t\tcount: commits.size,\n\t\t\t\tlimit: moreUntil == null ? (log.limit ?? 0) + moreLimit : undefined,\n\t\t\t\thasMore: moreUntil == null ? moreLog.hasMore : true,\n\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\tthis.getLogForFile(log.repoPath, relativePath, { ...options, limit: limit }),\n\t\t\t};\n\n\t\t\tif (options.renames) {\n\t\t\t\tconst renamed = find(\n\t\t\t\t\tmoreLog.commits.values(),\n\t\t\t\t\tc => Boolean(c.file?.originalPath) && c.file?.originalPath !== relativePath,\n\t\t\t\t);\n\t\t\t\trelativePath = renamed?.file?.originalPath ?? relativePath;\n\t\t\t}\n\n\t\t\tif (mergedLog.hasMore) {\n\t\t\t\tmergedLog.more = this.getLogForFileMoreFn(mergedLog, relativePath, options);\n\t\t\t}\n\n\t\t\treturn mergedLog;\n\t\t};\n\t}\n\n\t@log()\n\tasync getMergeBase(repoPath: string, ref1: string, ref2: string, options?: { forkPoint?: boolean }) {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tconst data = await this.git.merge_base(repoPath, ref1, ref2, options);\n\t\t\tif (data == null) return undefined;\n\n\t\t\treturn data.split('\\n')[0].trim() || undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tasync getMergeStatus(repoPath: string): Promise<GitMergeStatus | undefined> {\n\t\tlet status = this.useCaching ? this._mergeStatusCache.get(repoPath) : undefined;\n\t\tif (status === undefined) {\n\t\t\tconst merge = await this.git.rev_parse__verify(repoPath, 'MERGE_HEAD');\n\t\t\tif (merge != null) {\n\t\t\t\tconst [branch, mergeBase, possibleSourceBranches] = await Promise.all([\n\t\t\t\t\tthis.getBranch(repoPath),\n\t\t\t\t\tthis.getMergeBase(repoPath, 'MERGE_HEAD', 'HEAD'),\n\t\t\t\t\tthis.getCommitBranches(repoPath, 'MERGE_HEAD', { mode: 'pointsAt' }),\n\t\t\t\t]);\n\n\t\t\t\tstatus = {\n\t\t\t\t\ttype: 'merge',\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tmergeBase: mergeBase,\n\t\t\t\t\tHEAD: createReference(merge, repoPath, { refType: 'revision' }),\n\t\t\t\t\tcurrent: getReferenceFromBranch(branch!),\n\t\t\t\t\tincoming:\n\t\t\t\t\t\tpossibleSourceBranches?.length === 1\n\t\t\t\t\t\t\t? createReference(possibleSourceBranches[0], repoPath, {\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: possibleSourceBranches[0],\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._mergeStatusCache.set(repoPath, status ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn status ?? undefined;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getRebaseStatus(repoPath: string): Promise<GitRebaseStatus | undefined> {\n\t\tlet status = this.useCaching ? this._rebaseStatusCache.get(repoPath) : undefined;\n\t\tif (status === undefined) {\n\t\t\tconst rebase = await this.git.rev_parse__verify(repoPath, 'REBASE_HEAD');\n\t\t\tif (rebase != null) {\n\t\t\t\tlet [mergeBase, branch, onto, stepsNumber, stepsMessage, stepsTotal] = await Promise.all([\n\t\t\t\t\tthis.getMergeBase(repoPath, 'REBASE_HEAD', 'HEAD'),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'head-name']),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'onto']),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'msgnum'], { numeric: true }),\n\t\t\t\t\tthis.git\n\t\t\t\t\t\t.readDotGitFile(repoPath, ['rebase-merge', 'message'], { throw: true })\n\t\t\t\t\t\t.catch(() => this.git.readDotGitFile(repoPath, ['rebase-merge', 'message-squashed'])),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'end'], { numeric: true }),\n\t\t\t\t]);\n\n\t\t\t\tif (branch == null || onto == null) return undefined;\n\n\t\t\t\tif (branch.startsWith('refs/heads/')) {\n\t\t\t\t\tbranch = branch.substr(11).trim();\n\t\t\t\t}\n\n\t\t\t\tconst possibleSourceBranches = await this.getCommitBranches(repoPath, onto, { mode: 'pointsAt' });\n\n\t\t\t\tlet possibleSourceBranch: string | undefined;\n\t\t\t\tfor (const b of possibleSourceBranches) {\n\t\t\t\t\tif (b.startsWith('(no branch, rebasing')) continue;\n\n\t\t\t\t\tpossibleSourceBranch = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstatus = {\n\t\t\t\t\ttype: 'rebase',\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tmergeBase: mergeBase,\n\t\t\t\t\tHEAD: createReference(rebase, repoPath, { refType: 'revision' }),\n\t\t\t\t\tonto: createReference(onto, repoPath, { refType: 'revision' }),\n\t\t\t\t\tcurrent:\n\t\t\t\t\t\tpossibleSourceBranch != null\n\t\t\t\t\t\t\t? createReference(possibleSourceBranch, repoPath, {\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: possibleSourceBranch,\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: undefined,\n\n\t\t\t\t\tincoming: createReference(branch, repoPath, {\n\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\tname: branch,\n\t\t\t\t\t\tremote: false,\n\t\t\t\t\t}),\n\t\t\t\t\tsteps: {\n\t\t\t\t\t\tcurrent: {\n\t\t\t\t\t\t\tnumber: stepsNumber ?? 0,\n\t\t\t\t\t\t\tcommit: createReference(rebase, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'revision',\n\t\t\t\t\t\t\t\tmessage: stepsMessage,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttotal: stepsTotal ?? 0,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._rebaseStatusCache.set(repoPath, status ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn status ?? undefined;\n\t}\n\n\t@log()\n\tasync getNextComparisonUris(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<NextComparisonUrisResult | undefined> {\n\t\t// If we have no ref (or staged ref) there is no next commit\n\t\tif (!ref) return undefined;\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tif (isUncommittedStaged(ref)) {\n\t\t\treturn {\n\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t};\n\t\t}\n\n\t\tconst next = await this.getNextUri(repoPath, uri, ref, skip);\n\t\tif (next == null) {\n\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\tif (status != null) {\n\t\t\t\t// If the file is staged, diff with the staged version\n\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tcurrent:\n\t\t\t\tskip === 0\n\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t: (await this.getNextUri(repoPath, uri, ref, skip - 1))!,\n\t\t\tnext: next,\n\t\t};\n\t}\n\n\t@log()\n\tprivate async getNextUri(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref?: string,\n\t\tskip: number = 0,\n\t\t// editorLine?: number\n\t): Promise<GitUri | undefined> {\n\t\t// If we have no ref (or staged ref) there is no next commit\n\t\tif (!ref || isUncommittedStaged(ref)) return undefined;\n\n\t\tlet filters: GitDiffFilter[] | undefined;\n\t\tif (ref === deletedOrMissing) {\n\t\t\t// If we are trying to move next from a deleted or missing ref then get the first commit\n\t\t\tref = undefined;\n\t\t\tfilters = ['A'];\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\t\tlet data = await this.git.log__file(repoPath, relativePath, ref, {\n\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\tfileMode: 'simple',\n\t\t\tfilters: filters,\n\t\t\tlimit: skip + 1,\n\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\treverse: true,\n\t\t\t// startLine: editorLine != null ? editorLine + 1 : undefined,\n\t\t});\n\t\tif (data == null || data.length === 0) return undefined;\n\n\t\tconst [nextRef, file, status] = GitLogParser.parseSimple(data, skip);\n\t\t// If the file was deleted, check for a possible rename\n\t\tif (status === 'D') {\n\t\t\tdata = await this.git.log__file(repoPath, '.', nextRef, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfilters: ['R', 'C'],\n\t\t\t\tlimit: 1,\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t// startLine: editorLine != null ? editorLine + 1 : undefined\n\t\t\t});\n\t\t\tif (data == null || data.length === 0) {\n\t\t\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, nextRef);\n\t\t\t}\n\n\t\t\tconst [nextRenamedRef, renamedFile] = GitLogParser.parseSimpleRenamed(data, file ?? relativePath);\n\t\t\treturn GitUri.fromFile(\n\t\t\t\trenamedFile ?? file ?? relativePath,\n\t\t\t\trepoPath,\n\t\t\t\tnextRenamedRef ?? nextRef ?? deletedOrMissing,\n\t\t\t);\n\t\t}\n\n\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, nextRef);\n\t}\n\n\t@log()\n\tasync getOldestUnpushedRefForFile(repoPath: string, uri: Uri): Promise<string | undefined> {\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.log__file(root, relativePath, '@{u}..', {\n\t\t\targsOrFormat: ['-z', '--format=%H'],\n\t\t\tfileMode: 'none',\n\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\trenames: true,\n\t\t});\n\t\tif (!data) return undefined;\n\n\t\t// -2 to skip the ending null\n\t\tconst index = data.lastIndexOf('\\0', data.length - 2);\n\t\treturn index === -1 ? undefined : data.slice(index + 1, data.length - 2);\n\t}\n\n\t@log()\n\tasync getPreviousComparisonUris(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t\tfirstParent: boolean = false,\n\t): Promise<PreviousComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\t// If we are at the working tree (i.e. no ref), we need to dig deeper to figure out where to go\n\t\tif (!ref) {\n\t\t\t// First, check the file status to see if there is anything staged\n\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\tif (status != null) {\n\t\t\t\t// If the file is staged with working changes, diff working with staged (index)\n\t\t\t\t// If the file is staged without working changes, diff staged with HEAD\n\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\t// Backs up to get to HEAD\n\t\t\t\t\tif (status.workingTreeStatus == null) {\n\t\t\t\t\t\tskip++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (skip === 0) {\n\t\t\t\t\t\t// Diff working with staged\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\tprevious: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t// Diff staged with HEAD (or prior if more skips)\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, ref, skip - 1, undefined, firstParent),\n\t\t\t\t\t};\n\t\t\t\t} else if (status.workingTreeStatus != null) {\n\t\t\t\t\tif (skip === 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, undefined, firstParent),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (skip === 0) {\n\t\t\t\tskip++;\n\t\t\t}\n\t\t}\n\t\t// If we are at the index (staged), diff staged with HEAD\n\t\telse if (isUncommittedStaged(ref)) {\n\t\t\tconst current =\n\t\t\t\tskip === 0\n\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t: (await this.getPreviousUri(repoPath, uri, undefined, skip - 1, undefined, firstParent))!;\n\t\t\tif (current == null || current.sha === deletedOrMissing) return undefined;\n\n\t\t\treturn {\n\t\t\t\tcurrent: current,\n\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, undefined, firstParent),\n\t\t\t};\n\t\t}\n\n\t\t// If we are at a commit, diff commit with previous\n\t\tconst current =\n\t\t\tskip === 0\n\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t: (await this.getPreviousUri(repoPath, uri, ref, skip - 1, undefined, firstParent))!;\n\t\tif (current == null || current.sha === deletedOrMissing) return undefined;\n\n\t\treturn {\n\t\t\tcurrent: current,\n\t\t\tprevious: await this.getPreviousUri(repoPath, uri, ref, skip, undefined, firstParent),\n\t\t};\n\t}\n\n\t@log()\n\tasync getPreviousComparisonUrisForLine(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<PreviousLineComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tlet relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tlet previous;\n\n\t\t// If we are at the working tree (i.e. no ref), we need to dig deeper to figure out where to go\n\t\tif (!ref) {\n\t\t\t// First, check the blame on the current line to see if there are any working/staged changes\n\t\t\tconst gitUri = new GitUri(uri, repoPath);\n\n\t\t\tconst document = await workspace.openTextDocument(uri);\n\t\t\tconst blameLine = document.isDirty\n\t\t\t\t? await this.getBlameForLineContents(gitUri, editorLine, document.getText())\n\t\t\t\t: await this.getBlameForLine(gitUri, editorLine);\n\t\t\tif (blameLine == null) return undefined;\n\n\t\t\t// If line is uncommitted, we need to dig deeper to figure out where to go (because blame can't be trusted)\n\t\t\tif (blameLine.commit.isUncommitted) {\n\t\t\t\t// If the document is dirty (unsaved), use the status to determine where to go\n\t\t\t\tif (document.isDirty) {\n\t\t\t\t\t// Check the file status to see if there is anything staged\n\t\t\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t// If the file is staged, diff working with staged (index)\n\t\t\t\t\t\t// If the file is not staged, diff working with HEAD\n\t\t\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\t\t\t// Diff working with staged\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\t\tprevious: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\t\t\tline: editorLine,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Diff working with HEAD (or prior if more skips)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, editorLine),\n\t\t\t\t\t\tline: editorLine,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// First, check if we have a diff in the working tree\n\t\t\t\tlet hunkLine = await this.getDiffForLine(gitUri, editorLine, undefined);\n\t\t\t\tif (hunkLine == null) {\n\t\t\t\t\t// Next, check if we have a diff in the index (staged)\n\t\t\t\t\thunkLine = await this.getDiffForLine(gitUri, editorLine, undefined, uncommittedStaged);\n\n\t\t\t\t\tif (hunkLine != null) {\n\t\t\t\t\t\tref = uncommittedStaged;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tskip++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If line is committed, diff with line ref with previous\n\t\t\telse {\n\t\t\t\tref = blameLine.commit.sha;\n\t\t\t\trelativePath = blameLine.commit.file?.path ?? blameLine.commit.file?.originalPath ?? relativePath;\n\t\t\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\t\t\teditorLine = blameLine.line.originalLine - 1;\n\n\t\t\t\tif (skip === 0 && blameLine.commit.file?.previousSha) {\n\t\t\t\t\tprevious = GitUri.fromFile(relativePath, repoPath, blameLine.commit.file.previousSha);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (isUncommittedStaged(ref)) {\n\t\t\t\tconst current =\n\t\t\t\t\tskip === 0\n\t\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t\t: (await this.getPreviousUri(repoPath, uri, undefined, skip - 1, editorLine))!;\n\t\t\t\tif (current.sha === deletedOrMissing) return undefined;\n\n\t\t\t\treturn {\n\t\t\t\t\tcurrent: current,\n\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, editorLine),\n\t\t\t\t\tline: editorLine,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst gitUri = new GitUri(uri, { repoPath: repoPath, sha: ref });\n\t\t\tconst blameLine = await this.getBlameForLine(gitUri, editorLine);\n\t\t\tif (blameLine == null) return undefined;\n\n\t\t\t// Diff with line ref with previous\n\t\t\tref = blameLine.commit.sha;\n\t\t\trelativePath = blameLine.commit.file?.path ?? blameLine.commit.file?.originalPath ?? relativePath;\n\t\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\t\teditorLine = blameLine.line.originalLine - 1;\n\n\t\t\tif (skip === 0 && blameLine.commit.file?.previousSha) {\n\t\t\t\tprevious = GitUri.fromFile(relativePath, repoPath, blameLine.commit.file.previousSha);\n\t\t\t}\n\t\t}\n\n\t\tconst current =\n\t\t\tskip === 0\n\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t: (await this.getPreviousUri(repoPath, uri, ref, skip - 1, editorLine))!;\n\t\tif (current.sha === deletedOrMissing) return undefined;\n\n\t\treturn {\n\t\t\tcurrent: current,\n\t\t\tprevious: previous ?? (await this.getPreviousUri(repoPath, uri, ref, skip, editorLine)),\n\t\t\tline: editorLine,\n\t\t};\n\t}\n\n\t@log()\n\tprivate async getPreviousUri(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref?: string,\n\t\tskip: number = 0,\n\t\teditorLine?: number,\n\t\tfirstParent: boolean = false,\n\t): Promise<GitUri | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tif (ref === uncommitted) {\n\t\t\tref = undefined;\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\t// TODO: Add caching\n\t\tlet data;\n\t\ttry {\n\t\t\tdata = await this.git.log__file(repoPath, relativePath, ref, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfirstParent: firstParent,\n\t\t\t\tlimit: skip + 2,\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\tstartLine: editorLine != null ? editorLine + 1 : undefined,\n\t\t\t});\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t// If the line count is invalid just fallback to the most recent commit\n\t\t\tif ((ref == null || isUncommittedStaged(ref)) && GitErrors.invalidLineCount.test(msg)) {\n\t\t\t\tif (ref == null) {\n\t\t\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\t\t\tif (status?.indexStatus != null) {\n\t\t\t\t\t\treturn GitUri.fromFile(relativePath, repoPath, uncommittedStaged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tref = await this.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t});\n\t\t\t\treturn GitUri.fromFile(relativePath, repoPath, ref ?? deletedOrMissing);\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tthrow ex;\n\t\t}\n\t\tif (data == null || data.length === 0) return undefined;\n\n\t\tconst [previousRef, file] = GitLogParser.parseSimple(data, skip, ref);\n\t\t// If the previous ref matches the ref we asked for assume we are at the end of the history\n\t\tif (ref != null && ref === previousRef) return undefined;\n\n\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, previousRef ?? deletedOrMissing);\n\t}\n\n\t@log()\n\tasync getIncomingActivity(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitReflog | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\ttry {\n\t\t\t// Pass a much larger limit to reflog, because we aggregate the data and we won't know how many lines we'll need\n\t\t\tconst data = await this.git.reflog(repoPath, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tlimit: limit * 100,\n\t\t\t});\n\t\t\tif (data == null) return undefined;\n\n\t\t\tconst reflog = GitReflogParser.parse(data, repoPath, reflogCommands, limit, limit * 100);\n\t\t\tif (reflog?.hasMore) {\n\t\t\t\treflog.more = this.getReflogMoreFn(reflog, options);\n\t\t\t}\n\n\t\t\treturn reflog;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getReflogMoreFn(\n\t\treflog: GitReflog,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): (limit: number) => Promise<GitReflog> {\n\t\treturn async (limit: number | undefined) => {\n\t\t\tlimit = limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\tconst moreLog = await this.getIncomingActivity(reflog.repoPath, {\n\t\t\t\t...options,\n\t\t\t\tlimit: limit,\n\t\t\t\tskip: reflog.total,\n\t\t\t});\n\t\t\tif (moreLog == null) {\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\treturn { ...reflog, hasMore: false, more: undefined };\n\t\t\t}\n\n\t\t\tconst mergedLog: GitReflog = {\n\t\t\t\trepoPath: reflog.repoPath,\n\t\t\t\trecords: [...reflog.records, ...moreLog.records],\n\t\t\t\tcount: reflog.count + moreLog.count,\n\t\t\t\ttotal: reflog.total + moreLog.total,\n\t\t\t\tlimit: (reflog.limit ?? 0) + limit,\n\t\t\t\thasMore: moreLog.hasMore,\n\t\t\t};\n\t\t\tif (mergedLog.hasMore) {\n\t\t\t\tmergedLog.more = this.getReflogMoreFn(mergedLog, options);\n\t\t\t}\n\n\t\t\treturn mergedLog;\n\t\t};\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getRemotes(\n\t\trepoPath: string | undefined,\n\t\toptions?: { providers?: RemoteProviders; sort?: boolean },\n\t): Promise<GitRemote[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst providers = options?.providers ?? loadRemoteProviders(configuration.get('remotes', null));\n\n\t\ttry {\n\t\t\tconst data = await this.git.remote(repoPath);\n\t\t\tconst remotes = GitRemoteParser.parse(data, repoPath, getRemoteProviderMatcher(this.container, providers));\n\t\t\tif (remotes == null) return [];\n\n\t\t\tif (options?.sort) {\n\t\t\t\tGitRemote.sort(remotes);\n\t\t\t}\n\n\t\t\treturn remotes;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tgetRevisionContent(repoPath: string, path: string, ref: string): Promise<Uint8Array | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\treturn this.git.show<Buffer>(root, relativePath, ref, { encoding: 'buffer' });\n\t}\n\n\t@gate()\n\t@log()\n\tasync getStash(repoPath: string | undefined): Promise<GitStash | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tlet stash = this.useCaching ? this._stashesCache.get(repoPath) : undefined;\n\t\tif (stash === undefined) {\n\t\t\tconst parser = createLogParserWithFiles<{\n\t\t\t\tsha: string;\n\t\t\t\tdate: string;\n\t\t\t\tcommittedDate: string;\n\t\t\t\tparents: string;\n\t\t\t\tstashName: string;\n\t\t\t\tsummary: string;\n\t\t\t}>({\n\t\t\t\tsha: '%H',\n\t\t\t\tdate: '%at',\n\t\t\t\tcommittedDate: '%ct',\n\t\t\t\tparents: '%P',\n\t\t\t\tstashName: '%gd',\n\t\t\t\tsummary: '%gs',\n\t\t\t});\n\t\t\tconst data = await this.git.stash__list(repoPath, {\n\t\t\t\targs: parser.arguments,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst commits = new Map<string, GitStashCommit>();\n\n\t\t\tconst stashes = parser.parse(data);\n\t\t\tfor (const s of stashes) {\n\t\t\t\tlet onRef;\n\t\t\t\tlet summary;\n\t\t\t\tlet message;\n\n\t\t\t\tconst match = stashSummaryRegex.exec(s.summary);\n\t\t\t\tif (match?.groups != null) {\n\t\t\t\t\tonRef = match.groups.onref;\n\t\t\t\t\tsummary = match.groups.summary.trim();\n\n\t\t\t\t\tif (summary.length === 0) {\n\t\t\t\t\t\tmessage = 'WIP';\n\t\t\t\t\t} else if (match.groups.wip) {\n\t\t\t\t\t\tmessage = `WIP: ${summary}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage = summary;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmessage = s.summary.trim();\n\t\t\t\t}\n\n\t\t\t\tcommits.set(\n\t\t\t\t\ts.sha,\n\t\t\t\t\tnew GitCommit(\n\t\t\t\t\t\tthis.container,\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\ts.sha,\n\t\t\t\t\t\tnew GitCommitIdentity('You', undefined, new Date((s.date as any) * 1000)),\n\t\t\t\t\t\tnew GitCommitIdentity('You', undefined, new Date((s.committedDate as any) * 1000)),\n\t\t\t\t\t\tmessage.split('\\n', 1)[0] ?? '',\n\t\t\t\t\t\ts.parents.split(' '),\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\ts.files?.map(\n\t\t\t\t\t\t\tf => new GitFileChange(repoPath, f.path, f.status as GitFileStatus, f.originalPath),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t[],\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\ts.stashName,\n\t\t\t\t\t\tonRef,\n\t\t\t\t\t) as GitStashCommit,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tstash = { repoPath: repoPath, commits: commits };\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._stashesCache.set(repoPath, stash ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn stash ?? undefined;\n\t}\n\n\t@log()\n\tasync getStatusForFile(repoPath: string, uri: Uri): Promise<GitStatusFile | undefined> {\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.status__file(root, relativePath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, root, porcelainVersion);\n\t\tif (status == null || !status.files.length) return undefined;\n\n\t\treturn status.files[0];\n\t}\n\n\t@log()\n\tasync getStatusForFiles(repoPath: string, pathOrGlob: Uri): Promise<GitStatusFile[] | undefined> {\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst [relativePath, root] = splitPath(pathOrGlob, repoPath);\n\n\t\tconst data = await this.git.status__file(root, relativePath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, root, porcelainVersion);\n\t\tif (status == null || !status.files.length) return [];\n\n\t\treturn status.files;\n\t}\n\n\t@log()\n\tasync getStatusForRepo(repoPath: string | undefined): Promise<GitStatus | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst data = await this.git.status(repoPath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, repoPath, porcelainVersion);\n\n\t\tif (status?.detached) {\n\t\t\tconst rebaseStatus = await this.getRebaseStatus(repoPath);\n\t\t\tif (rebaseStatus != null) {\n\t\t\t\treturn new GitStatus(\n\t\t\t\t\trepoPath,\n\t\t\t\t\trebaseStatus.incoming.name,\n\t\t\t\t\tstatus.sha,\n\t\t\t\t\tstatus.files,\n\t\t\t\t\tstatus.state,\n\t\t\t\t\tstatus.upstream,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn status;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getTags(\n\t\trepoPath: string | undefined,\n\t\toptions?: { cursor?: string; filter?: (t: GitTag) => boolean; sort?: boolean | TagSortOptions },\n\t): Promise<PagedResult<GitTag>> {\n\t\tif (repoPath == null) return emptyPagedResult;\n\n\t\tlet resultsPromise = this.useCaching ? this._tagsCache.get(repoPath) : undefined;\n\t\tif (resultsPromise == null) {\n\t\t\tasync function load(this: LocalGitProvider): Promise<PagedResult<GitTag>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.git.tag(repoPath!);\n\t\t\t\t\treturn { values: GitTagParser.parse(data, repoPath!) ?? [] };\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._tagsCache.delete(repoPath!);\n\n\t\t\t\t\treturn emptyPagedResult;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresultsPromise = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._tagsCache.set(repoPath, resultsPromise);\n\t\t\t}\n\t\t}\n\n\t\tlet result = await resultsPromise;\n\t\tif (options?.filter != null) {\n\t\t\tresult = {\n\t\t\t\t...result,\n\t\t\t\tvalues: result.values.filter(options.filter),\n\t\t\t};\n\t\t}\n\n\t\tif (options?.sort) {\n\t\t\tsortTags(result.values, typeof options.sort === 'boolean' ? undefined : options.sort);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@log()\n\tasync getTreeEntryForRevision(repoPath: string, path: string, ref: string): Promise<GitTreeEntry | undefined> {\n\t\tif (repoPath == null || !path) return undefined;\n\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\tconst data = await this.git.ls_tree(root, ref, relativePath);\n\t\tconst trees = GitTreeParser.parse(data);\n\t\treturn trees?.length ? trees[0] : undefined;\n\t}\n\n\t@log()\n\tasync getTreeForRevision(repoPath: string, ref: string): Promise<GitTreeEntry[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst data = await this.git.ls_tree(repoPath, ref);\n\t\treturn GitTreeParser.parse(data) ?? [];\n\t}\n\n\t@log()\n\tasync getUniqueRepositoryId(repoPath: string): Promise<string | undefined> {\n\t\tconst data = await this.git.rev_list(repoPath, 'HEAD', { maxParents: 0 });\n\t\treturn data?.[0];\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasBranchOrTag(\n\t\trepoPath: string | undefined,\n\t\toptions?: {\n\t\t\tfilter?: { branches?: (b: GitBranch) => boolean; tags?: (t: GitTag) => boolean };\n\t\t},\n\t) {\n\t\tconst [{ values: branches }, { values: tags }] = await Promise.all([\n\t\t\tthis.getBranches(repoPath, {\n\t\t\t\tfilter: options?.filter?.branches,\n\t\t\t\tsort: false,\n\t\t\t}),\n\t\t\tthis.getTags(repoPath, {\n\t\t\t\tfilter: options?.filter?.tags,\n\t\t\t\tsort: false,\n\t\t\t}),\n\t\t]);\n\n\t\treturn branches.length !== 0 || tags.length !== 0;\n\t}\n\n\t@log()\n\tasync hasCommitBeenPushed(repoPath: string, ref: string): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\treturn this.git.merge_base__is_ancestor(repoPath, ref, '@{u}');\n\t}\n\n\thasUnsafeRepositories(): boolean {\n\t\treturn this.unsafePaths.size !== 0;\n\t}\n\n\tisTrackable(uri: Uri): boolean {\n\t\treturn this.supportedSchemes.has(uri.scheme);\n\t}\n\n\tasync isTracked(uri: Uri): Promise<boolean> {\n\t\treturn (await this.isTrackedPrivate(uri)) != null;\n\t}\n\n\tprivate async isTrackedPrivate(uri: Uri | GitUri): Promise<[string, string] | undefined>;\n\tprivate async isTrackedPrivate(\n\t\tpath: string,\n\t\trepoPath?: string,\n\t\tref?: string,\n\t): Promise<[string, string] | undefined>;\n\t@log<LocalGitProvider['isTrackedPrivate']>({ exit: tracked => `returned ${Boolean(tracked)}` })\n\tprivate async isTrackedPrivate(\n\t\tpathOrUri: string | Uri | GitUri,\n\t\trepoPath?: string,\n\t\tref?: string,\n\t): Promise<[string, string] | undefined> {\n\t\tlet relativePath: string;\n\t\tlet repository: Repository | undefined;\n\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\t\trepository = this.container.git.getRepository(Uri.file(pathOrUri));\n\t\t\trepoPath = repoPath || repository?.path;\n\n\t\t\t[relativePath, repoPath] = splitPath(pathOrUri, repoPath);\n\t\t} else {\n\t\t\tif (!this.isTrackable(pathOrUri)) return undefined;\n\n\t\t\tif (pathOrUri instanceof GitUri) {\n\t\t\t\t// Always use the ref of the GitUri\n\t\t\t\tref = pathOrUri.sha;\n\t\t\t\tif (ref === deletedOrMissing) return undefined;\n\t\t\t}\n\n\t\t\trepository = this.container.git.getRepository(pathOrUri);\n\t\t\trepoPath = repoPath || repository?.path;\n\n\t\t\t[relativePath, repoPath] = splitPath(pathOrUri, repoPath);\n\t\t}\n\n\t\tconst path = repoPath ? `${repoPath}/${relativePath}` : relativePath;\n\n\t\tlet key = path;\n\t\tkey = `${ref ?? ''}:${key.startsWith('/') ? key : `/${key}`}`;\n\n\t\tlet tracked = this._trackedPaths.get(key);\n\t\tif (tracked != null) return tracked;\n\n\t\ttracked = this.isTrackedCore(path, relativePath, repoPath ?? '', ref, repository);\n\t\tthis._trackedPaths.set(key, tracked);\n\n\t\ttracked = await tracked;\n\t\tthis._trackedPaths.set(key, tracked);\n\t\treturn tracked;\n\t}\n\n\t@debug()\n\tprivate async isTrackedCore(\n\t\tpath: string,\n\t\trelativePath: string,\n\t\trepoPath: string,\n\t\tref: string | undefined,\n\t\trepository: Repository | undefined,\n\t): Promise<[string, string] | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (!repoPath) {\n\t\t\t\t\t[relativePath, repoPath] = splitPath(path, '', true);\n\t\t\t\t}\n\n\t\t\t\t// Even if we have a ref, check first to see if the file exists (that way the cache will be better reused)\n\t\t\t\tlet tracked = Boolean(await this.git.ls_files(repoPath, relativePath));\n\t\t\t\tif (tracked) return [relativePath, repoPath];\n\n\t\t\t\tif (repoPath) {\n\t\t\t\t\tconst [newRelativePath, newRepoPath] = splitPath(path, '', true);\n\t\t\t\t\tif (newRelativePath !== relativePath) {\n\t\t\t\t\t\t// If we didn't find it, check it as close to the file as possible (will find nested repos)\n\t\t\t\t\t\ttracked = Boolean(await this.git.ls_files(newRepoPath, newRelativePath));\n\t\t\t\t\t\tif (tracked) {\n\t\t\t\t\t\t\trepository = await this.container.git.getOrOpenRepository(Uri.file(path), {\n\t\t\t\t\t\t\t\tdetectNested: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (repository != null) {\n\t\t\t\t\t\t\t\treturn splitPath(path, repository.path);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn [newRelativePath, newRepoPath];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!tracked && ref && !isUncommitted(ref)) {\n\t\t\t\t\ttracked = Boolean(await this.git.ls_files(repoPath, relativePath, { ref: ref }));\n\t\t\t\t\t// If we still haven't found this file, make sure it wasn't deleted in that ref (i.e. check the previous)\n\t\t\t\t\tif (!tracked) {\n\t\t\t\t\t\ttracked = Boolean(await this.git.ls_files(repoPath, relativePath, { ref: `${ref}^` }));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Since the file isn't tracked, make sure it isn't part of a nested repository we don't know about yet\n\t\t\t\tif (!tracked) {\n\t\t\t\t\tif (repository != null) {\n\t\t\t\t\t\t// Don't look for a nested repository if the file isn't at least one folder deep\n\t\t\t\t\t\tconst index = relativePath.indexOf('/');\n\t\t\t\t\t\tif (index < 0 || index === relativePath.length - 1) return undefined;\n\n\t\t\t\t\t\tconst nested = await this.container.git.getOrOpenRepository(Uri.file(path), {\n\t\t\t\t\t\t\tdetectNested: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (nested != null && nested !== repository) {\n\t\t\t\t\t\t\t[relativePath, repoPath] = splitPath(path, repository.path);\n\t\t\t\t\t\t\trepository = undefined;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn [relativePath, repoPath];\n\t\t\t}\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffTool(repoPath?: string): Promise<string | undefined> {\n\t\treturn (\n\t\t\t(await this.git.config__get('diff.guitool', repoPath, { local: true })) ??\n\t\t\tthis.git.config__get('diff.tool', repoPath, { local: true })\n\t\t);\n\t}\n\n\t@log()\n\tasync openDiffTool(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\toptions?: { ref1?: string; ref2?: string; staged?: boolean; tool?: string },\n\t): Promise<void> {\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\ttry {\n\t\t\tlet tool = options?.tool;\n\t\t\tif (!tool) {\n\t\t\t\tconst scope = getLogScope();\n\n\t\t\t\ttool = configuration.get('advanced.externalDiffTool') || (await this.getDiffTool(root));\n\t\t\t\tif (tool == null) throw new Error('No diff tool found');\n\n\t\t\t\tLogger.log(scope, `Using tool=${tool}`);\n\t\t\t}\n\n\t\t\tawait this.git.difftool(root, relativePath, tool, options);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (msg === 'No diff tool found' || /Unknown .+? tool/.test(msg)) {\n\t\t\t\tconst viewDocs = 'View Git Docs';\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to open changes because the specified diff tool cannot be found or no Git diff tool is configured',\n\t\t\t\t\tviewDocs,\n\t\t\t\t);\n\t\t\t\tif (result === viewDocs) {\n\t\t\t\t\tvoid env.openExternal(\n\t\t\t\t\t\tUri.parse('https://git-scm.com/docs/git-config#Documentation/git-config.txt-difftool'),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, 'openDiffTool');\n\t\t\tvoid showGenericErrorMessage('Unable to open compare');\n\t\t}\n\t}\n\n\t@log()\n\tasync openDirectoryCompare(repoPath: string, ref1: string, ref2?: string, tool?: string): Promise<void> {\n\t\ttry {\n\t\t\tif (!tool) {\n\t\t\t\tconst scope = getLogScope();\n\n\t\t\t\ttool = configuration.get('advanced.externalDirectoryDiffTool') || (await this.getDiffTool(repoPath));\n\t\t\t\tif (tool == null) throw new Error('No diff tool found');\n\n\t\t\t\tLogger.log(scope, `Using tool=${tool}`);\n\t\t\t}\n\n\t\t\tawait this.git.difftool__dir_diff(repoPath, tool, ref1, ref2);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (msg === 'No diff tool found' || /Unknown .+? tool/.test(msg)) {\n\t\t\t\tconst viewDocs = 'View Git Docs';\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to open directory compare because the specified diff tool cannot be found or no Git diff tool is configured',\n\t\t\t\t\tviewDocs,\n\t\t\t\t);\n\t\t\t\tif (result === viewDocs) {\n\t\t\t\t\tvoid env.openExternal(\n\t\t\t\t\t\tUri.parse('https://git-scm.com/docs/git-config#Documentation/git-config.txt-difftool'),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, 'openDirectoryCompare');\n\t\t\tvoid showGenericErrorMessage('Unable to open directory compare');\n\t\t}\n\t}\n\n\t@log()\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\tpathOrUri?: string | Uri,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t) {\n\t\tif (\n\t\t\t!ref ||\n\t\t\tref === deletedOrMissing ||\n\t\t\t(pathOrUri == null && isSha(ref)) ||\n\t\t\t(pathOrUri != null && isUncommitted(ref))\n\t\t) {\n\t\t\treturn ref;\n\t\t}\n\n\t\tif (pathOrUri == null) {\n\t\t\t// If it doesn't look like a sha at all (e.g. branch name) or is a stash ref (^3) don't try to resolve it\n\t\t\tif ((!options?.force && !isShaLike(ref)) || ref.endsWith('^3')) return ref;\n\n\t\t\treturn (await this.git.rev_parse__verify(repoPath, ref)) ?? ref;\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, repoPath);\n\n\t\tlet cancellation: TimedCancellationSource | undefined;\n\t\tif (options?.timeout != null) {\n\t\t\tcancellation = new TimedCancellationSource(options.timeout);\n\t\t}\n\n\t\tconst [verifiedResult, resolvedResult] = await Promise.allSettled([\n\t\t\tthis.git.rev_parse__verify(repoPath, ref, relativePath),\n\t\t\tthis.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\tref: ref,\n\t\t\t\tcancellation: cancellation?.token,\n\t\t\t}),\n\t\t]);\n\n\t\tconst verified = getSettledValue(verifiedResult);\n\t\tif (verified == null) return deletedOrMissing;\n\n\t\tconst resolved = getSettledValue(resolvedResult);\n\n\t\tconst cancelled = cancellation?.token.isCancellationRequested;\n\t\tcancellation?.dispose();\n\n\t\treturn cancelled ? ref : resolved ?? ref;\n\t}\n\n\t@log<LocalGitProvider['richSearchCommits']>({\n\t\targs: {\n\t\t\t1: s =>\n\t\t\t\t`[${s.matchAll ? 'A' : ''}${s.matchCase ? 'C' : ''}${s.matchRegex ? 'R' : ''}]: ${\n\t\t\t\t\ts.query.length > 500 ? `${s.query.substring(0, 500)}...` : s.query\n\t\t\t\t}`,\n\t\t},\n\t})\n\tasync richSearchCommits(\n\t\trepoPath: string,\n\t\tsearch: SearchQuery,\n\t\toptions?: { limit?: number; ordering?: 'date' | 'author-date' | 'topo' | null; skip?: number },\n\t): Promise<GitLog | undefined> {\n\t\tsearch = { matchAll: false, matchCase: false, matchRegex: true, ...search };\n\n\t\ttry {\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst currentUser = await this.getCurrentUser(repoPath);\n\n\t\t\tconst { args, files, shas } = getGitArgsFromSearchQuery(search, currentUser);\n\n\t\t\targs.push(`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`, '--');\n\t\t\tif (files.length !== 0) {\n\t\t\t\targs.push(...files);\n\t\t\t}\n\n\t\t\tlet stashes: Map<string, GitStashCommit> | undefined;\n\t\t\tlet stdin: string | undefined;\n\t\t\tif (shas == null) {\n\t\t\t\tconst stash = await this.getStash(repoPath);\n\t\t\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\t\t\tif (stash?.commits.size) {\n\t\t\t\t\tstashes = new Map();\n\t\t\t\t\tfor (const commit of stash.commits.values()) {\n\t\t\t\t\t\tstashes.set(commit.sha, commit);\n\t\t\t\t\t\tfor (const p of commit.parents) {\n\t\t\t\t\t\t\tstashes.set(p, commit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstdin = join(\n\t\t\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t\t\t'\\n',\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst data = await this.git.log__search(repoPath, shas?.size ? undefined : args, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tlimit: limit,\n\t\t\t\tshas: shas,\n\t\t\t\tstdin: stdin,\n\t\t\t});\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\tLogType.Log,\n\t\t\t\trepoPath,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tcurrentUser,\n\t\t\t\tlimit,\n\t\t\t\tfalse,\n\t\t\t\tundefined,\n\t\t\t\tstashes,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tfunction richSearchCommitsCore(\n\t\t\t\t\tthis: LocalGitProvider,\n\t\t\t\t\tlog: GitLog,\n\t\t\t\t): (limit: number | undefined) => Promise<GitLog> {\n\t\t\t\t\treturn async (limit: number | undefined) => {\n\t\t\t\t\t\tlimit = limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\t\t\t\tconst moreLog = await this.richSearchCommits(log.repoPath, search, {\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\tlimit: limit,\n\t\t\t\t\t\t\tskip: log.count,\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\t\t\t\tconst mergedLog: GitLog = {\n\t\t\t\t\t\t\trepoPath: log.repoPath,\n\t\t\t\t\t\t\tcommits: commits,\n\t\t\t\t\t\t\tsha: log.sha,\n\t\t\t\t\t\t\trange: log.range,\n\t\t\t\t\t\t\tcount: commits.size,\n\t\t\t\t\t\t\tlimit: (log.limit ?? 0) + limit,\n\t\t\t\t\t\t\thasMore: moreLog.hasMore,\n\t\t\t\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\t\t\t\tthis.richSearchCommits(log.repoPath, search, { ...options, limit: limit }),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (mergedLog.hasMore) {\n\t\t\t\t\t\t\tmergedLog.more = richSearchCommitsCore.call(this, mergedLog);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn mergedLog;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlog.query = (limit: number | undefined) =>\n\t\t\t\t\tthis.richSearchCommits(repoPath, search, { ...options, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlog.more = richSearchCommitsCore.call(this, log);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync searchCommits(\n\t\trepoPath: string,\n\t\tsearch: SearchQuery,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo';\n\t\t},\n\t): Promise<GitSearch> {\n\t\tsearch = { matchAll: false, matchCase: false, matchRegex: true, ...search };\n\n\t\tconst comparisonKey = getSearchQueryComparisonKey(search);\n\t\ttry {\n\t\t\tconst refAndDateParser = getRefAndDateParser();\n\n\t\t\tconst currentUser = search.query.includes('@me') ? await this.getCurrentUser(repoPath) : undefined;\n\n\t\t\tconst { args: searchArgs, files, shas } = getGitArgsFromSearchQuery(search, currentUser);\n\t\t\tif (shas?.size) {\n\t\t\t\tconst data = await this.git.show2(\n\t\t\t\t\trepoPath,\n\t\t\t\t\t{ cancellation: options?.cancellation },\n\t\t\t\t\t'-s',\n\t\t\t\t\t...refAndDateParser.arguments,\n\t\t\t\t\t...shas.values(),\n\t\t\t\t\t...searchArgs,\n\t\t\t\t\t'--',\n\t\t\t\t);\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst results: GitSearchResults = new Map<string, GitSearchResultData>(\n\t\t\t\t\tmap(refAndDateParser.parse(data), c => [\n\t\t\t\t\t\tc.sha,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti: i++,\n\t\t\t\t\t\t\tdate: Number(options?.ordering === 'author-date' ? c.authorDate : c.committerDate) * 1000,\n\t\t\t\t\t\t},\n\t\t\t\t\t]),\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tquery: search,\n\t\t\t\t\tcomparisonKey: comparisonKey,\n\t\t\t\t\tresults: results,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst stash = await this.getStash(repoPath);\n\t\t\tlet stdin: string | undefined;\n\t\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\t\tif (stash?.commits.size) {\n\t\t\t\tstdin = join(\n\t\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t\t'\\n',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst args = [\n\t\t\t\t...refAndDateParser.arguments,\n\t\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t\t'--use-mailmap',\n\t\t\t];\n\n\t\t\tconst results: GitSearchResults = new Map<string, GitSearchResultData>();\n\t\t\tlet total = 0;\n\n\t\t\tasync function searchForCommitsCore(\n\t\t\t\tthis: LocalGitProvider,\n\t\t\t\tlimit: number,\n\t\t\t\tcursor?: { sha: string; skip: number },\n\t\t\t): Promise<GitSearch> {\n\t\t\t\tif (options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t}\n\n\t\t\t\tlet data;\n\t\t\t\ttry {\n\t\t\t\t\tdata = await this.git.log2(\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\t\t\t\tconfigs: ['-C', repoPath, ...gitLogDefaultConfigs],\n\t\t\t\t\t\t\terrors: GitErrorHandling.Throw,\n\t\t\t\t\t\t\tstdin: stdin,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...args,\n\t\t\t\t\t\t...searchArgs,\n\t\t\t\t\t\t...(options?.ordering ? [`--${options.ordering}-order`] : emptyArray),\n\t\t\t\t\t\t...(limit ? [`-n${limit + 1}`] : emptyArray),\n\t\t\t\t\t\t...(cursor?.skip ? [`--skip=${cursor.skip}`] : emptyArray),\n\t\t\t\t\t\t'--',\n\t\t\t\t\t\t...files,\n\t\t\t\t\t);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof CancelledRunError || options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new GitSearchError(ex);\n\t\t\t\t}\n\n\t\t\t\tif (options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t}\n\n\t\t\t\tlet count = total;\n\n\t\t\t\tfor (const r of refAndDateParser.parse(data)) {\n\t\t\t\t\tif (results.has(r.sha)) {\n\t\t\t\t\t\tlimit--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tresults.set(r.sha, {\n\t\t\t\t\t\ti: total++,\n\t\t\t\t\t\tdate: Number(options?.ordering === 'author-date' ? r.authorDate : r.committerDate) * 1000,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcount = total - count;\n\t\t\t\tconst lastSha = last(results)?.[0];\n\t\t\t\tcursor =\n\t\t\t\t\tlastSha != null\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tsha: lastSha,\n\t\t\t\t\t\t\t\tskip: total,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\treturn {\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tquery: search,\n\t\t\t\t\tcomparisonKey: comparisonKey,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tpaging:\n\t\t\t\t\t\tlimit !== 0 && count > limit\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tlimit: limit,\n\t\t\t\t\t\t\t\t\thasMore: true,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\tmore: async (limit: number): Promise<GitSearch> => searchForCommitsCore.call(this, limit, cursor),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn searchForCommitsCore.call(this, limit);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof GitSearchError) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tthrow new GitSearchError(ex);\n\t\t}\n\t}\n\n\t@log({ args: { 2: false } })\n\tasync runGitCommandViaTerminal(\n\t\trepoPath: string,\n\t\tcommand: string,\n\t\targs: string[],\n\t\toptions?: { execute?: boolean },\n\t): Promise<void> {\n\t\tawait this.git.runGitCommandViaTerminal(repoPath, command, args, options);\n\n\t\t// Right now we are reliant on the Repository class to fire the change event (as a stop gap if we don't detect a change through the normal mechanisms)\n\t\t// setTimeout(() => this.fireChange(RepositoryChange.Unknown), 2500);\n\t}\n\n\t@log()\n\tvalidateBranchOrTagName(repoPath: string, ref: string): Promise<boolean> {\n\t\treturn this.git.check_ref_format(ref, repoPath);\n\t}\n\n\t@log()\n\tasync validateReference(repoPath: string, ref: string): Promise<boolean> {\n\t\tif (ref == null || ref.length === 0) return false;\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return true;\n\n\t\treturn (await this.git.rev_parse__verify(repoPath, ref)) != null;\n\t}\n\n\t@log()\n\tasync stageFile(repoPath: string, pathOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.add(repoPath, typeof pathOrUri === 'string' ? pathOrUri : splitPath(pathOrUri, repoPath)[0]);\n\t}\n\n\t@log()\n\tasync stageDirectory(repoPath: string, directoryOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.add(\n\t\t\trepoPath,\n\t\t\ttypeof directoryOrUri === 'string' ? directoryOrUri : splitPath(directoryOrUri, repoPath)[0],\n\t\t);\n\t}\n\n\t@log()\n\tasync unStageFile(repoPath: string, pathOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.reset(repoPath, typeof pathOrUri === 'string' ? pathOrUri : splitPath(pathOrUri, repoPath)[0]);\n\t}\n\n\t@log()\n\tasync unStageDirectory(repoPath: string, directoryOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.reset(\n\t\t\trepoPath,\n\t\t\ttypeof directoryOrUri === 'string' ? directoryOrUri : splitPath(directoryOrUri, repoPath)[0],\n\t\t);\n\t}\n\n\t@log()\n\tasync stashApply(repoPath: string, stashName: string, options?: { deleteAfter?: boolean }): Promise<void> {\n\t\ttry {\n\t\t\tawait this.git.stash__apply(repoPath, stashName, Boolean(options?.deleteAfter));\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Error) {\n\t\t\t\tconst msg: string = ex.message ?? '';\n\t\t\t\tif (msg.includes('Your local changes to the following files would be overwritten by merge')) {\n\t\t\t\t\tthrow new StashApplyError(StashApplyErrorReason.WorkingChanges, ex);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(msg.includes('Auto-merging') && msg.includes('CONFLICT')) ||\n\t\t\t\t\t(ex instanceof RunError &&\n\t\t\t\t\t\t((ex.stdout.includes('Auto-merging') && ex.stdout.includes('CONFLICT')) ||\n\t\t\t\t\t\t\tex.stdout.includes('needs merge')))\n\t\t\t\t) {\n\t\t\t\t\tvoid window.showInformationMessage('Stash applied with conflicts');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow new StashApplyError(`Unable to apply stash \\u2014 ${msg.trim().replace(/\\n+?/g, '; ')}`, ex);\n\t\t\t}\n\n\t\t\tthrow new StashApplyError(`Unable to apply stash \\u2014 ${String(ex)}`, ex);\n\t\t}\n\t}\n\n\t@log()\n\tasync stashDelete(repoPath: string, stashName: string, ref?: string): Promise<void> {\n\t\tawait this.git.stash__delete(repoPath, stashName, ref);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log()\n\tasync stashRename(\n\t\trepoPath: string,\n\t\tstashName: string,\n\t\tref: string,\n\t\tmessage: string,\n\t\tstashOnRef?: string,\n\t): Promise<void> {\n\t\tawait this.git.stash__rename(repoPath, stashName, ref, message, stashOnRef);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log<LocalGitProvider['stashSave']>({ args: { 2: uris => uris?.length } })\n\tasync stashSave(\n\t\trepoPath: string,\n\t\tmessage?: string,\n\t\turis?: Uri[],\n\t\toptions?: { includeUntracked?: boolean; keepIndex?: boolean; onlyStaged?: boolean },\n\t): Promise<void> {\n\t\tif (uris == null) {\n\t\t\tawait this.git.stash__push(repoPath, message, options);\n\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes', 'status'] });\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.13.2',\n\t\t\t'Stashing individual files',\n\t\t\t' Please retry by stashing everything or install a more recent version of Git and try again.',\n\t\t);\n\n\t\tconst pathspecs = uris.map(u => `./${splitPath(u, repoPath)[0]}`);\n\n\t\tconst stdinVersion = '2.30.0';\n\t\tconst stdin = await this.git.isAtLeastVersion(stdinVersion);\n\t\t// If we don't support stdin, then error out if we are over the maximum allowed git cli length\n\t\tif (!stdin && countStringLength(pathspecs) > maxGitCliLength) {\n\t\t\tawait this.ensureGitVersion(\n\t\t\t\tstdinVersion,\n\t\t\t\t`Stashing so many files (${pathspecs.length}) at once`,\n\t\t\t\t' Please retry by stashing fewer files or install a more recent version of Git and try again.',\n\t\t\t);\n\t\t}\n\n\t\tawait this.git.stash__push(repoPath, message, {\n\t\t\t...options,\n\t\t\tpathspecs: pathspecs,\n\t\t\tstdin: stdin,\n\t\t});\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log()\n\tasync createWorktree(\n\t\trepoPath: string,\n\t\tpath: string,\n\t\toptions?: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean },\n\t) {\n\t\ttry {\n\t\t\tawait this.git.worktree__add(repoPath, path, options);\n\t\t\tif (options?.createBranch) {\n\t\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['branches'] });\n\t\t\t}\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\n\t\t\tconst msg = String(ex);\n\n\t\t\tif (GitErrors.alreadyCheckedOut.test(msg)) {\n\t\t\t\tthrow new WorktreeCreateError(WorktreeCreateErrorReason.AlreadyCheckedOut, ex);\n\t\t\t}\n\n\t\t\tif (GitErrors.alreadyExists.test(msg)) {\n\t\t\t\tthrow new WorktreeCreateError(WorktreeCreateErrorReason.AlreadyExists, ex);\n\t\t\t}\n\n\t\t\tthrow new WorktreeCreateError(undefined, ex);\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tasync getWorktrees(repoPath: string): Promise<GitWorktree[]> {\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.7.6',\n\t\t\t'Displaying worktrees',\n\t\t\t' Please install a more recent version of Git and try again.',\n\t\t);\n\n\t\tconst data = await this.git.worktree__list(repoPath);\n\t\treturn GitWorktreeParser.parse(data, repoPath);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/require-await\n\t@log()\n\tasync getWorktreesDefaultUri(repoPath: string): Promise<Uri | undefined> {\n\t\tlet location = configuration.get('worktrees.defaultLocation');\n\t\tif (location == null) return undefined;\n\n\t\tif (location.startsWith('~')) {\n\t\t\tlocation = joinPaths(homedir(), location.slice(1));\n\t\t}\n\n\t\tconst folder = this.container.git.getRepository(repoPath)?.folder;\n\t\tlocation = interpolate(location, {\n\t\t\tuserHome: homedir(),\n\t\t\tworkspaceFolder: folder?.uri.fsPath,\n\t\t\tworkspaceFolderBasename: folder?.name,\n\t\t});\n\n\t\treturn this.getAbsoluteUri(location, repoPath);\n\t}\n\n\t@log()\n\tasync deleteWorktree(repoPath: string, path: string, options?: { force?: boolean }) {\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.17.0',\n\t\t\t'Deleting worktrees',\n\t\t\t' Please install a more recent version of Git and try again.',\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.git.worktree__remove(repoPath, path, options);\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\n\t\t\tconst msg = String(ex);\n\n\t\t\tif (GitErrors.mainWorkingTree.test(msg)) {\n\t\t\t\tthrow new WorktreeDeleteError(WorktreeDeleteErrorReason.MainWorkingTree, ex);\n\t\t\t}\n\n\t\t\tif (GitErrors.uncommittedChanges.test(msg)) {\n\t\t\t\tthrow new WorktreeDeleteError(WorktreeDeleteErrorReason.HasChanges, ex);\n\t\t\t}\n\n\t\t\tthrow new WorktreeDeleteError(undefined, ex);\n\t\t}\n\t}\n\n\tprivate _scmGitApi: Promise<BuiltInGitApi | undefined> | undefined;\n\tprivate async getScmGitApi(): Promise<BuiltInGitApi | undefined> {\n\t\treturn this._scmGitApi ?? (this._scmGitApi = this.getScmGitApiCore());\n\t}\n\n\t@log()\n\tprivate async getScmGitApiCore(): Promise<BuiltInGitApi | undefined> {\n\t\ttry {\n\t\t\tconst extension = extensions.getExtension<GitExtension>('vscode.git');\n\t\t\tif (extension == null) return undefined;\n\n\t\t\tconst gitExtension = extension.isActive ? extension.exports : await extension.activate();\n\t\t\treturn gitExtension?.getAPI(1);\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getScmGitUri(path: string, repoPath: string): Uri {\n\t\t// If the repoPath is a canonical path, then we need to remap it to the real path, because the vscode.git extension always uses the real path\n\t\tconst realUri = this.fromCanonicalMap.get(repoPath);\n\t\tconst uri = this.getAbsoluteUri(path, realUri ?? repoPath);\n\n\t\treturn Uri.from({\n\t\t\tscheme: Schemes.Git,\n\t\t\tpath: uri.path,\n\t\t\tquery: JSON.stringify({\n\t\t\t\t// Ensure we use the fsPath here, otherwise the url won't open properly\n\t\t\t\tpath: uri.fsPath,\n\t\t\t\tref: '~',\n\t\t\t}),\n\t\t});\n\t}\n\n\t@log()\n\tasync getOpenScmRepositories(): Promise<ScmRepository[]> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn gitApi?.repositories ?? [];\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t@log()\n\tasync getScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn gitApi?.getRepository(Uri.file(repoPath)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getOrOpenScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\tif (gitApi?.openRepository != null) {\n\t\t\t\treturn (await gitApi?.openRepository?.(Uri.file(repoPath))) ?? undefined;\n\t\t\t}\n\n\t\t\treturn gitApi?.getRepository(Uri.file(repoPath)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tprivate async openScmRepository(uri: Uri): Promise<BuiltInGitRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn (await gitApi?.openRepository?.(uri)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate async ensureGitVersion(version: string, prefix: string, suffix: string): Promise<void> {\n\t\tif (await this.git.isAtLeastVersion(version)) return;\n\n\t\tthrow new Error(\n\t\t\t`${prefix} requires a newer version of Git (>= ${version}) than is currently installed (${await this.git.version()}).${suffix}`,\n\t\t);\n\t}\n}\n\nasync function getEncoding(uri: Uri): Promise<string> {\n\tconst encoding = configuration.getAny<CoreConfiguration, string>('files.encoding', uri);\n\tif (encoding == null || encoding === 'utf8') return 'utf8';\n\n\tconst encodingExists = (await import(/* webpackChunkName: \"encoding\" */ 'iconv-lite')).encodingExists;\n\treturn encodingExists(encoding) ? encoding : 'utf8';\n}\n", "export class GitSearchError extends Error {\n\tconstructor(public readonly original: Error) {\n\t\tsuper(original.message);\n\n\t\tError.captureStackTrace?.(this, GitSearchError);\n\t}\n}\n\nexport const enum StashApplyErrorReason {\n\tWorkingChanges = 1,\n}\n\nexport class StashApplyError extends Error {\n\tstatic is(ex: any, reason?: StashApplyErrorReason): ex is StashApplyError {\n\t\treturn ex instanceof StashApplyError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: StashApplyErrorReason | undefined;\n\n\tconstructor(reason?: StashApplyErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | StashApplyErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: StashApplyErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to apply stash';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tmessage =\n\t\t\t\t'Unable to apply stash. Your working tree changes would be overwritten. Please commit or stash your changes before trying again';\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, StashApplyError);\n\t}\n}\n\nexport const enum StashPushErrorReason {\n\tConflictingStagedAndUnstagedLines = 1,\n}\n\nexport class StashPushError extends Error {\n\tstatic is(ex: any, reason?: StashPushErrorReason): ex is StashPushError {\n\t\treturn ex instanceof StashPushError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: StashPushErrorReason | undefined;\n\n\tconstructor(reason?: StashPushErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | StashPushErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: StashPushErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to stash';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase StashPushErrorReason.ConflictingStagedAndUnstagedLines:\n\t\t\t\t\tmessage =\n\t\t\t\t\t\t'Stash was created, but the working tree cannot be updated because at least one file has staged and unstaged changes on the same line(s).\\n\\nDo you want to try again by stashing both your staged and unstaged changes?';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmessage = 'Unable to stash';\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, StashApplyError);\n\t}\n}\nexport const enum WorktreeCreateErrorReason {\n\tAlreadyCheckedOut = 1,\n\tAlreadyExists = 2,\n}\n\nexport class WorktreeCreateError extends Error {\n\tstatic is(ex: any, reason?: WorktreeCreateErrorReason): ex is WorktreeCreateError {\n\t\treturn ex instanceof WorktreeCreateError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: WorktreeCreateErrorReason | undefined;\n\n\tconstructor(reason?: WorktreeCreateErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | WorktreeCreateErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: WorktreeCreateErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to create worktree';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase WorktreeCreateErrorReason.AlreadyCheckedOut:\n\t\t\t\t\tmessage = 'Unable to create worktree because it is already checked out';\n\t\t\t\t\tbreak;\n\t\t\t\tcase WorktreeCreateErrorReason.AlreadyExists:\n\t\t\t\t\tmessage = 'Unable to create worktree because it already exists';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, WorktreeCreateError);\n\t}\n}\n\nexport const enum WorktreeDeleteErrorReason {\n\tHasChanges = 1,\n\tMainWorkingTree = 2,\n}\n\nexport class WorktreeDeleteError extends Error {\n\tstatic is(ex: any, reason?: WorktreeDeleteErrorReason): ex is WorktreeDeleteError {\n\t\treturn ex instanceof WorktreeDeleteError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: WorktreeDeleteErrorReason | undefined;\n\n\tconstructor(reason?: WorktreeDeleteErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | WorktreeDeleteErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: WorktreeDeleteErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to delete worktree';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase WorktreeDeleteErrorReason.HasChanges:\n\t\t\t\t\tmessage = 'Unable to delete worktree because there are uncommitted changes';\n\t\t\t\t\tbreak;\n\t\t\t\tcase WorktreeDeleteErrorReason.MainWorkingTree:\n\t\t\t\t\tmessage = 'Unable to delete worktree because it is a main working tree';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, WorktreeDeleteError);\n\t}\n}\n", "import type {\n\tCancellationToken,\n\tConfigurationChangeEvent,\n\tEvent,\n\tRange,\n\tTextDocument,\n\tTextEditor,\n\tWindowState,\n\tWorkspaceFolder,\n\tWorkspaceFoldersChangeEvent,\n} from 'vscode';\nimport { Disposable, EventEmitter, FileType, ProgressLocation, Uri, window, workspace } from 'vscode';\nimport { isWeb } from '@env/platform';\nimport { resetAvatarCache } from '../avatars';\nimport type { CoreGitConfiguration } from '../constants';\nimport { GlyphChars, Schemes } from '../constants';\nimport type { Container } from '../container';\nimport { AccessDeniedError, ProviderNotFoundError } from '../errors';\nimport type { FeatureAccess, Features, PlusFeatures, RepoFeatureAccess } from '../features';\nimport type { SubscriptionChangeEvent } from '../plus/subscription/subscriptionService';\nimport type { RepoComparisonKey } from '../repositories';\nimport { asRepoComparisonKey, Repositories } from '../repositories';\nimport type { Subscription } from '../subscription';\nimport { isSubscriptionPaidPlan, SubscriptionPlanId } from '../subscription';\nimport { groupByFilterMap, groupByMap, joinUnique } from '../system/array';\nimport { registerCommand } from '../system/command';\nimport { configuration } from '../system/configuration';\nimport { setContext } from '../system/context';\nimport { gate } from '../system/decorators/gate';\nimport { debug, log } from '../system/decorators/log';\nimport type { Deferrable } from '../system/function';\nimport { debounce } from '../system/function';\nimport { count, filter, first, flatMap, join, map, some } from '../system/iterable';\nimport { Logger } from '../system/logger';\nimport { getLogScope, setLogScopeExit } from '../system/logger.scope';\nimport { getBestPath, getScheme, isAbsolute, maybeUri, normalizePath } from '../system/path';\nimport { asSettled, cancellable, getSettledValue, isPromise, PromiseCancelledError } from '../system/promise';\nimport { VisitedPathsTrie } from '../system/trie';\nimport type {\n\tGitCaches,\n\tGitDir,\n\tGitProvider,\n\tGitProviderDescriptor,\n\tGitProviderId,\n\tNextComparisonUrisResult,\n\tPagedResult,\n\tPreviousComparisonUrisResult,\n\tPreviousLineComparisonUrisResult,\n\tRepositoryVisibilityInfo,\n\tScmRepository,\n} from './gitProvider';\nimport { RepositoryVisibility } from './gitProvider';\nimport type { GitUri } from './gitUri';\nimport type { GitBlame, GitBlameLine, GitBlameLines } from './models/blame';\nimport type { BranchSortOptions, GitBranch } from './models/branch';\nimport { GitCommit, GitCommitIdentity } from './models/commit';\nimport { deletedOrMissing, uncommitted, uncommittedStaged } from './models/constants';\nimport type { GitContributor } from './models/contributor';\nimport type { GitDiff, GitDiffFilter, GitDiffHunkLine, GitDiffShortStat } from './models/diff';\nimport type { GitFile } from './models/file';\nimport type { GitGraph } from './models/graph';\nimport type { SearchedIssue } from './models/issue';\nimport type { GitLog } from './models/log';\nimport type { GitMergeStatus } from './models/merge';\nimport type { PullRequest, PullRequestState, SearchedPullRequest } from './models/pullRequest';\nimport type { GitRebaseStatus } from './models/rebase';\nimport type { GitBranchReference, GitReference } from './models/reference';\nimport { createRevisionRange, isSha, isUncommitted, isUncommittedParent } from './models/reference';\nimport type { GitReflog } from './models/reflog';\nimport { GitRemote } from './models/remote';\nimport type { RepositoryChangeEvent } from './models/repository';\nimport { Repository, RepositoryChange, RepositoryChangeComparisonMode } from './models/repository';\nimport type { GitStash } from './models/stash';\nimport type { GitStatus, GitStatusFile } from './models/status';\nimport type { GitTag, TagSortOptions } from './models/tag';\nimport type { GitTreeEntry } from './models/tree';\nimport type { GitUser } from './models/user';\nimport type { GitWorktree } from './models/worktree';\nimport type { RemoteProvider } from './remotes/remoteProvider';\nimport type { RemoteProviders } from './remotes/remoteProviders';\nimport type { RichRemoteProvider } from './remotes/richRemoteProvider';\nimport type { GitSearch, SearchQuery } from './search';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst maxDefaultBranchWeight = 100;\nconst weightedDefaultBranches = new Map<string, number>([\n\t['master', maxDefaultBranchWeight],\n\t['main', 15],\n\t['default', 10],\n\t['develop', 5],\n\t['development', 1],\n]);\n\nconst defaultRepositoryId = '0';\n\nexport type GitProvidersChangeEvent = {\n\treadonly added: readonly GitProvider[];\n\treadonly removed: readonly GitProvider[];\n\treadonly etag: number;\n};\n\nexport type RepositoriesChangeEvent = {\n\treadonly added: readonly Repository[];\n\treadonly removed: readonly Repository[];\n\treadonly etag: number;\n};\n\nexport interface GitProviderResult {\n\tprovider: GitProvider;\n\tpath: string;\n}\n\nexport const enum RepositoriesVisibility {\n\tPrivate = 'private',\n\tPublic = 'public',\n\tLocal = 'local',\n\tMixed = 'mixed',\n}\n\nexport class GitProviderService implements Disposable {\n\tprivate readonly _onDidChangeProviders = new EventEmitter<GitProvidersChangeEvent>();\n\tget onDidChangeProviders(): Event<GitProvidersChangeEvent> {\n\t\treturn this._onDidChangeProviders.event;\n\t}\n\tprivate fireProvidersChanged(added?: GitProvider[], removed?: GitProvider[]) {\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'providers.count': this._providers.size,\n\t\t\t\t'providers.ids': join(this._providers.keys(), ','),\n\t\t\t});\n\t\t\tthis.container.telemetry.sendEvent('providers/changed', {\n\t\t\t\t'providers.added': added?.length ?? 0,\n\t\t\t\t'providers.removed': removed?.length ?? 0,\n\t\t\t});\n\t\t}\n\n\t\tthis._etag = Date.now();\n\n\t\tthis._onDidChangeProviders.fire({ added: added ?? [], removed: removed ?? [], etag: this._etag });\n\t}\n\n\tprivate _onDidChangeRepositories = new EventEmitter<RepositoriesChangeEvent>();\n\tget onDidChangeRepositories(): Event<RepositoriesChangeEvent> {\n\t\treturn this._onDidChangeRepositories.event;\n\t}\n\tprivate fireRepositoriesChanged(added?: Repository[], removed?: Repository[]) {\n\t\tconst openSchemes = this.openRepositories.map(r => r.uri.scheme);\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'repositories.count': openSchemes.length,\n\t\t\t\t'repositories.schemes': joinUnique(openSchemes, ','),\n\t\t\t});\n\t\t\tthis.container.telemetry.sendEvent('repositories/changed', {\n\t\t\t\t'repositories.added': added?.length ?? 0,\n\t\t\t\t'repositories.removed': removed?.length ?? 0,\n\t\t\t});\n\t\t}\n\n\t\tthis._etag = Date.now();\n\n\t\tthis._accessCache.clear();\n\t\tthis._reposVisibilityCache = undefined;\n\n\t\tthis._onDidChangeRepositories.fire({ added: added ?? [], removed: removed ?? [], etag: this._etag });\n\n\t\tif (added?.length && this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(async () => {\n\t\t\t\tfor (const repo of added) {\n\t\t\t\t\tconst remoteProviders = new Set<string>();\n\n\t\t\t\t\tconst remotes = await repo.getRemotes();\n\t\t\t\t\tfor (const remote of remotes) {\n\t\t\t\t\t\tremoteProviders.add(remote.provider?.id ?? 'unknown');\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.container.telemetry.sendEvent('repository/opened', {\n\t\t\t\t\t\t'repository.id': repo.idHash,\n\t\t\t\t\t\t'repository.scheme': repo.uri.scheme,\n\t\t\t\t\t\t'repository.closed': repo.closed,\n\t\t\t\t\t\t'repository.folder.scheme': repo.folder?.uri.scheme,\n\t\t\t\t\t\t'repository.provider.id': repo.provider.id,\n\t\t\t\t\t\t'repository.remoteProviders': join(remoteProviders, ','),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate readonly _onDidChangeRepository = new EventEmitter<RepositoryChangeEvent>();\n\tget onDidChangeRepository(): Event<RepositoryChangeEvent> {\n\t\treturn this._onDidChangeRepository.event;\n\t}\n\n\treadonly supportedSchemes = new Set<string>();\n\n\tprivate readonly _disposable: Disposable;\n\tprivate readonly _pendingRepositories = new Map<RepoComparisonKey, Promise<Repository | undefined>>();\n\tprivate readonly _providers = new Map<GitProviderId, GitProvider>();\n\tprivate readonly _repositories = new Repositories();\n\tprivate readonly _bestRemotesCache: Map<RepoComparisonKey, GitRemote<RemoteProvider | RichRemoteProvider> | null> &\n\t\tMap<`rich|${RepoComparisonKey}`, GitRemote<RichRemoteProvider> | null> &\n\t\tMap<`rich+connected|${RepoComparisonKey}`, GitRemote<RichRemoteProvider> | null> = new Map();\n\tprivate readonly _visitedPaths = new VisitedPathsTrie();\n\n\tconstructor(private readonly container: Container) {\n\t\tthis._disposable = Disposable.from(\n\t\t\tcontainer.subscription.onDidChange(this.onSubscriptionChanged, this),\n\t\t\twindow.onDidChangeWindowState(this.onWindowStateChanged, this),\n\t\t\tworkspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged, this),\n\t\t\tconfiguration.onDidChange(this.onConfigurationChanged, this),\n\t\t\tcontainer.richRemoteProviders.onDidChangeConnectionState(e => {\n\t\t\t\tif (e.reason === 'connected') {\n\t\t\t\t\tresetAvatarCache('failed');\n\t\t\t\t}\n\n\t\t\t\tthis.resetCaches('providers');\n\t\t\t\tthis.updateContext();\n\t\t\t}),\n\t\t\t...this.registerCommands(),\n\t\t);\n\n\t\tthis.container.BranchDateFormatting.reset();\n\t\tthis.container.CommitDateFormatting.reset();\n\t\tthis.container.CommitShaFormatting.reset();\n\t\tthis.container.PullRequestDateFormatting.reset();\n\n\t\tthis.updateContext();\n\t}\n\n\tdispose() {\n\t\tthis._disposable.dispose();\n\t\tthis._providers.clear();\n\n\t\tthis._repositories.forEach(r => r.dispose());\n\t\tthis._repositories.clear();\n\t}\n\n\tprivate _etag: number = 0;\n\tget etag(): number {\n\t\treturn this._etag;\n\t}\n\n\tprivate onConfigurationChanged(e?: ConfigurationChangeEvent) {\n\t\tif (\n\t\t\tconfiguration.changed(e, 'defaultDateFormat') ||\n\t\t\tconfiguration.changed(e, 'defaultDateSource') ||\n\t\t\tconfiguration.changed(e, 'defaultDateStyle')\n\t\t) {\n\t\t\tthis.container.BranchDateFormatting.reset();\n\t\t\tthis.container.CommitDateFormatting.reset();\n\t\t\tthis.container.PullRequestDateFormatting.reset();\n\t\t}\n\n\t\tif (configuration.changed(e, 'advanced.abbreviatedShaLength')) {\n\t\t\tthis.container.CommitShaFormatting.reset();\n\t\t}\n\n\t\tif (configuration.changed(e, 'views.contributors.showAllBranches')) {\n\t\t\tthis.resetCaches('contributors');\n\t\t}\n\n\t\tif (e != null && configuration.changed(e, 'integrations.enabled')) {\n\t\t\tthis.updateContext();\n\t\t}\n\t}\n\n\tprivate registerCommands(): Disposable[] {\n\t\treturn [\n\t\t\tregisterCommand('gitlens.plus.resetRepositoryAccess', () => this.clearAllRepoVisibilityCaches()),\n\t\t\tregisterCommand('gitlens.plus.refreshRepositoryAccess', () => this.clearAllOpenRepoVisibilityCaches()),\n\t\t];\n\t}\n\n\t@debug()\n\tonSubscriptionChanged(e: SubscriptionChangeEvent) {\n\t\tthis._accessCache.clear();\n\t\tthis._subscription = e.current;\n\t}\n\n\t@debug<GitProviderService['onWindowStateChanged']>({ args: { 0: e => `focused=${e.focused}` } })\n\tprivate onWindowStateChanged(e: WindowState) {\n\t\tif (e.focused) {\n\t\t\tthis._repositories.forEach(r => r.resume());\n\t\t} else {\n\t\t\tthis._repositories.forEach(r => r.suspend());\n\t\t}\n\t}\n\n\t@debug<GitProviderService['onWorkspaceFoldersChanged']>({\n\t\targs: { 0: e => `added=${e.added.length}, removed=${e.removed.length}` },\n\t\tsingleLine: true,\n\t})\n\tprivate onWorkspaceFoldersChanged(e: WorkspaceFoldersChangeEvent) {\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tconst schemes = workspace.workspaceFolders?.map(f => f.uri.scheme);\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'folders.count': schemes?.length ?? 0,\n\t\t\t\t'folders.schemes': schemes != null ? joinUnique(schemes, ', ') : '',\n\t\t\t});\n\t\t}\n\n\t\tif (e.added.length) {\n\t\t\tvoid this.discoverRepositories(e.added);\n\t\t}\n\n\t\tif (e.removed.length) {\n\t\t\tconst removed: Repository[] = [];\n\n\t\t\tfor (const folder of e.removed) {\n\t\t\t\tconst repository = this._repositories.getClosest(folder.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\tthis._repositories.remove(repository.uri, false);\n\t\t\t\t\tremoved.push(repository);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (removed.length) {\n\t\t\t\tthis.updateContext();\n\n\t\t\t\t// Defer the event trigger enough to let everything unwind\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthis.fireRepositoriesChanged([], removed);\n\t\t\t\t\tremoved.forEach(r => r.dispose());\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tget hasProviders(): boolean {\n\t\treturn this._providers.size !== 0;\n\t}\n\n\tget registeredProviders(): GitProviderDescriptor[] {\n\t\treturn [...map(this._providers.values(), p => ({ ...p.descriptor }))];\n\t}\n\n\tget openRepositories(): Repository[] {\n\t\tif (this.repositoryCount === 0) return emptyArray as Repository[];\n\n\t\tconst repositories = [...filter(this.repositories, r => !r.closed)];\n\t\tif (repositories.length === 0) return repositories;\n\n\t\treturn Repository.sort(repositories);\n\t}\n\n\tget openRepositoryCount(): number {\n\t\treturn this.repositoryCount === 0 ? 0 : count(this.repositories, r => !r.closed);\n\t}\n\n\tget repositories(): IterableIterator<Repository> {\n\t\treturn this._repositories.values();\n\t}\n\n\tget repositoryCount(): number {\n\t\treturn this._repositories.count;\n\t}\n\n\tget highlander(): Repository | undefined {\n\t\treturn this.repositoryCount === 1 ? first(this._repositories.values()) : undefined;\n\t}\n\n\t// get readonly() {\n\t// \treturn true;\n\t// \t// return this.container.vsls.readonly;\n\t// }\n\n\t// get useCaching() {\n\t// \treturn configuration.get('advanced.caching.enabled');\n\t// }\n\n\t/**\n\t * Registers a {@link GitProvider}\n\t * @param id A unique indentifier for the provider\n\t * @param name A name for the provider\n\t * @param provider A provider for handling git operations\n\t * @returns A disposable to unregister the {@link GitProvider}\n\t */\n\t@log({ args: { 1: false }, singleLine: true })\n\tregister(id: GitProviderId, provider: GitProvider): Disposable {\n\t\tif (id !== provider.descriptor.id) {\n\t\t\tthrow new Error(`Id '${id}' must match provider id '${provider.descriptor.id}'`);\n\t\t}\n\t\tif (this._providers.has(id)) throw new Error(`Provider '${id}' has already been registered`);\n\n\t\tthis._providers.set(id, provider);\n\t\tfor (const scheme of provider.supportedSchemes) {\n\t\t\tthis.supportedSchemes.add(scheme);\n\t\t}\n\n\t\tconst disposables = [];\n\n\t\tconst watcher = provider.openRepositoryInitWatcher?.();\n\t\tif (watcher != null) {\n\t\t\tdisposables.push(\n\t\t\t\twatcher,\n\t\t\t\twatcher.onDidCreate(uri => {\n\t\t\t\t\tconst f = workspace.getWorkspaceFolder(uri);\n\t\t\t\t\tif (f == null) return;\n\n\t\t\t\t\tvoid this.discoverRepositories([f], { force: true });\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tconst disposable = Disposable.from(\n\t\t\tprovider,\n\t\t\t...disposables,\n\t\t\tprovider.onDidChangeRepository(async e => {\n\t\t\t\tif (\n\t\t\t\t\te.changed(\n\t\t\t\t\t\tRepositoryChange.Remotes,\n\t\t\t\t\t\tRepositoryChange.RemoteProviders,\n\t\t\t\t\t\tRepositoryChangeComparisonMode.Any,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthis._bestRemotesCache.clear();\n\t\t\t\t}\n\n\t\t\t\tif (e.changed(RepositoryChange.Closed, RepositoryChangeComparisonMode.Any)) {\n\t\t\t\t\tthis.updateContext();\n\n\t\t\t\t\t// Send a notification that the repositories changed\n\t\t\t\t\tqueueMicrotask(() => this.fireRepositoriesChanged([], [e.repository]));\n\t\t\t\t}\n\n\t\t\t\tif (e.changed(RepositoryChange.Remotes, RepositoryChangeComparisonMode.Any)) {\n\t\t\t\t\tconst remotes = await provider.getRemotes(e.repository.path);\n\t\t\t\t\tconst visibilityInfo = this.getVisibilityInfoFromCache(e.repository.path);\n\t\t\t\t\tif (visibilityInfo != null) {\n\t\t\t\t\t\tthis.checkVisibilityCachedRemotes(e.repository.path, visibilityInfo, remotes);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeRepository.fire(e);\n\t\t\t}),\n\t\t\tprovider.onDidCloseRepository(e => {\n\t\t\t\tconst repository = this._repositories.get(e.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\trepository.closed = true;\n\t\t\t\t}\n\t\t\t}),\n\t\t\tprovider.onDidOpenRepository(e => {\n\t\t\t\tconst repository = this._repositories.get(e.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\trepository.closed = false;\n\t\t\t\t} else {\n\t\t\t\t\tvoid this.getOrOpenRepository(e.uri);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tthis.fireProvidersChanged([provider]);\n\n\t\t// Don't kick off the discovery if we're still initializing (we'll do it at the end for all \"known\" providers)\n\t\tif (!this._initializing) {\n\t\t\tthis.onWorkspaceFoldersChanged({ added: workspace.workspaceFolders ?? [], removed: [] });\n\t\t}\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tthis._providers.delete(id);\n\n\t\t\t\tconst removed: Repository[] = [];\n\n\t\t\t\tfor (const repository of [...this._repositories.values()]) {\n\t\t\t\t\tif (repository?.provider.id === id) {\n\t\t\t\t\t\tthis._repositories.remove(repository.uri, false);\n\t\t\t\t\t\tremoved.push(repository);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst { deactivating } = this.container;\n\t\t\t\tif (!deactivating) {\n\t\t\t\t\tthis.updateContext();\n\t\t\t\t}\n\n\t\t\t\tif (removed.length) {\n\t\t\t\t\t// Defer the event trigger enough to let everything unwind\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tif (!deactivating) {\n\t\t\t\t\t\t\tthis.fireRepositoriesChanged([], removed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoved.forEach(r => r.dispose());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!deactivating) {\n\t\t\t\t\tthis.fireProvidersChanged([], [provider]);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate _initializing: boolean = true;\n\n\t@log({ singleLine: true })\n\tasync registrationComplete() {\n\t\tconst scope = getLogScope();\n\n\t\tthis._initializing = false;\n\n\t\tlet { workspaceFolders } = workspace;\n\t\tif (workspaceFolders?.length) {\n\t\t\tawait this.discoverRepositories(workspaceFolders);\n\n\t\t\t// This is a hack to work around some issue with remote repositories on the web not being discovered on the initial load\n\t\t\tif (this.repositoryCount === 0 && isWeb) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t({ workspaceFolders } = workspace);\n\t\t\t\t\tif (workspaceFolders?.length) {\n\t\t\t\t\t\tvoid this.discoverRepositories(workspaceFolders, { force: true });\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.updateContext();\n\t\t}\n\n\t\tconst autoRepositoryDetection = configuration.getAny<\n\t\t\tCoreGitConfiguration,\n\t\t\tboolean | 'subFolders' | 'openEditors'\n\t\t>('git.autoRepositoryDetection');\n\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tthis.container.telemetry.sendEvent('providers/registrationComplete', {\n\t\t\t\t\t'config.git.autoRepositoryDetection': autoRepositoryDetection,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tsetLogScopeExit(\n\t\t\tscope,\n\t\t\t` ${GlyphChars.Dot} workspaceFolders=${workspaceFolders?.length}, git.autoRepositoryDetection=${autoRepositoryDetection}`,\n\t\t);\n\t}\n\n\tgetOpenProviders(): GitProvider[] {\n\t\tconst map = this.getOpenRepositoriesByProvider();\n\t\treturn [...map.keys()].map(id => this._providers.get(id)!);\n\t}\n\n\tgetOpenRepositories(id: GitProviderId): Iterable<Repository> {\n\t\treturn filter(this.repositories, r => !r.closed && (id == null || id === r.provider.id));\n\t}\n\n\tgetOpenRepositoriesByProvider(): Map<GitProviderId, Repository[]> {\n\t\tconst repositories = [...filter(this.repositories, r => !r.closed)];\n\t\tif (repositories.length === 0) return new Map();\n\n\t\treturn groupByMap(repositories, r => r.provider.id);\n\t}\n\n\thasOpenRepositories(id: GitProviderId): boolean {\n\t\treturn some(this.repositories, r => !r.closed && (id == null || id === r.provider.id));\n\t}\n\n\tprivate _discoveredWorkspaceFolders = new Map<WorkspaceFolder, Promise<Repository[]>>();\n\n\t@log<GitProviderService['discoverRepositories']>({ args: { 0: folders => folders.length } })\n\tasync discoverRepositories(folders: readonly WorkspaceFolder[], options?: { force?: boolean }): Promise<void> {\n\t\tconst promises = [];\n\n\t\tfor (const folder of folders) {\n\t\t\tif (!options?.force && this._discoveredWorkspaceFolders.has(folder)) continue;\n\n\t\t\tconst promise = this.discoverRepositoriesCore(folder);\n\t\t\tpromises.push(promise);\n\t\t\tthis._discoveredWorkspaceFolders.set(folder, promise);\n\t\t}\n\n\t\tif (promises.length === 0) return;\n\n\t\tconst results = await Promise.allSettled(promises);\n\n\t\tconst repositories = flatMap<PromiseFulfilledResult<Repository[]>, Repository>(\n\t\t\tfilter<PromiseSettledResult<Repository[]>, PromiseFulfilledResult<Repository[]>>(\n\t\t\t\tresults,\n\t\t\t\t(r): r is PromiseFulfilledResult<Repository[]> => r.status === 'fulfilled',\n\t\t\t),\n\t\t\tr => r.value,\n\t\t);\n\n\t\tconst added: Repository[] = [];\n\n\t\tfor (const repository of repositories) {\n\t\t\tif (this._repositories.add(repository)) {\n\t\t\t\tadded.push(repository);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateContext();\n\n\t\tif (added.length === 0) return;\n\n\t\t// Defer the event trigger enough to let everything unwind\n\t\tqueueMicrotask(() => this.fireRepositoriesChanged(added));\n\t}\n\n\t@debug({ exit: true })\n\tprivate async discoverRepositoriesCore(folder: WorkspaceFolder): Promise<Repository[]> {\n\t\tconst { provider } = this.getProvider(folder.uri);\n\n\t\ttry {\n\t\t\treturn await provider.discoverRepositories(folder.uri);\n\t\t} catch (ex) {\n\t\t\tthis._discoveredWorkspaceFolders.delete(folder);\n\n\t\t\tLogger.error(\n\t\t\t\tex,\n\t\t\t\t`${provider.descriptor.name} Provider(${\n\t\t\t\t\tprovider.descriptor.id\n\t\t\t\t}) failed discovering repositories in ${folder.uri.toString(true)}`,\n\t\t\t);\n\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate _subscription: Subscription | undefined;\n\tprivate async getSubscription(): Promise<Subscription> {\n\t\treturn this._subscription ?? (this._subscription = await this.container.subscription.getSubscription());\n\t}\n\n\tprivate _accessCache: Map<string, Promise<RepoFeatureAccess>> &\n\t\tMap<undefined, Promise<FeatureAccess | RepoFeatureAccess>> = new Map();\n\tasync access(feature: PlusFeatures | undefined, repoPath: string | Uri): Promise<RepoFeatureAccess>;\n\tasync access(feature?: PlusFeatures, repoPath?: string | Uri): Promise<FeatureAccess | RepoFeatureAccess>;\n\t@debug({ exit: true })\n\tasync access(feature?: PlusFeatures, repoPath?: string | Uri): Promise<FeatureAccess | RepoFeatureAccess> {\n\t\tif (repoPath == null) {\n\t\t\tlet access = this._accessCache.get(undefined);\n\t\t\tif (access == null) {\n\t\t\t\taccess = this.accessCore(feature, repoPath);\n\t\t\t\tthis._accessCache.set(undefined, access);\n\t\t\t}\n\t\t\treturn access;\n\t\t}\n\n\t\tconst { path } = this.getProvider(repoPath);\n\t\tconst cacheKey = path;\n\n\t\tlet access = this._accessCache.get(cacheKey);\n\t\tif (access == null) {\n\t\t\taccess = this.accessCore(feature, repoPath);\n\t\t\tthis._accessCache.set(cacheKey, access);\n\t\t}\n\n\t\treturn access;\n\t}\n\n\tprivate async accessCore(feature: PlusFeatures | undefined, repoPath: string | Uri): Promise<RepoFeatureAccess>;\n\tprivate async accessCore(\n\t\tfeature?: PlusFeatures,\n\t\trepoPath?: string | Uri,\n\t): Promise<FeatureAccess | RepoFeatureAccess>;\n\t@debug({ exit: true })\n\tprivate async accessCore(\n\t\t_feature?: PlusFeatures,\n\t\trepoPath?: string | Uri,\n\t): Promise<FeatureAccess | RepoFeatureAccess> {\n\t\tconst subscription = await this.getSubscription();\n\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(() => void this.visibility());\n\t\t}\n\n\t\tconst plan = subscription.plan.effective.id;\n\t\tif (isSubscriptionPaidPlan(plan)) {\n\t\t\treturn { allowed: subscription.account?.verified !== false, subscription: { current: subscription } };\n\t\t}\n\n\t\tfunction getRepoAccess(\n\t\t\tthis: GitProviderService,\n\t\t\trepoPath: string | Uri,\n\t\t\tforce: boolean = false,\n\t\t): Promise<RepoFeatureAccess> {\n\t\t\tconst { path: cacheKey } = this.getProvider(repoPath);\n\n\t\t\tlet access = force ? undefined : this._accessCache.get(cacheKey);\n\t\t\tif (access == null) {\n\t\t\t\taccess = this.visibility(repoPath).then(\n\t\t\t\t\tvisibility => {\n\t\t\t\t\t\tif (visibility === RepositoryVisibility.Private) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tallowed: true,\n\t\t\t\t\t\t\tsubscription: { current: subscription },\n\t\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\t// If there is a failure assume access is allowed\n\t\t\t\t\t() => ({ allowed: true, subscription: { current: subscription } }),\n\t\t\t\t);\n\n\t\t\t\tthis._accessCache.set(cacheKey, access);\n\t\t\t}\n\n\t\t\treturn access;\n\t\t}\n\n\t\tif (repoPath == null) {\n\t\t\tconst repositories = this.openRepositories;\n\t\t\tif (repositories.length === 0) {\n\t\t\t\treturn { allowed: false, subscription: { current: subscription } };\n\t\t\t}\n\n\t\t\tif (repositories.length === 1) {\n\t\t\t\treturn getRepoAccess.call(this, repositories[0].path);\n\t\t\t}\n\n\t\t\tconst visibility = await this.visibility();\n\t\t\tswitch (visibility) {\n\t\t\t\tcase RepositoriesVisibility.Private:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t\tvisibility: RepositoryVisibility.Private,\n\t\t\t\t\t};\n\t\t\t\tcase RepositoriesVisibility.Mixed:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: 'mixed',\n\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: true,\n\t\t\t\t\t\tsubscription: { current: subscription },\n\t\t\t\t\t\tvisibility: RepositoryVisibility.Public,\n\t\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Pass force = true to bypass the cache and avoid a promise loop (where we used the cached promise we just created to try to resolve itself \ud83e\udd26)\n\t\treturn getRepoAccess.call(this, repoPath, true);\n\t}\n\n\tasync ensureAccess(feature: PlusFeatures, repoPath?: string): Promise<void> {\n\t\tconst { allowed, subscription } = await this.access(feature, repoPath);\n\t\tif (allowed === false) throw new AccessDeniedError(subscription.current, subscription.required);\n\t}\n\n\t@debug({ exit: true })\n\tsupports(repoPath: string | Uri, feature: Features): Promise<boolean> {\n\t\tconst { provider } = this.getProvider(repoPath);\n\t\treturn provider.supports(feature);\n\t}\n\n\tprivate _reposVisibilityCache: RepositoriesVisibility | undefined;\n\tprivate _repoVisibilityCache: Map<string, RepositoryVisibilityInfo> | undefined;\n\n\tprivate ensureRepoVisibilityCache(): void {\n\t\tif (this._repoVisibilityCache == null) {\n\t\t\tconst repoVisibility: [string, RepositoryVisibilityInfo][] | undefined = this.container.storage\n\t\t\t\t.get('repoVisibility')\n\t\t\t\t?.map<[string, RepositoryVisibilityInfo]>(([key, visibilityInfo]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\t{\n\t\t\t\t\t\tvisibility: visibilityInfo.visibility as RepositoryVisibility,\n\t\t\t\t\t\ttimestamp: visibilityInfo.timestamp,\n\t\t\t\t\t\tremotesHash: visibilityInfo.remotesHash,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\tthis._repoVisibilityCache = new Map(repoVisibility);\n\t\t}\n\t}\n\n\tprivate clearRepoVisibilityCache(keys?: string[]): void {\n\t\tif (keys == null) {\n\t\t\tthis._repoVisibilityCache = undefined;\n\t\t\tvoid this.container.storage.delete('repoVisibility');\n\t\t} else {\n\t\t\tkeys?.forEach(key => this._repoVisibilityCache?.delete(key));\n\t\t\tconst repoVisibility = Array.from(this._repoVisibilityCache?.entries() ?? []);\n\t\t\tif (repoVisibility.length === 0) {\n\t\t\t\tvoid this.container.storage.delete('repoVisibility');\n\t\t\t} else {\n\t\t\t\tvoid this.container.storage.store('repoVisibility', repoVisibility);\n\t\t\t}\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getVisibilityInfoFromCache']>({ exit: r => `returned ${r?.visibility}` })\n\tprivate getVisibilityInfoFromCache(key: string): RepositoryVisibilityInfo | undefined {\n\t\tthis.ensureRepoVisibilityCache();\n\t\tconst visibilityInfo = this._repoVisibilityCache?.get(key);\n\t\tif (visibilityInfo == null) return undefined;\n\n\t\tconst now = Date.now();\n\t\tif (now - visibilityInfo.timestamp > 1000 * 60 * 60 * 24 * 30 /* TTL is 30 days */) {\n\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn visibilityInfo;\n\t}\n\n\tprivate checkVisibilityCachedRemotes(\n\t\tkey: string,\n\t\tvisibilityInfo: RepositoryVisibilityInfo | undefined,\n\t\tremotes: GitRemote[],\n\t): boolean {\n\t\tif (visibilityInfo == null) return true;\n\n\t\tif (visibilityInfo.visibility === RepositoryVisibility.Public) {\n\t\t\tif (remotes.length == 0 || !remotes.some(r => r.id === visibilityInfo.remotesHash)) {\n\t\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (visibilityInfo.visibility === RepositoryVisibility.Private) {\n\t\t\tconst remotesHash = remotes\n\t\t\t\t.map(r => r.id)\n\t\t\t\t.sort()\n\t\t\t\t.join(',');\n\t\t\tif (remotesHash !== visibilityInfo.remotesHash) {\n\t\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate updateVisibilityCache(key: string, visibilityInfo: RepositoryVisibilityInfo): void {\n\t\tthis.ensureRepoVisibilityCache();\n\t\tthis._repoVisibilityCache?.set(key, visibilityInfo);\n\t\tvoid this.container.storage.store('repoVisibility', Array.from(this._repoVisibilityCache!.entries()));\n\t}\n\n\t@debug()\n\tclearAllRepoVisibilityCaches(): void {\n\t\tthis.clearRepoVisibilityCache();\n\t}\n\n\t@debug()\n\tclearAllOpenRepoVisibilityCaches(): void {\n\t\tconst openRepoProviderPaths = this.openRepositories.map(r => this.getProvider(r.path).path);\n\t\tthis.clearRepoVisibilityCache(openRepoProviderPaths);\n\t}\n\n\tvisibility(): Promise<RepositoriesVisibility>;\n\tvisibility(repoPath: string | Uri): Promise<RepositoryVisibility>;\n\t@debug({ exit: true })\n\tasync visibility(repoPath?: string | Uri): Promise<RepositoriesVisibility | RepositoryVisibility> {\n\t\tif (repoPath == null) {\n\t\t\tlet visibility = this._reposVisibilityCache;\n\t\t\tif (visibility == null) {\n\t\t\t\tvisibility = await this.visibilityCore();\n\t\t\t\tif (this.container.telemetry.enabled) {\n\t\t\t\t\tthis.container.telemetry.setGlobalAttribute('repositories.visibility', visibility);\n\t\t\t\t\tthis.container.telemetry.sendEvent('repositories/visibility');\n\t\t\t\t}\n\t\t\t\tthis._reposVisibilityCache = visibility;\n\t\t\t}\n\t\t\treturn visibility;\n\t\t}\n\n\t\tconst { path: cacheKey } = this.getProvider(repoPath);\n\n\t\tlet visibility = this.getVisibilityInfoFromCache(cacheKey)?.visibility;\n\t\tif (visibility == null) {\n\t\t\tvisibility = await this.visibilityCore(repoPath);\n\t\t\tif (this.container.telemetry.enabled) {\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tconst repo = this.getRepository(repoPath);\n\t\t\t\t\tthis.container.telemetry.sendEvent('repository/visibility', {\n\t\t\t\t\t\t'repository.visibility': visibility,\n\t\t\t\t\t\t'repository.id': repo?.idHash,\n\t\t\t\t\t\t'repository.scheme': repo?.uri.scheme,\n\t\t\t\t\t\t'repository.closed': repo?.closed,\n\t\t\t\t\t\t'repository.folder.scheme': repo?.folder?.uri.scheme,\n\t\t\t\t\t\t'repository.provider.id': repo?.provider.id,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn visibility;\n\t}\n\n\tprivate visibilityCore(): Promise<RepositoriesVisibility>;\n\tprivate visibilityCore(repoPath: string | Uri): Promise<RepositoryVisibility>;\n\t@debug({ exit: true })\n\tprivate async visibilityCore(repoPath?: string | Uri): Promise<RepositoriesVisibility | RepositoryVisibility> {\n\t\tasync function getRepoVisibility(\n\t\t\tthis: GitProviderService,\n\t\t\trepoPath: string | Uri,\n\t\t): Promise<RepositoryVisibility> {\n\t\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\t\tconst remotes = await provider.getRemotes(path, { sort: true });\n\t\t\tconst visibilityInfo = this.getVisibilityInfoFromCache(path);\n\t\t\tif (visibilityInfo == null || !this.checkVisibilityCachedRemotes(path, visibilityInfo, remotes)) {\n\t\t\t\tconst [visibility, remotesHash] = await provider.visibility(path);\n\t\t\t\tif (visibility !== RepositoryVisibility.Local) {\n\t\t\t\t\tthis.updateVisibilityCache(path, {\n\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tremotesHash: remotesHash,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn visibility;\n\t\t\t}\n\n\t\t\treturn visibilityInfo.visibility;\n\t\t}\n\n\t\tif (repoPath == null) {\n\t\t\tconst repositories = this.openRepositories;\n\t\t\tif (repositories.length === 0) return RepositoriesVisibility.Private;\n\n\t\t\tif (repositories.length === 1) {\n\t\t\t\treturn getRepoVisibility.call(this, repositories[0].path);\n\t\t\t}\n\n\t\t\tlet isPublic = false;\n\t\t\tlet isPrivate = false;\n\t\t\tlet isLocal = false;\n\n\t\t\tfor await (const result of asSettled(repositories.map(r => getRepoVisibility.call(this, r.path)))) {\n\t\t\t\tif (result.status !== 'fulfilled') continue;\n\n\t\t\t\tif (result.value === RepositoryVisibility.Public) {\n\t\t\t\t\tif (isLocal || isPrivate) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisPublic = true;\n\t\t\t\t} else if (result.value === RepositoryVisibility.Local) {\n\t\t\t\t\tif (isPublic || isPrivate) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisLocal = true;\n\t\t\t\t} else if (result.value === RepositoryVisibility.Private) {\n\t\t\t\t\tif (isPublic || isLocal) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisPrivate = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isPublic) return RepositoriesVisibility.Public;\n\t\t\tif (isLocal) return RepositoriesVisibility.Local;\n\t\t\treturn RepositoriesVisibility.Private;\n\t\t}\n\n\t\treturn getRepoVisibility.call(this, repoPath);\n\t}\n\n\tprivate _context: { enabled: boolean; disabled: boolean } = { enabled: false, disabled: false };\n\n\t@debug()\n\tasync setEnabledContext(enabled: boolean): Promise<void> {\n\t\tlet disabled = !enabled;\n\t\t// If we think we should be disabled during startup, check if we have a saved value from the last time this repo was loaded\n\t\tif (!enabled && this._initializing) {\n\t\t\tdisabled = !(this.container.storage.getWorkspace('assumeRepositoriesOnStartup') ?? true);\n\t\t}\n\n\t\tthis.container.telemetry.setGlobalAttribute('enabled', enabled);\n\n\t\tif (this._context.enabled === enabled && this._context.disabled === disabled) return;\n\n\t\tconst promises = [];\n\n\t\tif (this._context.enabled !== enabled) {\n\t\t\tthis._context.enabled = enabled;\n\t\t\tpromises.push(setContext('gitlens:enabled', enabled));\n\t\t}\n\n\t\tif (this._context.disabled !== disabled) {\n\t\t\tthis._context.disabled = disabled;\n\t\t\tpromises.push(setContext('gitlens:disabled', disabled));\n\t\t}\n\n\t\tawait Promise.allSettled(promises);\n\n\t\tif (!this._initializing) {\n\t\t\tvoid this.container.storage.storeWorkspace('assumeRepositoriesOnStartup', enabled).catch();\n\t\t}\n\t}\n\n\tprivate _sendProviderContextTelemetryDebounced: Deferrable<() => void> | undefined;\n\n\tprivate updateContext() {\n\t\tif (this.container.deactivating) return;\n\n\t\tconst openRepositoryCount = this.openRepositoryCount;\n\t\tconst hasRepositories = openRepositoryCount !== 0;\n\n\t\tvoid this.setEnabledContext(hasRepositories);\n\n\t\t// Don't bother trying to set the values if we're still starting up\n\t\tif (this._initializing) return;\n\n\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\tenabled: hasRepositories,\n\t\t\t'repositories.count': openRepositoryCount,\n\t\t});\n\n\t\tif (!hasRepositories) return;\n\n\t\t// Don't block for the remote context updates (because it can block other downstream requests during initialization)\n\t\tasync function updateRemoteContext(this: GitProviderService) {\n\t\t\tconst integrations = configuration.get('integrations.enabled');\n\n\t\t\tconst telemetryEnabled = this.container.telemetry.enabled;\n\t\t\tconst remoteProviders = new Set<string>();\n\n\t\t\tlet hasRemotes = false;\n\t\t\tlet hasRichRemotes = false;\n\t\t\tlet hasConnectedRemotes = false;\n\n\t\t\tif (hasRepositories) {\n\t\t\t\tfor (const repo of this._repositories.values()) {\n\t\t\t\t\tif (telemetryEnabled) {\n\t\t\t\t\t\tconst remotes = await repo.getRemotes();\n\t\t\t\t\t\tfor (const remote of remotes) {\n\t\t\t\t\t\t\tremoteProviders.add(remote.provider?.id ?? 'unknown');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasConnectedRemotes && integrations) {\n\t\t\t\t\t\thasConnectedRemotes = await repo.hasRichRemote(true);\n\n\t\t\t\t\t\tif (hasConnectedRemotes) {\n\t\t\t\t\t\t\thasRichRemotes = true;\n\t\t\t\t\t\t\thasRemotes = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasRichRemotes && integrations) {\n\t\t\t\t\t\thasRichRemotes = await repo.hasRichRemote();\n\n\t\t\t\t\t\tif (hasRichRemotes) {\n\t\t\t\t\t\t\thasRemotes = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasRemotes) {\n\t\t\t\t\t\thasRemotes = await repo.hasRemotes();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasRemotes && ((hasRichRemotes && hasConnectedRemotes) || !integrations)) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (telemetryEnabled) {\n\t\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t\t'repositories.hasRemotes': hasRemotes,\n\t\t\t\t\t'repositories.hasRichRemotes': hasRichRemotes,\n\t\t\t\t\t'repositories.hasConnectedRemotes': hasConnectedRemotes,\n\t\t\t\t\t'repositories.remoteProviders': join(remoteProviders, ','),\n\t\t\t\t});\n\t\t\t\tif (this._sendProviderContextTelemetryDebounced == null) {\n\t\t\t\t\tthis._sendProviderContextTelemetryDebounced = debounce(\n\t\t\t\t\t\t() => this.container.telemetry.sendEvent('providers/context'),\n\t\t\t\t\t\t2500,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis._sendProviderContextTelemetryDebounced();\n\t\t\t}\n\n\t\t\tawait Promise.allSettled([\n\t\t\t\tsetContext('gitlens:hasRemotes', hasRemotes),\n\t\t\t\tsetContext('gitlens:hasRichRemotes', hasRichRemotes),\n\t\t\t\tsetContext('gitlens:hasConnectedRemotes', hasConnectedRemotes),\n\t\t\t]);\n\t\t}\n\n\t\tvoid updateRemoteContext.call(this);\n\n\t\tthis._providers.forEach(p => p.updateContext?.());\n\t}\n\n\tprivate getProvider(repoPath: string | Uri): GitProviderResult {\n\t\tif (repoPath == null || (typeof repoPath !== 'string' && !this.supportedSchemes.has(repoPath.scheme))) {\n\t\t\tdebugger;\n\t\t\tthrow new ProviderNotFoundError(repoPath);\n\t\t}\n\n\t\tlet scheme;\n\t\tif (typeof repoPath === 'string') {\n\t\t\tscheme = getScheme(repoPath) ?? Schemes.File;\n\t\t} else {\n\t\t\t({ scheme } = repoPath);\n\t\t}\n\n\t\tconst possibleResults = new Set<GitProviderResult>();\n\n\t\tfor (const provider of this._providers.values()) {\n\t\t\tconst path = provider.canHandlePathOrUri(scheme, repoPath);\n\t\t\tif (path == null) continue;\n\n\t\t\tpossibleResults.add({ provider: provider, path: path });\n\t\t}\n\n\t\tif (possibleResults.size === 0) {\n\t\t\tdebugger;\n\t\t\tthrow new ProviderNotFoundError(repoPath);\n\t\t}\n\n\t\t// Prefer the provider with an open repository\n\t\tif (possibleResults.size > 1) {\n\t\t\tfor (const result of possibleResults) {\n\t\t\t\tif (this.hasOpenRepositories(result.provider.descriptor.id)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn first(possibleResults)!;\n\t}\n\n\tgetAbsoluteUri(pathOrUri: string | Uri, base?: string | Uri): Uri {\n\t\tif (base == null) {\n\t\t\tif (typeof pathOrUri === 'string') {\n\t\t\t\tif (maybeUri(pathOrUri)) return Uri.parse(pathOrUri, true);\n\n\t\t\t\t// I think it is safe to assume this should be file://\n\t\t\t\treturn Uri.file(pathOrUri);\n\t\t\t}\n\n\t\t\treturn pathOrUri;\n\t\t}\n\n\t\t// Short-circuit if the base is already a Uri and the path is relative\n\t\tif (typeof base !== 'string' && typeof pathOrUri === 'string') {\n\t\t\tconst normalized = normalizePath(pathOrUri);\n\t\t\tif (!isAbsolute(normalized)) return Uri.joinPath(base, normalized);\n\t\t}\n\n\t\tconst { provider } = this.getProvider(base);\n\t\treturn provider.getAbsoluteUri(pathOrUri, base);\n\t}\n\n\t@log()\n\tasync getBestRevisionUri(\n\t\trepoPath: string | Uri | undefined,\n\t\tpath: string,\n\t\tref: string | undefined,\n\t): Promise<Uri | undefined> {\n\t\tif (repoPath == null || ref === deletedOrMissing) return undefined;\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getBestRevisionUri(rp, provider.getRelativePath(path, rp), ref);\n\t}\n\n\tgetRelativePath(pathOrUri: string | Uri, base: string | Uri): string {\n\t\tconst { provider } = this.getProvider(pathOrUri instanceof Uri ? pathOrUri : base);\n\t\treturn provider.getRelativePath(pathOrUri, base);\n\t}\n\n\tgetRevisionUri(uri: GitUri): Uri;\n\tgetRevisionUri(ref: string, path: string, repoPath: string | Uri): Uri;\n\tgetRevisionUri(ref: string, file: GitFile, repoPath: string | Uri): Uri;\n\t@log()\n\tgetRevisionUri(refOrUri: string | GitUri, pathOrFile?: string | GitFile, repoPath?: string | Uri): Uri {\n\t\tlet path: string;\n\t\tlet ref: string | undefined;\n\n\t\tif (typeof refOrUri === 'string') {\n\t\t\tref = refOrUri;\n\n\t\t\tif (typeof pathOrFile === 'string') {\n\t\t\t\tpath = pathOrFile;\n\t\t\t} else {\n\t\t\t\tpath = pathOrFile?.originalPath ?? pathOrFile?.path ?? '';\n\t\t\t}\n\t\t} else {\n\t\t\tref = refOrUri.sha;\n\t\t\trepoPath = refOrUri.repoPath!;\n\n\t\t\tpath = getBestPath(refOrUri);\n\t\t}\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath!);\n\t\treturn provider.getRevisionUri(rp, provider.getRelativePath(path, rp), ref!);\n\t}\n\n\t@log()\n\tgetWorkingUri(repoPath: string | Uri, uri: Uri) {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getWorkingUri(path, uri);\n\t}\n\n\t@log()\n\taddRemote(repoPath: string | Uri, name: string, url: string, options?: { fetch?: boolean }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.addRemote(path, name, url, options);\n\t}\n\n\t@log()\n\tpruneRemote(repoPath: string | Uri, name: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.pruneRemote(path, name);\n\t}\n\n\t@log()\n\tremoveRemote(repoPath: string | Uri, name: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.removeRemote(path, name);\n\t}\n\n\t@log()\n\tapplyChangesToWorkingFile(uri: GitUri, ref1?: string, ref2?: string): Promise<void> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.applyChangesToWorkingFile(uri, ref1, ref2);\n\t}\n\n\t@log()\n\tcheckout(repoPath: string, ref: string, options?: { createBranch?: string } | { path?: string }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.checkout(path, ref, options);\n\t}\n\n\t@log({ singleLine: true })\n\tresetCaches(...caches: GitCaches[]): void {\n\t\tif (caches.length === 0 || caches.includes('providers')) {\n\t\t\tthis._bestRemotesCache.clear();\n\t\t}\n\n\t\tthis.container.events.fire('git:cache:reset', { caches: caches });\n\t}\n\n\t@log<GitProviderService['excludeIgnoredUris']>({ args: { 1: uris => uris.length } })\n\texcludeIgnoredUris(repoPath: string, uris: Uri[]): Promise<Uri[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.excludeIgnoredUris(path, uris);\n\t}\n\n\t@gate()\n\t@log()\n\tfetch(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; branch?: GitBranchReference; prune?: boolean; pull?: boolean; remote?: string },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.fetch(path, options);\n\t}\n\n\t@gate<GitProviderService['fetchAll']>(\n\t\t(repos, opts) => `${repos == null ? '' : repos.map(r => r.id).join(',')}|${JSON.stringify(opts)}`,\n\t)\n\t@log<GitProviderService['fetchAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync fetchAll(repositories?: Repository[], options?: { all?: boolean; prune?: boolean }) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].fetch(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Fetching ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.fetch({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@gate<GitProviderService['pullAll']>(\n\t\t(repos, opts) => `${repos == null ? '' : repos.map(r => r.id).join(',')}|${JSON.stringify(opts)}`,\n\t)\n\t@log<GitProviderService['pullAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync pullAll(repositories?: Repository[], options?: { rebase?: boolean }) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].pull(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Pulling ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.pull({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@gate<GitProviderService['pushAll']>(repos => `${repos == null ? '' : repos.map(r => r.id).join(',')}`)\n\t@log<GitProviderService['pushAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync pushAll(\n\t\trepositories?: Repository[],\n\t\toptions?: {\n\t\t\tforce?: boolean;\n\t\t\treference?: GitReference;\n\t\t\tpublish?: {\n\t\t\t\tremote: string;\n\t\t\t};\n\t\t},\n\t) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].push(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Pushing ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.push({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@log<GitProviderService['getAheadBehindCommitCount']>({ args: { 1: refs => refs.join(',') } })\n\tgetAheadBehindCommitCount(\n\t\trepoPath: string | Uri,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getAheadBehindCommitCount(path, refs);\n\t}\n\n\t@log<GitProviderService['getBlame']>({ args: { 1: d => d?.isDirty } })\n\t/**\n\t * Returns the blame of a file\n\t * @param uri Uri of the file to blame\n\t * @param document Optional TextDocument to blame the contents of if dirty\n\t */\n\tasync getBlame(uri: GitUri, document?: TextDocument | undefined): Promise<GitBlame | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlame(uri, document);\n\t}\n\n\t@log<GitProviderService['getBlameContents']>({ args: { 1: '<contents>' } })\n\t/**\n\t * Returns the blame of a file, using the editor contents (for dirty editors)\n\t * @param uri Uri of the file to blame\n\t * @param contents Contents from the editor to use\n\t */\n\tasync getBlameContents(uri: GitUri, contents: string): Promise<GitBlame | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameContents(uri, contents);\n\t}\n\n\t@log<GitProviderService['getBlameForLine']>({ args: { 2: d => d?.isDirty } })\n\t/**\n\t * Returns the blame of a single line\n\t * @param uri Uri of the file to blame\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param document Optional TextDocument to blame the contents of if dirty\n\t * @param options.forceSingleLine Forces blame to be for the single line (rather than the whole file)\n\t */\n\tasync getBlameForLine(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tdocument?: TextDocument | undefined,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForLine(uri, editorLine, document, options);\n\t}\n\n\t@log<GitProviderService['getBlameForLineContents']>({ args: { 2: '<contents>' } })\n\t/**\n\t * Returns the blame of a single line, using the editor contents (for dirty editors)\n\t * @param uri Uri of the file to blame\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param contents Contents from the editor to use\n\t * @param options.forceSingleLine Forces blame to be for the single line (rather than the whole file)\n\t */\n\tasync getBlameForLineContents(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tcontents: string,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForLineContents(uri, editorLine, contents, options);\n\t}\n\n\t@log()\n\tasync getBlameForRange(uri: GitUri, range: Range): Promise<GitBlameLines | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForRange(uri, range);\n\t}\n\n\t@log<GitProviderService['getBlameForRangeContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForRangeContents(uri: GitUri, range: Range, contents: string): Promise<GitBlameLines | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForRangeContents(uri, range, contents);\n\t}\n\n\t@log<GitProviderService['getBlameRange']>({ args: { 0: '<blame>' } })\n\tgetBlameRange(blame: GitBlame, uri: GitUri, range: Range): GitBlameLines | undefined {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameRange(blame, uri, range);\n\t}\n\n\t@log()\n\tasync getBranch(repoPath: string | Uri | undefined): Promise<GitBranch | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getBranch(path);\n\t}\n\n\t@log<GitProviderService['getBranchAheadRange']>({ args: { 0: b => b.name } })\n\tasync getBranchAheadRange(branch: GitBranch): Promise<string | undefined> {\n\t\tif (branch.state.ahead > 0) {\n\t\t\treturn createRevisionRange(branch.upstream?.name, branch.ref);\n\t\t}\n\n\t\tif (branch.upstream == null) {\n\t\t\t// If we have no upstream branch, try to find a best guess branch to use as the \"base\"\n\t\t\tconst { values: branches } = await this.getBranches(branch.repoPath, {\n\t\t\t\tfilter: b => weightedDefaultBranches.has(b.name),\n\t\t\t});\n\t\t\tif (branches.length > 0) {\n\t\t\t\tlet weightedBranch: { weight: number; branch: GitBranch } | undefined;\n\t\t\t\tfor (const branch of branches) {\n\t\t\t\t\tconst weight = weightedDefaultBranches.get(branch.name)!;\n\t\t\t\t\tif (weightedBranch == null || weightedBranch.weight < weight) {\n\t\t\t\t\t\tweightedBranch = { weight: weight, branch: branch };\n\t\t\t\t\t}\n\n\t\t\t\t\tif (weightedBranch.weight === maxDefaultBranchWeight) break;\n\t\t\t\t}\n\n\t\t\t\tconst possibleBranch = weightedBranch!.branch.upstream?.name ?? weightedBranch!.branch.ref;\n\t\t\t\tif (possibleBranch !== branch.ref) {\n\t\t\t\t\treturn createRevisionRange(possibleBranch, branch.ref);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getBranches(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: {\n\t\t\tfilter?: (b: GitBranch) => boolean;\n\t\t\tsort?: boolean | BranchSortOptions;\n\t\t},\n\t): Promise<PagedResult<GitBranch>> {\n\t\tif (repoPath == null) return { values: [] };\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getBranches(path, options);\n\t}\n\n\t@log()\n\tasync getBranchesAndTagsTipsFn(\n\t\trepoPath: string | Uri | undefined,\n\t\tcurrentName?: string,\n\t): Promise<\n\t\t(sha: string, options?: { compact?: boolean | undefined; icons?: boolean | undefined }) => string | undefined\n\t> {\n\t\tconst [branchesResult, tagsResult] = await Promise.allSettled([\n\t\t\tthis.getBranches(repoPath),\n\t\t\tthis.getTags(repoPath),\n\t\t]);\n\n\t\tconst branches = getSettledValue(branchesResult)?.values ?? [];\n\t\tconst tags = getSettledValue(tagsResult)?.values ?? [];\n\n\t\tconst branchesAndTagsBySha = groupByFilterMap(\n\t\t\t(branches as (GitBranch | GitTag)[]).concat(tags as (GitBranch | GitTag)[]),\n\t\t\tbt => bt.sha,\n\t\t\tbt => {\n\t\t\t\tif (currentName) {\n\t\t\t\t\tif (bt.name === currentName) return undefined;\n\t\t\t\t\tif (bt.refType === 'branch' && bt.getNameWithoutRemote() === currentName) {\n\t\t\t\t\t\treturn { name: bt.name, compactName: bt.getRemoteName(), type: bt.refType };\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { name: bt.name, compactName: undefined, type: bt.refType };\n\t\t\t},\n\t\t);\n\n\t\treturn (sha: string, options?: { compact?: boolean; icons?: boolean }): string | undefined => {\n\t\t\tconst branchesAndTags = branchesAndTagsBySha.get(sha);\n\t\t\tif (branchesAndTags == null || branchesAndTags.length === 0) return undefined;\n\n\t\t\tif (!options?.compact) {\n\t\t\t\treturn branchesAndTags\n\t\t\t\t\t.map(\n\t\t\t\t\t\tbt => `${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${bt.name}`,\n\t\t\t\t\t)\n\t\t\t\t\t.join(', ');\n\t\t\t}\n\n\t\t\tif (branchesAndTags.length > 1) {\n\t\t\t\tconst [bt] = branchesAndTags;\n\t\t\t\treturn `${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${\n\t\t\t\t\tbt.compactName ?? bt.name\n\t\t\t\t}, ${GlyphChars.Ellipsis}`;\n\t\t\t}\n\n\t\t\treturn branchesAndTags\n\t\t\t\t.map(\n\t\t\t\t\tbt =>\n\t\t\t\t\t\t`${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${\n\t\t\t\t\t\t\tbt.compactName ?? bt.name\n\t\t\t\t\t\t}`,\n\t\t\t\t)\n\t\t\t\t.join(', ');\n\t\t};\n\t}\n\n\t@log()\n\tgetChangedFilesCount(repoPath: string | Uri, ref?: string): Promise<GitDiffShortStat | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getChangedFilesCount(path, ref);\n\t}\n\n\t@log()\n\tasync getCommit(repoPath: string | Uri, ref: string): Promise<GitCommit | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\n\t\tif (ref === uncommitted || ref === uncommittedStaged) {\n\t\t\tconst now = new Date();\n\t\t\tconst user = await this.getCurrentUser(repoPath);\n\t\t\treturn new GitCommit(\n\t\t\t\tthis.container,\n\t\t\t\tpath,\n\t\t\t\tref,\n\t\t\t\tnew GitCommitIdentity('You', user?.email ?? undefined, now),\n\t\t\t\tnew GitCommitIdentity('You', user?.email ?? undefined, now),\n\t\t\t\t'Uncommitted changes',\n\t\t\t\t[],\n\t\t\t\t'Uncommitted changes',\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\t[],\n\t\t\t);\n\t\t}\n\n\t\treturn provider.getCommit(path, ref);\n\t}\n\n\t@log()\n\tgetCommitBranches(\n\t\trepoPath: string | Uri,\n\t\tref: string,\n\t\toptions?: { branch?: string; commitDate?: Date; mode?: 'contains' | 'pointsAt'; remotes?: boolean },\n\t): Promise<string[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitBranches(path, ref, options);\n\t}\n\n\t@log()\n\tgetCommitCount(repoPath: string | Uri, ref: string): Promise<number | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitCount(path, ref);\n\t}\n\n\t@log()\n\tasync getCommitForFile(\n\t\trepoPath: string | Uri | undefined,\n\t\turi: Uri,\n\t\toptions?: { ref?: string; firstIfNotFound?: boolean; range?: Range },\n\t): Promise<GitCommit | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitForFile(path, uri, options);\n\t}\n\n\t@log()\n\tgetCommitsForGraph(\n\t\trepoPath: string | Uri,\n\t\tasWebviewUri: (uri: Uri) => Uri,\n\t\toptions?: {\n\t\t\tbranch?: string;\n\t\t\tinclude?: { stats?: boolean };\n\t\t\tlimit?: number;\n\t\t\tref?: string;\n\t\t},\n\t): Promise<GitGraph> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitsForGraph(path, asWebviewUri, options);\n\t}\n\n\t@log()\n\tasync getConfig(repoPath: string, key: string): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getConfig?.(path, key);\n\t}\n\n\t@log()\n\tasync setConfig(repoPath: string, key: string, value: string | undefined): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.setConfig?.(path, key, value);\n\t}\n\n\t@log()\n\tasync getContributors(\n\t\trepoPath: string | Uri,\n\t\toptions?: { all?: boolean; ref?: string; stats?: boolean },\n\t): Promise<GitContributor[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getContributors(path, options);\n\t}\n\n\t@gate()\n\t@log()\n\tgetCurrentUser(repoPath: string | Uri): Promise<GitUser | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCurrentUser(path);\n\t}\n\n\t@log()\n\tasync getDefaultBranchName(repoPath: string | Uri | undefined, remote?: string): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDefaultBranchName(path, remote);\n\t}\n\n\t@log()\n\tasync getDiff(\n\t\trepoPath: string | Uri,\n\t\tref1: string,\n\t\tref2?: string,\n\t\toptions?: { includeRawDiff?: boolean },\n\t): Promise<GitDiff | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiff?.(path, ref1, ref2, options);\n\t}\n\n\t@log()\n\t/**\n\t * Returns a file diff between two commits\n\t * @param uri Uri of the file to diff\n\t * @param ref1 Commit to diff from\n\t * @param ref2 Commit to diff to\n\t */\n\tgetDiffForFile(uri: GitUri, ref1: string | undefined, ref2?: string): Promise<GitDiff | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForFile(uri, ref1, ref2);\n\t}\n\n\t@log<GitProviderService['getDiffForFileContents']>({ args: { 1: '<contents>' } })\n\t/**\n\t * Returns a file diff between a commit and the specified contents\n\t * @param uri Uri of the file to diff\n\t * @param ref Commit to diff from\n\t * @param contents Contents to use for the diff\n\t */\n\tgetDiffForFileContents(uri: GitUri, ref: string, contents: string): Promise<GitDiff | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForFileContents(uri, ref, contents);\n\t}\n\n\t@log()\n\t/**\n\t * Returns a line diff between two commits\n\t * @param uri Uri of the file to diff\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param ref1 Commit to diff from\n\t * @param ref2 Commit to diff to\n\t */\n\tgetDiffForLine(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tref1: string | undefined,\n\t\tref2?: string,\n\t): Promise<GitDiffHunkLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForLine(uri, editorLine, ref1, ref2);\n\t}\n\n\t@log()\n\tgetDiffStatus(\n\t\trepoPath: string | Uri,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions?: { filters?: GitDiffFilter[]; similarityThreshold?: number },\n\t): Promise<GitFile[] | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiffStatus(path, ref1, ref2, options);\n\t}\n\n\t@log()\n\tasync getFileStatusForCommit(repoPath: string | Uri, uri: Uri, ref: string): Promise<GitFile | undefined> {\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getFileStatusForCommit(path, uri, ref);\n\t}\n\n\t@debug()\n\tgetGitDir(repoPath: string): Promise<GitDir | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.getGitDir?.(path));\n\t}\n\n\t@debug()\n\tgetLastFetchedTimestamp(repoPath: string | Uri): Promise<number | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLastFetchedTimestamp(path);\n\t}\n\n\t@log()\n\tasync getLog(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLog(path, options);\n\t}\n\n\t@log()\n\tasync getLogRefsOnly(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<Set<string> | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLogRefsOnly(path, options);\n\t}\n\n\t@log()\n\tasync getLogForFile(\n\t\trepoPath: string | Uri | undefined,\n\t\tpathOrUri: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tforce?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLogForFile(path, pathOrUri, options);\n\t}\n\n\t@log()\n\tasync getMergeBase(\n\t\trepoPath: string | Uri,\n\t\tref1: string,\n\t\tref2: string,\n\t\toptions?: { forkPoint?: boolean },\n\t): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getMergeBase(path, ref1, ref2, options);\n\t}\n\n\t@gate()\n\t@log()\n\tasync getMergeStatus(repoPath: string | Uri): Promise<GitMergeStatus | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getMergeStatus(path);\n\t}\n\n\t@gate()\n\t@log()\n\tasync getRebaseStatus(repoPath: string | Uri): Promise<GitRebaseStatus | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getRebaseStatus(path);\n\t}\n\n\t@log()\n\tgetNextComparisonUris(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<NextComparisonUrisResult | undefined> {\n\t\tif (!ref) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getNextComparisonUris(path, uri, ref, skip);\n\t}\n\n\t@log()\n\tasync getOldestUnpushedRefForFile(repoPath: string | Uri, uri: Uri): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getOldestUnpushedRefForFile(path, uri);\n\t}\n\n\t@log()\n\tgetPreviousComparisonUris(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t\tfirstParent: boolean = false,\n\t): Promise<PreviousComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getPreviousComparisonUris(path, uri, ref, skip, firstParent);\n\t}\n\n\t@log()\n\tgetPreviousComparisonUrisForLine(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\teditorLine: number,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<PreviousLineComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getPreviousComparisonUrisForLine(path, uri, editorLine, ref, skip);\n\t}\n\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tremote: GitRemote<RemoteProvider | RichRemoteProvider>,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tprovider: RichRemoteProvider,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\t@gate<GitProviderService['getPullRequestForBranch']>((branch, remoteOrProvider, options) => {\n\t\tconst provider = GitRemote.is(remoteOrProvider) ? remoteOrProvider.provider : remoteOrProvider;\n\t\treturn `${branch}${\n\t\t\tprovider != null ? `|${provider.id}:${provider.domain}/${provider.path}` : ''\n\t\t}|${JSON.stringify(options)}`;\n\t})\n\t@debug<GitProviderService['getPullRequestForBranch']>({ args: { 1: remoteOrProvider => remoteOrProvider.name } })\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPR = provider.getPullRequestForBranch(branch, options);\n\t\tif (promiseOrPR == null || !isPromise(promiseOrPR)) {\n\t\t\treturn promiseOrPR;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPR = cancellable(promiseOrPR, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPR;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tremote: GitRemote,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tprovider: RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\t@gate<GitProviderService['getPullRequestForCommit']>((ref, remoteOrProvider, options) => {\n\t\tconst provider = GitRemote.is(remoteOrProvider) ? remoteOrProvider.provider : remoteOrProvider;\n\t\treturn `${ref}${provider != null ? `|${provider.id}:${provider.domain}/${provider.path}` : ''}|${\n\t\t\toptions?.timeout\n\t\t}`;\n\t})\n\t@debug<GitProviderService['getPullRequestForCommit']>({ args: { 1: remoteOrProvider => remoteOrProvider.name } })\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined> {\n\t\tif (isUncommitted(ref)) return undefined;\n\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet promiseOrPR = provider.getPullRequestForCommit(ref);\n\t\tif (promiseOrPR == null || !isPromise(promiseOrPR)) {\n\t\t\treturn promiseOrPR;\n\t\t}\n\n\t\tif (options?.timeout != null && options.timeout > 0) {\n\t\t\tpromiseOrPR = cancellable(promiseOrPR, options.timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPR;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getMyPullRequests']>({ args: { 0: remoteOrProvider => remoteOrProvider.name } })\n\tasync getMyPullRequests(\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<SearchedPullRequest[] | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPRs = provider.searchMyPullRequests();\n\t\tif (promiseOrPRs == null || !isPromise(promiseOrPRs)) {\n\t\t\treturn promiseOrPRs;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPRs = cancellable(promiseOrPRs, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPRs;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getMyIssues']>({ args: { 0: remoteOrProvider => remoteOrProvider.name } })\n\tasync getMyIssues(\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<SearchedIssue[] | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPRs = provider.searchMyIssues();\n\t\tif (promiseOrPRs == null || !isPromise(promiseOrPRs)) {\n\t\t\treturn promiseOrPRs;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPRs = cancellable(promiseOrPRs, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPRs;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getIncomingActivity(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitReflog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getIncomingActivity(path, options);\n\t}\n\n\tasync getBestRemoteWithProvider(\n\t\trepoPath: string | Uri | undefined,\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined>;\n\tasync getBestRemoteWithProvider(\n\t\tremotes: GitRemote[],\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined>;\n\t@gate<GitProviderService['getBestRemoteWithProvider']>(\n\t\tremotesOrRepoPath =>\n\t\t\t`${\n\t\t\t\tremotesOrRepoPath == null || typeof remotesOrRepoPath === 'string'\n\t\t\t\t\t? remotesOrRepoPath\n\t\t\t\t\t: remotesOrRepoPath instanceof Uri\n\t\t\t\t\t? remotesOrRepoPath.toString()\n\t\t\t\t\t: `${remotesOrRepoPath.length}:${remotesOrRepoPath[0]?.repoPath ?? ''}`\n\t\t\t}`,\n\t)\n\t@log<GitProviderService['getBestRemoteWithProvider']>({\n\t\targs: {\n\t\t\t0: remotesOrRepoPath =>\n\t\t\t\tArray.isArray(remotesOrRepoPath) ? remotesOrRepoPath.map(r => r.name).join(',') : remotesOrRepoPath,\n\t\t},\n\t})\n\tasync getBestRemoteWithProvider(\n\t\tremotesOrRepoPath: GitRemote[] | string | Uri | undefined,\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined> {\n\t\tif (remotesOrRepoPath == null) return undefined;\n\n\t\tlet remotes;\n\t\tlet repoPath;\n\t\tif (Array.isArray(remotesOrRepoPath)) {\n\t\t\tif (remotesOrRepoPath.length === 0) return undefined;\n\n\t\t\tremotes = remotesOrRepoPath;\n\t\t\trepoPath = remotesOrRepoPath[0].repoPath;\n\t\t} else {\n\t\t\trepoPath = remotesOrRepoPath;\n\t\t}\n\n\t\tif (typeof repoPath === 'string') {\n\t\t\trepoPath = this.getAbsoluteUri(repoPath);\n\t\t}\n\n\t\tconst cacheKey = asRepoComparisonKey(repoPath);\n\t\tlet remote = this._bestRemotesCache.get(cacheKey);\n\t\tif (remote !== undefined) return remote ?? undefined;\n\n\t\tremotes = (remotes ?? (await this.getRemotesWithProviders(repoPath))).filter(\n\t\t\t(r: GitRemote): r is GitRemote<RemoteProvider | RichRemoteProvider> => r.provider != null,\n\t\t);\n\n\t\tif (remotes.length === 0) return undefined;\n\n\t\tif (remotes.length === 1) {\n\t\t\tremote = remotes[0];\n\t\t} else {\n\t\t\tconst weightedRemotes = new Map<string, number>([\n\t\t\t\t['upstream', 15],\n\t\t\t\t['origin', 10],\n\t\t\t]);\n\n\t\t\tconst branch = await this.getBranch(remotes[0].repoPath);\n\t\t\tconst branchRemote = branch?.getRemoteName();\n\n\t\t\tif (branchRemote != null) {\n\t\t\t\tweightedRemotes.set(branchRemote, 100);\n\t\t\t}\n\n\t\t\tlet bestRemote;\n\t\t\tlet weight = 0;\n\t\t\tfor (const r of remotes) {\n\t\t\t\tif (r.default) {\n\t\t\t\t\tbestRemote = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Don't choose a remote unless its weighted above\n\t\t\t\tconst matchedWeight = weightedRemotes.get(r.name) ?? -1;\n\t\t\t\tif (matchedWeight > weight) {\n\t\t\t\t\tbestRemote = r;\n\t\t\t\t\tweight = matchedWeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremote = bestRemote ?? null;\n\t\t}\n\n\t\tthis._bestRemotesCache.set(cacheKey, remote);\n\n\t\treturn remote ?? undefined;\n\t}\n\n\tasync getBestRemoteWithRichProvider(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined>;\n\tasync getBestRemoteWithRichProvider(\n\t\tremotes: GitRemote[],\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined>;\n\t@gate<GitProviderService['getBestRemoteWithRichProvider']>(\n\t\t(remotesOrRepoPath, options) =>\n\t\t\t`${\n\t\t\t\tremotesOrRepoPath == null || typeof remotesOrRepoPath === 'string'\n\t\t\t\t\t? remotesOrRepoPath\n\t\t\t\t\t: remotesOrRepoPath instanceof Uri\n\t\t\t\t\t? remotesOrRepoPath.toString()\n\t\t\t\t\t: `${remotesOrRepoPath.length}:${remotesOrRepoPath[0]?.repoPath ?? ''}`\n\t\t\t}|${options?.includeDisconnected ?? false}`,\n\t)\n\t@log<GitProviderService['getBestRemoteWithRichProvider']>({\n\t\targs: {\n\t\t\t0: remotesOrRepoPath =>\n\t\t\t\tArray.isArray(remotesOrRepoPath) ? remotesOrRepoPath.map(r => r.name).join(',') : remotesOrRepoPath,\n\t\t},\n\t})\n\tasync getBestRemoteWithRichProvider(\n\t\tremotesOrRepoPath: GitRemote[] | string | Uri | undefined,\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined> {\n\t\tif (remotesOrRepoPath == null) return undefined;\n\n\t\tlet remotes;\n\t\tlet repoPath;\n\t\tif (Array.isArray(remotesOrRepoPath)) {\n\t\t\tif (remotesOrRepoPath.length === 0) return undefined;\n\n\t\t\tremotes = remotesOrRepoPath;\n\t\t\trepoPath = remotesOrRepoPath[0].repoPath;\n\t\t} else {\n\t\t\trepoPath = remotesOrRepoPath;\n\t\t}\n\n\t\tif (typeof repoPath === 'string') {\n\t\t\trepoPath = this.getAbsoluteUri(repoPath);\n\t\t}\n\n\t\tconst cacheKey = asRepoComparisonKey(repoPath);\n\n\t\tlet richRemote = this._bestRemotesCache.get(`rich+connected|${cacheKey}`);\n\t\tif (richRemote != null) return richRemote;\n\t\tif (richRemote === null && !options?.includeDisconnected) return undefined;\n\n\t\tif (options?.includeDisconnected) {\n\t\t\trichRemote = this._bestRemotesCache.get(`rich|${cacheKey}`);\n\t\t\tif (richRemote !== undefined) return richRemote ?? undefined;\n\t\t}\n\n\t\tconst remote = await (remotes != null\n\t\t\t? this.getBestRemoteWithProvider(remotes)\n\t\t\t: this.getBestRemoteWithProvider(repoPath));\n\n\t\tif (!remote?.hasRichProvider()) {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, null);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, null);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst { provider } = remote;\n\t\tconst connected = provider.maybeConnected ?? (await provider.isConnected());\n\t\tif (connected) {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, remote);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, remote);\n\t\t} else {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, remote);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, null);\n\n\t\t\tif (!options?.includeDisconnected) return undefined;\n\t\t}\n\n\t\treturn remote;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getRemotes(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { providers?: RemoteProviders; sort?: boolean },\n\t): Promise<GitRemote[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getRemotes(path, options);\n\t}\n\n\t@log()\n\tasync getRemotesWithProviders(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { sort?: boolean },\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider>[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst repository = this.container.git.getRepository(repoPath);\n\t\tconst remotes = await (repository != null\n\t\t\t? repository.getRemotes(options)\n\t\t\t: this.getRemotes(repoPath, options));\n\n\t\treturn remotes.filter(\n\t\t\t(r: GitRemote): r is GitRemote<RemoteProvider | RichRemoteProvider> => r.provider != null,\n\t\t);\n\t}\n\n\tgetBestRepository(): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepository(uri?: Uri, editor?: TextEditor): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepository(editor?: TextEditor): Repository | undefined;\n\t@log({ exit: true })\n\tgetBestRepository(editorOrUri?: TextEditor | Uri, editor?: TextEditor): Repository | undefined {\n\t\tconst count = this.repositoryCount;\n\t\tif (count === 0) return undefined;\n\t\tif (count === 1) return this.highlander;\n\n\t\tif (editorOrUri != null && editorOrUri instanceof Uri) {\n\t\t\tconst repo = this.getRepository(editorOrUri);\n\t\t\tif (repo != null) return repo;\n\n\t\t\teditorOrUri = undefined;\n\t\t}\n\n\t\teditor = editorOrUri ?? editor ?? window.activeTextEditor;\n\t\treturn (editor != null ? this.getRepository(editor.document.uri) : undefined) ?? this.highlander;\n\t}\n\n\tgetBestRepositoryOrFirst(): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepositoryOrFirst(uri?: Uri, editor?: TextEditor): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepositoryOrFirst(editor?: TextEditor): Repository | undefined;\n\t@log({ exit: true })\n\tgetBestRepositoryOrFirst(editorOrUri?: TextEditor | Uri, editor?: TextEditor): Repository | undefined {\n\t\tconst count = this.repositoryCount;\n\t\tif (count === 0) return undefined;\n\t\tif (count === 1) return first(this._repositories.values());\n\n\t\tif (editorOrUri != null && editorOrUri instanceof Uri) {\n\t\t\tconst repo = this.getRepository(editorOrUri);\n\t\t\tif (repo != null) return repo;\n\n\t\t\teditorOrUri = undefined;\n\t\t}\n\n\t\teditor = editorOrUri ?? editor ?? window.activeTextEditor;\n\t\treturn (\n\t\t\t(editor != null ? this.getRepository(editor.document.uri) : undefined) ?? first(this._repositories.values())\n\t\t);\n\t}\n\n\t@log({ exit: true })\n\tasync getOrOpenRepository(\n\t\turi: Uri,\n\t\toptions?: { closeOnOpen?: boolean; detectNested?: boolean; force?: boolean },\n\t): Promise<Repository | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst path = getBestPath(uri);\n\t\tlet repository: Repository | undefined;\n\t\trepository = this.getRepository(uri);\n\n\t\tlet isDirectory: boolean | undefined;\n\n\t\tconst detectNested = options?.detectNested ?? configuration.get('detectNestedRepositories', uri);\n\t\tif (!detectNested) {\n\t\t\tif (repository != null) return repository;\n\t\t} else if (!options?.force && this._visitedPaths.has(path)) {\n\t\t\treturn repository;\n\t\t} else {\n\t\t\tconst stats = await workspace.fs.stat(uri);\n\t\t\t// If the uri isn't a directory, go up one level\n\t\t\tif ((stats.type & FileType.Directory) !== FileType.Directory) {\n\t\t\t\turi = Uri.joinPath(uri, '..');\n\t\t\t\tif (!options?.force && this._visitedPaths.has(getBestPath(uri))) return repository;\n\t\t\t}\n\n\t\t\tisDirectory = true;\n\t\t}\n\n\t\tconst key = asRepoComparisonKey(uri);\n\t\tlet promise = this._pendingRepositories.get(key);\n\t\tif (promise == null) {\n\t\t\tasync function findRepository(this: GitProviderService): Promise<Repository | undefined> {\n\t\t\t\tconst { provider } = this.getProvider(uri);\n\t\t\t\tconst repoUri = await provider.findRepositoryUri(uri, isDirectory);\n\n\t\t\t\tthis._visitedPaths.set(path);\n\n\t\t\t\tif (repoUri == null) return undefined;\n\n\t\t\t\tlet root: Repository | undefined;\n\t\t\t\tif (this._repositories.count !== 0) {\n\t\t\t\t\trepository = this._repositories.get(repoUri);\n\t\t\t\t\tif (repository != null) return repository;\n\n\t\t\t\t\t// If this new repo is inside one of our known roots and we we don't already know about, add it\n\t\t\t\t\troot = this._repositories.getClosest(provider.getAbsoluteUri(uri, repoUri));\n\t\t\t\t}\n\n\t\t\t\tconst autoRepositoryDetection =\n\t\t\t\t\tconfiguration.getAny<CoreGitConfiguration, boolean | 'subFolders' | 'openEditors'>(\n\t\t\t\t\t\t'git.autoRepositoryDetection',\n\t\t\t\t\t) ?? true;\n\n\t\t\t\tconst closed =\n\t\t\t\t\toptions?.closeOnOpen ??\n\t\t\t\t\t(autoRepositoryDetection !== true && autoRepositoryDetection !== 'openEditors');\n\n\t\t\t\tLogger.log(scope, `Repository found in '${repoUri.toString(true)}'`);\n\t\t\t\tconst repositories = provider.openRepository(root?.folder, repoUri, false, undefined, closed);\n\t\t\t\tfor (const repository of repositories) {\n\t\t\t\t\tthis._repositories.add(repository);\n\t\t\t\t}\n\n\t\t\t\tthis._pendingRepositories.delete(key);\n\n\t\t\t\tthis.updateContext();\n\t\t\t\t// Send a notification that the repositories changed\n\t\t\t\tqueueMicrotask(() => this.fireRepositoriesChanged(repositories));\n\n\t\t\t\trepository = repositories.length === 1 ? repositories[0] : this.getRepository(uri);\n\t\t\t\treturn repository;\n\t\t\t}\n\n\t\t\tpromise = findRepository.call(this);\n\t\t\tthis._pendingRepositories.set(key, promise);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t@log<GitProviderService['getOrOpenRepositoryForEditor']>({\n\t\targs: { 0: e => (e != null ? `TextEditor(${Logger.toLoggable(e.document.uri)})` : undefined) },\n\t})\n\tasync getOrOpenRepositoryForEditor(editor?: TextEditor): Promise<Repository | undefined> {\n\t\teditor = editor ?? window.activeTextEditor;\n\n\t\tif (editor == null) return this.highlander;\n\n\t\treturn this.getOrOpenRepository(editor.document.uri);\n\t}\n\n\tgetRepository(uri: Uri): Repository | undefined;\n\tgetRepository(path: string): Repository | undefined;\n\tgetRepository(pathOrUri: string | Uri): Repository | undefined;\n\t@log({ exit: true })\n\tgetRepository(pathOrUri?: string | Uri): Repository | undefined {\n\t\tif (this.repositoryCount === 0) return undefined;\n\t\tif (pathOrUri == null) return undefined;\n\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (!pathOrUri) return undefined;\n\n\t\t\treturn this._repositories.getClosest(this.getAbsoluteUri(pathOrUri));\n\t\t}\n\n\t\treturn this._repositories.getClosest(pathOrUri);\n\t}\n\n\tasync getLocalInfoFromRemoteUri(\n\t\turi: Uri,\n\t\toptions?: { validate?: boolean },\n\t): Promise<{ uri: Uri; startLine?: number; endLine?: number } | undefined> {\n\t\tfor (const repo of this.openRepositories) {\n\t\t\tfor (const remote of await repo.getRemotes()) {\n\t\t\t\tconst local = await remote?.provider?.getLocalInfoFromRemoteUri(repo, uri, options);\n\t\t\t\tif (local != null) return local;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getStash(repoPath: string | Uri | undefined): Promise<GitStash | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStash(path);\n\t}\n\n\t@log()\n\tasync getStatusForFile(repoPath: string | Uri, uri: Uri): Promise<GitStatusFile | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForFile(path, uri);\n\t}\n\n\t@log()\n\tasync getStatusForFiles(repoPath: string | Uri, pathOrGlob: Uri): Promise<GitStatusFile[] | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForFiles(path, pathOrGlob);\n\t}\n\n\t@log()\n\tasync getStatusForRepo(repoPath: string | Uri | undefined): Promise<GitStatus | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForRepo(path);\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getTags(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { cursor?: string; filter?: (t: GitTag) => boolean; sort?: boolean | TagSortOptions },\n\t): Promise<PagedResult<GitTag>> {\n\t\tif (repoPath == null) return { values: [] };\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getTags(path, options);\n\t}\n\n\t@log()\n\tasync getTreeEntryForRevision(\n\t\trepoPath: string | Uri | undefined,\n\t\tpath: string,\n\t\tref: string,\n\t): Promise<GitTreeEntry | undefined> {\n\t\tif (repoPath == null || !path) return undefined;\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getTreeEntryForRevision(rp, provider.getRelativePath(path, rp), ref);\n\t}\n\n\t@log()\n\tasync getTreeForRevision(repoPath: string | Uri | undefined, ref: string): Promise<GitTreeEntry[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getTreeForRevision(path, ref);\n\t}\n\n\t@gate()\n\t@log()\n\tgetRevisionContent(repoPath: string | Uri, path: string, ref: string): Promise<Uint8Array | undefined> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getRevisionContent(rp, path, ref);\n\t}\n\n\t@log()\n\tasync getUniqueRepositoryId(repoPath: string | Uri): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\tconst id = await provider.getUniqueRepositoryId(path);\n\t\tif (id != null) return id;\n\n\t\treturn defaultRepositoryId;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasBranchOrTag(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: {\n\t\t\tfilter?: { branches?: (b: GitBranch) => boolean; tags?: (t: GitTag) => boolean };\n\t\t},\n\t): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.hasBranchOrTag(path, options);\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasCommitBeenPushed(repoPath: string | Uri, ref: string): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.hasCommitBeenPushed(path, ref);\n\t}\n\n\t@log()\n\tasync hasRemotes(repoPath: string | Uri | undefined): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst repository = this.getRepository(repoPath);\n\t\tif (repository == null) return false;\n\n\t\treturn repository.hasRemotes();\n\t}\n\n\t@log()\n\tasync hasTrackingBranch(repoPath: string | undefined): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst repository = this.getRepository(repoPath);\n\t\tif (repository == null) return false;\n\n\t\treturn repository.hasUpstreamBranch();\n\t}\n\n\t@log()\n\thasUnsafeRepositories(): boolean {\n\t\tfor (const provider of this._providers.values()) {\n\t\t\tif (provider.hasUnsafeRepositories?.()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@log<GitProviderService['isRepositoryForEditor']>({\n\t\targs: {\n\t\t\t0: r => r.uri.toString(true),\n\t\t\t1: e => (e != null ? `TextEditor(${Logger.toLoggable(e.document.uri)})` : undefined),\n\t\t},\n\t})\n\tisRepositoryForEditor(repository: Repository, editor?: TextEditor): boolean {\n\t\teditor = editor ?? window.activeTextEditor;\n\t\tif (editor == null) return false;\n\n\t\treturn repository === this.getRepository(editor.document.uri);\n\t}\n\n\tisTrackable(uri: Uri): boolean {\n\t\tif (!this.supportedSchemes.has(uri.scheme)) return false;\n\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.isTrackable(uri);\n\t}\n\n\tasync isTracked(uri: Uri): Promise<boolean> {\n\t\tif (!this.supportedSchemes.has(uri.scheme)) return false;\n\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.isTracked(uri);\n\t}\n\n\t@log()\n\tasync getDiffTool(repoPath?: string | Uri): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiffTool(path);\n\t}\n\n\t@log()\n\tasync openDiffTool(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\toptions?: { ref1?: string; ref2?: string; staged?: boolean; tool?: string },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.openDiffTool(path, uri, options);\n\t}\n\n\t@log()\n\tasync openDirectoryCompare(repoPath: string | Uri, ref1: string, ref2?: string, tool?: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.openDirectoryCompare(path, ref1, ref2, tool);\n\t}\n\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\tpath?: string,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t): Promise<string>;\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\turi?: Uri,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t): Promise<string>;\n\t@gate()\n\t@log()\n\tasync resolveReference(\n\t\trepoPath: string | Uri,\n\t\tref: string,\n\t\tpathOrUri?: string | Uri,\n\t\toptions?: { timeout?: number },\n\t) {\n\t\tif (pathOrUri != null && isUncommittedParent(ref)) {\n\t\t\tref = 'HEAD';\n\t\t}\n\n\t\tif (\n\t\t\t!ref ||\n\t\t\tref === deletedOrMissing ||\n\t\t\t(pathOrUri == null && isSha(ref)) ||\n\t\t\t(pathOrUri != null && isUncommitted(ref))\n\t\t) {\n\t\t\treturn ref;\n\t\t}\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.resolveReference(path, ref, pathOrUri, options);\n\t}\n\n\t@log<GitProviderService['richSearchCommits']>({\n\t\targs: {\n\t\t\t1: s =>\n\t\t\t\t`[${s.matchAll ? 'A' : ''}${s.matchCase ? 'C' : ''}${s.matchRegex ? 'R' : ''}]: ${\n\t\t\t\t\ts.query.length > 500 ? `${s.query.substring(0, 500)}...` : s.query\n\t\t\t\t}`,\n\t\t},\n\t})\n\tasync richSearchCommits(\n\t\trepoPath: string | Uri,\n\t\tsearch: SearchQuery,\n\t\toptions?: { limit?: number; ordering?: 'date' | 'author-date' | 'topo' | null; skip?: number },\n\t): Promise<GitLog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.richSearchCommits(path, search, options);\n\t}\n\n\t@log()\n\tsearchCommits(\n\t\trepoPath: string | Uri,\n\t\tsearch: SearchQuery,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo';\n\t\t},\n\t): Promise<GitSearch> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.searchCommits(path, search, options);\n\t}\n\n\t@log({ args: false })\n\tasync runGitCommandViaTerminal(\n\t\trepoPath: string | Uri,\n\t\tcommand: string,\n\t\targs: string[],\n\t\toptions?: { execute?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.runGitCommandViaTerminal?.(path, command, args, options);\n\t}\n\n\t@log()\n\tvalidateBranchOrTagName(repoPath: string | Uri, ref: string): Promise<boolean> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.validateBranchOrTagName(path, ref);\n\t}\n\n\t@log()\n\tasync validateReference(repoPath: string | Uri, ref: string) {\n\t\tif (ref == null || ref.length === 0) return false;\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return true;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.validateReference(path, ref);\n\t}\n\n\tstageFile(repoPath: string | Uri, path: string): Promise<void>;\n\tstageFile(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tstageFile(repoPath: string | Uri, pathOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stageFile(path, pathOrUri);\n\t}\n\n\tstageDirectory(repoPath: string | Uri, directory: string): Promise<void>;\n\tstageDirectory(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tstageDirectory(repoPath: string | Uri, directoryOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stageDirectory(path, directoryOrUri);\n\t}\n\n\tunStageFile(repoPath: string | Uri, path: string): Promise<void>;\n\tunStageFile(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tunStageFile(repoPath: string | Uri, pathOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.unStageFile(path, pathOrUri);\n\t}\n\n\tunStageDirectory(repoPath: string | Uri, directory: string): Promise<void>;\n\tunStageDirectory(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tunStageDirectory(repoPath: string | Uri, directoryOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.unStageDirectory(path, directoryOrUri);\n\t}\n\n\t@log()\n\tasync stashApply(repoPath: string | Uri, stashName: string, options?: { deleteAfter?: boolean }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashApply?.(path, stashName, options);\n\t}\n\n\t@log()\n\tasync stashDelete(repoPath: string | Uri, stashName: string, ref?: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashDelete?.(path, stashName, ref);\n\t}\n\n\t@log()\n\tasync stashRename(\n\t\trepoPath: string | Uri,\n\t\tstashName: string,\n\t\tref: string,\n\t\tmessage: string,\n\t\tstashOnRef?: string,\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashRename?.(path, stashName, ref, message, stashOnRef);\n\t}\n\n\t@log<GitProviderService['stashSave']>({ args: { 2: uris => uris?.length } })\n\tasync stashSave(\n\t\trepoPath: string | Uri,\n\t\tmessage?: string,\n\t\turis?: Uri[],\n\t\toptions?: { includeUntracked?: boolean; keepIndex?: boolean; onlyStaged?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashSave?.(path, message, uris, options);\n\t}\n\n\t@log()\n\tcreateWorktree(\n\t\trepoPath: string | Uri,\n\t\tpath: string,\n\t\toptions?: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.createWorktree?.(rp, path, options));\n\t}\n\n\t@log()\n\tasync getWorktree(\n\t\trepoPath: string | Uri,\n\t\tpredicate: (w: GitWorktree) => boolean,\n\t): Promise<GitWorktree | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn ((await provider.getWorktrees?.(path)) ?? []).find(predicate);\n\t}\n\n\t@log()\n\tasync getWorktrees(repoPath: string | Uri): Promise<GitWorktree[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn (await provider.getWorktrees?.(path)) ?? [];\n\t}\n\n\t@log()\n\tasync getWorktreesDefaultUri(path: string | Uri): Promise<Uri | undefined> {\n\t\tconst { provider, path: rp } = this.getProvider(path);\n\t\tlet defaultUri = await provider.getWorktreesDefaultUri?.(rp);\n\t\tif (defaultUri != null) return defaultUri;\n\n\t\t// If we don't have a default set, default it to the parent folder of the repo folder\n\t\tdefaultUri = this.getRepository(rp)?.uri;\n\t\tif (defaultUri != null) {\n\t\t\tdefaultUri = Uri.joinPath(defaultUri, '..');\n\t\t}\n\t\treturn defaultUri;\n\t}\n\n\t@log()\n\tdeleteWorktree(repoPath: string | Uri, path: string, options?: { force?: boolean }): Promise<void> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.deleteWorktree?.(rp, path, options));\n\t}\n\t@log()\n\tasync getOpenScmRepositories(): Promise<ScmRepository[]> {\n\t\tconst results = await Promise.allSettled([...this._providers.values()].map(p => p.getOpenScmRepositories()));\n\t\tconst repositories = flatMap<PromiseFulfilledResult<ScmRepository[]>, ScmRepository>(\n\t\t\tfilter<PromiseSettledResult<ScmRepository[]>, PromiseFulfilledResult<ScmRepository[]>>(\n\t\t\t\tresults,\n\t\t\t\t(r): r is PromiseFulfilledResult<ScmRepository[]> => r.status === 'fulfilled',\n\t\t\t),\n\t\t\tr => r.value,\n\t\t);\n\t\treturn [...repositories];\n\t}\n\n\t@log()\n\tgetScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getScmRepository(path);\n\t}\n\n\t@log()\n\tgetOrOpenScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getOrOpenScmRepository(path);\n\t}\n}\n", "<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t</head>\n\n\t<body class=\"home preload\">\n\t\t<a href=\"#links\" class=\"sr-skip sr-only-focusable\">skip to links</a>\n\t\t<a href=\"#main\" class=\"sr-skip sr-only-focusable\">skip to main content</a>\n\t\t<div class=\"home__nav\">\n\t\t\t<nav class=\"inline-nav\" id=\"links\" tabindex=\"-1\" aria-label=\"Help and Resources\">\n\t\t\t\t<div class=\"inline-nav__group\">\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://help.gitkraken.com/gitlens/gitlens-release-notes-current/\"\n\t\t\t\t\t\taria-label=\"What's New\"\n\t\t\t\t\t\ttitle=\"What's New\"\n\t\t\t\t\t\t><span class=\"codicon codicon-rocket\"></span><span>What's New</span></a\n\t\t\t\t\t>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://help.gitkraken.com/gitlens/gitlens-home/\"\n\t\t\t\t\t\taria-label=\"Help Center\"\n\t\t\t\t\t\ttitle=\"Help Center\"\n\t\t\t\t\t\t><span class=\"codicon codicon-question\"></span><span>Help</span></a\n\t\t\t\t\t>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens/issues\"\n\t\t\t\t\t\taria-label=\"Feedback\"\n\t\t\t\t\t\ttitle=\"Feedback\"\n\t\t\t\t\t\t><span class=\"codicon codicon-feedback\"></span><span>Feedback</span></a\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"inline-nav__group\">\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens/discussions\"\n\t\t\t\t\t\taria-label=\"GitHub Discussions\"\n\t\t\t\t\t\ttitle=\"GitHub Discussions\"\n\t\t\t\t\t\t><span class=\"codicon codicon-comment-discussion\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens\"\n\t\t\t\t\t\taria-label=\"GitHub Repo\"\n\t\t\t\t\t\ttitle=\"GitHub Repo\"\n\t\t\t\t\t\t><span class=\"codicon codicon-github\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://twitter.com/gitlens\"\n\t\t\t\t\t\taria-label=\"@gitlens on Twitter\"\n\t\t\t\t\t\ttitle=\"@gitlens on Twitter\"\n\t\t\t\t\t\t><span class=\"codicon codicon-twitter\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://gitkraken.com/gitlens?utm_source=gitlens-extension&utm_medium=in-app-links&utm_campaign=gitlens-logo-links\"\n\t\t\t\t\t\taria-label=\"GitLens Website\"\n\t\t\t\t\t\ttitle=\"GitLens Website\"\n\t\t\t\t\t\t><span class=\"codicon codicon-globe\"></span\n\t\t\t\t\t></a>\n\t\t\t\t</div>\n\t\t\t</nav>\n\t\t</div>\n\t\t<header class=\"home__header\">\n\t\t\t<div id=\"no-repo-alert\" class=\"alert alert--info mb-0\" aria-hidden=\"true\" hidden>\n\t\t\t\t<h1 class=\"alert__title\">No repository detected</h1>\n\t\t\t\t<div class=\"alert__description\">\n\t\t\t\t\t<p>\n\t\t\t\t\t\tTo use GitLens, open a folder containing a git repository or clone from a URL from the Explorer.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"centered\">\n\t\t\t\t\t\t<vscode-button data-action=\"command:workbench.view.explorer\"\n\t\t\t\t\t\t\t>Open a Folder or Repository</vscode-button\n\t\t\t\t\t\t>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tIf you have opened a folder with a repository, please let us know by\n\t\t\t\t\t\t<a class=\"one-line\" href=\"https://github.com/gitkraken/vscode-gitlens/issues/new/choose\"\n\t\t\t\t\t\t\t>creating an Issue</a\n\t\t\t\t\t\t>.\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div id=\"unsafe-repo-alert\" class=\"alert alert--info mb-0\" aria-hidden=\"true\" hidden>\n\t\t\t\t<h1 class=\"alert__title\">Unsafe repository</h1>\n\t\t\t\t<div class=\"alert__description\">\n\t\t\t\t\t<p>\n\t\t\t\t\t\tUnable to open any repositories as Git blocked them as potentially unsafe, due to the folder(s)\n\t\t\t\t\t\tnot being owned by the current user.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"centered\">\n\t\t\t\t\t\t<vscode-button data-action=\"command:workbench.view.scm\">Manage in Source Control</vscode-button>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<header-card id=\"header-card\" image=\"#{webroot}/media/gitlens-logo.webp\"></header-card>\n\t\t</header>\n\t\t<main class=\"home__main scrollable\" id=\"main\" tabindex=\"-1\">\n\t\t\t<style nonce=\"#{cspNonce}\">\n\t\t\t\t.video-banner {\n\t\t\t\t\t--video-banner-bg: url(#{webroot}/media/getting-started.webp);\n\t\t\t\t}\n\t\t\t\t.vscode-high-contrast .video-banner,\n\t\t\t\t.vscode-dark .video-banner {\n\t\t\t\t\t--video-banner-play: url(#{webroot}/media/play-button.webp);\n\t\t\t\t}\n\t\t\t\t.vscode-high-contrast-light .video-banner,\n\t\t\t\t.vscode-light .video-banner {\n\t\t\t\t\t--video-banner-play: url(#{webroot}/media/play-button-dark.webp);\n\t\t\t\t}\n\t\t\t\t.gl-plus-banner {\n\t\t\t\t\tbackground-image: url(#{webroot}/media/gitlens-backdrop-opacity.webp);\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<div class=\"stepped-sections\">\n\t\t\t\t<stepped-section id=\"welcome\">\n\t\t\t\t\t<span slot=\"heading\">Welcome to GitLens 13</span>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tGitLens supercharges Git inside VS Code and unlocks the untapped knowledge within each\n\t\t\t\t\t\trepository.\n\t\t\t\t\t</p>\n\t\t\t\t\t<a class=\"video-banner\" href=\"https://www.youtube.com/watch?v=UQPb73Zz9qk\">\n\t\t\t\t\t\t<span>Get Started</span> <small>Tutorial Video</small>\n\t\t\t\t\t</a>\n\t\t\t\t\t<ul class=\"icon-list mb-0\">\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<code-icon icon=\"circle-filled\"></code-icon>\n\t\t\t\t\t\t\t<a href=\"command:gitlens.showWelcomePage?%22quick-setup%22\">Quick Setup</a> &mdash; quickly\n\t\t\t\t\t\t\tpersonalize GitLens to your needs.\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<code-icon icon=\"circle-filled\"></code-icon>\n\t\t\t\t\t\t\t<a href=\"command:gitlens.showSettingsPage\">Interactive Settings editor</a> &mdash; fine-tune\n\t\t\t\t\t\t\tyour GitLens experience.\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"features\">\n\t\t\t\t\t<span slot=\"heading\">Features</span>\n\t\t\t\t\t<span slot=\"description\">always free and accessible</span>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tGitLens is deeply integrated into many areas and aspects of VS Code, especially editors and\n\t\t\t\t\t\tviews. Learn more in the <a href=\"command:gitlens.getStarted\">Feature Walkthrough</a>.\n\t\t\t\t\t</p>\n\t\t\t\t\t<card-section no-heading id=\"no-repo\" aria-hidden=\"true\">\n\t\t\t\t\t\t<p class=\"centered mb-0\">\n\t\t\t\t\t\t\tTo use GitLens, open a folder containing a git repository or clone from a URL from the\n\t\t\t\t\t\t\tExplorer.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</card-section>\n\t\t\t\t\t<div class=\"activitybar-banner\">\n\t\t\t\t\t\t<div class=\"activitybar-banner__content\">\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\tFind many features by opening the\n\t\t\t\t\t\t\t\t<a href=\"command:workbench.view.scm\">Source Control Side Bar</a>.\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\tClick on\n\t\t\t\t\t\t\t\t<span aria-hidden=\"true\"\n\t\t\t\t\t\t\t\t\t>the icon <span class=\"not-small\">to the left</span\n\t\t\t\t\t\t\t\t\t><span class=\"only-small\">below</span></span\n\t\t\t\t\t\t\t\t><span class=\"sr-only\">a layout option</span> to set the location of your GitLens views.\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<nav class=\"activitybar-banner__media\" aria-label=\"GitLens Layout\">\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\thref=\"command:gitlens.setViewsLayout?%7B%22layout%22%3A%22scm%22%7D\"\n\t\t\t\t\t\t\t\tclass=\"activitybar-banner__nav-item\"\n\t\t\t\t\t\t\t\ttitle=\"Move views to the Source Control side bar\"\n\t\t\t\t\t\t\t\taria-label=\"Move views to the Source Control side bar\"\n\t\t\t\t\t\t\t></a>\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\thref=\"command:gitlens.setViewsLayout?%7B%22layout%22%3A%22gitlens%22%7D\"\n\t\t\t\t\t\t\t\tclass=\"activitybar-banner__nav-item\"\n\t\t\t\t\t\t\t\ttitle=\"Move views to the GitLens side bar\"\n\t\t\t\t\t\t\t\taria-label=\"Move views to the GitLens side bar\"\n\t\t\t\t\t\t\t></a>\n\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\tclass=\"svg\"\n\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\t\t\tviewBox=\"0 0 68 91\"\n\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\tstyle=\"max-width: 9.2rem\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<rect x=\".5\" y=\".5\" width=\"40\" height=\"90\" rx=\"16.5\" stroke=\"url(#a)\" />\n\t\t\t\t\t\t\t\t<rect x=\"3\" y=\"3\" width=\"35\" height=\"85\" rx=\"14\" fill=\"#333\" class=\"svg__bar\" />\n\t\t\t\t\t\t\t\t<g clip-path=\"url(#b)\" class=\"svg__icon\" data-gitlens-layout=\"gitlens\">\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"m22.08 63-2.14-2.14.75-.75 2.14 2.13-.75.76ZM18.73 66.08v-5.16h1.06v5.16h-1.06Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M19.26 69.17a1.6 1.6 0 1 0 0-3.2 1.6 1.6 0 0 0 0 3.2ZM23.51 65.27a1.6 1.6 0 1 0 0-3.19 1.6 1.6 0 0 0 0 3.2ZM19.26 61.02a1.6 1.6 0 1 0 0-3.19 1.6 1.6 0 0 0 0 3.2Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M20.5 55.89a7.61 7.61 0 1 0 0 15.22 7.61 7.61 0 0 0 0-15.22ZM12 63.5a8.5 8.5 0 1 1 17 0 8.5 8.5 0 0 1-17 0Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\tfill=\"#fff\"\n\t\t\t\t\t\t\t\t\td=\"M3 52h1v23H3z\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__indicator\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"gitlens\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<g clip-path=\"url(#c)\" class=\"svg__icon\" data-gitlens-layout=\"scm\">\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M26.76 25.17a2.8 2.8 0 1 0-3.6 2.67 2.24 2.24 0 0 1-2.01 1.25h-2.24c-.83 0-1.63.31-2.24.87v-5.41a2.8 2.8 0 1 0-1.13 0v6.84a2.83 2.83 0 1 0 1.37.07 2.24 2.24 0 0 1 2-1.25h2.24a3.36 3.36 0 0 0 3.17-2.28 2.8 2.8 0 0 0 2.44-2.76ZM14.42 21.8a1.68 1.68 0 1 1 3.37 0 1.68 1.68 0 0 1-3.37 0Zm3.37 12.33a1.68 1.68 0 1 1-3.37 0 1.68 1.68 0 0 1 3.37 0Zm6.16-7.28a1.68 1.68 0 1 1 0-3.37 1.68 1.68 0 0 1 0 3.37Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t<path fill=\"#fff\" d=\"M3 16h1v24H3z\" class=\"svg__indicator\" data-gitlens-layout=\"scm\" />\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td=\"M67.67 64a2.67 2.67 0 1 0-5.34 0 2.67 2.67 0 0 0 5.34 0ZM49 64l5 2.89V61.1L49 64Zm16-.5H53.5v1H65v-1Z\"\n\t\t\t\t\t\t\t\t\tfill=\"red\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__arrow\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"gitlens\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td=\"M67.67 28a2.67 2.67 0 1 0-5.34 0 2.67 2.67 0 0 0 5.34 0ZM49 28l5 2.89V25.1L49 28Zm16-.5H53.5v1H65v-1Z\"\n\t\t\t\t\t\t\t\t\tfill=\"#007FD5\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__arrow\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"scm\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t\t\t<clipPath id=\"b\">\n\t\t\t\t\t\t\t\t\t\t<path fill=\"#fff\" transform=\"translate(12 55)\" d=\"M0 0h17v17H0z\" />\n\t\t\t\t\t\t\t\t\t</clipPath>\n\t\t\t\t\t\t\t\t\t<clipPath id=\"c\">\n\t\t\t\t\t\t\t\t\t\t<path fill=\"#fff\" transform=\"translate(11 19)\" d=\"M0 0h18v18H0z\" />\n\t\t\t\t\t\t\t\t\t</clipPath>\n\t\t\t\t\t\t\t\t\t<linearGradient\n\t\t\t\t\t\t\t\t\t\tid=\"a\"\n\t\t\t\t\t\t\t\t\t\tx1=\"20.5\"\n\t\t\t\t\t\t\t\t\t\ty1=\"-23.19\"\n\t\t\t\t\t\t\t\t\t\tx2=\"20.5\"\n\t\t\t\t\t\t\t\t\t\ty2=\"91\"\n\t\t\t\t\t\t\t\t\t\tgradientUnits=\"userSpaceOnUse\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<stop stop-color=\"#333\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t\t<stop offset=\"1\" stop-color=\"#333\" stop-opacity=\"0\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t\t<stop offset=\"1\" stop-color=\"#333\" stop-opacity=\"0\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t</linearGradient>\n\t\t\t\t\t\t\t\t</defs>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t</nav>\n\t\t\t\t\t</div>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"plus\">\n\t\t\t\t\t<span slot=\"heading\">GitLens+ Features</span>\n\t\t\t\t\t<span slot=\"description\">want even more from GitLens?</span>\n\t\t\t\t\t<card-section class=\"gl-plus-banner mb-1\" no-heading>\n\t\t\t\t\t\t<div class=\"centered plus-banner-text\">\n\t\t\t\t\t\t\t<plus-banner id=\"plus-banner\"></plus-banner>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</card-section>\n\t\t\t\t\t<plus-content id=\"plus-content\"></plus-content>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"integrations\">\n\t\t\t\t\t<span slot=\"heading\">Integrations</span>\n\t\t\t\t\t<p>GitLens provides issue and pull request auto-linking with many Git hosting services.</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tRich integrations with GitHub & GitLab provide more detailed hover information for auto-linked\n\t\t\t\t\t\tissues and pull requests, pull requests associated with branches and commits, and avatars.\n\t\t\t\t\t</p>\n\t\t\t\t</stepped-section>\n\t\t\t</div>\n\t\t\t<!-- check for gitlens+ -->\n\t\t\t<div id=\"plus-sections\">\n\t\t\t\t<card-section dismissable id=\"focus-view-preview\">\n\t\t\t\t\t<span slot=\"heading\">Focus View \u2728 (preview)</span>\n\t\t\t\t\t<a title=\"Open the Focus view\" href=\"command:gitlens.showFocusPage\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-focus-view-preview.webp\"\n\t\t\t\t\t\t\talt=\"Focus view Screenshot\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a title=\"Open the Focus view\" href=\"command:gitlens.showFocusPage\">Focus View</a>\n\t\t\t\t\t\tprovides you with a comprehensive list of all your most important work across your connected\n\t\t\t\t\t\tGitHub repos.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"commit-graph\">\n\t\t\t\t\t<span slot=\"heading\">Commit Graph \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about the Commit Graph\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.commitGraph%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-commit-graph-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Commit Graph illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about the Commit Graph\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.commitGraph%22\"\n\t\t\t\t\t\t\t>Commit Graph</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\thelps you easily visualize and keep track of all work in progress.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tUse the rich commit search to find exactly what you're looking for. It's powerful filters allow\n\t\t\t\t\t\tyou to search by a specific commit, message, author, a changed file or files, or even a specific\n\t\t\t\t\t\tcode change.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"visual-file-history\">\n\t\t\t\t\t<span slot=\"heading\">Visual File History \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about the Visual File History\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.visualFileHistory%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-visual-file-history-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Visual File History illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about the Visual File History\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.visualFileHistory%22\"\n\t\t\t\t\t\t\t>Visual File History</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\tallows you to quickly see the evolution of a file, including when changes were made, how large\n\t\t\t\t\t\tthey were, and who made them.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tUse it to quickly find when the most impactful changes were made to a file or who best to talk\n\t\t\t\t\t\tto about file changes and more.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"worktrees\">\n\t\t\t\t\t<span slot=\"heading\">Worktrees \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about Worktrees\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.worktrees%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-worktrees-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Worktrees illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about Worktrees\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.worktrees%22\"\n\t\t\t\t\t\t\t>Worktrees</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\thelp you multitask by minimizing the context switching between branches, allowing you to easily\n\t\t\t\t\t\twork on different branches of a repository simultaneously.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tAvoid interrupting your work in progress when needing to review a pull request. Simply create a\n\t\t\t\t\t\tnew worktree and open it in a new VS Code window, all without impacting your other work\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t</div>\n\t\t\t<div class=\"button-container\">\n\t\t\t\t<vscode-button appearance=\"secondary\" data-action=\"command:workbench.action.toggleSidebarVisibility\"\n\t\t\t\t\t>Close</vscode-button\n\t\t\t\t>\n\t\t\t\t<a id=\"restore-welcome\" class=\"link-minimal\" href=\"command:gitlens.home.restoreWelcome\"\n\t\t\t\t\t>Restore Home view state</a\n\t\t\t\t>\n\t\t\t</div>\n\t\t</main>\n\n\t\t#{endOfBody}\n\t\t<style nonce=\"#{cspNonce}\">\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'codicon';\n\t\t\t\tfont-display: block;\n\t\t\t\tsrc: url('#{webroot}/codicon.ttf?0e5b0adf625a37fbcd638d31f0fe72aa') format('truetype');\n\t\t\t}\n\t\t</style>\n\t</body>\n</html>\n", "/*global*/\nimport './home.scss';\nimport { provideVSCodeDesignSystem, vsCodeButton } from '@vscode/webview-ui-toolkit';\nimport type { Disposable } from 'vscode';\nimport { getSubscriptionTimeRemaining, SubscriptionState } from '../../../subscription';\nimport type { State } from '../../home/protocol';\nimport {\n\tCompleteStepCommandType,\n\tDidChangeConfigurationType,\n\tDidChangeLayoutType,\n\tDidChangeRepositoriesType,\n\tDidChangeSubscriptionNotificationType,\n\tDismissBannerCommandType,\n\tDismissSectionCommandType,\n\tDismissStatusCommandType,\n} from '../../home/protocol';\nimport type { IpcMessage } from '../../protocol';\nimport { ExecuteCommandType, onIpc } from '../../protocol';\nimport { App } from '../shared/appBase';\nimport { DOM } from '../shared/dom';\nimport type { CardSection } from './components/card-section';\nimport type { HeaderCard } from './components/header-card';\nimport type { PlusBanner } from './components/plus-banner';\nimport type { SteppedSection } from './components/stepped-section';\nimport '../shared/components/code-icon';\nimport '../shared/components/overlays/pop-over';\nimport './components/card-section';\nimport './components/header-card';\nimport './components/plus-banner';\nimport './components/plus-content';\nimport './components/stepped-section';\n\nexport class HomeApp extends App<State> {\n\tprivate $steps!: SteppedSection[];\n\tprivate $cards!: CardSection[];\n\n\tconstructor() {\n\t\tsuper('HomeApp');\n\t}\n\n\tprotected override onInitialize() {\n\t\tprovideVSCodeDesignSystem().register(vsCodeButton());\n\n\t\tthis.$steps = [...document.querySelectorAll<SteppedSection>('stepped-section[id]')];\n\t\tthis.$cards = [...document.querySelectorAll<CardSection>('card-section[id]')];\n\n\t\tthis.state = this.getState() ?? this.state;\n\t\tthis.updateState();\n\t}\n\n\tprotected override onBind(): Disposable[] {\n\t\tconst disposables = super.onBind?.() ?? [];\n\n\t\tdisposables.push(\n\t\t\tDOM.on('[data-action]', 'click', (e, target: HTMLElement) => this.onDataActionClicked(e, target)),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<PlusBanner, string>('plus-banner', 'action', (e, target: HTMLElement) =>\n\t\t\t\tthis.onPlusActionClicked(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<SteppedSection, boolean>('stepped-section', 'complete', (e, target: HTMLElement) =>\n\t\t\t\tthis.onStepComplete(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<CardSection, undefined>('card-section', 'dismiss', (e, target: HTMLElement) =>\n\t\t\t\tthis.onCardDismissed(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<HeaderCard, undefined>('header-card', 'dismiss-status', (e, target: HTMLElement) =>\n\t\t\t\tthis.onStatusDismissed(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on('[data-banner-dismiss]', 'click', (e, target: HTMLElement) => this.onBannerDismissed(e, target)),\n\t\t);\n\n\t\treturn disposables;\n\t}\n\n\tprotected override onMessageReceived(e: MessageEvent) {\n\t\tconst msg = e.data as IpcMessage;\n\n\t\tswitch (msg.method) {\n\t\t\tcase DidChangeSubscriptionNotificationType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeSubscriptionNotificationType, msg, params => {\n\t\t\t\t\tthis.state.subscription = params.subscription;\n\t\t\t\t\tthis.state.completedActions = params.completedActions;\n\t\t\t\t\tthis.state.avatar = params.avatar;\n\t\t\t\t\tthis.state.pinStatus = params.pinStatus;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateState();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeRepositoriesType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeRepositoriesType, msg, params => {\n\t\t\t\t\tthis.state.repositories = { ...params };\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateNoRepo();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeConfigurationType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeConfigurationType, msg, params => {\n\t\t\t\t\tthis.state.plusEnabled = params.plusEnabled;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updatePlusContent();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeLayoutType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeLayoutType, msg, params => {\n\t\t\t\t\tthis.state.layout = params.layout;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateLayout();\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tsuper.onMessageReceived?.(e);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate onStepComplete(e: CustomEvent<boolean>, target: HTMLElement) {\n\t\tconst id = target.id;\n\t\tconst isComplete = e.detail ?? false;\n\t\tthis.state.completedSteps = toggleArrayItem(this.state.completedSteps, id, isComplete);\n\t\tthis.sendCommand(CompleteStepCommandType, { id: id, completed: isComplete });\n\t\tthis.updateState();\n\t}\n\n\tprivate onCardDismissed(e: CustomEvent<undefined>, target: HTMLElement) {\n\t\tconst id = target.id;\n\t\tthis.state.dismissedSections = toggleArrayItem(this.state.dismissedSections, id);\n\t\tthis.sendCommand(DismissSectionCommandType, { id: id });\n\t\tthis.updateState();\n\t}\n\n\tprivate onStatusDismissed(_e: CustomEvent<undefined>, _target: HTMLElement) {\n\t\tthis.state.pinStatus = false;\n\t\tthis.sendCommand(DismissStatusCommandType, undefined);\n\t\tthis.updateHeader();\n\t}\n\n\tprivate onBannerDismissed(_e: MouseEvent, target: HTMLElement) {\n\t\tconst key = target.getAttribute('data-banner-dismiss');\n\t\tif (key == null || this.state.dismissedBanners?.includes(key)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.state.dismissedBanners = this.state.dismissedBanners ?? [];\n\t\tthis.state.dismissedBanners.push(key);\n\t\tthis.sendCommand(DismissBannerCommandType, { id: key });\n\t\tthis.updateBanners();\n\t}\n\n\tprivate onDataActionClicked(_e: MouseEvent, target: HTMLElement) {\n\t\tconst action = target.dataset.action;\n\t\tthis.onActionClickedCore(action);\n\t}\n\n\tprivate onPlusActionClicked(e: CustomEvent<string>, _target: HTMLElement) {\n\t\tthis.onActionClickedCore(e.detail);\n\t}\n\n\tprivate onActionClickedCore(action?: string) {\n\t\tif (action?.startsWith('command:')) {\n\t\t\tthis.sendCommand(ExecuteCommandType, { command: action.slice(8) });\n\t\t}\n\t}\n\n\tprivate getDaysRemaining() {\n\t\tif (\n\t\t\t![SubscriptionState.FreeInPreviewTrial, SubscriptionState.FreePlusInTrial].includes(\n\t\t\t\tthis.state.subscription.state,\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn getSubscriptionTimeRemaining(this.state.subscription, 'days') ?? 0;\n\t}\n\n\tprivate forceShowPlus() {\n\t\treturn [\n\t\t\tSubscriptionState.FreePreviewTrialExpired,\n\t\t\tSubscriptionState.FreePlusTrialExpired,\n\t\t\tSubscriptionState.VerificationRequired,\n\t\t].includes(this.state.subscription.state);\n\t}\n\n\tprivate updateHeader(days = this.getDaysRemaining(), forceShowPlus = this.forceShowPlus()) {\n\t\tconst { subscription, completedSteps, avatar, pinStatus } = this.state;\n\n\t\tconst $headerContent = document.getElementById('header-card') as HeaderCard;\n\t\tif ($headerContent) {\n\t\t\tif (avatar) {\n\t\t\t\t$headerContent.setAttribute('image', avatar);\n\t\t\t}\n\t\t\t$headerContent.setAttribute('name', subscription.account?.name ?? '');\n\n\t\t\tconst steps = this.$steps?.length ?? 0;\n\t\t\tlet completed = completedSteps?.length ?? 0;\n\t\t\tif (steps > 0 && completed > 0) {\n\t\t\t\tconst stepIds = this.$steps.map(el => el.id);\n\t\t\t\tconst availableCompleted = completedSteps!.filter(name => stepIds.includes(name));\n\t\t\t\tcompleted = availableCompleted.length;\n\n\t\t\t\tif (forceShowPlus && availableCompleted.includes('plus')) {\n\t\t\t\t\tcompleted -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$headerContent.setAttribute('steps', steps.toString());\n\t\t\t$headerContent.setAttribute('completed', completed.toString());\n\t\t\t$headerContent.setAttribute('state', subscription.state.toString());\n\t\t\t$headerContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t\t$headerContent.setAttribute('days', days.toString());\n\t\t\t$headerContent.pinStatus = pinStatus;\n\t\t}\n\t}\n\n\tprivate updateBanners() {\n\t\tconst $banners = [...document.querySelectorAll('[data-banner]')];\n\t\tif (!$banners.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { dismissedBanners } = this.state;\n\t\t$banners.forEach($el => {\n\t\t\tconst key = $el.getAttribute('data-banner');\n\t\t\tif (key !== null && dismissedBanners?.includes(key)) {\n\t\t\t\t$el.setAttribute('hidden', 'true');\n\t\t\t} else {\n\t\t\t\t$el.removeAttribute('hidden');\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateNoRepo() {\n\t\tconst { repositories } = this.state;\n\t\tconst hasRepos = repositories.openCount > 0;\n\t\tconst value = hasRepos ? 'true' : 'false';\n\n\t\tlet $el = document.getElementById('no-repo');\n\t\t$el?.setAttribute('aria-hidden', value);\n\t\tif (hasRepos) {\n\t\t\t$el?.setAttribute('hidden', value);\n\t\t} else {\n\t\t\t$el?.removeAttribute('hidden');\n\t\t}\n\n\t\t$el = document.getElementById('no-repo-alert');\n\t\tconst showUnsafe = repositories.hasUnsafe && !hasRepos;\n\t\tconst $unsafeEl = document.getElementById('unsafe-repo-alert');\n\t\tif (showUnsafe) {\n\t\t\t$el?.setAttribute('aria-hidden', 'true');\n\t\t\t$el?.setAttribute('hidden', 'true');\n\t\t\t$unsafeEl?.setAttribute('aria-hidden', 'false');\n\t\t\t$unsafeEl?.removeAttribute('hidden');\n\t\t} else {\n\t\t\t$unsafeEl?.setAttribute('aria-hidden', 'true');\n\t\t\t$unsafeEl?.setAttribute('hidden', 'true');\n\t\t\t$el?.setAttribute('aria-hidden', value);\n\t\t\tif (hasRepos) {\n\t\t\t\t$el?.setAttribute('hidden', value);\n\t\t\t} else {\n\t\t\t\t$el?.removeAttribute('hidden');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate updateLayout() {\n\t\tconst { layout } = this.state;\n\n\t\tconst $els = [...document.querySelectorAll('[data-gitlens-layout]')];\n\t\t$els.forEach(el => {\n\t\t\tconst attr = el.getAttribute('data-gitlens-layout');\n\t\t\tel.classList.toggle('is-active', attr === layout);\n\t\t});\n\t}\n\n\tprivate updatePlusContent(days = this.getDaysRemaining()) {\n\t\tconst { subscription, visibility, plusEnabled } = this.state;\n\n\t\tlet $plusContent = document.getElementById('plus-banner');\n\t\tif ($plusContent) {\n\t\t\t$plusContent.setAttribute('days', days.toString());\n\t\t\t$plusContent.setAttribute('state', subscription.state.toString());\n\t\t\t$plusContent.setAttribute('visibility', visibility);\n\t\t\t$plusContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t\t$plusContent.setAttribute('plus', plusEnabled.toString());\n\t\t\t($plusContent as PlusBanner).hasRepositories = this.state.repositories.count > 0;\n\t\t}\n\n\t\t$plusContent = document.getElementById('plus-content');\n\t\tif ($plusContent) {\n\t\t\t$plusContent.setAttribute('days', days.toString());\n\t\t\t$plusContent.setAttribute('state', subscription.state.toString());\n\t\t\t$plusContent.setAttribute('visibility', visibility);\n\t\t\t$plusContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t}\n\t}\n\n\tprivate updateSteps(forceShowPlus = this.forceShowPlus()) {\n\t\tif (\n\t\t\tthis.$steps == null ||\n\t\t\tthis.$steps.length === 0 ||\n\t\t\tthis.state.completedSteps == null ||\n\t\t\tthis.state.completedSteps.length === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$steps.forEach(el => {\n\t\t\tel.setAttribute(\n\t\t\t\t'completed',\n\t\t\t\t(el.id === 'plus' && forceShowPlus) || this.state.completedSteps?.includes(el.id) !== true\n\t\t\t\t\t? 'false'\n\t\t\t\t\t: 'true',\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate updateSections() {\n\t\tif (\n\t\t\tthis.$cards == null ||\n\t\t\tthis.$cards.length === 0 ||\n\t\t\tthis.state.dismissedSections == null ||\n\t\t\tthis.state.dismissedSections.length === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.dismissedSections.forEach(id => {\n\t\t\tconst found = this.$cards.findIndex(el => el.id === id);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.$cards[found].remove();\n\t\t\t\tthis.$cards.splice(found, 1);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateState() {\n\t\tconst { completedSteps, dismissedSections } = this.state;\n\n\t\tthis.updateNoRepo();\n\t\tthis.updateLayout();\n\n\t\tconst showRestoreWelcome = completedSteps?.length || dismissedSections?.length;\n\t\tdocument.getElementById('restore-welcome')?.classList.toggle('hide', !showRestoreWelcome);\n\n\t\tconst forceShowPlus = this.forceShowPlus();\n\t\tconst days = this.getDaysRemaining();\n\t\tthis.updateHeader(days, forceShowPlus);\n\t\tthis.updatePlusContent(days);\n\n\t\tthis.updateSteps(forceShowPlus);\n\n\t\tthis.updateSections();\n\t\tthis.updateBanners();\n\t}\n}\n\nfunction toggleArrayItem(list: string[] = [], item: string, add = true) {\n\tconst hasStep = list.includes(item);\n\tif (!hasStep && add) {\n\t\tlist.push(item);\n\t} else if (hasStep && !add) {\n\t\tlist.splice(list.indexOf(item), 1);\n\t}\n\n\treturn list;\n}\n\nnew HomeApp();\n", "import type { ConfigurationChangeEvent } from 'vscode';\nimport { Disposable, window } from 'vscode';\nimport { getAvatarUriFromGravatarEmail } from '../../avatars';\nimport { ViewsLayout } from '../../commands/setViewsLayout';\nimport type { Container } from '../../container';\nimport type { RepositoriesVisibility } from '../../git/gitProviderService';\nimport type { SubscriptionChangeEvent } from '../../plus/subscription/subscriptionService';\nimport type { Subscription } from '../../subscription';\nimport { executeCoreCommand, registerCommand } from '../../system/command';\nimport { configuration } from '../../system/configuration';\nimport type { Deferrable } from '../../system/function';\nimport { debounce } from '../../system/function';\nimport type { StorageChangeEvent } from '../../system/storage';\nimport type { IpcMessage } from '../protocol';\nimport { onIpc } from '../protocol';\nimport type { WebviewController, WebviewProvider } from '../webviewController';\nimport type { CompleteStepParams, DismissBannerParams, DismissSectionParams, State } from './protocol';\nimport {\n\tCompletedActions,\n\tCompleteStepCommandType,\n\tDidChangeConfigurationType,\n\tDidChangeLayoutType,\n\tDidChangeRepositoriesType,\n\tDidChangeSubscriptionNotificationType,\n\tDismissBannerCommandType,\n\tDismissSectionCommandType,\n\tDismissStatusCommandType,\n} from './protocol';\n\nexport class HomeWebviewProvider implements WebviewProvider<State> {\n\tprivate readonly _disposable: Disposable;\n\n\tconstructor(private readonly container: Container, private readonly host: WebviewController<State>) {\n\t\tthis._disposable = Disposable.from(\n\t\t\tthis.container.subscription.onDidChange(this.onSubscriptionChanged, this),\n\t\t\tthis.container.git.onDidChangeRepositories(this.onRepositoriesChanged, this),\n\t\t\tconfiguration.onDidChange(this.onConfigurationChanged, this),\n\t\t\tthis.container.storage.onDidChange(this.onStorageChanged, this),\n\t\t);\n\t}\n\n\tdispose() {\n\t\tthis._disposable.dispose();\n\t}\n\n\tprivate onConfigurationChanged(e: ConfigurationChangeEvent) {\n\t\tif (!configuration.changed(e, 'plusFeatures.enabled')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notifyDidChangeConfiguration();\n\t}\n\n\tprivate onRepositoriesChanged() {\n\t\tthis.notifyDidChangeRepositories();\n\t}\n\n\tprivate onStorageChanged(e: StorageChangeEvent) {\n\t\tif (e.key !== 'views:layout') return;\n\n\t\tthis.notifyDidChangeLayout();\n\t}\n\n\tprivate async onSubscriptionChanged(e: SubscriptionChangeEvent) {\n\t\tawait this.container.storage.store('home:status:pinned', true);\n\t\tvoid this.notifyDidChangeData(e.current);\n\t}\n\n\tonVisibilityChanged(visible: boolean): void {\n\t\tif (!visible) {\n\t\t\tthis._validateSubscriptionDebounced?.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tqueueMicrotask(() => void this.validateSubscription());\n\t}\n\n\tonWindowFocusChanged(focused: boolean): void {\n\t\tif (!focused || !this.host.visible) {\n\t\t\tthis._validateSubscriptionDebounced?.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tqueueMicrotask(() => void this.validateSubscription());\n\t}\n\n\tregisterCommands(): Disposable[] {\n\t\treturn [\n\t\t\tregisterCommand(`${this.host.id}.refresh`, () => this.host.refresh(true), this),\n\t\t\tregisterCommand('gitlens.home.toggleWelcome', async () => {\n\t\t\t\tconst welcomeVisible = !this.welcomeVisible;\n\t\t\t\tawait this.container.storage.store('views:welcome:visible', welcomeVisible);\n\t\t\t\tif (welcomeVisible) {\n\t\t\t\t\tawait Promise.allSettled([\n\t\t\t\t\t\tthis.container.storage.store('home:actions:completed', []),\n\t\t\t\t\t\tthis.container.storage.store('home:steps:completed', []),\n\t\t\t\t\t\tthis.container.storage.store('home:sections:dismissed', []),\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tvoid this.host.refresh();\n\t\t\t}),\n\t\t\tregisterCommand('gitlens.home.restoreWelcome', async () => {\n\t\t\t\tawait Promise.allSettled([\n\t\t\t\t\tthis.container.storage.store('home:steps:completed', []),\n\t\t\t\t\tthis.container.storage.store('home:sections:dismissed', []),\n\t\t\t\t]);\n\n\t\t\t\tvoid this.host.refresh();\n\t\t\t}),\n\n\t\t\tregisterCommand('gitlens.home.showSCM', async () => {\n\t\t\t\tconst completedActions = this.container.storage.get('home:actions:completed', []);\n\t\t\t\tif (!completedActions.includes(CompletedActions.OpenedSCM)) {\n\t\t\t\t\tcompletedActions.push(CompletedActions.OpenedSCM);\n\t\t\t\t\tawait this.container.storage.store('home:actions:completed', completedActions);\n\n\t\t\t\t\tvoid this.notifyDidChangeData();\n\t\t\t\t}\n\n\t\t\t\tawait executeCoreCommand('workbench.view.scm');\n\t\t\t}),\n\t\t];\n\t}\n\n\tonMessageReceived(e: IpcMessage) {\n\t\tswitch (e.method) {\n\t\t\tcase CompleteStepCommandType.method:\n\t\t\t\tonIpc(CompleteStepCommandType, e, params => this.completeStep(params));\n\t\t\t\tbreak;\n\t\t\tcase DismissSectionCommandType.method:\n\t\t\t\tonIpc(DismissSectionCommandType, e, params => this.dismissSection(params));\n\t\t\t\tbreak;\n\t\t\tcase DismissStatusCommandType.method:\n\t\t\t\tonIpc(DismissStatusCommandType, e, _params => this.dismissPinStatus());\n\t\t\t\tbreak;\n\t\t\tcase DismissBannerCommandType.method:\n\t\t\t\tonIpc(DismissBannerCommandType, e, params => this.dismissBanner(params));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate async completeStep({ id, completed = false }: CompleteStepParams) {\n\t\tconst steps = this.container.storage.get('home:steps:completed', []);\n\n\t\tconst hasStep = steps.includes(id);\n\t\tif (!hasStep && completed) {\n\t\t\tsteps.push(id);\n\t\t} else if (hasStep && !completed) {\n\t\t\tsteps.splice(steps.indexOf(id), 1);\n\t\t}\n\n\t\tawait this.container.storage.store('home:steps:completed', steps);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissSection(params: DismissSectionParams) {\n\t\tconst sections = this.container.storage.get('home:sections:dismissed', []);\n\t\tif (sections.includes(params.id)) return;\n\n\t\tsections.push(params.id);\n\n\t\tawait this.container.storage.store('home:sections:dismissed', sections);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissBanner(params: DismissBannerParams) {\n\t\tconst banners = this.container.storage.get('home:banners:dismissed', []);\n\n\t\tif (!banners.includes(params.id)) {\n\t\t\tbanners.push(params.id);\n\t\t}\n\n\t\tawait this.container.storage.store('home:banners:dismissed', banners);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissPinStatus() {\n\t\tawait this.container.storage.store('home:status:pinned', false);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tincludeBootstrap(): Promise<State> {\n\t\treturn this.getState();\n\t}\n\n\tprivate get welcomeVisible(): boolean {\n\t\treturn this.container.storage.get('views:welcome:visible', true);\n\t}\n\n\tprivate async getRepoVisibility(): Promise<RepositoriesVisibility> {\n\t\tconst visibility = await this.container.git.visibility();\n\t\treturn visibility;\n\t}\n\n\tprivate async getSubscription(subscription?: Subscription) {\n\t\t// Make sure to make a copy of the array otherwise it will be live to the storage value\n\t\tconst completedActions = [...this.container.storage.get('home:actions:completed', [])];\n\t\tif (!this.welcomeVisible) {\n\t\t\tcompletedActions.push(CompletedActions.DismissedWelcome);\n\t\t}\n\n\t\tconst sub = subscription ?? (await this.container.subscription.getSubscription(true));\n\n\t\tlet avatar;\n\t\tif (sub.account?.email) {\n\t\t\tavatar = getAvatarUriFromGravatarEmail(sub.account.email, 34).toString();\n\t\t} else {\n\t\t\tavatar = `${this.host.getWebRoot() ?? ''}/media/gitlens-logo.webp`;\n\t\t}\n\n\t\treturn {\n\t\t\tsubscription: sub,\n\t\t\tcompletedActions: completedActions,\n\t\t\tavatar: avatar,\n\t\t};\n\t}\n\n\tprivate getPinStatus() {\n\t\treturn this.container.storage.get('home:status:pinned') ?? true;\n\t}\n\n\tprivate async getState(subscription?: Subscription): Promise<State> {\n\t\tconst sub = await this.getSubscription(subscription);\n\t\tconst steps = this.container.storage.get('home:steps:completed', []);\n\t\tconst sections = this.container.storage.get('home:sections:dismissed', []);\n\t\tconst dismissedBanners = this.container.storage.get('home:banners:dismissed', []);\n\n\t\treturn {\n\t\t\ttimestamp: Date.now(),\n\t\t\trepositories: this.getRepositoriesState(),\n\t\t\twebroot: this.host.getWebRoot(),\n\t\t\tsubscription: sub.subscription,\n\t\t\tcompletedActions: sub.completedActions,\n\t\t\tplusEnabled: this.getPlusEnabled(),\n\t\t\tvisibility: await this.getRepoVisibility(),\n\t\t\tcompletedSteps: steps,\n\t\t\tdismissedSections: sections,\n\t\t\tavatar: sub.avatar,\n\t\t\tlayout: this.getLayout(),\n\t\t\tpinStatus: this.getPinStatus(),\n\t\t\tdismissedBanners: dismissedBanners,\n\t\t};\n\t}\n\n\tprivate notifyDidChangeData(subscription?: Subscription) {\n\t\tif (!this.host.ready) return false;\n\n\t\treturn window.withProgress({ location: { viewId: this.host.id } }, async () => {\n\t\t\tconst sub = await this.getSubscription(subscription);\n\t\t\treturn this.host.notify(DidChangeSubscriptionNotificationType, {\n\t\t\t\t...sub,\n\t\t\t\tpinStatus: this.getPinStatus(),\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getRepositoriesState() {\n\t\treturn {\n\t\t\tcount: this.container.git.repositoryCount,\n\t\t\topenCount: this.container.git.openRepositoryCount,\n\t\t\thasUnsafe: this.container.git.hasUnsafeRepositories(),\n\t\t};\n\t}\n\n\tprivate notifyDidChangeRepositories() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeRepositoriesType, this.getRepositoriesState());\n\t}\n\n\tprivate getPlusEnabled() {\n\t\treturn configuration.get('plusFeatures.enabled');\n\t}\n\n\tprivate notifyDidChangeConfiguration() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeConfigurationType, {\n\t\t\tplusEnabled: this.getPlusEnabled(),\n\t\t});\n\t}\n\n\tprivate getLayout() {\n\t\tconst layout = this.container.storage.get('views:layout');\n\t\treturn layout != null ? (layout as ViewsLayout) : ViewsLayout.SourceControl;\n\t}\n\n\tprivate notifyDidChangeLayout() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeLayoutType, { layout: this.getLayout() });\n\t}\n\n\tprivate _validateSubscriptionDebounced: Deferrable<HomeWebviewProvider['validateSubscription']> | undefined =\n\t\tundefined;\n\n\tprivate async validateSubscription(): Promise<void> {\n\t\tif (this._validateSubscriptionDebounced == null) {\n\t\t\tthis._validateSubscriptionDebounced = debounce(this.validateSubscriptionCore, 1000);\n\t\t}\n\n\t\tawait this._validateSubscriptionDebounced();\n\t}\n\n\tprivate _validating: Promise<void> | undefined;\n\tprivate async validateSubscriptionCore() {\n\t\tif (this._validating == null) {\n\t\t\tthis._validating = this.container.subscription.validate();\n\t\t\ttry {\n\t\t\t\tawait this._validating;\n\t\t\t} finally {\n\t\t\t\tthis._validating = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n", "import type { ViewsLayout } from '../../commands/setViewsLayout';\nimport type { RepositoriesVisibility } from '../../git/gitProviderService';\nimport type { Subscription } from '../../subscription';\nimport { IpcCommandType, IpcNotificationType } from '../protocol';\n\nexport const enum CompletedActions {\n\tDismissedWelcome = 'dismissed:welcome',\n\tOpenedSCM = 'opened:scm',\n}\n\nexport interface State {\n\ttimestamp: number;\n\n\trepositories: DidChangeRepositoriesParams;\n\twebroot?: string;\n\tsubscription: Subscription;\n\tcompletedActions: CompletedActions[];\n\tcompletedSteps?: string[];\n\tdismissedBanners?: string[];\n\tdismissedSections?: string[];\n\tplusEnabled: boolean;\n\tvisibility: RepositoriesVisibility;\n\tavatar?: string;\n\tlayout: ViewsLayout;\n\tpinStatus: boolean;\n}\n\nexport interface CompleteStepParams {\n\tid: string;\n\tcompleted: boolean;\n}\nexport const CompleteStepCommandType = new IpcCommandType<CompleteStepParams>('home/step/complete');\n\nexport interface DismissSectionParams {\n\tid: string;\n}\nexport const DismissSectionCommandType = new IpcCommandType<DismissSectionParams>('home/section/dismiss');\n\nexport const DismissStatusCommandType = new IpcCommandType<undefined>('home/status/dismiss');\n\nexport interface DismissBannerParams {\n\tid: string;\n}\nexport const DismissBannerCommandType = new IpcCommandType<DismissBannerParams>('home/banner/dismiss');\n\nexport interface DidChangeSubscriptionParams {\n\tsubscription: Subscription;\n\tcompletedActions: CompletedActions[];\n\tavatar?: string;\n\tpinStatus: boolean;\n}\nexport const DidChangeSubscriptionNotificationType = new IpcNotificationType<DidChangeSubscriptionParams>(\n\t'subscription/didChange',\n);\n\nexport interface DidChangeRepositoriesParams {\n\tcount: number;\n\topenCount: number;\n\thasUnsafe: boolean;\n}\nexport const DidChangeRepositoriesType = new IpcNotificationType<DidChangeRepositoriesParams>('repositories/didChange');\n\nexport interface DidChangeConfigurationParams {\n\tplusEnabled: boolean;\n}\nexport const DidChangeConfigurationType = new IpcNotificationType<DidChangeConfigurationParams>(\n\t'configuration/didChange',\n);\n\nexport interface DidChangeLayoutParams {\n\tlayout: ViewsLayout;\n}\nexport const DidChangeLayoutType = new IpcNotificationType<DidChangeLayoutParams>('layout/didChange');\n"], "fixing_code": ["import type { ChildProcess, SpawnOptions } from 'child_process';\nimport { spawn } from 'child_process';\nimport { accessSync } from 'fs';\nimport * as process from 'process';\nimport type { CancellationToken, OutputChannel } from 'vscode';\nimport { Uri, window, workspace } from 'vscode';\nimport { hrtime } from '@env/hrtime';\nimport type { CoreConfiguration } from '../../../constants';\nimport { GlyphChars } from '../../../constants';\nimport type { GitCommandOptions, GitSpawnOptions } from '../../../git/commandOptions';\nimport { GitErrorHandling } from '../../../git/commandOptions';\nimport { StashPushError, StashPushErrorReason, WorkspaceUntrustedError } from '../../../git/errors';\nimport type { GitDiffFilter } from '../../../git/models/diff';\nimport { isUncommitted, isUncommittedStaged, shortenRevision } from '../../../git/models/reference';\nimport type { GitUser } from '../../../git/models/user';\nimport { GitBranchParser } from '../../../git/parsers/branchParser';\nimport { GitLogParser } from '../../../git/parsers/logParser';\nimport { GitReflogParser } from '../../../git/parsers/reflogParser';\nimport { GitTagParser } from '../../../git/parsers/tagParser';\nimport { splitAt } from '../../../system/array';\nimport { configuration } from '../../../system/configuration';\nimport { log } from '../../../system/decorators/log';\nimport { join } from '../../../system/iterable';\nimport { Logger } from '../../../system/logger';\nimport { LogLevel, slowCallWarningThreshold } from '../../../system/logger.constants';\nimport { getLogScope } from '../../../system/logger.scope';\nimport { dirname, isAbsolute, isFolderGlob, joinPaths, normalizePath, splitPath } from '../../../system/path';\nimport { equalsIgnoreCase, getDurationMilliseconds } from '../../../system/string';\nimport { getEditorCommand } from '../../../system/utils';\nimport { compare, fromString } from '../../../system/version';\nimport { ensureGitTerminal } from '../../../terminal';\nimport { isWindows } from '../platform';\nimport type { GitLocation } from './locator';\nimport type { RunOptions } from './shell';\nimport { fsExists, getWindowsShortPath, run, RunError } from './shell';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyObj = Object.freeze({});\nconst emptyStr = '';\n\nconst gitBranchDefaultConfigs = Object.freeze(['-c', 'color.branch=false']);\nconst gitDiffDefaultConfigs = Object.freeze(['-c', 'color.diff=false']);\nexport const gitLogDefaultConfigs = Object.freeze(['-c', 'log.showSignature=false']);\nexport const gitLogDefaultConfigsWithFiles = Object.freeze([\n\t'-c',\n\t'log.showSignature=false',\n\t'-c',\n\t'diff.renameLimit=0',\n]);\nconst gitStatusDefaultConfigs = Object.freeze(['-c', 'color.status=false']);\n\nexport const maxGitCliLength = 30000;\n\nconst textDecoder = new TextDecoder('utf8');\n\n// This is a root sha of all git repo's if using sha1\nconst rootSha = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\n\nexport const GitErrors = {\n\tbadRevision: /bad revision '(.*?)'/i,\n\tnoFastForward: /\\(non-fast-forward\\)/i,\n\tnoMergeBase: /no merge base/i,\n\tnotAValidObjectName: /Not a valid object name/i,\n\tinvalidLineCount: /file .+? has only \\d+ lines/i,\n\tuncommittedChanges: /contains modified or untracked files/i,\n\talreadyExists: /already exists/i,\n\talreadyCheckedOut: /already checked out/i,\n\tmainWorkingTree: /is a main working tree/i,\n};\n\nconst GitWarnings = {\n\tnotARepository: /Not a git repository/i,\n\toutsideRepository: /is outside repository/i,\n\tnoPath: /no such path/i,\n\tnoCommits: /does not have any commits/i,\n\tnotFound: /Path '.*?' does not exist in/i,\n\tfoundButNotInRevision: /Path '.*?' exists on disk, but not in/i,\n\theadNotABranch: /HEAD does not point to a branch/i,\n\tnoUpstream: /no upstream configured for branch '(.*?)'/i,\n\tunknownRevision:\n\t\t/ambiguous argument '.*?': unknown revision or path not in the working tree|not stored as a remote-tracking branch/i,\n\tmustRunInWorkTree: /this operation must be run in a work tree/i,\n\tpatchWithConflicts: /Applied patch to '.*?' with conflicts/i,\n\tnoRemoteRepositorySpecified: /No remote repository specified\\./i,\n\tremoteConnectionError: /Could not read from remote repository/i,\n\tnotAGitCommand: /'.+' is not a git command/i,\n};\n\nfunction defaultExceptionHandler(ex: Error, cwd: string | undefined, start?: [number, number]): string {\n\tconst msg = ex.message || ex.toString();\n\tif (msg != null && msg.length !== 0) {\n\t\tfor (const warning of Object.values(GitWarnings)) {\n\t\t\tif (warning.test(msg)) {\n\t\t\t\tconst duration = start !== undefined ? ` [${getDurationMilliseconds(start)}ms]` : '';\n\t\t\t\tLogger.warn(\n\t\t\t\t\t`[${cwd}] Git ${msg\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)}${duration}`,\n\t\t\t\t);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\tconst match = GitErrors.badRevision.exec(msg);\n\t\tif (match != null) {\n\t\t\tconst [, ref] = match;\n\n\t\t\t// Since looking up a ref with ^3 (e.g. looking for untracked files in a stash) can error on some versions of git just ignore it\n\t\t\tif (ref?.endsWith('^3')) return '';\n\t\t}\n\t}\n\n\tthrow ex;\n}\n\ntype ExitCodeOnlyGitCommandOptions = GitCommandOptions & { exitCodeOnly: true };\n\nexport class Git {\n\t/** Map of running git commands -- avoids running duplicate overlaping commands */\n\tprivate readonly pendingCommands = new Map<string, Promise<string | Buffer>>();\n\n\tasync git(options: ExitCodeOnlyGitCommandOptions, ...args: any[]): Promise<number>;\n\tasync git<T extends string | Buffer>(options: GitCommandOptions, ...args: any[]): Promise<T>;\n\tasync git<T extends string | Buffer>(options: GitCommandOptions, ...args: any[]): Promise<T> {\n\t\tif (!workspace.isTrusted) throw new WorkspaceUntrustedError();\n\n\t\tconst start = hrtime();\n\n\t\tconst { configs, correlationKey, errors: errorHandling, encoding, ...opts } = options;\n\n\t\tconst runOpts: RunOptions = {\n\t\t\t...opts,\n\t\t\tencoding: (encoding ?? 'utf8') === 'utf8' ? 'utf8' : 'buffer',\n\t\t\t// Adds GCM environment variables to avoid any possible credential issues -- from https://github.com/Microsoft/vscode/issues/26573#issuecomment-338686581\n\t\t\t// Shouldn't *really* be needed but better safe than sorry\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\t...(options.env ?? emptyObj),\n\t\t\t\tGCM_INTERACTIVE: 'NEVER',\n\t\t\t\tGCM_PRESERVE_CREDS: 'TRUE',\n\t\t\t\tLC_ALL: 'C',\n\t\t\t},\n\t\t};\n\n\t\tconst gitCommand = `[${runOpts.cwd}] git ${args.join(' ')}`;\n\n\t\tconst command = `${correlationKey !== undefined ? `${correlationKey}:` : ''}${gitCommand}`;\n\n\t\tlet waiting;\n\t\tlet promise = this.pendingCommands.get(command);\n\t\tif (promise === undefined) {\n\t\t\twaiting = false;\n\n\t\t\t// Fixes https://github.com/gitkraken/vscode-gitlens/issues/73 & https://github.com/gitkraken/vscode-gitlens/issues/161\n\t\t\t// See https://stackoverflow.com/questions/4144417/how-to-handle-asian-characters-in-file-names-in-git-on-os-x\n\t\t\targs.unshift(\n\t\t\t\t'-c',\n\t\t\t\t'core.quotepath=false',\n\t\t\t\t'-c',\n\t\t\t\t'color.ui=false',\n\t\t\t\t...(configs != null ? configs : emptyArray),\n\t\t\t);\n\n\t\t\tif (process.platform === 'win32') {\n\t\t\t\targs.unshift('-c', 'core.longpaths=true');\n\t\t\t}\n\n\t\t\tpromise = run<T>(await this.path(), args, encoding ?? 'utf8', runOpts);\n\n\t\t\tthis.pendingCommands.set(command, promise);\n\t\t} else {\n\t\t\twaiting = true;\n\t\t\tLogger.debug(`[GIT  ] ${gitCommand} ${GlyphChars.Dot} waiting...`);\n\t\t}\n\n\t\tlet exception: Error | undefined;\n\t\ttry {\n\t\t\treturn (await promise) as T;\n\t\t} catch (ex) {\n\t\t\texception = ex;\n\n\t\t\tswitch (errorHandling) {\n\t\t\t\tcase GitErrorHandling.Ignore:\n\t\t\t\t\texception = undefined;\n\t\t\t\t\treturn '' as T;\n\n\t\t\t\tcase GitErrorHandling.Throw:\n\t\t\t\t\tthrow ex;\n\n\t\t\t\tdefault: {\n\t\t\t\t\tconst result = defaultExceptionHandler(ex, options.cwd, start);\n\t\t\t\t\texception = undefined;\n\t\t\t\t\treturn result as T;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.pendingCommands.delete(command);\n\n\t\t\tconst duration = getDurationMilliseconds(start);\n\t\t\tconst slow = duration > slowCallWarningThreshold;\n\t\t\tconst status =\n\t\t\t\tslow || waiting\n\t\t\t\t\t? ` (${slow ? `slow${waiting ? ', waiting' : ''}` : ''}${waiting ? 'waiting' : ''})`\n\t\t\t\t\t: '';\n\n\t\t\tif (exception != null) {\n\t\t\t\tLogger.error(\n\t\t\t\t\t'',\n\t\t\t\t\t`[GIT  ] ${gitCommand} ${GlyphChars.Dot} ${(exception.message || String(exception) || '')\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)} [${duration}ms]${status}`,\n\t\t\t\t);\n\t\t\t} else if (slow) {\n\t\t\t\tLogger.warn(`[GIT  ] ${gitCommand} [*${duration}ms]${status}`);\n\t\t\t} else {\n\t\t\t\tLogger.log(`[GIT  ] ${gitCommand} [${duration}ms]${status}`);\n\t\t\t}\n\t\t\tthis.logGitCommand(\n\t\t\t\t`${gitCommand}${exception != null ? ` ${GlyphChars.Dot} FAILED` : ''}${waiting ? ' (waited)' : ''}`,\n\t\t\t\tduration,\n\t\t\t\texception,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync gitSpawn(options: GitSpawnOptions, ...args: any[]): Promise<ChildProcess> {\n\t\tif (!workspace.isTrusted) throw new WorkspaceUntrustedError();\n\n\t\tconst start = hrtime();\n\n\t\tconst { cancellation, configs, stdin, stdinEncoding, ...opts } = options;\n\n\t\tconst spawnOpts: SpawnOptions = {\n\t\t\t// Unless provided, ignore stdin and leave default streams for stdout and stderr\n\t\t\tstdio: [stdin ? 'pipe' : 'ignore', null, null],\n\t\t\t...opts,\n\t\t\t// Adds GCM environment variables to avoid any possible credential issues -- from https://github.com/Microsoft/vscode/issues/26573#issuecomment-338686581\n\t\t\t// Shouldn't *really* be needed but better safe than sorry\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\t...(options.env ?? emptyObj),\n\t\t\t\tGCM_INTERACTIVE: 'NEVER',\n\t\t\t\tGCM_PRESERVE_CREDS: 'TRUE',\n\t\t\t\tLC_ALL: 'C',\n\t\t\t},\n\t\t};\n\n\t\tconst gitCommand = `[${spawnOpts.cwd as string}] git ${args.join(' ')}`;\n\n\t\t// Fixes https://github.com/gitkraken/vscode-gitlens/issues/73 & https://github.com/gitkraken/vscode-gitlens/issues/161\n\t\t// See https://stackoverflow.com/questions/4144417/how-to-handle-asian-characters-in-file-names-in-git-on-os-x\n\t\targs.unshift(\n\t\t\t'-c',\n\t\t\t'core.quotepath=false',\n\t\t\t'-c',\n\t\t\t'color.ui=false',\n\t\t\t...(configs !== undefined ? configs : emptyArray),\n\t\t);\n\n\t\tif (process.platform === 'win32') {\n\t\t\targs.unshift('-c', 'core.longpaths=true');\n\t\t}\n\n\t\tif (cancellation) {\n\t\t\tconst controller = new AbortController();\n\t\t\tspawnOpts.signal = controller.signal;\n\t\t\tcancellation.onCancellationRequested(() => controller.abort());\n\t\t}\n\n\t\tconst proc = spawn(await this.path(), args, spawnOpts);\n\t\tif (stdin) {\n\t\t\tproc.stdin?.end(stdin, (stdinEncoding ?? 'utf8') as BufferEncoding);\n\t\t}\n\n\t\tlet exception: Error | undefined;\n\t\tproc.once('error', e => (exception = e));\n\t\tproc.once('exit', () => {\n\t\t\tconst duration = getDurationMilliseconds(start);\n\t\t\tconst slow = duration > slowCallWarningThreshold;\n\t\t\tconst status = slow ? ' (slow)' : '';\n\n\t\t\tif (exception != null) {\n\t\t\t\tLogger.error(\n\t\t\t\t\t'',\n\t\t\t\t\t`[SGIT ] ${gitCommand} ${GlyphChars.Dot} ${(exception.message || String(exception) || '')\n\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t.replace(/fatal: /g, '')\n\t\t\t\t\t\t.replace(/\\r?\\n|\\r/g, ` ${GlyphChars.Dot} `)} [${duration}ms]${status}`,\n\t\t\t\t);\n\t\t\t} else if (slow) {\n\t\t\t\tLogger.warn(`[SGIT ] ${gitCommand} [*${duration}ms]${status}`);\n\t\t\t} else {\n\t\t\t\tLogger.log(`[SGIT ] ${gitCommand} [${duration}ms]${status}`);\n\t\t\t}\n\t\t\tthis.logGitCommand(\n\t\t\t\t`${gitCommand}${exception != null ? ` ${GlyphChars.Dot} FAILED` : ''}`,\n\t\t\t\tduration,\n\t\t\t\texception,\n\t\t\t);\n\t\t});\n\t\treturn proc;\n\t}\n\n\tprivate _gitLocation: GitLocation | undefined;\n\tprivate _gitLocationPromise: Promise<GitLocation> | undefined;\n\tprivate async getLocation(): Promise<GitLocation> {\n\t\tif (this._gitLocation == null) {\n\t\t\tif (this._gitLocationPromise == null) {\n\t\t\t\tthis._gitLocationPromise = this._gitLocator();\n\t\t\t}\n\t\t\tthis._gitLocation = await this._gitLocationPromise;\n\t\t}\n\t\treturn this._gitLocation;\n\t}\n\n\tprivate _gitLocator!: () => Promise<GitLocation>;\n\tsetLocator(locator: () => Promise<GitLocation>): void {\n\t\tthis._gitLocator = locator;\n\t\tthis._gitLocationPromise = undefined;\n\t\tthis._gitLocation = undefined;\n\t}\n\n\tasync path(): Promise<string> {\n\t\treturn (await this.getLocation()).path;\n\t}\n\n\tasync version(): Promise<string> {\n\t\treturn (await this.getLocation()).version;\n\t}\n\n\tasync isAtLeastVersion(minimum: string): Promise<boolean> {\n\t\tconst result = compare(fromString(await this.version()), fromString(minimum));\n\t\treturn result !== -1;\n\t}\n\n\tmaybeIsAtLeastVersion(minimum: string): boolean | undefined {\n\t\treturn this._gitLocation != null\n\t\t\t? compare(fromString(this._gitLocation.version), fromString(minimum)) !== -1\n\t\t\t: undefined;\n\t}\n\n\t// Git commands\n\n\tadd(repoPath: string | undefined, pathspec: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'add', '-A', '--', pathspec);\n\t}\n\n\tapply(repoPath: string | undefined, patch: string, options: { allowConflicts?: boolean } = {}) {\n\t\tconst params = ['apply', '--whitespace=warn'];\n\t\tif (options.allowConflicts) {\n\t\t\tparams.push('-3');\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath, stdin: patch }, ...params);\n\t}\n\n\tprivate readonly ignoreRevsFileMap = new Map<string, boolean>();\n\n\tasync blame(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tref?: string,\n\t\toptions: { args?: string[] | null; ignoreWhitespace?: boolean; startLine?: number; endLine?: number } = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['blame', '--root', '--incremental'];\n\n\t\tif (options.ignoreWhitespace) {\n\t\t\tparams.push('-w');\n\t\t}\n\t\tif (options.startLine != null && options.endLine != null) {\n\t\t\tparams.push(`-L ${options.startLine},${options.endLine}`);\n\t\t}\n\t\tif (options.args != null) {\n\t\t\tparams.push(...options.args);\n\t\t}\n\n\t\t// Ensure the version of Git supports the --ignore-revs-file flag, otherwise the blame will fail\n\t\tlet supportsIgnoreRevsFile = this.maybeIsAtLeastVersion('2.23');\n\t\tif (supportsIgnoreRevsFile === undefined) {\n\t\t\tsupportsIgnoreRevsFile = await this.isAtLeastVersion('2.23');\n\t\t}\n\n\t\tconst ignoreRevsIndex = params.indexOf('--ignore-revs-file');\n\n\t\tif (supportsIgnoreRevsFile) {\n\t\t\tlet ignoreRevsFile;\n\t\t\tif (ignoreRevsIndex !== -1) {\n\t\t\t\tignoreRevsFile = params[ignoreRevsIndex + 1];\n\t\t\t\tif (!isAbsolute(ignoreRevsFile)) {\n\t\t\t\t\tignoreRevsFile = joinPaths(root, ignoreRevsFile);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tignoreRevsFile = joinPaths(root, '.git-blame-ignore-revs');\n\t\t\t}\n\n\t\t\tconst exists = this.ignoreRevsFileMap.get(ignoreRevsFile);\n\t\t\tif (exists !== undefined) {\n\t\t\t\tsupportsIgnoreRevsFile = exists;\n\t\t\t} else {\n\t\t\t\t// Ensure the specified --ignore-revs-file exists, otherwise the blame will fail\n\t\t\t\ttry {\n\t\t\t\t\tsupportsIgnoreRevsFile = await fsExists(ignoreRevsFile);\n\t\t\t\t} catch {\n\t\t\t\t\tsupportsIgnoreRevsFile = false;\n\t\t\t\t}\n\n\t\t\t\tthis.ignoreRevsFileMap.set(ignoreRevsFile, supportsIgnoreRevsFile);\n\t\t\t}\n\t\t}\n\n\t\tif (!supportsIgnoreRevsFile && ignoreRevsIndex !== -1) {\n\t\t\tparams.splice(ignoreRevsIndex, 2);\n\t\t} else if (supportsIgnoreRevsFile && ignoreRevsIndex === -1) {\n\t\t\tparams.push('--ignore-revs-file', '.git-blame-ignore-revs');\n\t\t}\n\n\t\tlet stdin;\n\t\tif (ref) {\n\t\t\tif (isUncommittedStaged(ref)) {\n\t\t\t\t// Pipe the blame contents to stdin\n\t\t\t\tparams.push('--contents', '-');\n\n\t\t\t\t// Get the file contents for the staged version using `:`\n\t\t\t\tstdin = await this.show<string>(repoPath, fileName, ':');\n\t\t\t} else {\n\t\t\t\tparams.push(ref);\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: root, stdin: stdin }, ...params, '--', file);\n\t}\n\n\tblame__contents(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tcontents: string,\n\t\toptions: {\n\t\t\targs?: string[] | null;\n\t\t\tcorrelationKey?: string;\n\t\t\tignoreWhitespace?: boolean;\n\t\t\tstartLine?: number;\n\t\t\tendLine?: number;\n\t\t} = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['blame', '--root', '--incremental'];\n\n\t\tif (options.ignoreWhitespace) {\n\t\t\tparams.push('-w');\n\t\t}\n\t\tif (options.startLine != null && options.endLine != null) {\n\t\t\tparams.push(`-L ${options.startLine},${options.endLine}`);\n\t\t}\n\t\tif (options.args != null) {\n\t\t\tparams.push(...options.args);\n\t\t}\n\n\t\t// Pipe the blame contents to stdin\n\t\tparams.push('--contents', '-');\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: root, stdin: contents, correlationKey: options.correlationKey },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfile,\n\t\t);\n\t}\n\n\tbranch__containsOrPointsAt(\n\t\trepoPath: string,\n\t\tref: string,\n\t\t{\n\t\t\tmode = 'contains',\n\t\t\tname = undefined,\n\t\t\tremotes = false,\n\t\t}: { mode?: 'contains' | 'pointsAt'; name?: string; remotes?: boolean } = {},\n\t) {\n\t\tconst params = ['branch'];\n\t\tif (remotes) {\n\t\t\tparams.push('-r');\n\t\t}\n\t\tparams.push(mode === 'pointsAt' ? `--points-at=${ref}` : `--contains=${ref}`, '--format=%(refname:short)');\n\t\tif (name != null) {\n\t\t\tparams.push(name);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitBranchDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t);\n\t}\n\n\tcheck_ignore(repoPath: string, ...files: string[]) {\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore, stdin: files.join('\\0') },\n\t\t\t'check-ignore',\n\t\t\t'-z',\n\t\t\t'--stdin',\n\t\t);\n\t}\n\n\tcheck_mailmap(repoPath: string, author: string) {\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'check-mailmap', author);\n\t}\n\n\tasync check_ref_format(ref: string, repoPath?: string, options: { branch?: boolean } = { branch: true }) {\n\t\tconst params = ['check-ref-format'];\n\t\tif (options.branch) {\n\t\t\tparams.push('--branch');\n\t\t} else {\n\t\t\tparams.push('--normalize');\n\t\t}\n\n\t\ttry {\n\t\t\tconst data = await this.git<string>(\n\t\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Throw },\n\t\t\t\t...params,\n\t\t\t\tref,\n\t\t\t);\n\t\t\treturn Boolean(data.trim());\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcheckout(repoPath: string, ref: string, { createBranch, path }: { createBranch?: string; path?: string } = {}) {\n\t\tconst params = ['checkout'];\n\t\tif (createBranch) {\n\t\t\tparams.push('-b', createBranch, ref, '--');\n\t\t} else {\n\t\t\tparams.push(ref, '--');\n\n\t\t\tif (path) {\n\t\t\t\t[path, repoPath] = splitPath(path, repoPath, true);\n\n\t\t\t\tparams.push(path);\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tasync config__get(key: string, repoPath?: string, options?: { local?: boolean }) {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Ignore, local: options?.local },\n\t\t\t'config',\n\t\t\t'--get',\n\t\t\tkey,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync config__get_regex(pattern: string, repoPath?: string, options?: { local?: boolean }) {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath ?? '', errors: GitErrorHandling.Ignore, local: options?.local },\n\t\t\t'config',\n\t\t\t'--get-regex',\n\t\t\tpattern,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync config__set(key: string, value: string | undefined, repoPath?: string) {\n\t\tconst params = ['config', '--local'];\n\t\tif (value == null) {\n\t\t\tparams.push('--unset', key);\n\t\t} else {\n\t\t\tparams.push(key, value);\n\t\t}\n\t\tawait this.git<string>({ cwd: repoPath ?? '', local: true }, ...params);\n\t}\n\n\tasync diff(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions: {\n\t\t\tencoding?: string;\n\t\t\tfilters?: GitDiffFilter[];\n\t\t\tlinesOfContext?: number;\n\t\t\trenames?: boolean;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t} = {},\n\t): Promise<string> {\n\t\tconst params = ['diff', '--no-ext-diff', '--minimal'];\n\n\t\tif (options.linesOfContext != null) {\n\t\t\tparams.push(`-U${options.linesOfContext}`);\n\t\t}\n\n\t\tif (options.renames) {\n\t\t\tparams.push(`-M${options.similarityThreshold == null ? '' : `${options.similarityThreshold}%`}`);\n\t\t}\n\n\t\tif (options.filters != null && options.filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${options.filters.join('')}`);\n\t\t}\n\n\t\tif (ref1) {\n\t\t\t// <sha>^3 signals an untracked file in a stash and if we are trying to find its parent, use the root sha\n\t\t\tif (ref1.endsWith('^3^')) {\n\t\t\t\tref1 = rootSha;\n\t\t\t}\n\t\t\tparams.push(isUncommittedStaged(ref1) ? '--staged' : ref1);\n\t\t}\n\t\tif (ref2) {\n\t\t\tparams.push(isUncommittedStaged(ref2) ? '--staged' : ref2);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.git<string>(\n\t\t\t\t{\n\t\t\t\t\tcwd: repoPath,\n\t\t\t\t\tconfigs: gitDiffDefaultConfigs,\n\t\t\t\t\tencoding: options.encoding,\n\t\t\t\t},\n\t\t\t\t...params,\n\t\t\t\t'--',\n\t\t\t\tfileName,\n\t\t\t);\n\t\t} catch (ex) {\n\t\t\tconst match = GitErrors.badRevision.exec(ex.message);\n\t\t\tif (match !== null) {\n\t\t\t\tconst [, ref] = match;\n\n\t\t\t\t// If the bad ref is trying to find a parent ref, assume we hit to the last commit, so try again using the root sha\n\t\t\t\tif (ref === ref1 && ref != null && ref.endsWith('^')) {\n\t\t\t\t\treturn this.diff(repoPath, fileName, rootSha, ref2, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tasync diff2(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tconfigs?: readonly string[];\n\t\t\terrors?: GitErrorHandling;\n\t\t\tstdin?: string;\n\t\t},\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t\terrors: options?.errors,\n\t\t\t\tstdin: options?.stdin,\n\t\t\t},\n\t\t\t'diff',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t...args,\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tasync diff__contents(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string,\n\t\tcontents: string,\n\t\toptions: { encoding?: string; filters?: GitDiffFilter[]; similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst params = [\n\t\t\t'diff',\n\t\t\t`-M${options.similarityThreshold == null ? '' : `${options.similarityThreshold}%`}`,\n\t\t\t'--no-ext-diff',\n\t\t\t'-U0',\n\t\t\t'--minimal',\n\t\t];\n\n\t\tif (options.filters != null && options.filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${options.filters.join('')}`);\n\t\t}\n\n\t\t// // <sha>^3 signals an untracked file in a stash and if we are trying to find its parent, use the root sha\n\t\t// if (ref.endsWith('^3^')) {\n\t\t// \tref = rootSha;\n\t\t// }\n\t\t// params.push(isUncommittedStaged(ref) ? '--staged' : ref);\n\n\t\tparams.push('--no-index');\n\n\t\ttry {\n\t\t\treturn await this.git<string>(\n\t\t\t\t{\n\t\t\t\t\tcwd: repoPath,\n\t\t\t\t\tconfigs: gitDiffDefaultConfigs,\n\t\t\t\t\tencoding: options.encoding,\n\t\t\t\t\tstdin: contents,\n\t\t\t\t},\n\t\t\t\t...params,\n\t\t\t\t'--',\n\t\t\t\tfileName,\n\t\t\t\t// Pipe the contents to stdin\n\t\t\t\t'-',\n\t\t\t);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RunError && ex.stdout) {\n\t\t\t\treturn ex.stdout;\n\t\t\t}\n\n\t\t\tconst match = GitErrors.badRevision.exec(ex.message);\n\t\t\tif (match !== null) {\n\t\t\t\tconst [, matchedRef] = match;\n\n\t\t\t\t// If the bad ref is trying to find a parent ref, assume we hit to the last commit, so try again using the root sha\n\t\t\t\tif (matchedRef === ref && matchedRef != null && matchedRef.endsWith('^')) {\n\t\t\t\t\treturn this.diff__contents(repoPath, fileName, rootSha, contents, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tdiff__name_status(\n\t\trepoPath: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\t{ filters, similarityThreshold }: { filters?: GitDiffFilter[]; similarityThreshold?: number | null } = {},\n\t) {\n\t\tconst params = [\n\t\t\t'diff',\n\t\t\t'--name-status',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'--no-ext-diff',\n\t\t\t'-z',\n\t\t];\n\t\tif (filters != null && filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${filters.join('')}`);\n\t\t}\n\t\tif (ref1) {\n\t\t\tparams.push(ref1);\n\t\t}\n\t\tif (ref2) {\n\t\t\tparams.push(ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitDiffDefaultConfigs }, ...params, '--');\n\t}\n\n\tasync diff__shortstat(repoPath: string, ref?: string) {\n\t\tconst params = ['diff', '--shortstat', '--no-ext-diff'];\n\t\tif (ref) {\n\t\t\tparams.push(ref);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.git<string>({ cwd: repoPath, configs: gitDiffDefaultConfigs }, ...params, '--');\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (GitErrors.noMergeBase.test(msg)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tdifftool(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\ttool: string,\n\t\toptions: { ref1?: string; ref2?: string; staged?: boolean } = {},\n\t) {\n\t\tconst params = ['difftool', '--no-prompt', `--tool=${tool}`];\n\t\tif (options.staged) {\n\t\t\tparams.push('--staged');\n\t\t}\n\t\tif (options.ref1) {\n\t\t\tparams.push(options.ref1);\n\t\t}\n\t\tif (options.ref2) {\n\t\t\tparams.push(options.ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, '--', fileName);\n\t}\n\n\tdifftool__dir_diff(repoPath: string, tool: string, ref1: string, ref2?: string) {\n\t\tconst params = ['difftool', '--dir-diff', `--tool=${tool}`, ref1];\n\t\tif (ref2) {\n\t\t\tparams.push(ref2);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tasync fetch(\n\t\trepoPath: string,\n\t\toptions:\n\t\t\t| { all?: boolean; branch?: undefined; prune?: boolean; remote?: string }\n\t\t\t| {\n\t\t\t\t\tall?: undefined;\n\t\t\t\t\tbranch: string;\n\t\t\t\t\tprune?: undefined;\n\t\t\t\t\tpull?: boolean;\n\t\t\t\t\tremote: string;\n\t\t\t\t\tupstream: string;\n\t\t\t  } = {},\n\t): Promise<void> {\n\t\tconst params = ['fetch'];\n\n\t\tif (options.prune) {\n\t\t\tparams.push('--prune');\n\t\t}\n\n\t\tif (options.branch && options.remote) {\n\t\t\tif (options.upstream && options.pull) {\n\t\t\t\tparams.push('-u', options.remote, `${options.upstream}:${options.branch}`);\n\n\t\t\t\ttry {\n\t\t\t\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t\t\tif (GitErrors.noFastForward.test(msg)) {\n\t\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t\t`Unable to pull the '${options.branch}' branch, as it can't be fast-forwarded.`,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams.push(\n\t\t\t\t\toptions.remote,\n\t\t\t\t\toptions.upstream\n\t\t\t\t\t\t? `${options.upstream}:refs/remotes/${options.remote}/${options.branch}`\n\t\t\t\t\t\t: options.branch,\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (options.remote) {\n\t\t\tparams.push(options.remote);\n\t\t} else if (options.all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t}\n\n\tfor_each_ref__branch(repoPath: string, options: { all: boolean } = { all: false }) {\n\t\tconst params = ['for-each-ref', `--format=${GitBranchParser.defaultFormat}`, 'refs/heads'];\n\t\tif (options.all) {\n\t\t\tparams.push('refs/remotes');\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tlog(\n\t\trepoPath: string,\n\t\tref: string | undefined,\n\t\t{\n\t\t\tall,\n\t\t\targsOrFormat,\n\t\t\tauthors,\n\t\t\tlimit,\n\t\t\tmerges,\n\t\t\tordering,\n\t\t\tsimilarityThreshold,\n\t\t\tsince,\n\t\t\tuntil,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\targsOrFormat?: string | string[];\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t\tsince?: number | string;\n\t\t\tuntil?: number | string;\n\t\t},\n\t) {\n\t\tif (argsOrFormat == null) {\n\t\t\targsOrFormat = ['--name-status', `--format=${all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`];\n\t\t}\n\n\t\tif (typeof argsOrFormat === 'string') {\n\t\t\targsOrFormat = [`--format=${argsOrFormat}`];\n\t\t}\n\n\t\tconst params = [\n\t\t\t'log',\n\t\t\t...argsOrFormat,\n\t\t\t'--full-history',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'-m',\n\t\t];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (limit) {\n\t\t\tparams.push(`-n${limit + 1}`);\n\t\t}\n\n\t\tif (since) {\n\t\t\tparams.push(`--since=\"${since}\"`);\n\t\t}\n\n\t\tif (until) {\n\t\t\tparams.push(`--until=\"${until}\"`);\n\t\t}\n\n\t\tif (!merges) {\n\t\t\tparams.push('--first-parent');\n\t\t}\n\n\t\tif (authors != null && authors.length !== 0) {\n\t\t\tif (!params.includes('--use-mailmap')) {\n\t\t\t\tparams.push('--use-mailmap');\n\t\t\t}\n\t\t\tparams.push(...authors.map(a => `--author=^${a.name} <${a.email}>$`));\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all', '--single-worktree');\n\t\t}\n\n\t\tif (ref && !isUncommittedStaged(ref)) {\n\t\t\tparams.push(ref);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigsWithFiles }, ...params, '--');\n\t}\n\n\tlog2(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tconfigs?: readonly string[];\n\t\t\tref?: string;\n\t\t\terrors?: GitErrorHandling;\n\t\t\tstdin?: string;\n\t\t},\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t\terrors: options?.errors,\n\t\t\t\tstdin: options?.stdin,\n\t\t\t},\n\t\t\t'log',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t...args,\n\t\t\t...(options?.ref && !isUncommittedStaged(options.ref) ? [options.ref] : emptyArray),\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tasync logStreamTo(\n\t\trepoPath: string,\n\t\tsha: string,\n\t\tlimit: number,\n\t\toptions?: { configs?: readonly string[]; stdin?: string },\n\t\t...args: string[]\n\t): Promise<[data: string[], count: number]> {\n\t\tconst params = ['log', ...args];\n\t\tif (options?.stdin) {\n\t\t\tparams.push('--stdin');\n\t\t}\n\n\t\tconst proc = await this.gitSpawn(\n\t\t\t{ cwd: repoPath, configs: options?.configs ?? gitLogDefaultConfigs, stdin: options?.stdin },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\tconst shaRegex = getShaInLogRegex(sha);\n\n\t\tlet found = false;\n\t\tlet count = 0;\n\n\t\treturn new Promise<[data: string[], count: number]>((resolve, reject) => {\n\t\t\tconst errData: string[] = [];\n\t\t\tconst data: string[] = [];\n\n\t\t\tfunction onErrData(s: string) {\n\t\t\t\terrData.push(s);\n\t\t\t}\n\n\t\t\tfunction onError(e: Error) {\n\t\t\t\treject(e);\n\t\t\t}\n\n\t\t\tfunction onExit(exitCode: number) {\n\t\t\t\tif (exitCode !== 0) {\n\t\t\t\t\treject(new Error(errData.join('')));\n\t\t\t\t}\n\n\t\t\t\tresolve([data, count]);\n\t\t\t}\n\n\t\t\tfunction onData(s: string) {\n\t\t\t\tdata.push(s);\n\t\t\t\t// eslint-disable-next-line no-control-regex\n\t\t\t\tcount += s.match(/(?:^\\x00*|\\x00\\x00)[0-9a-f]{40}\\x00/g)?.length ?? 0;\n\n\t\t\t\tif (!found && shaRegex.test(s)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\t// Buffer a bit past the sha we are looking for\n\t\t\t\t\tif (count > limit) {\n\t\t\t\t\t\tlimit = count + 50;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found || count <= limit) return;\n\n\t\t\t\tproc.removeListener('exit', onExit);\n\t\t\t\tproc.removeListener('error', onError);\n\t\t\t\tproc.stdout!.removeListener('data', onData);\n\t\t\t\tproc.stderr!.removeListener('data', onErrData);\n\t\t\t\tproc.kill();\n\n\t\t\t\tresolve([data, count]);\n\t\t\t}\n\n\t\t\tproc.on('error', onError);\n\t\t\tproc.on('exit', onExit);\n\n\t\t\tproc.stdout!.setEncoding('utf8');\n\t\t\tproc.stdout!.on('data', onData);\n\n\t\t\tproc.stderr!.setEncoding('utf8');\n\t\t\tproc.stderr!.on('data', onErrData);\n\t\t});\n\t}\n\n\tlog__file(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string | undefined,\n\t\t{\n\t\t\tall,\n\t\t\targsOrFormat,\n\t\t\t// TODO@eamodio remove this in favor of argsOrFormat\n\t\t\tfileMode = 'full',\n\t\t\tfilters,\n\t\t\tfirstParent = false,\n\t\t\tlimit,\n\t\t\tordering,\n\t\t\trenames = true,\n\t\t\treverse = false,\n\t\t\tsince,\n\t\t\tskip,\n\t\t\tstartLine,\n\t\t\tendLine,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\targsOrFormat?: string | string[];\n\t\t\t// TODO@eamodio remove this in favor of argsOrFormat\n\t\t\tfileMode?: 'full' | 'simple' | 'none';\n\t\t\tfilters?: GitDiffFilter[];\n\t\t\tfirstParent?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t\tstartLine?: number;\n\t\t\tendLine?: number;\n\t\t} = {},\n\t) {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tif (argsOrFormat == null) {\n\t\t\targsOrFormat = [`--format=${all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`];\n\t\t}\n\n\t\tif (typeof argsOrFormat === 'string') {\n\t\t\targsOrFormat = [`--format=${argsOrFormat}`];\n\t\t}\n\n\t\tconst params = ['log', ...argsOrFormat];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (limit && !reverse) {\n\t\t\tparams.push(`-n${limit + 1}`);\n\t\t}\n\n\t\tif (skip) {\n\t\t\tparams.push(`--skip=${skip}`);\n\t\t}\n\n\t\tif (since) {\n\t\t\tparams.push(`--since=\"${since}\"`);\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all', '--single-worktree');\n\t\t}\n\n\t\t// Can't allow rename detection (`--follow`) if `all` or a `startLine` is specified\n\t\tif (renames && (all || startLine != null)) {\n\t\t\trenames = false;\n\t\t}\n\n\t\tparams.push(renames ? '--follow' : '-m');\n\t\tif (/*renames ||*/ firstParent) {\n\t\t\tparams.push('--first-parent');\n\t\t\t// In Git >= 2.29.0 `--first-parent` implies `-m`, so lets include it for consistency\n\t\t\tif (renames) {\n\t\t\t\tparams.push('-m');\n\t\t\t}\n\t\t}\n\n\t\tif (filters != null && filters.length !== 0) {\n\t\t\tparams.push(`--diff-filter=${filters.join('')}`);\n\t\t}\n\n\t\tif (fileMode !== 'none') {\n\t\t\tif (startLine == null) {\n\t\t\t\t// If this is the log of a folder, use `--name-status` to match non-file logs (for parsing)\n\t\t\t\tif (fileMode === 'simple' || isFolderGlob(file)) {\n\t\t\t\t\tparams.push('--name-status');\n\t\t\t\t} else {\n\t\t\t\t\tparams.push('--numstat', '--summary');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Don't include `--name-status`, `--numstat`, or `--summary` because they aren't supported with `-L`\n\t\t\t\tparams.push(`-L ${startLine},${endLine == null ? startLine : endLine}:${file}`);\n\t\t\t}\n\t\t}\n\n\t\tif (ref && !isUncommittedStaged(ref)) {\n\t\t\t// If we are reversing, we must add a range (with HEAD) because we are using --ancestry-path for better reverse walking\n\t\t\tif (reverse) {\n\t\t\t\tparams.push('--reverse', '--ancestry-path', `${ref}..HEAD`);\n\t\t\t} else {\n\t\t\t\tparams.push(ref);\n\t\t\t}\n\t\t}\n\n\t\t// Don't specify a file spec when using a line number (so say the git docs)\n\t\tif (startLine == null) {\n\t\t\tparams.push('--', file);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: root, configs: gitLogDefaultConfigs }, ...params);\n\t}\n\n\tasync log__file_recent(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\toptions?: {\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsimilarityThreshold?: number | null;\n\t\t\tcancellation?: CancellationToken;\n\t\t},\n\t) {\n\t\tconst params = [\n\t\t\t'log',\n\t\t\t`-M${options?.similarityThreshold == null ? '' : `${options?.similarityThreshold}%`}`,\n\t\t\t'-n1',\n\t\t\t'--format=%H',\n\t\t];\n\n\t\tif (options?.ordering) {\n\t\t\tparams.push(`--${options?.ordering}-order`);\n\t\t}\n\n\t\tif (options?.ref) {\n\t\t\tparams.push(options?.ref);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tcwd: repoPath,\n\t\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\t\terrors: GitErrorHandling.Ignore,\n\t\t\t},\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__find_object(\n\t\trepoPath: string,\n\t\tobjectId: string,\n\t\tref: string,\n\t\tordering: 'date' | 'author-date' | 'topo' | null,\n\t\tfile?: string,\n\t\tcancellation?: CancellationToken,\n\t) {\n\t\tconst params = ['log', '-n1', '--no-renames', '--format=%H', `--find-object=${objectId}`, ref];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (file) {\n\t\t\tparams.push('--', file);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{\n\t\t\t\tcancellation: cancellation,\n\t\t\t\tcwd: repoPath,\n\t\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\t\terrors: GitErrorHandling.Ignore,\n\t\t\t},\n\t\t\t...params,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__recent(repoPath: string, ordering?: 'date' | 'author-date' | 'topo' | null) {\n\t\tconst params = ['log', '-n1', '--format=%H'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitLogDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync log__recent_committerdate(repoPath: string, ordering?: 'date' | 'author-date' | 'topo' | null) {\n\t\tconst params = ['log', '-n1', '--format=%ct'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitLogDefaultConfigs, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tlog__search(\n\t\trepoPath: string,\n\t\tsearch: string[] = emptyArray,\n\t\toptions?: {\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t\tshas?: Set<string>;\n\t\t\tstdin?: string;\n\t\t},\n\t) {\n\t\tif (options?.shas != null) {\n\t\t\tconst stdin = join(options.shas, '\\n');\n\t\t\treturn this.git<string>(\n\t\t\t\t{ cwd: repoPath, stdin: stdin },\n\t\t\t\t'show',\n\t\t\t\t'--stdin',\n\t\t\t\t'--name-status',\n\t\t\t\t`--format=${GitLogParser.defaultFormat}`,\n\t\t\t\t'--use-mailmap',\n\t\t\t);\n\t\t}\n\n\t\tlet files;\n\t\t[search, files] = splitAt(search, search.indexOf('--'));\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: ['-C', repoPath, ...gitLogDefaultConfigs], stdin: options?.stdin },\n\t\t\t'log',\n\t\t\t...(options?.stdin ? ['--stdin'] : emptyArray),\n\t\t\t'--name-status',\n\t\t\t`--format=${GitLogParser.defaultFormat}`,\n\t\t\t'--use-mailmap',\n\t\t\t...search,\n\t\t\t...(options?.ordering ? [`--${options.ordering}-order`] : emptyArray),\n\t\t\t...(options?.limit ? [`-n${options.limit + 1}`] : emptyArray),\n\t\t\t...(options?.skip ? [`--skip=${options.skip}`] : emptyArray),\n\t\t\t...files,\n\t\t);\n\t}\n\n\t//  log__shortstat(repoPath: string, options: { ref?: string }) {\n\t//     const params = ['log', '--shortstat', '--oneline'];\n\t//     if (options.ref && !isUncommittedStaged(options.ref)) {\n\t//         params.push(options.ref);\n\t//     }\n\t//     return this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigs }, ...params, '--');\n\t// }\n\n\tasync ls_files(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\t{ ref, untracked }: { ref?: string; untracked?: boolean } = {},\n\t): Promise<string | undefined> {\n\t\tconst params = ['ls-files'];\n\t\tif (ref && !isUncommitted(ref)) {\n\t\t\tparams.push(`--with-tree=${ref}`);\n\t\t}\n\n\t\tif (!ref && untracked) {\n\t\t\tparams.push('-o');\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tls_remote(repoPath: string, remote: string, ref?: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'ls-remote', remote, ref);\n\t}\n\n\tls_remote__HEAD(repoPath: string, remote: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'ls-remote', '--symref', remote, 'HEAD');\n\t}\n\n\tasync ls_tree(repoPath: string, ref: string, path?: string) {\n\t\tconst params = ['ls-tree'];\n\t\tif (path) {\n\t\t\tparams.push('-l', ref, '--', path);\n\t\t} else {\n\t\t\tparams.push('-lrt', ref, '--');\n\t\t}\n\t\tconst data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, ...params);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tmerge_base(repoPath: string, ref1: string, ref2: string, options?: { forkPoint?: boolean }) {\n\t\tconst params = ['merge-base'];\n\t\tif (options?.forkPoint) {\n\t\t\tparams.push('--fork-point');\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, ref1, ref2);\n\t}\n\n\tasync merge_base__is_ancestor(repoPath: string, ref1: string, ref2: string): Promise<boolean> {\n\t\tconst params = ['merge-base', '--is-ancestor'];\n\t\tconst exitCode = await this.git({ cwd: repoPath, exitCodeOnly: true }, ...params, ref1, ref2);\n\t\treturn exitCode === 0;\n\t}\n\n\treflog(\n\t\trepoPath: string,\n\t\t{\n\t\t\tall,\n\t\t\tbranch,\n\t\t\tlimit,\n\t\t\tordering,\n\t\t\tskip,\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t} = {},\n\t): Promise<string> {\n\t\tconst params = ['log', '--walk-reflogs', `--format=${GitReflogParser.defaultFormat}`, '--date=iso8601'];\n\n\t\tif (ordering) {\n\t\t\tparams.push(`--${ordering}-order`);\n\t\t}\n\n\t\tif (all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tif (limit) {\n\t\t\tparams.push(`-n${limit}`);\n\t\t}\n\n\t\tif (skip) {\n\t\t\tparams.push(`--skip=${skip}`);\n\t\t}\n\n\t\tif (branch) {\n\t\t\tparams.push(branch);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath, configs: gitLogDefaultConfigs }, ...params, '--');\n\t}\n\n\tremote(repoPath: string): Promise<string> {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', '-v');\n\t}\n\n\tremote__add(repoPath: string, name: string, url: string, options?: { fetch?: boolean }) {\n\t\tconst params = ['remote', 'add'];\n\t\tif (options?.fetch) {\n\t\t\tparams.push('-f');\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath }, ...params, name, url);\n\t}\n\n\tremote__prune(repoPath: string, name: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'prune', name);\n\t}\n\n\tremote__remove(repoPath: string, name: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'remove', name);\n\t}\n\n\tremote__get_url(repoPath: string, remote: string): Promise<string> {\n\t\treturn this.git<string>({ cwd: repoPath }, 'remote', 'get-url', remote);\n\t}\n\n\treset(repoPath: string | undefined, fileName: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'reset', '-q', '--', fileName);\n\t}\n\n\tasync rev_list(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { all?: boolean; maxParents?: number },\n\t): Promise<string[] | undefined> {\n\t\tconst params = ['rev-list'];\n\t\tif (options?.all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tif (options?.maxParents != null) {\n\t\t\tparams.push(`--max-parents=${options.maxParents}`);\n\t\t}\n\n\t\tconst rawData = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\tref,\n\t\t\t'--',\n\t\t);\n\t\tconst data = rawData.trim().split('\\n');\n\t\tif (data.length === 0) return undefined;\n\n\t\treturn data;\n\t}\n\n\tasync rev_list__count(repoPath: string, ref: string, all?: boolean): Promise<number | undefined> {\n\t\tconst params = ['rev-list', '--count'];\n\t\tif (all) {\n\t\t\tparams.push('--all');\n\t\t}\n\n\t\tlet data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, ...params, ref, '--');\n\t\tdata = data.trim();\n\t\tif (data.length === 0) return undefined;\n\n\t\tconst result = parseInt(data, 10);\n\t\treturn isNaN(result) ? undefined : result;\n\t}\n\n\tasync rev_list__left_right(\n\t\trepoPath: string,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t'rev-list',\n\t\t\t'--left-right',\n\t\t\t'--count',\n\t\t\t...refs,\n\t\t\t'--',\n\t\t);\n\t\tif (data.length === 0) return undefined;\n\n\t\tconst parts = data.split('\\t');\n\t\tif (parts.length !== 2) return undefined;\n\n\t\tconst [ahead, behind] = parts;\n\t\tconst result = {\n\t\t\tahead: parseInt(ahead, 10),\n\t\t\tbehind: parseInt(behind, 10),\n\t\t};\n\n\t\tif (isNaN(result.ahead) || isNaN(result.behind)) return undefined;\n\n\t\treturn result;\n\t}\n\n\tasync rev_parse(repoPath: string, ref: string): Promise<string | undefined> {\n\t\tconst data = await this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'rev-parse', ref);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync rev_parse__currentBranch(\n\t\trepoPath: string,\n\t\tordering: 'date' | 'author-date' | 'topo' | null,\n\t): Promise<[string, string | undefined] | undefined> {\n\t\ttry {\n\t\t\tconst data = await this.git<string>(\n\t\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Throw },\n\t\t\t\t'rev-parse',\n\t\t\t\t'--abbrev-ref',\n\t\t\t\t'--symbolic-full-name',\n\t\t\t\t'@',\n\t\t\t\t'@{u}',\n\t\t\t\t'--',\n\t\t\t);\n\t\t\treturn [data, undefined];\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (GitErrors.badRevision.test(msg) || GitWarnings.noUpstream.test(msg)) {\n\t\t\t\tif (ex.stdout != null && ex.stdout.length !== 0) {\n\t\t\t\t\treturn [ex.stdout, undefined];\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.symbolic_ref(repoPath, 'HEAD');\n\t\t\t\t\tif (data != null) return [data.trim(), undefined];\n\t\t\t\t} catch {}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.symbolic_ref(repoPath, 'refs/remotes/origin/HEAD');\n\t\t\t\t\tif (data != null) return [data.trim().substr('origin/'.length), undefined];\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (/is not a symbolic ref/.test(ex.stderr)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst data = await this.ls_remote__HEAD(repoPath, 'origin');\n\t\t\t\t\t\t\tif (data != null) {\n\t\t\t\t\t\t\t\tconst match = /ref:\\s(\\S+)\\s+HEAD/m.exec(data);\n\t\t\t\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\t\t\t\tconst [, branch] = match;\n\t\t\t\t\t\t\t\t\treturn [branch.substr('refs/heads/'.length), undefined];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst defaultBranch = (await this.config__get('init.defaultBranch', repoPath)) ?? 'main';\n\t\t\t\tconst branchConfig = await this.config__get_regex(`branch\\\\.${defaultBranch}\\\\.+`, repoPath, {\n\t\t\t\t\tlocal: true,\n\t\t\t\t});\n\n\t\t\t\tlet remote;\n\t\t\t\tlet remoteBranch;\n\n\t\t\t\tif (branchConfig) {\n\t\t\t\t\tlet match = /^branch\\..+\\.remote\\s(.+)$/m.exec(branchConfig);\n\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\tremote = match[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tmatch = /^branch\\..+\\.merge\\srefs\\/heads\\/(.+)$/m.exec(branchConfig);\n\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\tremoteBranch = match[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [`${defaultBranch}${remote && remoteBranch ? `\\n${remote}/${remoteBranch}` : ''}`, undefined];\n\t\t\t}\n\n\t\t\tif (GitWarnings.headNotABranch.test(msg)) {\n\t\t\t\tconst sha = await this.log__recent(repoPath, ordering);\n\t\t\t\tif (sha === undefined) return undefined;\n\n\t\t\t\treturn [`(HEAD detached at ${shortenRevision(sha)})`, sha];\n\t\t\t}\n\n\t\t\tdefaultExceptionHandler(ex, repoPath);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync rev_parse__git_dir(cwd: string): Promise<{ path: string; commonPath?: string } | undefined> {\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t'rev-parse',\n\t\t\t'--git-dir',\n\t\t\t'--git-common-dir',\n\t\t);\n\t\tif (data.length === 0) return undefined;\n\n\t\t// Keep trailing spaces which are part of the directory name\n\t\tlet [dotGitPath, commonDotGitPath] = data.split('\\n').map(r => r.trimStart());\n\n\t\t// Make sure to normalize: https://github.com/git-for-windows/git/issues/2478\n\n\t\tif (!isAbsolute(dotGitPath)) {\n\t\t\tdotGitPath = joinPaths(cwd, dotGitPath);\n\t\t}\n\t\tdotGitPath = normalizePath(dotGitPath);\n\n\t\tif (commonDotGitPath) {\n\t\t\tif (!isAbsolute(commonDotGitPath)) {\n\t\t\t\tcommonDotGitPath = joinPaths(cwd, commonDotGitPath);\n\t\t\t}\n\t\t\tcommonDotGitPath = normalizePath(commonDotGitPath);\n\n\t\t\treturn { path: dotGitPath, commonPath: commonDotGitPath !== dotGitPath ? commonDotGitPath : undefined };\n\t\t}\n\n\t\treturn { path: dotGitPath };\n\t}\n\n\tasync rev_parse__show_toplevel(cwd: string): Promise<[safe: true, repoPath: string] | [safe: false] | []> {\n\t\tlet data;\n\n\t\tif (!workspace.isTrusted) {\n\t\t\t// Check if the folder is a bare clone: if it has a file named HEAD && `rev-parse --show-cdup` is empty\n\t\t\ttry {\n\t\t\t\taccessSync(joinPaths(cwd, 'HEAD'));\n\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Throw, configs: ['-C', cwd] },\n\t\t\t\t\t'rev-parse',\n\t\t\t\t\t'--show-cdup',\n\t\t\t\t);\n\t\t\t\tif (data.trim() === '') {\n\t\t\t\t\tLogger.log(`Skipping (untrusted workspace); bare clone repository detected in '${cwd}'`);\n\t\t\t\t\treturn emptyArray as [];\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// If this throw, we should be good to open the repo (e.g. HEAD doesn't exist)\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tdata = await this.git<string>({ cwd: cwd, errors: GitErrorHandling.Throw }, 'rev-parse', '--show-toplevel');\n\t\t\t// Make sure to normalize: https://github.com/git-for-windows/git/issues/2478\n\t\t\t// Keep trailing spaces which are part of the directory name\n\t\t\treturn data.length === 0\n\t\t\t\t? (emptyArray as [])\n\t\t\t\t: [true, normalizePath(data.trimStart().replace(/[\\r|\\n]+$/, ''))];\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof WorkspaceUntrustedError) return emptyArray as [];\n\n\t\t\tconst unsafeMatch =\n\t\t\t\t/^fatal: detected dubious ownership in repository at '([^']+)'[\\s\\S]*git config --global --add safe\\.directory '?([^'\\n]+)'?$/m.exec(\n\t\t\t\t\tex.stderr,\n\t\t\t\t);\n\t\t\tif (unsafeMatch?.length === 3) {\n\t\t\t\tLogger.log(\n\t\t\t\t\t`Skipping; unsafe repository detected in '${unsafeMatch[1]}'; run 'git config --global --add safe.directory ${unsafeMatch[2]}' to allow it`,\n\t\t\t\t);\n\t\t\t\treturn [false];\n\t\t\t}\n\n\t\t\tconst inDotGit = /this operation must be run in a work tree/.test(ex.stderr);\n\t\t\t// Check if we are in a bare clone\n\t\t\tif (inDotGit && workspace.isTrusted) {\n\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t\t\t'rev-parse',\n\t\t\t\t\t'--is-bare-repository',\n\t\t\t\t);\n\t\t\t\tif (data.trim() === 'true') {\n\t\t\t\t\t// If we are in a bare clone, then the common dir is the git dir\n\t\t\t\t\tdata = await this.git<string>(\n\t\t\t\t\t\t{ cwd: cwd, errors: GitErrorHandling.Ignore },\n\t\t\t\t\t\t'rev-parse',\n\t\t\t\t\t\t'--git-common-dir',\n\t\t\t\t\t);\n\t\t\t\t\tdata = data.trim();\n\t\t\t\t\tif (data.length) {\n\t\t\t\t\t\treturn [true, normalizePath((data === '.' ? cwd : data).trimStart().replace(/[\\r|\\n]+$/, ''))];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inDotGit || ex.code === 'ENOENT') {\n\t\t\t\t// If the `cwd` doesn't exist, walk backward to see if any parent folder exists\n\t\t\t\tlet exists = inDotGit ? false : await fsExists(cwd);\n\t\t\t\tif (!exists) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tconst parent = dirname(cwd);\n\t\t\t\t\t\tif (parent === cwd || parent.length === 0) return emptyArray as [];\n\n\t\t\t\t\t\tcwd = parent;\n\t\t\t\t\t\texists = await fsExists(cwd);\n\t\t\t\t\t} while (!exists);\n\n\t\t\t\t\treturn this.rev_parse__show_toplevel(cwd);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn emptyArray as [];\n\t\t}\n\t}\n\n\tasync rev_parse__verify(repoPath: string, ref: string, fileName?: string): Promise<string | undefined> {\n\t\tconst params = ['rev-parse', '--verify'];\n\n\t\tif (await this.isAtLeastVersion('2.30')) {\n\t\t\tparams.push('--end-of-options');\n\t\t}\n\n\t\tconst data = await this.git<string>(\n\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t...params,\n\t\t\tfileName ? `${ref}:./${fileName}` : `${ref}^{commit}`,\n\t\t);\n\t\treturn data.length === 0 ? undefined : data.trim();\n\t}\n\n\tasync show<TOut extends string | Buffer>(\n\t\trepoPath: string | undefined,\n\t\tfileName: string,\n\t\tref: string,\n\t\toptions: {\n\t\t\tencoding?: 'binary' | 'ascii' | 'utf8' | 'utf16le' | 'ucs2' | 'base64' | 'latin1' | 'hex' | 'buffer';\n\t\t} = {},\n\t): Promise<TOut | undefined> {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tif (isUncommittedStaged(ref)) {\n\t\t\tref = ':';\n\t\t}\n\t\tif (isUncommitted(ref)) throw new Error(`ref=${ref} is uncommitted`);\n\n\t\tconst opts: GitCommandOptions = {\n\t\t\tconfigs: gitLogDefaultConfigs,\n\t\t\tcwd: root,\n\t\t\tencoding: options.encoding ?? 'utf8',\n\t\t\terrors: GitErrorHandling.Throw,\n\t\t};\n\t\tconst args = ref.endsWith(':') ? `${ref}./${file}` : `${ref}:./${file}`;\n\n\t\ttry {\n\t\t\tconst data = await this.git<TOut>(opts, 'show', '--textconv', args, '--');\n\t\t\treturn data;\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (ref === ':' && GitErrors.badRevision.test(msg)) {\n\t\t\t\treturn this.show<TOut>(repoPath, fileName, 'HEAD:', options);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tGitErrors.badRevision.test(msg) ||\n\t\t\t\tGitWarnings.notFound.test(msg) ||\n\t\t\t\tGitWarnings.foundButNotInRevision.test(msg)\n\t\t\t) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn defaultExceptionHandler(ex, opts.cwd) as TOut;\n\t\t}\n\t}\n\n\tshow2(\n\t\trepoPath: string,\n\t\toptions?: { cancellation?: CancellationToken; configs?: readonly string[] },\n\t\t...args: string[]\n\t) {\n\t\treturn this.git<string>(\n\t\t\t{\n\t\t\t\tcwd: repoPath,\n\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\tconfigs: options?.configs ?? gitLogDefaultConfigs,\n\t\t\t},\n\t\t\t'show',\n\t\t\t...args,\n\t\t\t...(!args.includes('--') ? ['--'] : emptyArray),\n\t\t);\n\t}\n\n\tshow__diff(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tref: string,\n\t\toriginalFileName?: string,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t) {\n\t\tconst params = [\n\t\t\t'show',\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t'--format=',\n\t\t\t'--minimal',\n\t\t\t'-U0',\n\t\t\tref,\n\t\t\t'--',\n\t\t\tfileName,\n\t\t];\n\t\tif (originalFileName != null && originalFileName.length !== 0) {\n\t\t\tparams.push(originalFileName);\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tshow__name_status(repoPath: string, fileName: string, ref: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'show', '--name-status', '--format=', '-z', ref, '--', fileName);\n\t}\n\n\tshow_ref__tags(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Ignore }, 'show-ref', '--tags');\n\t}\n\n\tstash__apply(repoPath: string, stashName: string, deleteAfter: boolean): Promise<string | undefined> {\n\t\tif (!stashName) return Promise.resolve(undefined);\n\t\treturn this.git<string>({ cwd: repoPath }, 'stash', deleteAfter ? 'pop' : 'apply', stashName);\n\t}\n\n\tasync stash__rename(repoPath: string, stashName: string, ref: string, message: string, stashOnRef?: string) {\n\t\tawait this.stash__delete(repoPath, stashName, ref);\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath },\n\t\t\t'stash',\n\t\t\t'store',\n\t\t\t'-m',\n\t\t\tstashOnRef ? `On ${stashOnRef}: ${message}` : message,\n\t\t\tref,\n\t\t);\n\t}\n\n\tasync stash__delete(repoPath: string, stashName: string, ref?: string) {\n\t\tif (!stashName) return undefined;\n\n\t\tif (ref) {\n\t\t\tconst stashRef = await this.git<string>(\n\t\t\t\t{ cwd: repoPath, errors: GitErrorHandling.Ignore },\n\t\t\t\t'show',\n\t\t\t\t'--format=%H',\n\t\t\t\t'--no-patch',\n\t\t\t\tstashName,\n\t\t\t);\n\t\t\tif (stashRef?.trim() !== ref) {\n\t\t\t\tthrow new Error('Unable to delete stash; mismatch with stash number');\n\t\t\t}\n\t\t}\n\n\t\treturn this.git<string>({ cwd: repoPath }, 'stash', 'drop', stashName);\n\t}\n\n\tstash__list(\n\t\trepoPath: string,\n\t\t{ args, similarityThreshold }: { args?: string[]; similarityThreshold?: number | null },\n\t) {\n\t\tif (args == null) {\n\t\t\targs = ['--name-status'];\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath },\n\t\t\t'stash',\n\t\t\t'list',\n\t\t\t...args,\n\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t);\n\t}\n\n\tasync stash__push(\n\t\trepoPath: string,\n\t\tmessage?: string,\n\t\t{\n\t\t\tincludeUntracked,\n\t\t\tkeepIndex,\n\t\t\tonlyStaged,\n\t\t\tpathspecs,\n\t\t\tstdin,\n\t\t}: {\n\t\t\tincludeUntracked?: boolean;\n\t\t\tkeepIndex?: boolean;\n\t\t\tonlyStaged?: boolean;\n\t\t\tpathspecs?: string[];\n\t\t\tstdin?: boolean;\n\t\t} = {},\n\t): Promise<void> {\n\t\tconst params = ['stash', 'push'];\n\n\t\tif (includeUntracked || (pathspecs != null && pathspecs.length !== 0)) {\n\t\t\tparams.push('-u');\n\t\t}\n\n\t\tif (keepIndex) {\n\t\t\tparams.push('-k');\n\t\t}\n\n\t\tif (onlyStaged) {\n\t\t\tif (await this.isAtLeastVersion('2.35')) {\n\t\t\t\tparams.push('--staged');\n\t\t\t} else {\n\t\t\t\tthrow new Error('Git version 2.35 or higher is required for --staged');\n\t\t\t}\n\t\t}\n\n\t\tif (message) {\n\t\t\tparams.push('-m', message);\n\t\t}\n\n\t\tif (stdin && pathspecs != null && pathspecs.length !== 0) {\n\t\t\tvoid (await this.git<string>(\n\t\t\t\t{ cwd: repoPath, stdin: pathspecs.join('\\0') },\n\t\t\t\t...params,\n\t\t\t\t'--pathspec-from-file=-',\n\t\t\t\t'--pathspec-file-nul',\n\t\t\t));\n\n\t\t\treturn;\n\t\t}\n\n\t\tparams.push('--');\n\t\tif (pathspecs != null && pathspecs.length !== 0) {\n\t\t\tparams.push(...pathspecs);\n\t\t}\n\n\t\ttry {\n\t\t\tvoid (await this.git<string>({ cwd: repoPath }, ...params));\n\t\t} catch (ex) {\n\t\t\tif (\n\t\t\t\tex instanceof RunError &&\n\t\t\t\tex.stdout.includes('Saved working directory and index state') &&\n\t\t\t\tex.stderr.includes('Cannot remove worktree changes')\n\t\t\t) {\n\t\t\t\tthrow new StashPushError(StashPushErrorReason.ConflictingStagedAndUnstagedLines);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tasync status(\n\t\trepoPath: string,\n\t\tporcelainVersion: number = 1,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst params = [\n\t\t\t'status',\n\t\t\tporcelainVersion >= 2 ? `--porcelain=v${porcelainVersion}` : '--porcelain',\n\t\t\t'--branch',\n\t\t\t'-u',\n\t\t];\n\t\tif (await this.isAtLeastVersion('2.18')) {\n\t\t\tparams.push(`--find-renames${similarityThreshold == null ? '' : `=${similarityThreshold}%`}`);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: repoPath, configs: gitStatusDefaultConfigs, env: { GIT_OPTIONAL_LOCKS: '0' } },\n\t\t\t...params,\n\t\t\t'--',\n\t\t);\n\t}\n\n\tasync status__file(\n\t\trepoPath: string,\n\t\tfileName: string,\n\t\tporcelainVersion: number = 1,\n\t\t{ similarityThreshold }: { similarityThreshold?: number | null } = {},\n\t): Promise<string> {\n\t\tconst [file, root] = splitPath(fileName, repoPath, true);\n\n\t\tconst params = ['status', porcelainVersion >= 2 ? `--porcelain=v${porcelainVersion}` : '--porcelain'];\n\t\tif (await this.isAtLeastVersion('2.18')) {\n\t\t\tparams.push(`--find-renames${similarityThreshold == null ? '' : `=${similarityThreshold}%`}`);\n\t\t}\n\n\t\treturn this.git<string>(\n\t\t\t{ cwd: root, configs: gitStatusDefaultConfigs, env: { GIT_OPTIONAL_LOCKS: '0' } },\n\t\t\t...params,\n\t\t\t'--',\n\t\t\tfile,\n\t\t);\n\t}\n\n\tsymbolic_ref(repoPath: string, ref: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'symbolic-ref', '--short', ref);\n\t}\n\n\ttag(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'tag', '-l', `--format=${GitTagParser.defaultFormat}`);\n\t}\n\n\tworktree__add(\n\t\trepoPath: string,\n\t\tpath: string,\n\t\t{\n\t\t\tcommitish,\n\t\t\tcreateBranch,\n\t\t\tdetach,\n\t\t\tforce,\n\t\t}: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean } = {},\n\t) {\n\t\tconst params = ['worktree', 'add'];\n\t\tif (force) {\n\t\t\tparams.push('--force');\n\t\t}\n\t\tif (createBranch) {\n\t\t\tparams.push('-b', createBranch);\n\t\t}\n\t\tif (detach) {\n\t\t\tparams.push('--detach');\n\t\t}\n\t\tparams.push(path);\n\t\tif (commitish) {\n\t\t\tparams.push(commitish);\n\t\t}\n\t\treturn this.git<string>({ cwd: repoPath }, ...params);\n\t}\n\n\tworktree__list(repoPath: string) {\n\t\treturn this.git<string>({ cwd: repoPath }, 'worktree', 'list', '--porcelain');\n\t}\n\n\tworktree__remove(repoPath: string, worktree: string, { force }: { force?: boolean } = {}) {\n\t\tconst params = ['worktree', 'remove'];\n\t\tif (force) {\n\t\t\tparams.push('--force');\n\t\t}\n\t\tparams.push(worktree);\n\n\t\treturn this.git<string>({ cwd: repoPath, errors: GitErrorHandling.Throw }, ...params);\n\t}\n\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpaths: string[],\n\t\toptions?: { numeric?: false; throw?: boolean; trim?: boolean },\n\t): Promise<string | undefined>;\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpath: string[],\n\t\toptions?: { numeric: true; throw?: boolean; trim?: boolean },\n\t): Promise<number | undefined>;\n\tasync readDotGitFile(\n\t\trepoPath: string,\n\t\tpathParts: string[],\n\t\toptions?: { numeric?: boolean; throw?: boolean; trim?: boolean },\n\t): Promise<string | number | undefined> {\n\t\ttry {\n\t\t\tconst bytes = await workspace.fs.readFile(Uri.file(joinPaths(repoPath, '.git', ...pathParts)));\n\t\t\tlet contents = textDecoder.decode(bytes);\n\t\t\tcontents = options?.trim ?? true ? contents.trim() : contents;\n\n\t\t\tif (options?.numeric) {\n\t\t\t\tconst number = Number.parseInt(contents, 10);\n\t\t\t\treturn isNaN(number) ? undefined : number;\n\t\t\t}\n\n\t\t\treturn contents;\n\t\t} catch (ex) {\n\t\t\tif (options?.throw) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\t@log()\n\tasync runGitCommandViaTerminal(cwd: string, command: string, args: string[], options?: { execute?: boolean }) {\n\t\tconst scope = getLogScope();\n\n\t\tconst location = await this.getLocation();\n\t\tconst git = normalizePath(location.path ?? 'git');\n\n\t\tconst coreEditorConfig = configuration.get('terminal.overrideGitEditor')\n\t\t\t? `-c \"core.editor=${getEditorCommand()}\" `\n\t\t\t: '';\n\n\t\tconst parsedArgs = args.map(arg => (arg.startsWith('#') || /['();$|>&<]/.test(arg) ? `\"${arg}\"` : arg));\n\n\t\tlet text;\n\t\tif (git.includes(' ') && isWindows) {\n\t\t\tlet shortenedPath = await getWindowsShortPath(git);\n\t\t\tLogger.log(scope, `\\u2022 using short Git path '${shortenedPath}' rather than '${git}'`);\n\n\t\t\tif (shortenedPath.includes(' ')) {\n\t\t\t\tconst profile = configuration.getAny<CoreConfiguration, string | null>(\n\t\t\t\t\t'terminal.integrated.defaultProfile.windows',\n\t\t\t\t);\n\t\t\t\tLogger.debug(scope, `\\u2022 short path '${shortenedPath}' contains spaces, profile '${profile}'`);\n\t\t\t\tshortenedPath = `${equalsIgnoreCase(profile, 'powershell') ? '& ' : ''}\"${shortenedPath}\"`;\n\t\t\t}\n\n\t\t\ttext = `${shortenedPath} -C \"${cwd}\" ${coreEditorConfig}${command} ${parsedArgs.join(' ')}`;\n\t\t} else {\n\t\t\ttext = `${git.includes(' ') ? `\"${git}\"` : git} -C \"${cwd}\" ${coreEditorConfig}${command} ${parsedArgs.join(\n\t\t\t\t' ',\n\t\t\t)}`;\n\t\t}\n\n\t\tLogger.log(scope, `\\u2022 '${text}'`);\n\t\tthis.logGitCommand(`[TERM] ${text}`, 0);\n\n\t\tconst terminal = ensureGitTerminal();\n\t\tterminal.show(false);\n\t\t// Removing this as this doesn't seem to work on bash\n\t\t// // Sends ansi codes to remove any text on the current input line\n\t\t// terminal.sendText('\\x1b[2K\\x1b', false);\n\t\tterminal.sendText(text, options?.execute ?? false);\n\t}\n\n\tprivate _gitOutput: OutputChannel | undefined;\n\n\tprivate logGitCommand(command: string, duration: number, ex?: Error): void {\n\t\tif (!Logger.enabled(LogLevel.Debug) && !Logger.isDebugging) return;\n\n\t\tconst slow = duration > slowCallWarningThreshold;\n\n\t\tif (Logger.isDebugging) {\n\t\t\tif (ex != null) {\n\t\t\t\tconsole.error(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr, ex);\n\t\t\t} else if (slow) {\n\t\t\t\tconsole.warn(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr);\n\t\t\t} else {\n\t\t\t\tconsole.log(Logger.timestamp, '[GitLens (Git)]', command ?? emptyStr);\n\t\t\t}\n\t\t}\n\n\t\tif (this._gitOutput == null) {\n\t\t\tthis._gitOutput = window.createOutputChannel('GitLens (Git)');\n\t\t}\n\t\tthis._gitOutput.appendLine(\n\t\t\t`${Logger.timestamp} [${slow ? '*' : ' '}${duration.toString().padStart(6)}ms] ${command}${\n\t\t\t\tex != null ? `\\n\\n${ex.toString()}` : emptyStr\n\t\t\t}`,\n\t\t);\n\t}\n}\n\nexport function getShaInLogRegex(sha: string) {\n\treturn new RegExp(`(?:^\\x00*|\\x00\\x00)${sha}\\x00`);\n}\n", "import { readdir, realpath } from 'fs';\nimport { homedir, hostname, userInfo } from 'os';\nimport { resolve as resolvePath } from 'path';\nimport { env as process_env } from 'process';\nimport type { CancellationToken, Event, TextDocument, WorkspaceFolder } from 'vscode';\nimport { Disposable, env, EventEmitter, extensions, FileType, Range, Uri, window, workspace } from 'vscode';\nimport { md5 } from '@env/crypto';\nimport { fetch, getProxyAgent } from '@env/fetch';\nimport { hrtime } from '@env/hrtime';\nimport { isLinux, isWindows } from '@env/platform';\nimport type {\n\tAPI as BuiltInGitApi,\n\tRepository as BuiltInGitRepository,\n\tGitExtension,\n} from '../../../@types/vscode.git';\nimport { getCachedAvatarUri } from '../../../avatars';\nimport type { CoreConfiguration, CoreGitConfiguration } from '../../../constants';\nimport { GlyphChars, Schemes } from '../../../constants';\nimport type { Container } from '../../../container';\nimport { emojify } from '../../../emojis';\nimport { Features } from '../../../features';\nimport { GitErrorHandling } from '../../../git/commandOptions';\nimport {\n\tGitSearchError,\n\tStashApplyError,\n\tStashApplyErrorReason,\n\tWorktreeCreateError,\n\tWorktreeCreateErrorReason,\n\tWorktreeDeleteError,\n\tWorktreeDeleteErrorReason,\n} from '../../../git/errors';\nimport type {\n\tGitCaches,\n\tGitDir,\n\tGitProvider,\n\tGitProviderDescriptor,\n\tNextComparisonUrisResult,\n\tPagedResult,\n\tPreviousComparisonUrisResult,\n\tPreviousLineComparisonUrisResult,\n\tRepositoryCloseEvent,\n\tRepositoryInitWatcher,\n\tRepositoryOpenEvent,\n\tRevisionUriData,\n\tScmRepository,\n} from '../../../git/gitProvider';\nimport { GitProviderId, RepositoryVisibility } from '../../../git/gitProvider';\nimport { encodeGitLensRevisionUriAuthority, GitUri } from '../../../git/gitUri';\nimport type { GitBlame, GitBlameAuthor, GitBlameLine, GitBlameLines } from '../../../git/models/blame';\nimport type { BranchSortOptions } from '../../../git/models/branch';\nimport {\n\tgetBranchId,\n\tgetBranchNameWithoutRemote,\n\tgetRemoteNameFromBranchName,\n\tGitBranch,\n\tisDetachedHead,\n\tsortBranches,\n} from '../../../git/models/branch';\nimport type { GitStashCommit } from '../../../git/models/commit';\nimport { GitCommit, GitCommitIdentity } from '../../../git/models/commit';\nimport { deletedOrMissing, uncommitted, uncommittedStaged } from '../../../git/models/constants';\nimport { GitContributor } from '../../../git/models/contributor';\nimport type { GitDiff, GitDiffFilter, GitDiffHunkLine, GitDiffShortStat } from '../../../git/models/diff';\nimport type { GitFile, GitFileStatus } from '../../../git/models/file';\nimport { GitFileChange } from '../../../git/models/file';\nimport type {\n\tGitGraph,\n\tGitGraphRow,\n\tGitGraphRowContexts,\n\tGitGraphRowHead,\n\tGitGraphRowRemoteHead,\n\tGitGraphRowTag,\n} from '../../../git/models/graph';\nimport { GitGraphRowType } from '../../../git/models/graph';\nimport type { GitLog } from '../../../git/models/log';\nimport type { GitMergeStatus } from '../../../git/models/merge';\nimport type { GitRebaseStatus } from '../../../git/models/rebase';\nimport type { GitBranchReference } from '../../../git/models/reference';\nimport {\n\tcreateReference,\n\tgetReferenceFromBranch,\n\tisBranchReference,\n\tisRevisionRange,\n\tisSha,\n\tisShaLike,\n\tisUncommitted,\n\tisUncommittedStaged,\n\tshortenRevision,\n} from '../../../git/models/reference';\nimport type { GitReflog } from '../../../git/models/reflog';\nimport { getRemoteIconUri, getVisibilityCacheKey, GitRemote } from '../../../git/models/remote';\nimport { RemoteResourceType } from '../../../git/models/remoteResource';\nimport type { RepositoryChangeEvent } from '../../../git/models/repository';\nimport { Repository, RepositoryChange, RepositoryChangeComparisonMode } from '../../../git/models/repository';\nimport type { GitStash } from '../../../git/models/stash';\nimport type { GitStatusFile } from '../../../git/models/status';\nimport { GitStatus } from '../../../git/models/status';\nimport type { GitTag, TagSortOptions } from '../../../git/models/tag';\nimport { getTagId, sortTags } from '../../../git/models/tag';\nimport type { GitTreeEntry } from '../../../git/models/tree';\nimport type { GitUser } from '../../../git/models/user';\nimport { isUserMatch } from '../../../git/models/user';\nimport type { GitWorktree } from '../../../git/models/worktree';\nimport { GitBlameParser } from '../../../git/parsers/blameParser';\nimport { GitBranchParser } from '../../../git/parsers/branchParser';\nimport { GitDiffParser } from '../../../git/parsers/diffParser';\nimport {\n\tcreateLogParserSingle,\n\tcreateLogParserWithFiles,\n\tgetContributorsParser,\n\tgetGraphParser,\n\tgetRefAndDateParser,\n\tgetRefParser,\n\tGitLogParser,\n\tLogType,\n} from '../../../git/parsers/logParser';\nimport { GitReflogParser } from '../../../git/parsers/reflogParser';\nimport { GitRemoteParser } from '../../../git/parsers/remoteParser';\nimport { GitStatusParser } from '../../../git/parsers/statusParser';\nimport { GitTagParser } from '../../../git/parsers/tagParser';\nimport { GitTreeParser } from '../../../git/parsers/treeParser';\nimport { GitWorktreeParser } from '../../../git/parsers/worktreeParser';\nimport type { RemoteProviders } from '../../../git/remotes/remoteProviders';\nimport { getRemoteProviderMatcher, loadRemoteProviders } from '../../../git/remotes/remoteProviders';\nimport type { GitSearch, GitSearchResultData, GitSearchResults, SearchQuery } from '../../../git/search';\nimport { getGitArgsFromSearchQuery, getSearchQueryComparisonKey } from '../../../git/search';\nimport {\n\tshowGenericErrorMessage,\n\tshowGitDisabledErrorMessage,\n\tshowGitInvalidConfigErrorMessage,\n\tshowGitMissingErrorMessage,\n\tshowGitVersionUnsupportedErrorMessage,\n} from '../../../messages';\nimport type {\n\tGraphBranchContextValue,\n\tGraphItemContext,\n\tGraphItemRefContext,\n\tGraphItemRefGroupContext,\n\tGraphTagContextValue,\n} from '../../../plus/webviews/graph/protocol';\nimport { countStringLength, filterMap } from '../../../system/array';\nimport { TimedCancellationSource } from '../../../system/cancellation';\nimport { configuration } from '../../../system/configuration';\nimport { gate } from '../../../system/decorators/gate';\nimport { debug, log } from '../../../system/decorators/log';\nimport { debounce } from '../../../system/function';\nimport { filterMap as filterMapIterable, find, first, join, last, map, some } from '../../../system/iterable';\nimport { Logger } from '../../../system/logger';\nimport type { LogScope } from '../../../system/logger.scope';\nimport { getLogScope } from '../../../system/logger.scope';\nimport {\n\tcommonBaseIndex,\n\tdirname,\n\tgetBestPath,\n\tisAbsolute,\n\tisFolderGlob,\n\tjoinPaths,\n\tmaybeUri,\n\tnormalizePath,\n\trelative,\n\tsplitPath,\n} from '../../../system/path';\nimport type { PromiseOrValue } from '../../../system/promise';\nimport { any, asSettled, getSettledValue } from '../../../system/promise';\nimport { equalsIgnoreCase, getDurationMilliseconds, interpolate, splitSingle } from '../../../system/string';\nimport { PathTrie } from '../../../system/trie';\nimport { compare, fromString } from '../../../system/version';\nimport { serializeWebviewItemContext } from '../../../system/webview';\nimport type { CachedBlame, CachedDiff, CachedLog, TrackedDocument } from '../../../trackers/gitDocumentTracker';\nimport { GitDocumentState } from '../../../trackers/gitDocumentTracker';\nimport type { Git } from './git';\nimport {\n\tgetShaInLogRegex,\n\tGitErrors,\n\tgitLogDefaultConfigs,\n\tgitLogDefaultConfigsWithFiles,\n\tmaxGitCliLength,\n} from './git';\nimport type { GitLocation } from './locator';\nimport { findGitPath, InvalidGitConfigError, UnableToFindGitError } from './locator';\nimport { CancelledRunError, fsExists, RunError } from './shell';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyPromise: Promise<GitBlame | GitDiff | GitLog | undefined> = Promise.resolve(undefined);\nconst emptyPagedResult: PagedResult<any> = Object.freeze({ values: [] });\nconst slash = 47;\n\nconst RepoSearchWarnings = {\n\tdoesNotExist: /no such file or directory/i,\n};\n\nconst driveLetterRegex = /(?<=^\\/?)([a-zA-Z])(?=:\\/)/;\nconst userConfigRegex = /^user\\.(name|email) (.*)$/gm;\nconst mappedAuthorRegex = /(.+)\\s<(.+)>/;\nconst stashSummaryRegex =\n\t/(?:(?:(?<wip>WIP) on|On) (?<onref>[^/](?!.*\\/\\.)(?!.*\\.\\.)(?!.*\\/\\/)(?!.*@\\{)[^\\000-\\037\\177 ~^:?*[\\\\]+[^./]):\\s*)?(?<summary>.*)$/s;\n\nconst reflogCommands = ['merge', 'pull'];\n\ninterface RepositoryInfo {\n\tgitDir?: GitDir;\n\tuser?: GitUser | null;\n}\n\nexport class LocalGitProvider implements GitProvider, Disposable {\n\treadonly descriptor: GitProviderDescriptor = { id: GitProviderId.Git, name: 'Git', virtual: false };\n\treadonly supportedSchemes: Set<string> = new Set([\n\t\tSchemes.File,\n\t\tSchemes.Git,\n\t\tSchemes.GitLens,\n\t\tSchemes.PRs,\n\t\t// DocumentSchemes.Vsls,\n\t]);\n\n\tprivate _onDidChangeRepository = new EventEmitter<RepositoryChangeEvent>();\n\tget onDidChangeRepository(): Event<RepositoryChangeEvent> {\n\t\treturn this._onDidChangeRepository.event;\n\t}\n\n\tprivate _onDidCloseRepository = new EventEmitter<RepositoryCloseEvent>();\n\tget onDidCloseRepository(): Event<RepositoryCloseEvent> {\n\t\treturn this._onDidCloseRepository.event;\n\t}\n\n\tprivate _onDidOpenRepository = new EventEmitter<RepositoryOpenEvent>();\n\tget onDidOpenRepository(): Event<RepositoryOpenEvent> {\n\t\treturn this._onDidOpenRepository.event;\n\t}\n\n\tprivate readonly _branchesCache = new Map<string, Promise<PagedResult<GitBranch>>>();\n\tprivate readonly _contributorsCache = new Map<string, Promise<GitContributor[]>>();\n\tprivate readonly _mergeStatusCache = new Map<string, GitMergeStatus | null>();\n\tprivate readonly _rebaseStatusCache = new Map<string, GitRebaseStatus | null>();\n\tprivate readonly _repoInfoCache = new Map<string, RepositoryInfo>();\n\tprivate readonly _stashesCache = new Map<string, GitStash | null>();\n\tprivate readonly _tagsCache = new Map<string, Promise<PagedResult<GitTag>>>();\n\tprivate readonly _trackedPaths = new PathTrie<PromiseOrValue<[string, string] | undefined>>();\n\n\tprivate _disposables: Disposable[] = [];\n\n\tconstructor(protected readonly container: Container, protected readonly git: Git) {\n\t\tthis.git.setLocator(this.ensureGit.bind(this));\n\n\t\tthis._disposables.push(\n\t\t\tthis.container.events.on('git:cache:reset', e =>\n\t\t\t\te.data.repoPath\n\t\t\t\t\t? this.resetCache(e.data.repoPath, ...(e.data.caches ?? emptyArray))\n\t\t\t\t\t: this.resetCaches(...(e.data.caches ?? emptyArray)),\n\t\t\t),\n\t\t);\n\t}\n\n\tdispose() {\n\t\tDisposable.from(...this._disposables).dispose();\n\t}\n\n\tprivate get useCaching() {\n\t\treturn configuration.get('advanced.caching.enabled');\n\t}\n\n\tprivate onRepositoryChanged(repo: Repository, e: RepositoryChangeEvent) {\n\t\tif (e.changed(RepositoryChange.Config, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._repoInfoCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Heads, RepositoryChange.Remotes, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._branchesCache.delete(repo.path);\n\t\t\tthis._contributorsCache.delete(repo.path);\n\t\t\tthis._contributorsCache.delete(`stats|${repo.path}`);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Index, RepositoryChange.Unknown, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._trackedPaths.clear();\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Merge, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._mergeStatusCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Rebase, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._rebaseStatusCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Stash, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._stashesCache.delete(repo.path);\n\t\t}\n\n\t\tif (e.changed(RepositoryChange.Tags, RepositoryChangeComparisonMode.Any)) {\n\t\t\tthis._tagsCache.delete(repo.path);\n\t\t}\n\n\t\tthis._onDidChangeRepository.fire(e);\n\t}\n\n\tprivate _gitLocator: Promise<GitLocation> | undefined;\n\tprivate async ensureGit(): Promise<GitLocation> {\n\t\tif (this._gitLocator == null) {\n\t\t\tthis._gitLocator = this.findGit();\n\t\t}\n\n\t\treturn this._gitLocator;\n\t}\n\n\t@log()\n\tprivate async findGit(): Promise<GitLocation> {\n\t\tconst scope = getLogScope();\n\n\t\tif (!configuration.getAny<CoreGitConfiguration, boolean>('git.enabled', null, true)) {\n\t\t\tLogger.log(scope, 'Built-in Git is disabled (\"git.enabled\": false)');\n\t\t\tvoid showGitDisabledErrorMessage();\n\n\t\t\tthrow new UnableToFindGitError();\n\t\t}\n\n\t\tconst scmGitPromise = this.getScmGitApi();\n\n\t\tasync function subscribeToScmOpenCloseRepository(this: LocalGitProvider) {\n\t\t\tconst scmGit = await scmGitPromise;\n\t\t\tif (scmGit == null) return;\n\n\t\t\tthis._disposables.push(\n\t\t\t\t// Since we will get \"close\" events for repos when vscode is shutting down, debounce the event so ensure we aren't shutting down\n\t\t\t\tscmGit.onDidCloseRepository(\n\t\t\t\t\tdebounce(e => {\n\t\t\t\t\t\tif (this.container.deactivating) return;\n\t\t\t\t\t\tthis._onDidCloseRepository.fire({ uri: e.rootUri });\n\t\t\t\t\t}, 1000),\n\t\t\t\t),\n\t\t\t\tscmGit.onDidOpenRepository(e => this._onDidOpenRepository.fire({ uri: e.rootUri })),\n\t\t\t);\n\n\t\t\tfor (const scmRepository of scmGit.repositories) {\n\t\t\t\tthis._onDidOpenRepository.fire({ uri: scmRepository.rootUri });\n\t\t\t}\n\t\t}\n\t\tvoid subscribeToScmOpenCloseRepository.call(this);\n\n\t\tconst potentialGitPaths =\n\t\t\tconfiguration.getAny<CoreGitConfiguration, string | string[]>('git.path') ??\n\t\t\tthis.container.storage.getWorkspace('gitPath');\n\n\t\tconst start = hrtime();\n\n\t\tconst findGitPromise = findGitPath(potentialGitPaths);\n\t\t// Try to use the same git as the built-in vscode git extension, but don't wait for it if we find something faster\n\t\tconst findGitFromSCMPromise = scmGitPromise.then(gitApi => {\n\t\t\tconst path = gitApi?.git.path;\n\t\t\tif (!path) return findGitPromise;\n\n\t\t\tif (potentialGitPaths != null) {\n\t\t\t\tif (typeof potentialGitPaths === 'string') {\n\t\t\t\t\tif (path === potentialGitPaths) return findGitPromise;\n\t\t\t\t} else if (potentialGitPaths.includes(path)) {\n\t\t\t\t\treturn findGitPromise;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn findGitPath(path, false);\n\t\t});\n\n\t\tconst location = await any<GitLocation>(findGitPromise, findGitFromSCMPromise);\n\t\t// Save the found git path, but let things settle first to not impact startup performance\n\t\tsetTimeout(() => void this.container.storage.storeWorkspace('gitPath', location.path), 1000);\n\n\t\tif (scope != null) {\n\t\t\tscope.exitDetails = ` ${GlyphChars.Dot} Git (${location.version}) found in ${\n\t\t\t\tlocation.path === 'git' ? 'PATH' : location.path\n\t\t\t}`;\n\t\t} else {\n\t\t\tLogger.log(\n\t\t\t\tscope,\n\t\t\t\t`Git (${location.version}) found in ${\n\t\t\t\t\tlocation.path === 'git' ? 'PATH' : location.path\n\t\t\t\t} [${getDurationMilliseconds(start)}ms]`,\n\t\t\t);\n\t\t}\n\n\t\t// Warn if git is less than v2.7.2\n\t\tif (compare(fromString(location.version), fromString('2.7.2')) === -1) {\n\t\t\tLogger.log(scope, `Git version (${location.version}) is outdated`);\n\t\t\tvoid showGitVersionUnsupportedErrorMessage(location.version, '2.7.2');\n\t\t}\n\n\t\treturn location;\n\t}\n\n\t@debug({ exit: true })\n\tasync discoverRepositories(uri: Uri): Promise<Repository[]> {\n\t\tif (uri.scheme !== Schemes.File) return [];\n\n\t\ttry {\n\t\t\tconst autoRepositoryDetection =\n\t\t\t\tconfiguration.getAny<CoreGitConfiguration, boolean | 'subFolders' | 'openEditors'>(\n\t\t\t\t\t'git.autoRepositoryDetection',\n\t\t\t\t) ?? true;\n\n\t\t\tconst folder = workspace.getWorkspaceFolder(uri);\n\t\t\tif (folder == null) return [];\n\n\t\t\tvoid (await this.ensureGit());\n\n\t\t\tconst repositories = await this.repositorySearch(\n\t\t\t\tfolder,\n\t\t\t\tautoRepositoryDetection === false || autoRepositoryDetection === 'openEditors' ? 0 : undefined,\n\t\t\t);\n\n\t\t\tif (autoRepositoryDetection === true || autoRepositoryDetection === 'subFolders') {\n\t\t\t\tfor (const repository of repositories) {\n\t\t\t\t\tvoid this.openScmRepository(repository.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (repositories.length > 0) {\n\t\t\t\tthis._trackedPaths.clear();\n\t\t\t}\n\n\t\t\treturn repositories;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof InvalidGitConfigError) {\n\t\t\t\tvoid showGitInvalidConfigErrorMessage();\n\t\t\t} else if (ex instanceof UnableToFindGitError) {\n\t\t\t\tvoid showGitMissingErrorMessage();\n\t\t\t} else {\n\t\t\t\tconst msg: string = ex?.message ?? '';\n\t\t\t\tif (msg) {\n\t\t\t\t\tvoid window.showErrorMessage(`Unable to initialize Git; ${msg}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t@debug({ exit: true })\n\topenRepository(\n\t\tfolder: WorkspaceFolder | undefined,\n\t\turi: Uri,\n\t\troot: boolean,\n\t\tsuspended?: boolean,\n\t\tclosed?: boolean,\n\t): Repository[] {\n\t\tif (!closed) {\n\t\t\tvoid this.openScmRepository(uri);\n\t\t}\n\n\t\t// Add a closed (hidden) repository for the canonical version\n\t\tconst canonicalUri = this.toCanonicalMap.get(getBestPath(uri));\n\t\tif (canonicalUri != null) {\n\t\t\treturn [\n\t\t\t\tnew Repository(\n\t\t\t\t\tthis.container,\n\t\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\t\tthis.descriptor,\n\t\t\t\t\tfolder,\n\t\t\t\t\turi,\n\t\t\t\t\troot,\n\t\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\t\tclosed,\n\t\t\t\t\t// canonicalUri,\n\t\t\t\t),\n\t\t\t\tnew Repository(\n\t\t\t\t\tthis.container,\n\t\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\t\tthis.descriptor,\n\t\t\t\t\tfolder,\n\t\t\t\t\tcanonicalUri,\n\t\t\t\t\troot,\n\t\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\t\ttrue,\n\t\t\t\t\t// uri,\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\n\t\treturn [\n\t\t\tnew Repository(\n\t\t\t\tthis.container,\n\t\t\t\tthis.onRepositoryChanged.bind(this),\n\t\t\t\tthis.descriptor,\n\t\t\t\tfolder,\n\t\t\t\turi,\n\t\t\t\troot,\n\t\t\t\tsuspended ?? !window.state.focused,\n\t\t\t\tclosed,\n\t\t\t),\n\t\t];\n\t}\n\n\t@debug()\n\topenRepositoryInitWatcher(): RepositoryInitWatcher {\n\t\tconst watcher = workspace.createFileSystemWatcher('**/.git', false, true, true);\n\t\treturn {\n\t\t\tonDidCreate: watcher.onDidCreate,\n\t\t\tdispose: () => void watcher.dispose(),\n\t\t};\n\t}\n\n\tprivate _supportedFeatures = new Map<Features, boolean>();\n\tasync supports(feature: Features): Promise<boolean> {\n\t\tlet supported = this._supportedFeatures.get(feature);\n\t\tif (supported != null) return supported;\n\n\t\tswitch (feature) {\n\t\t\tcase Features.Worktrees:\n\t\t\t\tsupported = await this.git.isAtLeastVersion('2.17.0');\n\t\t\t\tthis._supportedFeatures.set(feature, supported);\n\t\t\t\treturn supported;\n\t\t\tcase Features.StashOnlyStaged:\n\t\t\t\tsupported = await this.git.isAtLeastVersion('2.35.0');\n\t\t\t\tthis._supportedFeatures.set(feature, supported);\n\t\t\t\treturn supported;\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t@debug<LocalGitProvider['visibility']>({ exit: r => `returned ${r[0]}` })\n\tasync visibility(repoPath: string): Promise<[visibility: RepositoryVisibility, cacheKey: string | undefined]> {\n\t\tconst remotes = await this.getRemotes(repoPath, { sort: true });\n\t\tif (remotes.length === 0) return [RepositoryVisibility.Local, undefined];\n\n\t\tlet local = true;\n\t\tfor await (const result of asSettled(remotes.map(r => this.getRemoteVisibility(r)))) {\n\t\t\tif (result.status !== 'fulfilled') continue;\n\n\t\t\tif (result.value[0] === RepositoryVisibility.Public) {\n\t\t\t\treturn [RepositoryVisibility.Public, getVisibilityCacheKey(result.value[1])];\n\t\t\t}\n\t\t\tif (result.value[0] !== RepositoryVisibility.Local) {\n\t\t\t\tlocal = false;\n\t\t\t}\n\t\t}\n\n\t\treturn local\n\t\t\t? [RepositoryVisibility.Local, undefined]\n\t\t\t: [RepositoryVisibility.Private, getVisibilityCacheKey(remotes)];\n\t}\n\n\t@debug<LocalGitProvider['getRemoteVisibility']>({ args: { 0: r => r.url }, exit: r => `returned ${r[0]}` })\n\tprivate async getRemoteVisibility(\n\t\tremote: GitRemote,\n\t): Promise<[visibility: RepositoryVisibility, remote: GitRemote]> {\n\t\tconst scope = getLogScope();\n\n\t\tswitch (remote.provider?.id) {\n\t\t\tcase 'github':\n\t\t\tcase 'gitlab':\n\t\t\tcase 'bitbucket':\n\t\t\tcase 'azure-devops':\n\t\t\tcase 'gitea':\n\t\t\tcase 'gerrit':\n\t\t\tcase 'google-source': {\n\t\t\t\tconst url = remote.provider.url({ type: RemoteResourceType.Repo });\n\t\t\t\tif (url == null) return [RepositoryVisibility.Private, remote];\n\n\t\t\t\t// Check if the url returns a 200 status code\n\t\t\t\ttry {\n\t\t\t\t\tconst rsp = await fetch(url, { method: 'HEAD', agent: getProxyAgent() });\n\t\t\t\t\tif (rsp.ok) return [RepositoryVisibility.Public, remote];\n\n\t\t\t\t\tLogger.debug(scope, `Response=${rsp.status}`);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tLogger.error(ex, scope);\n\t\t\t\t}\n\t\t\t\treturn [RepositoryVisibility.Private, remote];\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn maybeUri(remote.url)\n\t\t\t\t\t? [RepositoryVisibility.Private, remote]\n\t\t\t\t\t: [RepositoryVisibility.Local, remote];\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['repositorySearch']>({\n\t\targs: false,\n\t\tsingleLine: true,\n\t\tprefix: (context, folder) => `${context.prefix}(${folder.uri.fsPath})`,\n\t\texit: r => `returned ${r.length} repositories ${r.length !== 0 ? Logger.toLoggable(r) : ''}`,\n\t})\n\tprivate async repositorySearch(folder: WorkspaceFolder, depth?: number): Promise<Repository[]> {\n\t\tconst scope = getLogScope();\n\t\tdepth =\n\t\t\tdepth ??\n\t\t\tconfiguration.get('advanced.repositorySearchDepth', folder.uri) ??\n\t\t\tconfiguration.getAny<CoreGitConfiguration, number>('git.repositoryScanMaxDepth', folder.uri, 1);\n\n\t\tLogger.log(scope, `searching (depth=${depth})...`);\n\n\t\tconst repositories: Repository[] = [];\n\n\t\tlet rootPath;\n\t\tlet canonicalRootPath;\n\n\t\tconst uri = await this.findRepositoryUri(folder.uri, true);\n\t\tif (uri != null) {\n\t\t\trootPath = normalizePath(uri.fsPath);\n\n\t\t\tconst canonicalUri = this.toCanonicalMap.get(getBestPath(uri));\n\t\t\tif (canonicalUri != null) {\n\t\t\t\tcanonicalRootPath = normalizePath(canonicalUri.fsPath);\n\t\t\t}\n\n\t\t\tLogger.log(scope, `found root repository in '${uri.fsPath}'`);\n\t\t\trepositories.push(...this.openRepository(folder, uri, true));\n\t\t}\n\n\t\tif (depth <= 0) return repositories;\n\n\t\t// Get any specified excludes -- this is a total hack, but works for some simple cases and something is better than nothing :)\n\t\tconst excludes = new Set<string>(\n\t\t\tconfiguration.getAny<CoreGitConfiguration, string[]>('git.repositoryScanIgnoredFolders', folder.uri, []),\n\t\t);\n\t\tfor (let [key, value] of Object.entries({\n\t\t\t...configuration.getAny<CoreConfiguration, Record<string, boolean>>('files.exclude', folder.uri, {}),\n\t\t\t...configuration.getAny<CoreConfiguration, Record<string, boolean>>('search.exclude', folder.uri, {}),\n\t\t})) {\n\t\t\tif (!value) continue;\n\t\t\tif (key.includes('*.')) continue;\n\n\t\t\tif (key.startsWith('**/')) {\n\t\t\t\tkey = key.substring(3);\n\t\t\t}\n\t\t\texcludes.add(key);\n\t\t}\n\n\t\tlet repoPaths;\n\t\ttry {\n\t\t\trepoPaths = await this.repositorySearchCore(folder.uri.fsPath, depth, excludes);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (RepoSearchWarnings.doesNotExist.test(msg)) {\n\t\t\t\tLogger.log(scope, `FAILED${msg ? ` Error: ${msg}` : ''}`);\n\t\t\t} else {\n\t\t\t\tLogger.error(ex, scope, 'FAILED');\n\t\t\t}\n\n\t\t\treturn repositories;\n\t\t}\n\n\t\tfor (let p of repoPaths) {\n\t\t\tp = dirname(p);\n\t\t\tconst normalized = normalizePath(p);\n\n\t\t\t// If we are the same as the root, skip it\n\t\t\tif (\n\t\t\t\t(isLinux &&\n\t\t\t\t\t(normalized === rootPath || (canonicalRootPath != null && normalized === canonicalRootPath))) ||\n\t\t\t\tequalsIgnoreCase(normalized, rootPath) ||\n\t\t\t\t(canonicalRootPath != null && equalsIgnoreCase(normalized, canonicalRootPath))\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLogger.log(scope, `searching in '${p}'...`);\n\t\t\tLogger.debug(\n\t\t\t\tscope,\n\t\t\t\t`normalizedRepoPath=${normalized}, rootPath=${rootPath}, canonicalRootPath=${canonicalRootPath}`,\n\t\t\t);\n\n\t\t\tconst rp = await this.findRepositoryUri(Uri.file(p), true);\n\t\t\tif (rp == null) continue;\n\n\t\t\tLogger.log(scope, `found repository in '${rp.fsPath}'`);\n\t\t\trepositories.push(...this.openRepository(folder, rp, false));\n\t\t}\n\n\t\treturn repositories;\n\t}\n\n\t@debug<LocalGitProvider['repositorySearchCore']>({ args: { 2: false, 3: false }, exit: true })\n\tprivate repositorySearchCore(\n\t\troot: string,\n\t\tdepth: number,\n\t\texcludes: Set<string>,\n\t\trepositories: string[] = [],\n\t): Promise<string[]> {\n\t\tconst scope = getLogScope();\n\n\t\treturn new Promise<string[]>((resolve, reject) => {\n\t\t\treaddir(root, { withFileTypes: true }, async (err, files) => {\n\t\t\t\tif (err != null) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (files.length === 0) {\n\t\t\t\t\tresolve(repositories);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdepth--;\n\n\t\t\t\tlet f;\n\t\t\t\tfor (f of files) {\n\t\t\t\t\tif (f.name === '.git') {\n\t\t\t\t\t\trepositories.push(resolvePath(root, f.name));\n\t\t\t\t\t} else if (depth >= 0 && f.isDirectory() && !excludes.has(f.name)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.repositorySearchCore(resolvePath(root, f.name), depth, excludes, repositories);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tLogger.error(ex, scope, 'FAILED');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresolve(repositories);\n\t\t\t});\n\t\t});\n\t}\n\n\tcanHandlePathOrUri(scheme: string, pathOrUri: string | Uri): string | undefined {\n\t\tif (!this.supportedSchemes.has(scheme)) return undefined;\n\t\treturn getBestPath(pathOrUri);\n\t}\n\n\tgetAbsoluteUri(pathOrUri: string | Uri, base: string | Uri): Uri {\n\t\t// Convert the base to a Uri if it isn't one\n\t\tif (typeof base === 'string') {\n\t\t\t// If it looks like a Uri parse it\n\t\t\tif (maybeUri(base)) {\n\t\t\t\tbase = Uri.parse(base, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(base)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t`Unable to get absolute uri between ${\n\t\t\t\t\t\t\ttypeof pathOrUri === 'string' ? pathOrUri : pathOrUri.toString(true)\n\t\t\t\t\t\t} and ${base}; Base path '${base}' must be an absolute path`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Base path '${base}' must be an absolute path`);\n\t\t\t\t}\n\n\t\t\t\tbase = Uri.file(base);\n\t\t\t}\n\t\t}\n\n\t\t// Short-circuit if the path is relative\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tconst normalized = normalizePath(pathOrUri);\n\t\t\tif (!isAbsolute(normalized)) return Uri.joinPath(base, normalized);\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, base);\n\t\treturn Uri.joinPath(base, relativePath);\n\t}\n\n\t@log({ exit: true })\n\tasync getBestRevisionUri(repoPath: string, path: string, ref: string | undefined): Promise<Uri | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\t// TODO@eamodio Align this with isTrackedCore?\n\t\tif (!ref || (isUncommitted(ref) && !isUncommittedStaged(ref))) {\n\t\t\t// Make sure the file exists in the repo\n\t\t\tlet data = await this.git.ls_files(repoPath, path);\n\t\t\tif (data != null) return this.getAbsoluteUri(path, repoPath);\n\n\t\t\t// Check if the file exists untracked\n\t\t\tdata = await this.git.ls_files(repoPath, path, { untracked: true });\n\t\t\tif (data != null) return this.getAbsoluteUri(path, repoPath);\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (isUncommittedStaged(ref)) return this.getScmGitUri(path, repoPath);\n\n\t\treturn this.getRevisionUri(repoPath, path, ref);\n\t}\n\n\tgetRelativePath(pathOrUri: string | Uri, base: string | Uri): string {\n\t\t// Convert the base to a Uri if it isn't one\n\t\tif (typeof base === 'string') {\n\t\t\t// If it looks like a Uri parse it\n\t\t\tif (maybeUri(base)) {\n\t\t\t\tbase = Uri.parse(base, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(base)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t\tvoid window.showErrorMessage(\n\t\t\t\t\t\t`Unable to get relative path between ${\n\t\t\t\t\t\t\ttypeof pathOrUri === 'string' ? pathOrUri : pathOrUri.toString(true)\n\t\t\t\t\t\t} and ${base}; Base path '${base}' must be an absolute path`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Base path '${base}' must be an absolute path`);\n\t\t\t\t}\n\n\t\t\t\tbase = Uri.file(base);\n\t\t\t}\n\t\t}\n\n\t\t// Convert the path to a Uri if it isn't one\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (maybeUri(pathOrUri)) {\n\t\t\t\tpathOrUri = Uri.parse(pathOrUri, true);\n\t\t\t} else {\n\t\t\t\tif (!isAbsolute(pathOrUri)) return normalizePath(pathOrUri);\n\n\t\t\t\tpathOrUri = Uri.file(pathOrUri);\n\t\t\t}\n\t\t}\n\n\t\tconst relativePath = relative(base.fsPath, pathOrUri.fsPath);\n\t\treturn normalizePath(relativePath);\n\t}\n\n\tgetRevisionUri(repoPath: string, path: string, ref: string): Uri {\n\t\tif (isUncommitted(ref)) {\n\t\t\treturn isUncommittedStaged(ref) ? this.getScmGitUri(path, repoPath) : this.getAbsoluteUri(path, repoPath);\n\t\t}\n\n\t\tpath = normalizePath(this.getAbsoluteUri(path, repoPath).fsPath);\n\t\tif (path.charCodeAt(0) !== slash) {\n\t\t\tpath = `/${path}`;\n\t\t}\n\n\t\tconst metadata: RevisionUriData = {\n\t\t\tref: ref,\n\t\t\trepoPath: normalizePath(repoPath),\n\t\t};\n\n\t\tconst uri = Uri.from({\n\t\t\tscheme: Schemes.GitLens,\n\t\t\tauthority: encodeGitLensRevisionUriAuthority(metadata),\n\t\t\tpath: path,\n\t\t\tquery: ref ? JSON.stringify({ ref: shortenRevision(ref) }) : undefined,\n\t\t});\n\t\treturn uri;\n\t}\n\n\t@log({ exit: true })\n\tasync getWorkingUri(repoPath: string, uri: Uri) {\n\t\tlet relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tlet data;\n\t\tlet ref;\n\t\tdo {\n\t\t\tdata = await this.git.ls_files(repoPath, relativePath);\n\t\t\tif (data != null) {\n\t\t\t\trelativePath = splitSingle(data, '\\n')[0];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// TODO: Add caching\n\n\t\t\tconst cfg = configuration.get('advanced');\n\n\t\t\t// Get the most recent commit for this file name\n\t\t\tref = await this.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\tordering: cfg.commitOrdering,\n\t\t\t\tsimilarityThreshold: cfg.similarityThreshold,\n\t\t\t});\n\t\t\tif (ref == null) return undefined;\n\n\t\t\t// Now check if that commit had any renames\n\t\t\tdata = await this.git.log__file(repoPath, '.', ref, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfilters: ['R', 'C', 'D'],\n\t\t\t\tlimit: 1,\n\t\t\t\tordering: cfg.commitOrdering,\n\t\t\t});\n\t\t\tif (data == null || data.length === 0) break;\n\n\t\t\tconst [foundRef, foundFile, foundStatus] = GitLogParser.parseSimpleRenamed(data, relativePath);\n\t\t\tif (foundStatus === 'D' && foundFile != null) return undefined;\n\t\t\tif (foundRef == null || foundFile == null) break;\n\n\t\t\trelativePath = foundFile;\n\t\t} while (true);\n\n\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\treturn (await fsExists(uri.fsPath)) ? uri : undefined;\n\t}\n\n\t@log()\n\tasync addRemote(repoPath: string, name: string, url: string, options?: { fetch?: boolean }): Promise<void> {\n\t\tawait this.git.remote__add(repoPath, name, url, options);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync pruneRemote(repoPath: string, name: string): Promise<void> {\n\t\tawait this.git.remote__prune(repoPath, name);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync removeRemote(repoPath: string, name: string): Promise<void> {\n\t\tawait this.git.remote__remove(repoPath, name);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['remotes'] });\n\t}\n\n\t@log()\n\tasync applyChangesToWorkingFile(uri: GitUri, ref1?: string, ref2?: string) {\n\t\tconst scope = getLogScope();\n\n\t\tref1 = ref1 ?? uri.sha;\n\t\tif (ref1 == null || uri.repoPath == null) return;\n\n\t\tif (ref2 == null) {\n\t\t\tref2 = ref1;\n\t\t\tref1 = `${ref1}^`;\n\t\t}\n\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\tlet patch;\n\t\ttry {\n\t\t\tpatch = await this.git.diff(root, relativePath, ref1, ref2);\n\t\t\tvoid (await this.git.apply(root, patch));\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (patch && /patch does not apply/i.test(msg)) {\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to apply changes cleanly. Retry and allow conflicts?',\n\t\t\t\t\t{ title: 'Yes' },\n\t\t\t\t\t{ title: 'No', isCloseAffordance: true },\n\t\t\t\t);\n\n\t\t\t\tif (result == null || result.title !== 'Yes') return;\n\n\t\t\t\tif (result.title === 'Yes') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvoid (await this.git.apply(root, patch, { allowConflicts: true }));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// eslint-disable-next-line no-ex-assign\n\t\t\t\t\t\tex = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tvoid showGenericErrorMessage('Unable to apply changes');\n\t\t}\n\t}\n\n\t@log()\n\tasync checkout(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { createBranch?: string } | { path?: string },\n\t): Promise<void> {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tawait this.git.checkout(repoPath, ref, options);\n\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['branches', 'status'] });\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (/overwritten by checkout/i.test(msg)) {\n\t\t\t\tvoid showGenericErrorMessage(\n\t\t\t\t\t`Unable to checkout '${ref}'. Please commit or stash your changes before switching branches`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tvoid showGenericErrorMessage(`Unable to checkout '${ref}'`);\n\t\t}\n\t}\n\n\t@log({ singleLine: true })\n\tprivate resetCache(\n\t\trepoPath: string,\n\t\t...caches: ('branches' | 'contributors' | 'providers' | 'remotes' | 'stashes' | 'status' | 'tags')[]\n\t) {\n\t\tif (caches.length === 0 || caches.includes('branches')) {\n\t\t\tthis._branchesCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('contributors')) {\n\t\t\tthis._contributorsCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('stashes')) {\n\t\t\tthis._stashesCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('status')) {\n\t\t\tthis._mergeStatusCache.delete(repoPath);\n\t\t\tthis._rebaseStatusCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('tags')) {\n\t\t\tthis._tagsCache.delete(repoPath);\n\t\t}\n\n\t\tif (caches.length === 0) {\n\t\t\tthis._trackedPaths.delete(repoPath);\n\t\t\tthis._repoInfoCache.delete(repoPath);\n\t\t}\n\t}\n\n\t@log({ singleLine: true })\n\tprivate resetCaches(...caches: GitCaches[]) {\n\t\tif (caches.length === 0 || caches.includes('branches')) {\n\t\t\tthis._branchesCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('contributors')) {\n\t\t\tthis._contributorsCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('stashes')) {\n\t\t\tthis._stashesCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('status')) {\n\t\t\tthis._mergeStatusCache.clear();\n\t\t\tthis._rebaseStatusCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0 || caches.includes('tags')) {\n\t\t\tthis._tagsCache.clear();\n\t\t}\n\n\t\tif (caches.length === 0) {\n\t\t\tthis._trackedPaths.clear();\n\t\t\tthis._repoInfoCache.clear();\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['excludeIgnoredUris']>({ args: { 1: uris => uris.length } })\n\tasync excludeIgnoredUris(repoPath: string, uris: Uri[]): Promise<Uri[]> {\n\t\tconst paths = new Map<string, Uri>(uris.map(u => [normalizePath(u.fsPath), u]));\n\n\t\tconst data = await this.git.check_ignore(repoPath, ...paths.keys());\n\t\tif (data == null) return uris;\n\n\t\tconst ignored = data.split('\\0').filter(<T>(i?: T): i is T => Boolean(i));\n\t\tif (ignored.length === 0) return uris;\n\n\t\tfor (const file of ignored) {\n\t\t\tpaths.delete(file);\n\t\t}\n\n\t\treturn [...paths.values()];\n\t}\n\n\t@gate()\n\t@log()\n\tasync fetch(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; branch?: GitBranchReference; prune?: boolean; pull?: boolean; remote?: string },\n\t): Promise<void> {\n\t\tconst { branch: branchRef, ...opts } = options ?? {};\n\t\tif (isBranchReference(branchRef)) {\n\t\t\tconst repo = this.container.git.getRepository(repoPath);\n\t\t\tconst branch = await repo?.getBranch(branchRef?.name);\n\t\t\tif (!branch?.remote && branch?.upstream == null) return undefined;\n\n\t\t\tawait this.git.fetch(repoPath, {\n\t\t\t\tbranch: branch.getNameWithoutRemote(),\n\t\t\t\tremote: branch.getRemoteName()!,\n\t\t\t\tupstream: branch.getTrackingWithoutRemote()!,\n\t\t\t\tpull: options?.pull,\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.git.fetch(repoPath, opts);\n\t\t}\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath });\n\t}\n\n\tprivate readonly toCanonicalMap = new Map<string, Uri>();\n\tprivate readonly fromCanonicalMap = new Map<string, Uri>();\n\tprotected readonly unsafePaths = new Set<string>();\n\n\t@gate()\n\t@debug()\n\tasync findRepositoryUri(uri: Uri, isDirectory?: boolean): Promise<Uri | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tlet repoPath: string | undefined;\n\t\ttry {\n\t\t\tif (isDirectory == null) {\n\t\t\t\tconst stats = await workspace.fs.stat(uri);\n\t\t\t\tisDirectory = (stats.type & FileType.Directory) === FileType.Directory;\n\t\t\t}\n\n\t\t\t// If the uri isn't a directory, go up one level\n\t\t\tif (!isDirectory) {\n\t\t\t\turi = Uri.joinPath(uri, '..');\n\t\t\t}\n\n\t\t\tlet safe;\n\t\t\t[safe, repoPath] = await this.git.rev_parse__show_toplevel(uri.fsPath);\n\t\t\tif (safe) {\n\t\t\t\tthis.unsafePaths.delete(uri.fsPath);\n\t\t\t} else if (safe === false) {\n\t\t\t\tthis.unsafePaths.add(uri.fsPath);\n\t\t\t}\n\t\t\tif (!repoPath) return undefined;\n\n\t\t\tconst repoUri = Uri.file(repoPath);\n\n\t\t\t// On Git 2.25+ if you call `rev-parse --show-toplevel` on a mapped drive, instead of getting the mapped drive path back, you get the UNC path for the mapped drive.\n\t\t\t// So try to normalize it back to the mapped drive path, if possible\n\t\t\tif (isWindows && repoUri.authority.length !== 0 && uri.authority.length === 0) {\n\t\t\t\tconst match = driveLetterRegex.exec(uri.path);\n\t\t\t\tif (match != null) {\n\t\t\t\t\tconst [, letter] = match;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst networkPath = await new Promise<string | undefined>(resolve =>\n\t\t\t\t\t\t\trealpath.native(`${letter}:\\\\`, { encoding: 'utf8' }, (err, resolvedPath) =>\n\t\t\t\t\t\t\t\tresolve(err != null ? undefined : resolvedPath),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (networkPath != null) {\n\t\t\t\t\t\t\trepoPath = normalizePath(\n\t\t\t\t\t\t\t\trepoUri.fsPath.replace(\n\t\t\t\t\t\t\t\t\tnetworkPath,\n\t\t\t\t\t\t\t\t\t`${letter.toLowerCase()}:${networkPath.endsWith('\\\\') ? '\\\\' : ''}`,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn Uri.file(repoPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t}\n\n\t\t\t\treturn Uri.file(normalizePath(uri.fsPath));\n\t\t\t}\n\n\t\t\t// Check if we are a symlink and if so, use the symlink path (not its resolved path)\n\t\t\t// This is because VS Code will provide document Uris using the symlinked path\n\t\t\tconst canonicalUri = this.toCanonicalMap.get(repoPath);\n\t\t\tif (canonicalUri == null) {\n\t\t\t\tlet symlink;\n\t\t\t\t[repoPath, symlink] = await new Promise<[string, string | undefined]>(resolve => {\n\t\t\t\t\trealpath(uri.fsPath, { encoding: 'utf8' }, (err, resolvedPath) => {\n\t\t\t\t\t\tif (err != null) {\n\t\t\t\t\t\t\tLogger.debug(scope, `fs.realpath failed; repoPath=${repoPath}`);\n\t\t\t\t\t\t\tresolve([repoPath!, undefined]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (equalsIgnoreCase(uri.fsPath, resolvedPath)) {\n\t\t\t\t\t\t\tLogger.debug(scope, `No symlink detected; repoPath=${repoPath}`);\n\t\t\t\t\t\t\tresolve([repoPath!, undefined]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet linkPath = normalizePath(resolvedPath);\n\t\t\t\t\t\tconst index = commonBaseIndex(`${repoPath}/`, `${linkPath}/`, '/');\n\t\t\t\t\t\tconst uriPath = normalizePath(uri.fsPath);\n\t\t\t\t\t\tif (index < linkPath.length - 1) {\n\t\t\t\t\t\t\tlinkPath = uriPath.substring(0, uriPath.length - (linkPath.length - index));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlinkPath = uriPath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLogger.debug(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t`Symlink detected; repoPath=${repoPath}, path=${uri.fsPath}, resolvedPath=${resolvedPath}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve([repoPath!, linkPath]);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// If we found a symlink, keep track of the mappings\n\t\t\t\tif (symlink != null) {\n\t\t\t\t\tthis.toCanonicalMap.set(repoPath, Uri.file(symlink));\n\t\t\t\t\tthis.fromCanonicalMap.set(symlink, Uri.file(repoPath));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn repoPath ? Uri.file(repoPath) : undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getAheadBehindCommitCount']>({ args: { 1: refs => refs.join(',') } })\n\tgetAheadBehindCommitCount(\n\t\trepoPath: string,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\treturn this.git.rev_list__left_right(repoPath, refs);\n\t}\n\n\t@gate<LocalGitProvider['getBlame']>((u, d) => `${u.toString()}|${d?.isDirty}`)\n\t@log<LocalGitProvider['getBlame']>({ args: { 1: d => d?.isDirty } })\n\tasync getBlame(uri: GitUri, document?: TextDocument | undefined): Promise<GitBlame | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tif (document?.isDirty) return this.getBlameContents(uri, document.getText());\n\n\t\tlet key = 'blame';\n\t\tif (uri.sha != null) {\n\t\t\tkey += `:${uri.sha}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(document ?? uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedBlame = doc.state.getBlame(key);\n\t\t\t\tif (cachedBlame != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedBlame.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getBlameCore(uri, doc, key, scope);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedBlame = {\n\t\t\t\titem: promise as Promise<GitBlame>,\n\t\t\t};\n\t\t\tdoc.state.setBlame(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getBlameCore(\n\t\turi: GitUri,\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitBlame | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(uri);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${uri.fsPath}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame(root, relativePath, uri.sha, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\treturn blame;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected blame errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedBlame = {\n\t\t\t\t\titem: emptyPromise as Promise<GitBlame>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setBlame(key, value);\n\n\t\t\t\tdocument.setBlameFailure();\n\n\t\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getBlameContents']>({ args: { 1: '<contents>' } })\n\tasync getBlameContents(uri: GitUri, contents: string): Promise<GitBlame | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst key = `blame:${md5(contents)}`;\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedBlame = doc.state.getBlame(key);\n\t\t\t\tif (cachedBlame != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: ${key}`);\n\t\t\t\t\treturn cachedBlame.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: ${key}`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getBlameContentsCore(uri, contents, doc, key, scope);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedBlame = {\n\t\t\t\titem: promise as Promise<GitBlame>,\n\t\t\t};\n\t\t\tdoc.state.setBlame(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getBlameContentsCore(\n\t\turi: GitUri,\n\t\tcontents: string,\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitBlame | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(uri);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${uri.fsPath}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame__contents(root, relativePath, contents, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tcorrelationKey: `:${key}`,\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\treturn blame;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected blame errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedBlame = {\n\t\t\t\t\titem: emptyPromise as Promise<GitBlame>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setBlame(key, value);\n\n\t\t\t\tdocument.setBlameFailure();\n\t\t\t\treturn emptyPromise as Promise<GitBlame>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@gate<LocalGitProvider['getBlameForLine']>(\n\t\t(u, l, d, o) => `${u.toString()}|${l}|${d?.isDirty}|${o?.forceSingleLine}`,\n\t)\n\t@log<LocalGitProvider['getBlameForLine']>({ args: { 2: d => d?.isDirty } })\n\tasync getBlameForLine(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tdocument?: TextDocument | undefined,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tif (document?.isDirty) return this.getBlameForLineContents(uri, editorLine, document.getText(), options);\n\n\t\tif (!options?.forceSingleLine && this.useCaching) {\n\t\t\tconst blame = await this.getBlame(uri, document);\n\t\t\tif (blame == null) return undefined;\n\n\t\t\tlet blameLine = blame.lines[editorLine];\n\t\t\tif (blameLine == null) {\n\t\t\t\tif (blame.lines.length !== editorLine) return undefined;\n\t\t\t\tblameLine = blame.lines[editorLine - 1];\n\t\t\t}\n\n\t\t\tconst commit = blame.commits.get(blameLine.sha);\n\t\t\tif (commit == null) return undefined;\n\n\t\t\tconst author = blame.authors.get(commit.author.name)!;\n\t\t\treturn {\n\t\t\t\tauthor: { ...author, lineCount: commit.lines.length },\n\t\t\t\tcommit: commit,\n\t\t\t\tline: blameLine,\n\t\t\t};\n\t\t}\n\n\t\tconst lineToBlame = editorLine + 1;\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame(root, relativePath, uri.sha, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t\tstartLine: lineToBlame,\n\t\t\t\tendLine: lineToBlame,\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\tif (blame == null) return undefined;\n\n\t\t\treturn {\n\t\t\t\tauthor: first(blame.authors.values())!,\n\t\t\t\tcommit: first(blame.commits.values())!,\n\t\t\t\tline: blame.lines[editorLine],\n\t\t\t};\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getBlameForLineContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForLineContents(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tcontents: string,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tif (!options?.forceSingleLine && this.useCaching) {\n\t\t\tconst blame = await this.getBlameContents(uri, contents);\n\t\t\tif (blame == null) return undefined;\n\n\t\t\tlet blameLine = blame.lines[editorLine];\n\t\t\tif (blameLine == null) {\n\t\t\t\tif (blame.lines.length !== editorLine) return undefined;\n\t\t\t\tblameLine = blame.lines[editorLine - 1];\n\t\t\t}\n\n\t\t\tconst commit = blame.commits.get(blameLine.sha);\n\t\t\tif (commit == null) return undefined;\n\n\t\t\tconst author = blame.authors.get(commit.author.name)!;\n\t\t\treturn {\n\t\t\t\tauthor: { ...author, lineCount: commit.lines.length },\n\t\t\t\tcommit: commit,\n\t\t\t\tline: blameLine,\n\t\t\t};\n\t\t}\n\n\t\tconst lineToBlame = editorLine + 1;\n\t\tconst [relativePath, root] = splitPath(uri, uri.repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.blame__contents(root, relativePath, contents, {\n\t\t\t\targs: configuration.get('advanced.blame.customArguments'),\n\t\t\t\tignoreWhitespace: configuration.get('blame.ignoreWhitespace'),\n\t\t\t\tstartLine: lineToBlame,\n\t\t\t\tendLine: lineToBlame,\n\t\t\t});\n\t\t\tconst blame = GitBlameParser.parse(this.container, data, root, await this.getCurrentUser(root));\n\t\t\tif (blame == null) return undefined;\n\n\t\t\treturn {\n\t\t\t\tauthor: first(blame.authors.values())!,\n\t\t\t\tcommit: first(blame.commits.values())!,\n\t\t\t\tline: blame.lines[editorLine],\n\t\t\t};\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getBlameForRange(uri: GitUri, range: Range): Promise<GitBlameLines | undefined> {\n\t\tconst blame = await this.getBlame(uri);\n\t\tif (blame == null) return undefined;\n\n\t\treturn this.getBlameRange(blame, uri, range);\n\t}\n\n\t@log<LocalGitProvider['getBlameForRangeContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForRangeContents(uri: GitUri, range: Range, contents: string): Promise<GitBlameLines | undefined> {\n\t\tconst blame = await this.getBlameContents(uri, contents);\n\t\tif (blame == null) return undefined;\n\n\t\treturn this.getBlameRange(blame, uri, range);\n\t}\n\n\t@log<LocalGitProvider['getBlameRange']>({ args: { 0: '<blame>' } })\n\tgetBlameRange(blame: GitBlame, uri: GitUri, range: Range): GitBlameLines | undefined {\n\t\tif (blame.lines.length === 0) return { allLines: blame.lines, ...blame };\n\n\t\tif (range.start.line === 0 && range.end.line === blame.lines.length - 1) {\n\t\t\treturn { allLines: blame.lines, ...blame };\n\t\t}\n\n\t\tconst lines = blame.lines.slice(range.start.line, range.end.line + 1);\n\t\tconst shas = new Set(lines.map(l => l.sha));\n\n\t\t// ranges are 0-based\n\t\tconst startLine = range.start.line + 1;\n\t\tconst endLine = range.end.line + 1;\n\n\t\tconst authors = new Map<string, GitBlameAuthor>();\n\t\tconst commits = new Map<string, GitCommit>();\n\t\tfor (const c of blame.commits.values()) {\n\t\t\tif (!shas.has(c.sha)) continue;\n\n\t\t\tconst commit = c.with({\n\t\t\t\tlines: c.lines.filter(l => l.line >= startLine && l.line <= endLine),\n\t\t\t});\n\t\t\tcommits.set(c.sha, commit);\n\n\t\t\tlet author = authors.get(commit.author.name);\n\t\t\tif (author == null) {\n\t\t\t\tauthor = {\n\t\t\t\t\tname: commit.author.name,\n\t\t\t\t\tlineCount: 0,\n\t\t\t\t};\n\t\t\t\tauthors.set(author.name, author);\n\t\t\t}\n\n\t\t\tauthor.lineCount += commit.lines.length;\n\t\t}\n\n\t\tconst sortedAuthors = new Map([...authors.entries()].sort((a, b) => b[1].lineCount - a[1].lineCount));\n\n\t\treturn {\n\t\t\trepoPath: uri.repoPath!,\n\t\t\tauthors: sortedAuthors,\n\t\t\tcommits: commits,\n\t\t\tlines: lines,\n\t\t\tallLines: blame.lines,\n\t\t};\n\t}\n\n\t@log()\n\tasync getBranch(repoPath: string): Promise<GitBranch | undefined> {\n\t\tlet {\n\t\t\tvalues: [branch],\n\t\t} = await this.getBranches(repoPath, { filter: b => b.current });\n\t\tif (branch != null) return branch;\n\n\t\tconst commitOrdering = configuration.get('advanced.commitOrdering');\n\n\t\tconst data = await this.git.rev_parse__currentBranch(repoPath, commitOrdering);\n\t\tif (data == null) return undefined;\n\n\t\tconst [name, upstream] = data[0].split('\\n');\n\t\tif (isDetachedHead(name)) {\n\t\t\tconst [rebaseStatus, committerDate] = await Promise.all([\n\t\t\t\tthis.getRebaseStatus(repoPath),\n\n\t\t\t\tthis.git.log__recent_committerdate(repoPath, commitOrdering),\n\t\t\t]);\n\n\t\t\tbranch = new GitBranch(\n\t\t\t\trepoPath,\n\t\t\t\trebaseStatus?.incoming.name ?? name,\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\tcommitterDate != null ? new Date(Number(committerDate) * 1000) : undefined,\n\t\t\t\tdata[1],\n\t\t\t\tupstream ? { name: upstream, missing: false } : undefined,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\trebaseStatus != null,\n\t\t\t);\n\t\t}\n\n\t\treturn branch;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getBranches(\n\t\trepoPath: string | undefined,\n\t\toptions?: {\n\t\t\tcursor?: string;\n\t\t\tfilter?: (b: GitBranch) => boolean;\n\t\t\tsort?: boolean | BranchSortOptions;\n\t\t},\n\t): Promise<PagedResult<GitBranch>> {\n\t\tif (repoPath == null) return emptyPagedResult;\n\n\t\tlet resultsPromise = this.useCaching ? this._branchesCache.get(repoPath) : undefined;\n\t\tif (resultsPromise == null) {\n\t\t\tasync function load(this: LocalGitProvider): Promise<PagedResult<GitBranch>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.git.for_each_ref__branch(repoPath!, { all: true });\n\t\t\t\t\t// If we don't get any data, assume the repo doesn't have any commits yet so check if we have a current branch\n\t\t\t\t\tif (data == null || data.length === 0) {\n\t\t\t\t\t\tlet current;\n\n\t\t\t\t\t\tconst commitOrdering = configuration.get('advanced.commitOrdering');\n\n\t\t\t\t\t\tconst data = await this.git.rev_parse__currentBranch(repoPath!, commitOrdering);\n\t\t\t\t\t\tif (data != null) {\n\t\t\t\t\t\t\tconst [name, upstream] = data[0].split('\\n');\n\t\t\t\t\t\t\tconst [rebaseStatus, committerDate] = await Promise.all([\n\t\t\t\t\t\t\t\tisDetachedHead(name) ? this.getRebaseStatus(repoPath!) : undefined,\n\t\t\t\t\t\t\t\tthis.git.log__recent_committerdate(repoPath!, commitOrdering),\n\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\tcurrent = new GitBranch(\n\t\t\t\t\t\t\t\trepoPath!,\n\t\t\t\t\t\t\t\trebaseStatus?.incoming.name ?? name,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tcommitterDate != null ? new Date(Number(committerDate) * 1000) : undefined,\n\t\t\t\t\t\t\t\tdata[1],\n\t\t\t\t\t\t\t\t{ name: upstream, missing: false },\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\trebaseStatus != null,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn current != null ? { values: [current] } : emptyPagedResult;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { values: GitBranchParser.parse(data, repoPath!) };\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._branchesCache.delete(repoPath!);\n\n\t\t\t\t\treturn emptyPagedResult;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresultsPromise = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tif (options?.cursor == null) {\n\t\t\t\t\tthis._branchesCache.set(repoPath, resultsPromise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet result = await resultsPromise;\n\t\tif (options?.filter != null) {\n\t\t\tresult = {\n\t\t\t\t...result,\n\t\t\t\tvalues: result.values.filter(options.filter),\n\t\t\t};\n\t\t}\n\n\t\tif (options?.sort) {\n\t\t\tsortBranches(result.values, typeof options.sort === 'boolean' ? undefined : options.sort);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@log()\n\tasync getChangedFilesCount(repoPath: string, ref?: string): Promise<GitDiffShortStat | undefined> {\n\t\tconst data = await this.git.diff__shortstat(repoPath, ref);\n\t\tif (!data) return undefined;\n\n\t\treturn GitDiffParser.parseShortStat(data);\n\t}\n\n\t@log()\n\tasync getCommit(repoPath: string, ref: string): Promise<GitCommit | undefined> {\n\t\tconst log = await this.getLog(repoPath, { limit: 2, ref: ref });\n\t\tif (log == null) return undefined;\n\n\t\treturn log.commits.get(ref) ?? first(log.commits.values());\n\t}\n\n\t@log()\n\tasync getCommitBranches(\n\t\trepoPath: string,\n\t\tref: string,\n\t\toptions?: { branch?: string; commitDate?: Date; mode?: 'contains' | 'pointsAt'; remotes?: boolean },\n\t): Promise<string[]> {\n\t\tif (options?.branch) {\n\t\t\tconst data = await this.git.branch__containsOrPointsAt(repoPath, ref, {\n\t\t\t\tmode: 'contains',\n\t\t\t\tname: options.branch,\n\t\t\t});\n\t\t\tif (!data) return [];\n\n\t\t\treturn [data?.trim()];\n\t\t}\n\n\t\tconst data = await this.git.branch__containsOrPointsAt(repoPath, ref, options);\n\t\tif (!data) return [];\n\n\t\treturn filterMap(data.split('\\n'), b => b.trim() || undefined);\n\t}\n\n\t@log()\n\tgetCommitCount(repoPath: string, ref: string): Promise<number | undefined> {\n\t\treturn this.git.rev_list__count(repoPath, ref);\n\t}\n\n\t@log()\n\tasync getCommitForFile(\n\t\trepoPath: string | undefined,\n\t\turi: Uri,\n\t\toptions?: { ref?: string; firstIfNotFound?: boolean; range?: Range },\n\t): Promise<GitCommit | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\ttry {\n\t\t\tconst log = await this.getLogForFile(root, relativePath, {\n\t\t\t\tlimit: 2,\n\t\t\t\tref: options?.ref,\n\t\t\t\trange: options?.range,\n\t\t\t});\n\t\t\tif (log == null) return undefined;\n\n\t\t\tlet commit;\n\t\t\tif (options?.ref) {\n\t\t\t\tconst commit = log.commits.get(options.ref);\n\t\t\t\tif (commit == null && !options?.firstIfNotFound) {\n\t\t\t\t\t// If the ref isn't a valid sha we will never find it, so let it fall through so we return the first\n\t\t\t\t\tif (isSha(options.ref) || isUncommitted(options.ref)) return undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn commit ?? first(log.commits.values());\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getCommitsForGraph(\n\t\trepoPath: string,\n\t\tasWebviewUri: (uri: Uri) => Uri,\n\t\toptions?: {\n\t\t\tbranch?: string;\n\t\t\tinclude?: { stats?: boolean };\n\t\t\tlimit?: number;\n\t\t\tref?: string;\n\t\t},\n\t): Promise<GitGraph> {\n\t\tconst parser = getGraphParser(options?.include?.stats);\n\t\tconst refParser = getRefParser();\n\n\t\tconst defaultLimit = options?.limit ?? configuration.get('graph.defaultItemLimit') ?? 5000;\n\t\tconst defaultPageLimit = configuration.get('graph.pageItemLimit') ?? 1000;\n\t\tconst ordering = configuration.get('graph.commitOrdering', undefined, 'date');\n\n\t\tconst [refResult, stashResult, branchesResult, remotesResult, currentUserResult] = await Promise.allSettled([\n\t\t\tthis.git.log2(repoPath, undefined, ...refParser.arguments, '-n1', options?.ref ?? 'HEAD'),\n\t\t\tthis.getStash(repoPath),\n\t\t\tthis.getBranches(repoPath),\n\t\t\tthis.getRemotes(repoPath),\n\t\t\tthis.getCurrentUser(repoPath),\n\t\t]);\n\n\t\tconst branches = getSettledValue(branchesResult)?.values;\n\t\tconst branchMap = branches != null ? new Map(branches.map(r => [r.name, r])) : new Map<string, GitBranch>();\n\t\tconst headBranch = branches?.find(b => b.current);\n\t\tconst headRefUpstreamName = headBranch?.upstream?.name;\n\n\t\tconst currentUser = getSettledValue(currentUserResult);\n\n\t\tconst remotes = getSettledValue(remotesResult);\n\t\tconst remoteMap = remotes != null ? new Map(remotes.map(r => [r.name, r])) : new Map<string, GitRemote>();\n\t\tconst selectSha = first(refParser.parse(getSettledValue(refResult) ?? ''));\n\n\t\tconst downstreamMap = new Map<string, string[]>();\n\n\t\tlet stdin: string | undefined;\n\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\tconst stash = getSettledValue(stashResult);\n\t\tif (stash != null && stash.commits.size !== 0) {\n\t\t\tstdin = join(\n\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t'\\n',\n\t\t\t);\n\t\t}\n\n\t\tconst useAvatars = configuration.get('graph.avatars', undefined, true);\n\n\t\tconst avatars = new Map<string, string>();\n\t\tconst ids = new Set<string>();\n\t\tconst reachableFromHEAD = new Set<string>();\n\t\tconst remappedIds = new Map<string, string>();\n\t\tlet total = 0;\n\t\tlet iterations = 0;\n\n\t\tasync function getCommitsForGraphCore(\n\t\t\tthis: LocalGitProvider,\n\t\t\tlimit: number,\n\t\t\tsha?: string,\n\t\t\tcursor?: { sha: string; skip: number },\n\t\t): Promise<GitGraph> {\n\t\t\titerations++;\n\n\t\t\tlet log: string | string[] | undefined;\n\t\t\tlet nextPageLimit = limit;\n\t\t\tlet size;\n\n\t\t\tdo {\n\t\t\t\tconst args = [...parser.arguments, `--${ordering}-order`, '--all'];\n\t\t\t\tif (cursor?.skip) {\n\t\t\t\t\targs.push(`--skip=${cursor.skip}`);\n\t\t\t\t}\n\n\t\t\t\tlet data;\n\t\t\t\tif (sha) {\n\t\t\t\t\t[data, limit] = await this.git.logStreamTo(\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\tsha,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\tstdin ? { stdin: stdin } : undefined,\n\t\t\t\t\t\t...args,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(`-n${nextPageLimit + 1}`);\n\n\t\t\t\t\tdata = await this.git.log2(repoPath, stdin ? { stdin: stdin } : undefined, ...args);\n\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tif (!getShaInLogRegex(cursor.sha).test(data)) {\n\t\t\t\t\t\t\t// If we didn't find any new commits, we must have them all so return that we have everything\n\t\t\t\t\t\t\tif (size === data.length) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\t\t\t\tavatars: avatars,\n\t\t\t\t\t\t\t\t\tids: ids,\n\t\t\t\t\t\t\t\t\tincludes: options?.include,\n\t\t\t\t\t\t\t\t\tbranches: branchMap,\n\t\t\t\t\t\t\t\t\tremotes: remoteMap,\n\t\t\t\t\t\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\t\t\t\t\t\trows: [],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsize = data.length;\n\t\t\t\t\t\t\tnextPageLimit = (nextPageLimit === 0 ? defaultPageLimit : nextPageLimit) * 2;\n\t\t\t\t\t\t\tcursor.skip -= Math.floor(cursor.skip * 0.1);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\tavatars: avatars,\n\t\t\t\t\t\tids: ids,\n\t\t\t\t\t\tincludes: options?.include,\n\t\t\t\t\t\tbranches: branchMap,\n\t\t\t\t\t\tremotes: remoteMap,\n\t\t\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlog = data;\n\t\t\t\tif (limit !== 0) {\n\t\t\t\t\tlimit = nextPageLimit;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t} while (true);\n\n\t\t\tconst rows: GitGraphRow[] = [];\n\n\t\t\tlet avatarUri: Uri | undefined;\n\t\t\tlet avatarUrl: string | undefined;\n\t\t\tlet branch: GitBranch | undefined;\n\t\t\tlet branchId: string;\n\t\t\tlet branchName: string;\n\t\t\tlet context:\n\t\t\t\t| GraphItemRefContext<GraphBranchContextValue>\n\t\t\t\t| GraphItemRefContext<GraphTagContextValue>\n\t\t\t\t| undefined;\n\t\t\tlet contexts: GitGraphRowContexts | undefined;\n\t\t\tlet group;\n\t\t\tlet groupName;\n\t\t\tconst groupedRefs = new Map<\n\t\t\t\tstring,\n\t\t\t\t{ head?: boolean; local?: GitBranchReference; remotes?: GitBranchReference[] }\n\t\t\t>();\n\t\t\tlet head = false;\n\t\t\tlet isCurrentUser = false;\n\t\t\tlet refHead: GitGraphRowHead;\n\t\t\tlet refHeads: GitGraphRowHead[];\n\t\t\tlet refRemoteHead: GitGraphRowRemoteHead;\n\t\t\tlet refRemoteHeads: GitGraphRowRemoteHead[];\n\t\t\tlet refTag: GitGraphRowTag;\n\t\t\tlet refTags: GitGraphRowTag[];\n\t\t\tlet parent: string;\n\t\t\tlet parents: string[];\n\t\t\tlet remote: GitRemote | undefined;\n\t\t\tlet remoteBranchId: string;\n\t\t\tlet remoteName: string;\n\t\t\tlet stashCommit: GitStashCommit | undefined;\n\t\t\tlet tagId: string;\n\t\t\tlet tagName: string;\n\t\t\tlet tip: string;\n\n\t\t\tlet count = 0;\n\n\t\t\tconst commits = parser.parse(log);\n\t\t\tfor (const commit of commits) {\n\t\t\t\tcount++;\n\t\t\t\tif (ids.has(commit.sha)) continue;\n\n\t\t\t\ttotal++;\n\t\t\t\tif (remappedIds.has(commit.sha)) continue;\n\n\t\t\t\tids.add(commit.sha);\n\n\t\t\t\trefHeads = [];\n\t\t\t\trefRemoteHeads = [];\n\t\t\t\trefTags = [];\n\t\t\t\tcontexts = {};\n\t\t\t\thead = false;\n\n\t\t\t\tif (commit.tips) {\n\t\t\t\t\tgroupedRefs.clear();\n\n\t\t\t\t\tfor (tip of commit.tips.split(', ')) {\n\t\t\t\t\t\tif (tip === 'refs/stash') continue;\n\n\t\t\t\t\t\tif (tip.startsWith('tag: ')) {\n\t\t\t\t\t\t\ttagName = tip.substring(5);\n\t\t\t\t\t\t\ttagId = getTagId(repoPath, tagName);\n\t\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\t\twebviewItem: 'gitlens:tag',\n\t\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\t\ttype: 'tag',\n\t\t\t\t\t\t\t\t\tref: createReference(tagName, repoPath, {\n\t\t\t\t\t\t\t\t\t\tid: tagId,\n\t\t\t\t\t\t\t\t\t\trefType: 'tag',\n\t\t\t\t\t\t\t\t\t\tname: tagName,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\trefTag = {\n\t\t\t\t\t\t\t\tid: tagId,\n\t\t\t\t\t\t\t\tname: tagName,\n\t\t\t\t\t\t\t\t// Not currently used, so don't bother looking it up\n\t\t\t\t\t\t\t\tannotated: true,\n\t\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\trefTags.push(refTag);\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thead = tip.startsWith('HEAD');\n\t\t\t\t\t\tif (head) {\n\t\t\t\t\t\t\treachableFromHEAD.add(commit.sha);\n\n\t\t\t\t\t\t\tif (tip !== 'HEAD') {\n\t\t\t\t\t\t\t\ttip = tip.substring(8);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoteName = getRemoteNameFromBranchName(tip);\n\t\t\t\t\t\tif (remoteName) {\n\t\t\t\t\t\t\tremote = remoteMap.get(remoteName);\n\t\t\t\t\t\t\tif (remote != null) {\n\t\t\t\t\t\t\t\tbranchName = getBranchNameWithoutRemote(tip);\n\t\t\t\t\t\t\t\tif (branchName === 'HEAD') continue;\n\n\t\t\t\t\t\t\t\tremoteBranchId = getBranchId(repoPath, true, tip);\n\t\t\t\t\t\t\t\tavatarUrl = (\n\t\t\t\t\t\t\t\t\t(useAvatars ? remote.provider?.avatarUri : undefined) ??\n\t\t\t\t\t\t\t\t\tgetRemoteIconUri(this.container, remote, asWebviewUri)\n\t\t\t\t\t\t\t\t)?.toString(true);\n\t\t\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\t\t\twebviewItem: 'gitlens:branch+remote',\n\t\t\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\t\t\ttype: 'branch',\n\t\t\t\t\t\t\t\t\t\tref: createReference(tip, repoPath, {\n\t\t\t\t\t\t\t\t\t\t\tid: remoteBranchId,\n\t\t\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\t\t\t\t\tremote: true,\n\t\t\t\t\t\t\t\t\t\t\tupstream: { name: remote.name, missing: false },\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\trefRemoteHead = {\n\t\t\t\t\t\t\t\t\tid: remoteBranchId,\n\t\t\t\t\t\t\t\t\tname: branchName,\n\t\t\t\t\t\t\t\t\towner: remote.name,\n\t\t\t\t\t\t\t\t\turl: remote.url,\n\t\t\t\t\t\t\t\t\tavatarUrl: avatarUrl,\n\t\t\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\t\t\tcurrent: tip === headRefUpstreamName,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\trefRemoteHeads.push(refRemoteHead);\n\n\t\t\t\t\t\t\t\tgroup = groupedRefs.get(branchName);\n\t\t\t\t\t\t\t\tif (group == null) {\n\t\t\t\t\t\t\t\t\tgroup = { remotes: [] };\n\t\t\t\t\t\t\t\t\tgroupedRefs.set(branchName, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.remotes == null) {\n\t\t\t\t\t\t\t\t\tgroup.remotes = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgroup.remotes.push(context.webviewItemValue.ref);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbranch = branchMap.get(tip);\n\t\t\t\t\t\tbranchId = branch?.id ?? getBranchId(repoPath, false, tip);\n\t\t\t\t\t\tcontext = {\n\t\t\t\t\t\t\twebviewItem: `gitlens:branch${head ? '+current' : ''}${\n\t\t\t\t\t\t\t\tbranch?.upstream != null ? '+tracking' : ''\n\t\t\t\t\t\t\t}`,\n\t\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\t\ttype: 'branch',\n\t\t\t\t\t\t\t\tref: createReference(tip, repoPath, {\n\t\t\t\t\t\t\t\t\tid: branchId,\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t\t\tupstream: branch?.upstream,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\trefHead = {\n\t\t\t\t\t\t\tid: branchId,\n\t\t\t\t\t\t\tname: tip,\n\t\t\t\t\t\t\tisCurrentHead: head,\n\t\t\t\t\t\t\tcontext: serializeWebviewItemContext<GraphItemRefContext>(context),\n\t\t\t\t\t\t\tupstream:\n\t\t\t\t\t\t\t\tbranch?.upstream != null\n\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\tname: branch.upstream.name,\n\t\t\t\t\t\t\t\t\t\t\tid: getBranchId(repoPath, true, branch.upstream.name),\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t};\n\t\t\t\t\t\trefHeads.push(refHead);\n\t\t\t\t\t\tif (branch?.upstream?.name != null) {\n\t\t\t\t\t\t\t// Add the branch name (tip) to the upstream name entry in the downstreams map\n\t\t\t\t\t\t\tlet downstreams = downstreamMap.get(branch.upstream.name);\n\t\t\t\t\t\t\tif (downstreams == null) {\n\t\t\t\t\t\t\t\tdownstreams = [];\n\t\t\t\t\t\t\t\tdownstreamMap.set(branch.upstream.name, downstreams);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdownstreams.push(tip);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroup = groupedRefs.get(tip);\n\t\t\t\t\t\tif (group == null) {\n\t\t\t\t\t\t\tgroup = {};\n\t\t\t\t\t\t\tgroupedRefs.set(tip, group);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (head) {\n\t\t\t\t\t\t\tgroup.head = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup.local = context.webviewItemValue.ref;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ([groupName, group] of groupedRefs) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgroup.remotes != null &&\n\t\t\t\t\t\t\t((group.local != null && group.remotes.length > 0) || group.remotes.length > 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (contexts.refGroups == null) {\n\t\t\t\t\t\t\t\tcontexts.refGroups = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontexts.refGroups[groupName] = serializeWebviewItemContext<GraphItemRefGroupContext>({\n\t\t\t\t\t\t\t\twebviewItemGroup: `gitlens:refGroup${group.head ? '+current' : ''}`,\n\t\t\t\t\t\t\t\twebviewItemGroupValue: {\n\t\t\t\t\t\t\t\t\ttype: 'refGroup',\n\t\t\t\t\t\t\t\t\trefs: group.local != null ? [group.local, ...group.remotes] : group.remotes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstashCommit = stash?.commits.get(commit.sha);\n\n\t\t\t\tparents = commit.parents ? commit.parents.split(' ') : [];\n\t\t\t\tif (reachableFromHEAD.has(commit.sha)) {\n\t\t\t\t\tfor (parent of parents) {\n\t\t\t\t\t\treachableFromHEAD.add(parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the second & third parent, if exists, from each stash commit as it is a Git implementation for the index and untracked files\n\t\t\t\tif (stashCommit != null && parents.length > 1) {\n\t\t\t\t\t// Remap the \"index commit\" (e.g. contains staged files) of the stash\n\t\t\t\t\tremappedIds.set(parents[1], commit.sha);\n\t\t\t\t\t// Remap the \"untracked commit\" (e.g. contains untracked files) of the stash\n\t\t\t\t\tremappedIds.set(parents[2], commit.sha);\n\t\t\t\t\tparents.splice(1, 2);\n\t\t\t\t}\n\n\t\t\t\tif (stashCommit == null && !avatars.has(commit.authorEmail)) {\n\t\t\t\t\tavatarUri = getCachedAvatarUri(commit.authorEmail);\n\t\t\t\t\tif (avatarUri != null) {\n\t\t\t\t\t\tavatars.set(commit.authorEmail, avatarUri.toString(true));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tisCurrentUser = isUserMatch(currentUser, commit.author, commit.authorEmail);\n\n\t\t\t\tif (stashCommit != null) {\n\t\t\t\t\tcontexts.row = serializeWebviewItemContext<GraphItemRefContext>({\n\t\t\t\t\t\twebviewItem: 'gitlens:stash',\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'stash',\n\t\t\t\t\t\t\tref: createReference(commit.sha, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'stash',\n\t\t\t\t\t\t\t\tname: stashCommit.name,\n\t\t\t\t\t\t\t\tnumber: stashCommit.number,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontexts.row = serializeWebviewItemContext<GraphItemRefContext>({\n\t\t\t\t\t\twebviewItem: `gitlens:commit${head ? '+HEAD' : ''}${\n\t\t\t\t\t\t\treachableFromHEAD.has(commit.sha) ? '+current' : ''\n\t\t\t\t\t\t}`,\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'commit',\n\t\t\t\t\t\t\tref: createReference(commit.sha, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'revision',\n\t\t\t\t\t\t\t\tmessage: commit.message,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tcontexts.avatar = serializeWebviewItemContext<GraphItemContext>({\n\t\t\t\t\t\twebviewItem: `gitlens:contributor${isCurrentUser ? '+current' : ''}`,\n\t\t\t\t\t\twebviewItemValue: {\n\t\t\t\t\t\t\ttype: 'contributor',\n\t\t\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\t\t\tname: commit.author,\n\t\t\t\t\t\t\temail: commit.authorEmail,\n\t\t\t\t\t\t\tcurrent: isCurrentUser,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\trows.push({\n\t\t\t\t\tsha: commit.sha,\n\t\t\t\t\tparents: parents,\n\t\t\t\t\tauthor: isCurrentUser ? 'You' : commit.author,\n\t\t\t\t\temail: commit.authorEmail,\n\t\t\t\t\tdate: Number(ordering === 'author-date' ? commit.authorDate : commit.committerDate) * 1000,\n\t\t\t\t\tmessage: emojify(commit.message.trim()),\n\t\t\t\t\t// TODO: review logic for stash, wip, etc\n\t\t\t\t\ttype:\n\t\t\t\t\t\tstashCommit != null\n\t\t\t\t\t\t\t? GitGraphRowType.Stash\n\t\t\t\t\t\t\t: parents.length > 1\n\t\t\t\t\t\t\t? GitGraphRowType.MergeCommit\n\t\t\t\t\t\t\t: GitGraphRowType.Commit,\n\t\t\t\t\theads: refHeads,\n\t\t\t\t\tremotes: refRemoteHeads,\n\t\t\t\t\ttags: refTags,\n\t\t\t\t\tcontexts: contexts,\n\t\t\t\t\tstats: commit.stats,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst startingCursor = cursor?.sha;\n\t\t\tconst lastSha = last(ids);\n\t\t\tcursor =\n\t\t\t\tlastSha != null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsha: lastSha,\n\t\t\t\t\t\t\tskip: total - iterations,\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined;\n\n\t\t\treturn {\n\t\t\t\trepoPath: repoPath,\n\t\t\t\tavatars: avatars,\n\t\t\t\tids: ids,\n\t\t\t\tincludes: options?.include,\n\t\t\t\tremappedIds: remappedIds,\n\t\t\t\tbranches: branchMap,\n\t\t\t\tremotes: remoteMap,\n\t\t\t\tdownstreams: downstreamMap,\n\t\t\t\trows: rows,\n\t\t\t\tid: sha,\n\n\t\t\t\tpaging: {\n\t\t\t\t\tlimit: limit === 0 ? count : limit,\n\t\t\t\t\tstartingCursor: startingCursor,\n\t\t\t\t\thasMore: limit !== 0 && count > limit,\n\t\t\t\t},\n\t\t\t\tmore: async (limit: number, sha?: string): Promise<GitGraph | undefined> =>\n\t\t\t\t\tgetCommitsForGraphCore.call(this, limit, sha, cursor),\n\t\t\t};\n\t\t}\n\n\t\treturn getCommitsForGraphCore.call(this, defaultLimit, selectSha);\n\t}\n\n\tgetConfig(repoPath: string, key: string): Promise<string | undefined> {\n\t\treturn this.git.config__get(key, repoPath);\n\t}\n\n\tsetConfig(repoPath: string, key: string, value: string | undefined): Promise<void> {\n\t\treturn this.git.config__set(key, value, repoPath);\n\t}\n\n\t@log()\n\tasync getContributors(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; ref?: string; stats?: boolean },\n\t): Promise<GitContributor[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst key = options?.stats ? `stats|${repoPath}` : repoPath;\n\n\t\tlet contributors = this.useCaching ? this._contributorsCache.get(key) : undefined;\n\t\tif (contributors == null) {\n\t\t\tasync function load(this: LocalGitProvider) {\n\t\t\t\ttry {\n\t\t\t\t\trepoPath = normalizePath(repoPath);\n\t\t\t\t\tconst currentUser = await this.getCurrentUser(repoPath);\n\t\t\t\t\tconst parser = getContributorsParser(options?.stats);\n\n\t\t\t\t\tconst data = await this.git.log(repoPath, options?.ref, {\n\t\t\t\t\t\tall: options?.all,\n\t\t\t\t\t\targsOrFormat: parser.arguments,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst contributors = new Map<string, GitContributor>();\n\n\t\t\t\t\tconst commits = parser.parse(data);\n\t\t\t\t\tfor (const c of commits) {\n\t\t\t\t\t\tconst key = `${c.author}|${c.email}`;\n\t\t\t\t\t\tlet contributor = contributors.get(key);\n\t\t\t\t\t\tif (contributor == null) {\n\t\t\t\t\t\t\tcontributor = new GitContributor(\n\t\t\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\t\t\tc.author,\n\t\t\t\t\t\t\t\tc.email,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tnew Date(Number(c.date) * 1000),\n\t\t\t\t\t\t\t\tisUserMatch(currentUser, c.author, c.email),\n\t\t\t\t\t\t\t\tc.stats,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontributors.set(key, contributor);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(contributor as PickMutable<GitContributor, 'count'>).count++;\n\t\t\t\t\t\t\tconst date = new Date(Number(c.date) * 1000);\n\t\t\t\t\t\t\tif (date > contributor.date!) {\n\t\t\t\t\t\t\t\t(contributor as PickMutable<GitContributor, 'date'>).date = date;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [...contributors.values()];\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._contributorsCache.delete(key);\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontributors = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._contributorsCache.set(key, contributors);\n\t\t\t}\n\t\t}\n\n\t\treturn contributors;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getCurrentUser(repoPath: string): Promise<GitUser | undefined> {\n\t\tif (!repoPath) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tconst repo = this._repoInfoCache.get(repoPath);\n\n\t\tlet user = repo?.user;\n\t\tif (user != null) return user;\n\t\t// If we found the repo, but no user data was found just return\n\t\tif (user === null) return undefined;\n\n\t\tuser = { name: undefined, email: undefined };\n\n\t\ttry {\n\t\t\tconst data = await this.git.config__get_regex('^user\\\\.', repoPath, { local: true });\n\t\t\tif (data) {\n\t\t\t\tlet key: string;\n\t\t\t\tlet value: string;\n\n\t\t\t\tlet match;\n\t\t\t\tdo {\n\t\t\t\t\tmatch = userConfigRegex.exec(data);\n\t\t\t\t\tif (match == null) break;\n\n\t\t\t\t\t[, key, value] = match;\n\t\t\t\t\t// Stops excessive memory usage -- https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\tuser[key as 'name' | 'email'] = ` ${value}`.substr(1);\n\t\t\t\t} while (true);\n\t\t\t} else {\n\t\t\t\tuser.name =\n\t\t\t\t\tprocess_env.GIT_AUTHOR_NAME || process_env.GIT_COMMITTER_NAME || userInfo()?.username || undefined;\n\t\t\t\tif (!user.name) {\n\t\t\t\t\t// If we found no user data, mark it so we won't bother trying again\n\t\t\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: null });\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tuser.email =\n\t\t\t\t\tprocess_env.GIT_AUTHOR_EMAIL ||\n\t\t\t\t\tprocess_env.GIT_COMMITTER_EMAIL ||\n\t\t\t\t\tprocess_env.EMAIL ||\n\t\t\t\t\t`${user.name}@${hostname()}`;\n\t\t\t}\n\n\t\t\tconst author = `${user.name} <${user.email}>`;\n\t\t\t// Check if there is a mailmap for the current user\n\t\t\tconst mappedAuthor = await this.git.check_mailmap(repoPath, author);\n\t\t\tif (mappedAuthor != null && mappedAuthor.length !== 0 && author !== mappedAuthor) {\n\t\t\t\tconst match = mappedAuthorRegex.exec(mappedAuthor);\n\t\t\t\tif (match != null) {\n\t\t\t\t\t[, user.name, user.email] = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: user });\n\t\t\treturn user;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\n\t\t\t// Mark it so we won't bother trying again\n\t\t\tthis._repoInfoCache.set(repoPath, { ...repo, user: null });\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDefaultBranchName(repoPath: string | undefined, remote?: string): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tif (!remote) {\n\t\t\ttry {\n\t\t\t\tconst data = await this.git.symbolic_ref(repoPath, 'HEAD');\n\t\t\t\tif (data != null) return data.trim();\n\t\t\t} catch {}\n\t\t}\n\n\t\tremote = remote ?? 'origin';\n\t\ttry {\n\t\t\tconst data = await this.git.ls_remote__HEAD(repoPath, remote);\n\t\t\tif (data == null) return undefined;\n\n\t\t\tconst match = /ref:\\s(\\S+)\\s+HEAD/m.exec(data);\n\t\t\tif (match == null) return undefined;\n\n\t\t\tconst [, branch] = match;\n\t\t\treturn branch.substr('refs/heads/'.length);\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiff(\n\t\trepoPath: string,\n\t\tref1: string,\n\t\tref2?: string,\n\t\toptions?: { includeRawDiff?: boolean },\n\t): Promise<GitDiff | undefined> {\n\t\tlet data;\n\t\tif (ref1 === uncommitted) {\n\t\t\tif (ref2 == null) {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3');\n\t\t\t} else {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', ref2);\n\t\t\t}\n\t\t} else if (ref1 === uncommittedStaged) {\n\t\t\tif (ref2 == null) {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', '--staged');\n\t\t\t} else {\n\t\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', '--staged', ref2);\n\t\t\t}\n\t\t} else if (ref2 == null) {\n\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', `${ref1}^`, ref1);\n\t\t} else {\n\t\t\tdata = await this.git.diff2(repoPath, undefined, '-U3', ref1, ref2);\n\t\t}\n\n\t\tif (!data) return undefined;\n\n\t\tconst diff = GitDiffParser.parse(data, options?.includeRawDiff);\n\t\treturn diff;\n\t}\n\n\t@log()\n\tasync getDiffForFile(uri: GitUri, ref1: string | undefined, ref2?: string): Promise<GitDiff | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tlet key = 'diff';\n\t\tif (ref1 != null) {\n\t\t\tkey += `:${ref1}`;\n\t\t}\n\t\tif (ref2 != null) {\n\t\t\tkey += `:${ref2}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedDiff = doc.state.getDiff(key);\n\t\t\t\tif (cachedDiff != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedDiff.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst encoding = await getEncoding(uri);\n\t\tconst promise = this.getDiffForFileCore(\n\t\t\turi.repoPath,\n\t\t\turi.fsPath,\n\t\t\tref1,\n\t\t\tref2,\n\t\t\t{ encoding: encoding },\n\t\t\tdoc,\n\t\t\tkey,\n\t\t\tscope,\n\t\t);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedDiff = {\n\t\t\t\titem: promise as Promise<GitDiff>,\n\t\t\t};\n\t\t\tdoc.state.setDiff(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getDiffForFileCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\tref1: string | undefined,\n\t\tref2: string | undefined,\n\t\toptions: { encoding?: string },\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitDiff | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.diff(root, relativePath, ref1, ref2, {\n\t\t\t\t...options,\n\t\t\t\tfilters: ['M'],\n\t\t\t\tlinesOfContext: 0,\n\t\t\t\trenames: true,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst diff = GitDiffParser.parse(data);\n\t\t\treturn diff;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected diff errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedDiff = {\n\t\t\t\t\titem: emptyPromise as Promise<GitDiff>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setDiff(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitDiff>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log<LocalGitProvider['getDiffForFileContents']>({ args: { 1: '<contents>' } })\n\tasync getDiffForFileContents(uri: GitUri, ref: string, contents: string): Promise<GitDiff | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst key = `diff:${md5(contents)}`;\n\n\t\tconst doc = await this.container.tracker.getOrAdd(uri);\n\t\tif (this.useCaching) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedDiff = doc.state.getDiff(key);\n\t\t\t\tif (cachedDiff != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: ${key}`);\n\t\t\t\t\treturn cachedDiff.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: ${key}`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst encoding = await getEncoding(uri);\n\t\tconst promise = this.getDiffForFileContentsCore(\n\t\t\turi.repoPath,\n\t\t\turi.fsPath,\n\t\t\tref,\n\t\t\tcontents,\n\t\t\t{ encoding: encoding },\n\t\t\tdoc,\n\t\t\tkey,\n\t\t\tscope,\n\t\t);\n\n\t\tif (doc.state != null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedDiff = {\n\t\t\t\titem: promise as Promise<GitDiff>,\n\t\t\t};\n\t\t\tdoc.state.setDiff(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getDiffForFileContentsCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\tref: string,\n\t\tcontents: string,\n\t\toptions: { encoding?: string },\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitDiff | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\ttry {\n\t\t\tconst data = await this.git.diff__contents(root, relativePath, ref, contents, {\n\t\t\t\t...options,\n\t\t\t\tfilters: ['M'],\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst diff = GitDiffParser.parse(data);\n\t\t\treturn diff;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected diff errors\n\t\t\tif (document.state != null) {\n\t\t\t\tconst msg = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedDiff = {\n\t\t\t\t\titem: emptyPromise as Promise<GitDiff>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setDiff(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitDiff>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffForLine(\n\t\turi: GitUri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tref1: string | undefined,\n\t\tref2?: string,\n\t): Promise<GitDiffHunkLine | undefined> {\n\t\ttry {\n\t\t\tconst diff = await this.getDiffForFile(uri, ref1, ref2);\n\t\t\tif (diff == null) return undefined;\n\n\t\t\tconst line = editorLine + 1;\n\t\t\tconst hunk = diff.hunks.find(c => c.current.position.start <= line && c.current.position.end >= line);\n\t\t\tif (hunk == null) return undefined;\n\n\t\t\treturn hunk.lines[line - Math.min(hunk.current.position.start, hunk.previous.position.start)];\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffStatus(\n\t\trepoPath: string,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions?: { filters?: GitDiffFilter[]; similarityThreshold?: number },\n\t): Promise<GitFile[] | undefined> {\n\t\ttry {\n\t\t\tconst data = await this.git.diff__name_status(repoPath, ref1, ref2, {\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t\t...options,\n\t\t\t});\n\t\t\tif (!data) return undefined;\n\n\t\t\tconst files = GitDiffParser.parseNameStatus(data, repoPath);\n\t\t\treturn files == null || files.length === 0 ? undefined : files;\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getFileStatusForCommit(repoPath: string, uri: Uri, ref: string): Promise<GitFile | undefined> {\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return undefined;\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.show__name_status(root, relativePath, ref);\n\t\tif (!data) return undefined;\n\n\t\tconst files = GitDiffParser.parseNameStatus(data, repoPath);\n\t\tif (files == null || files.length === 0) return undefined;\n\n\t\treturn files[0];\n\t}\n\n\t@debug()\n\tasync getGitDir(repoPath: string): Promise<GitDir> {\n\t\tconst repo = this._repoInfoCache.get(repoPath);\n\t\tif (repo?.gitDir != null) return repo.gitDir;\n\n\t\tconst gitDirPaths = await this.git.rev_parse__git_dir(repoPath);\n\n\t\tlet gitDir: GitDir;\n\t\tif (gitDirPaths != null) {\n\t\t\tgitDir = {\n\t\t\t\turi: Uri.file(gitDirPaths.path),\n\t\t\t\tcommonUri: gitDirPaths.commonPath != null ? Uri.file(gitDirPaths.commonPath) : undefined,\n\t\t\t};\n\t\t} else {\n\t\t\tgitDir = {\n\t\t\t\turi: this.getAbsoluteUri('.git', repoPath),\n\t\t\t};\n\t\t}\n\t\tthis._repoInfoCache.set(repoPath, { ...repo, gitDir: gitDir });\n\n\t\treturn gitDir;\n\t}\n\n\t@debug()\n\tasync getLastFetchedTimestamp(repoPath: string): Promise<number | undefined> {\n\t\ttry {\n\t\t\tconst gitDir = await this.getGitDir(repoPath);\n\t\t\tconst stats = await workspace.fs.stat(Uri.joinPath(gitDir.uri, 'FETCH_HEAD'));\n\t\t\t// If the file is empty, assume the fetch failed, and don't update the timestamp\n\t\t\tif (stats.size > 0) return stats.mtime;\n\t\t} catch {}\n\n\t\treturn undefined;\n\t}\n\n\t@log()\n\tasync getLog(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tstatus?: null | 'name-status' | 'numstat' | 'stat';\n\t\t\tsince?: number | string;\n\t\t\tuntil?: number | string;\n\t\t\textraArgs?: string[];\n\t\t\tstdin?: string;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\t\tconst merges = options?.merges == null ? true : options.merges;\n\t\t\tconst ordering = options?.ordering ?? configuration.get('advanced.commitOrdering');\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst args = [\n\t\t\t\t`--format=${options?.all ? GitLogParser.allFormat : GitLogParser.defaultFormat}`,\n\t\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t\t'-m',\n\t\t\t];\n\n\t\t\tif (options?.status !== null) {\n\t\t\t\targs.push(`--${options?.status ?? 'name-status'}`, '--full-history');\n\t\t\t}\n\t\t\tif (options?.all) {\n\t\t\t\targs.push('--all');\n\t\t\t}\n\t\t\tif (!merges) {\n\t\t\t\targs.push('--first-parent');\n\t\t\t}\n\t\t\tif (ordering) {\n\t\t\t\targs.push(`--${ordering}-order`);\n\t\t\t}\n\t\t\tif (options?.authors?.length) {\n\t\t\t\targs.push('--use-mailmap', ...options.authors.map(a => `--author=^${a.name} <${a.email}>$`));\n\t\t\t}\n\n\t\t\tlet hasMoreOverride;\n\n\t\t\tif (options?.since) {\n\t\t\t\thasMoreOverride = true;\n\t\t\t\targs.push(`--since=\"${options.since}\"`);\n\t\t\t}\n\t\t\tif (options?.until) {\n\t\t\t\thasMoreOverride = true;\n\t\t\t\targs.push(`--until=\"${options.until}\"`);\n\t\t\t}\n\t\t\tif (options?.extraArgs?.length) {\n\t\t\t\tif (\n\t\t\t\t\toptions.extraArgs.some(\n\t\t\t\t\t\targ => arg.startsWith('-n') || arg.startsWith('--until=') || arg.startsWith('--since='),\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\thasMoreOverride = true;\n\t\t\t\t}\n\t\t\t\targs.push(...options.extraArgs);\n\t\t\t}\n\n\t\t\tif (limit) {\n\t\t\t\thasMoreOverride = undefined;\n\t\t\t\targs.push(`-n${limit + 1}`);\n\t\t\t}\n\n\t\t\tconst data = await this.git.log2(\n\t\t\t\trepoPath,\n\t\t\t\t{ configs: gitLogDefaultConfigsWithFiles, ref: options?.ref, stdin: options?.stdin },\n\t\t\t\t...args,\n\t\t\t);\n\n\t\t\t// const parser = GitLogParser.defaultParser;\n\n\t\t\t// const data = await this.git.log2(repoPath, options?.ref, {\n\t\t\t// \t...options,\n\t\t\t// \t// args: parser.arguments,\n\t\t\t// \tlimit: limit,\n\t\t\t// \tmerges: options?.merges == null ? true : options.merges,\n\t\t\t// \tordering: options?.ordering ?? configuration.get('advanced.commitOrdering'),\n\t\t\t// \tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t// });\n\n\t\t\t// const commits = [];\n\t\t\t// const entries = parser.parse(data);\n\t\t\t// for (const entry of entries) {\n\t\t\t// \tcommits.push(\n\t\t\t// \t\tnew GitCommit2(\n\t\t\t// \t\t\trepoPath,\n\t\t\t// \t\t\tentry.sha,\n\t\t\t// \t\t\tnew GitCommitIdentity(\n\t\t\t// \t\t\t\tentry.author,\n\t\t\t// \t\t\t\tentry.authorEmail,\n\t\t\t// \t\t\t\tnew Date((entry.authorDate as any) * 1000),\n\t\t\t// \t\t\t),\n\t\t\t// \t\t\tnew GitCommitIdentity(\n\t\t\t// \t\t\t\tentry.committer,\n\t\t\t// \t\t\t\tentry.committerEmail,\n\t\t\t// \t\t\t\tnew Date((entry.committerDate as any) * 1000),\n\t\t\t// \t\t\t),\n\t\t\t// \t\t\tentry.message.split('\\n', 1)[0],\n\t\t\t// \t\t\tentry.parents.split(' '),\n\t\t\t// \t\t\tentry.message,\n\t\t\t// \t\t\tentry.files.map(f => new GitFileChange(repoPath, f.path, f.status as any, f.originalPath)),\n\t\t\t// \t\t\t[],\n\t\t\t// \t\t),\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\tLogType.Log,\n\t\t\t\trepoPath,\n\t\t\t\tundefined,\n\t\t\t\toptions?.ref,\n\t\t\t\tawait this.getCurrentUser(repoPath),\n\t\t\t\tlimit,\n\t\t\t\tfalse,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\thasMoreOverride,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tlog.query = (limit: number | undefined) => this.getLog(repoPath, { ...options, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlet opts;\n\t\t\t\t\tif (options != null) {\n\t\t\t\t\t\tlet extraArgs;\n\t\t\t\t\t\t({ extraArgs, ...opts } = options);\n\t\t\t\t\t}\n\t\t\t\t\tlog.more = this.getLogMoreFn(log, opts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getLogRefsOnly(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tauthors?: GitUser[];\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<Set<string> | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\n\t\ttry {\n\t\t\tconst parser = createLogParserSingle('%H');\n\n\t\t\tconst data = await this.git.log(repoPath, options?.ref, {\n\t\t\t\tauthors: options?.authors,\n\t\t\t\targsOrFormat: parser.arguments,\n\t\t\t\tlimit: limit,\n\t\t\t\tmerges: options?.merges == null ? true : options.merges,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t\tsince: options?.since,\n\t\t\t\tordering: options?.ordering ?? configuration.get('advanced.commitOrdering'),\n\t\t\t});\n\n\t\t\tconst commits = new Set(parser.parse(data));\n\t\t\treturn commits;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\tdebugger;\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getLogMoreFn(\n\t\tlog: GitLog,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t},\n\t): (limit: number | { until: string } | undefined) => Promise<GitLog> {\n\t\treturn async (limit: number | { until: string } | undefined) => {\n\t\t\tconst moreUntil = limit != null && typeof limit === 'object' ? limit.until : undefined;\n\t\t\tlet moreLimit = typeof limit === 'number' ? limit : undefined;\n\n\t\t\tif (moreUntil && some(log.commits.values(), c => c.ref === moreUntil)) {\n\t\t\t\treturn log;\n\t\t\t}\n\n\t\t\tmoreLimit = moreLimit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\t// If the log is for a range, then just get everything prior + more\n\t\t\tif (isRevisionRange(log.sha)) {\n\t\t\t\tconst moreLog = await this.getLog(log.repoPath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tlimit: moreLimit === 0 ? 0 : (options?.limit ?? 0) + moreLimit,\n\t\t\t\t});\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\treturn moreLog;\n\t\t\t}\n\n\t\t\tconst lastCommit = last(log.commits.values());\n\t\t\tconst ref = lastCommit?.ref;\n\n\t\t\t// If we were asked for all refs, use the last commit timestamp (plus a second) as a cursor\n\t\t\tlet timestamp: number | undefined;\n\t\t\tif (options?.all) {\n\t\t\t\tconst date = lastCommit?.committer.date;\n\t\t\t\t// Git only allows 1-second precision, so round up to the nearest second\n\t\t\t\ttimestamp = date != null ? Math.ceil(date.getTime() / 1000) + 1 : undefined;\n\t\t\t}\n\n\t\t\tlet moreLogCount;\n\t\t\tlet queryLimit = moreUntil == null ? moreLimit : 0;\n\t\t\tdo {\n\t\t\t\tconst moreLog = await this.getLog(log.repoPath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tlimit: queryLimit,\n\t\t\t\t\t...(timestamp\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tuntil: timestamp,\n\t\t\t\t\t\t\t\textraArgs: ['--boundary'],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: { ref: moreUntil == null ? `${ref}^` : `${moreUntil}^..${ref}^` }),\n\t\t\t\t});\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\tconst currentCount = log.commits.size;\n\t\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\t\tif (currentCount === commits.size && queryLimit !== 0) {\n\t\t\t\t\t// If we didn't find any new commits, we must have them all so return that we have everything\n\t\t\t\t\tif (moreLogCount === moreLog.commits.size) {\n\t\t\t\t\t\treturn { ...log, hasMore: false, more: undefined };\n\t\t\t\t\t}\n\n\t\t\t\t\tmoreLogCount = moreLog.commits.size;\n\t\t\t\t\tqueryLimit = queryLimit * 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (timestamp != null && ref != null && !moreLog.commits.has(ref)) {\n\t\t\t\t\tdebugger;\n\t\t\t\t}\n\n\t\t\t\tconst mergedLog: GitLog = {\n\t\t\t\t\trepoPath: log.repoPath,\n\t\t\t\t\tcommits: commits,\n\t\t\t\t\tsha: log.sha,\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tcount: commits.size,\n\t\t\t\t\tlimit: moreUntil == null ? (log.limit ?? 0) + moreLimit : undefined,\n\t\t\t\t\thasMore: moreUntil == null ? moreLog.hasMore : true,\n\t\t\t\t\tstartingCursor: last(log.commits)?.[0],\n\t\t\t\t\tendingCursor: moreLog.endingCursor,\n\t\t\t\t\tpagedCommits: () => {\n\t\t\t\t\t\t// Remove any duplicates\n\t\t\t\t\t\tfor (const sha of log.commits.keys()) {\n\t\t\t\t\t\t\tmoreLog.commits.delete(sha);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn moreLog.commits;\n\t\t\t\t\t},\n\t\t\t\t\tquery: (limit: number | undefined) => this.getLog(log.repoPath, { ...options, limit: limit }),\n\t\t\t\t};\n\t\t\t\tif (mergedLog.hasMore) {\n\t\t\t\t\tmergedLog.more = this.getLogMoreFn(mergedLog, options);\n\t\t\t\t}\n\n\t\t\t\treturn mergedLog;\n\t\t\t} while (true);\n\t\t};\n\t}\n\n\t@log()\n\tasync getLogForFile(\n\t\trepoPath: string | undefined,\n\t\tpathOrUri: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tcursor?: string;\n\t\t\tforce?: boolean | undefined;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, repoPath);\n\n\t\tif (repoPath != null && repoPath === relativePath) {\n\t\t\tthrow new Error(`File name cannot match the repository path; path=${relativePath}`);\n\t\t}\n\n\t\toptions = { reverse: false, ...options };\n\n\t\tif (options.renames == null) {\n\t\t\toptions.renames = configuration.get('advanced.fileHistoryFollowsRenames');\n\t\t}\n\n\t\tlet key = 'log';\n\t\tif (options.ref != null) {\n\t\t\tkey += `:${options.ref}`;\n\t\t}\n\n\t\tif (options.all == null) {\n\t\t\toptions.all = configuration.get('advanced.fileHistoryShowAllBranches');\n\t\t}\n\t\tif (options.all) {\n\t\t\tkey += ':all';\n\t\t}\n\n\t\toptions.limit = options.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\tif (options.limit) {\n\t\t\tkey += `:n${options.limit}`;\n\t\t}\n\n\t\tif (options.renames) {\n\t\t\tkey += ':follow';\n\t\t}\n\n\t\tif (options.reverse) {\n\t\t\tkey += ':reverse';\n\t\t}\n\n\t\tif (options.since) {\n\t\t\tkey += `:since=${options.since}`;\n\t\t}\n\n\t\tif (options.skip) {\n\t\t\tkey += `:skip${options.skip}`;\n\t\t}\n\n\t\tconst doc = await this.container.tracker.getOrAdd(GitUri.fromFile(relativePath, repoPath, options.ref));\n\t\tif (!options.force && this.useCaching && options.range == null) {\n\t\t\tif (doc.state != null) {\n\t\t\t\tconst cachedLog = doc.state.getLog(key);\n\t\t\t\tif (cachedLog != null) {\n\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\t\t\t\t\treturn cachedLog.item;\n\t\t\t\t}\n\n\t\t\t\tif (options.ref != null || options.limit != null) {\n\t\t\t\t\t// Since we are looking for partial log, see if we have the log of the whole file\n\t\t\t\t\tconst cachedLog = doc.state.getLog(\n\t\t\t\t\t\t`log${options.renames ? ':follow' : ''}${options.reverse ? ':reverse' : ''}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (cachedLog != null) {\n\t\t\t\t\t\tif (options.ref == null) {\n\t\t\t\t\t\t\tLogger.debug(scope, `Cache hit: ~'${key}'`);\n\t\t\t\t\t\t\treturn cachedLog.item;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLogger.debug(scope, `Cache ?: '${key}'`);\n\t\t\t\t\t\tlet log = await cachedLog.item;\n\t\t\t\t\t\tif (log != null && !log.hasMore && log.commits.has(options.ref)) {\n\t\t\t\t\t\t\tLogger.debug(scope, `Cache hit: '${key}'`);\n\n\t\t\t\t\t\t\t// Create a copy of the log starting at the requested commit\n\t\t\t\t\t\t\tlet skip = true;\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tconst commits = new Map(\n\t\t\t\t\t\t\t\tfilterMapIterable<[string, GitCommit], [string, GitCommit]>(\n\t\t\t\t\t\t\t\t\tlog.commits.entries(),\n\t\t\t\t\t\t\t\t\t([ref, c]) => {\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\tif (ref !== options?.ref) return undefined;\n\t\t\t\t\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\tif (options?.limit != null && i > options.limit) {\n\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\treturn [ref, c];\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst opts = { ...options };\n\t\t\t\t\t\t\tlog = {\n\t\t\t\t\t\t\t\t...log,\n\t\t\t\t\t\t\t\tlimit: options.limit,\n\t\t\t\t\t\t\t\tcount: commits.size,\n\t\t\t\t\t\t\t\tcommits: commits,\n\t\t\t\t\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\t\t\t\t\tthis.getLogForFile(repoPath, pathOrUri, { ...opts, limit: limit }),\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\treturn log;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLogger.debug(scope, `Cache miss: '${key}'`);\n\n\t\t\tif (doc.state == null) {\n\t\t\t\tdoc.state = new GitDocumentState();\n\t\t\t}\n\t\t}\n\n\t\tconst promise = this.getLogForFileCore(repoPath, relativePath, options, doc, key, scope);\n\n\t\tif (doc.state != null && options.range == null) {\n\t\t\tLogger.debug(scope, `Cache add: '${key}'`);\n\n\t\t\tconst value: CachedLog = {\n\t\t\t\titem: promise as Promise<GitLog>,\n\t\t\t};\n\t\t\tdoc.state.setLog(key, value);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tprivate async getLogForFileCore(\n\t\trepoPath: string | undefined,\n\t\tpath: string,\n\t\t{\n\t\t\tref,\n\t\t\trange,\n\t\t\t...options\n\t\t}: {\n\t\t\tall?: boolean;\n\t\t\tcursor?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t\tdocument: TrackedDocument<GitDocumentState>,\n\t\tkey: string,\n\t\tscope: LogScope | undefined,\n\t): Promise<GitLog | undefined> {\n\t\tconst paths = await this.isTrackedPrivate(path, repoPath, ref);\n\t\tif (paths == null) {\n\t\t\tLogger.log(scope, `Skipping blame; '${path}' is not tracked`);\n\t\t\treturn emptyPromise as Promise<GitLog>;\n\t\t}\n\n\t\tconst [relativePath, root] = paths;\n\n\t\ttry {\n\t\t\tif (range != null && range.start.line > range.end.line) {\n\t\t\t\trange = new Range(range.end, range.start);\n\t\t\t}\n\n\t\t\tconst data = await this.git.log__file(root, relativePath, ref, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tfirstParent: options.renames,\n\t\t\t\tstartLine: range == null ? undefined : range.start.line + 1,\n\t\t\t\tendLine: range == null ? undefined : range.end.line + 1,\n\t\t\t});\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\t// If this is the log of a folder, parse it as a normal log rather than a file log\n\t\t\t\tisFolderGlob(relativePath) ? LogType.Log : LogType.LogFile,\n\t\t\t\troot,\n\t\t\t\trelativePath,\n\t\t\t\tref,\n\t\t\t\tawait this.getCurrentUser(root),\n\t\t\t\toptions.limit,\n\t\t\t\toptions.reverse ?? false,\n\t\t\t\trange,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tconst opts = { ...options, ref: ref, range: range };\n\t\t\t\tlog.query = (limit: number | undefined) =>\n\t\t\t\t\tthis.getLogForFile(repoPath, path, { ...opts, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlog.more = this.getLogForFileMoreFn(log, path, opts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\t// Trap and cache expected log errors\n\t\t\tif (document.state != null && range == null && !options.reverse) {\n\t\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t\tLogger.debug(scope, `Cache replace (with empty promise): '${key}'`);\n\n\t\t\t\tconst value: CachedLog = {\n\t\t\t\t\titem: emptyPromise as Promise<GitLog>,\n\t\t\t\t\terrorMessage: msg,\n\t\t\t\t};\n\t\t\t\tdocument.state.setLog(key, value);\n\n\t\t\t\treturn emptyPromise as Promise<GitLog>;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getLogForFileMoreFn(\n\t\tlog: GitLog,\n\t\trelativePath: string,\n\t\toptions: {\n\t\t\tall?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t},\n\t): (limit: number | { until: string } | undefined) => Promise<GitLog> {\n\t\treturn async (limit: number | { until: string } | undefined) => {\n\t\t\tconst moreUntil = limit != null && typeof limit === 'object' ? limit.until : undefined;\n\t\t\tlet moreLimit = typeof limit === 'number' ? limit : undefined;\n\n\t\t\tif (moreUntil && some(log.commits.values(), c => c.ref === moreUntil)) {\n\t\t\t\treturn log;\n\t\t\t}\n\n\t\t\tmoreLimit = moreLimit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\tconst ref = last(log.commits.values())?.ref;\n\t\t\tconst moreLog = await this.getLogForFile(log.repoPath, relativePath, {\n\t\t\t\t...options,\n\t\t\t\tlimit: moreUntil == null ? moreLimit : 0,\n\t\t\t\tref: options.all ? undefined : moreUntil == null ? `${ref}^` : `${moreUntil}^..${ref}^`,\n\t\t\t\tskip: options.all ? log.count : undefined,\n\t\t\t});\n\t\t\t// If we can't find any more, assume we have everything\n\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\tconst mergedLog: GitLog = {\n\t\t\t\trepoPath: log.repoPath,\n\t\t\t\tcommits: commits,\n\t\t\t\tsha: log.sha,\n\t\t\t\trange: log.range,\n\t\t\t\tcount: commits.size,\n\t\t\t\tlimit: moreUntil == null ? (log.limit ?? 0) + moreLimit : undefined,\n\t\t\t\thasMore: moreUntil == null ? moreLog.hasMore : true,\n\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\tthis.getLogForFile(log.repoPath, relativePath, { ...options, limit: limit }),\n\t\t\t};\n\n\t\t\tif (options.renames) {\n\t\t\t\tconst renamed = find(\n\t\t\t\t\tmoreLog.commits.values(),\n\t\t\t\t\tc => Boolean(c.file?.originalPath) && c.file?.originalPath !== relativePath,\n\t\t\t\t);\n\t\t\t\trelativePath = renamed?.file?.originalPath ?? relativePath;\n\t\t\t}\n\n\t\t\tif (mergedLog.hasMore) {\n\t\t\t\tmergedLog.more = this.getLogForFileMoreFn(mergedLog, relativePath, options);\n\t\t\t}\n\n\t\t\treturn mergedLog;\n\t\t};\n\t}\n\n\t@log()\n\tasync getMergeBase(repoPath: string, ref1: string, ref2: string, options?: { forkPoint?: boolean }) {\n\t\tconst scope = getLogScope();\n\n\t\ttry {\n\t\t\tconst data = await this.git.merge_base(repoPath, ref1, ref2, options);\n\t\t\tif (data == null) return undefined;\n\n\t\t\treturn data.split('\\n')[0].trim() || undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tasync getMergeStatus(repoPath: string): Promise<GitMergeStatus | undefined> {\n\t\tlet status = this.useCaching ? this._mergeStatusCache.get(repoPath) : undefined;\n\t\tif (status === undefined) {\n\t\t\tconst merge = await this.git.rev_parse__verify(repoPath, 'MERGE_HEAD');\n\t\t\tif (merge != null) {\n\t\t\t\tconst [branch, mergeBase, possibleSourceBranches] = await Promise.all([\n\t\t\t\t\tthis.getBranch(repoPath),\n\t\t\t\t\tthis.getMergeBase(repoPath, 'MERGE_HEAD', 'HEAD'),\n\t\t\t\t\tthis.getCommitBranches(repoPath, 'MERGE_HEAD', { mode: 'pointsAt' }),\n\t\t\t\t]);\n\n\t\t\t\tstatus = {\n\t\t\t\t\ttype: 'merge',\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tmergeBase: mergeBase,\n\t\t\t\t\tHEAD: createReference(merge, repoPath, { refType: 'revision' }),\n\t\t\t\t\tcurrent: getReferenceFromBranch(branch!),\n\t\t\t\t\tincoming:\n\t\t\t\t\t\tpossibleSourceBranches?.length === 1\n\t\t\t\t\t\t\t? createReference(possibleSourceBranches[0], repoPath, {\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: possibleSourceBranches[0],\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._mergeStatusCache.set(repoPath, status ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn status ?? undefined;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getRebaseStatus(repoPath: string): Promise<GitRebaseStatus | undefined> {\n\t\tlet status = this.useCaching ? this._rebaseStatusCache.get(repoPath) : undefined;\n\t\tif (status === undefined) {\n\t\t\tconst rebase = await this.git.rev_parse__verify(repoPath, 'REBASE_HEAD');\n\t\t\tif (rebase != null) {\n\t\t\t\tlet [mergeBase, branch, onto, stepsNumber, stepsMessage, stepsTotal] = await Promise.all([\n\t\t\t\t\tthis.getMergeBase(repoPath, 'REBASE_HEAD', 'HEAD'),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'head-name']),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'onto']),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'msgnum'], { numeric: true }),\n\t\t\t\t\tthis.git\n\t\t\t\t\t\t.readDotGitFile(repoPath, ['rebase-merge', 'message'], { throw: true })\n\t\t\t\t\t\t.catch(() => this.git.readDotGitFile(repoPath, ['rebase-merge', 'message-squashed'])),\n\t\t\t\t\tthis.git.readDotGitFile(repoPath, ['rebase-merge', 'end'], { numeric: true }),\n\t\t\t\t]);\n\n\t\t\t\tif (branch == null || onto == null) return undefined;\n\n\t\t\t\tif (branch.startsWith('refs/heads/')) {\n\t\t\t\t\tbranch = branch.substr(11).trim();\n\t\t\t\t}\n\n\t\t\t\tconst possibleSourceBranches = await this.getCommitBranches(repoPath, onto, { mode: 'pointsAt' });\n\n\t\t\t\tlet possibleSourceBranch: string | undefined;\n\t\t\t\tfor (const b of possibleSourceBranches) {\n\t\t\t\t\tif (b.startsWith('(no branch, rebasing')) continue;\n\n\t\t\t\t\tpossibleSourceBranch = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstatus = {\n\t\t\t\t\ttype: 'rebase',\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tmergeBase: mergeBase,\n\t\t\t\t\tHEAD: createReference(rebase, repoPath, { refType: 'revision' }),\n\t\t\t\t\tonto: createReference(onto, repoPath, { refType: 'revision' }),\n\t\t\t\t\tcurrent:\n\t\t\t\t\t\tpossibleSourceBranch != null\n\t\t\t\t\t\t\t? createReference(possibleSourceBranch, repoPath, {\n\t\t\t\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\t\t\t\tname: possibleSourceBranch,\n\t\t\t\t\t\t\t\t\tremote: false,\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: undefined,\n\n\t\t\t\t\tincoming: createReference(branch, repoPath, {\n\t\t\t\t\t\trefType: 'branch',\n\t\t\t\t\t\tname: branch,\n\t\t\t\t\t\tremote: false,\n\t\t\t\t\t}),\n\t\t\t\t\tsteps: {\n\t\t\t\t\t\tcurrent: {\n\t\t\t\t\t\t\tnumber: stepsNumber ?? 0,\n\t\t\t\t\t\t\tcommit: createReference(rebase, repoPath, {\n\t\t\t\t\t\t\t\trefType: 'revision',\n\t\t\t\t\t\t\t\tmessage: stepsMessage,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttotal: stepsTotal ?? 0,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._rebaseStatusCache.set(repoPath, status ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn status ?? undefined;\n\t}\n\n\t@log()\n\tasync getNextComparisonUris(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<NextComparisonUrisResult | undefined> {\n\t\t// If we have no ref (or staged ref) there is no next commit\n\t\tif (!ref) return undefined;\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tif (isUncommittedStaged(ref)) {\n\t\t\treturn {\n\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t};\n\t\t}\n\n\t\tconst next = await this.getNextUri(repoPath, uri, ref, skip);\n\t\tif (next == null) {\n\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\tif (status != null) {\n\t\t\t\t// If the file is staged, diff with the staged version\n\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, ref),\n\t\t\t\tnext: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tcurrent:\n\t\t\t\tskip === 0\n\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t: (await this.getNextUri(repoPath, uri, ref, skip - 1))!,\n\t\t\tnext: next,\n\t\t};\n\t}\n\n\t@log()\n\tprivate async getNextUri(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref?: string,\n\t\tskip: number = 0,\n\t\t// editorLine?: number\n\t): Promise<GitUri | undefined> {\n\t\t// If we have no ref (or staged ref) there is no next commit\n\t\tif (!ref || isUncommittedStaged(ref)) return undefined;\n\n\t\tlet filters: GitDiffFilter[] | undefined;\n\t\tif (ref === deletedOrMissing) {\n\t\t\t// If we are trying to move next from a deleted or missing ref then get the first commit\n\t\t\tref = undefined;\n\t\t\tfilters = ['A'];\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\t\tlet data = await this.git.log__file(repoPath, relativePath, ref, {\n\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\tfileMode: 'simple',\n\t\t\tfilters: filters,\n\t\t\tlimit: skip + 1,\n\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\treverse: true,\n\t\t\t// startLine: editorLine != null ? editorLine + 1 : undefined,\n\t\t});\n\t\tif (data == null || data.length === 0) return undefined;\n\n\t\tconst [nextRef, file, status] = GitLogParser.parseSimple(data, skip);\n\t\t// If the file was deleted, check for a possible rename\n\t\tif (status === 'D') {\n\t\t\tdata = await this.git.log__file(repoPath, '.', nextRef, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfilters: ['R', 'C'],\n\t\t\t\tlimit: 1,\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t// startLine: editorLine != null ? editorLine + 1 : undefined\n\t\t\t});\n\t\t\tif (data == null || data.length === 0) {\n\t\t\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, nextRef);\n\t\t\t}\n\n\t\t\tconst [nextRenamedRef, renamedFile] = GitLogParser.parseSimpleRenamed(data, file ?? relativePath);\n\t\t\treturn GitUri.fromFile(\n\t\t\t\trenamedFile ?? file ?? relativePath,\n\t\t\t\trepoPath,\n\t\t\t\tnextRenamedRef ?? nextRef ?? deletedOrMissing,\n\t\t\t);\n\t\t}\n\n\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, nextRef);\n\t}\n\n\t@log()\n\tasync getOldestUnpushedRefForFile(repoPath: string, uri: Uri): Promise<string | undefined> {\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.log__file(root, relativePath, '@{u}..', {\n\t\t\targsOrFormat: ['-z', '--format=%H'],\n\t\t\tfileMode: 'none',\n\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\trenames: true,\n\t\t});\n\t\tif (!data) return undefined;\n\n\t\t// -2 to skip the ending null\n\t\tconst index = data.lastIndexOf('\\0', data.length - 2);\n\t\treturn index === -1 ? undefined : data.slice(index + 1, data.length - 2);\n\t}\n\n\t@log()\n\tasync getPreviousComparisonUris(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t\tfirstParent: boolean = false,\n\t): Promise<PreviousComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\t// If we are at the working tree (i.e. no ref), we need to dig deeper to figure out where to go\n\t\tif (!ref) {\n\t\t\t// First, check the file status to see if there is anything staged\n\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\tif (status != null) {\n\t\t\t\t// If the file is staged with working changes, diff working with staged (index)\n\t\t\t\t// If the file is staged without working changes, diff staged with HEAD\n\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\t// Backs up to get to HEAD\n\t\t\t\t\tif (status.workingTreeStatus == null) {\n\t\t\t\t\t\tskip++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (skip === 0) {\n\t\t\t\t\t\t// Diff working with staged\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\tprevious: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t// Diff staged with HEAD (or prior if more skips)\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, ref, skip - 1, undefined, firstParent),\n\t\t\t\t\t};\n\t\t\t\t} else if (status.workingTreeStatus != null) {\n\t\t\t\t\tif (skip === 0) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, undefined, firstParent),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (skip === 0) {\n\t\t\t\tskip++;\n\t\t\t}\n\t\t}\n\t\t// If we are at the index (staged), diff staged with HEAD\n\t\telse if (isUncommittedStaged(ref)) {\n\t\t\tconst current =\n\t\t\t\tskip === 0\n\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t: (await this.getPreviousUri(repoPath, uri, undefined, skip - 1, undefined, firstParent))!;\n\t\t\tif (current == null || current.sha === deletedOrMissing) return undefined;\n\n\t\t\treturn {\n\t\t\t\tcurrent: current,\n\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, undefined, firstParent),\n\t\t\t};\n\t\t}\n\n\t\t// If we are at a commit, diff commit with previous\n\t\tconst current =\n\t\t\tskip === 0\n\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t: (await this.getPreviousUri(repoPath, uri, ref, skip - 1, undefined, firstParent))!;\n\t\tif (current == null || current.sha === deletedOrMissing) return undefined;\n\n\t\treturn {\n\t\t\tcurrent: current,\n\t\t\tprevious: await this.getPreviousUri(repoPath, uri, ref, skip, undefined, firstParent),\n\t\t};\n\t}\n\n\t@log()\n\tasync getPreviousComparisonUrisForLine(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\teditorLine: number, // 0-based, Git is 1-based\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<PreviousLineComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tlet relativePath = this.getRelativePath(uri, repoPath);\n\n\t\tlet previous;\n\n\t\t// If we are at the working tree (i.e. no ref), we need to dig deeper to figure out where to go\n\t\tif (!ref) {\n\t\t\t// First, check the blame on the current line to see if there are any working/staged changes\n\t\t\tconst gitUri = new GitUri(uri, repoPath);\n\n\t\t\tconst document = await workspace.openTextDocument(uri);\n\t\t\tconst blameLine = document.isDirty\n\t\t\t\t? await this.getBlameForLineContents(gitUri, editorLine, document.getText())\n\t\t\t\t: await this.getBlameForLine(gitUri, editorLine);\n\t\t\tif (blameLine == null) return undefined;\n\n\t\t\t// If line is uncommitted, we need to dig deeper to figure out where to go (because blame can't be trusted)\n\t\t\tif (blameLine.commit.isUncommitted) {\n\t\t\t\t// If the document is dirty (unsaved), use the status to determine where to go\n\t\t\t\tif (document.isDirty) {\n\t\t\t\t\t// Check the file status to see if there is anything staged\n\t\t\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t// If the file is staged, diff working with staged (index)\n\t\t\t\t\t\t// If the file is not staged, diff working with HEAD\n\t\t\t\t\t\tif (status.indexStatus != null) {\n\t\t\t\t\t\t\t// Diff working with staged\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\t\t\tprevious: GitUri.fromFile(relativePath, repoPath, uncommittedStaged),\n\t\t\t\t\t\t\t\tline: editorLine,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Diff working with HEAD (or prior if more skips)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcurrent: GitUri.fromFile(relativePath, repoPath, undefined),\n\t\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, editorLine),\n\t\t\t\t\t\tline: editorLine,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// First, check if we have a diff in the working tree\n\t\t\t\tlet hunkLine = await this.getDiffForLine(gitUri, editorLine, undefined);\n\t\t\t\tif (hunkLine == null) {\n\t\t\t\t\t// Next, check if we have a diff in the index (staged)\n\t\t\t\t\thunkLine = await this.getDiffForLine(gitUri, editorLine, undefined, uncommittedStaged);\n\n\t\t\t\t\tif (hunkLine != null) {\n\t\t\t\t\t\tref = uncommittedStaged;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tskip++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If line is committed, diff with line ref with previous\n\t\t\telse {\n\t\t\t\tref = blameLine.commit.sha;\n\t\t\t\trelativePath = blameLine.commit.file?.path ?? blameLine.commit.file?.originalPath ?? relativePath;\n\t\t\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\t\t\teditorLine = blameLine.line.originalLine - 1;\n\n\t\t\t\tif (skip === 0 && blameLine.commit.file?.previousSha) {\n\t\t\t\t\tprevious = GitUri.fromFile(relativePath, repoPath, blameLine.commit.file.previousSha);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (isUncommittedStaged(ref)) {\n\t\t\t\tconst current =\n\t\t\t\t\tskip === 0\n\t\t\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t\t\t: (await this.getPreviousUri(repoPath, uri, undefined, skip - 1, editorLine))!;\n\t\t\t\tif (current.sha === deletedOrMissing) return undefined;\n\n\t\t\t\treturn {\n\t\t\t\t\tcurrent: current,\n\t\t\t\t\tprevious: await this.getPreviousUri(repoPath, uri, undefined, skip, editorLine),\n\t\t\t\t\tline: editorLine,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst gitUri = new GitUri(uri, { repoPath: repoPath, sha: ref });\n\t\t\tconst blameLine = await this.getBlameForLine(gitUri, editorLine);\n\t\t\tif (blameLine == null) return undefined;\n\n\t\t\t// Diff with line ref with previous\n\t\t\tref = blameLine.commit.sha;\n\t\t\trelativePath = blameLine.commit.file?.path ?? blameLine.commit.file?.originalPath ?? relativePath;\n\t\t\turi = this.getAbsoluteUri(relativePath, repoPath);\n\t\t\teditorLine = blameLine.line.originalLine - 1;\n\n\t\t\tif (skip === 0 && blameLine.commit.file?.previousSha) {\n\t\t\t\tprevious = GitUri.fromFile(relativePath, repoPath, blameLine.commit.file.previousSha);\n\t\t\t}\n\t\t}\n\n\t\tconst current =\n\t\t\tskip === 0\n\t\t\t\t? GitUri.fromFile(relativePath, repoPath, ref)\n\t\t\t\t: (await this.getPreviousUri(repoPath, uri, ref, skip - 1, editorLine))!;\n\t\tif (current.sha === deletedOrMissing) return undefined;\n\n\t\treturn {\n\t\t\tcurrent: current,\n\t\t\tprevious: previous ?? (await this.getPreviousUri(repoPath, uri, ref, skip, editorLine)),\n\t\t\tline: editorLine,\n\t\t};\n\t}\n\n\t@log()\n\tprivate async getPreviousUri(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\tref?: string,\n\t\tskip: number = 0,\n\t\teditorLine?: number,\n\t\tfirstParent: boolean = false,\n\t): Promise<GitUri | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\tconst scope = getLogScope();\n\n\t\tif (ref === uncommitted) {\n\t\t\tref = undefined;\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(uri, repoPath);\n\n\t\t// TODO: Add caching\n\t\tlet data;\n\t\ttry {\n\t\t\tdata = await this.git.log__file(repoPath, relativePath, ref, {\n\t\t\t\targsOrFormat: GitLogParser.simpleFormat,\n\t\t\t\tfileMode: 'simple',\n\t\t\t\tfirstParent: firstParent,\n\t\t\t\tlimit: skip + 2,\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\tstartLine: editorLine != null ? editorLine + 1 : undefined,\n\t\t\t});\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\t// If the line count is invalid just fallback to the most recent commit\n\t\t\tif ((ref == null || isUncommittedStaged(ref)) && GitErrors.invalidLineCount.test(msg)) {\n\t\t\t\tif (ref == null) {\n\t\t\t\t\tconst status = await this.getStatusForFile(repoPath, uri);\n\t\t\t\t\tif (status?.indexStatus != null) {\n\t\t\t\t\t\treturn GitUri.fromFile(relativePath, repoPath, uncommittedStaged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tref = await this.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t});\n\t\t\t\treturn GitUri.fromFile(relativePath, repoPath, ref ?? deletedOrMissing);\n\t\t\t}\n\n\t\t\tLogger.error(ex, scope);\n\t\t\tthrow ex;\n\t\t}\n\t\tif (data == null || data.length === 0) return undefined;\n\n\t\tconst [previousRef, file] = GitLogParser.parseSimple(data, skip, ref);\n\t\t// If the previous ref matches the ref we asked for assume we are at the end of the history\n\t\tif (ref != null && ref === previousRef) return undefined;\n\n\t\treturn GitUri.fromFile(file ?? relativePath, repoPath, previousRef ?? deletedOrMissing);\n\t}\n\n\t@log()\n\tasync getIncomingActivity(\n\t\trepoPath: string,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitReflog | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst limit = options?.limit ?? configuration.get('advanced.maxListItems') ?? 0;\n\t\ttry {\n\t\t\t// Pass a much larger limit to reflog, because we aggregate the data and we won't know how many lines we'll need\n\t\t\tconst data = await this.git.reflog(repoPath, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tlimit: limit * 100,\n\t\t\t});\n\t\t\tif (data == null) return undefined;\n\n\t\t\tconst reflog = GitReflogParser.parse(data, repoPath, reflogCommands, limit, limit * 100);\n\t\t\tif (reflog?.hasMore) {\n\t\t\t\treflog.more = this.getReflogMoreFn(reflog, options);\n\t\t\t}\n\n\t\t\treturn reflog;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getReflogMoreFn(\n\t\treflog: GitReflog,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): (limit: number) => Promise<GitReflog> {\n\t\treturn async (limit: number | undefined) => {\n\t\t\tlimit = limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\tconst moreLog = await this.getIncomingActivity(reflog.repoPath, {\n\t\t\t\t...options,\n\t\t\t\tlimit: limit,\n\t\t\t\tskip: reflog.total,\n\t\t\t});\n\t\t\tif (moreLog == null) {\n\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\treturn { ...reflog, hasMore: false, more: undefined };\n\t\t\t}\n\n\t\t\tconst mergedLog: GitReflog = {\n\t\t\t\trepoPath: reflog.repoPath,\n\t\t\t\trecords: [...reflog.records, ...moreLog.records],\n\t\t\t\tcount: reflog.count + moreLog.count,\n\t\t\t\ttotal: reflog.total + moreLog.total,\n\t\t\t\tlimit: (reflog.limit ?? 0) + limit,\n\t\t\t\thasMore: moreLog.hasMore,\n\t\t\t};\n\t\t\tif (mergedLog.hasMore) {\n\t\t\t\tmergedLog.more = this.getReflogMoreFn(mergedLog, options);\n\t\t\t}\n\n\t\t\treturn mergedLog;\n\t\t};\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getRemotes(\n\t\trepoPath: string | undefined,\n\t\toptions?: { providers?: RemoteProviders; sort?: boolean },\n\t): Promise<GitRemote[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst providers = options?.providers ?? loadRemoteProviders(configuration.get('remotes', null));\n\n\t\ttry {\n\t\t\tconst data = await this.git.remote(repoPath);\n\t\t\tconst remotes = GitRemoteParser.parse(data, repoPath, getRemoteProviderMatcher(this.container, providers));\n\t\t\tif (remotes == null) return [];\n\n\t\t\tif (options?.sort) {\n\t\t\t\tGitRemote.sort(remotes);\n\t\t\t}\n\n\t\t\treturn remotes;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tgetRevisionContent(repoPath: string, path: string, ref: string): Promise<Uint8Array | undefined> {\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\treturn this.git.show<Buffer>(root, relativePath, ref, { encoding: 'buffer' });\n\t}\n\n\t@gate()\n\t@log()\n\tasync getStash(repoPath: string | undefined): Promise<GitStash | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tlet stash = this.useCaching ? this._stashesCache.get(repoPath) : undefined;\n\t\tif (stash === undefined) {\n\t\t\tconst parser = createLogParserWithFiles<{\n\t\t\t\tsha: string;\n\t\t\t\tdate: string;\n\t\t\t\tcommittedDate: string;\n\t\t\t\tparents: string;\n\t\t\t\tstashName: string;\n\t\t\t\tsummary: string;\n\t\t\t}>({\n\t\t\t\tsha: '%H',\n\t\t\t\tdate: '%at',\n\t\t\t\tcommittedDate: '%ct',\n\t\t\t\tparents: '%P',\n\t\t\t\tstashName: '%gd',\n\t\t\t\tsummary: '%gs',\n\t\t\t});\n\t\t\tconst data = await this.git.stash__list(repoPath, {\n\t\t\t\targs: parser.arguments,\n\t\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t\t});\n\n\t\t\tconst commits = new Map<string, GitStashCommit>();\n\n\t\t\tconst stashes = parser.parse(data);\n\t\t\tfor (const s of stashes) {\n\t\t\t\tlet onRef;\n\t\t\t\tlet summary;\n\t\t\t\tlet message;\n\n\t\t\t\tconst match = stashSummaryRegex.exec(s.summary);\n\t\t\t\tif (match?.groups != null) {\n\t\t\t\t\tonRef = match.groups.onref;\n\t\t\t\t\tsummary = match.groups.summary.trim();\n\n\t\t\t\t\tif (summary.length === 0) {\n\t\t\t\t\t\tmessage = 'WIP';\n\t\t\t\t\t} else if (match.groups.wip) {\n\t\t\t\t\t\tmessage = `WIP: ${summary}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage = summary;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmessage = s.summary.trim();\n\t\t\t\t}\n\n\t\t\t\tcommits.set(\n\t\t\t\t\ts.sha,\n\t\t\t\t\tnew GitCommit(\n\t\t\t\t\t\tthis.container,\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\ts.sha,\n\t\t\t\t\t\tnew GitCommitIdentity('You', undefined, new Date((s.date as any) * 1000)),\n\t\t\t\t\t\tnew GitCommitIdentity('You', undefined, new Date((s.committedDate as any) * 1000)),\n\t\t\t\t\t\tmessage.split('\\n', 1)[0] ?? '',\n\t\t\t\t\t\ts.parents.split(' '),\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\ts.files?.map(\n\t\t\t\t\t\t\tf => new GitFileChange(repoPath, f.path, f.status as GitFileStatus, f.originalPath),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t[],\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\ts.stashName,\n\t\t\t\t\t\tonRef,\n\t\t\t\t\t) as GitStashCommit,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tstash = { repoPath: repoPath, commits: commits };\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._stashesCache.set(repoPath, stash ?? null);\n\t\t\t}\n\t\t}\n\n\t\treturn stash ?? undefined;\n\t}\n\n\t@log()\n\tasync getStatusForFile(repoPath: string, uri: Uri): Promise<GitStatusFile | undefined> {\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\tconst data = await this.git.status__file(root, relativePath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, root, porcelainVersion);\n\t\tif (status == null || !status.files.length) return undefined;\n\n\t\treturn status.files[0];\n\t}\n\n\t@log()\n\tasync getStatusForFiles(repoPath: string, pathOrGlob: Uri): Promise<GitStatusFile[] | undefined> {\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst [relativePath, root] = splitPath(pathOrGlob, repoPath);\n\n\t\tconst data = await this.git.status__file(root, relativePath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, root, porcelainVersion);\n\t\tif (status == null || !status.files.length) return [];\n\n\t\treturn status.files;\n\t}\n\n\t@log()\n\tasync getStatusForRepo(repoPath: string | undefined): Promise<GitStatus | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst porcelainVersion = (await this.git.isAtLeastVersion('2.11')) ? 2 : 1;\n\n\t\tconst data = await this.git.status(repoPath, porcelainVersion, {\n\t\t\tsimilarityThreshold: configuration.get('advanced.similarityThreshold'),\n\t\t});\n\t\tconst status = GitStatusParser.parse(data, repoPath, porcelainVersion);\n\n\t\tif (status?.detached) {\n\t\t\tconst rebaseStatus = await this.getRebaseStatus(repoPath);\n\t\t\tif (rebaseStatus != null) {\n\t\t\t\treturn new GitStatus(\n\t\t\t\t\trepoPath,\n\t\t\t\t\trebaseStatus.incoming.name,\n\t\t\t\t\tstatus.sha,\n\t\t\t\t\tstatus.files,\n\t\t\t\t\tstatus.state,\n\t\t\t\t\tstatus.upstream,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn status;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getTags(\n\t\trepoPath: string | undefined,\n\t\toptions?: { cursor?: string; filter?: (t: GitTag) => boolean; sort?: boolean | TagSortOptions },\n\t): Promise<PagedResult<GitTag>> {\n\t\tif (repoPath == null) return emptyPagedResult;\n\n\t\tlet resultsPromise = this.useCaching ? this._tagsCache.get(repoPath) : undefined;\n\t\tif (resultsPromise == null) {\n\t\t\tasync function load(this: LocalGitProvider): Promise<PagedResult<GitTag>> {\n\t\t\t\ttry {\n\t\t\t\t\tconst data = await this.git.tag(repoPath!);\n\t\t\t\t\treturn { values: GitTagParser.parse(data, repoPath!) ?? [] };\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthis._tagsCache.delete(repoPath!);\n\n\t\t\t\t\treturn emptyPagedResult;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresultsPromise = load.call(this);\n\n\t\t\tif (this.useCaching) {\n\t\t\t\tthis._tagsCache.set(repoPath, resultsPromise);\n\t\t\t}\n\t\t}\n\n\t\tlet result = await resultsPromise;\n\t\tif (options?.filter != null) {\n\t\t\tresult = {\n\t\t\t\t...result,\n\t\t\t\tvalues: result.values.filter(options.filter),\n\t\t\t};\n\t\t}\n\n\t\tif (options?.sort) {\n\t\t\tsortTags(result.values, typeof options.sort === 'boolean' ? undefined : options.sort);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@log()\n\tasync getTreeEntryForRevision(repoPath: string, path: string, ref: string): Promise<GitTreeEntry | undefined> {\n\t\tif (repoPath == null || !path) return undefined;\n\n\t\tconst [relativePath, root] = splitPath(path, repoPath);\n\n\t\tconst data = await this.git.ls_tree(root, ref, relativePath);\n\t\tconst trees = GitTreeParser.parse(data);\n\t\treturn trees?.length ? trees[0] : undefined;\n\t}\n\n\t@log()\n\tasync getTreeForRevision(repoPath: string, ref: string): Promise<GitTreeEntry[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst data = await this.git.ls_tree(repoPath, ref);\n\t\treturn GitTreeParser.parse(data) ?? [];\n\t}\n\n\t@log()\n\tasync getUniqueRepositoryId(repoPath: string): Promise<string | undefined> {\n\t\tconst data = await this.git.rev_list(repoPath, 'HEAD', { maxParents: 0 });\n\t\treturn data?.[0];\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasBranchOrTag(\n\t\trepoPath: string | undefined,\n\t\toptions?: {\n\t\t\tfilter?: { branches?: (b: GitBranch) => boolean; tags?: (t: GitTag) => boolean };\n\t\t},\n\t) {\n\t\tconst [{ values: branches }, { values: tags }] = await Promise.all([\n\t\t\tthis.getBranches(repoPath, {\n\t\t\t\tfilter: options?.filter?.branches,\n\t\t\t\tsort: false,\n\t\t\t}),\n\t\t\tthis.getTags(repoPath, {\n\t\t\t\tfilter: options?.filter?.tags,\n\t\t\t\tsort: false,\n\t\t\t}),\n\t\t]);\n\n\t\treturn branches.length !== 0 || tags.length !== 0;\n\t}\n\n\t@log()\n\tasync hasCommitBeenPushed(repoPath: string, ref: string): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\treturn this.git.merge_base__is_ancestor(repoPath, ref, '@{u}');\n\t}\n\n\thasUnsafeRepositories(): boolean {\n\t\treturn this.unsafePaths.size !== 0;\n\t}\n\n\tisTrackable(uri: Uri): boolean {\n\t\treturn this.supportedSchemes.has(uri.scheme);\n\t}\n\n\tasync isTracked(uri: Uri): Promise<boolean> {\n\t\treturn (await this.isTrackedPrivate(uri)) != null;\n\t}\n\n\tprivate async isTrackedPrivate(uri: Uri | GitUri): Promise<[string, string] | undefined>;\n\tprivate async isTrackedPrivate(\n\t\tpath: string,\n\t\trepoPath?: string,\n\t\tref?: string,\n\t): Promise<[string, string] | undefined>;\n\t@log<LocalGitProvider['isTrackedPrivate']>({ exit: tracked => `returned ${Boolean(tracked)}` })\n\tprivate async isTrackedPrivate(\n\t\tpathOrUri: string | Uri | GitUri,\n\t\trepoPath?: string,\n\t\tref?: string,\n\t): Promise<[string, string] | undefined> {\n\t\tlet relativePath: string;\n\t\tlet repository: Repository | undefined;\n\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\t\trepository = this.container.git.getRepository(Uri.file(pathOrUri));\n\t\t\trepoPath = repoPath || repository?.path;\n\n\t\t\t[relativePath, repoPath] = splitPath(pathOrUri, repoPath);\n\t\t} else {\n\t\t\tif (!this.isTrackable(pathOrUri)) return undefined;\n\n\t\t\tif (pathOrUri instanceof GitUri) {\n\t\t\t\t// Always use the ref of the GitUri\n\t\t\t\tref = pathOrUri.sha;\n\t\t\t\tif (ref === deletedOrMissing) return undefined;\n\t\t\t}\n\n\t\t\trepository = this.container.git.getRepository(pathOrUri);\n\t\t\trepoPath = repoPath || repository?.path;\n\n\t\t\t[relativePath, repoPath] = splitPath(pathOrUri, repoPath);\n\t\t}\n\n\t\tconst path = repoPath ? `${repoPath}/${relativePath}` : relativePath;\n\n\t\tlet key = path;\n\t\tkey = `${ref ?? ''}:${key.startsWith('/') ? key : `/${key}`}`;\n\n\t\tlet tracked = this._trackedPaths.get(key);\n\t\tif (tracked != null) return tracked;\n\n\t\ttracked = this.isTrackedCore(path, relativePath, repoPath ?? '', ref, repository);\n\t\tthis._trackedPaths.set(key, tracked);\n\n\t\ttracked = await tracked;\n\t\tthis._trackedPaths.set(key, tracked);\n\t\treturn tracked;\n\t}\n\n\t@debug()\n\tprivate async isTrackedCore(\n\t\tpath: string,\n\t\trelativePath: string,\n\t\trepoPath: string,\n\t\tref: string | undefined,\n\t\trepository: Repository | undefined,\n\t): Promise<[string, string] | undefined> {\n\t\tif (ref === deletedOrMissing) return undefined;\n\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (!repoPath) {\n\t\t\t\t\t[relativePath, repoPath] = splitPath(path, '', true);\n\t\t\t\t}\n\n\t\t\t\t// Even if we have a ref, check first to see if the file exists (that way the cache will be better reused)\n\t\t\t\tlet tracked = Boolean(await this.git.ls_files(repoPath, relativePath));\n\t\t\t\tif (tracked) return [relativePath, repoPath];\n\n\t\t\t\tif (repoPath) {\n\t\t\t\t\tconst [newRelativePath, newRepoPath] = splitPath(path, '', true);\n\t\t\t\t\tif (newRelativePath !== relativePath) {\n\t\t\t\t\t\t// If we didn't find it, check it as close to the file as possible (will find nested repos)\n\t\t\t\t\t\ttracked = Boolean(await this.git.ls_files(newRepoPath, newRelativePath));\n\t\t\t\t\t\tif (tracked) {\n\t\t\t\t\t\t\trepository = await this.container.git.getOrOpenRepository(Uri.file(path), {\n\t\t\t\t\t\t\t\tdetectNested: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (repository != null) {\n\t\t\t\t\t\t\t\treturn splitPath(path, repository.path);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn [newRelativePath, newRepoPath];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!tracked && ref && !isUncommitted(ref)) {\n\t\t\t\t\ttracked = Boolean(await this.git.ls_files(repoPath, relativePath, { ref: ref }));\n\t\t\t\t\t// If we still haven't found this file, make sure it wasn't deleted in that ref (i.e. check the previous)\n\t\t\t\t\tif (!tracked) {\n\t\t\t\t\t\ttracked = Boolean(await this.git.ls_files(repoPath, relativePath, { ref: `${ref}^` }));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Since the file isn't tracked, make sure it isn't part of a nested repository we don't know about yet\n\t\t\t\tif (!tracked) {\n\t\t\t\t\tif (repository != null) {\n\t\t\t\t\t\t// Don't look for a nested repository if the file isn't at least one folder deep\n\t\t\t\t\t\tconst index = relativePath.indexOf('/');\n\t\t\t\t\t\tif (index < 0 || index === relativePath.length - 1) return undefined;\n\n\t\t\t\t\t\tconst nested = await this.container.git.getOrOpenRepository(Uri.file(path), {\n\t\t\t\t\t\t\tdetectNested: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (nested != null && nested !== repository) {\n\t\t\t\t\t\t\t[relativePath, repoPath] = splitPath(path, repository.path);\n\t\t\t\t\t\t\trepository = undefined;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn [relativePath, repoPath];\n\t\t\t}\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getDiffTool(repoPath?: string): Promise<string | undefined> {\n\t\treturn (\n\t\t\t(await this.git.config__get('diff.guitool', repoPath, { local: true })) ??\n\t\t\tthis.git.config__get('diff.tool', repoPath, { local: true })\n\t\t);\n\t}\n\n\t@log()\n\tasync openDiffTool(\n\t\trepoPath: string,\n\t\turi: Uri,\n\t\toptions?: { ref1?: string; ref2?: string; staged?: boolean; tool?: string },\n\t): Promise<void> {\n\t\tconst [relativePath, root] = splitPath(uri, repoPath);\n\n\t\ttry {\n\t\t\tlet tool = options?.tool;\n\t\t\tif (!tool) {\n\t\t\t\tconst scope = getLogScope();\n\n\t\t\t\ttool = configuration.get('advanced.externalDiffTool') || (await this.getDiffTool(root));\n\t\t\t\tif (tool == null) throw new Error('No diff tool found');\n\n\t\t\t\tLogger.log(scope, `Using tool=${tool}`);\n\t\t\t}\n\n\t\t\tawait this.git.difftool(root, relativePath, tool, options);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (msg === 'No diff tool found' || /Unknown .+? tool/.test(msg)) {\n\t\t\t\tconst viewDocs = 'View Git Docs';\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to open changes because the specified diff tool cannot be found or no Git diff tool is configured',\n\t\t\t\t\tviewDocs,\n\t\t\t\t);\n\t\t\t\tif (result === viewDocs) {\n\t\t\t\t\tvoid env.openExternal(\n\t\t\t\t\t\tUri.parse('https://git-scm.com/docs/git-config#Documentation/git-config.txt-difftool'),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, 'openDiffTool');\n\t\t\tvoid showGenericErrorMessage('Unable to open compare');\n\t\t}\n\t}\n\n\t@log()\n\tasync openDirectoryCompare(repoPath: string, ref1: string, ref2?: string, tool?: string): Promise<void> {\n\t\ttry {\n\t\t\tif (!tool) {\n\t\t\t\tconst scope = getLogScope();\n\n\t\t\t\ttool = configuration.get('advanced.externalDirectoryDiffTool') || (await this.getDiffTool(repoPath));\n\t\t\t\tif (tool == null) throw new Error('No diff tool found');\n\n\t\t\t\tLogger.log(scope, `Using tool=${tool}`);\n\t\t\t}\n\n\t\t\tawait this.git.difftool__dir_diff(repoPath, tool, ref1, ref2);\n\t\t} catch (ex) {\n\t\t\tconst msg: string = ex?.toString() ?? '';\n\t\t\tif (msg === 'No diff tool found' || /Unknown .+? tool/.test(msg)) {\n\t\t\t\tconst viewDocs = 'View Git Docs';\n\t\t\t\tconst result = await window.showWarningMessage(\n\t\t\t\t\t'Unable to open directory compare because the specified diff tool cannot be found or no Git diff tool is configured',\n\t\t\t\t\tviewDocs,\n\t\t\t\t);\n\t\t\t\tif (result === viewDocs) {\n\t\t\t\t\tvoid env.openExternal(\n\t\t\t\t\t\tUri.parse('https://git-scm.com/docs/git-config#Documentation/git-config.txt-difftool'),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLogger.error(ex, 'openDirectoryCompare');\n\t\t\tvoid showGenericErrorMessage('Unable to open directory compare');\n\t\t}\n\t}\n\n\t@log()\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\tpathOrUri?: string | Uri,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t) {\n\t\tif (\n\t\t\t!ref ||\n\t\t\tref === deletedOrMissing ||\n\t\t\t(pathOrUri == null && isSha(ref)) ||\n\t\t\t(pathOrUri != null && isUncommitted(ref))\n\t\t) {\n\t\t\treturn ref;\n\t\t}\n\n\t\tif (pathOrUri == null) {\n\t\t\t// If it doesn't look like a sha at all (e.g. branch name) or is a stash ref (^3) don't try to resolve it\n\t\t\tif ((!options?.force && !isShaLike(ref)) || ref.endsWith('^3')) return ref;\n\n\t\t\treturn (await this.git.rev_parse__verify(repoPath, ref)) ?? ref;\n\t\t}\n\n\t\tconst relativePath = this.getRelativePath(pathOrUri, repoPath);\n\n\t\tlet cancellation: TimedCancellationSource | undefined;\n\t\tif (options?.timeout != null) {\n\t\t\tcancellation = new TimedCancellationSource(options.timeout);\n\t\t}\n\n\t\tconst [verifiedResult, resolvedResult] = await Promise.allSettled([\n\t\t\tthis.git.rev_parse__verify(repoPath, ref, relativePath),\n\t\t\tthis.git.log__file_recent(repoPath, relativePath, {\n\t\t\t\tref: ref,\n\t\t\t\tcancellation: cancellation?.token,\n\t\t\t}),\n\t\t]);\n\n\t\tconst verified = getSettledValue(verifiedResult);\n\t\tif (verified == null) return deletedOrMissing;\n\n\t\tconst resolved = getSettledValue(resolvedResult);\n\n\t\tconst cancelled = cancellation?.token.isCancellationRequested;\n\t\tcancellation?.dispose();\n\n\t\treturn cancelled ? ref : resolved ?? ref;\n\t}\n\n\t@log<LocalGitProvider['richSearchCommits']>({\n\t\targs: {\n\t\t\t1: s =>\n\t\t\t\t`[${s.matchAll ? 'A' : ''}${s.matchCase ? 'C' : ''}${s.matchRegex ? 'R' : ''}]: ${\n\t\t\t\t\ts.query.length > 500 ? `${s.query.substring(0, 500)}...` : s.query\n\t\t\t\t}`,\n\t\t},\n\t})\n\tasync richSearchCommits(\n\t\trepoPath: string,\n\t\tsearch: SearchQuery,\n\t\toptions?: { limit?: number; ordering?: 'date' | 'author-date' | 'topo' | null; skip?: number },\n\t): Promise<GitLog | undefined> {\n\t\tsearch = { matchAll: false, matchCase: false, matchRegex: true, ...search };\n\n\t\ttry {\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst currentUser = await this.getCurrentUser(repoPath);\n\n\t\t\tconst { args, files, shas } = getGitArgsFromSearchQuery(search, currentUser);\n\n\t\t\targs.push(`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`, '--');\n\t\t\tif (files.length !== 0) {\n\t\t\t\targs.push(...files);\n\t\t\t}\n\n\t\t\tlet stashes: Map<string, GitStashCommit> | undefined;\n\t\t\tlet stdin: string | undefined;\n\t\t\tif (shas == null) {\n\t\t\t\tconst stash = await this.getStash(repoPath);\n\t\t\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\t\t\tif (stash?.commits.size) {\n\t\t\t\t\tstashes = new Map();\n\t\t\t\t\tfor (const commit of stash.commits.values()) {\n\t\t\t\t\t\tstashes.set(commit.sha, commit);\n\t\t\t\t\t\tfor (const p of commit.parents) {\n\t\t\t\t\t\t\tstashes.set(p, commit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstdin = join(\n\t\t\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t\t\t'\\n',\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst data = await this.git.log__search(repoPath, shas?.size ? undefined : args, {\n\t\t\t\tordering: configuration.get('advanced.commitOrdering'),\n\t\t\t\t...options,\n\t\t\t\tlimit: limit,\n\t\t\t\tshas: shas,\n\t\t\t\tstdin: stdin,\n\t\t\t});\n\t\t\tconst log = GitLogParser.parse(\n\t\t\t\tthis.container,\n\t\t\t\tdata,\n\t\t\t\tLogType.Log,\n\t\t\t\trepoPath,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tcurrentUser,\n\t\t\t\tlimit,\n\t\t\t\tfalse,\n\t\t\t\tundefined,\n\t\t\t\tstashes,\n\t\t\t);\n\n\t\t\tif (log != null) {\n\t\t\t\tfunction richSearchCommitsCore(\n\t\t\t\t\tthis: LocalGitProvider,\n\t\t\t\t\tlog: GitLog,\n\t\t\t\t): (limit: number | undefined) => Promise<GitLog> {\n\t\t\t\t\treturn async (limit: number | undefined) => {\n\t\t\t\t\t\tlimit = limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\n\t\t\t\t\t\tconst moreLog = await this.richSearchCommits(log.repoPath, search, {\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\tlimit: limit,\n\t\t\t\t\t\t\tskip: log.count,\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// If we can't find any more, assume we have everything\n\t\t\t\t\t\tif (moreLog == null) return { ...log, hasMore: false, more: undefined };\n\n\t\t\t\t\t\tconst commits = new Map([...log.commits, ...moreLog.commits]);\n\n\t\t\t\t\t\tconst mergedLog: GitLog = {\n\t\t\t\t\t\t\trepoPath: log.repoPath,\n\t\t\t\t\t\t\tcommits: commits,\n\t\t\t\t\t\t\tsha: log.sha,\n\t\t\t\t\t\t\trange: log.range,\n\t\t\t\t\t\t\tcount: commits.size,\n\t\t\t\t\t\t\tlimit: (log.limit ?? 0) + limit,\n\t\t\t\t\t\t\thasMore: moreLog.hasMore,\n\t\t\t\t\t\t\tquery: (limit: number | undefined) =>\n\t\t\t\t\t\t\t\tthis.richSearchCommits(log.repoPath, search, { ...options, limit: limit }),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (mergedLog.hasMore) {\n\t\t\t\t\t\t\tmergedLog.more = richSearchCommitsCore.call(this, mergedLog);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn mergedLog;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tlog.query = (limit: number | undefined) =>\n\t\t\t\t\tthis.richSearchCommits(repoPath, search, { ...options, limit: limit });\n\t\t\t\tif (log.hasMore) {\n\t\t\t\t\tlog.more = richSearchCommitsCore.call(this, log);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn log;\n\t\t} catch (ex) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync searchCommits(\n\t\trepoPath: string,\n\t\tsearch: SearchQuery,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo';\n\t\t},\n\t): Promise<GitSearch> {\n\t\tsearch = { matchAll: false, matchCase: false, matchRegex: true, ...search };\n\n\t\tconst comparisonKey = getSearchQueryComparisonKey(search);\n\t\ttry {\n\t\t\tconst refAndDateParser = getRefAndDateParser();\n\n\t\t\tconst currentUser = search.query.includes('@me') ? await this.getCurrentUser(repoPath) : undefined;\n\n\t\t\tconst { args: searchArgs, files, shas } = getGitArgsFromSearchQuery(search, currentUser);\n\t\t\tif (shas?.size) {\n\t\t\t\tconst data = await this.git.show2(\n\t\t\t\t\trepoPath,\n\t\t\t\t\t{ cancellation: options?.cancellation },\n\t\t\t\t\t'-s',\n\t\t\t\t\t...refAndDateParser.arguments,\n\t\t\t\t\t...shas.values(),\n\t\t\t\t\t...searchArgs,\n\t\t\t\t\t'--',\n\t\t\t\t);\n\n\t\t\t\tlet i = 0;\n\t\t\t\tconst results: GitSearchResults = new Map<string, GitSearchResultData>(\n\t\t\t\t\tmap(refAndDateParser.parse(data), c => [\n\t\t\t\t\t\tc.sha,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti: i++,\n\t\t\t\t\t\t\tdate: Number(options?.ordering === 'author-date' ? c.authorDate : c.committerDate) * 1000,\n\t\t\t\t\t\t},\n\t\t\t\t\t]),\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tquery: search,\n\t\t\t\t\tcomparisonKey: comparisonKey,\n\t\t\t\t\tresults: results,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst limit = options?.limit ?? configuration.get('advanced.maxSearchItems') ?? 0;\n\t\t\tconst similarityThreshold = configuration.get('advanced.similarityThreshold');\n\n\t\t\tconst stash = await this.getStash(repoPath);\n\t\t\tlet stdin: string | undefined;\n\t\t\t// TODO@eamodio this is insanity -- there *HAS* to be a better way to get git log to return stashes\n\t\t\tif (stash?.commits.size) {\n\t\t\t\tstdin = join(\n\t\t\t\t\tmap(stash.commits.values(), c => c.sha.substring(0, 9)),\n\t\t\t\t\t'\\n',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst args = [\n\t\t\t\t...refAndDateParser.arguments,\n\t\t\t\t`-M${similarityThreshold == null ? '' : `${similarityThreshold}%`}`,\n\t\t\t\t'--use-mailmap',\n\t\t\t];\n\n\t\t\tconst results: GitSearchResults = new Map<string, GitSearchResultData>();\n\t\t\tlet total = 0;\n\n\t\t\tasync function searchForCommitsCore(\n\t\t\t\tthis: LocalGitProvider,\n\t\t\t\tlimit: number,\n\t\t\t\tcursor?: { sha: string; skip: number },\n\t\t\t): Promise<GitSearch> {\n\t\t\t\tif (options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t}\n\n\t\t\t\tlet data;\n\t\t\t\ttry {\n\t\t\t\t\tdata = await this.git.log2(\n\t\t\t\t\t\trepoPath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcancellation: options?.cancellation,\n\t\t\t\t\t\t\tconfigs: ['-C', repoPath, ...gitLogDefaultConfigs],\n\t\t\t\t\t\t\terrors: GitErrorHandling.Throw,\n\t\t\t\t\t\t\tstdin: stdin,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...args,\n\t\t\t\t\t\t...searchArgs,\n\t\t\t\t\t\t...(options?.ordering ? [`--${options.ordering}-order`] : emptyArray),\n\t\t\t\t\t\t...(limit ? [`-n${limit + 1}`] : emptyArray),\n\t\t\t\t\t\t...(cursor?.skip ? [`--skip=${cursor.skip}`] : emptyArray),\n\t\t\t\t\t\t'--',\n\t\t\t\t\t\t...files,\n\t\t\t\t\t);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof CancelledRunError || options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new GitSearchError(ex);\n\t\t\t\t}\n\n\t\t\t\tif (options?.cancellation?.isCancellationRequested) {\n\t\t\t\t\treturn { repoPath: repoPath, query: search, comparisonKey: comparisonKey, results: results };\n\t\t\t\t}\n\n\t\t\t\tlet count = total;\n\n\t\t\t\tfor (const r of refAndDateParser.parse(data)) {\n\t\t\t\t\tif (results.has(r.sha)) {\n\t\t\t\t\t\tlimit--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tresults.set(r.sha, {\n\t\t\t\t\t\ti: total++,\n\t\t\t\t\t\tdate: Number(options?.ordering === 'author-date' ? r.authorDate : r.committerDate) * 1000,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcount = total - count;\n\t\t\t\tconst lastSha = last(results)?.[0];\n\t\t\t\tcursor =\n\t\t\t\t\tlastSha != null\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tsha: lastSha,\n\t\t\t\t\t\t\t\tskip: total,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\treturn {\n\t\t\t\t\trepoPath: repoPath,\n\t\t\t\t\tquery: search,\n\t\t\t\t\tcomparisonKey: comparisonKey,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tpaging:\n\t\t\t\t\t\tlimit !== 0 && count > limit\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tlimit: limit,\n\t\t\t\t\t\t\t\t\thasMore: true,\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\tmore: async (limit: number): Promise<GitSearch> => searchForCommitsCore.call(this, limit, cursor),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn searchForCommitsCore.call(this, limit);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof GitSearchError) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tthrow new GitSearchError(ex);\n\t\t}\n\t}\n\n\t@log({ args: { 2: false } })\n\tasync runGitCommandViaTerminal(\n\t\trepoPath: string,\n\t\tcommand: string,\n\t\targs: string[],\n\t\toptions?: { execute?: boolean },\n\t): Promise<void> {\n\t\tawait this.git.runGitCommandViaTerminal(repoPath, command, args, options);\n\n\t\t// Right now we are reliant on the Repository class to fire the change event (as a stop gap if we don't detect a change through the normal mechanisms)\n\t\t// setTimeout(() => this.fireChange(RepositoryChange.Unknown), 2500);\n\t}\n\n\t@log()\n\tvalidateBranchOrTagName(repoPath: string, ref: string): Promise<boolean> {\n\t\treturn this.git.check_ref_format(ref, repoPath);\n\t}\n\n\t@log()\n\tasync validateReference(repoPath: string, ref: string): Promise<boolean> {\n\t\tif (ref == null || ref.length === 0) return false;\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return true;\n\n\t\treturn (await this.git.rev_parse__verify(repoPath, ref)) != null;\n\t}\n\n\t@log()\n\tasync stageFile(repoPath: string, pathOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.add(repoPath, typeof pathOrUri === 'string' ? pathOrUri : splitPath(pathOrUri, repoPath)[0]);\n\t}\n\n\t@log()\n\tasync stageDirectory(repoPath: string, directoryOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.add(\n\t\t\trepoPath,\n\t\t\ttypeof directoryOrUri === 'string' ? directoryOrUri : splitPath(directoryOrUri, repoPath)[0],\n\t\t);\n\t}\n\n\t@log()\n\tasync unStageFile(repoPath: string, pathOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.reset(repoPath, typeof pathOrUri === 'string' ? pathOrUri : splitPath(pathOrUri, repoPath)[0]);\n\t}\n\n\t@log()\n\tasync unStageDirectory(repoPath: string, directoryOrUri: string | Uri): Promise<void> {\n\t\tawait this.git.reset(\n\t\t\trepoPath,\n\t\t\ttypeof directoryOrUri === 'string' ? directoryOrUri : splitPath(directoryOrUri, repoPath)[0],\n\t\t);\n\t}\n\n\t@log()\n\tasync stashApply(repoPath: string, stashName: string, options?: { deleteAfter?: boolean }): Promise<void> {\n\t\ttry {\n\t\t\tawait this.git.stash__apply(repoPath, stashName, Boolean(options?.deleteAfter));\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Error) {\n\t\t\t\tconst msg: string = ex.message ?? '';\n\t\t\t\tif (msg.includes('Your local changes to the following files would be overwritten by merge')) {\n\t\t\t\t\tthrow new StashApplyError(StashApplyErrorReason.WorkingChanges, ex);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(msg.includes('Auto-merging') && msg.includes('CONFLICT')) ||\n\t\t\t\t\t(ex instanceof RunError &&\n\t\t\t\t\t\t((ex.stdout.includes('Auto-merging') && ex.stdout.includes('CONFLICT')) ||\n\t\t\t\t\t\t\tex.stdout.includes('needs merge')))\n\t\t\t\t) {\n\t\t\t\t\tvoid window.showInformationMessage('Stash applied with conflicts');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow new StashApplyError(`Unable to apply stash \\u2014 ${msg.trim().replace(/\\n+?/g, '; ')}`, ex);\n\t\t\t}\n\n\t\t\tthrow new StashApplyError(`Unable to apply stash \\u2014 ${String(ex)}`, ex);\n\t\t}\n\t}\n\n\t@log()\n\tasync stashDelete(repoPath: string, stashName: string, ref?: string): Promise<void> {\n\t\tawait this.git.stash__delete(repoPath, stashName, ref);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log()\n\tasync stashRename(\n\t\trepoPath: string,\n\t\tstashName: string,\n\t\tref: string,\n\t\tmessage: string,\n\t\tstashOnRef?: string,\n\t): Promise<void> {\n\t\tawait this.git.stash__rename(repoPath, stashName, ref, message, stashOnRef);\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log<LocalGitProvider['stashSave']>({ args: { 2: uris => uris?.length } })\n\tasync stashSave(\n\t\trepoPath: string,\n\t\tmessage?: string,\n\t\turis?: Uri[],\n\t\toptions?: { includeUntracked?: boolean; keepIndex?: boolean; onlyStaged?: boolean },\n\t): Promise<void> {\n\t\tif (uris == null) {\n\t\t\tawait this.git.stash__push(repoPath, message, options);\n\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes', 'status'] });\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.13.2',\n\t\t\t'Stashing individual files',\n\t\t\t' Please retry by stashing everything or install a more recent version of Git and try again.',\n\t\t);\n\n\t\tconst pathspecs = uris.map(u => `./${splitPath(u, repoPath)[0]}`);\n\n\t\tconst stdinVersion = '2.30.0';\n\t\tconst stdin = await this.git.isAtLeastVersion(stdinVersion);\n\t\t// If we don't support stdin, then error out if we are over the maximum allowed git cli length\n\t\tif (!stdin && countStringLength(pathspecs) > maxGitCliLength) {\n\t\t\tawait this.ensureGitVersion(\n\t\t\t\tstdinVersion,\n\t\t\t\t`Stashing so many files (${pathspecs.length}) at once`,\n\t\t\t\t' Please retry by stashing fewer files or install a more recent version of Git and try again.',\n\t\t\t);\n\t\t}\n\n\t\tawait this.git.stash__push(repoPath, message, {\n\t\t\t...options,\n\t\t\tpathspecs: pathspecs,\n\t\t\tstdin: stdin,\n\t\t});\n\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['stashes'] });\n\t}\n\n\t@log()\n\tasync createWorktree(\n\t\trepoPath: string,\n\t\tpath: string,\n\t\toptions?: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean },\n\t) {\n\t\ttry {\n\t\t\tawait this.git.worktree__add(repoPath, path, options);\n\t\t\tif (options?.createBranch) {\n\t\t\t\tthis.container.events.fire('git:cache:reset', { repoPath: repoPath, caches: ['branches'] });\n\t\t\t}\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\n\t\t\tconst msg = String(ex);\n\n\t\t\tif (GitErrors.alreadyCheckedOut.test(msg)) {\n\t\t\t\tthrow new WorktreeCreateError(WorktreeCreateErrorReason.AlreadyCheckedOut, ex);\n\t\t\t}\n\n\t\t\tif (GitErrors.alreadyExists.test(msg)) {\n\t\t\t\tthrow new WorktreeCreateError(WorktreeCreateErrorReason.AlreadyExists, ex);\n\t\t\t}\n\n\t\t\tthrow new WorktreeCreateError(undefined, ex);\n\t\t}\n\t}\n\n\t@gate()\n\t@log()\n\tasync getWorktrees(repoPath: string): Promise<GitWorktree[]> {\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.7.6',\n\t\t\t'Displaying worktrees',\n\t\t\t' Please install a more recent version of Git and try again.',\n\t\t);\n\n\t\tconst data = await this.git.worktree__list(repoPath);\n\t\treturn GitWorktreeParser.parse(data, repoPath);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/require-await\n\t@log()\n\tasync getWorktreesDefaultUri(repoPath: string): Promise<Uri | undefined> {\n\t\tlet location = configuration.get('worktrees.defaultLocation');\n\t\tif (location == null) return undefined;\n\n\t\tif (location.startsWith('~')) {\n\t\t\tlocation = joinPaths(homedir(), location.slice(1));\n\t\t}\n\n\t\tconst folder = this.container.git.getRepository(repoPath)?.folder;\n\t\tlocation = interpolate(location, {\n\t\t\tuserHome: homedir(),\n\t\t\tworkspaceFolder: folder?.uri.fsPath,\n\t\t\tworkspaceFolderBasename: folder?.name,\n\t\t});\n\n\t\treturn this.getAbsoluteUri(location, repoPath);\n\t}\n\n\t@log()\n\tasync deleteWorktree(repoPath: string, path: string, options?: { force?: boolean }) {\n\t\tawait this.ensureGitVersion(\n\t\t\t'2.17.0',\n\t\t\t'Deleting worktrees',\n\t\t\t' Please install a more recent version of Git and try again.',\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.git.worktree__remove(repoPath, path, options);\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex);\n\n\t\t\tconst msg = String(ex);\n\n\t\t\tif (GitErrors.mainWorkingTree.test(msg)) {\n\t\t\t\tthrow new WorktreeDeleteError(WorktreeDeleteErrorReason.MainWorkingTree, ex);\n\t\t\t}\n\n\t\t\tif (GitErrors.uncommittedChanges.test(msg)) {\n\t\t\t\tthrow new WorktreeDeleteError(WorktreeDeleteErrorReason.HasChanges, ex);\n\t\t\t}\n\n\t\t\tthrow new WorktreeDeleteError(undefined, ex);\n\t\t}\n\t}\n\n\tprivate _scmGitApi: Promise<BuiltInGitApi | undefined> | undefined;\n\tprivate async getScmGitApi(): Promise<BuiltInGitApi | undefined> {\n\t\treturn this._scmGitApi ?? (this._scmGitApi = this.getScmGitApiCore());\n\t}\n\n\t@log()\n\tprivate async getScmGitApiCore(): Promise<BuiltInGitApi | undefined> {\n\t\ttry {\n\t\t\tconst extension = extensions.getExtension<GitExtension>('vscode.git');\n\t\t\tif (extension == null) return undefined;\n\n\t\t\tconst gitExtension = extension.isActive ? extension.exports : await extension.activate();\n\t\t\treturn gitExtension?.getAPI(1);\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate getScmGitUri(path: string, repoPath: string): Uri {\n\t\t// If the repoPath is a canonical path, then we need to remap it to the real path, because the vscode.git extension always uses the real path\n\t\tconst realUri = this.fromCanonicalMap.get(repoPath);\n\t\tconst uri = this.getAbsoluteUri(path, realUri ?? repoPath);\n\n\t\treturn Uri.from({\n\t\t\tscheme: Schemes.Git,\n\t\t\tpath: uri.path,\n\t\t\tquery: JSON.stringify({\n\t\t\t\t// Ensure we use the fsPath here, otherwise the url won't open properly\n\t\t\t\tpath: uri.fsPath,\n\t\t\t\tref: '~',\n\t\t\t}),\n\t\t});\n\t}\n\n\t@log()\n\tasync getOpenScmRepositories(): Promise<ScmRepository[]> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn gitApi?.repositories ?? [];\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t@log()\n\tasync getScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn gitApi?.getRepository(Uri.file(repoPath)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getOrOpenScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\tif (gitApi?.openRepository != null) {\n\t\t\t\treturn (await gitApi?.openRepository?.(Uri.file(repoPath))) ?? undefined;\n\t\t\t}\n\n\t\t\treturn gitApi?.getRepository(Uri.file(repoPath)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tprivate async openScmRepository(uri: Uri): Promise<BuiltInGitRepository | undefined> {\n\t\tconst scope = getLogScope();\n\t\ttry {\n\t\t\tconst gitApi = await this.getScmGitApi();\n\t\t\treturn (await gitApi?.openRepository?.(uri)) ?? undefined;\n\t\t} catch (ex) {\n\t\t\tLogger.error(ex, scope);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate async ensureGitVersion(version: string, prefix: string, suffix: string): Promise<void> {\n\t\tif (await this.git.isAtLeastVersion(version)) return;\n\n\t\tthrow new Error(\n\t\t\t`${prefix} requires a newer version of Git (>= ${version}) than is currently installed (${await this.git.version()}).${suffix}`,\n\t\t);\n\t}\n}\n\nasync function getEncoding(uri: Uri): Promise<string> {\n\tconst encoding = configuration.getAny<CoreConfiguration, string>('files.encoding', uri);\n\tif (encoding == null || encoding === 'utf8') return 'utf8';\n\n\tconst encodingExists = (await import(/* webpackChunkName: \"encoding\" */ 'iconv-lite')).encodingExists;\n\treturn encodingExists(encoding) ? encoding : 'utf8';\n}\n", "export class GitSearchError extends Error {\n\tconstructor(public readonly original: Error) {\n\t\tsuper(original.message);\n\n\t\tError.captureStackTrace?.(this, GitSearchError);\n\t}\n}\n\nexport const enum StashApplyErrorReason {\n\tWorkingChanges = 1,\n}\n\nexport class StashApplyError extends Error {\n\tstatic is(ex: any, reason?: StashApplyErrorReason): ex is StashApplyError {\n\t\treturn ex instanceof StashApplyError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: StashApplyErrorReason | undefined;\n\n\tconstructor(reason?: StashApplyErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | StashApplyErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: StashApplyErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to apply stash';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tmessage =\n\t\t\t\t'Unable to apply stash. Your working tree changes would be overwritten. Please commit or stash your changes before trying again';\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, StashApplyError);\n\t}\n}\n\nexport const enum StashPushErrorReason {\n\tConflictingStagedAndUnstagedLines = 1,\n}\n\nexport class StashPushError extends Error {\n\tstatic is(ex: any, reason?: StashPushErrorReason): ex is StashPushError {\n\t\treturn ex instanceof StashPushError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: StashPushErrorReason | undefined;\n\n\tconstructor(reason?: StashPushErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | StashPushErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: StashPushErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to stash';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase StashPushErrorReason.ConflictingStagedAndUnstagedLines:\n\t\t\t\t\tmessage =\n\t\t\t\t\t\t'Stash was created, but the working tree cannot be updated because at least one file has staged and unstaged changes on the same line(s).\\n\\nDo you want to try again by stashing both your staged and unstaged changes?';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmessage = 'Unable to stash';\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, StashApplyError);\n\t}\n}\n\nexport class WorkspaceUntrustedError extends Error {\n\tconstructor() {\n\t\tsuper('Unable to perform Git operations because the current workspace is untrusted');\n\n\t\tError.captureStackTrace?.(this, WorkspaceUntrustedError);\n\t}\n}\n\nexport const enum WorktreeCreateErrorReason {\n\tAlreadyCheckedOut = 1,\n\tAlreadyExists = 2,\n}\n\nexport class WorktreeCreateError extends Error {\n\tstatic is(ex: any, reason?: WorktreeCreateErrorReason): ex is WorktreeCreateError {\n\t\treturn ex instanceof WorktreeCreateError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: WorktreeCreateErrorReason | undefined;\n\n\tconstructor(reason?: WorktreeCreateErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | WorktreeCreateErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: WorktreeCreateErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to create worktree';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase WorktreeCreateErrorReason.AlreadyCheckedOut:\n\t\t\t\t\tmessage = 'Unable to create worktree because it is already checked out';\n\t\t\t\t\tbreak;\n\t\t\t\tcase WorktreeCreateErrorReason.AlreadyExists:\n\t\t\t\t\tmessage = 'Unable to create worktree because it already exists';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, WorktreeCreateError);\n\t}\n}\n\nexport const enum WorktreeDeleteErrorReason {\n\tHasChanges = 1,\n\tMainWorkingTree = 2,\n}\n\nexport class WorktreeDeleteError extends Error {\n\tstatic is(ex: any, reason?: WorktreeDeleteErrorReason): ex is WorktreeDeleteError {\n\t\treturn ex instanceof WorktreeDeleteError && (reason == null || ex.reason === reason);\n\t}\n\n\treadonly original?: Error;\n\treadonly reason: WorktreeDeleteErrorReason | undefined;\n\n\tconstructor(reason?: WorktreeDeleteErrorReason, original?: Error);\n\tconstructor(message?: string, original?: Error);\n\tconstructor(messageOrReason: string | WorktreeDeleteErrorReason | undefined, original?: Error) {\n\t\tlet message;\n\t\tlet reason: WorktreeDeleteErrorReason | undefined;\n\t\tif (messageOrReason == null) {\n\t\t\tmessage = 'Unable to delete worktree';\n\t\t} else if (typeof messageOrReason === 'string') {\n\t\t\tmessage = messageOrReason;\n\t\t\treason = undefined;\n\t\t} else {\n\t\t\treason = messageOrReason;\n\t\t\tswitch (reason) {\n\t\t\t\tcase WorktreeDeleteErrorReason.HasChanges:\n\t\t\t\t\tmessage = 'Unable to delete worktree because there are uncommitted changes';\n\t\t\t\t\tbreak;\n\t\t\t\tcase WorktreeDeleteErrorReason.MainWorkingTree:\n\t\t\t\t\tmessage = 'Unable to delete worktree because it is a main working tree';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper(message);\n\n\t\tthis.original = original;\n\t\tthis.reason = reason;\n\t\tError.captureStackTrace?.(this, WorktreeDeleteError);\n\t}\n}\n", "import type {\n\tCancellationToken,\n\tConfigurationChangeEvent,\n\tEvent,\n\tRange,\n\tTextDocument,\n\tTextEditor,\n\tWindowState,\n\tWorkspaceFolder,\n\tWorkspaceFoldersChangeEvent,\n} from 'vscode';\nimport { Disposable, EventEmitter, FileType, ProgressLocation, Uri, window, workspace } from 'vscode';\nimport { isWeb } from '@env/platform';\nimport { resetAvatarCache } from '../avatars';\nimport type { CoreGitConfiguration } from '../constants';\nimport { GlyphChars, Schemes } from '../constants';\nimport type { Container } from '../container';\nimport { AccessDeniedError, ProviderNotFoundError } from '../errors';\nimport type { FeatureAccess, Features, PlusFeatures, RepoFeatureAccess } from '../features';\nimport type { SubscriptionChangeEvent } from '../plus/subscription/subscriptionService';\nimport type { RepoComparisonKey } from '../repositories';\nimport { asRepoComparisonKey, Repositories } from '../repositories';\nimport type { Subscription } from '../subscription';\nimport { isSubscriptionPaidPlan, SubscriptionPlanId } from '../subscription';\nimport { groupByFilterMap, groupByMap, joinUnique } from '../system/array';\nimport { registerCommand } from '../system/command';\nimport { configuration } from '../system/configuration';\nimport { setContext } from '../system/context';\nimport { gate } from '../system/decorators/gate';\nimport { debug, log } from '../system/decorators/log';\nimport type { Deferrable } from '../system/function';\nimport { debounce } from '../system/function';\nimport { count, filter, first, flatMap, join, map, some } from '../system/iterable';\nimport { Logger } from '../system/logger';\nimport { getLogScope, setLogScopeExit } from '../system/logger.scope';\nimport { getBestPath, getScheme, isAbsolute, maybeUri, normalizePath } from '../system/path';\nimport { asSettled, cancellable, getSettledValue, isPromise, PromiseCancelledError } from '../system/promise';\nimport { VisitedPathsTrie } from '../system/trie';\nimport type {\n\tGitCaches,\n\tGitDir,\n\tGitProvider,\n\tGitProviderDescriptor,\n\tGitProviderId,\n\tNextComparisonUrisResult,\n\tPagedResult,\n\tPreviousComparisonUrisResult,\n\tPreviousLineComparisonUrisResult,\n\tRepositoryVisibilityInfo,\n\tScmRepository,\n} from './gitProvider';\nimport { RepositoryVisibility } from './gitProvider';\nimport type { GitUri } from './gitUri';\nimport type { GitBlame, GitBlameLine, GitBlameLines } from './models/blame';\nimport type { BranchSortOptions, GitBranch } from './models/branch';\nimport { GitCommit, GitCommitIdentity } from './models/commit';\nimport { deletedOrMissing, uncommitted, uncommittedStaged } from './models/constants';\nimport type { GitContributor } from './models/contributor';\nimport type { GitDiff, GitDiffFilter, GitDiffHunkLine, GitDiffShortStat } from './models/diff';\nimport type { GitFile } from './models/file';\nimport type { GitGraph } from './models/graph';\nimport type { SearchedIssue } from './models/issue';\nimport type { GitLog } from './models/log';\nimport type { GitMergeStatus } from './models/merge';\nimport type { PullRequest, PullRequestState, SearchedPullRequest } from './models/pullRequest';\nimport type { GitRebaseStatus } from './models/rebase';\nimport type { GitBranchReference, GitReference } from './models/reference';\nimport { createRevisionRange, isSha, isUncommitted, isUncommittedParent } from './models/reference';\nimport type { GitReflog } from './models/reflog';\nimport { GitRemote } from './models/remote';\nimport type { RepositoryChangeEvent } from './models/repository';\nimport { Repository, RepositoryChange, RepositoryChangeComparisonMode } from './models/repository';\nimport type { GitStash } from './models/stash';\nimport type { GitStatus, GitStatusFile } from './models/status';\nimport type { GitTag, TagSortOptions } from './models/tag';\nimport type { GitTreeEntry } from './models/tree';\nimport type { GitUser } from './models/user';\nimport type { GitWorktree } from './models/worktree';\nimport type { RemoteProvider } from './remotes/remoteProvider';\nimport type { RemoteProviders } from './remotes/remoteProviders';\nimport type { RichRemoteProvider } from './remotes/richRemoteProvider';\nimport type { GitSearch, SearchQuery } from './search';\n\nconst emptyArray = Object.freeze([]) as unknown as any[];\nconst emptyDisposable = Object.freeze({\n\tdispose: () => {\n\t\t/* noop */\n\t},\n});\n\nconst maxDefaultBranchWeight = 100;\nconst weightedDefaultBranches = new Map<string, number>([\n\t['master', maxDefaultBranchWeight],\n\t['main', 15],\n\t['default', 10],\n\t['develop', 5],\n\t['development', 1],\n]);\n\nconst defaultRepositoryId = '0';\n\nexport type GitProvidersChangeEvent = {\n\treadonly added: readonly GitProvider[];\n\treadonly removed: readonly GitProvider[];\n\treadonly etag: number;\n};\n\nexport type RepositoriesChangeEvent = {\n\treadonly added: readonly Repository[];\n\treadonly removed: readonly Repository[];\n\treadonly etag: number;\n};\n\nexport interface GitProviderResult {\n\tprovider: GitProvider;\n\tpath: string;\n}\n\nexport const enum RepositoriesVisibility {\n\tPrivate = 'private',\n\tPublic = 'public',\n\tLocal = 'local',\n\tMixed = 'mixed',\n}\n\nexport class GitProviderService implements Disposable {\n\tprivate readonly _onDidChangeProviders = new EventEmitter<GitProvidersChangeEvent>();\n\tget onDidChangeProviders(): Event<GitProvidersChangeEvent> {\n\t\treturn this._onDidChangeProviders.event;\n\t}\n\tprivate fireProvidersChanged(added?: GitProvider[], removed?: GitProvider[]) {\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'providers.count': this._providers.size,\n\t\t\t\t'providers.ids': join(this._providers.keys(), ','),\n\t\t\t});\n\t\t\tthis.container.telemetry.sendEvent('providers/changed', {\n\t\t\t\t'providers.added': added?.length ?? 0,\n\t\t\t\t'providers.removed': removed?.length ?? 0,\n\t\t\t});\n\t\t}\n\n\t\tthis._etag = Date.now();\n\n\t\tthis._onDidChangeProviders.fire({ added: added ?? [], removed: removed ?? [], etag: this._etag });\n\t}\n\n\tprivate _onDidChangeRepositories = new EventEmitter<RepositoriesChangeEvent>();\n\tget onDidChangeRepositories(): Event<RepositoriesChangeEvent> {\n\t\treturn this._onDidChangeRepositories.event;\n\t}\n\tprivate fireRepositoriesChanged(added?: Repository[], removed?: Repository[]) {\n\t\tconst openSchemes = this.openRepositories.map(r => r.uri.scheme);\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'repositories.count': openSchemes.length,\n\t\t\t\t'repositories.schemes': joinUnique(openSchemes, ','),\n\t\t\t});\n\t\t\tthis.container.telemetry.sendEvent('repositories/changed', {\n\t\t\t\t'repositories.added': added?.length ?? 0,\n\t\t\t\t'repositories.removed': removed?.length ?? 0,\n\t\t\t});\n\t\t}\n\n\t\tthis._etag = Date.now();\n\n\t\tthis._accessCache.clear();\n\t\tthis._reposVisibilityCache = undefined;\n\n\t\tthis._onDidChangeRepositories.fire({ added: added ?? [], removed: removed ?? [], etag: this._etag });\n\n\t\tif (added?.length && this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(async () => {\n\t\t\t\tfor (const repo of added) {\n\t\t\t\t\tconst remoteProviders = new Set<string>();\n\n\t\t\t\t\tconst remotes = await repo.getRemotes();\n\t\t\t\t\tfor (const remote of remotes) {\n\t\t\t\t\t\tremoteProviders.add(remote.provider?.id ?? 'unknown');\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.container.telemetry.sendEvent('repository/opened', {\n\t\t\t\t\t\t'repository.id': repo.idHash,\n\t\t\t\t\t\t'repository.scheme': repo.uri.scheme,\n\t\t\t\t\t\t'repository.closed': repo.closed,\n\t\t\t\t\t\t'repository.folder.scheme': repo.folder?.uri.scheme,\n\t\t\t\t\t\t'repository.provider.id': repo.provider.id,\n\t\t\t\t\t\t'repository.remoteProviders': join(remoteProviders, ','),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate readonly _onDidChangeRepository = new EventEmitter<RepositoryChangeEvent>();\n\tget onDidChangeRepository(): Event<RepositoryChangeEvent> {\n\t\treturn this._onDidChangeRepository.event;\n\t}\n\n\treadonly supportedSchemes = new Set<string>();\n\n\tprivate readonly _disposable: Disposable;\n\tprivate readonly _pendingRepositories = new Map<RepoComparisonKey, Promise<Repository | undefined>>();\n\tprivate readonly _providers = new Map<GitProviderId, GitProvider>();\n\tprivate readonly _repositories = new Repositories();\n\tprivate readonly _bestRemotesCache: Map<RepoComparisonKey, GitRemote<RemoteProvider | RichRemoteProvider> | null> &\n\t\tMap<`rich|${RepoComparisonKey}`, GitRemote<RichRemoteProvider> | null> &\n\t\tMap<`rich+connected|${RepoComparisonKey}`, GitRemote<RichRemoteProvider> | null> = new Map();\n\tprivate readonly _visitedPaths = new VisitedPathsTrie();\n\n\tconstructor(private readonly container: Container) {\n\t\tthis._disposable = Disposable.from(\n\t\t\tcontainer.subscription.onDidChange(this.onSubscriptionChanged, this),\n\t\t\twindow.onDidChangeWindowState(this.onWindowStateChanged, this),\n\t\t\tworkspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged, this),\n\t\t\tconfiguration.onDidChange(this.onConfigurationChanged, this),\n\t\t\tcontainer.richRemoteProviders.onDidChangeConnectionState(e => {\n\t\t\t\tif (e.reason === 'connected') {\n\t\t\t\t\tresetAvatarCache('failed');\n\t\t\t\t}\n\n\t\t\t\tthis.resetCaches('providers');\n\t\t\t\tthis.updateContext();\n\t\t\t}),\n\t\t\t!workspace.isTrusted\n\t\t\t\t? workspace.onDidGrantWorkspaceTrust(() => {\n\t\t\t\t\t\tif (workspace.isTrusted && workspace.workspaceFolders?.length) {\n\t\t\t\t\t\t\tvoid this.discoverRepositories(workspace.workspaceFolders, { force: true });\n\t\t\t\t\t\t}\n\t\t\t\t  })\n\t\t\t\t: emptyDisposable,\n\t\t\t...this.registerCommands(),\n\t\t);\n\n\t\tthis.container.BranchDateFormatting.reset();\n\t\tthis.container.CommitDateFormatting.reset();\n\t\tthis.container.CommitShaFormatting.reset();\n\t\tthis.container.PullRequestDateFormatting.reset();\n\n\t\tthis.updateContext();\n\t}\n\n\tdispose() {\n\t\tthis._disposable.dispose();\n\t\tthis._providers.clear();\n\n\t\tthis._repositories.forEach(r => r.dispose());\n\t\tthis._repositories.clear();\n\t}\n\n\tprivate _etag: number = 0;\n\tget etag(): number {\n\t\treturn this._etag;\n\t}\n\n\tprivate onConfigurationChanged(e?: ConfigurationChangeEvent) {\n\t\tif (\n\t\t\tconfiguration.changed(e, 'defaultDateFormat') ||\n\t\t\tconfiguration.changed(e, 'defaultDateSource') ||\n\t\t\tconfiguration.changed(e, 'defaultDateStyle')\n\t\t) {\n\t\t\tthis.container.BranchDateFormatting.reset();\n\t\t\tthis.container.CommitDateFormatting.reset();\n\t\t\tthis.container.PullRequestDateFormatting.reset();\n\t\t}\n\n\t\tif (configuration.changed(e, 'advanced.abbreviatedShaLength')) {\n\t\t\tthis.container.CommitShaFormatting.reset();\n\t\t}\n\n\t\tif (configuration.changed(e, 'views.contributors.showAllBranches')) {\n\t\t\tthis.resetCaches('contributors');\n\t\t}\n\n\t\tif (e != null && configuration.changed(e, 'integrations.enabled')) {\n\t\t\tthis.updateContext();\n\t\t}\n\t}\n\n\tprivate registerCommands(): Disposable[] {\n\t\treturn [\n\t\t\tregisterCommand('gitlens.plus.resetRepositoryAccess', () => this.clearAllRepoVisibilityCaches()),\n\t\t\tregisterCommand('gitlens.plus.refreshRepositoryAccess', () => this.clearAllOpenRepoVisibilityCaches()),\n\t\t];\n\t}\n\n\t@debug()\n\tonSubscriptionChanged(e: SubscriptionChangeEvent) {\n\t\tthis._accessCache.clear();\n\t\tthis._subscription = e.current;\n\t}\n\n\t@debug<GitProviderService['onWindowStateChanged']>({ args: { 0: e => `focused=${e.focused}` } })\n\tprivate onWindowStateChanged(e: WindowState) {\n\t\tif (e.focused) {\n\t\t\tthis._repositories.forEach(r => r.resume());\n\t\t} else {\n\t\t\tthis._repositories.forEach(r => r.suspend());\n\t\t}\n\t}\n\n\t@debug<GitProviderService['onWorkspaceFoldersChanged']>({\n\t\targs: { 0: e => `added=${e.added.length}, removed=${e.removed.length}` },\n\t\tsingleLine: true,\n\t})\n\tprivate onWorkspaceFoldersChanged(e: WorkspaceFoldersChangeEvent) {\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tconst schemes = workspace.workspaceFolders?.map(f => f.uri.scheme);\n\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t'folders.count': schemes?.length ?? 0,\n\t\t\t\t'folders.schemes': schemes != null ? joinUnique(schemes, ', ') : '',\n\t\t\t});\n\t\t}\n\n\t\tif (e.added.length) {\n\t\t\tvoid this.discoverRepositories(e.added);\n\t\t}\n\n\t\tif (e.removed.length) {\n\t\t\tconst removed: Repository[] = [];\n\n\t\t\tfor (const folder of e.removed) {\n\t\t\t\tconst repository = this._repositories.getClosest(folder.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\tthis._repositories.remove(repository.uri, false);\n\t\t\t\t\tremoved.push(repository);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (removed.length) {\n\t\t\t\tthis.updateContext();\n\n\t\t\t\t// Defer the event trigger enough to let everything unwind\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthis.fireRepositoriesChanged([], removed);\n\t\t\t\t\tremoved.forEach(r => r.dispose());\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tget hasProviders(): boolean {\n\t\treturn this._providers.size !== 0;\n\t}\n\n\tget registeredProviders(): GitProviderDescriptor[] {\n\t\treturn [...map(this._providers.values(), p => ({ ...p.descriptor }))];\n\t}\n\n\tget openRepositories(): Repository[] {\n\t\tif (this.repositoryCount === 0) return emptyArray as Repository[];\n\n\t\tconst repositories = [...filter(this.repositories, r => !r.closed)];\n\t\tif (repositories.length === 0) return repositories;\n\n\t\treturn Repository.sort(repositories);\n\t}\n\n\tget openRepositoryCount(): number {\n\t\treturn this.repositoryCount === 0 ? 0 : count(this.repositories, r => !r.closed);\n\t}\n\n\tget repositories(): IterableIterator<Repository> {\n\t\treturn this._repositories.values();\n\t}\n\n\tget repositoryCount(): number {\n\t\treturn this._repositories.count;\n\t}\n\n\tget highlander(): Repository | undefined {\n\t\treturn this.repositoryCount === 1 ? first(this._repositories.values()) : undefined;\n\t}\n\n\t// get readonly() {\n\t// \treturn true;\n\t// \t// return this.container.vsls.readonly;\n\t// }\n\n\t// get useCaching() {\n\t// \treturn configuration.get('advanced.caching.enabled');\n\t// }\n\n\t/**\n\t * Registers a {@link GitProvider}\n\t * @param id A unique indentifier for the provider\n\t * @param name A name for the provider\n\t * @param provider A provider for handling git operations\n\t * @returns A disposable to unregister the {@link GitProvider}\n\t */\n\t@log({ args: { 1: false }, singleLine: true })\n\tregister(id: GitProviderId, provider: GitProvider): Disposable {\n\t\tif (id !== provider.descriptor.id) {\n\t\t\tthrow new Error(`Id '${id}' must match provider id '${provider.descriptor.id}'`);\n\t\t}\n\t\tif (this._providers.has(id)) throw new Error(`Provider '${id}' has already been registered`);\n\n\t\tthis._providers.set(id, provider);\n\t\tfor (const scheme of provider.supportedSchemes) {\n\t\t\tthis.supportedSchemes.add(scheme);\n\t\t}\n\n\t\tconst disposables = [];\n\n\t\tconst watcher = provider.openRepositoryInitWatcher?.();\n\t\tif (watcher != null) {\n\t\t\tdisposables.push(\n\t\t\t\twatcher,\n\t\t\t\twatcher.onDidCreate(uri => {\n\t\t\t\t\tconst f = workspace.getWorkspaceFolder(uri);\n\t\t\t\t\tif (f == null) return;\n\n\t\t\t\t\tvoid this.discoverRepositories([f], { force: true });\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tconst disposable = Disposable.from(\n\t\t\tprovider,\n\t\t\t...disposables,\n\t\t\tprovider.onDidChangeRepository(async e => {\n\t\t\t\tif (\n\t\t\t\t\te.changed(\n\t\t\t\t\t\tRepositoryChange.Remotes,\n\t\t\t\t\t\tRepositoryChange.RemoteProviders,\n\t\t\t\t\t\tRepositoryChangeComparisonMode.Any,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthis._bestRemotesCache.clear();\n\t\t\t\t}\n\n\t\t\t\tif (e.changed(RepositoryChange.Closed, RepositoryChangeComparisonMode.Any)) {\n\t\t\t\t\tthis.updateContext();\n\n\t\t\t\t\t// Send a notification that the repositories changed\n\t\t\t\t\tqueueMicrotask(() => this.fireRepositoriesChanged([], [e.repository]));\n\t\t\t\t}\n\n\t\t\t\tif (e.changed(RepositoryChange.Remotes, RepositoryChangeComparisonMode.Any)) {\n\t\t\t\t\tconst remotes = await provider.getRemotes(e.repository.path);\n\t\t\t\t\tconst visibilityInfo = this.getVisibilityInfoFromCache(e.repository.path);\n\t\t\t\t\tif (visibilityInfo != null) {\n\t\t\t\t\t\tthis.checkVisibilityCachedRemotes(e.repository.path, visibilityInfo, remotes);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeRepository.fire(e);\n\t\t\t}),\n\t\t\tprovider.onDidCloseRepository(e => {\n\t\t\t\tconst repository = this._repositories.get(e.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\trepository.closed = true;\n\t\t\t\t}\n\t\t\t}),\n\t\t\tprovider.onDidOpenRepository(e => {\n\t\t\t\tconst repository = this._repositories.get(e.uri);\n\t\t\t\tif (repository != null) {\n\t\t\t\t\trepository.closed = false;\n\t\t\t\t} else {\n\t\t\t\t\tvoid this.getOrOpenRepository(e.uri);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tthis.fireProvidersChanged([provider]);\n\n\t\t// Don't kick off the discovery if we're still initializing (we'll do it at the end for all \"known\" providers)\n\t\tif (!this._initializing) {\n\t\t\tthis.onWorkspaceFoldersChanged({ added: workspace.workspaceFolders ?? [], removed: [] });\n\t\t}\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tthis._providers.delete(id);\n\n\t\t\t\tconst removed: Repository[] = [];\n\n\t\t\t\tfor (const repository of [...this._repositories.values()]) {\n\t\t\t\t\tif (repository?.provider.id === id) {\n\t\t\t\t\t\tthis._repositories.remove(repository.uri, false);\n\t\t\t\t\t\tremoved.push(repository);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst { deactivating } = this.container;\n\t\t\t\tif (!deactivating) {\n\t\t\t\t\tthis.updateContext();\n\t\t\t\t}\n\n\t\t\t\tif (removed.length) {\n\t\t\t\t\t// Defer the event trigger enough to let everything unwind\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tif (!deactivating) {\n\t\t\t\t\t\t\tthis.fireRepositoriesChanged([], removed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoved.forEach(r => r.dispose());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!deactivating) {\n\t\t\t\t\tthis.fireProvidersChanged([], [provider]);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate _initializing: boolean = true;\n\n\t@log({ singleLine: true })\n\tasync registrationComplete() {\n\t\tconst scope = getLogScope();\n\n\t\tthis._initializing = false;\n\n\t\tlet { workspaceFolders } = workspace;\n\t\tif (workspaceFolders?.length) {\n\t\t\tawait this.discoverRepositories(workspaceFolders);\n\n\t\t\t// This is a hack to work around some issue with remote repositories on the web not being discovered on the initial load\n\t\t\tif (this.repositoryCount === 0 && isWeb) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t({ workspaceFolders } = workspace);\n\t\t\t\t\tif (workspaceFolders?.length) {\n\t\t\t\t\t\tvoid this.discoverRepositories(workspaceFolders, { force: true });\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.updateContext();\n\t\t}\n\n\t\tconst autoRepositoryDetection = configuration.getAny<\n\t\t\tCoreGitConfiguration,\n\t\t\tboolean | 'subFolders' | 'openEditors'\n\t\t>('git.autoRepositoryDetection');\n\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tthis.container.telemetry.sendEvent('providers/registrationComplete', {\n\t\t\t\t\t'config.git.autoRepositoryDetection': autoRepositoryDetection,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tsetLogScopeExit(\n\t\t\tscope,\n\t\t\t` ${GlyphChars.Dot} workspaceFolders=${workspaceFolders?.length}, git.autoRepositoryDetection=${autoRepositoryDetection}`,\n\t\t);\n\t}\n\n\tgetOpenProviders(): GitProvider[] {\n\t\tconst map = this.getOpenRepositoriesByProvider();\n\t\treturn [...map.keys()].map(id => this._providers.get(id)!);\n\t}\n\n\tgetOpenRepositories(id: GitProviderId): Iterable<Repository> {\n\t\treturn filter(this.repositories, r => !r.closed && (id == null || id === r.provider.id));\n\t}\n\n\tgetOpenRepositoriesByProvider(): Map<GitProviderId, Repository[]> {\n\t\tconst repositories = [...filter(this.repositories, r => !r.closed)];\n\t\tif (repositories.length === 0) return new Map();\n\n\t\treturn groupByMap(repositories, r => r.provider.id);\n\t}\n\n\thasOpenRepositories(id: GitProviderId): boolean {\n\t\treturn some(this.repositories, r => !r.closed && (id == null || id === r.provider.id));\n\t}\n\n\tprivate _discoveredWorkspaceFolders = new Map<WorkspaceFolder, Promise<Repository[]>>();\n\n\t@log<GitProviderService['discoverRepositories']>({ args: { 0: folders => folders.length } })\n\tasync discoverRepositories(folders: readonly WorkspaceFolder[], options?: { force?: boolean }): Promise<void> {\n\t\tconst promises = [];\n\n\t\tfor (const folder of folders) {\n\t\t\tif (!options?.force && this._discoveredWorkspaceFolders.has(folder)) continue;\n\n\t\t\tconst promise = this.discoverRepositoriesCore(folder);\n\t\t\tpromises.push(promise);\n\t\t\tthis._discoveredWorkspaceFolders.set(folder, promise);\n\t\t}\n\n\t\tif (promises.length === 0) return;\n\n\t\tconst results = await Promise.allSettled(promises);\n\n\t\tconst repositories = flatMap<PromiseFulfilledResult<Repository[]>, Repository>(\n\t\t\tfilter<PromiseSettledResult<Repository[]>, PromiseFulfilledResult<Repository[]>>(\n\t\t\t\tresults,\n\t\t\t\t(r): r is PromiseFulfilledResult<Repository[]> => r.status === 'fulfilled',\n\t\t\t),\n\t\t\tr => r.value,\n\t\t);\n\n\t\tconst added: Repository[] = [];\n\n\t\tfor (const repository of repositories) {\n\t\t\tif (this._repositories.add(repository)) {\n\t\t\t\tadded.push(repository);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateContext();\n\n\t\tif (added.length === 0) return;\n\n\t\t// Defer the event trigger enough to let everything unwind\n\t\tqueueMicrotask(() => this.fireRepositoriesChanged(added));\n\t}\n\n\t@debug({ exit: true })\n\tprivate async discoverRepositoriesCore(folder: WorkspaceFolder): Promise<Repository[]> {\n\t\tconst { provider } = this.getProvider(folder.uri);\n\n\t\ttry {\n\t\t\treturn await provider.discoverRepositories(folder.uri);\n\t\t} catch (ex) {\n\t\t\tthis._discoveredWorkspaceFolders.delete(folder);\n\n\t\t\tLogger.error(\n\t\t\t\tex,\n\t\t\t\t`${provider.descriptor.name} Provider(${\n\t\t\t\t\tprovider.descriptor.id\n\t\t\t\t}) failed discovering repositories in ${folder.uri.toString(true)}`,\n\t\t\t);\n\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate _subscription: Subscription | undefined;\n\tprivate async getSubscription(): Promise<Subscription> {\n\t\treturn this._subscription ?? (this._subscription = await this.container.subscription.getSubscription());\n\t}\n\n\tprivate _accessCache: Map<string, Promise<RepoFeatureAccess>> &\n\t\tMap<undefined, Promise<FeatureAccess | RepoFeatureAccess>> = new Map();\n\tasync access(feature: PlusFeatures | undefined, repoPath: string | Uri): Promise<RepoFeatureAccess>;\n\tasync access(feature?: PlusFeatures, repoPath?: string | Uri): Promise<FeatureAccess | RepoFeatureAccess>;\n\t@debug({ exit: true })\n\tasync access(feature?: PlusFeatures, repoPath?: string | Uri): Promise<FeatureAccess | RepoFeatureAccess> {\n\t\tif (repoPath == null) {\n\t\t\tlet access = this._accessCache.get(undefined);\n\t\t\tif (access == null) {\n\t\t\t\taccess = this.accessCore(feature, repoPath);\n\t\t\t\tthis._accessCache.set(undefined, access);\n\t\t\t}\n\t\t\treturn access;\n\t\t}\n\n\t\tconst { path } = this.getProvider(repoPath);\n\t\tconst cacheKey = path;\n\n\t\tlet access = this._accessCache.get(cacheKey);\n\t\tif (access == null) {\n\t\t\taccess = this.accessCore(feature, repoPath);\n\t\t\tthis._accessCache.set(cacheKey, access);\n\t\t}\n\n\t\treturn access;\n\t}\n\n\tprivate async accessCore(feature: PlusFeatures | undefined, repoPath: string | Uri): Promise<RepoFeatureAccess>;\n\tprivate async accessCore(\n\t\tfeature?: PlusFeatures,\n\t\trepoPath?: string | Uri,\n\t): Promise<FeatureAccess | RepoFeatureAccess>;\n\t@debug({ exit: true })\n\tprivate async accessCore(\n\t\t_feature?: PlusFeatures,\n\t\trepoPath?: string | Uri,\n\t): Promise<FeatureAccess | RepoFeatureAccess> {\n\t\tconst subscription = await this.getSubscription();\n\n\t\tif (this.container.telemetry.enabled) {\n\t\t\tqueueMicrotask(() => void this.visibility());\n\t\t}\n\n\t\tconst plan = subscription.plan.effective.id;\n\t\tif (isSubscriptionPaidPlan(plan)) {\n\t\t\treturn { allowed: subscription.account?.verified !== false, subscription: { current: subscription } };\n\t\t}\n\n\t\tfunction getRepoAccess(\n\t\t\tthis: GitProviderService,\n\t\t\trepoPath: string | Uri,\n\t\t\tforce: boolean = false,\n\t\t): Promise<RepoFeatureAccess> {\n\t\t\tconst { path: cacheKey } = this.getProvider(repoPath);\n\n\t\t\tlet access = force ? undefined : this._accessCache.get(cacheKey);\n\t\t\tif (access == null) {\n\t\t\t\taccess = this.visibility(repoPath).then(\n\t\t\t\t\tvisibility => {\n\t\t\t\t\t\tif (visibility === RepositoryVisibility.Private) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tallowed: true,\n\t\t\t\t\t\t\tsubscription: { current: subscription },\n\t\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\t// If there is a failure assume access is allowed\n\t\t\t\t\t() => ({ allowed: true, subscription: { current: subscription } }),\n\t\t\t\t);\n\n\t\t\t\tthis._accessCache.set(cacheKey, access);\n\t\t\t}\n\n\t\t\treturn access;\n\t\t}\n\n\t\tif (repoPath == null) {\n\t\t\tconst repositories = this.openRepositories;\n\t\t\tif (repositories.length === 0) {\n\t\t\t\treturn { allowed: false, subscription: { current: subscription } };\n\t\t\t}\n\n\t\t\tif (repositories.length === 1) {\n\t\t\t\treturn getRepoAccess.call(this, repositories[0].path);\n\t\t\t}\n\n\t\t\tconst visibility = await this.visibility();\n\t\t\tswitch (visibility) {\n\t\t\t\tcase RepositoriesVisibility.Private:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: false,\n\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t\tvisibility: RepositoryVisibility.Private,\n\t\t\t\t\t};\n\t\t\t\tcase RepositoriesVisibility.Mixed:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: 'mixed',\n\t\t\t\t\t\tsubscription: { current: subscription, required: SubscriptionPlanId.Pro },\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\treturn {\n\t\t\t\t\t\tallowed: true,\n\t\t\t\t\t\tsubscription: { current: subscription },\n\t\t\t\t\t\tvisibility: RepositoryVisibility.Public,\n\t\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Pass force = true to bypass the cache and avoid a promise loop (where we used the cached promise we just created to try to resolve itself \ud83e\udd26)\n\t\treturn getRepoAccess.call(this, repoPath, true);\n\t}\n\n\tasync ensureAccess(feature: PlusFeatures, repoPath?: string): Promise<void> {\n\t\tconst { allowed, subscription } = await this.access(feature, repoPath);\n\t\tif (allowed === false) throw new AccessDeniedError(subscription.current, subscription.required);\n\t}\n\n\t@debug({ exit: true })\n\tsupports(repoPath: string | Uri, feature: Features): Promise<boolean> {\n\t\tconst { provider } = this.getProvider(repoPath);\n\t\treturn provider.supports(feature);\n\t}\n\n\tprivate _reposVisibilityCache: RepositoriesVisibility | undefined;\n\tprivate _repoVisibilityCache: Map<string, RepositoryVisibilityInfo> | undefined;\n\n\tprivate ensureRepoVisibilityCache(): void {\n\t\tif (this._repoVisibilityCache == null) {\n\t\t\tconst repoVisibility: [string, RepositoryVisibilityInfo][] | undefined = this.container.storage\n\t\t\t\t.get('repoVisibility')\n\t\t\t\t?.map<[string, RepositoryVisibilityInfo]>(([key, visibilityInfo]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\t{\n\t\t\t\t\t\tvisibility: visibilityInfo.visibility as RepositoryVisibility,\n\t\t\t\t\t\ttimestamp: visibilityInfo.timestamp,\n\t\t\t\t\t\tremotesHash: visibilityInfo.remotesHash,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\tthis._repoVisibilityCache = new Map(repoVisibility);\n\t\t}\n\t}\n\n\tprivate clearRepoVisibilityCache(keys?: string[]): void {\n\t\tif (keys == null) {\n\t\t\tthis._repoVisibilityCache = undefined;\n\t\t\tvoid this.container.storage.delete('repoVisibility');\n\t\t} else {\n\t\t\tkeys?.forEach(key => this._repoVisibilityCache?.delete(key));\n\t\t\tconst repoVisibility = Array.from(this._repoVisibilityCache?.entries() ?? []);\n\t\t\tif (repoVisibility.length === 0) {\n\t\t\t\tvoid this.container.storage.delete('repoVisibility');\n\t\t\t} else {\n\t\t\t\tvoid this.container.storage.store('repoVisibility', repoVisibility);\n\t\t\t}\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getVisibilityInfoFromCache']>({ exit: r => `returned ${r?.visibility}` })\n\tprivate getVisibilityInfoFromCache(key: string): RepositoryVisibilityInfo | undefined {\n\t\tthis.ensureRepoVisibilityCache();\n\t\tconst visibilityInfo = this._repoVisibilityCache?.get(key);\n\t\tif (visibilityInfo == null) return undefined;\n\n\t\tconst now = Date.now();\n\t\tif (now - visibilityInfo.timestamp > 1000 * 60 * 60 * 24 * 30 /* TTL is 30 days */) {\n\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn visibilityInfo;\n\t}\n\n\tprivate checkVisibilityCachedRemotes(\n\t\tkey: string,\n\t\tvisibilityInfo: RepositoryVisibilityInfo | undefined,\n\t\tremotes: GitRemote[],\n\t): boolean {\n\t\tif (visibilityInfo == null) return true;\n\n\t\tif (visibilityInfo.visibility === RepositoryVisibility.Public) {\n\t\t\tif (remotes.length == 0 || !remotes.some(r => r.id === visibilityInfo.remotesHash)) {\n\t\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (visibilityInfo.visibility === RepositoryVisibility.Private) {\n\t\t\tconst remotesHash = remotes\n\t\t\t\t.map(r => r.id)\n\t\t\t\t.sort()\n\t\t\t\t.join(',');\n\t\t\tif (remotesHash !== visibilityInfo.remotesHash) {\n\t\t\t\tthis.clearRepoVisibilityCache([key]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate updateVisibilityCache(key: string, visibilityInfo: RepositoryVisibilityInfo): void {\n\t\tthis.ensureRepoVisibilityCache();\n\t\tthis._repoVisibilityCache?.set(key, visibilityInfo);\n\t\tvoid this.container.storage.store('repoVisibility', Array.from(this._repoVisibilityCache!.entries()));\n\t}\n\n\t@debug()\n\tclearAllRepoVisibilityCaches(): void {\n\t\tthis.clearRepoVisibilityCache();\n\t}\n\n\t@debug()\n\tclearAllOpenRepoVisibilityCaches(): void {\n\t\tconst openRepoProviderPaths = this.openRepositories.map(r => this.getProvider(r.path).path);\n\t\tthis.clearRepoVisibilityCache(openRepoProviderPaths);\n\t}\n\n\tvisibility(): Promise<RepositoriesVisibility>;\n\tvisibility(repoPath: string | Uri): Promise<RepositoryVisibility>;\n\t@debug({ exit: true })\n\tasync visibility(repoPath?: string | Uri): Promise<RepositoriesVisibility | RepositoryVisibility> {\n\t\tif (repoPath == null) {\n\t\t\tlet visibility = this._reposVisibilityCache;\n\t\t\tif (visibility == null) {\n\t\t\t\tvisibility = await this.visibilityCore();\n\t\t\t\tif (this.container.telemetry.enabled) {\n\t\t\t\t\tthis.container.telemetry.setGlobalAttribute('repositories.visibility', visibility);\n\t\t\t\t\tthis.container.telemetry.sendEvent('repositories/visibility');\n\t\t\t\t}\n\t\t\t\tthis._reposVisibilityCache = visibility;\n\t\t\t}\n\t\t\treturn visibility;\n\t\t}\n\n\t\tconst { path: cacheKey } = this.getProvider(repoPath);\n\n\t\tlet visibility = this.getVisibilityInfoFromCache(cacheKey)?.visibility;\n\t\tif (visibility == null) {\n\t\t\tvisibility = await this.visibilityCore(repoPath);\n\t\t\tif (this.container.telemetry.enabled) {\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tconst repo = this.getRepository(repoPath);\n\t\t\t\t\tthis.container.telemetry.sendEvent('repository/visibility', {\n\t\t\t\t\t\t'repository.visibility': visibility,\n\t\t\t\t\t\t'repository.id': repo?.idHash,\n\t\t\t\t\t\t'repository.scheme': repo?.uri.scheme,\n\t\t\t\t\t\t'repository.closed': repo?.closed,\n\t\t\t\t\t\t'repository.folder.scheme': repo?.folder?.uri.scheme,\n\t\t\t\t\t\t'repository.provider.id': repo?.provider.id,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn visibility;\n\t}\n\n\tprivate visibilityCore(): Promise<RepositoriesVisibility>;\n\tprivate visibilityCore(repoPath: string | Uri): Promise<RepositoryVisibility>;\n\t@debug({ exit: true })\n\tprivate async visibilityCore(repoPath?: string | Uri): Promise<RepositoriesVisibility | RepositoryVisibility> {\n\t\tasync function getRepoVisibility(\n\t\t\tthis: GitProviderService,\n\t\t\trepoPath: string | Uri,\n\t\t): Promise<RepositoryVisibility> {\n\t\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\t\tconst remotes = await provider.getRemotes(path, { sort: true });\n\t\t\tconst visibilityInfo = this.getVisibilityInfoFromCache(path);\n\t\t\tif (visibilityInfo == null || !this.checkVisibilityCachedRemotes(path, visibilityInfo, remotes)) {\n\t\t\t\tconst [visibility, remotesHash] = await provider.visibility(path);\n\t\t\t\tif (visibility !== RepositoryVisibility.Local) {\n\t\t\t\t\tthis.updateVisibilityCache(path, {\n\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tremotesHash: remotesHash,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn visibility;\n\t\t\t}\n\n\t\t\treturn visibilityInfo.visibility;\n\t\t}\n\n\t\tif (repoPath == null) {\n\t\t\tconst repositories = this.openRepositories;\n\t\t\tif (repositories.length === 0) return RepositoriesVisibility.Private;\n\n\t\t\tif (repositories.length === 1) {\n\t\t\t\treturn getRepoVisibility.call(this, repositories[0].path);\n\t\t\t}\n\n\t\t\tlet isPublic = false;\n\t\t\tlet isPrivate = false;\n\t\t\tlet isLocal = false;\n\n\t\t\tfor await (const result of asSettled(repositories.map(r => getRepoVisibility.call(this, r.path)))) {\n\t\t\t\tif (result.status !== 'fulfilled') continue;\n\n\t\t\t\tif (result.value === RepositoryVisibility.Public) {\n\t\t\t\t\tif (isLocal || isPrivate) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisPublic = true;\n\t\t\t\t} else if (result.value === RepositoryVisibility.Local) {\n\t\t\t\t\tif (isPublic || isPrivate) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisLocal = true;\n\t\t\t\t} else if (result.value === RepositoryVisibility.Private) {\n\t\t\t\t\tif (isPublic || isLocal) return RepositoriesVisibility.Mixed;\n\n\t\t\t\t\tisPrivate = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isPublic) return RepositoriesVisibility.Public;\n\t\t\tif (isLocal) return RepositoriesVisibility.Local;\n\t\t\treturn RepositoriesVisibility.Private;\n\t\t}\n\n\t\treturn getRepoVisibility.call(this, repoPath);\n\t}\n\n\tprivate _context: { enabled: boolean; disabled: boolean } = { enabled: false, disabled: false };\n\n\t@debug()\n\tasync setEnabledContext(enabled: boolean): Promise<void> {\n\t\tlet disabled = !enabled;\n\t\t// If we think we should be disabled during startup, check if we have a saved value from the last time this repo was loaded\n\t\tif (!enabled && this._initializing) {\n\t\t\tdisabled = !(this.container.storage.getWorkspace('assumeRepositoriesOnStartup') ?? true);\n\t\t}\n\n\t\tthis.container.telemetry.setGlobalAttribute('enabled', enabled);\n\n\t\tif (this._context.enabled === enabled && this._context.disabled === disabled) return;\n\n\t\tconst promises = [];\n\n\t\tif (this._context.enabled !== enabled) {\n\t\t\tthis._context.enabled = enabled;\n\t\t\tpromises.push(setContext('gitlens:enabled', enabled));\n\t\t}\n\n\t\tif (this._context.disabled !== disabled) {\n\t\t\tthis._context.disabled = disabled;\n\t\t\tpromises.push(setContext('gitlens:disabled', disabled));\n\t\t}\n\n\t\tawait Promise.allSettled(promises);\n\n\t\tif (!this._initializing) {\n\t\t\tvoid this.container.storage.storeWorkspace('assumeRepositoriesOnStartup', enabled).catch();\n\t\t}\n\t}\n\n\tprivate _sendProviderContextTelemetryDebounced: Deferrable<() => void> | undefined;\n\n\tprivate updateContext() {\n\t\tif (this.container.deactivating) return;\n\n\t\tconst openRepositoryCount = this.openRepositoryCount;\n\t\tconst hasRepositories = openRepositoryCount !== 0;\n\n\t\tvoid this.setEnabledContext(hasRepositories);\n\n\t\t// Don't bother trying to set the values if we're still starting up\n\t\tif (this._initializing) return;\n\n\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\tenabled: hasRepositories,\n\t\t\t'repositories.count': openRepositoryCount,\n\t\t});\n\n\t\tif (!hasRepositories) return;\n\n\t\t// Don't block for the remote context updates (because it can block other downstream requests during initialization)\n\t\tasync function updateRemoteContext(this: GitProviderService) {\n\t\t\tconst integrations = configuration.get('integrations.enabled');\n\n\t\t\tconst telemetryEnabled = this.container.telemetry.enabled;\n\t\t\tconst remoteProviders = new Set<string>();\n\n\t\t\tlet hasRemotes = false;\n\t\t\tlet hasRichRemotes = false;\n\t\t\tlet hasConnectedRemotes = false;\n\n\t\t\tif (hasRepositories) {\n\t\t\t\tfor (const repo of this._repositories.values()) {\n\t\t\t\t\tif (telemetryEnabled) {\n\t\t\t\t\t\tconst remotes = await repo.getRemotes();\n\t\t\t\t\t\tfor (const remote of remotes) {\n\t\t\t\t\t\t\tremoteProviders.add(remote.provider?.id ?? 'unknown');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasConnectedRemotes && integrations) {\n\t\t\t\t\t\thasConnectedRemotes = await repo.hasRichRemote(true);\n\n\t\t\t\t\t\tif (hasConnectedRemotes) {\n\t\t\t\t\t\t\thasRichRemotes = true;\n\t\t\t\t\t\t\thasRemotes = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasRichRemotes && integrations) {\n\t\t\t\t\t\thasRichRemotes = await repo.hasRichRemote();\n\n\t\t\t\t\t\tif (hasRichRemotes) {\n\t\t\t\t\t\t\thasRemotes = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!hasRemotes) {\n\t\t\t\t\t\thasRemotes = await repo.hasRemotes();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasRemotes && ((hasRichRemotes && hasConnectedRemotes) || !integrations)) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (telemetryEnabled) {\n\t\t\t\tthis.container.telemetry.setGlobalAttributes({\n\t\t\t\t\t'repositories.hasRemotes': hasRemotes,\n\t\t\t\t\t'repositories.hasRichRemotes': hasRichRemotes,\n\t\t\t\t\t'repositories.hasConnectedRemotes': hasConnectedRemotes,\n\t\t\t\t\t'repositories.remoteProviders': join(remoteProviders, ','),\n\t\t\t\t});\n\t\t\t\tif (this._sendProviderContextTelemetryDebounced == null) {\n\t\t\t\t\tthis._sendProviderContextTelemetryDebounced = debounce(\n\t\t\t\t\t\t() => this.container.telemetry.sendEvent('providers/context'),\n\t\t\t\t\t\t2500,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis._sendProviderContextTelemetryDebounced();\n\t\t\t}\n\n\t\t\tawait Promise.allSettled([\n\t\t\t\tsetContext('gitlens:hasRemotes', hasRemotes),\n\t\t\t\tsetContext('gitlens:hasRichRemotes', hasRichRemotes),\n\t\t\t\tsetContext('gitlens:hasConnectedRemotes', hasConnectedRemotes),\n\t\t\t]);\n\t\t}\n\n\t\tvoid updateRemoteContext.call(this);\n\n\t\tthis._providers.forEach(p => p.updateContext?.());\n\t}\n\n\tprivate getProvider(repoPath: string | Uri): GitProviderResult {\n\t\tif (repoPath == null || (typeof repoPath !== 'string' && !this.supportedSchemes.has(repoPath.scheme))) {\n\t\t\tdebugger;\n\t\t\tthrow new ProviderNotFoundError(repoPath);\n\t\t}\n\n\t\tlet scheme;\n\t\tif (typeof repoPath === 'string') {\n\t\t\tscheme = getScheme(repoPath) ?? Schemes.File;\n\t\t} else {\n\t\t\t({ scheme } = repoPath);\n\t\t}\n\n\t\tconst possibleResults = new Set<GitProviderResult>();\n\n\t\tfor (const provider of this._providers.values()) {\n\t\t\tconst path = provider.canHandlePathOrUri(scheme, repoPath);\n\t\t\tif (path == null) continue;\n\n\t\t\tpossibleResults.add({ provider: provider, path: path });\n\t\t}\n\n\t\tif (possibleResults.size === 0) {\n\t\t\tdebugger;\n\t\t\tthrow new ProviderNotFoundError(repoPath);\n\t\t}\n\n\t\t// Prefer the provider with an open repository\n\t\tif (possibleResults.size > 1) {\n\t\t\tfor (const result of possibleResults) {\n\t\t\t\tif (this.hasOpenRepositories(result.provider.descriptor.id)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn first(possibleResults)!;\n\t}\n\n\tgetAbsoluteUri(pathOrUri: string | Uri, base?: string | Uri): Uri {\n\t\tif (base == null) {\n\t\t\tif (typeof pathOrUri === 'string') {\n\t\t\t\tif (maybeUri(pathOrUri)) return Uri.parse(pathOrUri, true);\n\n\t\t\t\t// I think it is safe to assume this should be file://\n\t\t\t\treturn Uri.file(pathOrUri);\n\t\t\t}\n\n\t\t\treturn pathOrUri;\n\t\t}\n\n\t\t// Short-circuit if the base is already a Uri and the path is relative\n\t\tif (typeof base !== 'string' && typeof pathOrUri === 'string') {\n\t\t\tconst normalized = normalizePath(pathOrUri);\n\t\t\tif (!isAbsolute(normalized)) return Uri.joinPath(base, normalized);\n\t\t}\n\n\t\tconst { provider } = this.getProvider(base);\n\t\treturn provider.getAbsoluteUri(pathOrUri, base);\n\t}\n\n\t@log()\n\tasync getBestRevisionUri(\n\t\trepoPath: string | Uri | undefined,\n\t\tpath: string,\n\t\tref: string | undefined,\n\t): Promise<Uri | undefined> {\n\t\tif (repoPath == null || ref === deletedOrMissing) return undefined;\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getBestRevisionUri(rp, provider.getRelativePath(path, rp), ref);\n\t}\n\n\tgetRelativePath(pathOrUri: string | Uri, base: string | Uri): string {\n\t\tconst { provider } = this.getProvider(pathOrUri instanceof Uri ? pathOrUri : base);\n\t\treturn provider.getRelativePath(pathOrUri, base);\n\t}\n\n\tgetRevisionUri(uri: GitUri): Uri;\n\tgetRevisionUri(ref: string, path: string, repoPath: string | Uri): Uri;\n\tgetRevisionUri(ref: string, file: GitFile, repoPath: string | Uri): Uri;\n\t@log()\n\tgetRevisionUri(refOrUri: string | GitUri, pathOrFile?: string | GitFile, repoPath?: string | Uri): Uri {\n\t\tlet path: string;\n\t\tlet ref: string | undefined;\n\n\t\tif (typeof refOrUri === 'string') {\n\t\t\tref = refOrUri;\n\n\t\t\tif (typeof pathOrFile === 'string') {\n\t\t\t\tpath = pathOrFile;\n\t\t\t} else {\n\t\t\t\tpath = pathOrFile?.originalPath ?? pathOrFile?.path ?? '';\n\t\t\t}\n\t\t} else {\n\t\t\tref = refOrUri.sha;\n\t\t\trepoPath = refOrUri.repoPath!;\n\n\t\t\tpath = getBestPath(refOrUri);\n\t\t}\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath!);\n\t\treturn provider.getRevisionUri(rp, provider.getRelativePath(path, rp), ref!);\n\t}\n\n\t@log()\n\tgetWorkingUri(repoPath: string | Uri, uri: Uri) {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getWorkingUri(path, uri);\n\t}\n\n\t@log()\n\taddRemote(repoPath: string | Uri, name: string, url: string, options?: { fetch?: boolean }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.addRemote(path, name, url, options);\n\t}\n\n\t@log()\n\tpruneRemote(repoPath: string | Uri, name: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.pruneRemote(path, name);\n\t}\n\n\t@log()\n\tremoveRemote(repoPath: string | Uri, name: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.removeRemote(path, name);\n\t}\n\n\t@log()\n\tapplyChangesToWorkingFile(uri: GitUri, ref1?: string, ref2?: string): Promise<void> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.applyChangesToWorkingFile(uri, ref1, ref2);\n\t}\n\n\t@log()\n\tcheckout(repoPath: string, ref: string, options?: { createBranch?: string } | { path?: string }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.checkout(path, ref, options);\n\t}\n\n\t@log({ singleLine: true })\n\tresetCaches(...caches: GitCaches[]): void {\n\t\tif (caches.length === 0 || caches.includes('providers')) {\n\t\t\tthis._bestRemotesCache.clear();\n\t\t}\n\n\t\tthis.container.events.fire('git:cache:reset', { caches: caches });\n\t}\n\n\t@log<GitProviderService['excludeIgnoredUris']>({ args: { 1: uris => uris.length } })\n\texcludeIgnoredUris(repoPath: string, uris: Uri[]): Promise<Uri[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.excludeIgnoredUris(path, uris);\n\t}\n\n\t@gate()\n\t@log()\n\tfetch(\n\t\trepoPath: string,\n\t\toptions?: { all?: boolean; branch?: GitBranchReference; prune?: boolean; pull?: boolean; remote?: string },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.fetch(path, options);\n\t}\n\n\t@gate<GitProviderService['fetchAll']>(\n\t\t(repos, opts) => `${repos == null ? '' : repos.map(r => r.id).join(',')}|${JSON.stringify(opts)}`,\n\t)\n\t@log<GitProviderService['fetchAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync fetchAll(repositories?: Repository[], options?: { all?: boolean; prune?: boolean }) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].fetch(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Fetching ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.fetch({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@gate<GitProviderService['pullAll']>(\n\t\t(repos, opts) => `${repos == null ? '' : repos.map(r => r.id).join(',')}|${JSON.stringify(opts)}`,\n\t)\n\t@log<GitProviderService['pullAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync pullAll(repositories?: Repository[], options?: { rebase?: boolean }) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].pull(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Pulling ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.pull({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@gate<GitProviderService['pushAll']>(repos => `${repos == null ? '' : repos.map(r => r.id).join(',')}`)\n\t@log<GitProviderService['pushAll']>({ args: { 0: repos => repos?.map(r => r.name).join(', ') } })\n\tasync pushAll(\n\t\trepositories?: Repository[],\n\t\toptions?: {\n\t\t\tforce?: boolean;\n\t\t\treference?: GitReference;\n\t\t\tpublish?: {\n\t\t\t\tremote: string;\n\t\t\t};\n\t\t},\n\t) {\n\t\tif (repositories == null) {\n\t\t\trepositories = this.openRepositories;\n\t\t}\n\t\tif (repositories.length === 0) return;\n\n\t\tif (repositories.length === 1) {\n\t\t\tawait repositories[0].push(options);\n\n\t\t\treturn;\n\t\t}\n\n\t\tawait window.withProgress(\n\t\t\t{\n\t\t\t\tlocation: ProgressLocation.Notification,\n\t\t\t\ttitle: `Pushing ${repositories.length} repositories`,\n\t\t\t},\n\t\t\t() => Promise.all(repositories!.map(r => r.push({ progress: false, ...options }))),\n\t\t);\n\t}\n\n\t@log<GitProviderService['getAheadBehindCommitCount']>({ args: { 1: refs => refs.join(',') } })\n\tgetAheadBehindCommitCount(\n\t\trepoPath: string | Uri,\n\t\trefs: string[],\n\t): Promise<{ ahead: number; behind: number } | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getAheadBehindCommitCount(path, refs);\n\t}\n\n\t@log<GitProviderService['getBlame']>({ args: { 1: d => d?.isDirty } })\n\t/**\n\t * Returns the blame of a file\n\t * @param uri Uri of the file to blame\n\t * @param document Optional TextDocument to blame the contents of if dirty\n\t */\n\tasync getBlame(uri: GitUri, document?: TextDocument | undefined): Promise<GitBlame | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlame(uri, document);\n\t}\n\n\t@log<GitProviderService['getBlameContents']>({ args: { 1: '<contents>' } })\n\t/**\n\t * Returns the blame of a file, using the editor contents (for dirty editors)\n\t * @param uri Uri of the file to blame\n\t * @param contents Contents from the editor to use\n\t */\n\tasync getBlameContents(uri: GitUri, contents: string): Promise<GitBlame | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameContents(uri, contents);\n\t}\n\n\t@log<GitProviderService['getBlameForLine']>({ args: { 2: d => d?.isDirty } })\n\t/**\n\t * Returns the blame of a single line\n\t * @param uri Uri of the file to blame\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param document Optional TextDocument to blame the contents of if dirty\n\t * @param options.forceSingleLine Forces blame to be for the single line (rather than the whole file)\n\t */\n\tasync getBlameForLine(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tdocument?: TextDocument | undefined,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForLine(uri, editorLine, document, options);\n\t}\n\n\t@log<GitProviderService['getBlameForLineContents']>({ args: { 2: '<contents>' } })\n\t/**\n\t * Returns the blame of a single line, using the editor contents (for dirty editors)\n\t * @param uri Uri of the file to blame\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param contents Contents from the editor to use\n\t * @param options.forceSingleLine Forces blame to be for the single line (rather than the whole file)\n\t */\n\tasync getBlameForLineContents(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tcontents: string,\n\t\toptions?: { forceSingleLine?: boolean },\n\t): Promise<GitBlameLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForLineContents(uri, editorLine, contents, options);\n\t}\n\n\t@log()\n\tasync getBlameForRange(uri: GitUri, range: Range): Promise<GitBlameLines | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForRange(uri, range);\n\t}\n\n\t@log<GitProviderService['getBlameForRangeContents']>({ args: { 2: '<contents>' } })\n\tasync getBlameForRangeContents(uri: GitUri, range: Range, contents: string): Promise<GitBlameLines | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameForRangeContents(uri, range, contents);\n\t}\n\n\t@log<GitProviderService['getBlameRange']>({ args: { 0: '<blame>' } })\n\tgetBlameRange(blame: GitBlame, uri: GitUri, range: Range): GitBlameLines | undefined {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getBlameRange(blame, uri, range);\n\t}\n\n\t@log()\n\tasync getBranch(repoPath: string | Uri | undefined): Promise<GitBranch | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getBranch(path);\n\t}\n\n\t@log<GitProviderService['getBranchAheadRange']>({ args: { 0: b => b.name } })\n\tasync getBranchAheadRange(branch: GitBranch): Promise<string | undefined> {\n\t\tif (branch.state.ahead > 0) {\n\t\t\treturn createRevisionRange(branch.upstream?.name, branch.ref);\n\t\t}\n\n\t\tif (branch.upstream == null) {\n\t\t\t// If we have no upstream branch, try to find a best guess branch to use as the \"base\"\n\t\t\tconst { values: branches } = await this.getBranches(branch.repoPath, {\n\t\t\t\tfilter: b => weightedDefaultBranches.has(b.name),\n\t\t\t});\n\t\t\tif (branches.length > 0) {\n\t\t\t\tlet weightedBranch: { weight: number; branch: GitBranch } | undefined;\n\t\t\t\tfor (const branch of branches) {\n\t\t\t\t\tconst weight = weightedDefaultBranches.get(branch.name)!;\n\t\t\t\t\tif (weightedBranch == null || weightedBranch.weight < weight) {\n\t\t\t\t\t\tweightedBranch = { weight: weight, branch: branch };\n\t\t\t\t\t}\n\n\t\t\t\t\tif (weightedBranch.weight === maxDefaultBranchWeight) break;\n\t\t\t\t}\n\n\t\t\t\tconst possibleBranch = weightedBranch!.branch.upstream?.name ?? weightedBranch!.branch.ref;\n\t\t\t\tif (possibleBranch !== branch.ref) {\n\t\t\t\t\treturn createRevisionRange(possibleBranch, branch.ref);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getBranches(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: {\n\t\t\tfilter?: (b: GitBranch) => boolean;\n\t\t\tsort?: boolean | BranchSortOptions;\n\t\t},\n\t): Promise<PagedResult<GitBranch>> {\n\t\tif (repoPath == null) return { values: [] };\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getBranches(path, options);\n\t}\n\n\t@log()\n\tasync getBranchesAndTagsTipsFn(\n\t\trepoPath: string | Uri | undefined,\n\t\tcurrentName?: string,\n\t): Promise<\n\t\t(sha: string, options?: { compact?: boolean | undefined; icons?: boolean | undefined }) => string | undefined\n\t> {\n\t\tconst [branchesResult, tagsResult] = await Promise.allSettled([\n\t\t\tthis.getBranches(repoPath),\n\t\t\tthis.getTags(repoPath),\n\t\t]);\n\n\t\tconst branches = getSettledValue(branchesResult)?.values ?? [];\n\t\tconst tags = getSettledValue(tagsResult)?.values ?? [];\n\n\t\tconst branchesAndTagsBySha = groupByFilterMap(\n\t\t\t(branches as (GitBranch | GitTag)[]).concat(tags as (GitBranch | GitTag)[]),\n\t\t\tbt => bt.sha,\n\t\t\tbt => {\n\t\t\t\tif (currentName) {\n\t\t\t\t\tif (bt.name === currentName) return undefined;\n\t\t\t\t\tif (bt.refType === 'branch' && bt.getNameWithoutRemote() === currentName) {\n\t\t\t\t\t\treturn { name: bt.name, compactName: bt.getRemoteName(), type: bt.refType };\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { name: bt.name, compactName: undefined, type: bt.refType };\n\t\t\t},\n\t\t);\n\n\t\treturn (sha: string, options?: { compact?: boolean; icons?: boolean }): string | undefined => {\n\t\t\tconst branchesAndTags = branchesAndTagsBySha.get(sha);\n\t\t\tif (branchesAndTags == null || branchesAndTags.length === 0) return undefined;\n\n\t\t\tif (!options?.compact) {\n\t\t\t\treturn branchesAndTags\n\t\t\t\t\t.map(\n\t\t\t\t\t\tbt => `${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${bt.name}`,\n\t\t\t\t\t)\n\t\t\t\t\t.join(', ');\n\t\t\t}\n\n\t\t\tif (branchesAndTags.length > 1) {\n\t\t\t\tconst [bt] = branchesAndTags;\n\t\t\t\treturn `${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${\n\t\t\t\t\tbt.compactName ?? bt.name\n\t\t\t\t}, ${GlyphChars.Ellipsis}`;\n\t\t\t}\n\n\t\t\treturn branchesAndTags\n\t\t\t\t.map(\n\t\t\t\t\tbt =>\n\t\t\t\t\t\t`${options?.icons ? `${bt.type === 'tag' ? '$(tag)' : '$(git-branch)'} ` : ''}${\n\t\t\t\t\t\t\tbt.compactName ?? bt.name\n\t\t\t\t\t\t}`,\n\t\t\t\t)\n\t\t\t\t.join(', ');\n\t\t};\n\t}\n\n\t@log()\n\tgetChangedFilesCount(repoPath: string | Uri, ref?: string): Promise<GitDiffShortStat | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getChangedFilesCount(path, ref);\n\t}\n\n\t@log()\n\tasync getCommit(repoPath: string | Uri, ref: string): Promise<GitCommit | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\n\t\tif (ref === uncommitted || ref === uncommittedStaged) {\n\t\t\tconst now = new Date();\n\t\t\tconst user = await this.getCurrentUser(repoPath);\n\t\t\treturn new GitCommit(\n\t\t\t\tthis.container,\n\t\t\t\tpath,\n\t\t\t\tref,\n\t\t\t\tnew GitCommitIdentity('You', user?.email ?? undefined, now),\n\t\t\t\tnew GitCommitIdentity('You', user?.email ?? undefined, now),\n\t\t\t\t'Uncommitted changes',\n\t\t\t\t[],\n\t\t\t\t'Uncommitted changes',\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\t[],\n\t\t\t);\n\t\t}\n\n\t\treturn provider.getCommit(path, ref);\n\t}\n\n\t@log()\n\tgetCommitBranches(\n\t\trepoPath: string | Uri,\n\t\tref: string,\n\t\toptions?: { branch?: string; commitDate?: Date; mode?: 'contains' | 'pointsAt'; remotes?: boolean },\n\t): Promise<string[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitBranches(path, ref, options);\n\t}\n\n\t@log()\n\tgetCommitCount(repoPath: string | Uri, ref: string): Promise<number | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitCount(path, ref);\n\t}\n\n\t@log()\n\tasync getCommitForFile(\n\t\trepoPath: string | Uri | undefined,\n\t\turi: Uri,\n\t\toptions?: { ref?: string; firstIfNotFound?: boolean; range?: Range },\n\t): Promise<GitCommit | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitForFile(path, uri, options);\n\t}\n\n\t@log()\n\tgetCommitsForGraph(\n\t\trepoPath: string | Uri,\n\t\tasWebviewUri: (uri: Uri) => Uri,\n\t\toptions?: {\n\t\t\tbranch?: string;\n\t\t\tinclude?: { stats?: boolean };\n\t\t\tlimit?: number;\n\t\t\tref?: string;\n\t\t},\n\t): Promise<GitGraph> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCommitsForGraph(path, asWebviewUri, options);\n\t}\n\n\t@log()\n\tasync getConfig(repoPath: string, key: string): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getConfig?.(path, key);\n\t}\n\n\t@log()\n\tasync setConfig(repoPath: string, key: string, value: string | undefined): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.setConfig?.(path, key, value);\n\t}\n\n\t@log()\n\tasync getContributors(\n\t\trepoPath: string | Uri,\n\t\toptions?: { all?: boolean; ref?: string; stats?: boolean },\n\t): Promise<GitContributor[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getContributors(path, options);\n\t}\n\n\t@gate()\n\t@log()\n\tgetCurrentUser(repoPath: string | Uri): Promise<GitUser | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getCurrentUser(path);\n\t}\n\n\t@log()\n\tasync getDefaultBranchName(repoPath: string | Uri | undefined, remote?: string): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDefaultBranchName(path, remote);\n\t}\n\n\t@log()\n\tasync getDiff(\n\t\trepoPath: string | Uri,\n\t\tref1: string,\n\t\tref2?: string,\n\t\toptions?: { includeRawDiff?: boolean },\n\t): Promise<GitDiff | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiff?.(path, ref1, ref2, options);\n\t}\n\n\t@log()\n\t/**\n\t * Returns a file diff between two commits\n\t * @param uri Uri of the file to diff\n\t * @param ref1 Commit to diff from\n\t * @param ref2 Commit to diff to\n\t */\n\tgetDiffForFile(uri: GitUri, ref1: string | undefined, ref2?: string): Promise<GitDiff | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForFile(uri, ref1, ref2);\n\t}\n\n\t@log<GitProviderService['getDiffForFileContents']>({ args: { 1: '<contents>' } })\n\t/**\n\t * Returns a file diff between a commit and the specified contents\n\t * @param uri Uri of the file to diff\n\t * @param ref Commit to diff from\n\t * @param contents Contents to use for the diff\n\t */\n\tgetDiffForFileContents(uri: GitUri, ref: string, contents: string): Promise<GitDiff | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForFileContents(uri, ref, contents);\n\t}\n\n\t@log()\n\t/**\n\t * Returns a line diff between two commits\n\t * @param uri Uri of the file to diff\n\t * @param editorLine Editor line number (0-based) to blame (Git is 1-based)\n\t * @param ref1 Commit to diff from\n\t * @param ref2 Commit to diff to\n\t */\n\tgetDiffForLine(\n\t\turi: GitUri,\n\t\teditorLine: number,\n\t\tref1: string | undefined,\n\t\tref2?: string,\n\t): Promise<GitDiffHunkLine | undefined> {\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.getDiffForLine(uri, editorLine, ref1, ref2);\n\t}\n\n\t@log()\n\tgetDiffStatus(\n\t\trepoPath: string | Uri,\n\t\tref1?: string,\n\t\tref2?: string,\n\t\toptions?: { filters?: GitDiffFilter[]; similarityThreshold?: number },\n\t): Promise<GitFile[] | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiffStatus(path, ref1, ref2, options);\n\t}\n\n\t@log()\n\tasync getFileStatusForCommit(repoPath: string | Uri, uri: Uri, ref: string): Promise<GitFile | undefined> {\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getFileStatusForCommit(path, uri, ref);\n\t}\n\n\t@debug()\n\tgetGitDir(repoPath: string): Promise<GitDir | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.getGitDir?.(path));\n\t}\n\n\t@debug()\n\tgetLastFetchedTimestamp(repoPath: string | Uri): Promise<number | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLastFetchedTimestamp(path);\n\t}\n\n\t@log()\n\tasync getLog(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLog(path, options);\n\t}\n\n\t@log()\n\tasync getLogRefsOnly(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tauthors?: GitUser[];\n\t\t\tlimit?: number;\n\t\t\tmerges?: boolean;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tref?: string;\n\t\t\tsince?: string;\n\t\t},\n\t): Promise<Set<string> | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLogRefsOnly(path, options);\n\t}\n\n\t@log()\n\tasync getLogForFile(\n\t\trepoPath: string | Uri | undefined,\n\t\tpathOrUri: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tforce?: boolean;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\trange?: Range;\n\t\t\tref?: string;\n\t\t\trenames?: boolean;\n\t\t\treverse?: boolean;\n\t\t\tsince?: string;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitLog | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getLogForFile(path, pathOrUri, options);\n\t}\n\n\t@log()\n\tasync getMergeBase(\n\t\trepoPath: string | Uri,\n\t\tref1: string,\n\t\tref2: string,\n\t\toptions?: { forkPoint?: boolean },\n\t): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getMergeBase(path, ref1, ref2, options);\n\t}\n\n\t@gate()\n\t@log()\n\tasync getMergeStatus(repoPath: string | Uri): Promise<GitMergeStatus | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getMergeStatus(path);\n\t}\n\n\t@gate()\n\t@log()\n\tasync getRebaseStatus(repoPath: string | Uri): Promise<GitRebaseStatus | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getRebaseStatus(path);\n\t}\n\n\t@log()\n\tgetNextComparisonUris(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<NextComparisonUrisResult | undefined> {\n\t\tif (!ref) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getNextComparisonUris(path, uri, ref, skip);\n\t}\n\n\t@log()\n\tasync getOldestUnpushedRefForFile(repoPath: string | Uri, uri: Uri): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getOldestUnpushedRefForFile(path, uri);\n\t}\n\n\t@log()\n\tgetPreviousComparisonUris(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t\tfirstParent: boolean = false,\n\t): Promise<PreviousComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getPreviousComparisonUris(path, uri, ref, skip, firstParent);\n\t}\n\n\t@log()\n\tgetPreviousComparisonUrisForLine(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\teditorLine: number,\n\t\tref: string | undefined,\n\t\tskip: number = 0,\n\t): Promise<PreviousLineComparisonUrisResult | undefined> {\n\t\tif (ref === deletedOrMissing) return Promise.resolve(undefined);\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getPreviousComparisonUrisForLine(path, uri, editorLine, ref, skip);\n\t}\n\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tremote: GitRemote<RemoteProvider | RichRemoteProvider>,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tprovider: RichRemoteProvider,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\t@gate<GitProviderService['getPullRequestForBranch']>((branch, remoteOrProvider, options) => {\n\t\tconst provider = GitRemote.is(remoteOrProvider) ? remoteOrProvider.provider : remoteOrProvider;\n\t\treturn `${branch}${\n\t\t\tprovider != null ? `|${provider.id}:${provider.domain}/${provider.path}` : ''\n\t\t}|${JSON.stringify(options)}`;\n\t})\n\t@debug<GitProviderService['getPullRequestForBranch']>({ args: { 1: remoteOrProvider => remoteOrProvider.name } })\n\tasync getPullRequestForBranch(\n\t\tbranch: string,\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { avatarSize?: number; include?: PullRequestState[]; limit?: number; timeout?: number },\n\t): Promise<PullRequest | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPR = provider.getPullRequestForBranch(branch, options);\n\t\tif (promiseOrPR == null || !isPromise(promiseOrPR)) {\n\t\t\treturn promiseOrPR;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPR = cancellable(promiseOrPR, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPR;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tremote: GitRemote,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tprovider: RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined>;\n\t@gate<GitProviderService['getPullRequestForCommit']>((ref, remoteOrProvider, options) => {\n\t\tconst provider = GitRemote.is(remoteOrProvider) ? remoteOrProvider.provider : remoteOrProvider;\n\t\treturn `${ref}${provider != null ? `|${provider.id}:${provider.domain}/${provider.path}` : ''}|${\n\t\t\toptions?.timeout\n\t\t}`;\n\t})\n\t@debug<GitProviderService['getPullRequestForCommit']>({ args: { 1: remoteOrProvider => remoteOrProvider.name } })\n\tasync getPullRequestForCommit(\n\t\tref: string,\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<PullRequest | undefined> {\n\t\tif (isUncommitted(ref)) return undefined;\n\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet promiseOrPR = provider.getPullRequestForCommit(ref);\n\t\tif (promiseOrPR == null || !isPromise(promiseOrPR)) {\n\t\t\treturn promiseOrPR;\n\t\t}\n\n\t\tif (options?.timeout != null && options.timeout > 0) {\n\t\t\tpromiseOrPR = cancellable(promiseOrPR, options.timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPR;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getMyPullRequests']>({ args: { 0: remoteOrProvider => remoteOrProvider.name } })\n\tasync getMyPullRequests(\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<SearchedPullRequest[] | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPRs = provider.searchMyPullRequests();\n\t\tif (promiseOrPRs == null || !isPromise(promiseOrPRs)) {\n\t\t\treturn promiseOrPRs;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPRs = cancellable(promiseOrPRs, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPRs;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@debug<GitProviderService['getMyIssues']>({ args: { 0: remoteOrProvider => remoteOrProvider.name } })\n\tasync getMyIssues(\n\t\tremoteOrProvider: GitRemote | RichRemoteProvider,\n\t\toptions?: { timeout?: number },\n\t): Promise<SearchedIssue[] | undefined> {\n\t\tlet provider;\n\t\tif (GitRemote.is(remoteOrProvider)) {\n\t\t\t({ provider } = remoteOrProvider);\n\t\t\tif (!provider?.hasRichIntegration()) return undefined;\n\t\t} else {\n\t\t\tprovider = remoteOrProvider;\n\t\t}\n\n\t\tlet timeout;\n\t\tif (options != null) {\n\t\t\t({ timeout, ...options } = options);\n\t\t}\n\n\t\tlet promiseOrPRs = provider.searchMyIssues();\n\t\tif (promiseOrPRs == null || !isPromise(promiseOrPRs)) {\n\t\t\treturn promiseOrPRs;\n\t\t}\n\n\t\tif (timeout != null && timeout > 0) {\n\t\t\tpromiseOrPRs = cancellable(promiseOrPRs, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn await promiseOrPRs;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof PromiseCancelledError) throw ex;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@log()\n\tasync getIncomingActivity(\n\t\trepoPath: string | Uri,\n\t\toptions?: {\n\t\t\tall?: boolean;\n\t\t\tbranch?: string;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo' | null;\n\t\t\tskip?: number;\n\t\t},\n\t): Promise<GitReflog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getIncomingActivity(path, options);\n\t}\n\n\tasync getBestRemoteWithProvider(\n\t\trepoPath: string | Uri | undefined,\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined>;\n\tasync getBestRemoteWithProvider(\n\t\tremotes: GitRemote[],\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined>;\n\t@gate<GitProviderService['getBestRemoteWithProvider']>(\n\t\tremotesOrRepoPath =>\n\t\t\t`${\n\t\t\t\tremotesOrRepoPath == null || typeof remotesOrRepoPath === 'string'\n\t\t\t\t\t? remotesOrRepoPath\n\t\t\t\t\t: remotesOrRepoPath instanceof Uri\n\t\t\t\t\t? remotesOrRepoPath.toString()\n\t\t\t\t\t: `${remotesOrRepoPath.length}:${remotesOrRepoPath[0]?.repoPath ?? ''}`\n\t\t\t}`,\n\t)\n\t@log<GitProviderService['getBestRemoteWithProvider']>({\n\t\targs: {\n\t\t\t0: remotesOrRepoPath =>\n\t\t\t\tArray.isArray(remotesOrRepoPath) ? remotesOrRepoPath.map(r => r.name).join(',') : remotesOrRepoPath,\n\t\t},\n\t})\n\tasync getBestRemoteWithProvider(\n\t\tremotesOrRepoPath: GitRemote[] | string | Uri | undefined,\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider> | undefined> {\n\t\tif (remotesOrRepoPath == null) return undefined;\n\n\t\tlet remotes;\n\t\tlet repoPath;\n\t\tif (Array.isArray(remotesOrRepoPath)) {\n\t\t\tif (remotesOrRepoPath.length === 0) return undefined;\n\n\t\t\tremotes = remotesOrRepoPath;\n\t\t\trepoPath = remotesOrRepoPath[0].repoPath;\n\t\t} else {\n\t\t\trepoPath = remotesOrRepoPath;\n\t\t}\n\n\t\tif (typeof repoPath === 'string') {\n\t\t\trepoPath = this.getAbsoluteUri(repoPath);\n\t\t}\n\n\t\tconst cacheKey = asRepoComparisonKey(repoPath);\n\t\tlet remote = this._bestRemotesCache.get(cacheKey);\n\t\tif (remote !== undefined) return remote ?? undefined;\n\n\t\tremotes = (remotes ?? (await this.getRemotesWithProviders(repoPath))).filter(\n\t\t\t(r: GitRemote): r is GitRemote<RemoteProvider | RichRemoteProvider> => r.provider != null,\n\t\t);\n\n\t\tif (remotes.length === 0) return undefined;\n\n\t\tif (remotes.length === 1) {\n\t\t\tremote = remotes[0];\n\t\t} else {\n\t\t\tconst weightedRemotes = new Map<string, number>([\n\t\t\t\t['upstream', 15],\n\t\t\t\t['origin', 10],\n\t\t\t]);\n\n\t\t\tconst branch = await this.getBranch(remotes[0].repoPath);\n\t\t\tconst branchRemote = branch?.getRemoteName();\n\n\t\t\tif (branchRemote != null) {\n\t\t\t\tweightedRemotes.set(branchRemote, 100);\n\t\t\t}\n\n\t\t\tlet bestRemote;\n\t\t\tlet weight = 0;\n\t\t\tfor (const r of remotes) {\n\t\t\t\tif (r.default) {\n\t\t\t\t\tbestRemote = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Don't choose a remote unless its weighted above\n\t\t\t\tconst matchedWeight = weightedRemotes.get(r.name) ?? -1;\n\t\t\t\tif (matchedWeight > weight) {\n\t\t\t\t\tbestRemote = r;\n\t\t\t\t\tweight = matchedWeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremote = bestRemote ?? null;\n\t\t}\n\n\t\tthis._bestRemotesCache.set(cacheKey, remote);\n\n\t\treturn remote ?? undefined;\n\t}\n\n\tasync getBestRemoteWithRichProvider(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined>;\n\tasync getBestRemoteWithRichProvider(\n\t\tremotes: GitRemote[],\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined>;\n\t@gate<GitProviderService['getBestRemoteWithRichProvider']>(\n\t\t(remotesOrRepoPath, options) =>\n\t\t\t`${\n\t\t\t\tremotesOrRepoPath == null || typeof remotesOrRepoPath === 'string'\n\t\t\t\t\t? remotesOrRepoPath\n\t\t\t\t\t: remotesOrRepoPath instanceof Uri\n\t\t\t\t\t? remotesOrRepoPath.toString()\n\t\t\t\t\t: `${remotesOrRepoPath.length}:${remotesOrRepoPath[0]?.repoPath ?? ''}`\n\t\t\t}|${options?.includeDisconnected ?? false}`,\n\t)\n\t@log<GitProviderService['getBestRemoteWithRichProvider']>({\n\t\targs: {\n\t\t\t0: remotesOrRepoPath =>\n\t\t\t\tArray.isArray(remotesOrRepoPath) ? remotesOrRepoPath.map(r => r.name).join(',') : remotesOrRepoPath,\n\t\t},\n\t})\n\tasync getBestRemoteWithRichProvider(\n\t\tremotesOrRepoPath: GitRemote[] | string | Uri | undefined,\n\t\toptions?: { includeDisconnected?: boolean },\n\t): Promise<GitRemote<RichRemoteProvider> | undefined> {\n\t\tif (remotesOrRepoPath == null) return undefined;\n\n\t\tlet remotes;\n\t\tlet repoPath;\n\t\tif (Array.isArray(remotesOrRepoPath)) {\n\t\t\tif (remotesOrRepoPath.length === 0) return undefined;\n\n\t\t\tremotes = remotesOrRepoPath;\n\t\t\trepoPath = remotesOrRepoPath[0].repoPath;\n\t\t} else {\n\t\t\trepoPath = remotesOrRepoPath;\n\t\t}\n\n\t\tif (typeof repoPath === 'string') {\n\t\t\trepoPath = this.getAbsoluteUri(repoPath);\n\t\t}\n\n\t\tconst cacheKey = asRepoComparisonKey(repoPath);\n\n\t\tlet richRemote = this._bestRemotesCache.get(`rich+connected|${cacheKey}`);\n\t\tif (richRemote != null) return richRemote;\n\t\tif (richRemote === null && !options?.includeDisconnected) return undefined;\n\n\t\tif (options?.includeDisconnected) {\n\t\t\trichRemote = this._bestRemotesCache.get(`rich|${cacheKey}`);\n\t\t\tif (richRemote !== undefined) return richRemote ?? undefined;\n\t\t}\n\n\t\tconst remote = await (remotes != null\n\t\t\t? this.getBestRemoteWithProvider(remotes)\n\t\t\t: this.getBestRemoteWithProvider(repoPath));\n\n\t\tif (!remote?.hasRichProvider()) {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, null);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, null);\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst { provider } = remote;\n\t\tconst connected = provider.maybeConnected ?? (await provider.isConnected());\n\t\tif (connected) {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, remote);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, remote);\n\t\t} else {\n\t\t\tthis._bestRemotesCache.set(`rich|${cacheKey}`, remote);\n\t\t\tthis._bestRemotesCache.set(`rich+connected|${cacheKey}`, null);\n\n\t\t\tif (!options?.includeDisconnected) return undefined;\n\t\t}\n\n\t\treturn remote;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getRemotes(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { providers?: RemoteProviders; sort?: boolean },\n\t): Promise<GitRemote[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getRemotes(path, options);\n\t}\n\n\t@log()\n\tasync getRemotesWithProviders(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { sort?: boolean },\n\t): Promise<GitRemote<RemoteProvider | RichRemoteProvider>[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst repository = this.container.git.getRepository(repoPath);\n\t\tconst remotes = await (repository != null\n\t\t\t? repository.getRemotes(options)\n\t\t\t: this.getRemotes(repoPath, options));\n\n\t\treturn remotes.filter(\n\t\t\t(r: GitRemote): r is GitRemote<RemoteProvider | RichRemoteProvider> => r.provider != null,\n\t\t);\n\t}\n\n\tgetBestRepository(): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepository(uri?: Uri, editor?: TextEditor): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepository(editor?: TextEditor): Repository | undefined;\n\t@log({ exit: true })\n\tgetBestRepository(editorOrUri?: TextEditor | Uri, editor?: TextEditor): Repository | undefined {\n\t\tconst count = this.repositoryCount;\n\t\tif (count === 0) return undefined;\n\t\tif (count === 1) return this.highlander;\n\n\t\tif (editorOrUri != null && editorOrUri instanceof Uri) {\n\t\t\tconst repo = this.getRepository(editorOrUri);\n\t\t\tif (repo != null) return repo;\n\n\t\t\teditorOrUri = undefined;\n\t\t}\n\n\t\teditor = editorOrUri ?? editor ?? window.activeTextEditor;\n\t\treturn (editor != null ? this.getRepository(editor.document.uri) : undefined) ?? this.highlander;\n\t}\n\n\tgetBestRepositoryOrFirst(): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepositoryOrFirst(uri?: Uri, editor?: TextEditor): Repository | undefined;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\tgetBestRepositoryOrFirst(editor?: TextEditor): Repository | undefined;\n\t@log({ exit: true })\n\tgetBestRepositoryOrFirst(editorOrUri?: TextEditor | Uri, editor?: TextEditor): Repository | undefined {\n\t\tconst count = this.repositoryCount;\n\t\tif (count === 0) return undefined;\n\t\tif (count === 1) return first(this._repositories.values());\n\n\t\tif (editorOrUri != null && editorOrUri instanceof Uri) {\n\t\t\tconst repo = this.getRepository(editorOrUri);\n\t\t\tif (repo != null) return repo;\n\n\t\t\teditorOrUri = undefined;\n\t\t}\n\n\t\teditor = editorOrUri ?? editor ?? window.activeTextEditor;\n\t\treturn (\n\t\t\t(editor != null ? this.getRepository(editor.document.uri) : undefined) ?? first(this._repositories.values())\n\t\t);\n\t}\n\n\t@log({ exit: true })\n\tasync getOrOpenRepository(\n\t\turi: Uri,\n\t\toptions?: { closeOnOpen?: boolean; detectNested?: boolean; force?: boolean },\n\t): Promise<Repository | undefined> {\n\t\tconst scope = getLogScope();\n\n\t\tconst path = getBestPath(uri);\n\t\tlet repository: Repository | undefined;\n\t\trepository = this.getRepository(uri);\n\n\t\tlet isDirectory: boolean | undefined;\n\n\t\tconst detectNested = options?.detectNested ?? configuration.get('detectNestedRepositories', uri);\n\t\tif (!detectNested) {\n\t\t\tif (repository != null) return repository;\n\t\t} else if (!options?.force && this._visitedPaths.has(path)) {\n\t\t\treturn repository;\n\t\t} else {\n\t\t\tconst stats = await workspace.fs.stat(uri);\n\t\t\t// If the uri isn't a directory, go up one level\n\t\t\tif ((stats.type & FileType.Directory) !== FileType.Directory) {\n\t\t\t\turi = Uri.joinPath(uri, '..');\n\t\t\t\tif (!options?.force && this._visitedPaths.has(getBestPath(uri))) return repository;\n\t\t\t}\n\n\t\t\tisDirectory = true;\n\t\t}\n\n\t\tconst key = asRepoComparisonKey(uri);\n\t\tlet promise = this._pendingRepositories.get(key);\n\t\tif (promise == null) {\n\t\t\tasync function findRepository(this: GitProviderService): Promise<Repository | undefined> {\n\t\t\t\tconst { provider } = this.getProvider(uri);\n\t\t\t\tconst repoUri = await provider.findRepositoryUri(uri, isDirectory);\n\n\t\t\t\tthis._visitedPaths.set(path);\n\n\t\t\t\tif (repoUri == null) return undefined;\n\n\t\t\t\tlet root: Repository | undefined;\n\t\t\t\tif (this._repositories.count !== 0) {\n\t\t\t\t\trepository = this._repositories.get(repoUri);\n\t\t\t\t\tif (repository != null) return repository;\n\n\t\t\t\t\t// If this new repo is inside one of our known roots and we we don't already know about, add it\n\t\t\t\t\troot = this._repositories.getClosest(provider.getAbsoluteUri(uri, repoUri));\n\t\t\t\t}\n\n\t\t\t\tconst autoRepositoryDetection =\n\t\t\t\t\tconfiguration.getAny<CoreGitConfiguration, boolean | 'subFolders' | 'openEditors'>(\n\t\t\t\t\t\t'git.autoRepositoryDetection',\n\t\t\t\t\t) ?? true;\n\n\t\t\t\tconst closed =\n\t\t\t\t\toptions?.closeOnOpen ??\n\t\t\t\t\t(autoRepositoryDetection !== true && autoRepositoryDetection !== 'openEditors');\n\n\t\t\t\tLogger.log(scope, `Repository found in '${repoUri.toString(true)}'`);\n\t\t\t\tconst repositories = provider.openRepository(root?.folder, repoUri, false, undefined, closed);\n\t\t\t\tfor (const repository of repositories) {\n\t\t\t\t\tthis._repositories.add(repository);\n\t\t\t\t}\n\n\t\t\t\tthis._pendingRepositories.delete(key);\n\n\t\t\t\tthis.updateContext();\n\t\t\t\t// Send a notification that the repositories changed\n\t\t\t\tqueueMicrotask(() => this.fireRepositoriesChanged(repositories));\n\n\t\t\t\trepository = repositories.length === 1 ? repositories[0] : this.getRepository(uri);\n\t\t\t\treturn repository;\n\t\t\t}\n\n\t\t\tpromise = findRepository.call(this);\n\t\t\tthis._pendingRepositories.set(key, promise);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t@log<GitProviderService['getOrOpenRepositoryForEditor']>({\n\t\targs: { 0: e => (e != null ? `TextEditor(${Logger.toLoggable(e.document.uri)})` : undefined) },\n\t})\n\tasync getOrOpenRepositoryForEditor(editor?: TextEditor): Promise<Repository | undefined> {\n\t\teditor = editor ?? window.activeTextEditor;\n\n\t\tif (editor == null) return this.highlander;\n\n\t\treturn this.getOrOpenRepository(editor.document.uri);\n\t}\n\n\tgetRepository(uri: Uri): Repository | undefined;\n\tgetRepository(path: string): Repository | undefined;\n\tgetRepository(pathOrUri: string | Uri): Repository | undefined;\n\t@log({ exit: true })\n\tgetRepository(pathOrUri?: string | Uri): Repository | undefined {\n\t\tif (this.repositoryCount === 0) return undefined;\n\t\tif (pathOrUri == null) return undefined;\n\n\t\tif (typeof pathOrUri === 'string') {\n\t\t\tif (!pathOrUri) return undefined;\n\n\t\t\treturn this._repositories.getClosest(this.getAbsoluteUri(pathOrUri));\n\t\t}\n\n\t\treturn this._repositories.getClosest(pathOrUri);\n\t}\n\n\tasync getLocalInfoFromRemoteUri(\n\t\turi: Uri,\n\t\toptions?: { validate?: boolean },\n\t): Promise<{ uri: Uri; startLine?: number; endLine?: number } | undefined> {\n\t\tfor (const repo of this.openRepositories) {\n\t\t\tfor (const remote of await repo.getRemotes()) {\n\t\t\t\tconst local = await remote?.provider?.getLocalInfoFromRemoteUri(repo, uri, options);\n\t\t\t\tif (local != null) return local;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@gate()\n\t@log()\n\tasync getStash(repoPath: string | Uri | undefined): Promise<GitStash | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStash(path);\n\t}\n\n\t@log()\n\tasync getStatusForFile(repoPath: string | Uri, uri: Uri): Promise<GitStatusFile | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForFile(path, uri);\n\t}\n\n\t@log()\n\tasync getStatusForFiles(repoPath: string | Uri, pathOrGlob: Uri): Promise<GitStatusFile[] | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForFiles(path, pathOrGlob);\n\t}\n\n\t@log()\n\tasync getStatusForRepo(repoPath: string | Uri | undefined): Promise<GitStatus | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getStatusForRepo(path);\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync getTags(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: { cursor?: string; filter?: (t: GitTag) => boolean; sort?: boolean | TagSortOptions },\n\t): Promise<PagedResult<GitTag>> {\n\t\tif (repoPath == null) return { values: [] };\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getTags(path, options);\n\t}\n\n\t@log()\n\tasync getTreeEntryForRevision(\n\t\trepoPath: string | Uri | undefined,\n\t\tpath: string,\n\t\tref: string,\n\t): Promise<GitTreeEntry | undefined> {\n\t\tif (repoPath == null || !path) return undefined;\n\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getTreeEntryForRevision(rp, provider.getRelativePath(path, rp), ref);\n\t}\n\n\t@log()\n\tasync getTreeForRevision(repoPath: string | Uri | undefined, ref: string): Promise<GitTreeEntry[]> {\n\t\tif (repoPath == null) return [];\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getTreeForRevision(path, ref);\n\t}\n\n\t@gate()\n\t@log()\n\tgetRevisionContent(repoPath: string | Uri, path: string, ref: string): Promise<Uint8Array | undefined> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn provider.getRevisionContent(rp, path, ref);\n\t}\n\n\t@log()\n\tasync getUniqueRepositoryId(repoPath: string | Uri): Promise<string | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\tconst id = await provider.getUniqueRepositoryId(path);\n\t\tif (id != null) return id;\n\n\t\treturn defaultRepositoryId;\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasBranchOrTag(\n\t\trepoPath: string | Uri | undefined,\n\t\toptions?: {\n\t\t\tfilter?: { branches?: (b: GitBranch) => boolean; tags?: (t: GitTag) => boolean };\n\t\t},\n\t): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.hasBranchOrTag(path, options);\n\t}\n\n\t@log({ args: { 1: false } })\n\tasync hasCommitBeenPushed(repoPath: string | Uri, ref: string): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.hasCommitBeenPushed(path, ref);\n\t}\n\n\t@log()\n\tasync hasRemotes(repoPath: string | Uri | undefined): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst repository = this.getRepository(repoPath);\n\t\tif (repository == null) return false;\n\n\t\treturn repository.hasRemotes();\n\t}\n\n\t@log()\n\tasync hasTrackingBranch(repoPath: string | undefined): Promise<boolean> {\n\t\tif (repoPath == null) return false;\n\n\t\tconst repository = this.getRepository(repoPath);\n\t\tif (repository == null) return false;\n\n\t\treturn repository.hasUpstreamBranch();\n\t}\n\n\t@log()\n\thasUnsafeRepositories(): boolean {\n\t\tfor (const provider of this._providers.values()) {\n\t\t\tif (provider.hasUnsafeRepositories?.()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@log<GitProviderService['isRepositoryForEditor']>({\n\t\targs: {\n\t\t\t0: r => r.uri.toString(true),\n\t\t\t1: e => (e != null ? `TextEditor(${Logger.toLoggable(e.document.uri)})` : undefined),\n\t\t},\n\t})\n\tisRepositoryForEditor(repository: Repository, editor?: TextEditor): boolean {\n\t\teditor = editor ?? window.activeTextEditor;\n\t\tif (editor == null) return false;\n\n\t\treturn repository === this.getRepository(editor.document.uri);\n\t}\n\n\tisTrackable(uri: Uri): boolean {\n\t\tif (!this.supportedSchemes.has(uri.scheme)) return false;\n\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.isTrackable(uri);\n\t}\n\n\tasync isTracked(uri: Uri): Promise<boolean> {\n\t\tif (!this.supportedSchemes.has(uri.scheme)) return false;\n\n\t\tconst { provider } = this.getProvider(uri);\n\t\treturn provider.isTracked(uri);\n\t}\n\n\t@log()\n\tasync getDiffTool(repoPath?: string | Uri): Promise<string | undefined> {\n\t\tif (repoPath == null) return undefined;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getDiffTool(path);\n\t}\n\n\t@log()\n\tasync openDiffTool(\n\t\trepoPath: string | Uri,\n\t\turi: Uri,\n\t\toptions?: { ref1?: string; ref2?: string; staged?: boolean; tool?: string },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.openDiffTool(path, uri, options);\n\t}\n\n\t@log()\n\tasync openDirectoryCompare(repoPath: string | Uri, ref1: string, ref2?: string, tool?: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.openDirectoryCompare(path, ref1, ref2, tool);\n\t}\n\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\tpath?: string,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t): Promise<string>;\n\tasync resolveReference(\n\t\trepoPath: string,\n\t\tref: string,\n\t\turi?: Uri,\n\t\toptions?: { force?: boolean; timeout?: number },\n\t): Promise<string>;\n\t@gate()\n\t@log()\n\tasync resolveReference(\n\t\trepoPath: string | Uri,\n\t\tref: string,\n\t\tpathOrUri?: string | Uri,\n\t\toptions?: { timeout?: number },\n\t) {\n\t\tif (pathOrUri != null && isUncommittedParent(ref)) {\n\t\t\tref = 'HEAD';\n\t\t}\n\n\t\tif (\n\t\t\t!ref ||\n\t\t\tref === deletedOrMissing ||\n\t\t\t(pathOrUri == null && isSha(ref)) ||\n\t\t\t(pathOrUri != null && isUncommitted(ref))\n\t\t) {\n\t\t\treturn ref;\n\t\t}\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.resolveReference(path, ref, pathOrUri, options);\n\t}\n\n\t@log<GitProviderService['richSearchCommits']>({\n\t\targs: {\n\t\t\t1: s =>\n\t\t\t\t`[${s.matchAll ? 'A' : ''}${s.matchCase ? 'C' : ''}${s.matchRegex ? 'R' : ''}]: ${\n\t\t\t\t\ts.query.length > 500 ? `${s.query.substring(0, 500)}...` : s.query\n\t\t\t\t}`,\n\t\t},\n\t})\n\tasync richSearchCommits(\n\t\trepoPath: string | Uri,\n\t\tsearch: SearchQuery,\n\t\toptions?: { limit?: number; ordering?: 'date' | 'author-date' | 'topo' | null; skip?: number },\n\t): Promise<GitLog | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.richSearchCommits(path, search, options);\n\t}\n\n\t@log()\n\tsearchCommits(\n\t\trepoPath: string | Uri,\n\t\tsearch: SearchQuery,\n\t\toptions?: {\n\t\t\tcancellation?: CancellationToken;\n\t\t\tlimit?: number;\n\t\t\tordering?: 'date' | 'author-date' | 'topo';\n\t\t},\n\t): Promise<GitSearch> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.searchCommits(path, search, options);\n\t}\n\n\t@log({ args: false })\n\tasync runGitCommandViaTerminal(\n\t\trepoPath: string | Uri,\n\t\tcommand: string,\n\t\targs: string[],\n\t\toptions?: { execute?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.runGitCommandViaTerminal?.(path, command, args, options);\n\t}\n\n\t@log()\n\tvalidateBranchOrTagName(repoPath: string | Uri, ref: string): Promise<boolean> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.validateBranchOrTagName(path, ref);\n\t}\n\n\t@log()\n\tasync validateReference(repoPath: string | Uri, ref: string) {\n\t\tif (ref == null || ref.length === 0) return false;\n\t\tif (ref === deletedOrMissing || isUncommitted(ref)) return true;\n\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.validateReference(path, ref);\n\t}\n\n\tstageFile(repoPath: string | Uri, path: string): Promise<void>;\n\tstageFile(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tstageFile(repoPath: string | Uri, pathOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stageFile(path, pathOrUri);\n\t}\n\n\tstageDirectory(repoPath: string | Uri, directory: string): Promise<void>;\n\tstageDirectory(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tstageDirectory(repoPath: string | Uri, directoryOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stageDirectory(path, directoryOrUri);\n\t}\n\n\tunStageFile(repoPath: string | Uri, path: string): Promise<void>;\n\tunStageFile(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tunStageFile(repoPath: string | Uri, pathOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.unStageFile(path, pathOrUri);\n\t}\n\n\tunStageDirectory(repoPath: string | Uri, directory: string): Promise<void>;\n\tunStageDirectory(repoPath: string | Uri, uri: Uri): Promise<void>;\n\t@log()\n\tunStageDirectory(repoPath: string | Uri, directoryOrUri: string | Uri): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.unStageDirectory(path, directoryOrUri);\n\t}\n\n\t@log()\n\tasync stashApply(repoPath: string | Uri, stashName: string, options?: { deleteAfter?: boolean }): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashApply?.(path, stashName, options);\n\t}\n\n\t@log()\n\tasync stashDelete(repoPath: string | Uri, stashName: string, ref?: string): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashDelete?.(path, stashName, ref);\n\t}\n\n\t@log()\n\tasync stashRename(\n\t\trepoPath: string | Uri,\n\t\tstashName: string,\n\t\tref: string,\n\t\tmessage: string,\n\t\tstashOnRef?: string,\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashRename?.(path, stashName, ref, message, stashOnRef);\n\t}\n\n\t@log<GitProviderService['stashSave']>({ args: { 2: uris => uris?.length } })\n\tasync stashSave(\n\t\trepoPath: string | Uri,\n\t\tmessage?: string,\n\t\turis?: Uri[],\n\t\toptions?: { includeUntracked?: boolean; keepIndex?: boolean; onlyStaged?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.stashSave?.(path, message, uris, options);\n\t}\n\n\t@log()\n\tcreateWorktree(\n\t\trepoPath: string | Uri,\n\t\tpath: string,\n\t\toptions?: { commitish?: string; createBranch?: string; detach?: boolean; force?: boolean },\n\t): Promise<void> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.createWorktree?.(rp, path, options));\n\t}\n\n\t@log()\n\tasync getWorktree(\n\t\trepoPath: string | Uri,\n\t\tpredicate: (w: GitWorktree) => boolean,\n\t): Promise<GitWorktree | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn ((await provider.getWorktrees?.(path)) ?? []).find(predicate);\n\t}\n\n\t@log()\n\tasync getWorktrees(repoPath: string | Uri): Promise<GitWorktree[]> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn (await provider.getWorktrees?.(path)) ?? [];\n\t}\n\n\t@log()\n\tasync getWorktreesDefaultUri(path: string | Uri): Promise<Uri | undefined> {\n\t\tconst { provider, path: rp } = this.getProvider(path);\n\t\tlet defaultUri = await provider.getWorktreesDefaultUri?.(rp);\n\t\tif (defaultUri != null) return defaultUri;\n\n\t\t// If we don't have a default set, default it to the parent folder of the repo folder\n\t\tdefaultUri = this.getRepository(rp)?.uri;\n\t\tif (defaultUri != null) {\n\t\t\tdefaultUri = Uri.joinPath(defaultUri, '..');\n\t\t}\n\t\treturn defaultUri;\n\t}\n\n\t@log()\n\tdeleteWorktree(repoPath: string | Uri, path: string, options?: { force?: boolean }): Promise<void> {\n\t\tconst { provider, path: rp } = this.getProvider(repoPath);\n\t\treturn Promise.resolve(provider.deleteWorktree?.(rp, path, options));\n\t}\n\t@log()\n\tasync getOpenScmRepositories(): Promise<ScmRepository[]> {\n\t\tconst results = await Promise.allSettled([...this._providers.values()].map(p => p.getOpenScmRepositories()));\n\t\tconst repositories = flatMap<PromiseFulfilledResult<ScmRepository[]>, ScmRepository>(\n\t\t\tfilter<PromiseSettledResult<ScmRepository[]>, PromiseFulfilledResult<ScmRepository[]>>(\n\t\t\t\tresults,\n\t\t\t\t(r): r is PromiseFulfilledResult<ScmRepository[]> => r.status === 'fulfilled',\n\t\t\t),\n\t\t\tr => r.value,\n\t\t);\n\t\treturn [...repositories];\n\t}\n\n\t@log()\n\tgetScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getScmRepository(path);\n\t}\n\n\t@log()\n\tgetOrOpenScmRepository(repoPath: string): Promise<ScmRepository | undefined> {\n\t\tconst { provider, path } = this.getProvider(repoPath);\n\t\treturn provider.getOrOpenScmRepository(path);\n\t}\n}\n", "<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t</head>\n\n\t<body class=\"home preload\">\n\t\t<a href=\"#links\" class=\"sr-skip sr-only-focusable\">skip to links</a>\n\t\t<a href=\"#main\" class=\"sr-skip sr-only-focusable\">skip to main content</a>\n\t\t<div class=\"home__nav\">\n\t\t\t<nav class=\"inline-nav\" id=\"links\" tabindex=\"-1\" aria-label=\"Help and Resources\">\n\t\t\t\t<div class=\"inline-nav__group\">\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://help.gitkraken.com/gitlens/gitlens-release-notes-current/\"\n\t\t\t\t\t\taria-label=\"What's New\"\n\t\t\t\t\t\ttitle=\"What's New\"\n\t\t\t\t\t\t><span class=\"codicon codicon-rocket\"></span><span>What's New</span></a\n\t\t\t\t\t>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://help.gitkraken.com/gitlens/gitlens-home/\"\n\t\t\t\t\t\taria-label=\"Help Center\"\n\t\t\t\t\t\ttitle=\"Help Center\"\n\t\t\t\t\t\t><span class=\"codicon codicon-question\"></span><span>Help</span></a\n\t\t\t\t\t>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link inline-nav__link--text\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens/issues\"\n\t\t\t\t\t\taria-label=\"Feedback\"\n\t\t\t\t\t\ttitle=\"Feedback\"\n\t\t\t\t\t\t><span class=\"codicon codicon-feedback\"></span><span>Feedback</span></a\n\t\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"inline-nav__group\">\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens/discussions\"\n\t\t\t\t\t\taria-label=\"GitHub Discussions\"\n\t\t\t\t\t\ttitle=\"GitHub Discussions\"\n\t\t\t\t\t\t><span class=\"codicon codicon-comment-discussion\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://github.com/gitkraken/vscode-gitlens\"\n\t\t\t\t\t\taria-label=\"GitHub Repo\"\n\t\t\t\t\t\ttitle=\"GitHub Repo\"\n\t\t\t\t\t\t><span class=\"codicon codicon-github\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://twitter.com/gitlens\"\n\t\t\t\t\t\taria-label=\"@gitlens on Twitter\"\n\t\t\t\t\t\ttitle=\"@gitlens on Twitter\"\n\t\t\t\t\t\t><span class=\"codicon codicon-twitter\"></span\n\t\t\t\t\t></a>\n\t\t\t\t\t<a\n\t\t\t\t\t\tclass=\"inline-nav__link\"\n\t\t\t\t\t\thref=\"https://gitkraken.com/gitlens?utm_source=gitlens-extension&utm_medium=in-app-links&utm_campaign=gitlens-logo-links\"\n\t\t\t\t\t\taria-label=\"GitLens Website\"\n\t\t\t\t\t\ttitle=\"GitLens Website\"\n\t\t\t\t\t\t><span class=\"codicon codicon-globe\"></span\n\t\t\t\t\t></a>\n\t\t\t\t</div>\n\t\t\t</nav>\n\t\t</div>\n\t\t<header class=\"home__header\">\n\t\t\t<div id=\"no-repo-alert\" class=\"alert alert--info mb-0\" aria-hidden=\"true\" hidden>\n\t\t\t\t<h1 class=\"alert__title\">No repository detected</h1>\n\t\t\t\t<div class=\"alert__description\">\n\t\t\t\t\t<p>\n\t\t\t\t\t\tTo use GitLens, open a folder containing a git repository or clone from a URL from the Explorer.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"centered\">\n\t\t\t\t\t\t<vscode-button data-action=\"command:workbench.view.explorer\"\n\t\t\t\t\t\t\t>Open a Folder or Repository</vscode-button\n\t\t\t\t\t\t>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tIf you have opened a folder with a repository, please let us know by\n\t\t\t\t\t\t<a class=\"one-line\" href=\"https://github.com/gitkraken/vscode-gitlens/issues/new/choose\"\n\t\t\t\t\t\t\t>creating an Issue</a\n\t\t\t\t\t\t>.\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div id=\"unsafe-repo-alert\" class=\"alert alert--info mb-0\" aria-hidden=\"true\" hidden>\n\t\t\t\t<h1 class=\"alert__title\">Unsafe repository</h1>\n\t\t\t\t<div class=\"alert__description\">\n\t\t\t\t\t<p>\n\t\t\t\t\t\tUnable to open any repositories as Git blocked them as potentially unsafe, due to the folder(s)\n\t\t\t\t\t\tnot being owned by the current user.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"centered\">\n\t\t\t\t\t\t<vscode-button data-action=\"command:workbench.view.scm\">Manage in Source Control</vscode-button>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div id=\"untrusted-alert\" class=\"alert alert--info mb-0\" aria-hidden=\"true\" hidden>\n\t\t\t\t<h1 class=\"alert__title\">Untrusted workspace</h1>\n\t\t\t\t<div class=\"alert__description\">\n\t\t\t\t\t<p>Unable to open repositories in Restricted Mode.</p>\n\t\t\t\t\t<p class=\"centered\">\n\t\t\t\t\t\t<vscode-button data-action=\"command:workbench.trust.manage\"\n\t\t\t\t\t\t\t>Manage Workspace Trust</vscode-button\n\t\t\t\t\t\t>\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<header-card id=\"header-card\" image=\"#{webroot}/media/gitlens-logo.webp\"></header-card>\n\t\t</header>\n\t\t<main class=\"home__main scrollable\" id=\"main\" tabindex=\"-1\">\n\t\t\t<style nonce=\"#{cspNonce}\">\n\t\t\t\t.video-banner {\n\t\t\t\t\t--video-banner-bg: url(#{webroot}/media/getting-started.webp);\n\t\t\t\t}\n\t\t\t\t.vscode-high-contrast .video-banner,\n\t\t\t\t.vscode-dark .video-banner {\n\t\t\t\t\t--video-banner-play: url(#{webroot}/media/play-button.webp);\n\t\t\t\t}\n\t\t\t\t.vscode-high-contrast-light .video-banner,\n\t\t\t\t.vscode-light .video-banner {\n\t\t\t\t\t--video-banner-play: url(#{webroot}/media/play-button-dark.webp);\n\t\t\t\t}\n\t\t\t\t.gl-plus-banner {\n\t\t\t\t\tbackground-image: url(#{webroot}/media/gitlens-backdrop-opacity.webp);\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<div class=\"stepped-sections\">\n\t\t\t\t<stepped-section id=\"welcome\">\n\t\t\t\t\t<span slot=\"heading\">Welcome to GitLens 13</span>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tGitLens supercharges Git inside VS Code and unlocks the untapped knowledge within each\n\t\t\t\t\t\trepository.\n\t\t\t\t\t</p>\n\t\t\t\t\t<a class=\"video-banner\" href=\"https://www.youtube.com/watch?v=UQPb73Zz9qk\">\n\t\t\t\t\t\t<span>Get Started</span> <small>Tutorial Video</small>\n\t\t\t\t\t</a>\n\t\t\t\t\t<ul class=\"icon-list mb-0\">\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<code-icon icon=\"circle-filled\"></code-icon>\n\t\t\t\t\t\t\t<a href=\"command:gitlens.showWelcomePage?%22quick-setup%22\">Quick Setup</a> &mdash; quickly\n\t\t\t\t\t\t\tpersonalize GitLens to your needs.\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t\t\t<code-icon icon=\"circle-filled\"></code-icon>\n\t\t\t\t\t\t\t<a href=\"command:gitlens.showSettingsPage\">Interactive Settings editor</a> &mdash; fine-tune\n\t\t\t\t\t\t\tyour GitLens experience.\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"features\">\n\t\t\t\t\t<span slot=\"heading\">Features</span>\n\t\t\t\t\t<span slot=\"description\">always free and accessible</span>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tGitLens is deeply integrated into many areas and aspects of VS Code, especially editors and\n\t\t\t\t\t\tviews. Learn more in the <a href=\"command:gitlens.getStarted\">Feature Walkthrough</a>.\n\t\t\t\t\t</p>\n\t\t\t\t\t<card-section no-heading id=\"no-repo\" aria-hidden=\"true\">\n\t\t\t\t\t\t<p class=\"centered mb-0\">\n\t\t\t\t\t\t\tTo use GitLens, open a folder containing a git repository or clone from a URL from the\n\t\t\t\t\t\t\tExplorer.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</card-section>\n\t\t\t\t\t<div class=\"activitybar-banner\">\n\t\t\t\t\t\t<div class=\"activitybar-banner__content\">\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\tFind many features by opening the\n\t\t\t\t\t\t\t\t<a href=\"command:workbench.view.scm\">Source Control Side Bar</a>.\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\tClick on\n\t\t\t\t\t\t\t\t<span aria-hidden=\"true\"\n\t\t\t\t\t\t\t\t\t>the icon <span class=\"not-small\">to the left</span\n\t\t\t\t\t\t\t\t\t><span class=\"only-small\">below</span></span\n\t\t\t\t\t\t\t\t><span class=\"sr-only\">a layout option</span> to set the location of your GitLens views.\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<nav class=\"activitybar-banner__media\" aria-label=\"GitLens Layout\">\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\thref=\"command:gitlens.setViewsLayout?%7B%22layout%22%3A%22scm%22%7D\"\n\t\t\t\t\t\t\t\tclass=\"activitybar-banner__nav-item\"\n\t\t\t\t\t\t\t\ttitle=\"Move views to the Source Control side bar\"\n\t\t\t\t\t\t\t\taria-label=\"Move views to the Source Control side bar\"\n\t\t\t\t\t\t\t></a>\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\thref=\"command:gitlens.setViewsLayout?%7B%22layout%22%3A%22gitlens%22%7D\"\n\t\t\t\t\t\t\t\tclass=\"activitybar-banner__nav-item\"\n\t\t\t\t\t\t\t\ttitle=\"Move views to the GitLens side bar\"\n\t\t\t\t\t\t\t\taria-label=\"Move views to the GitLens side bar\"\n\t\t\t\t\t\t\t></a>\n\t\t\t\t\t\t\t<svg\n\t\t\t\t\t\t\t\tclass=\"svg\"\n\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\t\t\tviewBox=\"0 0 68 91\"\n\t\t\t\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\t\t\t\tstyle=\"max-width: 9.2rem\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<rect x=\".5\" y=\".5\" width=\"40\" height=\"90\" rx=\"16.5\" stroke=\"url(#a)\" />\n\t\t\t\t\t\t\t\t<rect x=\"3\" y=\"3\" width=\"35\" height=\"85\" rx=\"14\" fill=\"#333\" class=\"svg__bar\" />\n\t\t\t\t\t\t\t\t<g clip-path=\"url(#b)\" class=\"svg__icon\" data-gitlens-layout=\"gitlens\">\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"m22.08 63-2.14-2.14.75-.75 2.14 2.13-.75.76ZM18.73 66.08v-5.16h1.06v5.16h-1.06Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M19.26 69.17a1.6 1.6 0 1 0 0-3.2 1.6 1.6 0 0 0 0 3.2ZM23.51 65.27a1.6 1.6 0 1 0 0-3.19 1.6 1.6 0 0 0 0 3.2ZM19.26 61.02a1.6 1.6 0 1 0 0-3.19 1.6 1.6 0 0 0 0 3.2Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M20.5 55.89a7.61 7.61 0 1 0 0 15.22 7.61 7.61 0 0 0 0-15.22ZM12 63.5a8.5 8.5 0 1 1 17 0 8.5 8.5 0 0 1-17 0Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\tfill=\"#fff\"\n\t\t\t\t\t\t\t\t\td=\"M3 52h1v23H3z\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__indicator\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"gitlens\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<g clip-path=\"url(#c)\" class=\"svg__icon\" data-gitlens-layout=\"scm\">\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td=\"M26.76 25.17a2.8 2.8 0 1 0-3.6 2.67 2.24 2.24 0 0 1-2.01 1.25h-2.24c-.83 0-1.63.31-2.24.87v-5.41a2.8 2.8 0 1 0-1.13 0v6.84a2.83 2.83 0 1 0 1.37.07 2.24 2.24 0 0 1 2-1.25h2.24a3.36 3.36 0 0 0 3.17-2.28 2.8 2.8 0 0 0 2.44-2.76ZM14.42 21.8a1.68 1.68 0 1 1 3.37 0 1.68 1.68 0 0 1-3.37 0Zm3.37 12.33a1.68 1.68 0 1 1-3.37 0 1.68 1.68 0 0 1 3.37 0Zm6.16-7.28a1.68 1.68 0 1 1 0-3.37 1.68 1.68 0 0 1 0 3.37Z\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t<path fill=\"#fff\" d=\"M3 16h1v24H3z\" class=\"svg__indicator\" data-gitlens-layout=\"scm\" />\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td=\"M67.67 64a2.67 2.67 0 1 0-5.34 0 2.67 2.67 0 0 0 5.34 0ZM49 64l5 2.89V61.1L49 64Zm16-.5H53.5v1H65v-1Z\"\n\t\t\t\t\t\t\t\t\tfill=\"red\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__arrow\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"gitlens\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td=\"M67.67 28a2.67 2.67 0 1 0-5.34 0 2.67 2.67 0 0 0 5.34 0ZM49 28l5 2.89V25.1L49 28Zm16-.5H53.5v1H65v-1Z\"\n\t\t\t\t\t\t\t\t\tfill=\"#007FD5\"\n\t\t\t\t\t\t\t\t\tclass=\"svg__arrow\"\n\t\t\t\t\t\t\t\t\tdata-gitlens-layout=\"scm\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t\t\t<clipPath id=\"b\">\n\t\t\t\t\t\t\t\t\t\t<path fill=\"#fff\" transform=\"translate(12 55)\" d=\"M0 0h17v17H0z\" />\n\t\t\t\t\t\t\t\t\t</clipPath>\n\t\t\t\t\t\t\t\t\t<clipPath id=\"c\">\n\t\t\t\t\t\t\t\t\t\t<path fill=\"#fff\" transform=\"translate(11 19)\" d=\"M0 0h18v18H0z\" />\n\t\t\t\t\t\t\t\t\t</clipPath>\n\t\t\t\t\t\t\t\t\t<linearGradient\n\t\t\t\t\t\t\t\t\t\tid=\"a\"\n\t\t\t\t\t\t\t\t\t\tx1=\"20.5\"\n\t\t\t\t\t\t\t\t\t\ty1=\"-23.19\"\n\t\t\t\t\t\t\t\t\t\tx2=\"20.5\"\n\t\t\t\t\t\t\t\t\t\ty2=\"91\"\n\t\t\t\t\t\t\t\t\t\tgradientUnits=\"userSpaceOnUse\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<stop stop-color=\"#333\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t\t<stop offset=\"1\" stop-color=\"#333\" stop-opacity=\"0\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t\t<stop offset=\"1\" stop-color=\"#333\" stop-opacity=\"0\" class=\"svg__outline\" />\n\t\t\t\t\t\t\t\t\t</linearGradient>\n\t\t\t\t\t\t\t\t</defs>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t</nav>\n\t\t\t\t\t</div>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"plus\">\n\t\t\t\t\t<span slot=\"heading\">GitLens+ Features</span>\n\t\t\t\t\t<span slot=\"description\">want even more from GitLens?</span>\n\t\t\t\t\t<card-section class=\"gl-plus-banner mb-1\" no-heading>\n\t\t\t\t\t\t<div class=\"centered plus-banner-text\">\n\t\t\t\t\t\t\t<plus-banner id=\"plus-banner\"></plus-banner>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</card-section>\n\t\t\t\t\t<plus-content id=\"plus-content\"></plus-content>\n\t\t\t\t</stepped-section>\n\t\t\t\t<stepped-section id=\"integrations\">\n\t\t\t\t\t<span slot=\"heading\">Integrations</span>\n\t\t\t\t\t<p>GitLens provides issue and pull request auto-linking with many Git hosting services.</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tRich integrations with GitHub & GitLab provide more detailed hover information for auto-linked\n\t\t\t\t\t\tissues and pull requests, pull requests associated with branches and commits, and avatars.\n\t\t\t\t\t</p>\n\t\t\t\t</stepped-section>\n\t\t\t</div>\n\t\t\t<!-- check for gitlens+ -->\n\t\t\t<div id=\"plus-sections\">\n\t\t\t\t<card-section dismissable id=\"focus-view-preview\">\n\t\t\t\t\t<span slot=\"heading\">Focus View \u2728 (preview)</span>\n\t\t\t\t\t<a title=\"Open the Focus view\" href=\"command:gitlens.showFocusPage\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-focus-view-preview.webp\"\n\t\t\t\t\t\t\talt=\"Focus view Screenshot\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a title=\"Open the Focus view\" href=\"command:gitlens.showFocusPage\">Focus View</a>\n\t\t\t\t\t\tprovides you with a comprehensive list of all your most important work across your connected\n\t\t\t\t\t\tGitHub repos.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"commit-graph\">\n\t\t\t\t\t<span slot=\"heading\">Commit Graph \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about the Commit Graph\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.commitGraph%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-commit-graph-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Commit Graph illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about the Commit Graph\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.commitGraph%22\"\n\t\t\t\t\t\t\t>Commit Graph</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\thelps you easily visualize and keep track of all work in progress.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tUse the rich commit search to find exactly what you're looking for. It's powerful filters allow\n\t\t\t\t\t\tyou to search by a specific commit, message, author, a changed file or files, or even a specific\n\t\t\t\t\t\tcode change.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"visual-file-history\">\n\t\t\t\t\t<span slot=\"heading\">Visual File History \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about the Visual File History\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.visualFileHistory%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-visual-file-history-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Visual File History illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\tThe\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about the Visual File History\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.visualFileHistory%22\"\n\t\t\t\t\t\t\t>Visual File History</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\tallows you to quickly see the evolution of a file, including when changes were made, how large\n\t\t\t\t\t\tthey were, and who made them.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tUse it to quickly find when the most impactful changes were made to a file or who best to talk\n\t\t\t\t\t\tto about file changes and more.\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t\t<card-section dismissable id=\"worktrees\">\n\t\t\t\t\t<span slot=\"heading\">Worktrees \u2728</span>\n\t\t\t\t\t<a\n\t\t\t\t\t\ttitle=\"Learn more about Worktrees\"\n\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.worktrees%22\"\n\t\t\t\t\t\t><img\n\t\t\t\t\t\t\tsrc=\"#{webroot}/media/plus-worktrees-illustrated.webp\"\n\t\t\t\t\t\t\talt=\"Worktrees illustration\"\n\t\t\t\t\t\t\tclass=\"plus-section-thumb mb-1\"\n\t\t\t\t\t/></a>\n\t\t\t\t\t<p>\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\ttitle=\"Learn more about Worktrees\"\n\t\t\t\t\t\t\thref=\"command:gitlens.openWalkthrough?%22gitlens.plus%7Cgitlens.plus.worktrees%22\"\n\t\t\t\t\t\t\t>Worktrees</a\n\t\t\t\t\t\t>\n\t\t\t\t\t\thelp you multitask by minimizing the context switching between branches, allowing you to easily\n\t\t\t\t\t\twork on different branches of a repository simultaneously.\n\t\t\t\t\t</p>\n\t\t\t\t\t<p class=\"mb-0\">\n\t\t\t\t\t\tAvoid interrupting your work in progress when needing to review a pull request. Simply create a\n\t\t\t\t\t\tnew worktree and open it in a new VS Code window, all without impacting your other work\n\t\t\t\t\t</p>\n\t\t\t\t</card-section>\n\t\t\t</div>\n\t\t\t<div class=\"button-container\">\n\t\t\t\t<vscode-button appearance=\"secondary\" data-action=\"command:workbench.action.toggleSidebarVisibility\"\n\t\t\t\t\t>Close</vscode-button\n\t\t\t\t>\n\t\t\t\t<a id=\"restore-welcome\" class=\"link-minimal\" href=\"command:gitlens.home.restoreWelcome\"\n\t\t\t\t\t>Restore Home view state</a\n\t\t\t\t>\n\t\t\t</div>\n\t\t</main>\n\n\t\t#{endOfBody}\n\t\t<style nonce=\"#{cspNonce}\">\n\t\t\t@font-face {\n\t\t\t\tfont-family: 'codicon';\n\t\t\t\tfont-display: block;\n\t\t\t\tsrc: url('#{webroot}/codicon.ttf?0e5b0adf625a37fbcd638d31f0fe72aa') format('truetype');\n\t\t\t}\n\t\t</style>\n\t</body>\n</html>\n", "/*global*/\nimport './home.scss';\nimport { provideVSCodeDesignSystem, vsCodeButton } from '@vscode/webview-ui-toolkit';\nimport type { Disposable } from 'vscode';\nimport { getSubscriptionTimeRemaining, SubscriptionState } from '../../../subscription';\nimport type { State } from '../../home/protocol';\nimport {\n\tCompleteStepCommandType,\n\tDidChangeConfigurationType,\n\tDidChangeLayoutType,\n\tDidChangeRepositoriesType,\n\tDidChangeSubscriptionNotificationType,\n\tDismissBannerCommandType,\n\tDismissSectionCommandType,\n\tDismissStatusCommandType,\n} from '../../home/protocol';\nimport type { IpcMessage } from '../../protocol';\nimport { ExecuteCommandType, onIpc } from '../../protocol';\nimport { App } from '../shared/appBase';\nimport { DOM } from '../shared/dom';\nimport type { CardSection } from './components/card-section';\nimport type { HeaderCard } from './components/header-card';\nimport type { PlusBanner } from './components/plus-banner';\nimport type { SteppedSection } from './components/stepped-section';\nimport '../shared/components/code-icon';\nimport '../shared/components/overlays/pop-over';\nimport './components/card-section';\nimport './components/header-card';\nimport './components/plus-banner';\nimport './components/plus-content';\nimport './components/stepped-section';\n\nexport class HomeApp extends App<State> {\n\tprivate $steps!: SteppedSection[];\n\tprivate $cards!: CardSection[];\n\n\tconstructor() {\n\t\tsuper('HomeApp');\n\t}\n\n\tprotected override onInitialize() {\n\t\tprovideVSCodeDesignSystem().register(vsCodeButton());\n\n\t\tthis.$steps = [...document.querySelectorAll<SteppedSection>('stepped-section[id]')];\n\t\tthis.$cards = [...document.querySelectorAll<CardSection>('card-section[id]')];\n\n\t\tthis.state = this.getState() ?? this.state;\n\t\tthis.updateState();\n\t}\n\n\tprotected override onBind(): Disposable[] {\n\t\tconst disposables = super.onBind?.() ?? [];\n\n\t\tdisposables.push(\n\t\t\tDOM.on('[data-action]', 'click', (e, target: HTMLElement) => this.onDataActionClicked(e, target)),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<PlusBanner, string>('plus-banner', 'action', (e, target: HTMLElement) =>\n\t\t\t\tthis.onPlusActionClicked(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<SteppedSection, boolean>('stepped-section', 'complete', (e, target: HTMLElement) =>\n\t\t\t\tthis.onStepComplete(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<CardSection, undefined>('card-section', 'dismiss', (e, target: HTMLElement) =>\n\t\t\t\tthis.onCardDismissed(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on<HeaderCard, undefined>('header-card', 'dismiss-status', (e, target: HTMLElement) =>\n\t\t\t\tthis.onStatusDismissed(e, target),\n\t\t\t),\n\t\t);\n\t\tdisposables.push(\n\t\t\tDOM.on('[data-banner-dismiss]', 'click', (e, target: HTMLElement) => this.onBannerDismissed(e, target)),\n\t\t);\n\n\t\treturn disposables;\n\t}\n\n\tprotected override onMessageReceived(e: MessageEvent) {\n\t\tconst msg = e.data as IpcMessage;\n\n\t\tswitch (msg.method) {\n\t\t\tcase DidChangeSubscriptionNotificationType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeSubscriptionNotificationType, msg, params => {\n\t\t\t\t\tthis.state.subscription = params.subscription;\n\t\t\t\t\tthis.state.completedActions = params.completedActions;\n\t\t\t\t\tthis.state.avatar = params.avatar;\n\t\t\t\t\tthis.state.pinStatus = params.pinStatus;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateState();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeRepositoriesType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeRepositoriesType, msg, params => {\n\t\t\t\t\tthis.state.repositories = { ...params };\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateNoRepo();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeConfigurationType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeConfigurationType, msg, params => {\n\t\t\t\t\tthis.state.plusEnabled = params.plusEnabled;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updatePlusContent();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase DidChangeLayoutType.method:\n\t\t\t\tthis.log(`onMessageReceived(${msg.id}): name=${msg.method}`);\n\n\t\t\t\tonIpc(DidChangeLayoutType, msg, params => {\n\t\t\t\t\tthis.state.layout = params.layout;\n\t\t\t\t\tthis.setState(this.state);\n\t\t\t\t\tthis.updateLayout();\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tsuper.onMessageReceived?.(e);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate onStepComplete(e: CustomEvent<boolean>, target: HTMLElement) {\n\t\tconst id = target.id;\n\t\tconst isComplete = e.detail ?? false;\n\t\tthis.state.completedSteps = toggleArrayItem(this.state.completedSteps, id, isComplete);\n\t\tthis.sendCommand(CompleteStepCommandType, { id: id, completed: isComplete });\n\t\tthis.updateState();\n\t}\n\n\tprivate onCardDismissed(e: CustomEvent<undefined>, target: HTMLElement) {\n\t\tconst id = target.id;\n\t\tthis.state.dismissedSections = toggleArrayItem(this.state.dismissedSections, id);\n\t\tthis.sendCommand(DismissSectionCommandType, { id: id });\n\t\tthis.updateState();\n\t}\n\n\tprivate onStatusDismissed(_e: CustomEvent<undefined>, _target: HTMLElement) {\n\t\tthis.state.pinStatus = false;\n\t\tthis.sendCommand(DismissStatusCommandType, undefined);\n\t\tthis.updateHeader();\n\t}\n\n\tprivate onBannerDismissed(_e: MouseEvent, target: HTMLElement) {\n\t\tconst key = target.getAttribute('data-banner-dismiss');\n\t\tif (key == null || this.state.dismissedBanners?.includes(key)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.state.dismissedBanners = this.state.dismissedBanners ?? [];\n\t\tthis.state.dismissedBanners.push(key);\n\t\tthis.sendCommand(DismissBannerCommandType, { id: key });\n\t\tthis.updateBanners();\n\t}\n\n\tprivate onDataActionClicked(_e: MouseEvent, target: HTMLElement) {\n\t\tconst action = target.dataset.action;\n\t\tthis.onActionClickedCore(action);\n\t}\n\n\tprivate onPlusActionClicked(e: CustomEvent<string>, _target: HTMLElement) {\n\t\tthis.onActionClickedCore(e.detail);\n\t}\n\n\tprivate onActionClickedCore(action?: string) {\n\t\tif (action?.startsWith('command:')) {\n\t\t\tthis.sendCommand(ExecuteCommandType, { command: action.slice(8) });\n\t\t}\n\t}\n\n\tprivate getDaysRemaining() {\n\t\tif (\n\t\t\t![SubscriptionState.FreeInPreviewTrial, SubscriptionState.FreePlusInTrial].includes(\n\t\t\t\tthis.state.subscription.state,\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn getSubscriptionTimeRemaining(this.state.subscription, 'days') ?? 0;\n\t}\n\n\tprivate forceShowPlus() {\n\t\treturn [\n\t\t\tSubscriptionState.FreePreviewTrialExpired,\n\t\t\tSubscriptionState.FreePlusTrialExpired,\n\t\t\tSubscriptionState.VerificationRequired,\n\t\t].includes(this.state.subscription.state);\n\t}\n\n\tprivate updateHeader(days = this.getDaysRemaining(), forceShowPlus = this.forceShowPlus()) {\n\t\tconst { subscription, completedSteps, avatar, pinStatus } = this.state;\n\n\t\tconst $headerContent = document.getElementById('header-card') as HeaderCard;\n\t\tif ($headerContent) {\n\t\t\tif (avatar) {\n\t\t\t\t$headerContent.setAttribute('image', avatar);\n\t\t\t}\n\t\t\t$headerContent.setAttribute('name', subscription.account?.name ?? '');\n\n\t\t\tconst steps = this.$steps?.length ?? 0;\n\t\t\tlet completed = completedSteps?.length ?? 0;\n\t\t\tif (steps > 0 && completed > 0) {\n\t\t\t\tconst stepIds = this.$steps.map(el => el.id);\n\t\t\t\tconst availableCompleted = completedSteps!.filter(name => stepIds.includes(name));\n\t\t\t\tcompleted = availableCompleted.length;\n\n\t\t\t\tif (forceShowPlus && availableCompleted.includes('plus')) {\n\t\t\t\t\tcompleted -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$headerContent.setAttribute('steps', steps.toString());\n\t\t\t$headerContent.setAttribute('completed', completed.toString());\n\t\t\t$headerContent.setAttribute('state', subscription.state.toString());\n\t\t\t$headerContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t\t$headerContent.setAttribute('days', days.toString());\n\t\t\t$headerContent.pinStatus = pinStatus;\n\t\t}\n\t}\n\n\tprivate updateBanners() {\n\t\tconst $banners = [...document.querySelectorAll('[data-banner]')];\n\t\tif (!$banners.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { dismissedBanners } = this.state;\n\t\t$banners.forEach($el => {\n\t\t\tconst key = $el.getAttribute('data-banner');\n\t\t\tif (key !== null && dismissedBanners?.includes(key)) {\n\t\t\t\t$el.setAttribute('hidden', 'true');\n\t\t\t} else {\n\t\t\t\t$el.removeAttribute('hidden');\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateNoRepo() {\n\t\tconst {\n\t\t\trepositories: { openCount, hasUnsafe, trusted },\n\t\t} = this.state;\n\n\t\tif (!trusted) {\n\t\t\tsetElementVisibility('untrusted-alert', true);\n\t\t\tsetElementVisibility('no-repo', false);\n\t\t\tsetElementVisibility('no-repo-alert', false);\n\t\t\tsetElementVisibility('unsafe-repo-alert', false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tsetElementVisibility('untrusted-alert', false);\n\n\t\tconst noRepos = openCount === 0;\n\n\t\tsetElementVisibility('no-repo', noRepos);\n\t\tsetElementVisibility('no-repo-alert', noRepos && !hasUnsafe);\n\t\tsetElementVisibility('unsafe-repo-alert', hasUnsafe);\n\t}\n\n\tprivate updateLayout() {\n\t\tconst { layout } = this.state;\n\n\t\tconst $els = [...document.querySelectorAll('[data-gitlens-layout]')];\n\t\t$els.forEach(el => {\n\t\t\tconst attr = el.getAttribute('data-gitlens-layout');\n\t\t\tel.classList.toggle('is-active', attr === layout);\n\t\t});\n\t}\n\n\tprivate updatePlusContent(days = this.getDaysRemaining()) {\n\t\tconst { subscription, visibility, plusEnabled } = this.state;\n\n\t\tlet $plusContent = document.getElementById('plus-banner');\n\t\tif ($plusContent) {\n\t\t\t$plusContent.setAttribute('days', days.toString());\n\t\t\t$plusContent.setAttribute('state', subscription.state.toString());\n\t\t\t$plusContent.setAttribute('visibility', visibility);\n\t\t\t$plusContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t\t$plusContent.setAttribute('plus', plusEnabled.toString());\n\t\t\t($plusContent as PlusBanner).hasRepositories = this.state.repositories.count > 0;\n\t\t}\n\n\t\t$plusContent = document.getElementById('plus-content');\n\t\tif ($plusContent) {\n\t\t\t$plusContent.setAttribute('days', days.toString());\n\t\t\t$plusContent.setAttribute('state', subscription.state.toString());\n\t\t\t$plusContent.setAttribute('visibility', visibility);\n\t\t\t$plusContent.setAttribute('plan', subscription.plan.effective.name);\n\t\t}\n\t}\n\n\tprivate updateSteps(forceShowPlus = this.forceShowPlus()) {\n\t\tif (\n\t\t\tthis.$steps == null ||\n\t\t\tthis.$steps.length === 0 ||\n\t\t\tthis.state.completedSteps == null ||\n\t\t\tthis.state.completedSteps.length === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$steps.forEach(el => {\n\t\t\tel.setAttribute(\n\t\t\t\t'completed',\n\t\t\t\t(el.id === 'plus' && forceShowPlus) || this.state.completedSteps?.includes(el.id) !== true\n\t\t\t\t\t? 'false'\n\t\t\t\t\t: 'true',\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate updateSections() {\n\t\tif (\n\t\t\tthis.$cards == null ||\n\t\t\tthis.$cards.length === 0 ||\n\t\t\tthis.state.dismissedSections == null ||\n\t\t\tthis.state.dismissedSections.length === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.dismissedSections.forEach(id => {\n\t\t\tconst found = this.$cards.findIndex(el => el.id === id);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.$cards[found].remove();\n\t\t\t\tthis.$cards.splice(found, 1);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateState() {\n\t\tconst { completedSteps, dismissedSections } = this.state;\n\n\t\tthis.updateNoRepo();\n\t\tthis.updateLayout();\n\n\t\tconst showRestoreWelcome = completedSteps?.length || dismissedSections?.length;\n\t\tdocument.getElementById('restore-welcome')?.classList.toggle('hide', !showRestoreWelcome);\n\n\t\tconst forceShowPlus = this.forceShowPlus();\n\t\tconst days = this.getDaysRemaining();\n\t\tthis.updateHeader(days, forceShowPlus);\n\t\tthis.updatePlusContent(days);\n\n\t\tthis.updateSteps(forceShowPlus);\n\n\t\tthis.updateSections();\n\t\tthis.updateBanners();\n\t}\n}\n\nfunction setElementVisibility(elementOrId: string | HTMLElement | null | undefined, visible: boolean) {\n\tlet el;\n\tif (typeof elementOrId === 'string') {\n\t\tel = document.getElementById(elementOrId);\n\t} else {\n\t\tel = elementOrId;\n\t}\n\tif (el == null) return;\n\n\tif (visible) {\n\t\tel.setAttribute('aria-hidden', 'false');\n\t\tel.removeAttribute('hidden');\n\t} else {\n\t\tel.setAttribute('aria-hidden', 'true');\n\t\tel?.setAttribute('hidden', 'true');\n\t}\n}\n\nfunction toggleArrayItem(list: string[] = [], item: string, add = true) {\n\tconst hasStep = list.includes(item);\n\tif (!hasStep && add) {\n\t\tlist.push(item);\n\t} else if (hasStep && !add) {\n\t\tlist.splice(list.indexOf(item), 1);\n\t}\n\n\treturn list;\n}\n\nnew HomeApp();\n", "import type { ConfigurationChangeEvent } from 'vscode';\nimport { Disposable, window, workspace } from 'vscode';\nimport { getAvatarUriFromGravatarEmail } from '../../avatars';\nimport { ViewsLayout } from '../../commands/setViewsLayout';\nimport type { Container } from '../../container';\nimport type { RepositoriesVisibility } from '../../git/gitProviderService';\nimport type { SubscriptionChangeEvent } from '../../plus/subscription/subscriptionService';\nimport type { Subscription } from '../../subscription';\nimport { executeCoreCommand, registerCommand } from '../../system/command';\nimport { configuration } from '../../system/configuration';\nimport type { Deferrable } from '../../system/function';\nimport { debounce } from '../../system/function';\nimport { getSettledValue } from '../../system/promise';\nimport type { StorageChangeEvent } from '../../system/storage';\nimport type { IpcMessage } from '../protocol';\nimport { onIpc } from '../protocol';\nimport type { WebviewController, WebviewProvider } from '../webviewController';\nimport type {\n\tCompleteStepParams,\n\tDidChangeRepositoriesParams,\n\tDismissBannerParams,\n\tDismissSectionParams,\n\tState,\n} from './protocol';\nimport {\n\tCompletedActions,\n\tCompleteStepCommandType,\n\tDidChangeConfigurationType,\n\tDidChangeLayoutType,\n\tDidChangeRepositoriesType,\n\tDidChangeSubscriptionNotificationType,\n\tDismissBannerCommandType,\n\tDismissSectionCommandType,\n\tDismissStatusCommandType,\n} from './protocol';\n\nconst emptyDisposable = Object.freeze({\n\tdispose: () => {\n\t\t/* noop */\n\t},\n});\n\nexport class HomeWebviewProvider implements WebviewProvider<State> {\n\tprivate readonly _disposable: Disposable;\n\n\tconstructor(private readonly container: Container, private readonly host: WebviewController<State>) {\n\t\tthis._disposable = Disposable.from(\n\t\t\tthis.container.subscription.onDidChange(this.onSubscriptionChanged, this),\n\t\t\tthis.container.git.onDidChangeRepositories(this.onRepositoriesChanged, this),\n\t\t\tconfiguration.onDidChange(this.onConfigurationChanged, this),\n\t\t\tthis.container.storage.onDidChange(this.onStorageChanged, this),\n\t\t\t!workspace.isTrusted\n\t\t\t\t? workspace.onDidGrantWorkspaceTrust(this.notifyDidChangeRepositories, this)\n\t\t\t\t: emptyDisposable,\n\t\t);\n\t}\n\n\tdispose() {\n\t\tthis._disposable.dispose();\n\t}\n\n\tprivate onConfigurationChanged(e: ConfigurationChangeEvent) {\n\t\tif (!configuration.changed(e, 'plusFeatures.enabled')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notifyDidChangeConfiguration();\n\t}\n\n\tprivate onRepositoriesChanged() {\n\t\tthis.notifyDidChangeRepositories();\n\t}\n\n\tprivate onStorageChanged(e: StorageChangeEvent) {\n\t\tif (e.key !== 'views:layout') return;\n\n\t\tthis.notifyDidChangeLayout();\n\t}\n\n\tprivate async onSubscriptionChanged(e: SubscriptionChangeEvent) {\n\t\tawait this.container.storage.store('home:status:pinned', true);\n\t\tvoid this.notifyDidChangeData(e.current);\n\t}\n\n\tonVisibilityChanged(visible: boolean): void {\n\t\tif (!visible) {\n\t\t\tthis._validateSubscriptionDebounced?.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tqueueMicrotask(() => void this.validateSubscription());\n\t}\n\n\tonWindowFocusChanged(focused: boolean): void {\n\t\tif (!focused || !this.host.visible) {\n\t\t\tthis._validateSubscriptionDebounced?.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tqueueMicrotask(() => void this.validateSubscription());\n\t}\n\n\tregisterCommands(): Disposable[] {\n\t\treturn [\n\t\t\tregisterCommand(`${this.host.id}.refresh`, () => this.host.refresh(true), this),\n\t\t\tregisterCommand('gitlens.home.toggleWelcome', async () => {\n\t\t\t\tconst welcomeVisible = !this.welcomeVisible;\n\t\t\t\tawait this.container.storage.store('views:welcome:visible', welcomeVisible);\n\t\t\t\tif (welcomeVisible) {\n\t\t\t\t\tawait Promise.allSettled([\n\t\t\t\t\t\tthis.container.storage.store('home:actions:completed', []),\n\t\t\t\t\t\tthis.container.storage.store('home:steps:completed', []),\n\t\t\t\t\t\tthis.container.storage.store('home:sections:dismissed', []),\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tvoid this.host.refresh();\n\t\t\t}),\n\t\t\tregisterCommand('gitlens.home.restoreWelcome', async () => {\n\t\t\t\tawait Promise.allSettled([\n\t\t\t\t\tthis.container.storage.store('home:steps:completed', []),\n\t\t\t\t\tthis.container.storage.store('home:sections:dismissed', []),\n\t\t\t\t]);\n\n\t\t\t\tvoid this.host.refresh();\n\t\t\t}),\n\n\t\t\tregisterCommand('gitlens.home.showSCM', async () => {\n\t\t\t\tconst completedActions = this.container.storage.get('home:actions:completed', []);\n\t\t\t\tif (!completedActions.includes(CompletedActions.OpenedSCM)) {\n\t\t\t\t\tcompletedActions.push(CompletedActions.OpenedSCM);\n\t\t\t\t\tawait this.container.storage.store('home:actions:completed', completedActions);\n\n\t\t\t\t\tvoid this.notifyDidChangeData();\n\t\t\t\t}\n\n\t\t\t\tawait executeCoreCommand('workbench.view.scm');\n\t\t\t}),\n\t\t];\n\t}\n\n\tonMessageReceived(e: IpcMessage) {\n\t\tswitch (e.method) {\n\t\t\tcase CompleteStepCommandType.method:\n\t\t\t\tonIpc(CompleteStepCommandType, e, params => this.completeStep(params));\n\t\t\t\tbreak;\n\t\t\tcase DismissSectionCommandType.method:\n\t\t\t\tonIpc(DismissSectionCommandType, e, params => this.dismissSection(params));\n\t\t\t\tbreak;\n\t\t\tcase DismissStatusCommandType.method:\n\t\t\t\tonIpc(DismissStatusCommandType, e, _params => this.dismissPinStatus());\n\t\t\t\tbreak;\n\t\t\tcase DismissBannerCommandType.method:\n\t\t\t\tonIpc(DismissBannerCommandType, e, params => this.dismissBanner(params));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate async completeStep({ id, completed = false }: CompleteStepParams) {\n\t\tconst steps = this.container.storage.get('home:steps:completed', []);\n\n\t\tconst hasStep = steps.includes(id);\n\t\tif (!hasStep && completed) {\n\t\t\tsteps.push(id);\n\t\t} else if (hasStep && !completed) {\n\t\t\tsteps.splice(steps.indexOf(id), 1);\n\t\t}\n\n\t\tawait this.container.storage.store('home:steps:completed', steps);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissSection(params: DismissSectionParams) {\n\t\tconst sections = this.container.storage.get('home:sections:dismissed', []);\n\t\tif (sections.includes(params.id)) return;\n\n\t\tsections.push(params.id);\n\n\t\tawait this.container.storage.store('home:sections:dismissed', sections);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissBanner(params: DismissBannerParams) {\n\t\tconst banners = this.container.storage.get('home:banners:dismissed', []);\n\n\t\tif (!banners.includes(params.id)) {\n\t\t\tbanners.push(params.id);\n\t\t}\n\n\t\tawait this.container.storage.store('home:banners:dismissed', banners);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tprivate async dismissPinStatus() {\n\t\tawait this.container.storage.store('home:status:pinned', false);\n\t\tvoid this.notifyDidChangeData();\n\t}\n\n\tincludeBootstrap(): Promise<State> {\n\t\treturn this.getState();\n\t}\n\n\tprivate get welcomeVisible(): boolean {\n\t\treturn this.container.storage.get('views:welcome:visible', true);\n\t}\n\n\tprivate async getRepoVisibility(): Promise<RepositoriesVisibility> {\n\t\tconst visibility = await this.container.git.visibility();\n\t\treturn visibility;\n\t}\n\n\tprivate async getSubscription(subscription?: Subscription) {\n\t\t// Make sure to make a copy of the array otherwise it will be live to the storage value\n\t\tconst completedActions = [...this.container.storage.get('home:actions:completed', [])];\n\t\tif (!this.welcomeVisible) {\n\t\t\tcompletedActions.push(CompletedActions.DismissedWelcome);\n\t\t}\n\n\t\tconst sub = subscription ?? (await this.container.subscription.getSubscription(true));\n\n\t\tlet avatar;\n\t\tif (sub.account?.email) {\n\t\t\tavatar = getAvatarUriFromGravatarEmail(sub.account.email, 34).toString();\n\t\t} else {\n\t\t\tavatar = `${this.host.getWebRoot() ?? ''}/media/gitlens-logo.webp`;\n\t\t}\n\n\t\treturn {\n\t\t\tsubscription: sub,\n\t\t\tcompletedActions: completedActions,\n\t\t\tavatar: avatar,\n\t\t};\n\t}\n\n\tprivate getPinStatus() {\n\t\treturn this.container.storage.get('home:status:pinned') ?? true;\n\t}\n\n\tprivate async getState(subscription?: Subscription): Promise<State> {\n\t\tconst [visibilityResult, subscriptionResult] = await Promise.allSettled([\n\t\t\tthis.getRepoVisibility(),\n\t\t\tthis.getSubscription(subscription),\n\t\t]);\n\n\t\tconst sub = getSettledValue(subscriptionResult)!;\n\t\tconst steps = this.container.storage.get('home:steps:completed', []);\n\t\tconst sections = this.container.storage.get('home:sections:dismissed', []);\n\t\tconst dismissedBanners = this.container.storage.get('home:banners:dismissed', []);\n\n\t\treturn {\n\t\t\ttimestamp: Date.now(),\n\t\t\trepositories: this.getRepositoriesState(),\n\t\t\twebroot: this.host.getWebRoot(),\n\t\t\tsubscription: sub.subscription,\n\t\t\tcompletedActions: sub.completedActions,\n\t\t\tplusEnabled: this.getPlusEnabled(),\n\t\t\tvisibility: getSettledValue(visibilityResult)!,\n\t\t\tcompletedSteps: steps,\n\t\t\tdismissedSections: sections,\n\t\t\tavatar: sub.avatar,\n\t\t\tlayout: this.getLayout(),\n\t\t\tpinStatus: this.getPinStatus(),\n\t\t\tdismissedBanners: dismissedBanners,\n\t\t};\n\t}\n\n\tprivate notifyDidChangeData(subscription?: Subscription) {\n\t\tif (!this.host.ready) return false;\n\n\t\treturn window.withProgress({ location: { viewId: this.host.id } }, async () => {\n\t\t\tconst sub = await this.getSubscription(subscription);\n\t\t\treturn this.host.notify(DidChangeSubscriptionNotificationType, {\n\t\t\t\t...sub,\n\t\t\t\tpinStatus: this.getPinStatus(),\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getRepositoriesState(): DidChangeRepositoriesParams {\n\t\treturn {\n\t\t\tcount: this.container.git.repositoryCount,\n\t\t\topenCount: this.container.git.openRepositoryCount,\n\t\t\thasUnsafe: this.container.git.hasUnsafeRepositories(),\n\t\t\ttrusted: workspace.isTrusted,\n\t\t};\n\t}\n\n\tprivate notifyDidChangeRepositories() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeRepositoriesType, this.getRepositoriesState());\n\t}\n\n\tprivate getPlusEnabled() {\n\t\treturn configuration.get('plusFeatures.enabled');\n\t}\n\n\tprivate notifyDidChangeConfiguration() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeConfigurationType, {\n\t\t\tplusEnabled: this.getPlusEnabled(),\n\t\t});\n\t}\n\n\tprivate getLayout() {\n\t\tconst layout = this.container.storage.get('views:layout');\n\t\treturn layout != null ? (layout as ViewsLayout) : ViewsLayout.SourceControl;\n\t}\n\n\tprivate notifyDidChangeLayout() {\n\t\tif (!this.host.ready) return;\n\n\t\tvoid this.host.notify(DidChangeLayoutType, { layout: this.getLayout() });\n\t}\n\n\tprivate _validateSubscriptionDebounced: Deferrable<HomeWebviewProvider['validateSubscription']> | undefined =\n\t\tundefined;\n\n\tprivate async validateSubscription(): Promise<void> {\n\t\tif (this._validateSubscriptionDebounced == null) {\n\t\t\tthis._validateSubscriptionDebounced = debounce(this.validateSubscriptionCore, 1000);\n\t\t}\n\n\t\tawait this._validateSubscriptionDebounced();\n\t}\n\n\tprivate _validating: Promise<void> | undefined;\n\tprivate async validateSubscriptionCore() {\n\t\tif (this._validating == null) {\n\t\t\tthis._validating = this.container.subscription.validate();\n\t\t\ttry {\n\t\t\t\tawait this._validating;\n\t\t\t} finally {\n\t\t\t\tthis._validating = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n", "import type { ViewsLayout } from '../../commands/setViewsLayout';\nimport type { RepositoriesVisibility } from '../../git/gitProviderService';\nimport type { Subscription } from '../../subscription';\nimport { IpcCommandType, IpcNotificationType } from '../protocol';\n\nexport const enum CompletedActions {\n\tDismissedWelcome = 'dismissed:welcome',\n\tOpenedSCM = 'opened:scm',\n}\n\nexport interface State {\n\ttimestamp: number;\n\n\trepositories: DidChangeRepositoriesParams;\n\twebroot?: string;\n\tsubscription: Subscription;\n\tcompletedActions: CompletedActions[];\n\tcompletedSteps?: string[];\n\tdismissedBanners?: string[];\n\tdismissedSections?: string[];\n\tplusEnabled: boolean;\n\tvisibility: RepositoriesVisibility;\n\tavatar?: string;\n\tlayout: ViewsLayout;\n\tpinStatus: boolean;\n}\n\nexport interface CompleteStepParams {\n\tid: string;\n\tcompleted: boolean;\n}\nexport const CompleteStepCommandType = new IpcCommandType<CompleteStepParams>('home/step/complete');\n\nexport interface DismissSectionParams {\n\tid: string;\n}\nexport const DismissSectionCommandType = new IpcCommandType<DismissSectionParams>('home/section/dismiss');\n\nexport const DismissStatusCommandType = new IpcCommandType<undefined>('home/status/dismiss');\n\nexport interface DismissBannerParams {\n\tid: string;\n}\nexport const DismissBannerCommandType = new IpcCommandType<DismissBannerParams>('home/banner/dismiss');\n\nexport interface DidChangeSubscriptionParams {\n\tsubscription: Subscription;\n\tcompletedActions: CompletedActions[];\n\tavatar?: string;\n\tpinStatus: boolean;\n}\nexport const DidChangeSubscriptionNotificationType = new IpcNotificationType<DidChangeSubscriptionParams>(\n\t'subscription/didChange',\n);\n\nexport interface DidChangeRepositoriesParams {\n\tcount: number;\n\topenCount: number;\n\thasUnsafe: boolean;\n\ttrusted: boolean;\n}\nexport const DidChangeRepositoriesType = new IpcNotificationType<DidChangeRepositoriesParams>('repositories/didChange');\n\nexport interface DidChangeConfigurationParams {\n\tplusEnabled: boolean;\n}\nexport const DidChangeConfigurationType = new IpcNotificationType<DidChangeConfigurationParams>(\n\t'configuration/didChange',\n);\n\nexport interface DidChangeLayoutParams {\n\tlayout: ViewsLayout;\n}\nexport const DidChangeLayoutType = new IpcNotificationType<DidChangeLayoutParams>('layout/didChange');\n"], "filenames": ["src/env/node/git/git.ts", "src/env/node/git/localGitProvider.ts", "src/git/errors.ts", "src/git/gitProviderService.ts", "src/webviews/apps/home/home.html", "src/webviews/apps/home/home.ts", "src/webviews/home/homeWebview.ts", "src/webviews/home/protocol.ts"], "buggy_code_start_loc": [12, 1091, 83, 84, 95, 250, 2, 59], "buggy_code_end_loc": [1647, 1092, 83, 218, 95, 373, 262, 59], "fixing_code_start_loc": [12, 1091, 84, 85, 96, 250, 2, 60], "fixing_code_end_loc": [1654, 1092, 93, 232, 107, 382, 285, 61], "type": "NVD-CWE-noinfo", "message": "An issue in GitKraken GitLens before v.14.0.0 allows an attacker to execute arbitrary code via a crafted file to the Visual Studio Codes workspace trust component.", "other": {"cve": {"id": "CVE-2023-46944", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-28T22:15:06.937", "lastModified": "2023-12-04T19:39:27.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in GitKraken GitLens before v.14.0.0 allows an attacker to execute arbitrary code via a crafted file to the Visual Studio Codes workspace trust component."}, {"lang": "es", "value": "Un problema en GitKraken GitLens anterior a v.14.0.0 permite a un atacante ejecutar c\u00f3digo arbitrario a trav\u00e9s de un archivo manipulado en el componente de confianza del espacio de trabajo de Visual Studio Codes."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitkraken:gitlens:*:*:*:*:*:visual_studio_code:*:*", "versionEndExcluding": "14.0.0", "matchCriteriaId": "19941443-90FE-46A6-B057-14792318CFAA"}]}]}], "references": [{"url": "https://github.com/gitkraken/vscode-gitlens/commit/ee2a0c42a92d33059a39fd15fbbd5dd3d5ab6440", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.sonarsource.com/blog/vscode-security-markdown-vulnerabilities-in-extensions/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gitkraken/vscode-gitlens/commit/ee2a0c42a92d33059a39fd15fbbd5dd3d5ab6440"}}