{"buggy_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n#include \"regexp.h\"\n\nvoid js_newregexp(js_State *J, const char *pattern, int flags)\n{\n\tconst char *error;\n\tjs_Object *obj;\n\tReprog *prog;\n\tint opts;\n\n\tobj = jsV_newobject(J, JS_CREGEXP, J->RegExp_prototype);\n\n\topts = 0;\n\tif (flags & JS_REGEXP_I) opts |= REG_ICASE;\n\tif (flags & JS_REGEXP_M) opts |= REG_NEWLINE;\n\n\tprog = js_regcompx(J->alloc, J->actx, pattern, opts, &error);\n\tif (!prog)\n\t\tjs_syntaxerror(J, \"regular expression: %s\", error);\n\n\tobj->u.r.prog = prog;\n\tobj->u.r.source = js_strdup(J, pattern);\n\tobj->u.r.flags = flags;\n\tobj->u.r.last = 0;\n\tjs_pushobject(J, obj);\n}\n\nvoid js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushnull(J);\n}\n\nstatic void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushboolean(J, 0);\n}\n\nstatic void jsB_new_RegExp(js_State *J)\n{\n\tjs_Regexp *old;\n\tconst char *pattern;\n\tint flags;\n\n\tif (js_isregexp(J, 1)) {\n\t\tif (js_isdefined(J, 2))\n\t\t\tjs_typeerror(J, \"cannot supply flags when creating one RegExp from another\");\n\t\told = js_toregexp(J, 1);\n\t\tpattern = old->source;\n\t\tflags = old->flags;\n\t} else if (js_isundefined(J, 1)) {\n\t\tpattern = \"(?:)\";\n\t\tflags = 0;\n\t} else {\n\t\tpattern = js_tostring(J, 1);\n\t\tflags = 0;\n\t}\n\n\tif (strlen(pattern) == 0)\n\t\tpattern = \"(?:)\";\n\n\tif (js_isdefined(J, 2)) {\n\t\tconst char *s = js_tostring(J, 2);\n\t\tint g = 0, i = 0, m = 0;\n\t\twhile (*s) {\n\t\t\tif (*s == 'g') ++g;\n\t\t\telse if (*s == 'i') ++i;\n\t\t\telse if (*s == 'm') ++m;\n\t\t\telse js_syntaxerror(J, \"invalid regular expression flag: '%c'\", *s);\n\t\t\t++s;\n\t\t}\n\t\tif (g > 1) js_syntaxerror(J, \"invalid regular expression flag: 'g'\");\n\t\tif (i > 1) js_syntaxerror(J, \"invalid regular expression flag: 'i'\");\n\t\tif (m > 1) js_syntaxerror(J, \"invalid regular expression flag: 'm'\");\n\t\tif (g) flags |= JS_REGEXP_G;\n\t\tif (i) flags |= JS_REGEXP_I;\n\t\tif (m) flags |= JS_REGEXP_M;\n\t}\n\n\tjs_newregexp(J, pattern, flags);\n}\n\nstatic void jsB_RegExp(js_State *J)\n{\n\tif (js_isregexp(J, 1))\n\t\treturn;\n\tjsB_new_RegExp(J);\n}\n\nstatic void Rp_toString(js_State *J)\n{\n\tjs_Regexp *re;\n\tchar *out;\n\n\tre = js_toregexp(J, 0);\n\n\tout = js_malloc(J, strlen(re->source) + 6); /* extra space for //gim */\n\tstrcpy(out, \"/\");\n\tstrcat(out, re->source);\n\tstrcat(out, \"/\");\n\tif (re->flags & JS_REGEXP_G) strcat(out, \"g\");\n\tif (re->flags & JS_REGEXP_I) strcat(out, \"i\");\n\tif (re->flags & JS_REGEXP_M) strcat(out, \"m\");\n\n\tif (js_try(J)) {\n\t\tjs_free(J, out);\n\t\tjs_throw(J);\n\t}\n\tjs_pop(J, 0);\n\tjs_pushstring(J, out);\n\tjs_endtry(J);\n\tjs_free(J, out);\n}\n\nstatic void Rp_exec(js_State *J)\n{\n\tjs_RegExp_prototype_exec(J, js_toregexp(J, 0), js_tostring(J, 1));\n}\n\nvoid jsB_initregexp(js_State *J)\n{\n\tjs_pushobject(J, J->RegExp_prototype);\n\t{\n\t\tjsB_propf(J, \"RegExp.prototype.toString\", Rp_toString, 0);\n\t\tjsB_propf(J, \"RegExp.prototype.test\", Rp_test, 0);\n\t\tjsB_propf(J, \"RegExp.prototype.exec\", Rp_exec, 0);\n\t}\n\tjs_newcconstructor(J, jsB_RegExp, jsB_new_RegExp, \"RegExp\", 1);\n\tjs_defglobal(J, \"RegExp\", JS_DONTENUM);\n}\n", "#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n#include \"utf.h\"\n#include \"regexp.h\"\n\nstatic const char *checkstring(js_State *J, int idx)\n{\n\tif (!js_iscoercible(J, idx))\n\t\tjs_typeerror(J, \"string function called on null or undefined\");\n\treturn js_tostring(J, idx);\n}\n\nint js_runeat(js_State *J, const char *s, int i)\n{\n\tRune rune = 0;\n\twhile (i-- >= 0) {\n\t\trune = *(unsigned char*)s;\n\t\tif (rune < Runeself) {\n\t\t\tif (rune == 0)\n\t\t\t\treturn 0;\n\t\t\t++s;\n\t\t} else\n\t\t\ts += chartorune(&rune, s);\n\t}\n\treturn rune;\n}\n\nconst char *js_utfidxtoptr(const char *s, int i)\n{\n\tRune rune;\n\twhile (i-- > 0) {\n\t\trune = *(unsigned char*)s;\n\t\tif (rune < Runeself) {\n\t\t\tif (rune == 0)\n\t\t\t\treturn NULL;\n\t\t\t++s;\n\t\t} else\n\t\t\ts += chartorune(&rune, s);\n\t}\n\treturn s;\n}\n\nint js_utfptrtoidx(const char *s, const char *p)\n{\n\tRune rune;\n\tint i = 0;\n\twhile (s < p) {\n\t\tif (*(unsigned char *)s < Runeself)\n\t\t\t++s;\n\t\telse\n\t\t\ts += chartorune(&rune, s);\n\t\t++i;\n\t}\n\treturn i;\n}\n\nstatic void jsB_new_String(js_State *J)\n{\n\tjs_newstring(J, js_gettop(J) > 1 ? js_tostring(J, 1) : \"\");\n}\n\nstatic void jsB_String(js_State *J)\n{\n\tjs_pushstring(J, js_gettop(J) > 1 ? js_tostring(J, 1) : \"\");\n}\n\nstatic void Sp_toString(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CSTRING) js_typeerror(J, \"not a string\");\n\tjs_pushliteral(J, self->u.s.string);\n}\n\nstatic void Sp_valueOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CSTRING) js_typeerror(J, \"not a string\");\n\tjs_pushliteral(J, self->u.s.string);\n}\n\nstatic void Sp_charAt(js_State *J)\n{\n\tchar buf[UTFmax + 1];\n\tconst char *s = checkstring(J, 0);\n\tint pos = js_tointeger(J, 1);\n\tRune rune = js_runeat(J, s, pos);\n\tif (rune > 0) {\n\t\tbuf[runetochar(buf, &rune)] = 0;\n\t\tjs_pushstring(J, buf);\n\t} else {\n\t\tjs_pushliteral(J, \"\");\n\t}\n}\n\nstatic void Sp_charCodeAt(js_State *J)\n{\n\tconst char *s = checkstring(J, 0);\n\tint pos = js_tointeger(J, 1);\n\tRune rune = js_runeat(J, s, pos);\n\tif (rune > 0)\n\t\tjs_pushnumber(J, rune);\n\telse\n\t\tjs_pushnumber(J, NAN);\n}\n\nstatic void Sp_concat(js_State *J)\n{\n\tint i, top = js_gettop(J);\n\tint n;\n\tchar * volatile out;\n\tconst char *s;\n\n\tif (top == 1)\n\t\treturn;\n\n\ts = checkstring(J, 0);\n\tn = strlen(s);\n\tout = js_malloc(J, n + 1);\n\tstrcpy(out, s);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, out);\n\t\tjs_throw(J);\n\t}\n\n\tfor (i = 1; i < top; ++i) {\n\t\ts = js_tostring(J, i);\n\t\tn += strlen(s);\n\t\tout = js_realloc(J, out, n + 1);\n\t\tstrcat(out, s);\n\t}\n\n\tjs_pushstring(J, out);\n\tjs_endtry(J);\n\tjs_free(J, out);\n}\n\nstatic void Sp_indexOf(js_State *J)\n{\n\tconst char *haystack = checkstring(J, 0);\n\tconst char *needle = js_tostring(J, 1);\n\tint pos = js_tointeger(J, 2);\n\tint len = strlen(needle);\n\tint k = 0;\n\tRune rune;\n\twhile (*haystack) {\n\t\tif (k >= pos && !strncmp(haystack, needle, len)) {\n\t\t\tjs_pushnumber(J, k);\n\t\t\treturn;\n\t\t}\n\t\thaystack += chartorune(&rune, haystack);\n\t\t++k;\n\t}\n\tjs_pushnumber(J, -1);\n}\n\nstatic void Sp_lastIndexOf(js_State *J)\n{\n\tconst char *haystack = checkstring(J, 0);\n\tconst char *needle = js_tostring(J, 1);\n\tint pos = js_isdefined(J, 2) ? js_tointeger(J, 2) : (int)strlen(haystack);\n\tint len = strlen(needle);\n\tint k = 0, last = -1;\n\tRune rune;\n\twhile (*haystack && k <= pos) {\n\t\tif (!strncmp(haystack, needle, len))\n\t\t\tlast = k;\n\t\thaystack += chartorune(&rune, haystack);\n\t\t++k;\n\t}\n\tjs_pushnumber(J, last);\n}\n\nstatic void Sp_localeCompare(js_State *J)\n{\n\tconst char *a = checkstring(J, 0);\n\tconst char *b = js_tostring(J, 1);\n\tjs_pushnumber(J, strcmp(a, b));\n}\n\nstatic void Sp_slice(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *ss, *ee;\n\tint len = utflen(str);\n\tint s = js_tointeger(J, 1);\n\tint e = js_isdefined(J, 2) ? js_tointeger(J, 2) : len;\n\n\ts = s < 0 ? s + len : s;\n\te = e < 0 ? e + len : e;\n\n\ts = s < 0 ? 0 : s > len ? len : s;\n\te = e < 0 ? 0 : e > len ? len : e;\n\n\tif (s < e) {\n\t\tss = js_utfidxtoptr(str, s);\n\t\tee = js_utfidxtoptr(ss, e - s);\n\t} else {\n\t\tss = js_utfidxtoptr(str, e);\n\t\tee = js_utfidxtoptr(ss, s - e);\n\t}\n\n\tjs_pushlstring(J, ss, ee - ss);\n}\n\nstatic void Sp_substring(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *ss, *ee;\n\tint len = utflen(str);\n\tint s = js_tointeger(J, 1);\n\tint e = js_isdefined(J, 2) ? js_tointeger(J, 2) : len;\n\n\ts = s < 0 ? 0 : s > len ? len : s;\n\te = e < 0 ? 0 : e > len ? len : e;\n\n\tif (s < e) {\n\t\tss = js_utfidxtoptr(str, s);\n\t\tee = js_utfidxtoptr(ss, e - s);\n\t} else {\n\t\tss = js_utfidxtoptr(str, e);\n\t\tee = js_utfidxtoptr(ss, s - e);\n\t}\n\n\tjs_pushlstring(J, ss, ee - ss);\n}\n\nstatic void Sp_toLowerCase(js_State *J)\n{\n\tconst char *src = checkstring(J, 0);\n\tchar *dst = js_malloc(J, UTFmax * strlen(src) + 1);\n\tconst char *s = src;\n\tchar *d = dst;\n\tRune rune;\n\twhile (*s) {\n\t\ts += chartorune(&rune, s);\n\t\trune = tolowerrune(rune);\n\t\td += runetochar(d, &rune);\n\t}\n\t*d = 0;\n\tif (js_try(J)) {\n\t\tjs_free(J, dst);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, dst);\n\tjs_endtry(J);\n\tjs_free(J, dst);\n}\n\nstatic void Sp_toUpperCase(js_State *J)\n{\n\tconst char *src = checkstring(J, 0);\n\tchar *dst = js_malloc(J, UTFmax * strlen(src) + 1);\n\tconst char *s = src;\n\tchar *d = dst;\n\tRune rune;\n\twhile (*s) {\n\t\ts += chartorune(&rune, s);\n\t\trune = toupperrune(rune);\n\t\td += runetochar(d, &rune);\n\t}\n\t*d = 0;\n\tif (js_try(J)) {\n\t\tjs_free(J, dst);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, dst);\n\tjs_endtry(J);\n\tjs_free(J, dst);\n}\n\nstatic int istrim(int c)\n{\n\treturn c == 0x9 || c == 0xB || c == 0xC || c == 0x20 || c == 0xA0 || c == 0xFEFF ||\n\t\tc == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;\n}\n\nstatic void Sp_trim(js_State *J)\n{\n\tconst char *s, *e;\n\ts = checkstring(J, 0);\n\twhile (istrim(*s))\n\t\t++s;\n\te = s + strlen(s);\n\twhile (e > s && istrim(e[-1]))\n\t\t--e;\n\tjs_pushlstring(J, s, e - s);\n}\n\nstatic void S_fromCharCode(js_State *J)\n{\n\tint i, top = js_gettop(J);\n\tRune c;\n\tchar *s, *p;\n\n\ts = p = js_malloc(J, (top-1) * UTFmax + 1);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, s);\n\t\tjs_throw(J);\n\t}\n\n\tfor (i = 1; i < top; ++i) {\n\t\tc = js_touint16(J, i);\n\t\tp += runetochar(p, &c);\n\t}\n\t*p = 0;\n\tjs_pushstring(J, s);\n\n\tjs_endtry(J);\n\tjs_free(J, s);\n}\n\nstatic void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}\n\nstatic void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}\n\nstatic void Sp_replace_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *source, *s, *r;\n\tjs_Buffer *sb = NULL;\n\tint n, x;\n\tResub m;\n\n\tsource = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\n\tif (js_regexec(re->prog, source, &m, 0)) {\n\t\tjs_copy(J, 0);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\nloop:\n\ts = m.sub[0].sp;\n\tn = m.sub[0].ep - m.sub[0].sp;\n\n\tif (js_iscallable(J, 2)) {\n\t\tjs_copy(J, 2);\n\t\tjs_pushundefined(J);\n\t\tfor (x = 0; m.sub[x].sp; ++x) /* arg 0..x: substring and subexps that matched */\n\t\t\tjs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);\n\t\tjs_pushnumber(J, s - source); /* arg x+2: offset within search string */\n\t\tjs_copy(J, 0); /* arg x+3: search string */\n\t\tjs_call(J, 2 + x);\n\t\tr = js_tostring(J, -1);\n\t\tjs_putm(J, &sb, source, s);\n\t\tjs_puts(J, &sb, r);\n\t\tjs_pop(J, 1);\n\t} else {\n\t\tr = js_tostring(J, 2);\n\t\tjs_putm(J, &sb, source, s);\n\t\twhile (*r) {\n\t\t\tif (*r == '$') {\n\t\t\t\tswitch (*(++r)) {\n\t\t\t\tcase 0: --r; /* end of string; back up */\n\t\t\t\t/* fallthrough */\n\t\t\t\tcase '$': js_putc(J, &sb, '$'); break;\n\t\t\t\tcase '`': js_putm(J, &sb, source, s); break;\n\t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;\n\t\t\t\tcase '&':\n\t\t\t\t\tjs_putm(J, &sb, s, s + n);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\t\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t\t\t\tx = *r - '0';\n\t\t\t\t\tif (r[1] >= '0' && r[1] <= '9')\n\t\t\t\t\t\tx = x * 10 + *(++r) - '0';\n\t\t\t\t\tif (x > 0 && x < m.nsub) {\n\t\t\t\t\t\tjs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjs_putc(J, &sb, '$');\n\t\t\t\t\t\tif (x > 10) {\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x / 10);\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x % 10);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tjs_putc(J, &sb, '$');\n\t\t\t\t\tjs_putc(J, &sb, *r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++r;\n\t\t\t} else {\n\t\t\t\tjs_putc(J, &sb, *r++);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re->flags & JS_REGEXP_G) {\n\t\tsource = m.sub[0].ep;\n\t\tif (n == 0) {\n\t\t\tif (*source)\n\t\t\t\tjs_putc(J, &sb, *source++);\n\t\t\telse\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n\t\t\tgoto loop;\n\t}\n\nend:\n\tjs_puts(J, &sb, s + n);\n\tjs_putc(J, &sb, 0);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, sb);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, sb ? sb->s : \"\");\n\tjs_endtry(J);\n\tjs_free(J, sb);\n}\n\nstatic void Sp_replace_string(js_State *J)\n{\n\tconst char *source, *needle, *s, *r;\n\tjs_Buffer *sb = NULL;\n\tint n;\n\n\tsource = checkstring(J, 0);\n\tneedle = js_tostring(J, 1);\n\n\ts = strstr(source, needle);\n\tif (!s) {\n\t\tjs_copy(J, 0);\n\t\treturn;\n\t}\n\tn = strlen(needle);\n\n\tif (js_iscallable(J, 2)) {\n\t\tjs_copy(J, 2);\n\t\tjs_pushundefined(J);\n\t\tjs_pushlstring(J, s, n); /* arg 1: substring that matched */\n\t\tjs_pushnumber(J, s - source); /* arg 2: offset within search string */\n\t\tjs_copy(J, 0); /* arg 3: search string */\n\t\tjs_call(J, 3);\n\t\tr = js_tostring(J, -1);\n\t\tjs_putm(J, &sb, source, s);\n\t\tjs_puts(J, &sb, r);\n\t\tjs_puts(J, &sb, s + n);\n\t\tjs_putc(J, &sb, 0);\n\t\tjs_pop(J, 1);\n\t} else {\n\t\tr = js_tostring(J, 2);\n\t\tjs_putm(J, &sb, source, s);\n\t\twhile (*r) {\n\t\t\tif (*r == '$') {\n\t\t\t\tswitch (*(++r)) {\n\t\t\t\tcase 0: --r; /* end of string; back up */\n\t\t\t\t/* fallthrough */\n\t\t\t\tcase '$': js_putc(J, &sb, '$'); break;\n\t\t\t\tcase '&': js_putm(J, &sb, s, s + n); break;\n\t\t\t\tcase '`': js_putm(J, &sb, source, s); break;\n\t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;\n\t\t\t\tdefault: js_putc(J, &sb, '$'); js_putc(J, &sb, *r); break;\n\t\t\t\t}\n\t\t\t\t++r;\n\t\t\t} else {\n\t\t\t\tjs_putc(J, &sb, *r++);\n\t\t\t}\n\t\t}\n\t\tjs_puts(J, &sb, s + n);\n\t\tjs_putc(J, &sb, 0);\n\t}\n\n\tif (js_try(J)) {\n\t\tjs_free(J, sb);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, sb ? sb->s : \"\");\n\tjs_endtry(J);\n\tjs_free(J, sb);\n}\n\nstatic void Sp_replace(js_State *J)\n{\n\tif (js_isregexp(J, 1))\n\t\tSp_replace_regexp(J);\n\telse\n\t\tSp_replace_string(J);\n}\n\nstatic void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\n\tjs_newarray(J);\n\tlen = 0;\n\n\te = text + strlen(text);\n\n\t/* splitting the empty string */\n\tif (e == text) {\n\t\tif (js_regexec(re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; /* no match */\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\t/* empty string at end of last match */\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\n\t\ta = p = c;\n\t}\n\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}\n\nstatic void Sp_split_string(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *sep = js_tostring(J, 1);\n\tint limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tint i, n;\n\n\tjs_newarray(J);\n\n\tn = strlen(sep);\n\n\t/* empty string */\n\tif (n == 0) {\n\t\tRune rune;\n\t\tfor (i = 0; *str && i < limit; ++i) {\n\t\t\tn = chartorune(&rune, str);\n\t\t\tjs_pushlstring(J, str, n);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr += n;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; str && i < limit; ++i) {\n\t\tconst char *s = strstr(str, sep);\n\t\tif (s) {\n\t\t\tjs_pushlstring(J, str, s-str);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr = s + n;\n\t\t} else {\n\t\t\tjs_pushstring(J, str);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr = NULL;\n\t\t}\n\t}\n}\n\nstatic void Sp_split(js_State *J)\n{\n\tif (js_isundefined(J, 1)) {\n\t\tjs_newarray(J);\n\t\tjs_copy(J, 0);\n\t\tjs_setindex(J, -2, 0);\n\t} else if (js_isregexp(J, 1)) {\n\t\tSp_split_regexp(J);\n\t} else {\n\t\tSp_split_string(J);\n\t}\n}\n\nvoid jsB_initstring(js_State *J)\n{\n\tJ->String_prototype->u.s.string = \"\";\n\tJ->String_prototype->u.s.length = 0;\n\n\tjs_pushobject(J, J->String_prototype);\n\t{\n\t\tjsB_propf(J, \"String.prototype.toString\", Sp_toString, 0);\n\t\tjsB_propf(J, \"String.prototype.valueOf\", Sp_valueOf, 0);\n\t\tjsB_propf(J, \"String.prototype.charAt\", Sp_charAt, 1);\n\t\tjsB_propf(J, \"String.prototype.charCodeAt\", Sp_charCodeAt, 1);\n\t\tjsB_propf(J, \"String.prototype.concat\", Sp_concat, 0); /* 1 */\n\t\tjsB_propf(J, \"String.prototype.indexOf\", Sp_indexOf, 1);\n\t\tjsB_propf(J, \"String.prototype.lastIndexOf\", Sp_lastIndexOf, 1);\n\t\tjsB_propf(J, \"String.prototype.localeCompare\", Sp_localeCompare, 1);\n\t\tjsB_propf(J, \"String.prototype.match\", Sp_match, 1);\n\t\tjsB_propf(J, \"String.prototype.replace\", Sp_replace, 2);\n\t\tjsB_propf(J, \"String.prototype.search\", Sp_search, 1);\n\t\tjsB_propf(J, \"String.prototype.slice\", Sp_slice, 2);\n\t\tjsB_propf(J, \"String.prototype.split\", Sp_split, 2);\n\t\tjsB_propf(J, \"String.prototype.substring\", Sp_substring, 2);\n\t\tjsB_propf(J, \"String.prototype.toLowerCase\", Sp_toLowerCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toLocaleLowerCase\", Sp_toLowerCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toUpperCase\", Sp_toUpperCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toLocaleUpperCase\", Sp_toUpperCase, 0);\n\n\t\t/* ES5 */\n\t\tjsB_propf(J, \"String.prototype.trim\", Sp_trim, 0);\n\t}\n\tjs_newcconstructor(J, jsB_String, jsB_new_String, \"String\", 0); /* 1 */\n\t{\n\t\tjsB_propf(J, \"String.fromCharCode\", S_fromCharCode, 0); /* 1 */\n\t}\n\tjs_defglobal(J, \"String\", JS_DONTENUM);\n}\n", "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n#include <limits.h>\n\n#include \"regexp.h\"\n#include \"utf.h\"\n\n#define emit regemit\n#define next regnext\n#define accept regaccept\n\n#define nelem(a) (int)(sizeof (a) / sizeof (a)[0])\n\n#define REPINF 255\n#define MAXSUB REG_MAXSUB\n#define MAXPROG (32 << 10)\n\ntypedef struct Reclass Reclass;\ntypedef struct Renode Renode;\ntypedef struct Reinst Reinst;\ntypedef struct Rethread Rethread;\n\nstruct Reclass {\n\tRune *end;\n\tRune spans[64];\n};\n\nstruct Reprog {\n\tReinst *start, *end;\n\tint flags;\n\tint nsub;\n\tReclass cclass[16];\n};\n\nstruct cstate {\n\tReprog *prog;\n\tRenode *pstart, *pend;\n\n\tconst char *source;\n\tint ncclass;\n\tint nsub;\n\tRenode *sub[MAXSUB];\n\n\tint lookahead;\n\tRune yychar;\n\tReclass *yycc;\n\tint yymin, yymax;\n\n\tconst char *error;\n\tjmp_buf kaboom;\n};\n\nstatic void die(struct cstate *g, const char *message)\n{\n\tg->error = message;\n\tlongjmp(g->kaboom, 1);\n}\n\nstatic int canon(Rune c)\n{\n\tRune u = toupperrune(c);\n\tif (c >= 128 && u < 128)\n\t\treturn c;\n\treturn u;\n}\n\n/* Scan */\n\nenum {\n\tL_CHAR = 256,\n\tL_CCLASS,\t/* character class */\n\tL_NCCLASS,\t/* negative character class */\n\tL_NC,\t\t/* \"(?:\" no capture */\n\tL_PLA,\t\t/* \"(?=\" positive lookahead */\n\tL_NLA,\t\t/* \"(?!\" negative lookahead */\n\tL_WORD,\t\t/* \"\\b\" word boundary */\n\tL_NWORD,\t/* \"\\B\" non-word boundary */\n\tL_REF,\t\t/* \"\\1\" back-reference */\n\tL_COUNT,\t/* {M,N} */\n};\n\nstatic int hex(struct cstate *g, int c)\n{\n\tif (c >= '0' && c <= '9') return c - '0';\n\tif (c >= 'a' && c <= 'f') return c - 'a' + 0xA;\n\tif (c >= 'A' && c <= 'F') return c - 'A' + 0xA;\n\tdie(g, \"invalid escape sequence\");\n\treturn 0;\n}\n\nstatic int dec(struct cstate *g, int c)\n{\n\tif (c >= '0' && c <= '9') return c - '0';\n\tdie(g, \"invalid quantifier\");\n\treturn 0;\n}\n\n#define ESCAPES \"BbDdSsWw^$\\\\.*+?()[]{}|0123456789\"\n\nstatic int isunicodeletter(int c)\n{\n\treturn (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || isalpharune(c);\n}\n\nstatic int nextrune(struct cstate *g)\n{\n\tg->source += chartorune(&g->yychar, g->source);\n\tif (g->yychar == '\\\\') {\n\t\tg->source += chartorune(&g->yychar, g->source);\n\t\tswitch (g->yychar) {\n\t\tcase 0: die(g, \"unterminated escape sequence\"); break;\n\t\tcase 'f': g->yychar = '\\f'; return 0;\n\t\tcase 'n': g->yychar = '\\n'; return 0;\n\t\tcase 'r': g->yychar = '\\r'; return 0;\n\t\tcase 't': g->yychar = '\\t'; return 0;\n\t\tcase 'v': g->yychar = '\\v'; return 0;\n\t\tcase 'c':\n\t\t\tg->yychar = (*g->source++) & 31;\n\t\t\treturn 0;\n\t\tcase 'x':\n\t\t\tg->yychar = hex(g, *g->source++) << 4;\n\t\t\tg->yychar += hex(g, *g->source++);\n\t\t\tif (g->yychar == 0) {\n\t\t\t\tg->yychar = '0';\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'u':\n\t\t\tg->yychar = hex(g, *g->source++) << 12;\n\t\t\tg->yychar += hex(g, *g->source++) << 8;\n\t\t\tg->yychar += hex(g, *g->source++) << 4;\n\t\t\tg->yychar += hex(g, *g->source++);\n\t\t\tif (g->yychar == 0) {\n\t\t\t\tg->yychar = '0';\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (strchr(ESCAPES, g->yychar))\n\t\t\treturn 1;\n\t\tif (isunicodeletter(g->yychar) || g->yychar == '_') /* check identity escape */\n\t\t\tdie(g, \"invalid escape character\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int lexcount(struct cstate *g)\n{\n\tg->yychar = *g->source++;\n\n\tg->yymin = dec(g, g->yychar);\n\tg->yychar = *g->source++;\n\twhile (g->yychar != ',' && g->yychar != '}') {\n\t\tg->yymin = g->yymin * 10 + dec(g, g->yychar);\n\t\tg->yychar = *g->source++;\n\t\tif (g->yymin >= REPINF)\n\t\t\tdie(g, \"numeric overflow\");\n\t}\n\n\tif (g->yychar == ',') {\n\t\tg->yychar = *g->source++;\n\t\tif (g->yychar == '}') {\n\t\t\tg->yymax = REPINF;\n\t\t} else {\n\t\t\tg->yymax = dec(g, g->yychar);\n\t\t\tg->yychar = *g->source++;\n\t\t\twhile (g->yychar != '}') {\n\t\t\t\tg->yymax = g->yymax * 10 + dec(g, g->yychar);\n\t\t\t\tg->yychar = *g->source++;\n\t\t\t\tif (g->yymax >= REPINF)\n\t\t\t\t\tdie(g, \"numeric overflow\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tg->yymax = g->yymin;\n\t}\n\n\treturn L_COUNT;\n}\n\nstatic void newcclass(struct cstate *g)\n{\n\tif (g->ncclass >= nelem(g->prog->cclass))\n\t\tdie(g, \"too many character classes\");\n\tg->yycc = g->prog->cclass + g->ncclass++;\n\tg->yycc->end = g->yycc->spans;\n}\n\nstatic void addrange(struct cstate *g, Rune a, Rune b)\n{\n\tif (a > b)\n\t\tdie(g, \"invalid character class range\");\n\tif (g->yycc->end + 2 == g->yycc->spans + nelem(g->yycc->spans))\n\t\tdie(g, \"too many character class ranges\");\n\t*g->yycc->end++ = a;\n\t*g->yycc->end++ = b;\n}\n\nstatic void addranges_d(struct cstate *g)\n{\n\taddrange(g, '0', '9');\n}\n\nstatic void addranges_D(struct cstate *g)\n{\n\taddrange(g, 0, '0'-1);\n\taddrange(g, '9'+1, 0xFFFF);\n}\n\nstatic void addranges_s(struct cstate *g)\n{\n\taddrange(g, 0x9, 0xD);\n\taddrange(g, 0x20, 0x20);\n\taddrange(g, 0xA0, 0xA0);\n\taddrange(g, 0x2028, 0x2029);\n\taddrange(g, 0xFEFF, 0xFEFF);\n}\n\nstatic void addranges_S(struct cstate *g)\n{\n\taddrange(g, 0, 0x9-1);\n\taddrange(g, 0xD+1, 0x20-1);\n\taddrange(g, 0x20+1, 0xA0-1);\n\taddrange(g, 0xA0+1, 0x2028-1);\n\taddrange(g, 0x2029+1, 0xFEFF-1);\n\taddrange(g, 0xFEFF+1, 0xFFFF);\n}\n\nstatic void addranges_w(struct cstate *g)\n{\n\taddrange(g, '0', '9');\n\taddrange(g, 'A', 'Z');\n\taddrange(g, '_', '_');\n\taddrange(g, 'a', 'z');\n}\n\nstatic void addranges_W(struct cstate *g)\n{\n\taddrange(g, 0, '0'-1);\n\taddrange(g, '9'+1, 'A'-1);\n\taddrange(g, 'Z'+1, '_'-1);\n\taddrange(g, '_'+1, 'a'-1);\n\taddrange(g, 'z'+1, 0xFFFF);\n}\n\nstatic int lexclass(struct cstate *g)\n{\n\tint type = L_CCLASS;\n\tint quoted, havesave, havedash;\n\tRune save = 0;\n\n\tnewcclass(g);\n\n\tquoted = nextrune(g);\n\tif (!quoted && g->yychar == '^') {\n\t\ttype = L_NCCLASS;\n\t\tquoted = nextrune(g);\n\t}\n\n\thavesave = havedash = 0;\n\tfor (;;) {\n\t\tif (g->yychar == 0)\n\t\t\tdie(g, \"unterminated character class\");\n\t\tif (!quoted && g->yychar == ']')\n\t\t\tbreak;\n\n\t\tif (!quoted && g->yychar == '-') {\n\t\t\tif (havesave) {\n\t\t\t\tif (havedash) {\n\t\t\t\t\taddrange(g, save, '-');\n\t\t\t\t\thavesave = havedash = 0;\n\t\t\t\t} else {\n\t\t\t\t\thavedash = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsave = '-';\n\t\t\t\thavesave = 1;\n\t\t\t}\n\t\t} else if (quoted && strchr(\"DSWdsw\", g->yychar)) {\n\t\t\tif (havesave) {\n\t\t\t\taddrange(g, save, save);\n\t\t\t\tif (havedash)\n\t\t\t\t\taddrange(g, '-', '-');\n\t\t\t}\n\t\t\tswitch (g->yychar) {\n\t\t\tcase 'd': addranges_d(g); break;\n\t\t\tcase 's': addranges_s(g); break;\n\t\t\tcase 'w': addranges_w(g); break;\n\t\t\tcase 'D': addranges_D(g); break;\n\t\t\tcase 'S': addranges_S(g); break;\n\t\t\tcase 'W': addranges_W(g); break;\n\t\t\t}\n\t\t\thavesave = havedash = 0;\n\t\t} else {\n\t\t\tif (quoted) {\n\t\t\t\tif (g->yychar == 'b')\n\t\t\t\t\tg->yychar = '\\b';\n\t\t\t\telse if (g->yychar == '0')\n\t\t\t\t\tg->yychar = 0;\n\t\t\t\t/* else identity escape */\n\t\t\t}\n\t\t\tif (havesave) {\n\t\t\t\tif (havedash) {\n\t\t\t\t\taddrange(g, save, g->yychar);\n\t\t\t\t\thavesave = havedash = 0;\n\t\t\t\t} else {\n\t\t\t\t\taddrange(g, save, save);\n\t\t\t\t\tsave = g->yychar;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsave = g->yychar;\n\t\t\t\thavesave = 1;\n\t\t\t}\n\t\t}\n\n\t\tquoted = nextrune(g);\n\t}\n\n\tif (havesave) {\n\t\taddrange(g, save, save);\n\t\tif (havedash)\n\t\t\taddrange(g, '-', '-');\n\t}\n\n\treturn type;\n}\n\nstatic int lex(struct cstate *g)\n{\n\tint quoted = nextrune(g);\n\tif (quoted) {\n\t\tswitch (g->yychar) {\n\t\tcase 'b': return L_WORD;\n\t\tcase 'B': return L_NWORD;\n\t\tcase 'd': newcclass(g); addranges_d(g); return L_CCLASS;\n\t\tcase 's': newcclass(g); addranges_s(g); return L_CCLASS;\n\t\tcase 'w': newcclass(g); addranges_w(g); return L_CCLASS;\n\t\tcase 'D': newcclass(g); addranges_d(g); return L_NCCLASS;\n\t\tcase 'S': newcclass(g); addranges_s(g); return L_NCCLASS;\n\t\tcase 'W': newcclass(g); addranges_w(g); return L_NCCLASS;\n\t\tcase '0': g->yychar = 0; return L_CHAR;\n\t\t}\n\t\tif (g->yychar >= '0' && g->yychar <= '9') {\n\t\t\tg->yychar -= '0';\n\t\t\tif (*g->source >= '0' && *g->source <= '9')\n\t\t\t\tg->yychar = g->yychar * 10 + *g->source++ - '0';\n\t\t\treturn L_REF;\n\t\t}\n\t\treturn L_CHAR;\n\t}\n\n\tswitch (g->yychar) {\n\tcase 0:\n\tcase '$': case ')': case '*': case '+':\n\tcase '.': case '?': case '^': case '|':\n\t\treturn g->yychar;\n\t}\n\n\tif (g->yychar == '{')\n\t\treturn lexcount(g);\n\tif (g->yychar == '[')\n\t\treturn lexclass(g);\n\tif (g->yychar == '(') {\n\t\tif (g->source[0] == '?') {\n\t\t\tif (g->source[1] == ':') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NC;\n\t\t\t}\n\t\t\tif (g->source[1] == '=') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_PLA;\n\t\t\t}\n\t\t\tif (g->source[1] == '!') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NLA;\n\t\t\t}\n\t\t}\n\t\treturn '(';\n\t}\n\n\treturn L_CHAR;\n}\n\n/* Parse */\n\nenum {\n\tP_CAT, P_ALT, P_REP,\n\tP_BOL, P_EOL, P_WORD, P_NWORD,\n\tP_PAR, P_PLA, P_NLA,\n\tP_ANY, P_CHAR, P_CCLASS, P_NCCLASS,\n\tP_REF,\n};\n\nstruct Renode {\n\tunsigned char type;\n\tunsigned char ng, m, n;\n\tRune c;\n\tReclass *cc;\n\tRenode *x;\n\tRenode *y;\n};\n\nstatic Renode *newnode(struct cstate *g, int type)\n{\n\tRenode *node = g->pend++;\n\tnode->type = type;\n\tnode->cc = NULL;\n\tnode->c = 0;\n\tnode->ng = 0;\n\tnode->m = 0;\n\tnode->n = 0;\n\tnode->x = node->y = NULL;\n\treturn node;\n}\n\nstatic int empty(Renode *node)\n{\n\tif (!node) return 1;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return empty(node->x) && empty(node->y);\n\tcase P_ALT: return empty(node->x) || empty(node->y);\n\tcase P_REP: return empty(node->x) || node->m == 0;\n\tcase P_PAR: return empty(node->x);\n\tcase P_REF: return empty(node->x);\n\tcase P_ANY: case P_CHAR: case P_CCLASS: case P_NCCLASS: return 0;\n\t}\n}\n\nstatic Renode *newrep(struct cstate *g, Renode *atom, int ng, int min, int max)\n{\n\tRenode *rep = newnode(g, P_REP);\n\tif (max == REPINF && empty(atom))\n\t\tdie(g, \"infinite loop matching the empty string\");\n\trep->ng = ng;\n\trep->m = min;\n\trep->n = max;\n\trep->x = atom;\n\treturn rep;\n}\n\nstatic void next(struct cstate *g)\n{\n\tg->lookahead = lex(g);\n}\n\nstatic int accept(struct cstate *g, int t)\n{\n\tif (g->lookahead == t) {\n\t\tnext(g);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Renode *parsealt(struct cstate *g);\n\nstatic Renode *parseatom(struct cstate *g)\n{\n\tRenode *atom;\n\tif (g->lookahead == L_CHAR) {\n\t\tatom = newnode(g, P_CHAR);\n\t\tatom->c = g->yychar;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_CCLASS) {\n\t\tatom = newnode(g, P_CCLASS);\n\t\tatom->cc = g->yycc;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_NCCLASS) {\n\t\tatom = newnode(g, P_NCCLASS);\n\t\tatom->cc = g->yycc;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_REF) {\n\t\tatom = newnode(g, P_REF);\n\t\tif (g->yychar == 0 || g->yychar >= g->nsub || !g->sub[g->yychar])\n\t\t\tdie(g, \"invalid back-reference\");\n\t\tatom->n = g->yychar;\n\t\tatom->x = g->sub[g->yychar];\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (accept(g, '.'))\n\t\treturn newnode(g, P_ANY);\n\tif (accept(g, '(')) {\n\t\tatom = newnode(g, P_PAR);\n\t\tif (g->nsub == MAXSUB)\n\t\t\tdie(g, \"too many captures\");\n\t\tatom->n = g->nsub++;\n\t\tatom->x = parsealt(g);\n\t\tg->sub[atom->n] = atom;\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_NC)) {\n\t\tatom = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_PLA)) {\n\t\tatom = newnode(g, P_PLA);\n\t\tatom->x = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_NLA)) {\n\t\tatom = newnode(g, P_NLA);\n\t\tatom->x = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tdie(g, \"syntax error\");\n\treturn NULL;\n}\n\nstatic Renode *parserep(struct cstate *g)\n{\n\tRenode *atom;\n\n\tif (accept(g, '^')) return newnode(g, P_BOL);\n\tif (accept(g, '$')) return newnode(g, P_EOL);\n\tif (accept(g, L_WORD)) return newnode(g, P_WORD);\n\tif (accept(g, L_NWORD)) return newnode(g, P_NWORD);\n\n\tatom = parseatom(g);\n\tif (g->lookahead == L_COUNT) {\n\t\tint min = g->yymin, max = g->yymax;\n\t\tnext(g);\n\t\tif (max < min)\n\t\t\tdie(g, \"invalid quantifier\");\n\t\treturn newrep(g, atom, accept(g, '?'), min, max);\n\t}\n\tif (accept(g, '*')) return newrep(g, atom, accept(g, '?'), 0, REPINF);\n\tif (accept(g, '+')) return newrep(g, atom, accept(g, '?'), 1, REPINF);\n\tif (accept(g, '?')) return newrep(g, atom, accept(g, '?'), 0, 1);\n\treturn atom;\n}\n\nstatic Renode *parsecat(struct cstate *g)\n{\n\tRenode *cat, *head, **tail;\n\tif (g->lookahead && g->lookahead != '|' && g->lookahead != ')') {\n\t\t/* Build a right-leaning tree by splicing in new 'cat' at the tail. */\n\t\thead = parserep(g);\n\t\ttail = &head;\n\t\twhile (g->lookahead && g->lookahead != '|' && g->lookahead != ')') {\n\t\t\tcat = newnode(g, P_CAT);\n\t\t\tcat->x = *tail;\n\t\t\tcat->y = parserep(g);\n\t\t\t*tail = cat;\n\t\t\ttail = &cat->y;\n\t\t}\n\t\treturn head;\n\t}\n\treturn NULL;\n}\n\nstatic Renode *parsealt(struct cstate *g)\n{\n\tRenode *alt, *x;\n\talt = parsecat(g);\n\twhile (accept(g, '|')) {\n\t\tx = alt;\n\t\talt = newnode(g, P_ALT);\n\t\talt->x = x;\n\t\talt->y = parsecat(g);\n\t}\n\treturn alt;\n}\n\n/* Compile */\n\nenum {\n\tI_END, I_JUMP, I_SPLIT, I_PLA, I_NLA,\n\tI_ANYNL, I_ANY, I_CHAR, I_CCLASS, I_NCCLASS, I_REF,\n\tI_BOL, I_EOL, I_WORD, I_NWORD,\n\tI_LPAR, I_RPAR\n};\n\nstruct Reinst {\n\tunsigned char opcode;\n\tunsigned char n;\n\tRune c;\n\tReclass *cc;\n\tReinst *x;\n\tReinst *y;\n};\n\nstatic int count(struct cstate *g, Renode *node)\n{\n\tint min, max, n;\n\tif (!node) return 0;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return count(g, node->x) + count(g, node->y);\n\tcase P_ALT: return count(g, node->x) + count(g, node->y) + 2;\n\tcase P_REP:\n\t\tmin = node->m;\n\t\tmax = node->n;\n\t\tif (min == max) n = count(g, node->x) * min;\n\t\telse if (max < REPINF) n = count(g, node->x) * max + (max - min);\n\t\telse n = count(g, node->x) * (min + 1) + 2;\n\t\tif (n < 0 || n > MAXPROG) die(g, \"program too large\");\n\t\treturn n;\n\tcase P_PAR: return count(g, node->x) + 2;\n\tcase P_PLA: return count(g, node->x) + 2;\n\tcase P_NLA: return count(g, node->x) + 2;\n\t}\n}\n\nstatic Reinst *emit(Reprog *prog, int opcode)\n{\n\tReinst *inst = prog->end++;\n\tinst->opcode = opcode;\n\tinst->n = 0;\n\tinst->c = 0;\n\tinst->cc = NULL;\n\tinst->x = inst->y = NULL;\n\treturn inst;\n}\n\nstatic void compile(Reprog *prog, Renode *node)\n{\n\tReinst *inst, *split, *jump;\n\tint i;\n\n\tif (!node)\n\t\treturn;\n\nloop:\n\tswitch (node->type) {\n\tcase P_CAT:\n\t\tcompile(prog, node->x);\n\t\tnode = node->y;\n\t\tgoto loop;\n\n\tcase P_ALT:\n\t\tsplit = emit(prog, I_SPLIT);\n\t\tcompile(prog, node->x);\n\t\tjump = emit(prog, I_JUMP);\n\t\tcompile(prog, node->y);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = jump + 1;\n\t\tjump->x = prog->end;\n\t\tbreak;\n\n\tcase P_REP:\n\t\tinst = NULL; /* silence compiler warning. assert(node->m > 0). */\n\t\tfor (i = 0; i < node->m; ++i) {\n\t\t\tinst = prog->end;\n\t\t\tcompile(prog, node->x);\n\t\t}\n\t\tif (node->m == node->n)\n\t\t\tbreak;\n\t\tif (node->n < REPINF) {\n\t\t\tfor (i = node->m; i < node->n; ++i) {\n\t\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\t\tcompile(prog, node->x);\n\t\t\t\tif (node->ng) {\n\t\t\t\t\tsplit->y = split + 1;\n\t\t\t\t\tsplit->x = prog->end;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->x = split + 1;\n\t\t\t\t\tsplit->y = prog->end;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node->m == 0) {\n\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\tcompile(prog, node->x);\n\t\t\tjump = emit(prog, I_JUMP);\n\t\t\tif (node->ng) {\n\t\t\t\tsplit->y = split + 1;\n\t\t\t\tsplit->x = prog->end;\n\t\t\t} else {\n\t\t\t\tsplit->x = split + 1;\n\t\t\t\tsplit->y = prog->end;\n\t\t\t}\n\t\t\tjump->x = split;\n\t\t} else {\n\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\tif (node->ng) {\n\t\t\t\tsplit->y = inst;\n\t\t\t\tsplit->x = prog->end;\n\t\t\t} else {\n\t\t\t\tsplit->x = inst;\n\t\t\t\tsplit->y = prog->end;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase P_BOL: emit(prog, I_BOL); break;\n\tcase P_EOL: emit(prog, I_EOL); break;\n\tcase P_WORD: emit(prog, I_WORD); break;\n\tcase P_NWORD: emit(prog, I_NWORD); break;\n\n\tcase P_PAR:\n\t\tinst = emit(prog, I_LPAR);\n\t\tinst->n = node->n;\n\t\tcompile(prog, node->x);\n\t\tinst = emit(prog, I_RPAR);\n\t\tinst->n = node->n;\n\t\tbreak;\n\tcase P_PLA:\n\t\tsplit = emit(prog, I_PLA);\n\t\tcompile(prog, node->x);\n\t\temit(prog, I_END);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = prog->end;\n\t\tbreak;\n\tcase P_NLA:\n\t\tsplit = emit(prog, I_NLA);\n\t\tcompile(prog, node->x);\n\t\temit(prog, I_END);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = prog->end;\n\t\tbreak;\n\n\tcase P_ANY:\n\t\temit(prog, I_ANY);\n\t\tbreak;\n\tcase P_CHAR:\n\t\tinst = emit(prog, I_CHAR);\n\t\tinst->c = (prog->flags & REG_ICASE) ? canon(node->c) : node->c;\n\t\tbreak;\n\tcase P_CCLASS:\n\t\tinst = emit(prog, I_CCLASS);\n\t\tinst->cc = node->cc;\n\t\tbreak;\n\tcase P_NCCLASS:\n\t\tinst = emit(prog, I_NCCLASS);\n\t\tinst->cc = node->cc;\n\t\tbreak;\n\tcase P_REF:\n\t\tinst = emit(prog, I_REF);\n\t\tinst->n = node->n;\n\t\tbreak;\n\t}\n}\n\n#ifdef TEST\nstatic void dumpnode(Renode *node)\n{\n\tRune *p;\n\tif (!node) { printf(\"Empty\"); return; }\n\tswitch (node->type) {\n\tcase P_CAT: printf(\"Cat(\"); dumpnode(node->x); printf(\", \"); dumpnode(node->y); printf(\")\"); break;\n\tcase P_ALT: printf(\"Alt(\"); dumpnode(node->x); printf(\", \"); dumpnode(node->y); printf(\")\"); break;\n\tcase P_REP:\n\t\tprintf(node->ng ? \"NgRep(%d,%d,\" : \"Rep(%d,%d,\", node->m, node->n);\n\t\tdumpnode(node->x);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_BOL: printf(\"Bol\"); break;\n\tcase P_EOL: printf(\"Eol\"); break;\n\tcase P_WORD: printf(\"Word\"); break;\n\tcase P_NWORD: printf(\"NotWord\"); break;\n\tcase P_PAR: printf(\"Par(%d,\", node->n); dumpnode(node->x); printf(\")\"); break;\n\tcase P_PLA: printf(\"PLA(\"); dumpnode(node->x); printf(\")\"); break;\n\tcase P_NLA: printf(\"NLA(\"); dumpnode(node->x); printf(\")\"); break;\n\tcase P_ANY: printf(\"Any\"); break;\n\tcase P_CHAR: printf(\"Char(%c)\", node->c); break;\n\tcase P_CCLASS:\n\t\tprintf(\"Class(\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"%02X-%02X,\", p[0], p[1]);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_NCCLASS:\n\t\tprintf(\"NotClass(\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"%02X-%02X,\", p[0], p[1]);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_REF: printf(\"Ref(%d)\", node->n); break;\n\t}\n}\n\nstatic void dumpprog(Reprog *prog)\n{\n\tReinst *inst;\n\tint i;\n\tfor (i = 0, inst = prog->start; inst < prog->end; ++i, ++inst) {\n\t\tprintf(\"% 5d: \", i);\n\t\tswitch (inst->opcode) {\n\t\tcase I_END: puts(\"end\"); break;\n\t\tcase I_JUMP: printf(\"jump %d\\n\", (int)(inst->x - prog->start)); break;\n\t\tcase I_SPLIT: printf(\"split %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_PLA: printf(\"pla %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_NLA: printf(\"nla %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_ANY: puts(\"any\"); break;\n\t\tcase I_ANYNL: puts(\"anynl\"); break;\n\t\tcase I_CHAR: printf(inst->c >= 32 && inst->c < 127 ? \"char '%c'\\n\" : \"char U+%04X\\n\", inst->c); break;\n\t\tcase I_CCLASS: puts(\"cclass\"); break;\n\t\tcase I_NCCLASS: puts(\"ncclass\"); break;\n\t\tcase I_REF: printf(\"ref %d\\n\", inst->n); break;\n\t\tcase I_BOL: puts(\"bol\"); break;\n\t\tcase I_EOL: puts(\"eol\"); break;\n\t\tcase I_WORD: puts(\"word\"); break;\n\t\tcase I_NWORD: puts(\"nword\"); break;\n\t\tcase I_LPAR: printf(\"lpar %d\\n\", inst->n); break;\n\t\tcase I_RPAR: printf(\"rpar %d\\n\", inst->n); break;\n\t\t}\n\t}\n}\n#endif\n\nReprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx,\n\tconst char *pattern, int cflags, const char **errorp)\n{\n\tstruct cstate g;\n\tRenode *node;\n\tReinst *split, *jump;\n\tint i, n;\n\n\tg.pstart = NULL;\n\tg.prog = NULL;\n\n\tif (setjmp(g.kaboom)) {\n\t\tif (errorp) *errorp = g.error;\n\t\talloc(ctx, g.pstart, 0);\n\t\talloc(ctx, g.prog, 0);\n\t\treturn NULL;\n\t}\n\n\tg.prog = alloc(ctx, NULL, sizeof (Reprog));\n\tif (!g.prog)\n\t\tdie(&g, \"cannot allocate regular expression\");\n\tn = strlen(pattern) * 2;\n\tif (n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\tif (n > 0) {\n\t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n\t\tif (!g.pstart)\n\t\t\tdie(&g, \"cannot allocate regular expression parse list\");\n\t}\n\n\tg.source = pattern;\n\tg.ncclass = 0;\n\tg.nsub = 1;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tg.sub[i] = 0;\n\n\tg.prog->flags = cflags;\n\n\tnext(&g);\n\tnode = parsealt(&g);\n\tif (g.lookahead == ')')\n\t\tdie(&g, \"unmatched ')'\");\n\tif (g.lookahead != 0)\n\t\tdie(&g, \"syntax error\");\n\n#ifdef TEST\n\tdumpnode(node);\n\tputchar('\\n');\n#endif\n\n\tn = 6 + count(&g, node);\n\tif (n < 0 || n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\n\tg.prog->nsub = g.nsub;\n\tg.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst));\n\tif (!g.prog->start)\n\t\tdie(&g, \"cannot allocate regular expression instruction list\");\n\n\tsplit = emit(g.prog, I_SPLIT);\n\tsplit->x = split + 3;\n\tsplit->y = split + 1;\n\temit(g.prog, I_ANYNL);\n\tjump = emit(g.prog, I_JUMP);\n\tjump->x = split;\n\temit(g.prog, I_LPAR);\n\tcompile(g.prog, node);\n\temit(g.prog, I_RPAR);\n\temit(g.prog, I_END);\n\n#ifdef TEST\n\tdumpprog(g.prog);\n#endif\n\n\talloc(ctx, g.pstart, 0);\n\n\tif (errorp) *errorp = NULL;\n\treturn g.prog;\n}\n\nvoid regfreex(void *(*alloc)(void *ctx, void *p, int n), void *ctx, Reprog *prog)\n{\n\tif (prog) {\n\t\talloc(ctx, prog->start, 0);\n\t\talloc(ctx, prog, 0);\n\t}\n}\n\nstatic void *default_alloc(void *ctx, void *p, int n)\n{\n\treturn realloc(p, (size_t)n);\n}\n\nReprog *regcomp(const char *pattern, int cflags, const char **errorp)\n{\n\treturn regcompx(default_alloc, NULL, pattern, cflags, errorp);\n}\n\nvoid regfree(Reprog *prog)\n{\n\tregfreex(default_alloc, NULL, prog);\n}\n\n/* Match */\n\nstatic int isnewline(int c)\n{\n\treturn c == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;\n}\n\nstatic int iswordchar(int c)\n{\n\treturn c == '_' ||\n\t\t(c >= 'a' && c <= 'z') ||\n\t\t(c >= 'A' && c <= 'Z') ||\n\t\t(c >= '0' && c <= '9');\n}\n\nstatic int incclass(Reclass *cc, Rune c)\n{\n\tRune *p;\n\tfor (p = cc->spans; p < cc->end; p += 2)\n\t\tif (p[0] <= c && c <= p[1])\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int incclasscanon(Reclass *cc, Rune c)\n{\n\tRune *p, r;\n\tfor (p = cc->spans; p < cc->end; p += 2)\n\t\tfor (r = p[0]; r <= p[1]; ++r)\n\t\t\tif (c == canon(r))\n\t\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int strncmpcanon(const char *a, const char *b, int n)\n{\n\tRune ra, rb;\n\tint c;\n\twhile (n--) {\n\t\tif (!*a) return -1;\n\t\tif (!*b) return 1;\n\t\ta += chartorune(&ra, a);\n\t\tb += chartorune(&rb, b);\n\t\tc = canon(ra) - canon(rb);\n\t\tif (c)\n\t\t\treturn c;\n\t}\n\treturn 0;\n}\n\nstatic int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n{\n\tResub scratch;\n\tint i;\n\tRune c;\n\n\tfor (;;) {\n\t\tswitch (pc->opcode) {\n\t\tcase I_END:\n\t\t\treturn 1;\n\t\tcase I_JUMP:\n\t\t\tpc = pc->x;\n\t\t\tbreak;\n\t\tcase I_SPLIT:\n\t\t\tscratch = *out;\n\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n\t\t\t\t*out = scratch;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\n\t\tcase I_PLA:\n\t\t\tif (!match(pc->x, sp, bol, flags, out))\n\t\t\t\treturn 0;\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\t\tcase I_NLA:\n\t\t\tscratch = *out;\n\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n\t\t\t\treturn 0;\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\n\t\tcase I_ANYNL:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 0;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_ANY:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 0;\n\t\t\tif (isnewline(c))\n\t\t\t\treturn 0;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_CHAR:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 0;\n\t\t\tif (flags & REG_ICASE)\n\t\t\t\tc = canon(c);\n\t\t\tif (c != pc->c)\n\t\t\t\treturn 0;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_CCLASS:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 0;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif (!incclass(pc->cc, c))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_NCCLASS:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 0;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif (incclass(pc->cc, c))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_REF:\n\t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t\tsp += i;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\n\t\tcase I_BOL:\n\t\t\tif (sp == bol && !(flags & REG_NOTBOL)) {\n\t\t\t\tpc = pc + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & REG_NEWLINE) {\n\t\t\t\tif (sp > bol && isnewline(sp[-1])) {\n\t\t\t\t\tpc = pc + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase I_EOL:\n\t\t\tif (*sp == 0) {\n\t\t\t\tpc = pc + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & REG_NEWLINE) {\n\t\t\t\tif (isnewline(*sp)) {\n\t\t\t\t\tpc = pc + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase I_WORD:\n\t\t\ti = sp > bol && iswordchar(sp[-1]);\n\t\t\ti ^= iswordchar(sp[0]);\n\t\t\tif (!i)\n\t\t\t\treturn 0;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_NWORD:\n\t\t\ti = sp > bol && iswordchar(sp[-1]);\n\t\t\ti ^= iswordchar(sp[0]);\n\t\t\tif (i)\n\t\t\t\treturn 0;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\n\t\tcase I_LPAR:\n\t\t\tout->sub[pc->n].sp = sp;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_RPAR:\n\t\t\tout->sub[pc->n].ep = sp;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nint regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\n\tif (!sub)\n\t\tsub = &scratch;\n\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}\n\n#ifdef TEST\nint main(int argc, char **argv)\n{\n\tconst char *error;\n\tconst char *s;\n\tReprog *p;\n\tResub m;\n\tint i;\n\n\tif (argc > 1) {\n\t\tp = regcomp(argv[1], 0, &error);\n\t\tif (!p) {\n\t\t\tfprintf(stderr, \"regcomp: %s\\n\", error);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (argc > 2) {\n\t\t\ts = argv[2];\n\t\t\tprintf(\"nsub = %d\\n\", p->nsub);\n\t\t\tif (!regexec(p, s, &m, 0)) {\n\t\t\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\t\t\tint n = m.sub[i].ep - m.sub[i].sp;\n\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\tprintf(\"match %d: s=%d e=%d n=%d '%.*s'\\n\", i, (int)(m.sub[i].sp - s), (int)(m.sub[i].ep - s), n, n, m.sub[i].sp);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"match %d: n=0 ''\\n\", i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"no match\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n"], "fixing_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n#include \"regexp.h\"\n\nvoid js_newregexp(js_State *J, const char *pattern, int flags)\n{\n\tconst char *error;\n\tjs_Object *obj;\n\tReprog *prog;\n\tint opts;\n\n\tobj = jsV_newobject(J, JS_CREGEXP, J->RegExp_prototype);\n\n\topts = 0;\n\tif (flags & JS_REGEXP_I) opts |= REG_ICASE;\n\tif (flags & JS_REGEXP_M) opts |= REG_NEWLINE;\n\n\tprog = js_regcompx(J->alloc, J->actx, pattern, opts, &error);\n\tif (!prog)\n\t\tjs_syntaxerror(J, \"regular expression: %s\", error);\n\n\tobj->u.r.prog = prog;\n\tobj->u.r.source = js_strdup(J, pattern);\n\tobj->u.r.flags = flags;\n\tobj->u.r.last = 0;\n\tjs_pushobject(J, obj);\n}\n\nvoid js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint result;\n\tint i;\n\tint opts;\n\tResub m;\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tresult = js_regexec(re->prog, text, &m, opts);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\tif (result == 0) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushnull(J);\n}\n\nstatic void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint result;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tresult = js_regexec(re->prog, text, &m, opts);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\tif (result == 0) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushboolean(J, 0);\n}\n\nstatic void jsB_new_RegExp(js_State *J)\n{\n\tjs_Regexp *old;\n\tconst char *pattern;\n\tint flags;\n\n\tif (js_isregexp(J, 1)) {\n\t\tif (js_isdefined(J, 2))\n\t\t\tjs_typeerror(J, \"cannot supply flags when creating one RegExp from another\");\n\t\told = js_toregexp(J, 1);\n\t\tpattern = old->source;\n\t\tflags = old->flags;\n\t} else if (js_isundefined(J, 1)) {\n\t\tpattern = \"(?:)\";\n\t\tflags = 0;\n\t} else {\n\t\tpattern = js_tostring(J, 1);\n\t\tflags = 0;\n\t}\n\n\tif (strlen(pattern) == 0)\n\t\tpattern = \"(?:)\";\n\n\tif (js_isdefined(J, 2)) {\n\t\tconst char *s = js_tostring(J, 2);\n\t\tint g = 0, i = 0, m = 0;\n\t\twhile (*s) {\n\t\t\tif (*s == 'g') ++g;\n\t\t\telse if (*s == 'i') ++i;\n\t\t\telse if (*s == 'm') ++m;\n\t\t\telse js_syntaxerror(J, \"invalid regular expression flag: '%c'\", *s);\n\t\t\t++s;\n\t\t}\n\t\tif (g > 1) js_syntaxerror(J, \"invalid regular expression flag: 'g'\");\n\t\tif (i > 1) js_syntaxerror(J, \"invalid regular expression flag: 'i'\");\n\t\tif (m > 1) js_syntaxerror(J, \"invalid regular expression flag: 'm'\");\n\t\tif (g) flags |= JS_REGEXP_G;\n\t\tif (i) flags |= JS_REGEXP_I;\n\t\tif (m) flags |= JS_REGEXP_M;\n\t}\n\n\tjs_newregexp(J, pattern, flags);\n}\n\nstatic void jsB_RegExp(js_State *J)\n{\n\tif (js_isregexp(J, 1))\n\t\treturn;\n\tjsB_new_RegExp(J);\n}\n\nstatic void Rp_toString(js_State *J)\n{\n\tjs_Regexp *re;\n\tchar *out;\n\n\tre = js_toregexp(J, 0);\n\n\tout = js_malloc(J, strlen(re->source) + 6); /* extra space for //gim */\n\tstrcpy(out, \"/\");\n\tstrcat(out, re->source);\n\tstrcat(out, \"/\");\n\tif (re->flags & JS_REGEXP_G) strcat(out, \"g\");\n\tif (re->flags & JS_REGEXP_I) strcat(out, \"i\");\n\tif (re->flags & JS_REGEXP_M) strcat(out, \"m\");\n\n\tif (js_try(J)) {\n\t\tjs_free(J, out);\n\t\tjs_throw(J);\n\t}\n\tjs_pop(J, 0);\n\tjs_pushstring(J, out);\n\tjs_endtry(J);\n\tjs_free(J, out);\n}\n\nstatic void Rp_exec(js_State *J)\n{\n\tjs_RegExp_prototype_exec(J, js_toregexp(J, 0), js_tostring(J, 1));\n}\n\nvoid jsB_initregexp(js_State *J)\n{\n\tjs_pushobject(J, J->RegExp_prototype);\n\t{\n\t\tjsB_propf(J, \"RegExp.prototype.toString\", Rp_toString, 0);\n\t\tjsB_propf(J, \"RegExp.prototype.test\", Rp_test, 0);\n\t\tjsB_propf(J, \"RegExp.prototype.exec\", Rp_exec, 0);\n\t}\n\tjs_newcconstructor(J, jsB_RegExp, jsB_new_RegExp, \"RegExp\", 1);\n\tjs_defglobal(J, \"RegExp\", JS_DONTENUM);\n}\n", "#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n#include \"utf.h\"\n#include \"regexp.h\"\n\nstatic int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n{\n\tint result = js_regexec(prog, string, sub, eflags);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\treturn result;\n}\n\nstatic const char *checkstring(js_State *J, int idx)\n{\n\tif (!js_iscoercible(J, idx))\n\t\tjs_typeerror(J, \"string function called on null or undefined\");\n\treturn js_tostring(J, idx);\n}\n\nint js_runeat(js_State *J, const char *s, int i)\n{\n\tRune rune = 0;\n\twhile (i-- >= 0) {\n\t\trune = *(unsigned char*)s;\n\t\tif (rune < Runeself) {\n\t\t\tif (rune == 0)\n\t\t\t\treturn 0;\n\t\t\t++s;\n\t\t} else\n\t\t\ts += chartorune(&rune, s);\n\t}\n\treturn rune;\n}\n\nconst char *js_utfidxtoptr(const char *s, int i)\n{\n\tRune rune;\n\twhile (i-- > 0) {\n\t\trune = *(unsigned char*)s;\n\t\tif (rune < Runeself) {\n\t\t\tif (rune == 0)\n\t\t\t\treturn NULL;\n\t\t\t++s;\n\t\t} else\n\t\t\ts += chartorune(&rune, s);\n\t}\n\treturn s;\n}\n\nint js_utfptrtoidx(const char *s, const char *p)\n{\n\tRune rune;\n\tint i = 0;\n\twhile (s < p) {\n\t\tif (*(unsigned char *)s < Runeself)\n\t\t\t++s;\n\t\telse\n\t\t\ts += chartorune(&rune, s);\n\t\t++i;\n\t}\n\treturn i;\n}\n\nstatic void jsB_new_String(js_State *J)\n{\n\tjs_newstring(J, js_gettop(J) > 1 ? js_tostring(J, 1) : \"\");\n}\n\nstatic void jsB_String(js_State *J)\n{\n\tjs_pushstring(J, js_gettop(J) > 1 ? js_tostring(J, 1) : \"\");\n}\n\nstatic void Sp_toString(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CSTRING) js_typeerror(J, \"not a string\");\n\tjs_pushliteral(J, self->u.s.string);\n}\n\nstatic void Sp_valueOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CSTRING) js_typeerror(J, \"not a string\");\n\tjs_pushliteral(J, self->u.s.string);\n}\n\nstatic void Sp_charAt(js_State *J)\n{\n\tchar buf[UTFmax + 1];\n\tconst char *s = checkstring(J, 0);\n\tint pos = js_tointeger(J, 1);\n\tRune rune = js_runeat(J, s, pos);\n\tif (rune > 0) {\n\t\tbuf[runetochar(buf, &rune)] = 0;\n\t\tjs_pushstring(J, buf);\n\t} else {\n\t\tjs_pushliteral(J, \"\");\n\t}\n}\n\nstatic void Sp_charCodeAt(js_State *J)\n{\n\tconst char *s = checkstring(J, 0);\n\tint pos = js_tointeger(J, 1);\n\tRune rune = js_runeat(J, s, pos);\n\tif (rune > 0)\n\t\tjs_pushnumber(J, rune);\n\telse\n\t\tjs_pushnumber(J, NAN);\n}\n\nstatic void Sp_concat(js_State *J)\n{\n\tint i, top = js_gettop(J);\n\tint n;\n\tchar * volatile out;\n\tconst char *s;\n\n\tif (top == 1)\n\t\treturn;\n\n\ts = checkstring(J, 0);\n\tn = strlen(s);\n\tout = js_malloc(J, n + 1);\n\tstrcpy(out, s);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, out);\n\t\tjs_throw(J);\n\t}\n\n\tfor (i = 1; i < top; ++i) {\n\t\ts = js_tostring(J, i);\n\t\tn += strlen(s);\n\t\tout = js_realloc(J, out, n + 1);\n\t\tstrcat(out, s);\n\t}\n\n\tjs_pushstring(J, out);\n\tjs_endtry(J);\n\tjs_free(J, out);\n}\n\nstatic void Sp_indexOf(js_State *J)\n{\n\tconst char *haystack = checkstring(J, 0);\n\tconst char *needle = js_tostring(J, 1);\n\tint pos = js_tointeger(J, 2);\n\tint len = strlen(needle);\n\tint k = 0;\n\tRune rune;\n\twhile (*haystack) {\n\t\tif (k >= pos && !strncmp(haystack, needle, len)) {\n\t\t\tjs_pushnumber(J, k);\n\t\t\treturn;\n\t\t}\n\t\thaystack += chartorune(&rune, haystack);\n\t\t++k;\n\t}\n\tjs_pushnumber(J, -1);\n}\n\nstatic void Sp_lastIndexOf(js_State *J)\n{\n\tconst char *haystack = checkstring(J, 0);\n\tconst char *needle = js_tostring(J, 1);\n\tint pos = js_isdefined(J, 2) ? js_tointeger(J, 2) : (int)strlen(haystack);\n\tint len = strlen(needle);\n\tint k = 0, last = -1;\n\tRune rune;\n\twhile (*haystack && k <= pos) {\n\t\tif (!strncmp(haystack, needle, len))\n\t\t\tlast = k;\n\t\thaystack += chartorune(&rune, haystack);\n\t\t++k;\n\t}\n\tjs_pushnumber(J, last);\n}\n\nstatic void Sp_localeCompare(js_State *J)\n{\n\tconst char *a = checkstring(J, 0);\n\tconst char *b = js_tostring(J, 1);\n\tjs_pushnumber(J, strcmp(a, b));\n}\n\nstatic void Sp_slice(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *ss, *ee;\n\tint len = utflen(str);\n\tint s = js_tointeger(J, 1);\n\tint e = js_isdefined(J, 2) ? js_tointeger(J, 2) : len;\n\n\ts = s < 0 ? s + len : s;\n\te = e < 0 ? e + len : e;\n\n\ts = s < 0 ? 0 : s > len ? len : s;\n\te = e < 0 ? 0 : e > len ? len : e;\n\n\tif (s < e) {\n\t\tss = js_utfidxtoptr(str, s);\n\t\tee = js_utfidxtoptr(ss, e - s);\n\t} else {\n\t\tss = js_utfidxtoptr(str, e);\n\t\tee = js_utfidxtoptr(ss, s - e);\n\t}\n\n\tjs_pushlstring(J, ss, ee - ss);\n}\n\nstatic void Sp_substring(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *ss, *ee;\n\tint len = utflen(str);\n\tint s = js_tointeger(J, 1);\n\tint e = js_isdefined(J, 2) ? js_tointeger(J, 2) : len;\n\n\ts = s < 0 ? 0 : s > len ? len : s;\n\te = e < 0 ? 0 : e > len ? len : e;\n\n\tif (s < e) {\n\t\tss = js_utfidxtoptr(str, s);\n\t\tee = js_utfidxtoptr(ss, e - s);\n\t} else {\n\t\tss = js_utfidxtoptr(str, e);\n\t\tee = js_utfidxtoptr(ss, s - e);\n\t}\n\n\tjs_pushlstring(J, ss, ee - ss);\n}\n\nstatic void Sp_toLowerCase(js_State *J)\n{\n\tconst char *src = checkstring(J, 0);\n\tchar *dst = js_malloc(J, UTFmax * strlen(src) + 1);\n\tconst char *s = src;\n\tchar *d = dst;\n\tRune rune;\n\twhile (*s) {\n\t\ts += chartorune(&rune, s);\n\t\trune = tolowerrune(rune);\n\t\td += runetochar(d, &rune);\n\t}\n\t*d = 0;\n\tif (js_try(J)) {\n\t\tjs_free(J, dst);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, dst);\n\tjs_endtry(J);\n\tjs_free(J, dst);\n}\n\nstatic void Sp_toUpperCase(js_State *J)\n{\n\tconst char *src = checkstring(J, 0);\n\tchar *dst = js_malloc(J, UTFmax * strlen(src) + 1);\n\tconst char *s = src;\n\tchar *d = dst;\n\tRune rune;\n\twhile (*s) {\n\t\ts += chartorune(&rune, s);\n\t\trune = toupperrune(rune);\n\t\td += runetochar(d, &rune);\n\t}\n\t*d = 0;\n\tif (js_try(J)) {\n\t\tjs_free(J, dst);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, dst);\n\tjs_endtry(J);\n\tjs_free(J, dst);\n}\n\nstatic int istrim(int c)\n{\n\treturn c == 0x9 || c == 0xB || c == 0xC || c == 0x20 || c == 0xA0 || c == 0xFEFF ||\n\t\tc == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;\n}\n\nstatic void Sp_trim(js_State *J)\n{\n\tconst char *s, *e;\n\ts = checkstring(J, 0);\n\twhile (istrim(*s))\n\t\t++s;\n\te = s + strlen(s);\n\twhile (e > s && istrim(e[-1]))\n\t\t--e;\n\tjs_pushlstring(J, s, e - s);\n}\n\nstatic void S_fromCharCode(js_State *J)\n{\n\tint i, top = js_gettop(J);\n\tRune c;\n\tchar *s, *p;\n\n\ts = p = js_malloc(J, (top-1) * UTFmax + 1);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, s);\n\t\tjs_throw(J);\n\t}\n\n\tfor (i = 1; i < top; ++i) {\n\t\tc = js_touint16(J, i);\n\t\tp += runetochar(p, &c);\n\t}\n\t*p = 0;\n\tjs_pushstring(J, s);\n\n\tjs_endtry(J);\n\tjs_free(J, s);\n}\n\nstatic void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}\n\nstatic void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\n\tif (!js_doregexec(J, re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}\n\nstatic void Sp_replace_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *source, *s, *r;\n\tjs_Buffer *sb = NULL;\n\tint n, x;\n\tResub m;\n\n\tsource = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\n\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n\t\tjs_copy(J, 0);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\nloop:\n\ts = m.sub[0].sp;\n\tn = m.sub[0].ep - m.sub[0].sp;\n\n\tif (js_iscallable(J, 2)) {\n\t\tjs_copy(J, 2);\n\t\tjs_pushundefined(J);\n\t\tfor (x = 0; m.sub[x].sp; ++x) /* arg 0..x: substring and subexps that matched */\n\t\t\tjs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);\n\t\tjs_pushnumber(J, s - source); /* arg x+2: offset within search string */\n\t\tjs_copy(J, 0); /* arg x+3: search string */\n\t\tjs_call(J, 2 + x);\n\t\tr = js_tostring(J, -1);\n\t\tjs_putm(J, &sb, source, s);\n\t\tjs_puts(J, &sb, r);\n\t\tjs_pop(J, 1);\n\t} else {\n\t\tr = js_tostring(J, 2);\n\t\tjs_putm(J, &sb, source, s);\n\t\twhile (*r) {\n\t\t\tif (*r == '$') {\n\t\t\t\tswitch (*(++r)) {\n\t\t\t\tcase 0: --r; /* end of string; back up */\n\t\t\t\t/* fallthrough */\n\t\t\t\tcase '$': js_putc(J, &sb, '$'); break;\n\t\t\t\tcase '`': js_putm(J, &sb, source, s); break;\n\t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;\n\t\t\t\tcase '&':\n\t\t\t\t\tjs_putm(J, &sb, s, s + n);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\t\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t\t\t\tx = *r - '0';\n\t\t\t\t\tif (r[1] >= '0' && r[1] <= '9')\n\t\t\t\t\t\tx = x * 10 + *(++r) - '0';\n\t\t\t\t\tif (x > 0 && x < m.nsub) {\n\t\t\t\t\t\tjs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjs_putc(J, &sb, '$');\n\t\t\t\t\t\tif (x > 10) {\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x / 10);\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x % 10);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tjs_putc(J, &sb, '$');\n\t\t\t\t\tjs_putc(J, &sb, *r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++r;\n\t\t\t} else {\n\t\t\t\tjs_putc(J, &sb, *r++);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re->flags & JS_REGEXP_G) {\n\t\tsource = m.sub[0].ep;\n\t\tif (n == 0) {\n\t\t\tif (*source)\n\t\t\t\tjs_putc(J, &sb, *source++);\n\t\t\telse\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n\t\t\tgoto loop;\n\t}\n\nend:\n\tjs_puts(J, &sb, s + n);\n\tjs_putc(J, &sb, 0);\n\n\tif (js_try(J)) {\n\t\tjs_free(J, sb);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, sb ? sb->s : \"\");\n\tjs_endtry(J);\n\tjs_free(J, sb);\n}\n\nstatic void Sp_replace_string(js_State *J)\n{\n\tconst char *source, *needle, *s, *r;\n\tjs_Buffer *sb = NULL;\n\tint n;\n\n\tsource = checkstring(J, 0);\n\tneedle = js_tostring(J, 1);\n\n\ts = strstr(source, needle);\n\tif (!s) {\n\t\tjs_copy(J, 0);\n\t\treturn;\n\t}\n\tn = strlen(needle);\n\n\tif (js_iscallable(J, 2)) {\n\t\tjs_copy(J, 2);\n\t\tjs_pushundefined(J);\n\t\tjs_pushlstring(J, s, n); /* arg 1: substring that matched */\n\t\tjs_pushnumber(J, s - source); /* arg 2: offset within search string */\n\t\tjs_copy(J, 0); /* arg 3: search string */\n\t\tjs_call(J, 3);\n\t\tr = js_tostring(J, -1);\n\t\tjs_putm(J, &sb, source, s);\n\t\tjs_puts(J, &sb, r);\n\t\tjs_puts(J, &sb, s + n);\n\t\tjs_putc(J, &sb, 0);\n\t\tjs_pop(J, 1);\n\t} else {\n\t\tr = js_tostring(J, 2);\n\t\tjs_putm(J, &sb, source, s);\n\t\twhile (*r) {\n\t\t\tif (*r == '$') {\n\t\t\t\tswitch (*(++r)) {\n\t\t\t\tcase 0: --r; /* end of string; back up */\n\t\t\t\t/* fallthrough */\n\t\t\t\tcase '$': js_putc(J, &sb, '$'); break;\n\t\t\t\tcase '&': js_putm(J, &sb, s, s + n); break;\n\t\t\t\tcase '`': js_putm(J, &sb, source, s); break;\n\t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;\n\t\t\t\tdefault: js_putc(J, &sb, '$'); js_putc(J, &sb, *r); break;\n\t\t\t\t}\n\t\t\t\t++r;\n\t\t\t} else {\n\t\t\t\tjs_putc(J, &sb, *r++);\n\t\t\t}\n\t\t}\n\t\tjs_puts(J, &sb, s + n);\n\t\tjs_putc(J, &sb, 0);\n\t}\n\n\tif (js_try(J)) {\n\t\tjs_free(J, sb);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, sb ? sb->s : \"\");\n\tjs_endtry(J);\n\tjs_free(J, sb);\n}\n\nstatic void Sp_replace(js_State *J)\n{\n\tif (js_isregexp(J, 1))\n\t\tSp_replace_regexp(J);\n\telse\n\t\tSp_replace_string(J);\n}\n\nstatic void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\n\tjs_newarray(J);\n\tlen = 0;\n\n\te = text + strlen(text);\n\n\t/* splitting the empty string */\n\tif (e == text) {\n\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; /* no match */\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\t/* empty string at end of last match */\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\n\t\ta = p = c;\n\t}\n\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}\n\nstatic void Sp_split_string(js_State *J)\n{\n\tconst char *str = checkstring(J, 0);\n\tconst char *sep = js_tostring(J, 1);\n\tint limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tint i, n;\n\n\tjs_newarray(J);\n\n\tn = strlen(sep);\n\n\t/* empty string */\n\tif (n == 0) {\n\t\tRune rune;\n\t\tfor (i = 0; *str && i < limit; ++i) {\n\t\t\tn = chartorune(&rune, str);\n\t\t\tjs_pushlstring(J, str, n);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr += n;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; str && i < limit; ++i) {\n\t\tconst char *s = strstr(str, sep);\n\t\tif (s) {\n\t\t\tjs_pushlstring(J, str, s-str);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr = s + n;\n\t\t} else {\n\t\t\tjs_pushstring(J, str);\n\t\t\tjs_setindex(J, -2, i);\n\t\t\tstr = NULL;\n\t\t}\n\t}\n}\n\nstatic void Sp_split(js_State *J)\n{\n\tif (js_isundefined(J, 1)) {\n\t\tjs_newarray(J);\n\t\tjs_copy(J, 0);\n\t\tjs_setindex(J, -2, 0);\n\t} else if (js_isregexp(J, 1)) {\n\t\tSp_split_regexp(J);\n\t} else {\n\t\tSp_split_string(J);\n\t}\n}\n\nvoid jsB_initstring(js_State *J)\n{\n\tJ->String_prototype->u.s.string = \"\";\n\tJ->String_prototype->u.s.length = 0;\n\n\tjs_pushobject(J, J->String_prototype);\n\t{\n\t\tjsB_propf(J, \"String.prototype.toString\", Sp_toString, 0);\n\t\tjsB_propf(J, \"String.prototype.valueOf\", Sp_valueOf, 0);\n\t\tjsB_propf(J, \"String.prototype.charAt\", Sp_charAt, 1);\n\t\tjsB_propf(J, \"String.prototype.charCodeAt\", Sp_charCodeAt, 1);\n\t\tjsB_propf(J, \"String.prototype.concat\", Sp_concat, 0); /* 1 */\n\t\tjsB_propf(J, \"String.prototype.indexOf\", Sp_indexOf, 1);\n\t\tjsB_propf(J, \"String.prototype.lastIndexOf\", Sp_lastIndexOf, 1);\n\t\tjsB_propf(J, \"String.prototype.localeCompare\", Sp_localeCompare, 1);\n\t\tjsB_propf(J, \"String.prototype.match\", Sp_match, 1);\n\t\tjsB_propf(J, \"String.prototype.replace\", Sp_replace, 2);\n\t\tjsB_propf(J, \"String.prototype.search\", Sp_search, 1);\n\t\tjsB_propf(J, \"String.prototype.slice\", Sp_slice, 2);\n\t\tjsB_propf(J, \"String.prototype.split\", Sp_split, 2);\n\t\tjsB_propf(J, \"String.prototype.substring\", Sp_substring, 2);\n\t\tjsB_propf(J, \"String.prototype.toLowerCase\", Sp_toLowerCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toLocaleLowerCase\", Sp_toLowerCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toUpperCase\", Sp_toUpperCase, 0);\n\t\tjsB_propf(J, \"String.prototype.toLocaleUpperCase\", Sp_toUpperCase, 0);\n\n\t\t/* ES5 */\n\t\tjsB_propf(J, \"String.prototype.trim\", Sp_trim, 0);\n\t}\n\tjs_newcconstructor(J, jsB_String, jsB_new_String, \"String\", 0); /* 1 */\n\t{\n\t\tjsB_propf(J, \"String.fromCharCode\", S_fromCharCode, 0); /* 1 */\n\t}\n\tjs_defglobal(J, \"String\", JS_DONTENUM);\n}\n", "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n#include <limits.h>\n\n#include \"regexp.h\"\n#include \"utf.h\"\n\n#define emit regemit\n#define next regnext\n#define accept regaccept\n\n#define nelem(a) (int)(sizeof (a) / sizeof (a)[0])\n\n#define REPINF 255\n#define MAXSUB REG_MAXSUB\n#define MAXPROG (32 << 10)\n#define MAXREC 1024\n\ntypedef struct Reclass Reclass;\ntypedef struct Renode Renode;\ntypedef struct Reinst Reinst;\ntypedef struct Rethread Rethread;\n\nstruct Reclass {\n\tRune *end;\n\tRune spans[64];\n};\n\nstruct Reprog {\n\tReinst *start, *end;\n\tint flags;\n\tint nsub;\n\tReclass cclass[16];\n};\n\nstruct cstate {\n\tReprog *prog;\n\tRenode *pstart, *pend;\n\n\tconst char *source;\n\tint ncclass;\n\tint nsub;\n\tRenode *sub[MAXSUB];\n\n\tint lookahead;\n\tRune yychar;\n\tReclass *yycc;\n\tint yymin, yymax;\n\n\tconst char *error;\n\tjmp_buf kaboom;\n};\n\nstatic void die(struct cstate *g, const char *message)\n{\n\tg->error = message;\n\tlongjmp(g->kaboom, 1);\n}\n\nstatic int canon(Rune c)\n{\n\tRune u = toupperrune(c);\n\tif (c >= 128 && u < 128)\n\t\treturn c;\n\treturn u;\n}\n\n/* Scan */\n\nenum {\n\tL_CHAR = 256,\n\tL_CCLASS,\t/* character class */\n\tL_NCCLASS,\t/* negative character class */\n\tL_NC,\t\t/* \"(?:\" no capture */\n\tL_PLA,\t\t/* \"(?=\" positive lookahead */\n\tL_NLA,\t\t/* \"(?!\" negative lookahead */\n\tL_WORD,\t\t/* \"\\b\" word boundary */\n\tL_NWORD,\t/* \"\\B\" non-word boundary */\n\tL_REF,\t\t/* \"\\1\" back-reference */\n\tL_COUNT,\t/* {M,N} */\n};\n\nstatic int hex(struct cstate *g, int c)\n{\n\tif (c >= '0' && c <= '9') return c - '0';\n\tif (c >= 'a' && c <= 'f') return c - 'a' + 0xA;\n\tif (c >= 'A' && c <= 'F') return c - 'A' + 0xA;\n\tdie(g, \"invalid escape sequence\");\n\treturn 0;\n}\n\nstatic int dec(struct cstate *g, int c)\n{\n\tif (c >= '0' && c <= '9') return c - '0';\n\tdie(g, \"invalid quantifier\");\n\treturn 0;\n}\n\n#define ESCAPES \"BbDdSsWw^$\\\\.*+?()[]{}|0123456789\"\n\nstatic int isunicodeletter(int c)\n{\n\treturn (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || isalpharune(c);\n}\n\nstatic int nextrune(struct cstate *g)\n{\n\tg->source += chartorune(&g->yychar, g->source);\n\tif (g->yychar == '\\\\') {\n\t\tg->source += chartorune(&g->yychar, g->source);\n\t\tswitch (g->yychar) {\n\t\tcase 0: die(g, \"unterminated escape sequence\"); break;\n\t\tcase 'f': g->yychar = '\\f'; return 0;\n\t\tcase 'n': g->yychar = '\\n'; return 0;\n\t\tcase 'r': g->yychar = '\\r'; return 0;\n\t\tcase 't': g->yychar = '\\t'; return 0;\n\t\tcase 'v': g->yychar = '\\v'; return 0;\n\t\tcase 'c':\n\t\t\tg->yychar = (*g->source++) & 31;\n\t\t\treturn 0;\n\t\tcase 'x':\n\t\t\tg->yychar = hex(g, *g->source++) << 4;\n\t\t\tg->yychar += hex(g, *g->source++);\n\t\t\tif (g->yychar == 0) {\n\t\t\t\tg->yychar = '0';\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'u':\n\t\t\tg->yychar = hex(g, *g->source++) << 12;\n\t\t\tg->yychar += hex(g, *g->source++) << 8;\n\t\t\tg->yychar += hex(g, *g->source++) << 4;\n\t\t\tg->yychar += hex(g, *g->source++);\n\t\t\tif (g->yychar == 0) {\n\t\t\t\tg->yychar = '0';\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (strchr(ESCAPES, g->yychar))\n\t\t\treturn 1;\n\t\tif (isunicodeletter(g->yychar) || g->yychar == '_') /* check identity escape */\n\t\t\tdie(g, \"invalid escape character\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int lexcount(struct cstate *g)\n{\n\tg->yychar = *g->source++;\n\n\tg->yymin = dec(g, g->yychar);\n\tg->yychar = *g->source++;\n\twhile (g->yychar != ',' && g->yychar != '}') {\n\t\tg->yymin = g->yymin * 10 + dec(g, g->yychar);\n\t\tg->yychar = *g->source++;\n\t\tif (g->yymin >= REPINF)\n\t\t\tdie(g, \"numeric overflow\");\n\t}\n\n\tif (g->yychar == ',') {\n\t\tg->yychar = *g->source++;\n\t\tif (g->yychar == '}') {\n\t\t\tg->yymax = REPINF;\n\t\t} else {\n\t\t\tg->yymax = dec(g, g->yychar);\n\t\t\tg->yychar = *g->source++;\n\t\t\twhile (g->yychar != '}') {\n\t\t\t\tg->yymax = g->yymax * 10 + dec(g, g->yychar);\n\t\t\t\tg->yychar = *g->source++;\n\t\t\t\tif (g->yymax >= REPINF)\n\t\t\t\t\tdie(g, \"numeric overflow\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tg->yymax = g->yymin;\n\t}\n\n\treturn L_COUNT;\n}\n\nstatic void newcclass(struct cstate *g)\n{\n\tif (g->ncclass >= nelem(g->prog->cclass))\n\t\tdie(g, \"too many character classes\");\n\tg->yycc = g->prog->cclass + g->ncclass++;\n\tg->yycc->end = g->yycc->spans;\n}\n\nstatic void addrange(struct cstate *g, Rune a, Rune b)\n{\n\tif (a > b)\n\t\tdie(g, \"invalid character class range\");\n\tif (g->yycc->end + 2 == g->yycc->spans + nelem(g->yycc->spans))\n\t\tdie(g, \"too many character class ranges\");\n\t*g->yycc->end++ = a;\n\t*g->yycc->end++ = b;\n}\n\nstatic void addranges_d(struct cstate *g)\n{\n\taddrange(g, '0', '9');\n}\n\nstatic void addranges_D(struct cstate *g)\n{\n\taddrange(g, 0, '0'-1);\n\taddrange(g, '9'+1, 0xFFFF);\n}\n\nstatic void addranges_s(struct cstate *g)\n{\n\taddrange(g, 0x9, 0xD);\n\taddrange(g, 0x20, 0x20);\n\taddrange(g, 0xA0, 0xA0);\n\taddrange(g, 0x2028, 0x2029);\n\taddrange(g, 0xFEFF, 0xFEFF);\n}\n\nstatic void addranges_S(struct cstate *g)\n{\n\taddrange(g, 0, 0x9-1);\n\taddrange(g, 0xD+1, 0x20-1);\n\taddrange(g, 0x20+1, 0xA0-1);\n\taddrange(g, 0xA0+1, 0x2028-1);\n\taddrange(g, 0x2029+1, 0xFEFF-1);\n\taddrange(g, 0xFEFF+1, 0xFFFF);\n}\n\nstatic void addranges_w(struct cstate *g)\n{\n\taddrange(g, '0', '9');\n\taddrange(g, 'A', 'Z');\n\taddrange(g, '_', '_');\n\taddrange(g, 'a', 'z');\n}\n\nstatic void addranges_W(struct cstate *g)\n{\n\taddrange(g, 0, '0'-1);\n\taddrange(g, '9'+1, 'A'-1);\n\taddrange(g, 'Z'+1, '_'-1);\n\taddrange(g, '_'+1, 'a'-1);\n\taddrange(g, 'z'+1, 0xFFFF);\n}\n\nstatic int lexclass(struct cstate *g)\n{\n\tint type = L_CCLASS;\n\tint quoted, havesave, havedash;\n\tRune save = 0;\n\n\tnewcclass(g);\n\n\tquoted = nextrune(g);\n\tif (!quoted && g->yychar == '^') {\n\t\ttype = L_NCCLASS;\n\t\tquoted = nextrune(g);\n\t}\n\n\thavesave = havedash = 0;\n\tfor (;;) {\n\t\tif (g->yychar == 0)\n\t\t\tdie(g, \"unterminated character class\");\n\t\tif (!quoted && g->yychar == ']')\n\t\t\tbreak;\n\n\t\tif (!quoted && g->yychar == '-') {\n\t\t\tif (havesave) {\n\t\t\t\tif (havedash) {\n\t\t\t\t\taddrange(g, save, '-');\n\t\t\t\t\thavesave = havedash = 0;\n\t\t\t\t} else {\n\t\t\t\t\thavedash = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsave = '-';\n\t\t\t\thavesave = 1;\n\t\t\t}\n\t\t} else if (quoted && strchr(\"DSWdsw\", g->yychar)) {\n\t\t\tif (havesave) {\n\t\t\t\taddrange(g, save, save);\n\t\t\t\tif (havedash)\n\t\t\t\t\taddrange(g, '-', '-');\n\t\t\t}\n\t\t\tswitch (g->yychar) {\n\t\t\tcase 'd': addranges_d(g); break;\n\t\t\tcase 's': addranges_s(g); break;\n\t\t\tcase 'w': addranges_w(g); break;\n\t\t\tcase 'D': addranges_D(g); break;\n\t\t\tcase 'S': addranges_S(g); break;\n\t\t\tcase 'W': addranges_W(g); break;\n\t\t\t}\n\t\t\thavesave = havedash = 0;\n\t\t} else {\n\t\t\tif (quoted) {\n\t\t\t\tif (g->yychar == 'b')\n\t\t\t\t\tg->yychar = '\\b';\n\t\t\t\telse if (g->yychar == '0')\n\t\t\t\t\tg->yychar = 0;\n\t\t\t\t/* else identity escape */\n\t\t\t}\n\t\t\tif (havesave) {\n\t\t\t\tif (havedash) {\n\t\t\t\t\taddrange(g, save, g->yychar);\n\t\t\t\t\thavesave = havedash = 0;\n\t\t\t\t} else {\n\t\t\t\t\taddrange(g, save, save);\n\t\t\t\t\tsave = g->yychar;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsave = g->yychar;\n\t\t\t\thavesave = 1;\n\t\t\t}\n\t\t}\n\n\t\tquoted = nextrune(g);\n\t}\n\n\tif (havesave) {\n\t\taddrange(g, save, save);\n\t\tif (havedash)\n\t\t\taddrange(g, '-', '-');\n\t}\n\n\treturn type;\n}\n\nstatic int lex(struct cstate *g)\n{\n\tint quoted = nextrune(g);\n\tif (quoted) {\n\t\tswitch (g->yychar) {\n\t\tcase 'b': return L_WORD;\n\t\tcase 'B': return L_NWORD;\n\t\tcase 'd': newcclass(g); addranges_d(g); return L_CCLASS;\n\t\tcase 's': newcclass(g); addranges_s(g); return L_CCLASS;\n\t\tcase 'w': newcclass(g); addranges_w(g); return L_CCLASS;\n\t\tcase 'D': newcclass(g); addranges_d(g); return L_NCCLASS;\n\t\tcase 'S': newcclass(g); addranges_s(g); return L_NCCLASS;\n\t\tcase 'W': newcclass(g); addranges_w(g); return L_NCCLASS;\n\t\tcase '0': g->yychar = 0; return L_CHAR;\n\t\t}\n\t\tif (g->yychar >= '0' && g->yychar <= '9') {\n\t\t\tg->yychar -= '0';\n\t\t\tif (*g->source >= '0' && *g->source <= '9')\n\t\t\t\tg->yychar = g->yychar * 10 + *g->source++ - '0';\n\t\t\treturn L_REF;\n\t\t}\n\t\treturn L_CHAR;\n\t}\n\n\tswitch (g->yychar) {\n\tcase 0:\n\tcase '$': case ')': case '*': case '+':\n\tcase '.': case '?': case '^': case '|':\n\t\treturn g->yychar;\n\t}\n\n\tif (g->yychar == '{')\n\t\treturn lexcount(g);\n\tif (g->yychar == '[')\n\t\treturn lexclass(g);\n\tif (g->yychar == '(') {\n\t\tif (g->source[0] == '?') {\n\t\t\tif (g->source[1] == ':') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NC;\n\t\t\t}\n\t\t\tif (g->source[1] == '=') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_PLA;\n\t\t\t}\n\t\t\tif (g->source[1] == '!') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NLA;\n\t\t\t}\n\t\t}\n\t\treturn '(';\n\t}\n\n\treturn L_CHAR;\n}\n\n/* Parse */\n\nenum {\n\tP_CAT, P_ALT, P_REP,\n\tP_BOL, P_EOL, P_WORD, P_NWORD,\n\tP_PAR, P_PLA, P_NLA,\n\tP_ANY, P_CHAR, P_CCLASS, P_NCCLASS,\n\tP_REF,\n};\n\nstruct Renode {\n\tunsigned char type;\n\tunsigned char ng, m, n;\n\tRune c;\n\tReclass *cc;\n\tRenode *x;\n\tRenode *y;\n};\n\nstatic Renode *newnode(struct cstate *g, int type)\n{\n\tRenode *node = g->pend++;\n\tnode->type = type;\n\tnode->cc = NULL;\n\tnode->c = 0;\n\tnode->ng = 0;\n\tnode->m = 0;\n\tnode->n = 0;\n\tnode->x = node->y = NULL;\n\treturn node;\n}\n\nstatic int empty(Renode *node)\n{\n\tif (!node) return 1;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return empty(node->x) && empty(node->y);\n\tcase P_ALT: return empty(node->x) || empty(node->y);\n\tcase P_REP: return empty(node->x) || node->m == 0;\n\tcase P_PAR: return empty(node->x);\n\tcase P_REF: return empty(node->x);\n\tcase P_ANY: case P_CHAR: case P_CCLASS: case P_NCCLASS: return 0;\n\t}\n}\n\nstatic Renode *newrep(struct cstate *g, Renode *atom, int ng, int min, int max)\n{\n\tRenode *rep = newnode(g, P_REP);\n\tif (max == REPINF && empty(atom))\n\t\tdie(g, \"infinite loop matching the empty string\");\n\trep->ng = ng;\n\trep->m = min;\n\trep->n = max;\n\trep->x = atom;\n\treturn rep;\n}\n\nstatic void next(struct cstate *g)\n{\n\tg->lookahead = lex(g);\n}\n\nstatic int accept(struct cstate *g, int t)\n{\n\tif (g->lookahead == t) {\n\t\tnext(g);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Renode *parsealt(struct cstate *g);\n\nstatic Renode *parseatom(struct cstate *g)\n{\n\tRenode *atom;\n\tif (g->lookahead == L_CHAR) {\n\t\tatom = newnode(g, P_CHAR);\n\t\tatom->c = g->yychar;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_CCLASS) {\n\t\tatom = newnode(g, P_CCLASS);\n\t\tatom->cc = g->yycc;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_NCCLASS) {\n\t\tatom = newnode(g, P_NCCLASS);\n\t\tatom->cc = g->yycc;\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (g->lookahead == L_REF) {\n\t\tatom = newnode(g, P_REF);\n\t\tif (g->yychar == 0 || g->yychar >= g->nsub || !g->sub[g->yychar])\n\t\t\tdie(g, \"invalid back-reference\");\n\t\tatom->n = g->yychar;\n\t\tatom->x = g->sub[g->yychar];\n\t\tnext(g);\n\t\treturn atom;\n\t}\n\tif (accept(g, '.'))\n\t\treturn newnode(g, P_ANY);\n\tif (accept(g, '(')) {\n\t\tatom = newnode(g, P_PAR);\n\t\tif (g->nsub == MAXSUB)\n\t\t\tdie(g, \"too many captures\");\n\t\tatom->n = g->nsub++;\n\t\tatom->x = parsealt(g);\n\t\tg->sub[atom->n] = atom;\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_NC)) {\n\t\tatom = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_PLA)) {\n\t\tatom = newnode(g, P_PLA);\n\t\tatom->x = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tif (accept(g, L_NLA)) {\n\t\tatom = newnode(g, P_NLA);\n\t\tatom->x = parsealt(g);\n\t\tif (!accept(g, ')'))\n\t\t\tdie(g, \"unmatched '('\");\n\t\treturn atom;\n\t}\n\tdie(g, \"syntax error\");\n\treturn NULL;\n}\n\nstatic Renode *parserep(struct cstate *g)\n{\n\tRenode *atom;\n\n\tif (accept(g, '^')) return newnode(g, P_BOL);\n\tif (accept(g, '$')) return newnode(g, P_EOL);\n\tif (accept(g, L_WORD)) return newnode(g, P_WORD);\n\tif (accept(g, L_NWORD)) return newnode(g, P_NWORD);\n\n\tatom = parseatom(g);\n\tif (g->lookahead == L_COUNT) {\n\t\tint min = g->yymin, max = g->yymax;\n\t\tnext(g);\n\t\tif (max < min)\n\t\t\tdie(g, \"invalid quantifier\");\n\t\treturn newrep(g, atom, accept(g, '?'), min, max);\n\t}\n\tif (accept(g, '*')) return newrep(g, atom, accept(g, '?'), 0, REPINF);\n\tif (accept(g, '+')) return newrep(g, atom, accept(g, '?'), 1, REPINF);\n\tif (accept(g, '?')) return newrep(g, atom, accept(g, '?'), 0, 1);\n\treturn atom;\n}\n\nstatic Renode *parsecat(struct cstate *g)\n{\n\tRenode *cat, *head, **tail;\n\tif (g->lookahead && g->lookahead != '|' && g->lookahead != ')') {\n\t\t/* Build a right-leaning tree by splicing in new 'cat' at the tail. */\n\t\thead = parserep(g);\n\t\ttail = &head;\n\t\twhile (g->lookahead && g->lookahead != '|' && g->lookahead != ')') {\n\t\t\tcat = newnode(g, P_CAT);\n\t\t\tcat->x = *tail;\n\t\t\tcat->y = parserep(g);\n\t\t\t*tail = cat;\n\t\t\ttail = &cat->y;\n\t\t}\n\t\treturn head;\n\t}\n\treturn NULL;\n}\n\nstatic Renode *parsealt(struct cstate *g)\n{\n\tRenode *alt, *x;\n\talt = parsecat(g);\n\twhile (accept(g, '|')) {\n\t\tx = alt;\n\t\talt = newnode(g, P_ALT);\n\t\talt->x = x;\n\t\talt->y = parsecat(g);\n\t}\n\treturn alt;\n}\n\n/* Compile */\n\nenum {\n\tI_END, I_JUMP, I_SPLIT, I_PLA, I_NLA,\n\tI_ANYNL, I_ANY, I_CHAR, I_CCLASS, I_NCCLASS, I_REF,\n\tI_BOL, I_EOL, I_WORD, I_NWORD,\n\tI_LPAR, I_RPAR\n};\n\nstruct Reinst {\n\tunsigned char opcode;\n\tunsigned char n;\n\tRune c;\n\tReclass *cc;\n\tReinst *x;\n\tReinst *y;\n};\n\nstatic int count(struct cstate *g, Renode *node)\n{\n\tint min, max, n;\n\tif (!node) return 0;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return count(g, node->x) + count(g, node->y);\n\tcase P_ALT: return count(g, node->x) + count(g, node->y) + 2;\n\tcase P_REP:\n\t\tmin = node->m;\n\t\tmax = node->n;\n\t\tif (min == max) n = count(g, node->x) * min;\n\t\telse if (max < REPINF) n = count(g, node->x) * max + (max - min);\n\t\telse n = count(g, node->x) * (min + 1) + 2;\n\t\tif (n < 0 || n > MAXPROG) die(g, \"program too large\");\n\t\treturn n;\n\tcase P_PAR: return count(g, node->x) + 2;\n\tcase P_PLA: return count(g, node->x) + 2;\n\tcase P_NLA: return count(g, node->x) + 2;\n\t}\n}\n\nstatic Reinst *emit(Reprog *prog, int opcode)\n{\n\tReinst *inst = prog->end++;\n\tinst->opcode = opcode;\n\tinst->n = 0;\n\tinst->c = 0;\n\tinst->cc = NULL;\n\tinst->x = inst->y = NULL;\n\treturn inst;\n}\n\nstatic void compile(Reprog *prog, Renode *node)\n{\n\tReinst *inst, *split, *jump;\n\tint i;\n\n\tif (!node)\n\t\treturn;\n\nloop:\n\tswitch (node->type) {\n\tcase P_CAT:\n\t\tcompile(prog, node->x);\n\t\tnode = node->y;\n\t\tgoto loop;\n\n\tcase P_ALT:\n\t\tsplit = emit(prog, I_SPLIT);\n\t\tcompile(prog, node->x);\n\t\tjump = emit(prog, I_JUMP);\n\t\tcompile(prog, node->y);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = jump + 1;\n\t\tjump->x = prog->end;\n\t\tbreak;\n\n\tcase P_REP:\n\t\tinst = NULL; /* silence compiler warning. assert(node->m > 0). */\n\t\tfor (i = 0; i < node->m; ++i) {\n\t\t\tinst = prog->end;\n\t\t\tcompile(prog, node->x);\n\t\t}\n\t\tif (node->m == node->n)\n\t\t\tbreak;\n\t\tif (node->n < REPINF) {\n\t\t\tfor (i = node->m; i < node->n; ++i) {\n\t\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\t\tcompile(prog, node->x);\n\t\t\t\tif (node->ng) {\n\t\t\t\t\tsplit->y = split + 1;\n\t\t\t\t\tsplit->x = prog->end;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->x = split + 1;\n\t\t\t\t\tsplit->y = prog->end;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node->m == 0) {\n\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\tcompile(prog, node->x);\n\t\t\tjump = emit(prog, I_JUMP);\n\t\t\tif (node->ng) {\n\t\t\t\tsplit->y = split + 1;\n\t\t\t\tsplit->x = prog->end;\n\t\t\t} else {\n\t\t\t\tsplit->x = split + 1;\n\t\t\t\tsplit->y = prog->end;\n\t\t\t}\n\t\t\tjump->x = split;\n\t\t} else {\n\t\t\tsplit = emit(prog, I_SPLIT);\n\t\t\tif (node->ng) {\n\t\t\t\tsplit->y = inst;\n\t\t\t\tsplit->x = prog->end;\n\t\t\t} else {\n\t\t\t\tsplit->x = inst;\n\t\t\t\tsplit->y = prog->end;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase P_BOL: emit(prog, I_BOL); break;\n\tcase P_EOL: emit(prog, I_EOL); break;\n\tcase P_WORD: emit(prog, I_WORD); break;\n\tcase P_NWORD: emit(prog, I_NWORD); break;\n\n\tcase P_PAR:\n\t\tinst = emit(prog, I_LPAR);\n\t\tinst->n = node->n;\n\t\tcompile(prog, node->x);\n\t\tinst = emit(prog, I_RPAR);\n\t\tinst->n = node->n;\n\t\tbreak;\n\tcase P_PLA:\n\t\tsplit = emit(prog, I_PLA);\n\t\tcompile(prog, node->x);\n\t\temit(prog, I_END);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = prog->end;\n\t\tbreak;\n\tcase P_NLA:\n\t\tsplit = emit(prog, I_NLA);\n\t\tcompile(prog, node->x);\n\t\temit(prog, I_END);\n\t\tsplit->x = split + 1;\n\t\tsplit->y = prog->end;\n\t\tbreak;\n\n\tcase P_ANY:\n\t\temit(prog, I_ANY);\n\t\tbreak;\n\tcase P_CHAR:\n\t\tinst = emit(prog, I_CHAR);\n\t\tinst->c = (prog->flags & REG_ICASE) ? canon(node->c) : node->c;\n\t\tbreak;\n\tcase P_CCLASS:\n\t\tinst = emit(prog, I_CCLASS);\n\t\tinst->cc = node->cc;\n\t\tbreak;\n\tcase P_NCCLASS:\n\t\tinst = emit(prog, I_NCCLASS);\n\t\tinst->cc = node->cc;\n\t\tbreak;\n\tcase P_REF:\n\t\tinst = emit(prog, I_REF);\n\t\tinst->n = node->n;\n\t\tbreak;\n\t}\n}\n\n#ifdef TEST\nstatic void dumpnode(Renode *node)\n{\n\tRune *p;\n\tif (!node) { printf(\"Empty\"); return; }\n\tswitch (node->type) {\n\tcase P_CAT: printf(\"Cat(\"); dumpnode(node->x); printf(\", \"); dumpnode(node->y); printf(\")\"); break;\n\tcase P_ALT: printf(\"Alt(\"); dumpnode(node->x); printf(\", \"); dumpnode(node->y); printf(\")\"); break;\n\tcase P_REP:\n\t\tprintf(node->ng ? \"NgRep(%d,%d,\" : \"Rep(%d,%d,\", node->m, node->n);\n\t\tdumpnode(node->x);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_BOL: printf(\"Bol\"); break;\n\tcase P_EOL: printf(\"Eol\"); break;\n\tcase P_WORD: printf(\"Word\"); break;\n\tcase P_NWORD: printf(\"NotWord\"); break;\n\tcase P_PAR: printf(\"Par(%d,\", node->n); dumpnode(node->x); printf(\")\"); break;\n\tcase P_PLA: printf(\"PLA(\"); dumpnode(node->x); printf(\")\"); break;\n\tcase P_NLA: printf(\"NLA(\"); dumpnode(node->x); printf(\")\"); break;\n\tcase P_ANY: printf(\"Any\"); break;\n\tcase P_CHAR: printf(\"Char(%c)\", node->c); break;\n\tcase P_CCLASS:\n\t\tprintf(\"Class(\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"%02X-%02X,\", p[0], p[1]);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_NCCLASS:\n\t\tprintf(\"NotClass(\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"%02X-%02X,\", p[0], p[1]);\n\t\tprintf(\")\");\n\t\tbreak;\n\tcase P_REF: printf(\"Ref(%d)\", node->n); break;\n\t}\n}\n\nstatic void dumpprog(Reprog *prog)\n{\n\tReinst *inst;\n\tint i;\n\tfor (i = 0, inst = prog->start; inst < prog->end; ++i, ++inst) {\n\t\tprintf(\"% 5d: \", i);\n\t\tswitch (inst->opcode) {\n\t\tcase I_END: puts(\"end\"); break;\n\t\tcase I_JUMP: printf(\"jump %d\\n\", (int)(inst->x - prog->start)); break;\n\t\tcase I_SPLIT: printf(\"split %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_PLA: printf(\"pla %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_NLA: printf(\"nla %d %d\\n\", (int)(inst->x - prog->start), (int)(inst->y - prog->start)); break;\n\t\tcase I_ANY: puts(\"any\"); break;\n\t\tcase I_ANYNL: puts(\"anynl\"); break;\n\t\tcase I_CHAR: printf(inst->c >= 32 && inst->c < 127 ? \"char '%c'\\n\" : \"char U+%04X\\n\", inst->c); break;\n\t\tcase I_CCLASS: puts(\"cclass\"); break;\n\t\tcase I_NCCLASS: puts(\"ncclass\"); break;\n\t\tcase I_REF: printf(\"ref %d\\n\", inst->n); break;\n\t\tcase I_BOL: puts(\"bol\"); break;\n\t\tcase I_EOL: puts(\"eol\"); break;\n\t\tcase I_WORD: puts(\"word\"); break;\n\t\tcase I_NWORD: puts(\"nword\"); break;\n\t\tcase I_LPAR: printf(\"lpar %d\\n\", inst->n); break;\n\t\tcase I_RPAR: printf(\"rpar %d\\n\", inst->n); break;\n\t\t}\n\t}\n}\n#endif\n\nReprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx,\n\tconst char *pattern, int cflags, const char **errorp)\n{\n\tstruct cstate g;\n\tRenode *node;\n\tReinst *split, *jump;\n\tint i, n;\n\n\tg.pstart = NULL;\n\tg.prog = NULL;\n\n\tif (setjmp(g.kaboom)) {\n\t\tif (errorp) *errorp = g.error;\n\t\talloc(ctx, g.pstart, 0);\n\t\talloc(ctx, g.prog, 0);\n\t\treturn NULL;\n\t}\n\n\tg.prog = alloc(ctx, NULL, sizeof (Reprog));\n\tif (!g.prog)\n\t\tdie(&g, \"cannot allocate regular expression\");\n\tn = strlen(pattern) * 2;\n\tif (n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\tif (n > 0) {\n\t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n\t\tif (!g.pstart)\n\t\t\tdie(&g, \"cannot allocate regular expression parse list\");\n\t}\n\n\tg.source = pattern;\n\tg.ncclass = 0;\n\tg.nsub = 1;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tg.sub[i] = 0;\n\n\tg.prog->flags = cflags;\n\n\tnext(&g);\n\tnode = parsealt(&g);\n\tif (g.lookahead == ')')\n\t\tdie(&g, \"unmatched ')'\");\n\tif (g.lookahead != 0)\n\t\tdie(&g, \"syntax error\");\n\n#ifdef TEST\n\tdumpnode(node);\n\tputchar('\\n');\n#endif\n\n\tn = 6 + count(&g, node);\n\tif (n < 0 || n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\n\tg.prog->nsub = g.nsub;\n\tg.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst));\n\tif (!g.prog->start)\n\t\tdie(&g, \"cannot allocate regular expression instruction list\");\n\n\tsplit = emit(g.prog, I_SPLIT);\n\tsplit->x = split + 3;\n\tsplit->y = split + 1;\n\temit(g.prog, I_ANYNL);\n\tjump = emit(g.prog, I_JUMP);\n\tjump->x = split;\n\temit(g.prog, I_LPAR);\n\tcompile(g.prog, node);\n\temit(g.prog, I_RPAR);\n\temit(g.prog, I_END);\n\n#ifdef TEST\n\tdumpprog(g.prog);\n#endif\n\n\talloc(ctx, g.pstart, 0);\n\n\tif (errorp) *errorp = NULL;\n\treturn g.prog;\n}\n\nvoid regfreex(void *(*alloc)(void *ctx, void *p, int n), void *ctx, Reprog *prog)\n{\n\tif (prog) {\n\t\talloc(ctx, prog->start, 0);\n\t\talloc(ctx, prog, 0);\n\t}\n}\n\nstatic void *default_alloc(void *ctx, void *p, int n)\n{\n\treturn realloc(p, (size_t)n);\n}\n\nReprog *regcomp(const char *pattern, int cflags, const char **errorp)\n{\n\treturn regcompx(default_alloc, NULL, pattern, cflags, errorp);\n}\n\nvoid regfree(Reprog *prog)\n{\n\tregfreex(default_alloc, NULL, prog);\n}\n\n/* Match */\n\nstatic int isnewline(int c)\n{\n\treturn c == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;\n}\n\nstatic int iswordchar(int c)\n{\n\treturn c == '_' ||\n\t\t(c >= 'a' && c <= 'z') ||\n\t\t(c >= 'A' && c <= 'Z') ||\n\t\t(c >= '0' && c <= '9');\n}\n\nstatic int incclass(Reclass *cc, Rune c)\n{\n\tRune *p;\n\tfor (p = cc->spans; p < cc->end; p += 2)\n\t\tif (p[0] <= c && c <= p[1])\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int incclasscanon(Reclass *cc, Rune c)\n{\n\tRune *p, r;\n\tfor (p = cc->spans; p < cc->end; p += 2)\n\t\tfor (r = p[0]; r <= p[1]; ++r)\n\t\t\tif (c == canon(r))\n\t\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int strncmpcanon(const char *a, const char *b, int n)\n{\n\tRune ra, rb;\n\tint c;\n\twhile (n--) {\n\t\tif (!*a) return -1;\n\t\tif (!*b) return 1;\n\t\ta += chartorune(&ra, a);\n\t\tb += chartorune(&rb, b);\n\t\tc = canon(ra) - canon(rb);\n\t\tif (c)\n\t\t\treturn c;\n\t}\n\treturn 0;\n}\n\nstatic int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n{\n\tResub scratch;\n\tint result;\n\tint i;\n\tRune c;\n\n\t/* stack overflow */\n\tif (depth > MAXREC)\n\t\treturn -1;\n\n\tfor (;;) {\n\t\tswitch (pc->opcode) {\n\t\tcase I_END:\n\t\t\treturn 0;\n\t\tcase I_JUMP:\n\t\t\tpc = pc->x;\n\t\t\tbreak;\n\t\tcase I_SPLIT:\n\t\t\tscratch = *out;\n\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n\t\t\tif (result == -1)\n\t\t\t\treturn -1;\n\t\t\tif (result == 0) {\n\t\t\t\t*out = scratch;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\n\t\tcase I_PLA:\n\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n\t\t\tif (result == -1)\n\t\t\t\treturn -1;\n\t\t\tif (result == 1)\n\t\t\t\treturn 1;\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\t\tcase I_NLA:\n\t\t\tscratch = *out;\n\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n\t\t\tif (result == -1)\n\t\t\t\treturn -1;\n\t\t\tif (result == 0)\n\t\t\t\treturn 1;\n\t\t\tpc = pc->y;\n\t\t\tbreak;\n\n\t\tcase I_ANYNL:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 1;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_ANY:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 1;\n\t\t\tif (isnewline(c))\n\t\t\t\treturn 1;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_CHAR:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 1;\n\t\t\tif (flags & REG_ICASE)\n\t\t\t\tc = canon(c);\n\t\t\tif (c != pc->c)\n\t\t\t\treturn 1;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_CCLASS:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 1;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (!incclass(pc->cc, c))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_NCCLASS:\n\t\t\tsp += chartorune(&c, sp);\n\t\t\tif (c == 0)\n\t\t\t\treturn 1;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (incclass(pc->cc, c))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_REF:\n\t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n\t\t\tif (flags & REG_ICASE) {\n\t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t\tsp += i;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\n\t\tcase I_BOL:\n\t\t\tif (sp == bol && !(flags & REG_NOTBOL)) {\n\t\t\t\tpc = pc + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & REG_NEWLINE) {\n\t\t\t\tif (sp > bol && isnewline(sp[-1])) {\n\t\t\t\t\tpc = pc + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\tcase I_EOL:\n\t\t\tif (*sp == 0) {\n\t\t\t\tpc = pc + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & REG_NEWLINE) {\n\t\t\t\tif (isnewline(*sp)) {\n\t\t\t\t\tpc = pc + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\tcase I_WORD:\n\t\t\ti = sp > bol && iswordchar(sp[-1]);\n\t\t\ti ^= iswordchar(sp[0]);\n\t\t\tif (!i)\n\t\t\t\treturn 1;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_NWORD:\n\t\t\ti = sp > bol && iswordchar(sp[-1]);\n\t\t\ti ^= iswordchar(sp[0]);\n\t\t\tif (i)\n\t\t\t\treturn 1;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\n\t\tcase I_LPAR:\n\t\t\tout->sub[pc->n].sp = sp;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tcase I_RPAR:\n\t\t\tout->sub[pc->n].ep = sp;\n\t\t\tpc = pc + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nint regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\n\tif (!sub)\n\t\tsub = &scratch;\n\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\n\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n}\n\n#ifdef TEST\nint main(int argc, char **argv)\n{\n\tconst char *error;\n\tconst char *s;\n\tReprog *p;\n\tResub m;\n\tint i;\n\n\tif (argc > 1) {\n\t\tp = regcomp(argv[1], 0, &error);\n\t\tif (!p) {\n\t\t\tfprintf(stderr, \"regcomp: %s\\n\", error);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (argc > 2) {\n\t\t\ts = argv[2];\n\t\t\tprintf(\"nsub = %d\\n\", p->nsub);\n\t\t\tif (!regexec(p, s, &m, 0)) {\n\t\t\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\t\t\tint n = m.sub[i].ep - m.sub[i].sp;\n\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\tprintf(\"match %d: s=%d e=%d n=%d '%.*s'\\n\", i, (int)(m.sub[i].sp - s), (int)(m.sub[i].ep - s), n, n, m.sub[i].sp);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"match %d: n=0 ''\\n\", i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"no match\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n"], "filenames": ["jsregexp.c", "jsstring.c", "regexp.c"], "buggy_code_start_loc": [31, 5, 18], "buggy_code_end_loc": [94, 590, 1134], "fixing_code_start_loc": [32, 6, 19], "fixing_code_end_loc": [102, 598, 1149], "type": "CWE-674", "message": "An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.", "other": {"cve": {"id": "CVE-2019-11413", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-22T11:29:05.157", "lastModified": "2020-11-10T03:15:11.647", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check."}, {"lang": "es", "value": "Se ha descubierto un problema en Artifex MuJS 1.0.5. Tiene recursi\u00f3n ilimitada porque la funci\u00f3n match en regexp.c carece de un control de profundidad."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mujs:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "3FA24B50-E74E-4790-928D-DAD8CC042C09"}]}]}], "references": [{"url": "http://www.ghostscript.com/cgi-bin/findgit.cgi?00d4606c3baf813b7b1c176823b2729bf51002a2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/108093", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.ghostscript.com/show_bug.cgi?id=700937", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}, {"url": "https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3RQXMWEOWCGLOLFBQSXBM3MBN33T4I5H/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/67PMOZV4DLVL2KGU2SV724QL7Y4PKWKU/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MFCRO74ORRIVWNVAX2MAMRY3THCTWLQI/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202007-52", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2"}}