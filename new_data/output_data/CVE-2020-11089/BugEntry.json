{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n\t                      CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Print Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Armin Novak <armin.novak@gmail.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/interlocked.h>\n#include <winpr/path.h>\n\n#include <freerdp/channels/rdpdr.h>\n#include <freerdp/crypto/crypto.h>\n\n#include \"../printer.h\"\n\n#include <freerdp/client/printer.h>\n\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"printer.client\")\n\ntypedef struct _PRINTER_DEVICE PRINTER_DEVICE;\nstruct _PRINTER_DEVICE\n{\n\tDEVICE device;\n\n\trdpPrinter* printer;\n\n\tWINPR_PSLIST_HEADER pIrpList;\n\n\tHANDLE event;\n\tHANDLE stopEvent;\n\n\tHANDLE thread;\n\trdpContext* rdpcontext;\n\tchar port[64];\n};\n\ntypedef enum\n{\n\tPRN_CONF_PORT = 0,\n\tPRN_CONF_PNP = 1,\n\tPRN_CONF_DRIVER = 2,\n\tPRN_CONF_DATA = 3\n} prn_conf_t;\n\nstatic const char* filemap[] = { \"PortDosName\", \"PnPName\", \"DriverName\",\n\t                             \"CachedPrinterConfigData\" };\n\nstatic char* get_printer_config_path(const rdpSettings* settings, const WCHAR* name, size_t length)\n{\n\tchar* dir = GetCombinedPath(settings->ConfigPath, \"printers\");\n\tchar* bname = crypto_base64_encode((const BYTE*)name, (int)length);\n\tchar* config = GetCombinedPath(dir, bname);\n\n\tif (config && !PathFileExistsA(config))\n\t{\n\t\tif (!PathMakePathA(config, NULL))\n\t\t{\n\t\t\tfree(config);\n\t\t\tconfig = NULL;\n\t\t}\n\t}\n\n\tfree(dir);\n\tfree(bname);\n\treturn config;\n}\n\nstatic BOOL printer_write_setting(const char* path, prn_conf_t type, const void* data,\n                                  size_t length)\n{\n\tDWORD written = 0;\n\tBOOL rc = FALSE;\n\tHANDLE file;\n\tsize_t b64len;\n\tchar* base64 = NULL;\n\tconst char* name = filemap[type];\n\tchar* abs = GetCombinedPath(path, name);\n\n\tif (!abs)\n\t\treturn FALSE;\n\n\tfile = CreateFileA(abs, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\tfree(abs);\n\n\tif (file == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\tif (length > 0)\n\t{\n\t\tbase64 = crypto_base64_encode(data, length);\n\n\t\tif (!base64)\n\t\t\tgoto fail;\n\n\t\t/* base64 char represents 6bit -> 4*(n/3) is the length which is\n\t\t * always smaller than 2*n */\n\t\tb64len = strnlen(base64, 2 * length);\n\t\trc = WriteFile(file, base64, b64len, &written, NULL);\n\n\t\tif (b64len != written)\n\t\t\trc = FALSE;\n\t}\n\telse\n\t\trc = TRUE;\n\nfail:\n\tCloseHandle(file);\n\tfree(base64);\n\treturn rc;\n}\n\nstatic BOOL printer_config_valid(const char* path)\n{\n\tif (!path)\n\t\treturn FALSE;\n\n\tif (!PathFileExistsA(path))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL printer_read_setting(const char* path, prn_conf_t type, void** data, UINT32* length)\n{\n\tDWORD lowSize, highSize;\n\tDWORD read = 0;\n\tBOOL rc = FALSE;\n\tHANDLE file;\n\tchar* fdata = NULL;\n\tconst char* name = filemap[type];\n\tchar* abs = GetCombinedPath(path, name);\n\n\tif (!abs)\n\t\treturn FALSE;\n\n\tfile = CreateFileA(abs, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\tfree(abs);\n\n\tif (file == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\tlowSize = GetFileSize(file, &highSize);\n\n\tif ((lowSize == INVALID_FILE_SIZE) || (highSize != 0))\n\t\tgoto fail;\n\n\tif (lowSize != 0)\n\t{\n\t\tfdata = malloc(lowSize);\n\n\t\tif (!fdata)\n\t\t\tgoto fail;\n\n\t\trc = ReadFile(file, fdata, lowSize, &read, NULL);\n\n\t\tif (lowSize != read)\n\t\t\trc = FALSE;\n\t}\n\nfail:\n\tCloseHandle(file);\n\n\tif (rc && (lowSize <= INT_MAX))\n\t{\n\t\tint blen = 0;\n\t\tcrypto_base64_decode(fdata, (int)lowSize, (BYTE**)data, &blen);\n\n\t\tif (*data && (blen > 0))\n\t\t\t*length = (UINT32)blen;\n\t\telse\n\t\t{\n\t\t\trc = FALSE;\n\t\t\t*length = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t*length = 0;\n\t\t*data = NULL;\n\t}\n\n\tfree(fdata);\n\treturn rc;\n}\n\nstatic BOOL printer_save_to_config(const rdpSettings* settings, const char* PortDosName,\n                                   size_t PortDosNameLen, const WCHAR* PnPName, size_t PnPNameLen,\n                                   const WCHAR* DriverName, size_t DriverNameLen,\n                                   const WCHAR* PrinterName, size_t PrintNameLen,\n                                   const BYTE* CachedPrinterConfigData, size_t CacheFieldsLen)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, PrinterName, PrintNameLen);\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_PORT, PortDosName, PortDosNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_PNP, PnPName, PnPNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_DRIVER, DriverName, DriverNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_DATA, CachedPrinterConfigData, CacheFieldsLen))\n\t\tgoto fail;\n\nfail:\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_update_to_config(const rdpSettings* settings, const WCHAR* name, size_t length,\n                                     const BYTE* data, size_t datalen)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, name, length);\n\trc = printer_write_setting(path, PRN_CONF_DATA, data, datalen);\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_remove_config(const rdpSettings* settings, const WCHAR* name, size_t length)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, name, length);\n\n\tif (!printer_config_valid(path))\n\t\tgoto fail;\n\n\trc = RemoveDirectoryA(path);\nfail:\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_move_config(const rdpSettings* settings, const WCHAR* oldName, size_t oldLength,\n                                const WCHAR* newName, size_t newLength)\n{\n\tBOOL rc = FALSE;\n\tchar* oldPath = get_printer_config_path(settings, oldName, oldLength);\n\tchar* newPath = get_printer_config_path(settings, newName, newLength);\n\n\tif (printer_config_valid(oldPath))\n\t\trc = MoveFileA(oldPath, newPath);\n\n\tfree(oldPath);\n\tfree(newPath);\n\treturn rc;\n}\n\nstatic BOOL printer_load_from_config(const rdpSettings* settings, rdpPrinter* printer,\n                                     PRINTER_DEVICE* printer_dev)\n{\n\tBOOL res = FALSE;\n\tWCHAR* wname = NULL;\n\tsize_t wlen;\n\tchar* path = NULL;\n\tint rc;\n\tUINT32 flags = 0;\n\tvoid* DriverName = NULL;\n\tUINT32 DriverNameLen = 0;\n\tvoid* PnPName = NULL;\n\tUINT32 PnPNameLen = 0;\n\tvoid* CachedPrinterConfigData = NULL;\n\tUINT32 CachedFieldsLen = 0;\n\tUINT32 PrinterNameLen = 0;\n\n\tif (!settings || !printer)\n\t\treturn FALSE;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->name, -1, &wname, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\twlen = _wcslen(wname) + 1;\n\tpath = get_printer_config_path(settings, wname, wlen * sizeof(WCHAR));\n\tPrinterNameLen = (wlen + 1) * sizeof(WCHAR);\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (printer->is_default)\n\t\tflags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;\n\n\tif (!printer_read_setting(path, PRN_CONF_PNP, &PnPName, &PnPNameLen))\n\t{\n\t}\n\n\tif (!printer_read_setting(path, PRN_CONF_DRIVER, &DriverName, &DriverNameLen))\n\t{\n\t\tDriverNameLen =\n\t\t    ConvertToUnicode(CP_UTF8, 0, printer->driver, -1, (LPWSTR*)&DriverName, 0) * 2 + 1;\n\t}\n\n\tif (!printer_read_setting(path, PRN_CONF_DATA, &CachedPrinterConfigData, &CachedFieldsLen))\n\t{\n\t}\n\n\tStream_SetPosition(printer_dev->device.data, 0);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, 24))\n\t\tgoto fail;\n\n\tStream_Write_UINT32(printer_dev->device.data, flags);\n\tStream_Write_UINT32(printer_dev->device.data, 0);          /* CodePage, reserved */\n\tStream_Write_UINT32(printer_dev->device.data, PnPNameLen); /* PnPNameLen */\n\tStream_Write_UINT32(printer_dev->device.data, DriverNameLen);\n\tStream_Write_UINT32(printer_dev->device.data, PrinterNameLen);\n\tStream_Write_UINT32(printer_dev->device.data, CachedFieldsLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, PnPNameLen))\n\t\tgoto fail;\n\n\tif (PnPNameLen > 0)\n\t\tStream_Write(printer_dev->device.data, PnPName, PnPNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, DriverNameLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, DriverName, DriverNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, PrinterNameLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, wname, PrinterNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, CachedFieldsLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, CachedPrinterConfigData, CachedFieldsLen);\n\tres = TRUE;\nfail:\n\tfree(path);\n\tfree(wname);\n\tfree(PnPName);\n\tfree(DriverName);\n\tfree(CachedPrinterConfigData);\n\treturn res;\n}\n\nstatic BOOL printer_save_default_config(const rdpSettings* settings, rdpPrinter* printer)\n{\n\tBOOL res = FALSE;\n\tWCHAR* wname = NULL;\n\tWCHAR* driver = NULL;\n\tsize_t wlen, dlen;\n\tchar* path = NULL;\n\tint rc;\n\n\tif (!settings || !printer)\n\t\treturn FALSE;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->name, -1, &wname, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->driver, -1, &driver, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\twlen = _wcslen(wname) + 1;\n\tdlen = _wcslen(driver) + 1;\n\tpath = get_printer_config_path(settings, wname, wlen * sizeof(WCHAR));\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (dlen > 1)\n\t{\n\t\tif (!printer_write_setting(path, PRN_CONF_DRIVER, driver, dlen * sizeof(WCHAR)))\n\t\t\tgoto fail;\n\t}\n\n\tres = TRUE;\nfail:\n\tfree(path);\n\tfree(wname);\n\tfree(driver);\n\treturn res;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_create(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\trdpPrintJob* printjob = NULL;\n\n\tif (printer_dev->printer)\n\t\tprintjob =\n\t\t    printer_dev->printer->CreatePrintJob(printer_dev->printer, irp->devman->id_sequence++);\n\n\tif (printjob)\n\t{\n\t\tStream_Write_UINT32(irp->output, printjob->id); /* FileId */\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT32(irp->output, 0); /* FileId */\n\t\tirp->IoStatus = STATUS_PRINT_QUEUE_FULL;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_close(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\trdpPrintJob* printjob = NULL;\n\n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse\n\t{\n\t\tprintjob->Close(printjob);\n\t}\n\n\tStream_Zero(irp->output, 4); /* Padding(4) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_device_control(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT error;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\tif ((error = printer_process_irp_create(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_create failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\tif ((error = printer_process_irp_close(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_close failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\tif ((error = printer_process_irp_write(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_write failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tif ((error = printer_process_irp_device_control(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_device_control failed with error %\" PRIu32 \"!\",\n\t\t\t\t         error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\treturn irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic DWORD WINAPI printer_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)arg;\n\tHANDLE obj[] = { printer_dev->event, printer_dev->stopEvent };\n\tUINT error = CHANNEL_RC_OK;\n\n\twhile (1)\n\t{\n\t\tDWORD rc = WaitForMultipleObjects(2, obj, FALSE, INFINITE);\n\n\t\tif (rc == WAIT_FAILED)\n\t\t{\n\t\t\terror = GetLastError();\n\t\t\tWLog_ERR(TAG, \"WaitForMultipleObjects failed with error %\" PRIu32 \"!\", error);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == WAIT_OBJECT_0 + 1)\n\t\t\tbreak;\n\t\telse if (rc != WAIT_OBJECT_0)\n\t\t\tcontinue;\n\n\t\tResetEvent(printer_dev->event);\n\t\tirp = (IRP*)InterlockedPopEntrySList(printer_dev->pIrpList);\n\n\t\tif (irp == NULL)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"InterlockedPopEntrySList failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = printer_process_irp(printer_dev, irp)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"printer_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error && printer_dev->rdpcontext)\n\t\tsetChannelError(printer_dev->rdpcontext, error, \"printer_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_irp_request(DEVICE* device, IRP* irp)\n{\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tInterlockedPushEntrySList(printer_dev->pIrpList, &(irp->ItemEntry));\n\tSetEvent(printer_dev->event);\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT printer_custom_component(DEVICE* device, UINT16 component, UINT16 packetId, wStream* s)\n{\n\tUINT32 eventID;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tconst rdpSettings* settings = printer_dev->rdpcontext->settings;\n\n\tif (component != RDPDR_CTYP_PRN)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, eventID);\n\n\tswitch (packetId)\n\t{\n\t\tcase PAKID_PRN_CACHE_DATA:\n\t\t\tswitch (eventID)\n\t\t\t{\n\t\t\t\tcase RDPDR_ADD_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tchar PortDosName[8];\n\t\t\t\t\tUINT32 PnPNameLen, DriverNameLen, PrintNameLen, CacheFieldsLen;\n\t\t\t\t\tconst WCHAR *PnPName, *DriverName, *PrinterName;\n\t\t\t\t\tconst BYTE* CachedPrinterConfigData;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 24)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read(s, PortDosName, sizeof(PortDosName));\n\t\t\t\t\tStream_Read_UINT32(s, PnPNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, DriverNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, PrintNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, CacheFieldsLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PnPNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPnPName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PnPNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < DriverNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tDriverName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, DriverNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrintNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrintNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < CacheFieldsLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tCachedPrinterConfigData = Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, CacheFieldsLen);\n\n\t\t\t\t\tif (!printer_save_to_config(settings, PortDosName, sizeof(PortDosName), PnPName,\n\t\t\t\t\t                            PnPNameLen, DriverName, DriverNameLen, PrinterName,\n\t\t\t\t\t                            PrintNameLen, CachedPrinterConfigData,\n\t\t\t\t\t                            CacheFieldsLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_UPDATE_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 PrinterNameLen, ConfigDataLen;\n\t\t\t\t\tconst WCHAR* PrinterName;\n\t\t\t\t\tconst BYTE* ConfigData;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, PrinterNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, ConfigDataLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < ConfigDataLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tConfigData = Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, ConfigDataLen);\n\n\t\t\t\t\tif (!printer_update_to_config(settings, PrinterName, PrinterNameLen, ConfigData,\n\t\t\t\t\t                              ConfigDataLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_DELETE_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 PrinterNameLen;\n\t\t\t\t\tconst WCHAR* PrinterName;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, PrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrinterNameLen);\n\t\t\t\t\tprinter_remove_config(settings, PrinterName, PrinterNameLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_RENAME_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 OldPrinterNameLen, NewPrinterNameLen;\n\t\t\t\t\tconst WCHAR* OldPrinterName;\n\t\t\t\t\tconst WCHAR* NewPrinterName;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, OldPrinterNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, NewPrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < OldPrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tOldPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, OldPrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < NewPrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tNewPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, NewPrinterNameLen);\n\n\t\t\t\t\tif (!printer_move_config(settings, OldPrinterName, OldPrinterNameLen,\n\t\t\t\t\t                         NewPrinterName, NewPrinterNameLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"Unknown cache data eventID: 0x%08\" PRIX32 \"\", eventID);\n\t\t\t\t\treturn ERROR_INVALID_DATA;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase PAKID_PRN_USING_XPS:\n\t\t{\n\t\t\tUINT32 flags;\n\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tStream_Read_UINT32(s, flags);\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"Ignoring unhandled message PAKID_PRN_USING_XPS [printerID=%08\" PRIx32\n\t\t\t         \", flags=%08\" PRIx32 \"]\",\n\t\t\t         eventID, flags);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Unknown printing component packetID: 0x%04\" PRIX16 \"\", packetId);\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_free(DEVICE* device)\n{\n\tIRP* irp;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tUINT error;\n\tSetEvent(printer_dev->stopEvent);\n\n\tif (WaitForSingleObject(printer_dev->thread, INFINITE) == WAIT_FAILED)\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\n\t\t/* The analyzer is confused by this premature return value.\n\t\t * Since this case can not be handled gracefully silence the\n\t\t * analyzer here. */\n#ifndef __clang_analyzer__\n\t\treturn error;\n#endif\n\t}\n\n\twhile ((irp = (IRP*)InterlockedPopEntrySList(printer_dev->pIrpList)) != NULL)\n\t\tirp->Discard(irp);\n\n\tCloseHandle(printer_dev->thread);\n\tCloseHandle(printer_dev->stopEvent);\n\tCloseHandle(printer_dev->event);\n\t_aligned_free(printer_dev->pIrpList);\n\n\tif (printer_dev->printer)\n\t\tprinter_dev->printer->ReleaseRef(printer_dev->printer);\n\n\tStream_Free(printer_dev->device.data, TRUE);\n\tfree(printer_dev);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_register(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, rdpPrinter* printer)\n{\n\tPRINTER_DEVICE* printer_dev;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tprinter_dev = (PRINTER_DEVICE*)calloc(1, sizeof(PRINTER_DEVICE));\n\n\tif (!printer_dev)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tprinter_dev->device.data = Stream_New(NULL, 1024);\n\n\tif (!printer_dev->device.data)\n\t\tgoto error_out;\n\n\tsprintf_s(printer_dev->port, sizeof(printer_dev->port), \"PRN%\" PRIdz, printer->id);\n\tprinter_dev->device.type = RDPDR_DTYP_PRINT;\n\tprinter_dev->device.name = printer_dev->port;\n\tprinter_dev->device.IRPRequest = printer_irp_request;\n\tprinter_dev->device.CustomComponentRequest = printer_custom_component;\n\tprinter_dev->device.Free = printer_free;\n\tprinter_dev->rdpcontext = pEntryPoints->rdpcontext;\n\tprinter_dev->printer = printer;\n\tprinter_dev->pIrpList = (WINPR_PSLIST_HEADER)_aligned_malloc(sizeof(WINPR_SLIST_HEADER),\n\t                                                             MEMORY_ALLOCATION_ALIGNMENT);\n\n\tif (!printer_dev->pIrpList)\n\t{\n\t\tWLog_ERR(TAG, \"_aligned_malloc failed!\");\n\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\tgoto error_out;\n\t}\n\n\tif (!printer_load_from_config(pEntryPoints->rdpcontext->settings, printer, printer_dev))\n\t\tgoto error_out;\n\n\tInitializeSListHead(printer_dev->pIrpList);\n\n\tif (!(printer_dev->event = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateEvent failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tif (!(printer_dev->stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateEvent failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)printer_dev)))\n\t{\n\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\tgoto error_out;\n\t}\n\n\tif (!(printer_dev->thread =\n\t          CreateThread(NULL, 0, printer_thread_func, (void*)printer_dev, 0, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tprinter->AddRef(printer);\n\treturn CHANNEL_RC_OK;\nerror_out:\n\tprinter_free(&printer_dev->device);\n\treturn error;\n}\n\nstatic rdpPrinterDriver* printer_load_backend(const char* backend)\n{\n\ttypedef rdpPrinterDriver* (*backend_load_t)(void);\n\tunion {\n\t\tPVIRTUALCHANNELENTRY entry;\n\t\tbackend_load_t backend;\n\t} fktconv;\n\n\tfktconv.entry = freerdp_load_channel_addin_entry(\"printer\", backend, NULL, 0);\n\tif (!fktconv.entry)\n\t\treturn NULL;\n\n\treturn fktconv.backend();\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT\n#ifdef BUILTIN_CHANNELS\nprinter_DeviceServiceEntry\n#else\n    FREERDP_API\n    DeviceServiceEntry\n#endif\n    (PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tint i;\n\tchar* name;\n\tchar* driver_name;\n\tBOOL default_backend = TRUE;\n\tRDPDR_PRINTER* device = NULL;\n\trdpPrinterDriver* driver = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!pEntryPoints || !pEntryPoints->device)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tdevice = (RDPDR_PRINTER*)pEntryPoints->device;\n\tname = device->Name;\n\tdriver_name = device->DriverName;\n\n\t/* Secondary argument is one of the following:\n\t *\n\t * <driver_name>                ... name of a printer driver\n\t * <driver_name>:<backend_name> ... name of a printer driver and local printer backend to use\n\t */\n\tif (driver_name)\n\t{\n\t\tchar* sep = strstr(driver_name, \":\");\n\t\tif (sep)\n\t\t{\n\t\t\tconst char* backend = sep + 1;\n\t\t\t*sep = '\\0';\n\t\t\tdriver = printer_load_backend(backend);\n\t\t\tdefault_backend = FALSE;\n\t\t}\n\t}\n\n\tif (!driver && default_backend)\n\t{\n\t\tconst char* backend =\n#if defined(WITH_CUPS)\n\t\t    \"cups\"\n#elif defined(_WIN32)\n\t\t    \"win\"\n#else\n\t\t    \"\"\n#endif\n\t\t    ;\n\n\t\tdriver = printer_load_backend(backend);\n\t}\n\n\tif (!driver)\n\t{\n\t\tWLog_ERR(TAG, \"Could not get a printer driver!\");\n\t\treturn CHANNEL_RC_INITIALIZATION_ERROR;\n\t}\n\n\tif (name && name[0])\n\t{\n\t\trdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);\n\n\t\tif (!printer)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Could not get printer %s!\", name);\n\t\t\terror = CHANNEL_RC_INITIALIZATION_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!printer_save_default_config(pEntryPoints->rdpcontext->settings, printer))\n\t\t{\n\t\t\terror = CHANNEL_RC_INITIALIZATION_ERROR;\n\t\t\tprinter->ReleaseRef(printer);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif ((error = printer_register(pEntryPoints, printer)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"printer_register failed with error %\" PRIu32 \"!\", error);\n\t\t\tprinter->ReleaseRef(printer);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\telse\n\t{\n\t\trdpPrinter** printers = driver->EnumPrinters(driver);\n\t\trdpPrinter** current = printers;\n\n\t\tfor (i = 0; current[i]; i++)\n\t\t{\n\t\t\trdpPrinter* printer = current[i];\n\n\t\t\tif ((error = printer_register(pEntryPoints, printer)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_register failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdriver->ReleaseEnumPrinters(printers);\n\t}\n\nfail:\n\tdriver->ReleaseRef(driver);\n\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Input Virtual Channel Extension\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/sysinfo.h>\n#include <winpr/cmdline.h>\n#include <winpr/collections.h>\n\n#include <freerdp/addin.h>\n#include <freerdp/freerdp.h>\n\n#include \"rdpei_common.h\"\n\n#include \"rdpei_main.h\"\n\n/**\n * Touch Input\n * http://msdn.microsoft.com/en-us/library/windows/desktop/dd562197/\n *\n * Windows Touch Input\n * http://msdn.microsoft.com/en-us/library/windows/desktop/dd317321/\n *\n * Input: Touch injection sample\n * http://code.msdn.microsoft.com/windowsdesktop/Touch-Injection-Sample-444d9bf7\n *\n * Pointer Input Message Reference\n * http://msdn.microsoft.com/en-us/library/hh454916/\n *\n * POINTER_INFO Structure\n * http://msdn.microsoft.com/en-us/library/hh454907/\n *\n * POINTER_TOUCH_INFO Structure\n * http://msdn.microsoft.com/en-us/library/hh454910/\n */\n\n#define MAX_CONTACTS 512\n\nstruct _RDPEI_CHANNEL_CALLBACK\n{\n\tIWTSVirtualChannelCallback iface;\n\n\tIWTSPlugin* plugin;\n\tIWTSVirtualChannelManager* channel_mgr;\n\tIWTSVirtualChannel* channel;\n};\ntypedef struct _RDPEI_CHANNEL_CALLBACK RDPEI_CHANNEL_CALLBACK;\n\nstruct _RDPEI_LISTENER_CALLBACK\n{\n\tIWTSListenerCallback iface;\n\n\tIWTSPlugin* plugin;\n\tIWTSVirtualChannelManager* channel_mgr;\n\tRDPEI_CHANNEL_CALLBACK* channel_callback;\n};\ntypedef struct _RDPEI_LISTENER_CALLBACK RDPEI_LISTENER_CALLBACK;\n\nstruct _RDPEI_PLUGIN\n{\n\tIWTSPlugin iface;\n\n\tIWTSListener* listener;\n\tRDPEI_LISTENER_CALLBACK* listener_callback;\n\n\tRdpeiClientContext* context;\n\n\tint version;\n\tUINT16 maxTouchContacts;\n\tUINT64 currentFrameTime;\n\tUINT64 previousFrameTime;\n\tRDPINPUT_TOUCH_FRAME frame;\n\tRDPINPUT_CONTACT_DATA contacts[MAX_CONTACTS];\n\tRDPINPUT_CONTACT_POINT* contactPoints;\n\n\trdpContext* rdpcontext;\n};\ntypedef struct _RDPEI_PLUGIN RDPEI_PLUGIN;\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_frame(RdpeiClientContext* context);\n\n#ifdef WITH_DEBUG_RDPEI\nstatic const char* rdpei_eventid_string(UINT16 event)\n{\n\tswitch (event)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\treturn \"EVENTID_SC_READY\";\n\t\tcase EVENTID_CS_READY:\n\t\t\treturn \"EVENTID_CS_READY\";\n\t\tcase EVENTID_TOUCH:\n\t\t\treturn \"EVENTID_TOUCH\";\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\treturn \"EVENTID_SUSPEND_TOUCH\";\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\treturn \"EVENTID_RESUME_TOUCH\";\n\t\tcase EVENTID_DISMISS_HOVERING_CONTACT:\n\t\t\treturn \"EVENTID_DISMISS_HOVERING_CONTACT\";\n\t\tdefault:\n\t\t\treturn \"EVENTID_UNKNOWN\";\n\t}\n}\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_add_frame(RdpeiClientContext* context)\n{\n\tint i;\n\tRDPINPUT_CONTACT_DATA* contact;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\trdpei->frame.contactCount = 0;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontact = (RDPINPUT_CONTACT_DATA*)&(rdpei->contactPoints[i].data);\n\n\t\tif (rdpei->contactPoints[i].dirty)\n\t\t{\n\t\t\tCopyMemory(&(rdpei->contacts[rdpei->frame.contactCount]), contact,\n\t\t\t           sizeof(RDPINPUT_CONTACT_DATA));\n\t\t\trdpei->contactPoints[i].dirty = FALSE;\n\t\t\trdpei->frame.contactCount++;\n\t\t}\n\t\telse if (rdpei->contactPoints[i].active)\n\t\t{\n\t\t\tif (contact->contactFlags & CONTACT_FLAG_DOWN)\n\t\t\t{\n\t\t\t\tcontact->contactFlags = CONTACT_FLAG_UPDATE;\n\t\t\t\tcontact->contactFlags |= CONTACT_FLAG_INRANGE;\n\t\t\t\tcontact->contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\t\t}\n\n\t\t\tCopyMemory(&(rdpei->contacts[rdpei->frame.contactCount]), contact,\n\t\t\t           sizeof(RDPINPUT_CONTACT_DATA));\n\t\t\trdpei->frame.contactCount++;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s, UINT16 eventId,\n                           UINT32 pduLength)\n{\n\tUINT status;\n\tStream_SetPosition(s, 0);\n\tStream_Write_UINT16(s, eventId);   /* eventId (2 bytes) */\n\tStream_Write_UINT32(s, pduLength); /* pduLength (4 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\tstatus = callback->channel->Write(callback->channel, (UINT32)Stream_Length(s), Stream_Buffer(s),\n\t                                  NULL);\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG,\n\t         \"rdpei_send_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \" status: %\" PRIu32 \"\",\n\t         eventId, rdpei_eventid_string(eventId), pduLength, status);\n#endif\n\treturn status;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_cs_ready_pdu(RDPEI_CHANNEL_CALLBACK* callback)\n{\n\tUINT status;\n\twStream* s;\n\tUINT32 flags;\n\tUINT32 pduLength;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)callback->plugin;\n\tflags = 0;\n\tflags |= READY_FLAGS_SHOW_TOUCH_VISUALS;\n\t// flags |= READY_FLAGS_DISABLE_TIMESTAMP_INJECTION;\n\tpduLength = RDPINPUT_HEADER_LENGTH + 10;\n\ts = Stream_New(NULL, pduLength);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tStream_Seek(s, RDPINPUT_HEADER_LENGTH);\n\tStream_Write_UINT32(s, flags);                   /* flags (4 bytes) */\n\tStream_Write_UINT32(s, RDPINPUT_PROTOCOL_V10);   /* protocolVersion (4 bytes) */\n\tStream_Write_UINT16(s, rdpei->maxTouchContacts); /* maxTouchContacts (2 bytes) */\n\tStream_SealLength(s);\n\tstatus = rdpei_send_pdu(callback, s, EVENTID_CS_READY, pduLength);\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\nstatic void rdpei_print_contact_flags(UINT32 contactFlags)\n{\n\tif (contactFlags & CONTACT_FLAG_DOWN)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_DOWN\");\n\n\tif (contactFlags & CONTACT_FLAG_UPDATE)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_UPDATE\");\n\n\tif (contactFlags & CONTACT_FLAG_UP)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_UP\");\n\n\tif (contactFlags & CONTACT_FLAG_INRANGE)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_INRANGE\");\n\n\tif (contactFlags & CONTACT_FLAG_INCONTACT)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_INCONTACT\");\n\n\tif (contactFlags & CONTACT_FLAG_CANCELED)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_CANCELED\");\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_write_touch_frame(wStream* s, RDPINPUT_TOUCH_FRAME* frame)\n{\n\tUINT32 index;\n\tint rectSize = 2;\n\tRDPINPUT_CONTACT_DATA* contact;\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"contactCount: %\" PRIu32 \"\", frame->contactCount);\n\tWLog_DBG(TAG, \"frameOffset: 0x%016\" PRIX64 \"\", frame->frameOffset);\n#endif\n\trdpei_write_2byte_unsigned(s,\n\t                           frame->contactCount); /* contactCount (TWO_BYTE_UNSIGNED_INTEGER) */\n\t/**\n\t * the time offset from the previous frame (in microseconds).\n\t * If this is the first frame being transmitted then this field MUST be set to zero.\n\t */\n\trdpei_write_8byte_unsigned(s, frame->frameOffset *\n\t                                  1000); /* frameOffset (EIGHT_BYTE_UNSIGNED_INTEGER) */\n\n\tif (!Stream_EnsureRemainingCapacity(s, (size_t)frame->contactCount * 64))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tfor (index = 0; index < frame->contactCount; index++)\n\t{\n\t\tcontact = &frame->contacts[index];\n\t\tcontact->fieldsPresent |= CONTACT_DATA_CONTACTRECT_PRESENT;\n\t\tcontact->contactRectLeft = contact->x - rectSize;\n\t\tcontact->contactRectTop = contact->y - rectSize;\n\t\tcontact->contactRectRight = contact->x + rectSize;\n\t\tcontact->contactRectBottom = contact->y + rectSize;\n#ifdef WITH_DEBUG_RDPEI\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].contactId: %\" PRIu32 \"\", index, contact->contactId);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].fieldsPresent: %\" PRIu32 \"\", index,\n\t\t         contact->fieldsPresent);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].x: %\" PRId32 \"\", index, contact->x);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].y: %\" PRId32 \"\", index, contact->y);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].contactFlags: 0x%08\" PRIX32 \"\", index,\n\t\t         contact->contactFlags);\n\t\trdpei_print_contact_flags(contact->contactFlags);\n#endif\n\t\tStream_Write_UINT8(s, contact->contactId); /* contactId (1 byte) */\n\t\t/* fieldsPresent (TWO_BYTE_UNSIGNED_INTEGER) */\n\t\trdpei_write_2byte_unsigned(s, contact->fieldsPresent);\n\t\trdpei_write_4byte_signed(s, contact->x); /* x (FOUR_BYTE_SIGNED_INTEGER) */\n\t\trdpei_write_4byte_signed(s, contact->y); /* y (FOUR_BYTE_SIGNED_INTEGER) */\n\t\t/* contactFlags (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\trdpei_write_4byte_unsigned(s, contact->contactFlags);\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_CONTACTRECT_PRESENT)\n\t\t{\n\t\t\t/* contactRectLeft (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectLeft);\n\t\t\t/* contactRectTop (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectTop);\n\t\t\t/* contactRectRight (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectRight);\n\t\t\t/* contactRectBottom (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectBottom);\n\t\t}\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_ORIENTATION_PRESENT)\n\t\t{\n\t\t\t/* orientation (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\t\trdpei_write_4byte_unsigned(s, contact->orientation);\n\t\t}\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_PRESSURE_PRESENT)\n\t\t{\n\t\t\t/* pressure (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\t\trdpei_write_4byte_unsigned(s, contact->pressure);\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_touch_event_pdu(RDPEI_CHANNEL_CALLBACK* callback,\n                                       RDPINPUT_TOUCH_FRAME* frame)\n{\n\tUINT status;\n\twStream* s;\n\tUINT32 pduLength;\n\tpduLength = 64 + (frame->contactCount * 64);\n\ts = Stream_New(NULL, pduLength);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tStream_Seek(s, RDPINPUT_HEADER_LENGTH);\n\t/**\n\t * the time that has elapsed (in milliseconds) from when the oldest touch frame\n\t * was generated to when it was encoded for transmission by the client.\n\t */\n\trdpei_write_4byte_unsigned(\n\t    s, (UINT32)frame->frameOffset); /* encodeTime (FOUR_BYTE_UNSIGNED_INTEGER) */\n\trdpei_write_2byte_unsigned(s, 1);   /* (frameCount) TWO_BYTE_UNSIGNED_INTEGER */\n\n\tif ((status = rdpei_write_touch_frame(s, frame)))\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_write_touch_frame failed with error %\" PRIu32 \"!\", status);\n\t\tStream_Free(s, TRUE);\n\t\treturn status;\n\t}\n\n\tStream_SealLength(s);\n\tpduLength = Stream_Length(s);\n\tstatus = rdpei_send_pdu(callback, s, EVENTID_TOUCH, pduLength);\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_sc_ready_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT32 protocolVersion;\n\tStream_Read_UINT32(s, protocolVersion); /* protocolVersion (4 bytes) */\n#if 0\n\n\tif (protocolVersion != RDPINPUT_PROTOCOL_V10)\n\t{\n\t\tWLog_ERR(TAG,  \"Unknown [MS-RDPEI] protocolVersion: 0x%08\"PRIX32\"\", protocolVersion);\n\t\treturn -1;\n\t}\n\n#endif\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_suspend_touch_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tRdpeiClientContext* rdpei = (RdpeiClientContext*)callback->plugin->pInterface;\n\tUINT error = CHANNEL_RC_OK;\n\tIFCALLRET(rdpei->SuspendTouch, error, rdpei);\n\n\tif (error)\n\t\tWLog_ERR(TAG, \"rdpei->SuspendTouch failed with error %\" PRIu32 \"!\", error);\n\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_resume_touch_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tRdpeiClientContext* rdpei = (RdpeiClientContext*)callback->plugin->pInterface;\n\tUINT error = CHANNEL_RC_OK;\n\tIFCALLRET(rdpei->ResumeTouch, error, rdpei);\n\n\tif (error)\n\t\tWLog_ERR(TAG, \"rdpei->ResumeTouch failed with error %\" PRIu32 \"!\", error);\n\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   /* eventId (2 bytes) */\n\tStream_Read_UINT32(s, pduLength); /* pduLength (4 bytes) */\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_data_received(IWTSVirtualChannelCallback* pChannelCallback, wStream* data)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback = (RDPEI_CHANNEL_CALLBACK*)pChannelCallback;\n\treturn rdpei_recv_pdu(callback, data);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_close(IWTSVirtualChannelCallback* pChannelCallback)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback = (RDPEI_CHANNEL_CALLBACK*)pChannelCallback;\n\tfree(callback);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_new_channel_connection(IWTSListenerCallback* pListenerCallback,\n                                            IWTSVirtualChannel* pChannel, BYTE* Data,\n                                            BOOL* pbAccept, IWTSVirtualChannelCallback** ppCallback)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback;\n\tRDPEI_LISTENER_CALLBACK* listener_callback = (RDPEI_LISTENER_CALLBACK*)pListenerCallback;\n\tcallback = (RDPEI_CHANNEL_CALLBACK*)calloc(1, sizeof(RDPEI_CHANNEL_CALLBACK));\n\n\tif (!callback)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tcallback->iface.OnDataReceived = rdpei_on_data_received;\n\tcallback->iface.OnClose = rdpei_on_close;\n\tcallback->plugin = listener_callback->plugin;\n\tcallback->channel_mgr = listener_callback->channel_mgr;\n\tcallback->channel = pChannel;\n\tlistener_callback->channel_callback = callback;\n\t*ppCallback = (IWTSVirtualChannelCallback*)callback;\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_plugin_initialize(IWTSPlugin* pPlugin, IWTSVirtualChannelManager* pChannelMgr)\n{\n\tUINT error;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)pPlugin;\n\trdpei->listener_callback = (RDPEI_LISTENER_CALLBACK*)calloc(1, sizeof(RDPEI_LISTENER_CALLBACK));\n\n\tif (!rdpei->listener_callback)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\trdpei->listener_callback->iface.OnNewChannelConnection = rdpei_on_new_channel_connection;\n\trdpei->listener_callback->plugin = pPlugin;\n\trdpei->listener_callback->channel_mgr = pChannelMgr;\n\n\tif ((error = pChannelMgr->CreateListener(pChannelMgr, RDPEI_DVC_CHANNEL_NAME, 0,\n\t                                         (IWTSListenerCallback*)rdpei->listener_callback,\n\t                                         &(rdpei->listener))))\n\t{\n\t\tWLog_ERR(TAG, \"ChannelMgr->CreateListener failed with error %\" PRIu32 \"!\", error);\n\t\tgoto error_out;\n\t}\n\n\trdpei->listener->pInterface = rdpei->iface.pInterface;\n\n\treturn error;\nerror_out:\n\tfree(rdpei->listener_callback);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_plugin_terminated(IWTSPlugin* pPlugin)\n{\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)pPlugin;\n\n\tif (!pPlugin)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfree(rdpei->listener_callback);\n\tfree(rdpei->context);\n\tfree(rdpei);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Channel Client Interface\n */\n\nstatic int rdpei_get_version(RdpeiClientContext* context)\n{\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\treturn rdpei->version;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT rdpei_send_frame(RdpeiClientContext* context)\n{\n\tUINT64 currentTime;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tRDPEI_CHANNEL_CALLBACK* callback = rdpei->listener_callback->channel_callback;\n\tUINT error;\n\tcurrentTime = GetTickCount64();\n\n\tif (!rdpei->previousFrameTime && !rdpei->currentFrameTime)\n\t{\n\t\trdpei->currentFrameTime = currentTime;\n\t\trdpei->frame.frameOffset = 0;\n\t}\n\telse\n\t{\n\t\trdpei->currentFrameTime = currentTime;\n\t\trdpei->frame.frameOffset = rdpei->currentFrameTime - rdpei->previousFrameTime;\n\t}\n\n\tif ((error = rdpei_send_touch_event_pdu(callback, &rdpei->frame)))\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_send_touch_event_pdu failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\trdpei->previousFrameTime = rdpei->currentFrameTime;\n\trdpei->frame.contactCount = 0;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_add_contact(RdpeiClientContext* context, const RDPINPUT_CONTACT_DATA* contact)\n{\n\tUINT error;\n\tRDPINPUT_CONTACT_POINT* contactPoint;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\n\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[contact->contactId];\n\tCopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));\n\tcontactPoint->dirty = TRUE;\n\n\terror = rdpei_add_frame(context);\n\tif (error != CHANNEL_RC_OK)\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_add_frame failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tif (rdpei->frame.contactCount > 0)\n\t{\n\t\terror = rdpei_send_frame(context);\n\t\tif (error != CHANNEL_RC_OK)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdpei_send_frame failed with error %\" PRIu32 \"!\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_begin(RdpeiClientContext* context, int externalId, int x, int y,\n                              int* contactId)\n{\n\tunsigned int i;\n\tINT64 contactIdlocal = -1;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error = CHANNEL_RC_OK;\n\n\t/* Create a new contact point in an empty slot */\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t{\n\t\t\tcontactPoint->contactId = i;\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tcontactPoint->externalId = externalId;\n\t\t\tcontactPoint->active = TRUE;\n\t\t\tcontactPoint->state = RDPINPUT_CONTACT_STATE_ENGAGED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\t\tcontactPoint->lastX = x;\n\t\tcontactPoint->lastY = y;\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_DOWN;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INRANGE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\terror = context->AddContact(context, &contact);\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_update(RdpeiClientContext* context, int externalId, int x, int y,\n                               int* contactId)\n{\n\tunsigned int i;\n\tint contactIdlocal = -1;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error = CHANNEL_RC_OK;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t\tcontinue;\n\n\t\tif (contactPoint->externalId == externalId)\n\t\t{\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\t\tcontactPoint->lastX = x;\n\t\tcontactPoint->lastY = y;\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_UPDATE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INRANGE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\terror = context->AddContact(context, &contact);\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_end(RdpeiClientContext* context, int externalId, int x, int y,\n                            int* contactId)\n{\n\tunsigned int i;\n\tint contactIdlocal = -1;\n\tint tempvalue;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t\tcontinue;\n\n\t\tif (contactPoint->externalId == externalId)\n\t\t{\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\n\t\tif ((contactPoint->lastX != x) && (contactPoint->lastY != y))\n\t\t{\n\t\t\tif ((error = context->TouchUpdate(context, externalId, x, y, &tempvalue)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"context->TouchUpdate failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_UP;\n\n\t\tif ((error = context->AddContact(context, &contact)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"context->AddContact failed with error %\" PRIu32 \"!\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tcontactPoint->externalId = 0;\n\t\tcontactPoint->active = FALSE;\n\t\tcontactPoint->flags = 0;\n\t\tcontactPoint->contactId = 0;\n\t\tcontactPoint->state = RDPINPUT_CONTACT_STATE_OUT_OF_RANGE;\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn CHANNEL_RC_OK;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DVCPluginEntry rdpei_DVCPluginEntry\n#else\n#define DVCPluginEntry FREERDP_API DVCPluginEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DVCPluginEntry(IDRDYNVC_ENTRY_POINTS* pEntryPoints)\n{\n\tUINT error;\n\tRDPEI_PLUGIN* rdpei = NULL;\n\tRdpeiClientContext* context = NULL;\n\trdpei = (RDPEI_PLUGIN*)pEntryPoints->GetPlugin(pEntryPoints, \"rdpei\");\n\n\tif (!rdpei)\n\t{\n\t\tsize_t size;\n\t\trdpei = (RDPEI_PLUGIN*)calloc(1, sizeof(RDPEI_PLUGIN));\n\n\t\tif (!rdpei)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\trdpei->iface.Initialize = rdpei_plugin_initialize;\n\t\trdpei->iface.Connected = NULL;\n\t\trdpei->iface.Disconnected = NULL;\n\t\trdpei->iface.Terminated = rdpei_plugin_terminated;\n\t\trdpei->version = 1;\n\t\trdpei->currentFrameTime = 0;\n\t\trdpei->previousFrameTime = 0;\n\t\trdpei->frame.contacts = (RDPINPUT_CONTACT_DATA*)rdpei->contacts;\n\t\trdpei->maxTouchContacts = 10;\n\t\tsize = rdpei->maxTouchContacts * sizeof(RDPINPUT_CONTACT_POINT);\n\t\trdpei->contactPoints = (RDPINPUT_CONTACT_POINT*)calloc(1, size);\n\t\trdpei->rdpcontext =\n\t\t    ((freerdp*)((rdpSettings*)pEntryPoints->GetRdpSettings(pEntryPoints))->instance)\n\t\t        ->context;\n\n\t\tif (!rdpei->contactPoints)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tcontext = (RdpeiClientContext*)calloc(1, sizeof(RdpeiClientContext));\n\n\t\tif (!context)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tcontext->handle = (void*)rdpei;\n\t\tcontext->GetVersion = rdpei_get_version;\n\t\tcontext->AddContact = rdpei_add_contact;\n\t\tcontext->TouchBegin = rdpei_touch_begin;\n\t\tcontext->TouchUpdate = rdpei_touch_update;\n\t\tcontext->TouchEnd = rdpei_touch_end;\n\t\trdpei->iface.pInterface = (void*)context;\n\n\t\tif ((error = pEntryPoints->RegisterPlugin(pEntryPoints, \"rdpei\", (IWTSPlugin*)rdpei)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"EntryPoints->RegisterPlugin failed with error %\" PRIu32 \"!\", error);\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\trdpei->context = context;\n\t}\n\n\treturn CHANNEL_RC_OK;\nerror_out:\n\tfree(context);\n\tfree(rdpei->contactPoints);\n\tfree(rdpei);\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Serial Port Device Service Virtual Channel\n *\n * Copyright 2011 O.S. Systems Software Ltda.\n * Copyright 2011 Eduardo Fiss Beloni <beloni@ossystems.com.br>\n * Copyright 2014 Hewlett-Packard Development Company, L.P.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/collections.h>\n#include <winpr/comm.h>\n#include <winpr/crt.h>\n#include <winpr/stream.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/wlog.h>\n\n#include <freerdp/freerdp.h>\n#include <freerdp/channels/rdpdr.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"serial.client\")\n\n/* TODO: all #ifdef __linux__ could be removed once only some generic\n * functions will be used. Replace CommReadFile by ReadFile,\n * CommWriteFile by WriteFile etc..  */\n#if defined __linux__ && !defined ANDROID\n\n#define MAX_IRP_THREADS 5\n\ntypedef struct _SERIAL_DEVICE SERIAL_DEVICE;\n\nstruct _SERIAL_DEVICE\n{\n\tDEVICE device;\n\tBOOL permissive;\n\tSERIAL_DRIVER_ID ServerSerialDriverId;\n\tHANDLE* hComm;\n\n\twLog* log;\n\tHANDLE MainThread;\n\twMessageQueue* MainIrpQueue;\n\n\t/* one thread per pending IRP and indexed according their CompletionId */\n\twListDictionary* IrpThreads;\n\tUINT32 IrpThreadToBeTerminatedCount;\n\tCRITICAL_SECTION TerminatingIrpThreadsLock;\n\trdpContext* rdpcontext;\n};\n\ntypedef struct _IRP_THREAD_DATA IRP_THREAD_DATA;\n\nstruct _IRP_THREAD_DATA\n{\n\tSERIAL_DEVICE* serial;\n\tIRP* irp;\n};\n\nstatic UINT32 _GetLastErrorToIoStatus(SERIAL_DEVICE* serial)\n{\n\t/* http://msdn.microsoft.com/en-us/library/ff547466%28v=vs.85%29.aspx#generic_status_values_for_serial_device_control_requests\n\t */\n\tswitch (GetLastError())\n\t{\n\t\tcase ERROR_BAD_DEVICE:\n\t\t\treturn STATUS_INVALID_DEVICE_REQUEST;\n\n\t\tcase ERROR_CALL_NOT_IMPLEMENTED:\n\t\t\treturn STATUS_NOT_IMPLEMENTED;\n\n\t\tcase ERROR_CANCELLED:\n\t\t\treturn STATUS_CANCELLED;\n\n\t\tcase ERROR_INSUFFICIENT_BUFFER:\n\t\t\treturn STATUS_BUFFER_TOO_SMALL; /* NB: STATUS_BUFFER_SIZE_TOO_SMALL not defined  */\n\n\t\tcase ERROR_INVALID_DEVICE_OBJECT_PARAMETER: /* eg: SerCx2.sys' _purge() */\n\t\t\treturn STATUS_INVALID_DEVICE_STATE;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\treturn STATUS_INVALID_DEVICE_REQUEST;\n\n\t\tcase ERROR_INVALID_PARAMETER:\n\t\t\treturn STATUS_INVALID_PARAMETER;\n\n\t\tcase ERROR_IO_DEVICE:\n\t\t\treturn STATUS_IO_DEVICE_ERROR;\n\n\t\tcase ERROR_IO_PENDING:\n\t\t\treturn STATUS_PENDING;\n\n\t\tcase ERROR_NOT_SUPPORTED:\n\t\t\treturn STATUS_NOT_SUPPORTED;\n\n\t\tcase ERROR_TIMEOUT:\n\t\t\treturn STATUS_TIMEOUT;\n\t\t\t/* no default */\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"unexpected last-error: 0x%08\" PRIX32 \"\", GetLastError());\n\treturn STATUS_UNSUCCESSFUL;\n}\n\nstatic UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tDWORD DesiredAccess;\n\tDWORD SharedAccess;\n\tDWORD CreateDisposition;\n\tUINT32 PathLength;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); /* Path (variable) */\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |\n\t * FILE_SHARE_WRITE | FILE_SHARE_READ CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * assert(DesiredAccess == (GENERIC_READ | GENERIC_WRITE));\n\t * assert(SharedAccess == 0);\n\t * assert(CreateDisposition == OPEN_EXISTING);\n\t *\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" PRIX32\n\t           \", CreateDisposition: 0x%\" PRIX32 \"\",\n\t           DesiredAccess, SharedAccess, CreateDisposition);\n\t/* FIXME: As of today only the flags below are supported by CommCreateFileA: */\n\tDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n\tSharedAccess = 0;\n\tCreateDisposition = OPEN_EXISTING;\n#endif\n\tserial->hComm =\n\t    CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL, /* SecurityAttributes */\n\t               CreateDisposition, 0,                                   /* FlagsAndAttributes */\n\t               NULL);                                                  /* TemplateFile */\n\n\tif (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CreateFile failure: %s last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, GetLastError());\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\t_comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId);\n\t_comm_set_permissive(serial->hComm, serial->permissive);\n\t/* NOTE: binary mode/raw mode required for the redirection. On\n\t * Linux, CommCreateFileA forces this setting.\n\t */\n\t/* ZeroMemory(&dcb, sizeof(DCB)); */\n\t/* dcb.DCBlength = sizeof(DCB); */\n\t/* GetCommState(serial->hComm, &dcb); */\n\t/* dcb.fBinary = TRUE; */\n\t/* SetCommState(serial->hComm, &dcb); */\n\tassert(irp->FileId == 0);\n\tirp->FileId = irp->devman->id_sequence++; /* FIXME: why not ((WINPR_COMM*)hComm)->fd? */\n\tirp->IoStatus = STATUS_SUCCESS;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") created.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\nerror_handle:\n\tStream_Write_UINT32(irp->output, irp->FileId); /* FileId (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);            /* Information (1 byte) */\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT serial_process_irp_close(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, 32); /* Padding (32 bytes) */\n\n\tif (!CloseHandle(serial->hComm))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CloseHandle failure: %s (%\" PRIu32 \") closed.\",\n\t\t           serial->device.name, irp->device->id);\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") closed.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\n\tserial->hComm = NULL;\n\tirp->IoStatus = STATUS_SUCCESS;\nerror_handle:\n\tStream_Zero(irp->output, 5); /* Padding (5 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp_read(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tBYTE* buffer = NULL;\n\tDWORD nbRead = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length); /* Length (4 bytes) */\n\tStream_Read_UINT64(irp->input, Offset); /* Offset (8 bytes) */\n\tStream_Seek(irp->input, 20);            /* Padding (20 bytes) */\n\tbuffer = (BYTE*)calloc(Length, sizeof(BYTE));\n\n\tif (buffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\t/* MS-RDPESP 3.2.5.1.4: If the Offset field is not set to 0, the value MUST be ignored\n\t * assert(Offset == 0);\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG, \"reading %\" PRIu32 \" bytes from %s\", Length,\n\t           serial->device.name);\n\n\t/* FIXME: CommReadFile to be replaced by ReadFile */\n\tif (CommReadFile(serial->hComm, buffer, Length, &nbRead, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"read failure to %s, nbRead=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbRead, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes read from %s\", nbRead,\n\t           serial->device.name);\nerror_handle:\n\tStream_Write_UINT32(irp->output, nbRead); /* Length (4 bytes) */\n\n\tif (nbRead > 0)\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(irp->output, nbRead))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\tfree(buffer);\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tStream_Write(irp->output, buffer, nbRead); /* ReadData */\n\t}\n\n\tfree(buffer);\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length); /* Length (4 bytes) */\n\tStream_Read_UINT64(irp->input, Offset); /* Offset (8 bytes) */\n\tStream_Seek(irp->input, 20);            /* Padding (20 bytes) */\n\t/* MS-RDPESP 3.2.5.1.5: The Offset field is ignored\n\t * assert(Offset == 0);\n\t *\n\t * Using a serial printer, noticed though this field could be\n\t * set.\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\n\t/* FIXME: CommWriteFile to be replaced by WriteFile */\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); /* Length (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);          /* Padding (1 byte) */\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp_device_control(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 IoControlCode;\n\tUINT32 InputBufferLength;\n\tBYTE* InputBuffer = NULL;\n\tUINT32 OutputBufferLength;\n\tBYTE* OutputBuffer = NULL;\n\tDWORD BytesReturned = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, OutputBufferLength); /* OutputBufferLength (4 bytes) */\n\tStream_Read_UINT32(irp->input, InputBufferLength);  /* InputBufferLength (4 bytes) */\n\tStream_Read_UINT32(irp->input, IoControlCode);      /* IoControlCode (4 bytes) */\n\tStream_Seek(irp->input, 20);                        /* Padding (20 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < InputBufferLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tOutputBuffer = (BYTE*)calloc(OutputBufferLength, sizeof(BYTE));\n\n\tif (OutputBuffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\tInputBuffer = (BYTE*)calloc(InputBufferLength, sizeof(BYTE));\n\n\tif (InputBuffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\tStream_Read(irp->input, InputBuffer, InputBufferLength);\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"CommDeviceIoControl: CompletionId=%\" PRIu32 \", IoControlCode=[0x%\" PRIX32 \"] %s\",\n\t           irp->CompletionId, IoControlCode, _comm_serial_ioctl_name(IoControlCode));\n\n\t/* FIXME: CommDeviceIoControl to be replaced by DeviceIoControl() */\n\tif (CommDeviceIoControl(serial->hComm, IoControlCode, InputBuffer, InputBufferLength,\n\t                        OutputBuffer, OutputBufferLength, &BytesReturned, NULL))\n\t{\n\t\t/* WLog_Print(serial->log, WLOG_DEBUG, \"CommDeviceIoControl: CompletionId=%\"PRIu32\",\n\t\t * IoControlCode=[0x%\"PRIX32\"] %s done\", irp->CompletionId, IoControlCode,\n\t\t * _comm_serial_ioctl_name(IoControlCode)); */\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"CommDeviceIoControl failure: IoControlCode=[0x%\" PRIX32\n\t\t           \"] %s, last-error: 0x%08\" PRIX32 \"\",\n\t\t           IoControlCode, _comm_serial_ioctl_name(IoControlCode), GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\nerror_handle:\n\t/* FIXME: find out whether it's required or not to get\n\t * BytesReturned == OutputBufferLength when\n\t * CommDeviceIoControl returns FALSE */\n\tassert(OutputBufferLength == BytesReturned);\n\tStream_Write_UINT32(irp->output, BytesReturned); /* OutputBufferLength (4 bytes) */\n\n\tif (BytesReturned > 0)\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(irp->output, BytesReturned))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\tfree(InputBuffer);\n\t\t\tfree(OutputBuffer);\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tStream_Write(irp->output, OutputBuffer, BytesReturned); /* OutputBuffer */\n\t}\n\n\t/* FIXME: Why at least Windows 2008R2 gets lost with this\n\t * extra byte and likely on a IOCTL_SERIAL_SET_BAUD_RATE? The\n\t * extra byte is well required according MS-RDPEFS\n\t * 2.2.1.5.5 */\n\t/* else */\n\t/* { */\n\t/* \tStream_Write_UINT8(irp->output, 0); /\\* Padding (1 byte) *\\/ */\n\t/* } */\n\tfree(InputBuffer);\n\tfree(OutputBuffer);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT error = CHANNEL_RC_OK;\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"IRP MajorFunction: 0x%08\" PRIX32 \" MinorFunction: 0x%08\" PRIX32 \"\\n\",\n\t           irp->MajorFunction, irp->MinorFunction);\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = serial_process_irp_create(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = serial_process_irp_close(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\tif ((error = serial_process_irp_read(serial, irp)))\n\t\t\t\tWLog_ERR(TAG, \"serial_process_irp_read failed with error %\" PRIu32 \"!\", error);\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = serial_process_irp_write(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tif ((error = serial_process_irp_device_control(serial, irp)))\n\t\t\t\tWLog_ERR(TAG, \"serial_process_irp_device_control failed with error %\" PRIu32 \"!\",\n\t\t\t\t         error);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI irp_thread_func(LPVOID arg)\n{\n\tIRP_THREAD_DATA* data = (IRP_THREAD_DATA*)arg;\n\tUINT error;\n\n\t/* blocks until the end of the request */\n\tif ((error = serial_process_irp(data->serial, data->irp)))\n\t{\n\t\tWLog_ERR(TAG, \"serial_process_irp failed with error %\" PRIu32 \"\", error);\n\t\tgoto error_out;\n\t}\n\n\tEnterCriticalSection(&data->serial->TerminatingIrpThreadsLock);\n\tdata->serial->IrpThreadToBeTerminatedCount++;\n\terror = data->irp->Complete(data->irp);\n\tLeaveCriticalSection(&data->serial->TerminatingIrpThreadsLock);\nerror_out:\n\n\tif (error && data->serial->rdpcontext)\n\t\tsetChannelError(data->serial->rdpcontext, error, \"irp_thread_func reported an error\");\n\n\t/* NB: At this point, the server might already being reusing\n\t * the CompletionId whereas the thread is not yet\n\t * terminated */\n\tfree(data);\n\tExitThread(error);\n\treturn error;\n}\n\nstatic void create_irp_thread(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tIRP_THREAD_DATA* data = NULL;\n\tHANDLE irpThread;\n\tHANDLE previousIrpThread;\n\tuintptr_t key;\n\t/* for a test/debug purpose, uncomment the code below to get a\n\t * single thread for all IRPs. NB: two IRPs could not be\n\t * processed at the same time, typically two concurent\n\t * Read/Write operations could block each other. */\n\t/* serial_process_irp(serial, irp); */\n\t/* irp->Complete(irp); */\n\t/* return; */\n\t/* NOTE: for good or bad, this implementation relies on the\n\t * server to avoid a flooding of requests. see also _purge().\n\t */\n\tEnterCriticalSection(&serial->TerminatingIrpThreadsLock);\n\n\twhile (serial->IrpThreadToBeTerminatedCount > 0)\n\t{\n\t\t/* Cleaning up termitating and pending irp\n\t\t * threads. See also: irp_thread_func() */\n\t\tHANDLE irpThread;\n\t\tULONG_PTR* ids;\n\t\tint i, nbIds;\n\t\tnbIds = ListDictionary_GetKeys(serial->IrpThreads, &ids);\n\n\t\tfor (i = 0; i < nbIds; i++)\n\t\t{\n\t\t\t/* Checking if ids[i] is terminating or pending */\n\t\t\tDWORD waitResult;\n\t\t\tULONG_PTR id = ids[i];\n\t\t\tirpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)id);\n\t\t\t/* FIXME: not quite sure a zero timeout is a good thing to check whether a thread is\n\t\t\t * stil alived or not */\n\t\t\twaitResult = WaitForSingleObject(irpThread, 0);\n\n\t\t\tif (waitResult == WAIT_OBJECT_0)\n\t\t\t{\n\t\t\t\t/* terminating thread */\n\t\t\t\t/* WLog_Print(serial->log, WLOG_DEBUG, \"IRP thread with CompletionId=%\"PRIuz\"\n\t\t\t\t * naturally died\", id); */\n\t\t\t\tCloseHandle(irpThread);\n\t\t\t\tListDictionary_Remove(serial->IrpThreads, (void*)id);\n\t\t\t\tserial->IrpThreadToBeTerminatedCount--;\n\t\t\t}\n\t\t\telse if (waitResult != WAIT_TIMEOUT)\n\t\t\t{\n\t\t\t\t/* unexpected thread state */\n\t\t\t\tWLog_Print(serial->log, WLOG_WARN,\n\t\t\t\t           \"WaitForSingleObject, got an unexpected result=0x%\" PRIX32 \"\\n\",\n\t\t\t\t           waitResult);\n\t\t\t\tassert(FALSE);\n\t\t\t}\n\n\t\t\t/* pending thread (but not yet terminating thread) if waitResult == WAIT_TIMEOUT */\n\t\t}\n\n\t\tif (serial->IrpThreadToBeTerminatedCount > 0)\n\t\t{\n\t\t\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" IRP thread(s) not yet terminated\",\n\t\t\t           serial->IrpThreadToBeTerminatedCount);\n\t\t\tSleep(1); /* 1 ms */\n\t\t}\n\n\t\tfree(ids);\n\t}\n\n\tLeaveCriticalSection(&serial->TerminatingIrpThreadsLock);\n\t/* NB: At this point and thanks to the synchronization we're\n\t * sure that the incoming IRP uses well a recycled\n\t * CompletionId or the server sent again an IRP already posted\n\t * which didn't get yet a response (this later server behavior\n\t * at least observed with IOCTL_SERIAL_WAIT_ON_MASK and\n\t * mstsc.exe).\n\t *\n\t * FIXME: behavior documented somewhere? behavior not yet\n\t * observed with FreeRDP).\n\t */\n\tkey = irp->CompletionId;\n\tpreviousIrpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)key);\n\n\tif (previousIrpThread)\n\t{\n\t\t/* Thread still alived <=> Request still pending */\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"IRP recall: IRP with the CompletionId=%\" PRIu32 \" not yet completed!\",\n\t\t           irp->CompletionId);\n\t\tassert(FALSE); /* unimplemented */\n\t\t/* TODO: asserts that previousIrpThread handles well\n\t\t * the same request by checking more details. Need an\n\t\t * access to the IRP object used by previousIrpThread\n\t\t */\n\t\t/* TODO: taking over the pending IRP or sending a kind\n\t\t * of wake up signal to accelerate the pending\n\t\t * request\n\t\t *\n\t\t * To be considered:\n\t\t *   if (IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) {\n\t\t *       pComm->PendingEvents |= SERIAL_EV_FREERDP_*;\n\t\t *   }\n\t\t */\n\t\tirp->Discard(irp);\n\t\treturn;\n\t}\n\n\tif (ListDictionary_Count(serial->IrpThreads) >= MAX_IRP_THREADS)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN,\n\t\t           \"Number of IRP threads threshold reached: %d, keep on anyway\",\n\t\t           ListDictionary_Count(serial->IrpThreads));\n\t\tassert(FALSE); /* unimplemented */\n\t\t               /* TODO: MAX_IRP_THREADS has been thought to avoid a\n\t\t                * flooding of pending requests. Use\n\t\t                * WaitForMultipleObjects() when available in winpr\n\t\t                * for threads.\n\t\t                */\n\t}\n\n\t/* error_handle to be used ... */\n\tdata = (IRP_THREAD_DATA*)calloc(1, sizeof(IRP_THREAD_DATA));\n\n\tif (data == NULL)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"Could not allocate a new IRP_THREAD_DATA.\");\n\t\tgoto error_handle;\n\t}\n\n\tdata->serial = serial;\n\tdata->irp = irp;\n\t/* data freed by irp_thread_func */\n\tirpThread = CreateThread(NULL, 0, irp_thread_func, (void*)data, 0, NULL);\n\n\tif (irpThread == INVALID_HANDLE_VALUE)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"Could not allocate a new IRP thread.\");\n\t\tgoto error_handle;\n\t}\n\n\tkey = irp->CompletionId;\n\n\tif (!ListDictionary_Add(serial->IrpThreads, (void*)key, irpThread))\n\t{\n\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\tgoto error_handle;\n\t}\n\n\treturn;\nerror_handle:\n\tirp->IoStatus = STATUS_NO_MEMORY;\n\tirp->Complete(irp);\n\tfree(data);\n}\n\nstatic void terminate_pending_irp_threads(SERIAL_DEVICE* serial)\n{\n\tULONG_PTR* ids;\n\tint i, nbIds;\n\tnbIds = ListDictionary_GetKeys(serial->IrpThreads, &ids);\n\tWLog_Print(serial->log, WLOG_DEBUG, \"Terminating %d IRP thread(s)\", nbIds);\n\n\tfor (i = 0; i < nbIds; i++)\n\t{\n\t\tHANDLE irpThread;\n\t\tULONG_PTR id = ids[i];\n\t\tirpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)id);\n\t\tTerminateThread(irpThread, 0);\n\n\t\tif (WaitForSingleObject(irpThread, INFINITE) == WAIT_FAILED)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"WaitForSingleObject failed!\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tCloseHandle(irpThread);\n\t\tWLog_Print(serial->log, WLOG_DEBUG, \"IRP thread terminated, CompletionId %p\", (void*)id);\n\t}\n\n\tListDictionary_Clear(serial->IrpThreads);\n\tfree(ids);\n}\n\nstatic DWORD WINAPI serial_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(serial->MainIrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(serial->MainIrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t{\n\t\t\tterminate_pending_irp_threads(serial);\n\t\t\tbreak;\n\t\t}\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t\tcreate_irp_thread(serial, irp);\n\t}\n\n\tif (error && serial->rdpcontext)\n\t\tsetChannelError(serial->rdpcontext, error, \"serial_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_irp_request(DEVICE* device, IRP* irp)\n{\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)device;\n\tassert(irp != NULL);\n\n\tif (irp == NULL)\n\t\treturn CHANNEL_RC_OK;\n\n\t/* NB: ENABLE_ASYNCIO is set, (MS-RDPEFS 2.2.2.7.2) this\n\t * allows the server to send multiple simultaneous read or\n\t * write requests.\n\t */\n\n\tif (!MessageQueue_Post(serial->MainIrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_free(DEVICE* device)\n{\n\tUINT error;\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)device;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"freeing\");\n\tMessageQueue_PostQuit(serial->MainIrpQueue, 0);\n\n\tif (WaitForSingleObject(serial->MainThread, INFINITE) == WAIT_FAILED)\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tCloseHandle(serial->MainThread);\n\n\tif (serial->hComm)\n\t\tCloseHandle(serial->hComm);\n\n\t/* Clean up resources */\n\tStream_Free(serial->device.data, TRUE);\n\tMessageQueue_Free(serial->MainIrpQueue);\n\tListDictionary_Free(serial->IrpThreads);\n\tDeleteCriticalSection(&serial->TerminatingIrpThreadsLock);\n\tfree(serial);\n\treturn CHANNEL_RC_OK;\n}\n\n#endif /* __linux__ */\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry serial_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tchar* name;\n\tchar* path;\n\tchar* driver;\n\tRDPDR_SERIAL* device;\n#if defined __linux__ && !defined ANDROID\n\tsize_t i, len;\n\tSERIAL_DEVICE* serial;\n#endif /* __linux__ */\n\tUINT error = CHANNEL_RC_OK;\n\tdevice = (RDPDR_SERIAL*)pEntryPoints->device;\n\tname = device->Name;\n\tpath = device->Path;\n\tdriver = device->Driver;\n\n\tif (!name || (name[0] == '*'))\n\t{\n\t\t/* TODO: implement auto detection of serial ports */\n\t\treturn CHANNEL_RC_OK;\n\t}\n\n\tif ((name && name[0]) && (path && path[0]))\n\t{\n\t\twLog* log;\n\t\tlog = WLog_Get(\"com.freerdp.channel.serial.client\");\n\t\tWLog_Print(log, WLOG_DEBUG, \"initializing\");\n#ifndef __linux__ /* to be removed */\n\t\tWLog_Print(log, WLOG_WARN, \"Serial ports redirection not supported on this platform.\");\n\t\treturn CHANNEL_RC_INITIALIZATION_ERROR;\n#else /* __linux __ */\n\t\tWLog_Print(log, WLOG_DEBUG, \"Defining %s as %s\", name, path);\n\n\t\tif (!DefineCommDevice(name /* eg: COM1 */, path /* eg: /dev/ttyS0 */))\n\t\t{\n\t\t\tDWORD status = GetLastError();\n\t\t\tWLog_ERR(TAG, \"DefineCommDevice failed with %08\" PRIx32, status);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tserial = (SERIAL_DEVICE*)calloc(1, sizeof(SERIAL_DEVICE));\n\n\t\tif (!serial)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tserial->log = log;\n\t\tserial->device.type = RDPDR_DTYP_SERIAL;\n\t\tserial->device.name = name;\n\t\tserial->device.IRPRequest = serial_irp_request;\n\t\tserial->device.Free = serial_free;\n\t\tserial->rdpcontext = pEntryPoints->rdpcontext;\n\t\tlen = strlen(name);\n\t\tserial->device.data = Stream_New(NULL, len + 1);\n\n\t\tif (!serial->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tfor (i = 0; i <= len; i++)\n\t\t\tStream_Write_UINT8(serial->device.data, name[i] < 0 ? '_' : name[i]);\n\n\t\tif (driver != NULL)\n\t\t{\n\t\t\tif (_stricmp(driver, \"Serial\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t\telse if (_stricmp(driver, \"SerCx\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerCxSys;\n\t\t\telse if (_stricmp(driver, \"SerCx2\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerCx2Sys;\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(FALSE);\n\t\t\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t\t\t           \"Unknown server's serial driver: %s. SerCx2 will be used\", driver);\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* default driver */\n\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t}\n\n\t\tif (device->Permissive != NULL)\n\t\t{\n\t\t\tif (_stricmp(device->Permissive, \"permissive\") == 0)\n\t\t\t{\n\t\t\t\tserial->permissive = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_Print(serial->log, WLOG_DEBUG, \"Unknown flag: %s\", device->Permissive);\n\t\t\t\tassert(FALSE);\n\t\t\t}\n\t\t}\n\n\t\tWLog_Print(serial->log, WLOG_DEBUG, \"Server's serial driver: %s (id: %d)\", driver,\n\t\t           serial->ServerSerialDriverId);\n\t\t/* TODO: implement auto detection of the server's serial driver */\n\t\tserial->MainIrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!serial->MainIrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\t/* IrpThreads content only modified by create_irp_thread() */\n\t\tserial->IrpThreads = ListDictionary_New(FALSE);\n\n\t\tif (!serial->IrpThreads)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tserial->IrpThreadToBeTerminatedCount = 0;\n\t\tInitializeCriticalSection(&serial->TerminatingIrpThreadsLock);\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)serial)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"EntryPoints->RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (!(serial->MainThread =\n\t\t          CreateThread(NULL, 0, serial_thread_func, (void*)serial, 0, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tgoto error_out;\n\t\t}\n\n#endif /* __linux __ */\n\t}\n\n\treturn error;\nerror_out:\n#ifdef __linux__ /* to be removed */\n\tListDictionary_Free(serial->IrpThreads);\n\tMessageQueue_Free(serial->MainIrpQueue);\n\tStream_Free(serial->device.data, TRUE);\n\tfree(serial);\n#endif /* __linux __ */\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Remote Desktop Gateway (RDG)\n *\n * Copyright 2015 Denis Vincent <dvincent@devolutions.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/print.h>\n#include <winpr/stream.h>\n#include <winpr/winsock.h>\n\n#include <freerdp/log.h>\n#include <freerdp/error.h>\n#include <freerdp/utils/ringbuffer.h>\n\n#include \"rdg.h\"\n#include \"../proxy.h\"\n#include \"../rdp.h\"\n#include \"../../crypto/opensslcompat.h\"\n#include \"rpc_fault.h\"\n\n#define TAG FREERDP_TAG(\"core.gateway.rdg\")\n\n/* HTTP channel response fields present flags. */\n#define HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID 0x1\n#define HTTP_CHANNEL_RESPONSE_OPTIONAL 0x2\n#define HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT 0x4\n\n/* HTTP extended auth. */\n#define HTTP_EXTENDED_AUTH_NONE 0x0\n#define HTTP_EXTENDED_AUTH_SC 0x1         /* Smart card authentication. */\n#define HTTP_EXTENDED_AUTH_PAA 0x02       /* Pluggable authentication. */\n#define HTTP_EXTENDED_AUTH_SSPI_NTLM 0x04 /* NTLM extended authentication. */\n\n/* HTTP packet types. */\n#define PKT_TYPE_HANDSHAKE_REQUEST 0x1\n#define PKT_TYPE_HANDSHAKE_RESPONSE 0x2\n#define PKT_TYPE_EXTENDED_AUTH_MSG 0x3\n#define PKT_TYPE_TUNNEL_CREATE 0x4\n#define PKT_TYPE_TUNNEL_RESPONSE 0x5\n#define PKT_TYPE_TUNNEL_AUTH 0x6\n#define PKT_TYPE_TUNNEL_AUTH_RESPONSE 0x7\n#define PKT_TYPE_CHANNEL_CREATE 0x8\n#define PKT_TYPE_CHANNEL_RESPONSE 0x9\n#define PKT_TYPE_DATA 0xA\n#define PKT_TYPE_SERVICE_MESSAGE 0xB\n#define PKT_TYPE_REAUTH_MESSAGE 0xC\n#define PKT_TYPE_KEEPALIVE 0xD\n#define PKT_TYPE_CLOSE_CHANNEL 0x10\n#define PKT_TYPE_CLOSE_CHANNEL_RESPONSE 0x11\n\n/* HTTP tunnel auth fields present flags. */\n#define HTTP_TUNNEL_AUTH_FIELD_SOH 0x1\n\n/* HTTP tunnel auth response fields present flags. */\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS 0x1\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT 0x2\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE 0x4\n\n/* HTTP tunnel packet fields present flags. */\n#define HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE 0x1\n#define HTTP_TUNNEL_PACKET_FIELD_REAUTH 0x2\n\n/* HTTP tunnel redir flags. */\n#define HTTP_TUNNEL_REDIR_ENABLE_ALL 0x80000000\n#define HTTP_TUNNEL_REDIR_DISABLE_ALL 0x40000000\n#define HTTP_TUNNEL_REDIR_DISABLE_DRIVE 0x1\n#define HTTP_TUNNEL_REDIR_DISABLE_PRINTER 0x2\n#define HTTP_TUNNEL_REDIR_DISABLE_PORT 0x4\n#define HTTP_TUNNEL_REDIR_DISABLE_CLIPBOARD 0x8\n#define HTTP_TUNNEL_REDIR_DISABLE_PNP 0x10\n\n/* HTTP tunnel response fields present flags. */\n#define HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID 0x1\n#define HTTP_TUNNEL_RESPONSE_FIELD_CAPS 0x2\n#define HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ 0x4\n#define HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG 0x10\n\n/* HTTP capability type enumeration. */\n#define HTTP_CAPABILITY_TYPE_QUAR_SOH 0x1\n#define HTTP_CAPABILITY_IDLE_TIMEOUT 0x2\n#define HTTP_CAPABILITY_MESSAGING_CONSENT_SIGN 0x4\n#define HTTP_CAPABILITY_MESSAGING_SERVICE_MSG 0x8\n#define HTTP_CAPABILITY_REAUTH 0x10\n#define HTTP_CAPABILITY_UDP_TRANSPORT 0x20\n\nstruct rdp_rdg\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tBOOL attached;\n\tBIO* frontBio;\n\trdpTls* tlsIn;\n\trdpTls* tlsOut;\n\trdpNtlm* ntlm;\n\tHttpContext* http;\n\tCRITICAL_SECTION writeSection;\n\n\tUUID guid;\n\n\tint state;\n\tUINT16 packetRemainingCount;\n\tUINT16 reserved1;\n\tint timeout;\n\tUINT16 extAuth;\n\tUINT16 reserved2;\n};\n\nenum\n{\n\tRDG_CLIENT_STATE_INITIAL,\n\tRDG_CLIENT_STATE_HANDSHAKE,\n\tRDG_CLIENT_STATE_TUNNEL_CREATE,\n\tRDG_CLIENT_STATE_TUNNEL_AUTHORIZE,\n\tRDG_CLIENT_STATE_CHANNEL_CREATE,\n\tRDG_CLIENT_STATE_OPENED,\n};\n\n#pragma pack(push, 1)\n\ntypedef struct rdg_packet_header\n{\n\tUINT16 type;\n\tUINT16 reserved;\n\tUINT32 packetLength;\n} RdgPacketHeader;\n\n#pragma pack(pop)\n\ntypedef struct\n{\n\tUINT32 code;\n\tconst char* name;\n} t_err_mapping;\n\nstatic const t_err_mapping tunnel_response_fields_present[] = {\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID, \"HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_CAPS, \"HTTP_TUNNEL_RESPONSE_FIELD_CAPS\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ, \"HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG, \"HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG\" }\n};\n\nstatic const t_err_mapping channel_response_fields_present[] = {\n\t{ HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID, \"HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID\" },\n\t{ HTTP_CHANNEL_RESPONSE_OPTIONAL, \"HTTP_CHANNEL_RESPONSE_OPTIONAL\" },\n\t{ HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT, \"HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT\" }\n};\n\nstatic const t_err_mapping tunnel_authorization_response_fields_present[] = {\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS, \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS\" },\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT,\n\t  \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT\" },\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE,\n\t  \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE\" }\n};\n\nstatic const t_err_mapping extended_auth[] = {\n\t{ HTTP_EXTENDED_AUTH_NONE, \"HTTP_EXTENDED_AUTH_NONE\" },\n\t{ HTTP_EXTENDED_AUTH_SC, \"HTTP_EXTENDED_AUTH_SC\" },\n\t{ HTTP_EXTENDED_AUTH_PAA, \"HTTP_EXTENDED_AUTH_PAA\" },\n\t{ HTTP_EXTENDED_AUTH_SSPI_NTLM, \"HTTP_EXTENDED_AUTH_SSPI_NTLM\" }\n};\n\nstatic const char* fields_present_to_string(UINT16 fieldsPresent, const t_err_mapping* map,\n                                            size_t elements)\n{\n\tsize_t x = 0;\n\tstatic char buffer[1024] = { 0 };\n\tchar fields[12];\n\tmemset(buffer, 0, sizeof(buffer));\n\n\tfor (x = 0; x < elements; x++)\n\t{\n\t\tif (buffer[0] != '\\0')\n\t\t\tstrcat(buffer, \"|\");\n\n\t\tif ((map[x].code & fieldsPresent) != 0)\n\t\t\tstrcat(buffer, map[x].name);\n\t}\n\n\tsprintf_s(fields, ARRAYSIZE(fields), \" [%04\" PRIx16 \"]\", fieldsPresent);\n\tstrcat(buffer, fields);\n\treturn buffer;\n}\n\nstatic const char* channel_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, channel_response_fields_present,\n\t                                ARRAYSIZE(channel_response_fields_present));\n}\n\nstatic const char* tunnel_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, tunnel_response_fields_present,\n\t                                ARRAYSIZE(tunnel_response_fields_present));\n}\n\nstatic const char* tunnel_authorization_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, tunnel_authorization_response_fields_present,\n\t                                ARRAYSIZE(tunnel_authorization_response_fields_present));\n}\n\nstatic const char* extended_auth_to_string(UINT16 auth)\n{\n\tif (auth == HTTP_EXTENDED_AUTH_NONE)\n\t\treturn \"HTTP_EXTENDED_AUTH_NONE [0x0000]\";\n\n\treturn fields_present_to_string(auth, extended_auth, ARRAYSIZE(extended_auth));\n}\n\nstatic BOOL rdg_write_packet(rdpRdg* rdg, wStream* sPacket)\n{\n\tsize_t s;\n\tint status;\n\twStream* sChunk;\n\tchar chunkSize[11];\n\tsprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIXz \"\\r\\n\", Stream_Length(sPacket));\n\tsChunk = Stream_New(NULL, strnlen(chunkSize, sizeof(chunkSize)) + Stream_Length(sPacket) + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, strnlen(chunkSize, sizeof(chunkSize)));\n\tStream_Write(sChunk, Stream_Buffer(sPacket), Stream_Length(sPacket));\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s > INT_MAX)\n\t\treturn FALSE;\n\n\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\tStream_Free(sChunk, TRUE);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_read_all(rdpTls* tls, BYTE* buffer, int size)\n{\n\tint status;\n\tint readCount = 0;\n\tBYTE* pBuffer = buffer;\n\n\twhile (readCount < size)\n\t{\n\t\tstatus = BIO_read(tls->bio, pBuffer, size - readCount);\n\n\t\tif (status <= 0)\n\t\t{\n\t\t\tif (!BIO_should_retry(tls->bio))\n\t\t\t\treturn FALSE;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\treadCount += status;\n\t\tpBuffer += status;\n\t}\n\n\treturn TRUE;\n}\n\nstatic wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}\n\nstatic BOOL rdg_send_handshake(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\ts = Stream_New(NULL, 14);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, PKT_TYPE_HANDSHAKE_REQUEST); /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                          /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, 14);                         /* PacketLength (4 bytes) */\n\tStream_Write_UINT8(s, 1);                           /* VersionMajor (1 byte) */\n\tStream_Write_UINT8(s, 0);                           /* VersionMinor (1 byte) */\n\tStream_Write_UINT16(s, 0);                          /* ClientVersion (2 bytes), must be 0 */\n\tStream_Write_UINT16(s, rdg->extAuth);               /* ExtendedAuthentication (2 bytes) */\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_HANDSHAKE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_tunnel_request(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\tUINT32 packetSize = 16;\n\tUINT16 fieldsPresent = 0;\n\tWCHAR* PAACookie = NULL;\n\tint PAACookieLen = 0;\n\n\tif (rdg->extAuth == HTTP_EXTENDED_AUTH_PAA)\n\t{\n\t\tPAACookieLen =\n\t\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->GatewayAccessToken, -1, &PAACookie, 0);\n\n\t\tif (!PAACookie || (PAACookieLen < 0) || (PAACookieLen > UINT16_MAX / 2))\n\t\t{\n\t\t\tfree(PAACookie);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpacketSize += 2 + (UINT32)PAACookieLen * sizeof(WCHAR);\n\t\tfieldsPresent = HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE;\n\t}\n\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t{\n\t\tfree(PAACookie);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT16(s, PKT_TYPE_TUNNEL_CREATE);        /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);                    /* PacketLength (4 bytes) */\n\tStream_Write_UINT32(s, HTTP_CAPABILITY_TYPE_QUAR_SOH); /* CapabilityFlags (4 bytes) */\n\tStream_Write_UINT16(s, fieldsPresent);                 /* FieldsPresent (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* Reserved (2 bytes), must be 0 */\n\n\tif (PAACookie)\n\t{\n\t\tStream_Write_UINT16(s, (UINT16)PAACookieLen * 2); /* PAA cookie string length */\n\t\tStream_Write_UTF16_String(s, PAACookie, (size_t)PAACookieLen);\n\t}\n\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\tfree(PAACookie);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_TUNNEL_CREATE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_tunnel_authorization(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\tWCHAR* clientName = NULL;\n\tUINT32 packetSize;\n\tint clientNameLen =\n\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->ClientHostname, -1, &clientName, 0);\n\n\tif (!clientName || (clientNameLen < 0) || (clientNameLen > UINT16_MAX / 2))\n\t{\n\t\tfree(clientName);\n\t\treturn FALSE;\n\t}\n\n\tpacketSize = 12 + (UINT32)clientNameLen * sizeof(WCHAR);\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t{\n\t\tfree(clientName);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT16(s, PKT_TYPE_TUNNEL_AUTH);      /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                         /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);                /* PacketLength (4 bytes) */\n\tStream_Write_UINT16(s, 0);                         /* FieldsPresent (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)clientNameLen * 2); /* Client name string length */\n\tStream_Write_UTF16_String(s, clientName, (size_t)clientNameLen);\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\tfree(clientName);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_TUNNEL_AUTHORIZE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_channel_create(rdpRdg* rdg)\n{\n\twStream* s = NULL;\n\tBOOL status = FALSE;\n\tWCHAR* serverName = NULL;\n\tint serverNameLen =\n\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->ServerHostname, -1, &serverName, 0);\n\tUINT32 packetSize = 16 + ((UINT32)serverNameLen) * 2;\n\n\tif ((serverNameLen < 0) || (serverNameLen > UINT16_MAX / 2))\n\t\tgoto fail;\n\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t\tgoto fail;\n\n\tStream_Write_UINT16(s, PKT_TYPE_CHANNEL_CREATE); /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);              /* PacketLength (4 bytes) */\n\tStream_Write_UINT8(s, 1);                        /* Number of resources. (1 byte) */\n\tStream_Write_UINT8(s, 0);                        /* Number of alternative resources (1 byte) */\n\tStream_Write_UINT16(s, (UINT16)rdg->settings->ServerPort); /* Resource port (2 bytes) */\n\tStream_Write_UINT16(s, 3);                                 /* Protocol number (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)serverNameLen * 2);\n\tStream_Write_UTF16_String(s, serverName, (size_t)serverNameLen);\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\nfail:\n\tfree(serverName);\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t\trdg->state = RDG_CLIENT_STATE_CHANNEL_CREATE;\n\n\treturn status;\n}\n\nstatic BOOL rdg_set_ntlm_auth_header(rdpNtlm* ntlm, HttpRequest* request)\n{\n\tconst SecBuffer* ntlmToken = ntlm_client_get_output_buffer(ntlm);\n\tchar* base64NtlmToken = NULL;\n\n\tif (ntlmToken)\n\t{\n\t\tif (ntlmToken->cbBuffer > INT_MAX)\n\t\t\treturn FALSE;\n\n\t\tbase64NtlmToken = crypto_base64_encode(ntlmToken->pvBuffer, (int)ntlmToken->cbBuffer);\n\t}\n\n\tif (base64NtlmToken)\n\t{\n\t\tBOOL rc = http_request_set_auth_scheme(request, \"NTLM\") &&\n\t\t          http_request_set_auth_param(request, base64NtlmToken);\n\t\tfree(base64NtlmToken);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic wStream* rdg_build_http_request(rdpRdg* rdg, const char* method,\n                                       const char* transferEncoding)\n{\n\twStream* s = NULL;\n\tHttpRequest* request = NULL;\n\tconst char* uri;\n\n\tif (!rdg || !method)\n\t\treturn NULL;\n\n\turi = http_context_get_uri(rdg->http);\n\trequest = http_request_new();\n\n\tif (!request)\n\t\treturn NULL;\n\n\tif (!http_request_set_method(request, method) || !http_request_set_uri(request, uri))\n\t\tgoto out;\n\n\tif (rdg->ntlm)\n\t{\n\t\tif (!rdg_set_ntlm_auth_header(rdg->ntlm, request))\n\t\t\tgoto out;\n\t}\n\n\tif (transferEncoding)\n\t{\n\t\thttp_request_set_transfer_encoding(request, transferEncoding);\n\t}\n\n\ts = http_request_write(rdg->http, request);\nout:\n\thttp_request_free(request);\n\n\tif (s)\n\t\tStream_SealLength(s);\n\n\treturn s;\n}\n\nstatic BOOL rdg_handle_ntlm_challenge(rdpNtlm* ntlm, HttpResponse* response)\n{\n\tBOOL continueNeeded = FALSE;\n\tsize_t len;\n\tconst char* token64 = NULL;\n\tint ntlmTokenLength = 0;\n\tBYTE* ntlmTokenData = NULL;\n\tlong StatusCode;\n\n\tif (!ntlm || !response)\n\t\treturn FALSE;\n\n\tStatusCode = http_response_get_status_code(response);\n\n\tif (StatusCode != HTTP_STATUS_DENIED)\n\t{\n\t\tWLog_DBG(TAG, \"Unexpected NTLM challenge HTTP status: %ld\", StatusCode);\n\t\treturn FALSE;\n\t}\n\n\ttoken64 = http_response_get_auth_token(response, \"NTLM\");\n\n\tif (!token64)\n\t\treturn FALSE;\n\n\tlen = strlen(token64);\n\n\tif (len > INT_MAX)\n\t\treturn FALSE;\n\n\tcrypto_base64_decode(token64, (int)len, &ntlmTokenData, &ntlmTokenLength);\n\n\tif (ntlmTokenLength < 0)\n\t{\n\t\tfree(ntlmTokenData);\n\t\treturn FALSE;\n\t}\n\n\tif (ntlmTokenData && ntlmTokenLength)\n\t{\n\t\tif (!ntlm_client_set_input_buffer(ntlm, FALSE, ntlmTokenData, (size_t)ntlmTokenLength))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!ntlm_authenticate(ntlm, &continueNeeded))\n\t\treturn FALSE;\n\n\tif (continueNeeded)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_skip_seed_payload(rdpTls* tls, SSIZE_T lastResponseLength)\n{\n\tBYTE seed_payload[10];\n\tconst size_t size = sizeof(seed_payload);\n\n\tassert(size < SSIZE_MAX);\n\n\t/* Per [MS-TSGU] 3.3.5.1 step 4, after final OK response RDG server sends\n\t * random \"seed\" payload of limited size. In practice it's 10 bytes.\n\t */\n\tif (lastResponseLength < (SSIZE_T)size)\n\t{\n\t\tif (!rdg_read_all(tls, seed_payload, size - lastResponseLength))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_handshake_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT32 errorCode;\n\tUINT16 serverVersion, extendedAuth;\n\tBYTE verMajor, verMinor;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Handshake response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_HANDSHAKE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 10\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT8(s, verMajor);\n\tStream_Read_UINT8(s, verMinor);\n\tStream_Read_UINT16(s, serverVersion);\n\tStream_Read_UINT16(s, extendedAuth);\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG,\n\t         \"errorCode=%s, verMajor=%\" PRId8 \", verMinor=%\" PRId8 \", serverVersion=%\" PRId16\n\t         \", extendedAuth=%s\",\n\t         error, verMajor, verMinor, serverVersion, extended_auth_to_string(extendedAuth));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Handshake error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_tunnel_request(rdg);\n}\n\nstatic BOOL rdg_process_tunnel_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT16 serverVersion, fieldsPresent;\n\tUINT32 errorCode;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Tunnel response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_TUNNEL_CREATE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 10\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, serverVersion);\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"serverVersion=%\" PRId16 \", errorCode=%s, fieldsPresent=%s\", serverVersion, error,\n\t         tunnel_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Tunnel creation error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_tunnel_authorization(rdg);\n}\n\nstatic BOOL rdg_process_tunnel_authorization_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT32 errorCode;\n\tUINT16 fieldsPresent;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Tunnel authorization received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_TUNNEL_AUTHORIZE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"errorCode=%s, fieldsPresent=%s\", error,\n\t         tunnel_authorization_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Tunnel authorization error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_channel_create(rdg);\n}\n\nstatic BOOL rdg_process_channel_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT16 fieldsPresent;\n\tUINT32 errorCode;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Channel response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_CHANNEL_CREATE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"channel response errorCode=%s, fieldsPresent=%s\", error,\n\t         channel_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"channel response errorCode=%s, fieldsPresent=%s\", error,\n\t\t         channel_response_fields_present_to_string(fieldsPresent));\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\trdg->state = RDG_CLIENT_STATE_OPENED;\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_packet(rdpRdg* rdg, wStream* s)\n{\n\tBOOL status = TRUE;\n\tUINT16 type;\n\tUINT32 packetLength;\n\tStream_SetPosition(s, 0);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, type);\n\tStream_Seek_UINT16(s); /* reserved */\n\tStream_Read_UINT32(s, packetLength);\n\n\tif (Stream_Length(s) < packetLength)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected %\" PRIuz, __FUNCTION__,\n\t\t         Stream_Length(s), packetLength);\n\t\treturn FALSE;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase PKT_TYPE_HANDSHAKE_RESPONSE:\n\t\t\tstatus = rdg_process_handshake_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_TUNNEL_RESPONSE:\n\t\t\tstatus = rdg_process_tunnel_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_TUNNEL_AUTH_RESPONSE:\n\t\t\tstatus = rdg_process_tunnel_authorization_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_CHANNEL_RESPONSE:\n\t\t\tstatus = rdg_process_channel_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_DATA:\n\t\t\tWLog_ERR(TAG, \"[%s] Unexpected packet type DATA\", __FUNCTION__);\n\t\t\treturn FALSE;\n\t}\n\n\treturn status;\n}\n\nDWORD rdg_get_event_handles(rdpRdg* rdg, HANDLE* events, DWORD count)\n{\n\tDWORD nCount = 0;\n\tassert(rdg != NULL);\n\n\tif (rdg->tlsOut && rdg->tlsOut->bio)\n\t{\n\t\tif (events && (nCount < count))\n\t\t{\n\t\t\tBIO_get_event(rdg->tlsOut->bio, &events[nCount]);\n\t\t\tnCount++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (rdg->tlsIn && rdg->tlsIn->bio)\n\t{\n\t\tif (events && (nCount < count))\n\t\t{\n\t\t\tBIO_get_event(rdg->tlsIn->bio, &events[nCount]);\n\t\t\tnCount++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn nCount;\n}\n\nstatic BOOL rdg_get_gateway_credentials(rdpContext* context)\n{\n\trdpSettings* settings = context->settings;\n\tfreerdp* instance = context->instance;\n\n\tif (!settings->GatewayPassword || !settings->GatewayUsername ||\n\t    !strlen(settings->GatewayPassword) || !strlen(settings->GatewayUsername))\n\t{\n\t\tif (freerdp_shall_disconnect(instance))\n\t\t\treturn FALSE;\n\n\t\tif (!instance->GatewayAuthenticate)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBOOL proceed =\n\t\t\t    instance->GatewayAuthenticate(instance, &settings->GatewayUsername,\n\t\t\t                                  &settings->GatewayPassword, &settings->GatewayDomain);\n\n\t\t\tif (!proceed)\n\t\t\t{\n\t\t\t\tfreerdp_set_last_error_log(context,\n\t\t\t\t                           FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (settings->GatewayUseSameCredentials)\n\t\t\t{\n\t\t\t\tif (settings->GatewayUsername)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Username);\n\n\t\t\t\t\tif (!(settings->Username = _strdup(settings->GatewayUsername)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (settings->GatewayDomain)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Domain);\n\n\t\t\t\t\tif (!(settings->Domain = _strdup(settings->GatewayDomain)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (settings->GatewayPassword)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Password);\n\n\t\t\t\t\tif (!(settings->Password = _strdup(settings->GatewayPassword)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_ntlm_init(rdpRdg* rdg, rdpTls* tls)\n{\n\tBOOL continueNeeded = FALSE;\n\trdpContext* context = rdg->context;\n\trdpSettings* settings = context->settings;\n\trdg->ntlm = ntlm_new();\n\n\tif (!rdg->ntlm)\n\t\treturn FALSE;\n\n\tif (!rdg_get_gateway_credentials(context))\n\t\treturn FALSE;\n\n\tif (!ntlm_client_init(rdg->ntlm, TRUE, settings->GatewayUsername, settings->GatewayDomain,\n\t                      settings->GatewayPassword, tls->Bindings))\n\t\treturn FALSE;\n\n\tif (!ntlm_client_make_spn(rdg->ntlm, _T(\"HTTP\"), settings->GatewayHostname))\n\t\treturn FALSE;\n\n\tif (!ntlm_authenticate(rdg->ntlm, &continueNeeded))\n\t\treturn FALSE;\n\n\treturn continueNeeded;\n}\n\nstatic BOOL rdg_send_http_request(rdpRdg* rdg, rdpTls* tls, const char* method,\n                                  const char* transferEncoding)\n{\n\tsize_t sz;\n\twStream* s = NULL;\n\tint status = -1;\n\ts = rdg_build_http_request(rdg, method, transferEncoding);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tsz = Stream_Length(s);\n\n\tif (sz <= INT_MAX)\n\t\tstatus = tls_write_all(tls, Stream_Buffer(s), (int)sz);\n\n\tStream_Free(s, TRUE);\n\treturn (status >= 0);\n}\n\nstatic BOOL rdg_tls_connect(rdpRdg* rdg, rdpTls* tls, const char* peerAddress, int timeout)\n{\n\tint sockfd = 0;\n\tlong status = 0;\n\tBIO* socketBio = NULL;\n\tBIO* bufferedBio = NULL;\n\trdpSettings* settings = rdg->settings;\n\tconst char* peerHostname = settings->GatewayHostname;\n\tUINT16 peerPort = (UINT16)settings->GatewayPort;\n\tconst char *proxyUsername, *proxyPassword;\n\tBOOL isProxyConnection =\n\t    proxy_prepare(settings, &peerHostname, &peerPort, &proxyUsername, &proxyPassword);\n\n\tif (settings->GatewayPort > UINT16_MAX)\n\t\treturn FALSE;\n\n\tsockfd = freerdp_tcp_connect(rdg->context, settings, peerAddress ? peerAddress : peerHostname,\n\t                             peerPort, timeout);\n\n\tif (sockfd < 0)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tsocketBio = BIO_new(BIO_s_simple_socket());\n\n\tif (!socketBio)\n\t{\n\t\tclosesocket((SOCKET)sockfd);\n\t\treturn FALSE;\n\t}\n\n\tBIO_set_fd(socketBio, sockfd, BIO_CLOSE);\n\tbufferedBio = BIO_new(BIO_s_buffered_socket());\n\n\tif (!bufferedBio)\n\t{\n\t\tBIO_free_all(socketBio);\n\t\treturn FALSE;\n\t}\n\n\tbufferedBio = BIO_push(bufferedBio, socketBio);\n\tstatus = BIO_set_nonblock(bufferedBio, TRUE);\n\n\tif (isProxyConnection)\n\t{\n\t\tif (!proxy_connect(settings, bufferedBio, proxyUsername, proxyPassword,\n\t\t                   settings->GatewayHostname, (UINT16)settings->GatewayPort))\n\t\t{\n\t\t\tBIO_free_all(bufferedBio);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (!status)\n\t{\n\t\tBIO_free_all(bufferedBio);\n\t\treturn FALSE;\n\t}\n\n\ttls->hostname = settings->GatewayHostname;\n\ttls->port = (int)settings->GatewayPort;\n\ttls->isGatewayTransport = TRUE;\n\tstatus = tls_connect(tls, bufferedBio);\n\tif (status < 1)\n\t{\n\t\trdpContext* context = rdg->context;\n\t\tif (status < 0)\n\t\t{\n\t\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_TLS_CONNECT_FAILED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_CONNECT_CANCELLED);\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\treturn (status >= 1);\n}\n\nstatic BOOL rdg_establish_data_connection(rdpRdg* rdg, rdpTls* tls, const char* method,\n                                          const char* peerAddress, int timeout, BOOL* rpcFallback)\n{\n\tHttpResponse* response = NULL;\n\tlong statusCode;\n\tSSIZE_T bodyLength;\n\tlong StatusCode;\n\n\tif (!rdg_tls_connect(rdg, tls, peerAddress, timeout))\n\t\treturn FALSE;\n\n\tif (rdg->extAuth == HTTP_EXTENDED_AUTH_NONE)\n\t{\n\t\tif (!rdg_ntlm_init(rdg, tls))\n\t\t\treturn FALSE;\n\n\t\tif (!rdg_send_http_request(rdg, tls, method, NULL))\n\t\t\treturn FALSE;\n\n\t\tresponse = http_response_recv(tls, TRUE);\n\n\t\tif (!response)\n\t\t\treturn FALSE;\n\n\t\tStatusCode = http_response_get_status_code(response);\n\n\t\tswitch (StatusCode)\n\t\t{\n\t\t\tcase HTTP_STATUS_NOT_FOUND:\n\t\t\t{\n\t\t\t\tWLog_INFO(TAG, \"RD Gateway does not support HTTP transport.\");\n\n\t\t\t\tif (rpcFallback)\n\t\t\t\t\t*rpcFallback = TRUE;\n\n\t\t\t\thttp_response_free(response);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!rdg_handle_ntlm_challenge(rdg->ntlm, response))\n\t\t{\n\t\t\thttp_response_free(response);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\thttp_response_free(response);\n\t}\n\n\tif (!rdg_send_http_request(rdg, tls, method, NULL))\n\t\treturn FALSE;\n\n\tntlm_free(rdg->ntlm);\n\trdg->ntlm = NULL;\n\tresponse = http_response_recv(tls, TRUE);\n\n\tif (!response)\n\t\treturn FALSE;\n\n\tstatusCode = http_response_get_status_code(response);\n\tbodyLength = http_response_get_body_length(response);\n\thttp_response_free(response);\n\tWLog_DBG(TAG, \"%s authorization result: %d\", method, statusCode);\n\n\tswitch (statusCode)\n\t{\n\t\tcase HTTP_STATUS_OK:\n\t\t\tbreak;\n\t\tcase HTTP_STATUS_DENIED:\n\t\t\tfreerdp_set_last_error_log(rdg->context, FREERDP_ERROR_CONNECT_ACCESS_DENIED);\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\tif (strcmp(method, \"RDG_OUT_DATA\") == 0)\n\t{\n\t\tif (!rdg_skip_seed_payload(tls, bodyLength))\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!rdg_send_http_request(rdg, tls, method, \"chunked\"))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_tunnel_connect(rdpRdg* rdg)\n{\n\tBOOL status;\n\twStream* s;\n\trdg_send_handshake(rdg);\n\n\twhile (rdg->state < RDG_CLIENT_STATE_OPENED)\n\t{\n\t\tstatus = FALSE;\n\t\ts = rdg_receive_packet(rdg);\n\n\t\tif (s)\n\t\t{\n\t\t\tstatus = rdg_process_packet(rdg, s);\n\t\t\tStream_Free(s, TRUE);\n\t\t}\n\n\t\tif (!status)\n\t\t{\n\t\t\trdg->context->rdp->transport->layer = TRANSPORT_LAYER_CLOSED;\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rdg_connect(rdpRdg* rdg, int timeout, BOOL* rpcFallback)\n{\n\tBOOL status;\n\tSOCKET outConnSocket = 0;\n\tchar* peerAddress = NULL;\n\tassert(rdg != NULL);\n\tstatus =\n\t    rdg_establish_data_connection(rdg, rdg->tlsOut, \"RDG_OUT_DATA\", NULL, timeout, rpcFallback);\n\n\tif (status)\n\t{\n\t\t/* Establish IN connection with the same peer/server as OUT connection,\n\t\t * even when server hostname resolves to different IP addresses.\n\t\t */\n\t\tBIO_get_socket(rdg->tlsOut->underlying, &outConnSocket);\n\t\tpeerAddress = freerdp_tcp_get_peer_address(outConnSocket);\n\t\tstatus = rdg_establish_data_connection(rdg, rdg->tlsIn, \"RDG_IN_DATA\", peerAddress, timeout,\n\t\t                                       NULL);\n\t\tfree(peerAddress);\n\t}\n\n\tif (!status)\n\t{\n\t\trdg->context->rdp->transport->layer = TRANSPORT_LAYER_CLOSED;\n\t\treturn FALSE;\n\t}\n\n\tstatus = rdg_tunnel_connect(rdg);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic int rdg_write_data_packet(rdpRdg* rdg, const BYTE* buf, int isize)\n{\n\tint status;\n\tsize_t s;\n\twStream* sChunk;\n\tsize_t size = (size_t)isize;\n\tsize_t packetSize = size + 10;\n\tchar chunkSize[11];\n\n\tif ((isize < 0) || (isize > UINT16_MAX))\n\t\treturn -1;\n\n\tif (size < 1)\n\t\treturn 0;\n\n\tsprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIxz \"\\r\\n\", packetSize);\n\tsChunk = Stream_New(NULL, strnlen(chunkSize, sizeof(chunkSize)) + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn -1;\n\n\tStream_Write(sChunk, chunkSize, strnlen(chunkSize, sizeof(chunkSize)));\n\tStream_Write_UINT16(sChunk, PKT_TYPE_DATA);      /* Type */\n\tStream_Write_UINT16(sChunk, 0);                  /* Reserved */\n\tStream_Write_UINT32(sChunk, (UINT32)packetSize); /* Packet length */\n\tStream_Write_UINT16(sChunk, (UINT16)size);       /* Data size */\n\tStream_Write(sChunk, buf, size);                 /* Data */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s > INT_MAX)\n\t\treturn -1;\n\n\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\tStream_Free(sChunk, TRUE);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\treturn (int)size;\n}\n\nstatic BOOL rdg_process_close_packet(rdpRdg* rdg)\n{\n\tint status = -1;\n\tsize_t s;\n\twStream* sChunk;\n\tUINT32 packetSize = 12;\n\tchar chunkSize[11];\n\tint chunkLen = sprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIx32 \"\\r\\n\", packetSize);\n\n\tif (chunkLen < 0)\n\t\treturn FALSE;\n\n\tsChunk = Stream_New(NULL, (size_t)chunkLen + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, (size_t)chunkLen);\n\tStream_Write_UINT16(sChunk, PKT_TYPE_CLOSE_CHANNEL_RESPONSE); /* Type */\n\tStream_Write_UINT16(sChunk, 0);                               /* Reserved */\n\tStream_Write_UINT32(sChunk, packetSize);                      /* Packet length */\n\tStream_Write_UINT32(sChunk, 0);                               /* Status code */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s <= INT_MAX)\n\t\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\n\tStream_Free(sChunk, TRUE);\n\treturn (status < 0 ? FALSE : TRUE);\n}\n\nstatic BOOL rdg_process_keep_alive_packet(rdpRdg* rdg)\n{\n\tint status = -1;\n\tsize_t s;\n\twStream* sChunk;\n\tsize_t packetSize = 8;\n\tchar chunkSize[11];\n\tint chunkLen = sprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIxz \"\\r\\n\", packetSize);\n\n\tif ((chunkLen < 0) || (packetSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tsChunk = Stream_New(NULL, (size_t)chunkLen + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, (size_t)chunkLen);\n\tStream_Write_UINT16(sChunk, PKT_TYPE_KEEPALIVE); /* Type */\n\tStream_Write_UINT16(sChunk, 0);                  /* Reserved */\n\tStream_Write_UINT32(sChunk, (UINT32)packetSize); /* Packet length */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s <= INT_MAX)\n\t\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\n\tStream_Free(sChunk, TRUE);\n\treturn (status < 0 ? FALSE : TRUE);\n}\n\nstatic BOOL rdg_process_unknown_packet(rdpRdg* rdg, int type)\n{\n\tWINPR_UNUSED(rdg);\n\tWINPR_UNUSED(type);\n\tWLog_WARN(TAG, \"Unknown Control Packet received: %X\", type);\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_control_packet(rdpRdg* rdg, int type, size_t packetLength)\n{\n\twStream* s = NULL;\n\tsize_t readCount = 0;\n\tint status;\n\tsize_t payloadSize = packetLength - sizeof(RdgPacketHeader);\n\n\tif (packetLength < sizeof(RdgPacketHeader))\n\t\treturn FALSE;\n\n\tassert(sizeof(RdgPacketHeader) < INT_MAX);\n\n\tif (payloadSize)\n\t{\n\t\ts = Stream_New(NULL, payloadSize);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\twhile (readCount < payloadSize)\n\t\t{\n\t\t\tstatus =\n\t\t\t    BIO_read(rdg->tlsOut->bio, Stream_Pointer(s), (int)payloadSize - (int)readCount);\n\n\t\t\tif (status <= 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t{\n\t\t\t\t\tStream_Free(s, TRUE);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStream_Seek(s, (size_t)status);\n\t\t\treadCount += (size_t)status;\n\n\t\t\tif (readCount > INT_MAX)\n\t\t\t{\n\t\t\t\tStream_Free(s, TRUE);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase PKT_TYPE_CLOSE_CHANNEL:\n\t\t\tEnterCriticalSection(&rdg->writeSection);\n\t\t\tstatus = rdg_process_close_packet(rdg);\n\t\t\tLeaveCriticalSection(&rdg->writeSection);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_KEEPALIVE:\n\t\t\tEnterCriticalSection(&rdg->writeSection);\n\t\t\tstatus = rdg_process_keep_alive_packet(rdg);\n\t\t\tLeaveCriticalSection(&rdg->writeSection);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstatus = rdg_process_unknown_packet(rdg, type);\n\t\t\tbreak;\n\t}\n\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\nstatic int rdg_read_data_packet(rdpRdg* rdg, BYTE* buffer, int size)\n{\n\tRdgPacketHeader header;\n\tsize_t readCount = 0;\n\tint readSize;\n\tint status;\n\n\tif (!rdg->packetRemainingCount)\n\t{\n\t\tassert(sizeof(RdgPacketHeader) < INT_MAX);\n\n\t\twhile (readCount < sizeof(RdgPacketHeader))\n\t\t{\n\t\t\tstatus = BIO_read(rdg->tlsOut->bio, (BYTE*)(&header) + readCount,\n\t\t\t                  (int)sizeof(RdgPacketHeader) - (int)readCount);\n\n\t\t\tif (status <= 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tif (!readCount)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tBIO_wait_read(rdg->tlsOut->bio, 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treadCount += (size_t)status;\n\n\t\t\tif (readCount > INT_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (header.type != PKT_TYPE_DATA)\n\t\t{\n\t\t\tstatus = rdg_process_control_packet(rdg, header.type, header.packetLength);\n\n\t\t\tif (!status)\n\t\t\t\treturn -1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treadCount = 0;\n\n\t\twhile (readCount < 2)\n\t\t{\n\t\t\tstatus = BIO_read(rdg->tlsOut->bio, (BYTE*)(&rdg->packetRemainingCount) + readCount,\n\t\t\t                  2 - (int)readCount);\n\n\t\t\tif (status < 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tBIO_wait_read(rdg->tlsOut->bio, 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treadCount += (size_t)status;\n\t\t}\n\t}\n\n\treadSize = (rdg->packetRemainingCount < size ? rdg->packetRemainingCount : size);\n\tstatus = BIO_read(rdg->tlsOut->bio, buffer, readSize);\n\n\tif (status <= 0)\n\t{\n\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trdg->packetRemainingCount -= status;\n\treturn status;\n}\n\nstatic int rdg_bio_write(BIO* bio, const char* buf, int num)\n{\n\tint status;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\tBIO_clear_flags(bio, BIO_FLAGS_WRITE);\n\tEnterCriticalSection(&rdg->writeSection);\n\tstatus = rdg_write_data_packet(rdg, (const BYTE*)buf, num);\n\tLeaveCriticalSection(&rdg->writeSection);\n\n\tif (status < 0)\n\t{\n\t\tBIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY);\n\t\treturn -1;\n\t}\n\telse if (status < num)\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_WRITE);\n\t\tWSASetLastError(WSAEWOULDBLOCK);\n\t}\n\telse\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_WRITE);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_read(BIO* bio, char* buf, int size)\n{\n\tint status;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\tstatus = rdg_read_data_packet(rdg, (BYTE*)buf, size);\n\n\tif (status < 0)\n\t{\n\t\tBIO_clear_retry_flags(bio);\n\t\treturn -1;\n\t}\n\telse if (status == 0)\n\t{\n\t\tBIO_set_retry_read(bio);\n\t\tWSASetLastError(WSAEWOULDBLOCK);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_READ);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_puts(BIO* bio, const char* str)\n{\n\tWINPR_UNUSED(bio);\n\tWINPR_UNUSED(str);\n\treturn -2;\n}\n\nstatic int rdg_bio_gets(BIO* bio, char* str, int size)\n{\n\tWINPR_UNUSED(bio);\n\tWINPR_UNUSED(str);\n\tWINPR_UNUSED(size);\n\treturn -2;\n}\n\nstatic long rdg_bio_ctrl(BIO* bio, int cmd, long arg1, void* arg2)\n{\n\tlong status = -1;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\trdpTls* tlsOut = rdg->tlsOut;\n\trdpTls* tlsIn = rdg->tlsIn;\n\n\tif (cmd == BIO_CTRL_FLUSH)\n\t{\n\t\t(void)BIO_flush(tlsOut->bio);\n\t\t(void)BIO_flush(tlsIn->bio);\n\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_SET_NONBLOCK)\n\t{\n\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_READ_BLOCKED)\n\t{\n\t\tBIO* bio = tlsOut->bio;\n\t\tstatus = BIO_read_blocked(bio);\n\t}\n\telse if (cmd == BIO_C_WRITE_BLOCKED)\n\t{\n\t\tBIO* bio = tlsIn->bio;\n\t\tstatus = BIO_write_blocked(bio);\n\t}\n\telse if (cmd == BIO_C_WAIT_READ)\n\t{\n\t\tint timeout = (int)arg1;\n\t\tBIO* bio = tlsOut->bio;\n\n\t\tif (BIO_read_blocked(bio))\n\t\t\treturn BIO_wait_read(bio, timeout);\n\t\telse if (BIO_write_blocked(bio))\n\t\t\treturn BIO_wait_write(bio, timeout);\n\t\telse\n\t\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_WAIT_WRITE)\n\t{\n\t\tint timeout = (int)arg1;\n\t\tBIO* bio = tlsIn->bio;\n\n\t\tif (BIO_write_blocked(bio))\n\t\t\tstatus = BIO_wait_write(bio, timeout);\n\t\telse if (BIO_read_blocked(bio))\n\t\t\tstatus = BIO_wait_read(bio, timeout);\n\t\telse\n\t\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_GET_EVENT || cmd == BIO_C_GET_FD)\n\t{\n\t\t/*\n\t\t * A note about BIO_C_GET_FD:\n\t\t * Even if two FDs are part of RDG, only one FD can be returned here.\n\t\t *\n\t\t * In FreeRDP, BIO FDs are only used for polling, so it is safe to use the outgoing FD only\n\t\t *\n\t\t * See issue #3602\n\t\t */\n\t\tstatus = BIO_ctrl(tlsOut->bio, cmd, arg1, arg2);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_new(BIO* bio)\n{\n\tBIO_set_init(bio, 1);\n\tBIO_set_flags(bio, BIO_FLAGS_SHOULD_RETRY);\n\treturn 1;\n}\n\nstatic int rdg_bio_free(BIO* bio)\n{\n\tWINPR_UNUSED(bio);\n\treturn 1;\n}\n\nstatic BIO_METHOD* BIO_s_rdg(void)\n{\n\tstatic BIO_METHOD* bio_methods = NULL;\n\n\tif (bio_methods == NULL)\n\t{\n\t\tif (!(bio_methods = BIO_meth_new(BIO_TYPE_TSG, \"RDGateway\")))\n\t\t\treturn NULL;\n\n\t\tBIO_meth_set_write(bio_methods, rdg_bio_write);\n\t\tBIO_meth_set_read(bio_methods, rdg_bio_read);\n\t\tBIO_meth_set_puts(bio_methods, rdg_bio_puts);\n\t\tBIO_meth_set_gets(bio_methods, rdg_bio_gets);\n\t\tBIO_meth_set_ctrl(bio_methods, rdg_bio_ctrl);\n\t\tBIO_meth_set_create(bio_methods, rdg_bio_new);\n\t\tBIO_meth_set_destroy(bio_methods, rdg_bio_free);\n\t}\n\n\treturn bio_methods;\n}\n\nrdpRdg* rdg_new(rdpContext* context)\n{\n\trdpRdg* rdg;\n\tRPC_CSTR stringUuid;\n\tchar bracedUuid[40];\n\tRPC_STATUS rpcStatus;\n\n\tif (!context)\n\t\treturn NULL;\n\n\trdg = (rdpRdg*)calloc(1, sizeof(rdpRdg));\n\n\tif (rdg)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_INITIAL;\n\t\trdg->context = context;\n\t\trdg->settings = rdg->context->settings;\n\t\trdg->extAuth = HTTP_EXTENDED_AUTH_NONE;\n\n\t\tif (rdg->settings->GatewayAccessToken)\n\t\t\trdg->extAuth = HTTP_EXTENDED_AUTH_PAA;\n\n\t\tUuidCreate(&rdg->guid);\n\t\trpcStatus = UuidToStringA(&rdg->guid, &stringUuid);\n\n\t\tif (rpcStatus == RPC_S_OUT_OF_MEMORY)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tsprintf_s(bracedUuid, sizeof(bracedUuid), \"{%s}\", stringUuid);\n\t\tRpcStringFreeA(&stringUuid);\n\t\trdg->tlsOut = tls_new(rdg->settings);\n\n\t\tif (!rdg->tlsOut)\n\t\t\tgoto rdg_alloc_error;\n\n\t\trdg->tlsIn = tls_new(rdg->settings);\n\n\t\tif (!rdg->tlsIn)\n\t\t\tgoto rdg_alloc_error;\n\n\t\trdg->http = http_context_new();\n\n\t\tif (!rdg->http)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tif (!http_context_set_uri(rdg->http, \"/remoteDesktopGateway/\") ||\n\t\t    !http_context_set_accept(rdg->http, \"*/*\") ||\n\t\t    !http_context_set_cache_control(rdg->http, \"no-cache\") ||\n\t\t    !http_context_set_pragma(rdg->http, \"no-cache\") ||\n\t\t    !http_context_set_connection(rdg->http, \"Keep-Alive\") ||\n\t\t    !http_context_set_user_agent(rdg->http, \"MS-RDGateway/1.0\") ||\n\t\t    !http_context_set_host(rdg->http, rdg->settings->GatewayHostname) ||\n\t\t    !http_context_set_rdg_connection_id(rdg->http, bracedUuid))\n\t\t{\n\t\t\tgoto rdg_alloc_error;\n\t\t}\n\n\t\tif (rdg->extAuth != HTTP_EXTENDED_AUTH_NONE)\n\t\t{\n\t\t\tswitch (rdg->extAuth)\n\t\t\t{\n\t\t\t\tcase HTTP_EXTENDED_AUTH_PAA:\n\t\t\t\t\tif (!http_context_set_rdg_auth_scheme(rdg->http, \"PAA\"))\n\t\t\t\t\t\tgoto rdg_alloc_error;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_DBG(TAG, \"RDG extended authentication method %d not supported\",\n\t\t\t\t\t         rdg->extAuth);\n\t\t\t}\n\t\t}\n\n\t\trdg->frontBio = BIO_new(BIO_s_rdg());\n\n\t\tif (!rdg->frontBio)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tBIO_set_data(rdg->frontBio, rdg);\n\t\tInitializeCriticalSection(&rdg->writeSection);\n\t}\n\n\treturn rdg;\nrdg_alloc_error:\n\trdg_free(rdg);\n\treturn NULL;\n}\n\nvoid rdg_free(rdpRdg* rdg)\n{\n\tif (!rdg)\n\t\treturn;\n\n\ttls_free(rdg->tlsOut);\n\ttls_free(rdg->tlsIn);\n\thttp_context_free(rdg->http);\n\tntlm_free(rdg->ntlm);\n\n\tif (!rdg->attached)\n\t\tBIO_free_all(rdg->frontBio);\n\n\tDeleteCriticalSection(&rdg->writeSection);\n\tfree(rdg);\n}\n\nBIO* rdg_get_front_bio_and_take_ownership(rdpRdg* rdg)\n{\n\tif (!rdg)\n\t\treturn NULL;\n\n\trdg->attached = TRUE;\n\treturn rdg->frontBio;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Protocol Security Negotiation\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"tpkt.h\"\n\n#include \"nego.h\"\n\n#include \"transport.h\"\n\n#define TAG FREERDP_TAG(\"core.nego\")\n\nstruct rdp_nego\n{\n\tUINT16 port;\n\tUINT32 flags;\n\tconst char* hostname;\n\tchar* cookie;\n\tBYTE* RoutingToken;\n\tDWORD RoutingTokenLength;\n\tBOOL SendPreconnectionPdu;\n\tUINT32 PreconnectionId;\n\tchar* PreconnectionBlob;\n\n\tNEGO_STATE state;\n\tBOOL TcpConnected;\n\tBOOL SecurityConnected;\n\tUINT32 CookieMaxLength;\n\n\tBOOL sendNegoData;\n\tUINT32 SelectedProtocol;\n\tUINT32 RequestedProtocols;\n\tBOOL NegotiateSecurityLayer;\n\tBOOL EnabledProtocols[16];\n\tBOOL RestrictedAdminModeRequired;\n\tBOOL GatewayEnabled;\n\tBOOL GatewayBypassLocal;\n\n\trdpTransport* transport;\n};\n\nstatic const char* nego_state_string(NEGO_STATE state)\n{\n\tstatic const char* const NEGO_STATE_STRINGS[] = { \"NEGO_STATE_INITIAL\", \"NEGO_STATE_EXT\",\n\t\t                                              \"NEGO_STATE_NLA\",     \"NEGO_STATE_TLS\",\n\t\t                                              \"NEGO_STATE_RDP\",     \"NEGO_STATE_FAIL\",\n\t\t                                              \"NEGO_STATE_FINAL\",   \"NEGO_STATE_INVALID\" };\n\tif (state >= ARRAYSIZE(NEGO_STATE_STRINGS))\n\t\treturn NEGO_STATE_STRINGS[ARRAYSIZE(NEGO_STATE_STRINGS) - 1];\n\treturn NEGO_STATE_STRINGS[state];\n}\n\nstatic const char* protocol_security_string(UINT32 security)\n{\n\tstatic const char* PROTOCOL_SECURITY_STRINGS[] = { \"RDP\", \"TLS\", \"NLA\", \"UNK\", \"UNK\",\n\t\t                                               \"UNK\", \"UNK\", \"UNK\", \"EXT\", \"UNK\" };\n\tif (security >= ARRAYSIZE(PROTOCOL_SECURITY_STRINGS))\n\t\treturn PROTOCOL_SECURITY_STRINGS[ARRAYSIZE(PROTOCOL_SECURITY_STRINGS) - 1];\n\treturn PROTOCOL_SECURITY_STRINGS[security];\n}\n\nstatic BOOL nego_transport_connect(rdpNego* nego);\nstatic BOOL nego_transport_disconnect(rdpNego* nego);\nstatic BOOL nego_security_connect(rdpNego* nego);\nstatic BOOL nego_send_preconnection_pdu(rdpNego* nego);\nstatic BOOL nego_recv_response(rdpNego* nego);\nstatic void nego_send(rdpNego* nego);\nstatic void nego_process_negotiation_request(rdpNego* nego, wStream* s);\nstatic void nego_process_negotiation_response(rdpNego* nego, wStream* s);\nstatic void nego_process_negotiation_failure(rdpNego* nego, wStream* s);\n\n/**\n * Negotiate protocol security and connect.\n * @param nego\n * @return\n */\n\nBOOL nego_connect(rdpNego* nego)\n{\n\trdpSettings* settings = nego->transport->settings;\n\n\tif (nego->state == NEGO_STATE_INITIAL)\n\t{\n\t\tif (nego->EnabledProtocols[PROTOCOL_HYBRID_EX])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_EXT;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_HYBRID])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_NLA;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"No security protocol is enabled\");\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!nego->NegotiateSecurityLayer)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Security Layer Negotiation is disabled\");\n\t\t\t/* attempt only the highest enabled protocol (see nego_attempt_*) */\n\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_SSL] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_RDP] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = FALSE;\n\n\t\t\tif (nego->state == NEGO_STATE_EXT)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = TRUE;\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_HYBRID_EX;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_NLA)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_HYBRID;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_TLS)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_SSL] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_SSL;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_RDP)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_RDP] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_RDP;\n\t\t\t}\n\t\t}\n\n\t\tif (nego->SendPreconnectionPdu)\n\t\t{\n\t\t\tif (!nego_send_preconnection_pdu(nego))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to send preconnection pdu\");\n\t\t\t\tnego->state = NEGO_STATE_FINAL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nego->NegotiateSecurityLayer)\n\t{\n\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tdo\n\t\t{\n\t\t\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\t\t\tnego_send(nego);\n\n\t\t\tif (nego->state == NEGO_STATE_FAIL)\n\t\t\t{\n\t\t\t\tif (freerdp_get_last_error(nego->transport->context) == FREERDP_ERROR_SUCCESS)\n\t\t\t\t\tWLog_ERR(TAG, \"Protocol Security Negotiation Failure\");\n\n\t\t\t\tnego->state = NEGO_STATE_FINAL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} while (nego->state != NEGO_STATE_FINAL);\n\t}\n\n\tWLog_DBG(TAG, \"Negotiated %s security\", protocol_security_string(nego->SelectedProtocol));\n\t/* update settings with negotiated protocol security */\n\tsettings->RequestedProtocols = nego->RequestedProtocols;\n\tsettings->SelectedProtocol = nego->SelectedProtocol;\n\tsettings->NegotiationFlags = nego->flags;\n\n\tif (nego->SelectedProtocol == PROTOCOL_RDP)\n\t{\n\t\tsettings->UseRdpSecurityLayer = TRUE;\n\n\t\tif (!settings->EncryptionMethods)\n\t\t{\n\t\t\t/**\n\t\t\t * Advertise all supported encryption methods if the client\n\t\t\t * implementation did not set any security methods\n\t\t\t */\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_40BIT | ENCRYPTION_METHOD_56BIT |\n\t\t\t                              ENCRYPTION_METHOD_128BIT | ENCRYPTION_METHOD_FIPS;\n\t\t}\n\t}\n\n\t/* finally connect security layer (if not already done) */\n\tif (!nego_security_connect(nego))\n\t{\n\t\tWLog_DBG(TAG, \"Failed to connect with %s security\",\n\t\t         protocol_security_string(nego->SelectedProtocol));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL nego_disconnect(rdpNego* nego)\n{\n\tnego->state = NEGO_STATE_INITIAL;\n\treturn nego_transport_disconnect(nego);\n}\n\n/* connect to selected security layer */\nBOOL nego_security_connect(rdpNego* nego)\n{\n\tif (!nego->TcpConnected)\n\t{\n\t\tnego->SecurityConnected = FALSE;\n\t}\n\telse if (!nego->SecurityConnected)\n\t{\n\t\tif (nego->SelectedProtocol == PROTOCOL_HYBRID)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_HYBRID\");\n\t\t\tnego->SecurityConnected = transport_connect_nla(nego->transport);\n\t\t}\n\t\telse if (nego->SelectedProtocol == PROTOCOL_SSL)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_SSL\");\n\t\t\tnego->SecurityConnected = transport_connect_tls(nego->transport);\n\t\t}\n\t\telse if (nego->SelectedProtocol == PROTOCOL_RDP)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_RDP\");\n\t\t\tnego->SecurityConnected = transport_connect_rdp(nego->transport);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"cannot connect security layer because no protocol has been selected yet.\");\n\t\t}\n\t}\n\n\treturn nego->SecurityConnected;\n}\n\n/**\n * Connect TCP layer.\n * @param nego\n * @return\n */\n\nstatic BOOL nego_tcp_connect(rdpNego* nego)\n{\n\tif (!nego->TcpConnected)\n\t{\n\t\tif (nego->GatewayEnabled)\n\t\t{\n\t\t\tif (nego->GatewayBypassLocal)\n\t\t\t{\n\t\t\t\t/* Attempt a direct connection first, and then fallback to using the gateway */\n\t\t\t\tWLog_INFO(TAG,\n\t\t\t\t          \"Detecting if host can be reached locally. - This might take some time.\");\n\t\t\t\tWLog_INFO(TAG, \"To disable auto detection use /gateway-usage-method:direct\");\n\t\t\t\ttransport_set_gateway_enabled(nego->transport, FALSE);\n\t\t\t\tnego->TcpConnected =\n\t\t\t\t    transport_connect(nego->transport, nego->hostname, nego->port, 1);\n\t\t\t}\n\n\t\t\tif (!nego->TcpConnected)\n\t\t\t{\n\t\t\t\ttransport_set_gateway_enabled(nego->transport, TRUE);\n\t\t\t\tnego->TcpConnected =\n\t\t\t\t    transport_connect(nego->transport, nego->hostname, nego->port, 15);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnego->TcpConnected = transport_connect(nego->transport, nego->hostname, nego->port, 15);\n\t\t}\n\t}\n\n\treturn nego->TcpConnected;\n}\n\n/**\n * Connect TCP layer. For direct approach, connect security layer as well.\n * @param nego\n * @return\n */\n\nBOOL nego_transport_connect(rdpNego* nego)\n{\n\tif (!nego_tcp_connect(nego))\n\t\treturn FALSE;\n\n\tif (nego->TcpConnected && !nego->NegotiateSecurityLayer)\n\t\treturn nego_security_connect(nego);\n\n\treturn nego->TcpConnected;\n}\n\n/**\n * Disconnect TCP layer.\n * @param nego\n * @return\n */\n\nBOOL nego_transport_disconnect(rdpNego* nego)\n{\n\tif (nego->TcpConnected)\n\t\ttransport_disconnect(nego->transport);\n\n\tnego->TcpConnected = FALSE;\n\tnego->SecurityConnected = FALSE;\n\treturn TRUE;\n}\n\n/**\n * Send preconnection information if enabled.\n * @param nego\n * @return\n */\n\nBOOL nego_send_preconnection_pdu(rdpNego* nego)\n{\n\twStream* s;\n\tUINT32 cbSize;\n\tUINT16 cchPCB = 0;\n\tWCHAR* wszPCB = NULL;\n\tWLog_DBG(TAG, \"Sending preconnection PDU\");\n\n\tif (!nego_tcp_connect(nego))\n\t\treturn FALSE;\n\n\t/* it's easier to always send the version 2 PDU, and it's just 2 bytes overhead */\n\tcbSize = PRECONNECTION_PDU_V2_MIN_SIZE;\n\n\tif (nego->PreconnectionBlob)\n\t{\n\t\tcchPCB = (UINT16)ConvertToUnicode(CP_UTF8, 0, nego->PreconnectionBlob, -1, &wszPCB, 0);\n\t\tcchPCB += 1; /* zero-termination */\n\t\tcbSize += cchPCB * 2;\n\t}\n\n\ts = Stream_New(NULL, cbSize);\n\n\tif (!s)\n\t{\n\t\tfree(wszPCB);\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT32(s, cbSize);                /* cbSize */\n\tStream_Write_UINT32(s, 0);                     /* Flags */\n\tStream_Write_UINT32(s, PRECONNECTION_PDU_V2);  /* Version */\n\tStream_Write_UINT32(s, nego->PreconnectionId); /* Id */\n\tStream_Write_UINT16(s, cchPCB);                /* cchPCB */\n\n\tif (wszPCB)\n\t{\n\t\tStream_Write(s, wszPCB, cchPCB * 2); /* wszPCB */\n\t\tfree(wszPCB);\n\t}\n\n\tStream_SealLength(s);\n\n\tif (transport_write(nego->transport, s) < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\n/**\n * Attempt negotiating NLA + TLS extended security.\n * @param nego\n */\n\nstatic void nego_attempt_ext(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_HYBRID | PROTOCOL_SSL | PROTOCOL_HYBRID_EX;\n\tWLog_DBG(TAG, \"Attempting NLA extended security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_HYBRID])\n\t\t\tnego->state = NEGO_STATE_NLA;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating NLA + TLS security.\n * @param nego\n */\n\nstatic void nego_attempt_nla(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_HYBRID | PROTOCOL_SSL;\n\tWLog_DBG(TAG, \"Attempting NLA security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating TLS security.\n * @param nego\n */\n\nstatic void nego_attempt_tls(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_SSL;\n\tWLog_DBG(TAG, \"Attempting TLS security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating standard RDP security.\n * @param nego\n */\n\nstatic void nego_attempt_rdp(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_RDP;\n\tWLog_DBG(TAG, \"Attempting RDP security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n}\n\n/**\n * Wait to receive a negotiation response\n * @param nego\n */\n\nBOOL nego_recv_response(rdpNego* nego)\n{\n\tint status;\n\twStream* s;\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tstatus = transport_read_pdu(nego->transport, s);\n\n\tif (status < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tstatus = nego_recv(nego->transport, s, nego);\n\tStream_Free(s, TRUE);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Receive protocol security negotiation message.\\n\n * @msdn{cc240501}\n * @param transport transport\n * @param s stream\n * @param extra nego pointer\n */\n\nint nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\n\tif (li > 6)\n\t{\n\t\t/* rdpNegData (optional) */\n\t\tStream_Read_UINT8(s, type); /* Type */\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\n\t\t\t\t/* enhanced security selected ? */\n\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\n/**\n * Read optional routing token or cookie of X.224 Connection Request PDU.\n * @msdn{cc240470}\n * @param nego\n * @param s stream\n */\n\nstatic BOOL nego_read_request_token_or_cookie(rdpNego* nego, wStream* s)\n{\n\t/* routingToken and cookie are optional and mutually exclusive!\n\t *\n\t * routingToken (variable): An optional and variable-length routing\n\t * token (used for load balancing) terminated by a 0x0D0A two-byte\n\t * sequence: (check [MSFT-SDLBTS] for details!)\n\t * Cookie:[space]msts=[ip address].[port].[reserved][\\x0D\\x0A]\n\t *\n\t * cookie (variable): An optional and variable-length ANSI character\n\t * string terminated by a 0x0D0A two-byte sequence:\n\t * Cookie:[space]mstshash=[ANSISTRING][\\x0D\\x0A]\n\t */\n\tBYTE* str = NULL;\n\tUINT16 crlf = 0;\n\tsize_t pos, len;\n\tBOOL result = FALSE;\n\tBOOL isToken = FALSE;\n\tsize_t remain = Stream_GetRemainingLength(s);\n\tstr = Stream_Pointer(s);\n\tpos = Stream_GetPosition(s);\n\n\t/* minimum length for token is 15 */\n\tif (remain < 15)\n\t\treturn TRUE;\n\n\tif (memcmp(Stream_Pointer(s), \"Cookie: mstshash=\", 17) != 0)\n\t{\n\t\tisToken = TRUE;\n\t}\n\telse\n\t{\n\t\t/* not a token, minimum length for cookie is 19 */\n\t\tif (remain < 19)\n\t\t\treturn TRUE;\n\n\t\tStream_Seek(s, 17);\n\t}\n\n\twhile ((remain = Stream_GetRemainingLength(s)) >= 2)\n\t{\n\t\tStream_Read_UINT16(s, crlf);\n\n\t\tif (crlf == 0x0A0D)\n\t\t\tbreak;\n\n\t\tStream_Rewind(s, 1);\n\t}\n\n\tif (crlf == 0x0A0D)\n\t{\n\t\tStream_Rewind(s, 2);\n\t\tlen = Stream_GetPosition(s) - pos;\n\t\tremain = Stream_GetRemainingLength(s);\n\t\tStream_Write_UINT16(s, 0);\n\n\t\tif (strnlen((char*)str, len) == len)\n\t\t{\n\t\t\tif (isToken)\n\t\t\t\tresult = nego_set_routing_token(nego, str, len);\n\t\t\telse\n\t\t\t\tresult = nego_set_cookie(nego, (char*)str);\n\t\t}\n\t}\n\n\tif (!result)\n\t{\n\t\tStream_SetPosition(s, pos);\n\t\tWLog_ERR(TAG, \"invalid %s received\", isToken ? \"routing token\" : \"cookie\");\n\t}\n\telse\n\t{\n\t\tWLog_DBG(TAG, \"received %s [%s]\", isToken ? \"routing token\" : \"cookie\", str);\n\t}\n\n\treturn result;\n}\n\n/**\n * Read protocol security negotiation request message.\\n\n * @param nego\n * @param s stream\n */\n\nBOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\t/* rdpNegData (optional) */\n\t\tStream_Read_UINT8(s, type); /* Type */\n\n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\n\treturn tpkt_ensure_stream_consumed(s, length);\n}\n\n/**\n * Send protocol security negotiation message.\n * @param nego\n */\n\nvoid nego_send(rdpNego* nego)\n{\n\tif (nego->state == NEGO_STATE_EXT)\n\t\tnego_attempt_ext(nego);\n\telse if (nego->state == NEGO_STATE_NLA)\n\t\tnego_attempt_nla(nego);\n\telse if (nego->state == NEGO_STATE_TLS)\n\t\tnego_attempt_tls(nego);\n\telse if (nego->state == NEGO_STATE_RDP)\n\t\tnego_attempt_rdp(nego);\n\telse\n\t\tWLog_ERR(TAG, \"invalid negotiation state for sending\");\n}\n\n/**\n * Send RDP Negotiation Request (RDP_NEG_REQ).\\n\n * @msdn{cc240500}\\n\n * @msdn{cc240470}\n * @param nego\n */\n\nBOOL nego_send_negotiation_request(rdpNego* nego)\n{\n\tBOOL rc = FALSE;\n\twStream* s;\n\tsize_t length;\n\tsize_t bm, em;\n\tBYTE flags = 0;\n\tsize_t cookie_length;\n\ts = Stream_New(NULL, 512);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tlength = TPDU_CONNECTION_REQUEST_LENGTH;\n\tbm = Stream_GetPosition(s);\n\tStream_Seek(s, length);\n\n\tif (nego->RoutingToken)\n\t{\n\t\tStream_Write(s, nego->RoutingToken, nego->RoutingTokenLength);\n\n\t\t/* Ensure Routing Token is correctly terminated - may already be present in string */\n\n\t\tif ((nego->RoutingTokenLength > 2) &&\n\t\t    (nego->RoutingToken[nego->RoutingTokenLength - 2] == 0x0D) &&\n\t\t    (nego->RoutingToken[nego->RoutingTokenLength - 1] == 0x0A))\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Routing token looks correctly terminated - use verbatim\");\n\t\t\tlength += nego->RoutingTokenLength;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Adding terminating CRLF to routing token\");\n\t\t\tStream_Write_UINT8(s, 0x0D); /* CR */\n\t\t\tStream_Write_UINT8(s, 0x0A); /* LF */\n\t\t\tlength += nego->RoutingTokenLength + 2;\n\t\t}\n\t}\n\telse if (nego->cookie)\n\t{\n\t\tcookie_length = strlen(nego->cookie);\n\n\t\tif (cookie_length > nego->CookieMaxLength)\n\t\t\tcookie_length = nego->CookieMaxLength;\n\n\t\tStream_Write(s, \"Cookie: mstshash=\", 17);\n\t\tStream_Write(s, (BYTE*)nego->cookie, cookie_length);\n\t\tStream_Write_UINT8(s, 0x0D); /* CR */\n\t\tStream_Write_UINT8(s, 0x0A); /* LF */\n\t\tlength += cookie_length + 19;\n\t}\n\n\tWLog_DBG(TAG, \"RequestedProtocols: %\" PRIu32 \"\", nego->RequestedProtocols);\n\n\tif ((nego->RequestedProtocols > PROTOCOL_RDP) || (nego->sendNegoData))\n\t{\n\t\t/* RDP_NEG_DATA must be present for TLS and NLA */\n\t\tif (nego->RestrictedAdminModeRequired)\n\t\t\tflags |= RESTRICTED_ADMIN_MODE_REQUIRED;\n\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_REQ);\n\t\tStream_Write_UINT8(s, flags);\n\t\tStream_Write_UINT16(s, 8);                        /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, nego->RequestedProtocols); /* requestedProtocols */\n\t\tlength += 8;\n\t}\n\n\tif (length > UINT16_MAX)\n\t\tgoto fail;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\ttpkt_write_header(s, (UINT16)length);\n\ttpdu_write_connection_request(s, (UINT16)length - 5);\n\tStream_SetPosition(s, em);\n\tStream_SealLength(s);\n\trc = (transport_write(nego->transport, s) >= 0);\nfail:\n\tStream_Free(s, TRUE);\n\treturn rc;\n}\n\n/**\n * Process Negotiation Request from Connection Request message.\n * @param nego\n * @param s\n */\n\nvoid nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}\n\n/**\n * Process Negotiation Response from Connection Confirm message.\n * @param nego\n * @param s\n */\n\nvoid nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}\n\n/**\n * Process Negotiation Failure from Connection Confirm message.\n * @param nego\n * @param s\n */\n\nvoid nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n}\n\n/**\n * Send RDP Negotiation Response (RDP_NEG_RSP).\\n\n * @param nego\n */\n\nBOOL nego_send_negotiation_response(rdpNego* nego)\n{\n\tUINT16 length;\n\tsize_t bm, em;\n\tBOOL status;\n\twStream* s;\n\tBYTE flags;\n\trdpSettings* settings;\n\tstatus = TRUE;\n\tsettings = nego->transport->settings;\n\ts = Stream_New(NULL, 512);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tlength = TPDU_CONNECTION_CONFIRM_LENGTH;\n\tbm = Stream_GetPosition(s);\n\tStream_Seek(s, length);\n\n\tif (nego->SelectedProtocol & PROTOCOL_FAILED_NEGO)\n\t{\n\t\tUINT32 errorCode = (nego->SelectedProtocol & ~PROTOCOL_FAILED_NEGO);\n\t\tflags = 0;\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_FAILURE);\n\t\tStream_Write_UINT8(s, flags); /* flags */\n\t\tStream_Write_UINT16(s, 8);    /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, errorCode);\n\t\tlength += 8;\n\t\tstatus = FALSE;\n\t}\n\telse\n\t{\n\t\tflags = EXTENDED_CLIENT_DATA_SUPPORTED;\n\n\t\tif (settings->SupportGraphicsPipeline)\n\t\t\tflags |= DYNVC_GFX_PROTOCOL_SUPPORTED;\n\n\t\t/* RDP_NEG_DATA must be present for TLS, NLA, and RDP */\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_RSP);\n\t\tStream_Write_UINT8(s, flags);                   /* flags */\n\t\tStream_Write_UINT16(s, 8);                      /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, nego->SelectedProtocol); /* selectedProtocol */\n\t\tlength += 8;\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\ttpkt_write_header(s, length);\n\ttpdu_write_connection_confirm(s, length - 5);\n\tStream_SetPosition(s, em);\n\tStream_SealLength(s);\n\n\tif (transport_write(nego->transport, s) < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t{\n\t\t/* update settings with negotiated protocol security */\n\t\tsettings->RequestedProtocols = nego->RequestedProtocols;\n\t\tsettings->SelectedProtocol = nego->SelectedProtocol;\n\n\t\tif (settings->SelectedProtocol == PROTOCOL_RDP)\n\t\t{\n\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\tsettings->RdpSecurity = TRUE;\n\t\t\tsettings->UseRdpSecurityLayer = TRUE;\n\n\t\t\tif (settings->EncryptionLevel == ENCRYPTION_LEVEL_NONE)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * If the server implementation did not explicitely set a\n\t\t\t\t * encryption level we default to client compatible\n\t\t\t\t */\n\t\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_CLIENT_COMPATIBLE;\n\t\t\t}\n\n\t\t\tif (settings->LocalConnection)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Note: This hack was firstly introduced in commit 95f5e115 to\n\t\t\t\t * disable the unnecessary encryption with peers connecting to\n\t\t\t\t * 127.0.0.1 or local unix sockets.\n\t\t\t\t * This also affects connections via port tunnels! (e.g. ssh -L)\n\t\t\t\t */\n\t\t\t\tWLog_INFO(TAG, \"Turning off encryption for local peer with standard rdp security\");\n\t\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t\t}\n\n\t\t\tif (!settings->RdpServerRsaKey && !settings->RdpKeyFile && !settings->RdpKeyContent)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Missing server certificate\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse if (settings->SelectedProtocol == PROTOCOL_SSL)\n\t\t{\n\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t}\n\t\telse if (settings->SelectedProtocol == PROTOCOL_HYBRID)\n\t\t{\n\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\tsettings->NlaSecurity = TRUE;\n\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/**\n * Initialize NEGO state machine.\n * @param nego\n */\n\nvoid nego_init(rdpNego* nego)\n{\n\tnego->state = NEGO_STATE_INITIAL;\n\tnego->RequestedProtocols = PROTOCOL_RDP;\n\tnego->CookieMaxLength = DEFAULT_COOKIE_MAX_LENGTH;\n\tnego->sendNegoData = FALSE;\n\tnego->flags = 0;\n}\n\n/**\n * Create a new NEGO state machine instance.\n * @param transport\n * @return\n */\n\nrdpNego* nego_new(rdpTransport* transport)\n{\n\trdpNego* nego = (rdpNego*)calloc(1, sizeof(rdpNego));\n\n\tif (!nego)\n\t\treturn NULL;\n\n\tnego->transport = transport;\n\tnego_init(nego);\n\treturn nego;\n}\n\n/**\n * Free NEGO state machine.\n * @param nego\n */\n\nvoid nego_free(rdpNego* nego)\n{\n\tif (nego)\n\t{\n\t\tfree(nego->RoutingToken);\n\t\tfree(nego->cookie);\n\t\tfree(nego);\n\t}\n}\n\n/**\n * Set target hostname and port.\n * @param nego\n * @param hostname\n * @param port\n */\n\nBOOL nego_set_target(rdpNego* nego, const char* hostname, UINT16 port)\n{\n\tif (!nego || !hostname)\n\t\treturn FALSE;\n\n\tnego->hostname = hostname;\n\tnego->port = port;\n\treturn TRUE;\n}\n\n/**\n * Enable security layer negotiation.\n * @param nego pointer to the negotiation structure\n * @param enable_rdp whether to enable security layer negotiation (TRUE for enabled, FALSE for\n * disabled)\n */\n\nvoid nego_set_negotiation_enabled(rdpNego* nego, BOOL NegotiateSecurityLayer)\n{\n\tWLog_DBG(TAG, \"Enabling security layer negotiation: %s\",\n\t         NegotiateSecurityLayer ? \"TRUE\" : \"FALSE\");\n\tnego->NegotiateSecurityLayer = NegotiateSecurityLayer;\n}\n\n/**\n * Enable restricted admin mode.\n * @param nego pointer to the negotiation structure\n * @param enable_restricted whether to enable security layer negotiation (TRUE for enabled, FALSE\n * for disabled)\n */\n\nvoid nego_set_restricted_admin_mode_required(rdpNego* nego, BOOL RestrictedAdminModeRequired)\n{\n\tWLog_DBG(TAG, \"Enabling restricted admin mode: %s\",\n\t         RestrictedAdminModeRequired ? \"TRUE\" : \"FALSE\");\n\tnego->RestrictedAdminModeRequired = RestrictedAdminModeRequired;\n}\n\nvoid nego_set_gateway_enabled(rdpNego* nego, BOOL GatewayEnabled)\n{\n\tnego->GatewayEnabled = GatewayEnabled;\n}\n\nvoid nego_set_gateway_bypass_local(rdpNego* nego, BOOL GatewayBypassLocal)\n{\n\tnego->GatewayBypassLocal = GatewayBypassLocal;\n}\n\n/**\n * Enable RDP security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_rdp whether to enable normal RDP protocol (TRUE for enabled, FALSE for disabled)\n */\n\nvoid nego_enable_rdp(rdpNego* nego, BOOL enable_rdp)\n{\n\tWLog_DBG(TAG, \"Enabling RDP security: %s\", enable_rdp ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_RDP] = enable_rdp;\n}\n\n/**\n * Enable TLS security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_tls whether to enable TLS + RDP protocol (TRUE for enabled, FALSE for disabled)\n */\n\nvoid nego_enable_tls(rdpNego* nego, BOOL enable_tls)\n{\n\tWLog_DBG(TAG, \"Enabling TLS security: %s\", enable_tls ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_SSL] = enable_tls;\n}\n\n/**\n * Enable NLA security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_nla whether to enable network level authentication protocol (TRUE for enabled,\n * FALSE for disabled)\n */\n\nvoid nego_enable_nla(rdpNego* nego, BOOL enable_nla)\n{\n\tWLog_DBG(TAG, \"Enabling NLA security: %s\", enable_nla ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_HYBRID] = enable_nla;\n}\n\n/**\n * Enable NLA extended security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_ext whether to enable network level authentication extended protocol (TRUE for\n * enabled, FALSE for disabled)\n */\n\nvoid nego_enable_ext(rdpNego* nego, BOOL enable_ext)\n{\n\tWLog_DBG(TAG, \"Enabling NLA extended security: %s\", enable_ext ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = enable_ext;\n}\n\n/**\n * Set routing token.\n * @param nego\n * @param RoutingToken\n * @param RoutingTokenLength\n */\n\nBOOL nego_set_routing_token(rdpNego* nego, BYTE* RoutingToken, DWORD RoutingTokenLength)\n{\n\tif (RoutingTokenLength == 0)\n\t\treturn FALSE;\n\n\tfree(nego->RoutingToken);\n\tnego->RoutingTokenLength = RoutingTokenLength;\n\tnego->RoutingToken = (BYTE*)malloc(nego->RoutingTokenLength);\n\n\tif (!nego->RoutingToken)\n\t\treturn FALSE;\n\n\tCopyMemory(nego->RoutingToken, RoutingToken, nego->RoutingTokenLength);\n\treturn TRUE;\n}\n\n/**\n * Set cookie.\n * @param nego\n * @param cookie\n */\n\nBOOL nego_set_cookie(rdpNego* nego, char* cookie)\n{\n\tif (nego->cookie)\n\t{\n\t\tfree(nego->cookie);\n\t\tnego->cookie = NULL;\n\t}\n\n\tif (!cookie)\n\t\treturn TRUE;\n\n\tnego->cookie = _strdup(cookie);\n\n\tif (!nego->cookie)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Set cookie maximum length\n * @param nego\n * @param CookieMaxLength\n */\n\nvoid nego_set_cookie_max_length(rdpNego* nego, UINT32 CookieMaxLength)\n{\n\tnego->CookieMaxLength = CookieMaxLength;\n}\n\n/**\n * Enable / disable preconnection PDU.\n * @param nego\n * @param send_pcpdu\n */\n\nvoid nego_set_send_preconnection_pdu(rdpNego* nego, BOOL SendPreconnectionPdu)\n{\n\tnego->SendPreconnectionPdu = SendPreconnectionPdu;\n}\n\n/**\n * Set preconnection id.\n * @param nego\n * @param id\n */\n\nvoid nego_set_preconnection_id(rdpNego* nego, UINT32 PreconnectionId)\n{\n\tnego->PreconnectionId = PreconnectionId;\n}\n\n/**\n * Set preconnection blob.\n * @param nego\n * @param blob\n */\n\nvoid nego_set_preconnection_blob(rdpNego* nego, char* PreconnectionBlob)\n{\n\tnego->PreconnectionBlob = PreconnectionBlob;\n}\n\nUINT32 nego_get_selected_protocol(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn 0;\n\n\treturn nego->SelectedProtocol;\n}\n\nBOOL nego_set_selected_protocol(rdpNego* nego, UINT32 SelectedProtocol)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->SelectedProtocol = SelectedProtocol;\n\treturn TRUE;\n}\n\nUINT32 nego_get_requested_protocols(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn 0;\n\n\treturn nego->RequestedProtocols;\n}\n\nBOOL nego_set_requested_protocols(rdpNego* nego, UINT32 RequestedProtocols)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->RequestedProtocols = RequestedProtocols;\n\treturn TRUE;\n}\n\nNEGO_STATE nego_get_state(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn NEGO_STATE_FAIL;\n\n\treturn nego->state;\n}\n\nBOOL nego_set_state(rdpNego* nego, NEGO_STATE state)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->state = state;\n\treturn TRUE;\n}\n\nSEC_WINNT_AUTH_IDENTITY* nego_get_identity(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn NULL;\n\n\treturn nla_get_identity(nego->transport->nla);\n}\n\nvoid nego_free_nla(rdpNego* nego)\n{\n\tif (!nego || !nego->transport)\n\t\treturn;\n\n\tnla_free(nego->transport->nla);\n\tnego->transport->nla = NULL;\n}\n\nconst BYTE* nego_get_routing_token(rdpNego* nego, DWORD* RoutingTokenLength)\n{\n\tif (!nego)\n\t\treturn NULL;\n\tif (RoutingTokenLength)\n\t\t*RoutingTokenLength = nego->RoutingTokenLength;\n\treturn nego->RoutingToken;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n\t                      CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Print Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 Armin Novak <armin.novak@gmail.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/interlocked.h>\n#include <winpr/path.h>\n\n#include <freerdp/channels/rdpdr.h>\n#include <freerdp/crypto/crypto.h>\n\n#include \"../printer.h\"\n\n#include <freerdp/client/printer.h>\n\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"printer.client\")\n\ntypedef struct _PRINTER_DEVICE PRINTER_DEVICE;\nstruct _PRINTER_DEVICE\n{\n\tDEVICE device;\n\n\trdpPrinter* printer;\n\n\tWINPR_PSLIST_HEADER pIrpList;\n\n\tHANDLE event;\n\tHANDLE stopEvent;\n\n\tHANDLE thread;\n\trdpContext* rdpcontext;\n\tchar port[64];\n};\n\ntypedef enum\n{\n\tPRN_CONF_PORT = 0,\n\tPRN_CONF_PNP = 1,\n\tPRN_CONF_DRIVER = 2,\n\tPRN_CONF_DATA = 3\n} prn_conf_t;\n\nstatic const char* filemap[] = { \"PortDosName\", \"PnPName\", \"DriverName\",\n\t                             \"CachedPrinterConfigData\" };\n\nstatic char* get_printer_config_path(const rdpSettings* settings, const WCHAR* name, size_t length)\n{\n\tchar* dir = GetCombinedPath(settings->ConfigPath, \"printers\");\n\tchar* bname = crypto_base64_encode((const BYTE*)name, (int)length);\n\tchar* config = GetCombinedPath(dir, bname);\n\n\tif (config && !PathFileExistsA(config))\n\t{\n\t\tif (!PathMakePathA(config, NULL))\n\t\t{\n\t\t\tfree(config);\n\t\t\tconfig = NULL;\n\t\t}\n\t}\n\n\tfree(dir);\n\tfree(bname);\n\treturn config;\n}\n\nstatic BOOL printer_write_setting(const char* path, prn_conf_t type, const void* data,\n                                  size_t length)\n{\n\tDWORD written = 0;\n\tBOOL rc = FALSE;\n\tHANDLE file;\n\tsize_t b64len;\n\tchar* base64 = NULL;\n\tconst char* name = filemap[type];\n\tchar* abs = GetCombinedPath(path, name);\n\n\tif (!abs)\n\t\treturn FALSE;\n\n\tfile = CreateFileA(abs, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\tfree(abs);\n\n\tif (file == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\tif (length > 0)\n\t{\n\t\tbase64 = crypto_base64_encode(data, length);\n\n\t\tif (!base64)\n\t\t\tgoto fail;\n\n\t\t/* base64 char represents 6bit -> 4*(n/3) is the length which is\n\t\t * always smaller than 2*n */\n\t\tb64len = strnlen(base64, 2 * length);\n\t\trc = WriteFile(file, base64, b64len, &written, NULL);\n\n\t\tif (b64len != written)\n\t\t\trc = FALSE;\n\t}\n\telse\n\t\trc = TRUE;\n\nfail:\n\tCloseHandle(file);\n\tfree(base64);\n\treturn rc;\n}\n\nstatic BOOL printer_config_valid(const char* path)\n{\n\tif (!path)\n\t\treturn FALSE;\n\n\tif (!PathFileExistsA(path))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL printer_read_setting(const char* path, prn_conf_t type, void** data, UINT32* length)\n{\n\tDWORD lowSize, highSize;\n\tDWORD read = 0;\n\tBOOL rc = FALSE;\n\tHANDLE file;\n\tchar* fdata = NULL;\n\tconst char* name = filemap[type];\n\tchar* abs = GetCombinedPath(path, name);\n\n\tif (!abs)\n\t\treturn FALSE;\n\n\tfile = CreateFileA(abs, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\tfree(abs);\n\n\tif (file == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\n\tlowSize = GetFileSize(file, &highSize);\n\n\tif ((lowSize == INVALID_FILE_SIZE) || (highSize != 0))\n\t\tgoto fail;\n\n\tif (lowSize != 0)\n\t{\n\t\tfdata = malloc(lowSize);\n\n\t\tif (!fdata)\n\t\t\tgoto fail;\n\n\t\trc = ReadFile(file, fdata, lowSize, &read, NULL);\n\n\t\tif (lowSize != read)\n\t\t\trc = FALSE;\n\t}\n\nfail:\n\tCloseHandle(file);\n\n\tif (rc && (lowSize <= INT_MAX))\n\t{\n\t\tint blen = 0;\n\t\tcrypto_base64_decode(fdata, (int)lowSize, (BYTE**)data, &blen);\n\n\t\tif (*data && (blen > 0))\n\t\t\t*length = (UINT32)blen;\n\t\telse\n\t\t{\n\t\t\trc = FALSE;\n\t\t\t*length = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t*length = 0;\n\t\t*data = NULL;\n\t}\n\n\tfree(fdata);\n\treturn rc;\n}\n\nstatic BOOL printer_save_to_config(const rdpSettings* settings, const char* PortDosName,\n                                   size_t PortDosNameLen, const WCHAR* PnPName, size_t PnPNameLen,\n                                   const WCHAR* DriverName, size_t DriverNameLen,\n                                   const WCHAR* PrinterName, size_t PrintNameLen,\n                                   const BYTE* CachedPrinterConfigData, size_t CacheFieldsLen)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, PrinterName, PrintNameLen);\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_PORT, PortDosName, PortDosNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_PNP, PnPName, PnPNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_DRIVER, DriverName, DriverNameLen))\n\t\tgoto fail;\n\n\tif (!printer_write_setting(path, PRN_CONF_DATA, CachedPrinterConfigData, CacheFieldsLen))\n\t\tgoto fail;\n\nfail:\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_update_to_config(const rdpSettings* settings, const WCHAR* name, size_t length,\n                                     const BYTE* data, size_t datalen)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, name, length);\n\trc = printer_write_setting(path, PRN_CONF_DATA, data, datalen);\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_remove_config(const rdpSettings* settings, const WCHAR* name, size_t length)\n{\n\tBOOL rc = FALSE;\n\tchar* path = get_printer_config_path(settings, name, length);\n\n\tif (!printer_config_valid(path))\n\t\tgoto fail;\n\n\trc = RemoveDirectoryA(path);\nfail:\n\tfree(path);\n\treturn rc;\n}\n\nstatic BOOL printer_move_config(const rdpSettings* settings, const WCHAR* oldName, size_t oldLength,\n                                const WCHAR* newName, size_t newLength)\n{\n\tBOOL rc = FALSE;\n\tchar* oldPath = get_printer_config_path(settings, oldName, oldLength);\n\tchar* newPath = get_printer_config_path(settings, newName, newLength);\n\n\tif (printer_config_valid(oldPath))\n\t\trc = MoveFileA(oldPath, newPath);\n\n\tfree(oldPath);\n\tfree(newPath);\n\treturn rc;\n}\n\nstatic BOOL printer_load_from_config(const rdpSettings* settings, rdpPrinter* printer,\n                                     PRINTER_DEVICE* printer_dev)\n{\n\tBOOL res = FALSE;\n\tWCHAR* wname = NULL;\n\tsize_t wlen;\n\tchar* path = NULL;\n\tint rc;\n\tUINT32 flags = 0;\n\tvoid* DriverName = NULL;\n\tUINT32 DriverNameLen = 0;\n\tvoid* PnPName = NULL;\n\tUINT32 PnPNameLen = 0;\n\tvoid* CachedPrinterConfigData = NULL;\n\tUINT32 CachedFieldsLen = 0;\n\tUINT32 PrinterNameLen = 0;\n\n\tif (!settings || !printer)\n\t\treturn FALSE;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->name, -1, &wname, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\twlen = _wcslen(wname) + 1;\n\tpath = get_printer_config_path(settings, wname, wlen * sizeof(WCHAR));\n\tPrinterNameLen = (wlen + 1) * sizeof(WCHAR);\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (printer->is_default)\n\t\tflags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;\n\n\tif (!printer_read_setting(path, PRN_CONF_PNP, &PnPName, &PnPNameLen))\n\t{\n\t}\n\n\tif (!printer_read_setting(path, PRN_CONF_DRIVER, &DriverName, &DriverNameLen))\n\t{\n\t\tDriverNameLen =\n\t\t    ConvertToUnicode(CP_UTF8, 0, printer->driver, -1, (LPWSTR*)&DriverName, 0) * 2 + 1;\n\t}\n\n\tif (!printer_read_setting(path, PRN_CONF_DATA, &CachedPrinterConfigData, &CachedFieldsLen))\n\t{\n\t}\n\n\tStream_SetPosition(printer_dev->device.data, 0);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, 24))\n\t\tgoto fail;\n\n\tStream_Write_UINT32(printer_dev->device.data, flags);\n\tStream_Write_UINT32(printer_dev->device.data, 0);          /* CodePage, reserved */\n\tStream_Write_UINT32(printer_dev->device.data, PnPNameLen); /* PnPNameLen */\n\tStream_Write_UINT32(printer_dev->device.data, DriverNameLen);\n\tStream_Write_UINT32(printer_dev->device.data, PrinterNameLen);\n\tStream_Write_UINT32(printer_dev->device.data, CachedFieldsLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, PnPNameLen))\n\t\tgoto fail;\n\n\tif (PnPNameLen > 0)\n\t\tStream_Write(printer_dev->device.data, PnPName, PnPNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, DriverNameLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, DriverName, DriverNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, PrinterNameLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, wname, PrinterNameLen);\n\n\tif (!Stream_EnsureRemainingCapacity(printer_dev->device.data, CachedFieldsLen))\n\t\tgoto fail;\n\n\tStream_Write(printer_dev->device.data, CachedPrinterConfigData, CachedFieldsLen);\n\tres = TRUE;\nfail:\n\tfree(path);\n\tfree(wname);\n\tfree(PnPName);\n\tfree(DriverName);\n\tfree(CachedPrinterConfigData);\n\treturn res;\n}\n\nstatic BOOL printer_save_default_config(const rdpSettings* settings, rdpPrinter* printer)\n{\n\tBOOL res = FALSE;\n\tWCHAR* wname = NULL;\n\tWCHAR* driver = NULL;\n\tsize_t wlen, dlen;\n\tchar* path = NULL;\n\tint rc;\n\n\tif (!settings || !printer)\n\t\treturn FALSE;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->name, -1, &wname, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\trc = ConvertToUnicode(CP_UTF8, 0, printer->driver, -1, &driver, 0);\n\n\tif (rc <= 0)\n\t\tgoto fail;\n\n\twlen = _wcslen(wname) + 1;\n\tdlen = _wcslen(driver) + 1;\n\tpath = get_printer_config_path(settings, wname, wlen * sizeof(WCHAR));\n\n\tif (!path)\n\t\tgoto fail;\n\n\tif (dlen > 1)\n\t{\n\t\tif (!printer_write_setting(path, PRN_CONF_DRIVER, driver, dlen * sizeof(WCHAR)))\n\t\t\tgoto fail;\n\t}\n\n\tres = TRUE;\nfail:\n\tfree(path);\n\tfree(wname);\n\tfree(driver);\n\treturn res;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_create(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\trdpPrintJob* printjob = NULL;\n\n\tif (printer_dev->printer)\n\t\tprintjob =\n\t\t    printer_dev->printer->CreatePrintJob(printer_dev->printer, irp->devman->id_sequence++);\n\n\tif (printjob)\n\t{\n\t\tStream_Write_UINT32(irp->output, printjob->id); /* FileId */\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT32(irp->output, 0); /* FileId */\n\t\tirp->IoStatus = STATUS_PRINT_QUEUE_FULL;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_close(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\trdpPrintJob* printjob = NULL;\n\n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse\n\t{\n\t\tprintjob->Close(printjob);\n\t}\n\n\tStream_Zero(irp->output, 4); /* Padding(4) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tvoid* ptr;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, ptr, Length);\n\t}\n\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp_device_control(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_process_irp(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT error;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\tif ((error = printer_process_irp_create(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_create failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\tif ((error = printer_process_irp_close(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_close failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\tif ((error = printer_process_irp_write(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_write failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tif ((error = printer_process_irp_device_control(printer_dev, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_process_irp_device_control failed with error %\" PRIu32 \"!\",\n\t\t\t\t         error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\treturn irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic DWORD WINAPI printer_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)arg;\n\tHANDLE obj[] = { printer_dev->event, printer_dev->stopEvent };\n\tUINT error = CHANNEL_RC_OK;\n\n\twhile (1)\n\t{\n\t\tDWORD rc = WaitForMultipleObjects(2, obj, FALSE, INFINITE);\n\n\t\tif (rc == WAIT_FAILED)\n\t\t{\n\t\t\terror = GetLastError();\n\t\t\tWLog_ERR(TAG, \"WaitForMultipleObjects failed with error %\" PRIu32 \"!\", error);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == WAIT_OBJECT_0 + 1)\n\t\t\tbreak;\n\t\telse if (rc != WAIT_OBJECT_0)\n\t\t\tcontinue;\n\n\t\tResetEvent(printer_dev->event);\n\t\tirp = (IRP*)InterlockedPopEntrySList(printer_dev->pIrpList);\n\n\t\tif (irp == NULL)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"InterlockedPopEntrySList failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = printer_process_irp(printer_dev, irp)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"printer_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error && printer_dev->rdpcontext)\n\t\tsetChannelError(printer_dev->rdpcontext, error, \"printer_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_irp_request(DEVICE* device, IRP* irp)\n{\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tInterlockedPushEntrySList(printer_dev->pIrpList, &(irp->ItemEntry));\n\tSetEvent(printer_dev->event);\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT printer_custom_component(DEVICE* device, UINT16 component, UINT16 packetId, wStream* s)\n{\n\tUINT32 eventID;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tconst rdpSettings* settings = printer_dev->rdpcontext->settings;\n\n\tif (component != RDPDR_CTYP_PRN)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, eventID);\n\n\tswitch (packetId)\n\t{\n\t\tcase PAKID_PRN_CACHE_DATA:\n\t\t\tswitch (eventID)\n\t\t\t{\n\t\t\t\tcase RDPDR_ADD_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tchar PortDosName[8];\n\t\t\t\t\tUINT32 PnPNameLen, DriverNameLen, PrintNameLen, CacheFieldsLen;\n\t\t\t\t\tconst WCHAR *PnPName, *DriverName, *PrinterName;\n\t\t\t\t\tconst BYTE* CachedPrinterConfigData;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 24)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read(s, PortDosName, sizeof(PortDosName));\n\t\t\t\t\tStream_Read_UINT32(s, PnPNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, DriverNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, PrintNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, CacheFieldsLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PnPNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPnPName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PnPNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < DriverNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tDriverName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, DriverNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrintNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrintNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < CacheFieldsLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tCachedPrinterConfigData = Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, CacheFieldsLen);\n\n\t\t\t\t\tif (!printer_save_to_config(settings, PortDosName, sizeof(PortDosName), PnPName,\n\t\t\t\t\t                            PnPNameLen, DriverName, DriverNameLen, PrinterName,\n\t\t\t\t\t                            PrintNameLen, CachedPrinterConfigData,\n\t\t\t\t\t                            CacheFieldsLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_UPDATE_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 PrinterNameLen, ConfigDataLen;\n\t\t\t\t\tconst WCHAR* PrinterName;\n\t\t\t\t\tconst BYTE* ConfigData;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, PrinterNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, ConfigDataLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < ConfigDataLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tConfigData = Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, ConfigDataLen);\n\n\t\t\t\t\tif (!printer_update_to_config(settings, PrinterName, PrinterNameLen, ConfigData,\n\t\t\t\t\t                              ConfigDataLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_DELETE_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 PrinterNameLen;\n\t\t\t\t\tconst WCHAR* PrinterName;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, PrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < PrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, PrinterNameLen);\n\t\t\t\t\tprinter_remove_config(settings, PrinterName, PrinterNameLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase RDPDR_RENAME_PRINTER_EVENT:\n\t\t\t\t{\n\t\t\t\t\tUINT32 OldPrinterNameLen, NewPrinterNameLen;\n\t\t\t\t\tconst WCHAR* OldPrinterName;\n\t\t\t\t\tconst WCHAR* NewPrinterName;\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tStream_Read_UINT32(s, OldPrinterNameLen);\n\t\t\t\t\tStream_Read_UINT32(s, NewPrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < OldPrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tOldPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, OldPrinterNameLen);\n\n\t\t\t\t\tif (Stream_GetRemainingLength(s) < NewPrinterNameLen)\n\t\t\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\t\t\tNewPrinterName = (const WCHAR*)Stream_Pointer(s);\n\t\t\t\t\tStream_Seek(s, NewPrinterNameLen);\n\n\t\t\t\t\tif (!printer_move_config(settings, OldPrinterName, OldPrinterNameLen,\n\t\t\t\t\t                         NewPrinterName, NewPrinterNameLen))\n\t\t\t\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"Unknown cache data eventID: 0x%08\" PRIX32 \"\", eventID);\n\t\t\t\t\treturn ERROR_INVALID_DATA;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase PAKID_PRN_USING_XPS:\n\t\t{\n\t\t\tUINT32 flags;\n\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tStream_Read_UINT32(s, flags);\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"Ignoring unhandled message PAKID_PRN_USING_XPS [printerID=%08\" PRIx32\n\t\t\t         \", flags=%08\" PRIx32 \"]\",\n\t\t\t         eventID, flags);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Unknown printing component packetID: 0x%04\" PRIX16 \"\", packetId);\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_free(DEVICE* device)\n{\n\tIRP* irp;\n\tPRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*)device;\n\tUINT error;\n\tSetEvent(printer_dev->stopEvent);\n\n\tif (WaitForSingleObject(printer_dev->thread, INFINITE) == WAIT_FAILED)\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\n\t\t/* The analyzer is confused by this premature return value.\n\t\t * Since this case can not be handled gracefully silence the\n\t\t * analyzer here. */\n#ifndef __clang_analyzer__\n\t\treturn error;\n#endif\n\t}\n\n\twhile ((irp = (IRP*)InterlockedPopEntrySList(printer_dev->pIrpList)) != NULL)\n\t\tirp->Discard(irp);\n\n\tCloseHandle(printer_dev->thread);\n\tCloseHandle(printer_dev->stopEvent);\n\tCloseHandle(printer_dev->event);\n\t_aligned_free(printer_dev->pIrpList);\n\n\tif (printer_dev->printer)\n\t\tprinter_dev->printer->ReleaseRef(printer_dev->printer);\n\n\tStream_Free(printer_dev->device.data, TRUE);\n\tfree(printer_dev);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT printer_register(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, rdpPrinter* printer)\n{\n\tPRINTER_DEVICE* printer_dev;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tprinter_dev = (PRINTER_DEVICE*)calloc(1, sizeof(PRINTER_DEVICE));\n\n\tif (!printer_dev)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tprinter_dev->device.data = Stream_New(NULL, 1024);\n\n\tif (!printer_dev->device.data)\n\t\tgoto error_out;\n\n\tsprintf_s(printer_dev->port, sizeof(printer_dev->port), \"PRN%\" PRIdz, printer->id);\n\tprinter_dev->device.type = RDPDR_DTYP_PRINT;\n\tprinter_dev->device.name = printer_dev->port;\n\tprinter_dev->device.IRPRequest = printer_irp_request;\n\tprinter_dev->device.CustomComponentRequest = printer_custom_component;\n\tprinter_dev->device.Free = printer_free;\n\tprinter_dev->rdpcontext = pEntryPoints->rdpcontext;\n\tprinter_dev->printer = printer;\n\tprinter_dev->pIrpList = (WINPR_PSLIST_HEADER)_aligned_malloc(sizeof(WINPR_SLIST_HEADER),\n\t                                                             MEMORY_ALLOCATION_ALIGNMENT);\n\n\tif (!printer_dev->pIrpList)\n\t{\n\t\tWLog_ERR(TAG, \"_aligned_malloc failed!\");\n\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\tgoto error_out;\n\t}\n\n\tif (!printer_load_from_config(pEntryPoints->rdpcontext->settings, printer, printer_dev))\n\t\tgoto error_out;\n\n\tInitializeSListHead(printer_dev->pIrpList);\n\n\tif (!(printer_dev->event = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateEvent failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tif (!(printer_dev->stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateEvent failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)printer_dev)))\n\t{\n\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\tgoto error_out;\n\t}\n\n\tif (!(printer_dev->thread =\n\t          CreateThread(NULL, 0, printer_thread_func, (void*)printer_dev, 0, NULL)))\n\t{\n\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\terror = ERROR_INTERNAL_ERROR;\n\t\tgoto error_out;\n\t}\n\n\tprinter->AddRef(printer);\n\treturn CHANNEL_RC_OK;\nerror_out:\n\tprinter_free(&printer_dev->device);\n\treturn error;\n}\n\nstatic rdpPrinterDriver* printer_load_backend(const char* backend)\n{\n\ttypedef rdpPrinterDriver* (*backend_load_t)(void);\n\tunion {\n\t\tPVIRTUALCHANNELENTRY entry;\n\t\tbackend_load_t backend;\n\t} fktconv;\n\n\tfktconv.entry = freerdp_load_channel_addin_entry(\"printer\", backend, NULL, 0);\n\tif (!fktconv.entry)\n\t\treturn NULL;\n\n\treturn fktconv.backend();\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT\n#ifdef BUILTIN_CHANNELS\nprinter_DeviceServiceEntry\n#else\n    FREERDP_API\n    DeviceServiceEntry\n#endif\n    (PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tint i;\n\tchar* name;\n\tchar* driver_name;\n\tBOOL default_backend = TRUE;\n\tRDPDR_PRINTER* device = NULL;\n\trdpPrinterDriver* driver = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!pEntryPoints || !pEntryPoints->device)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tdevice = (RDPDR_PRINTER*)pEntryPoints->device;\n\tname = device->Name;\n\tdriver_name = device->DriverName;\n\n\t/* Secondary argument is one of the following:\n\t *\n\t * <driver_name>                ... name of a printer driver\n\t * <driver_name>:<backend_name> ... name of a printer driver and local printer backend to use\n\t */\n\tif (driver_name)\n\t{\n\t\tchar* sep = strstr(driver_name, \":\");\n\t\tif (sep)\n\t\t{\n\t\t\tconst char* backend = sep + 1;\n\t\t\t*sep = '\\0';\n\t\t\tdriver = printer_load_backend(backend);\n\t\t\tdefault_backend = FALSE;\n\t\t}\n\t}\n\n\tif (!driver && default_backend)\n\t{\n\t\tconst char* backend =\n#if defined(WITH_CUPS)\n\t\t    \"cups\"\n#elif defined(_WIN32)\n\t\t    \"win\"\n#else\n\t\t    \"\"\n#endif\n\t\t    ;\n\n\t\tdriver = printer_load_backend(backend);\n\t}\n\n\tif (!driver)\n\t{\n\t\tWLog_ERR(TAG, \"Could not get a printer driver!\");\n\t\treturn CHANNEL_RC_INITIALIZATION_ERROR;\n\t}\n\n\tif (name && name[0])\n\t{\n\t\trdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);\n\n\t\tif (!printer)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Could not get printer %s!\", name);\n\t\t\terror = CHANNEL_RC_INITIALIZATION_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!printer_save_default_config(pEntryPoints->rdpcontext->settings, printer))\n\t\t{\n\t\t\terror = CHANNEL_RC_INITIALIZATION_ERROR;\n\t\t\tprinter->ReleaseRef(printer);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif ((error = printer_register(pEntryPoints, printer)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"printer_register failed with error %\" PRIu32 \"!\", error);\n\t\t\tprinter->ReleaseRef(printer);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\telse\n\t{\n\t\trdpPrinter** printers = driver->EnumPrinters(driver);\n\t\trdpPrinter** current = printers;\n\n\t\tfor (i = 0; current[i]; i++)\n\t\t{\n\t\t\trdpPrinter* printer = current[i];\n\n\t\t\tif ((error = printer_register(pEntryPoints, printer)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"printer_register failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdriver->ReleaseEnumPrinters(printers);\n\t}\n\nfail:\n\tdriver->ReleaseRef(driver);\n\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Input Virtual Channel Extension\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/sysinfo.h>\n#include <winpr/cmdline.h>\n#include <winpr/collections.h>\n\n#include <freerdp/addin.h>\n#include <freerdp/freerdp.h>\n\n#include \"rdpei_common.h\"\n\n#include \"rdpei_main.h\"\n\n/**\n * Touch Input\n * http://msdn.microsoft.com/en-us/library/windows/desktop/dd562197/\n *\n * Windows Touch Input\n * http://msdn.microsoft.com/en-us/library/windows/desktop/dd317321/\n *\n * Input: Touch injection sample\n * http://code.msdn.microsoft.com/windowsdesktop/Touch-Injection-Sample-444d9bf7\n *\n * Pointer Input Message Reference\n * http://msdn.microsoft.com/en-us/library/hh454916/\n *\n * POINTER_INFO Structure\n * http://msdn.microsoft.com/en-us/library/hh454907/\n *\n * POINTER_TOUCH_INFO Structure\n * http://msdn.microsoft.com/en-us/library/hh454910/\n */\n\n#define MAX_CONTACTS 512\n\nstruct _RDPEI_CHANNEL_CALLBACK\n{\n\tIWTSVirtualChannelCallback iface;\n\n\tIWTSPlugin* plugin;\n\tIWTSVirtualChannelManager* channel_mgr;\n\tIWTSVirtualChannel* channel;\n};\ntypedef struct _RDPEI_CHANNEL_CALLBACK RDPEI_CHANNEL_CALLBACK;\n\nstruct _RDPEI_LISTENER_CALLBACK\n{\n\tIWTSListenerCallback iface;\n\n\tIWTSPlugin* plugin;\n\tIWTSVirtualChannelManager* channel_mgr;\n\tRDPEI_CHANNEL_CALLBACK* channel_callback;\n};\ntypedef struct _RDPEI_LISTENER_CALLBACK RDPEI_LISTENER_CALLBACK;\n\nstruct _RDPEI_PLUGIN\n{\n\tIWTSPlugin iface;\n\n\tIWTSListener* listener;\n\tRDPEI_LISTENER_CALLBACK* listener_callback;\n\n\tRdpeiClientContext* context;\n\n\tint version;\n\tUINT16 maxTouchContacts;\n\tUINT64 currentFrameTime;\n\tUINT64 previousFrameTime;\n\tRDPINPUT_TOUCH_FRAME frame;\n\tRDPINPUT_CONTACT_DATA contacts[MAX_CONTACTS];\n\tRDPINPUT_CONTACT_POINT* contactPoints;\n\n\trdpContext* rdpcontext;\n};\ntypedef struct _RDPEI_PLUGIN RDPEI_PLUGIN;\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_frame(RdpeiClientContext* context);\n\n#ifdef WITH_DEBUG_RDPEI\nstatic const char* rdpei_eventid_string(UINT16 event)\n{\n\tswitch (event)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\treturn \"EVENTID_SC_READY\";\n\t\tcase EVENTID_CS_READY:\n\t\t\treturn \"EVENTID_CS_READY\";\n\t\tcase EVENTID_TOUCH:\n\t\t\treturn \"EVENTID_TOUCH\";\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\treturn \"EVENTID_SUSPEND_TOUCH\";\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\treturn \"EVENTID_RESUME_TOUCH\";\n\t\tcase EVENTID_DISMISS_HOVERING_CONTACT:\n\t\t\treturn \"EVENTID_DISMISS_HOVERING_CONTACT\";\n\t\tdefault:\n\t\t\treturn \"EVENTID_UNKNOWN\";\n\t}\n}\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_add_frame(RdpeiClientContext* context)\n{\n\tint i;\n\tRDPINPUT_CONTACT_DATA* contact;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\trdpei->frame.contactCount = 0;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontact = (RDPINPUT_CONTACT_DATA*)&(rdpei->contactPoints[i].data);\n\n\t\tif (rdpei->contactPoints[i].dirty)\n\t\t{\n\t\t\tCopyMemory(&(rdpei->contacts[rdpei->frame.contactCount]), contact,\n\t\t\t           sizeof(RDPINPUT_CONTACT_DATA));\n\t\t\trdpei->contactPoints[i].dirty = FALSE;\n\t\t\trdpei->frame.contactCount++;\n\t\t}\n\t\telse if (rdpei->contactPoints[i].active)\n\t\t{\n\t\t\tif (contact->contactFlags & CONTACT_FLAG_DOWN)\n\t\t\t{\n\t\t\t\tcontact->contactFlags = CONTACT_FLAG_UPDATE;\n\t\t\t\tcontact->contactFlags |= CONTACT_FLAG_INRANGE;\n\t\t\t\tcontact->contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\t\t}\n\n\t\t\tCopyMemory(&(rdpei->contacts[rdpei->frame.contactCount]), contact,\n\t\t\t           sizeof(RDPINPUT_CONTACT_DATA));\n\t\t\trdpei->frame.contactCount++;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s, UINT16 eventId,\n                           UINT32 pduLength)\n{\n\tUINT status;\n\tStream_SetPosition(s, 0);\n\tStream_Write_UINT16(s, eventId);   /* eventId (2 bytes) */\n\tStream_Write_UINT32(s, pduLength); /* pduLength (4 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\tstatus = callback->channel->Write(callback->channel, (UINT32)Stream_Length(s), Stream_Buffer(s),\n\t                                  NULL);\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG,\n\t         \"rdpei_send_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \" status: %\" PRIu32 \"\",\n\t         eventId, rdpei_eventid_string(eventId), pduLength, status);\n#endif\n\treturn status;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_cs_ready_pdu(RDPEI_CHANNEL_CALLBACK* callback)\n{\n\tUINT status;\n\twStream* s;\n\tUINT32 flags;\n\tUINT32 pduLength;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)callback->plugin;\n\tflags = 0;\n\tflags |= READY_FLAGS_SHOW_TOUCH_VISUALS;\n\t// flags |= READY_FLAGS_DISABLE_TIMESTAMP_INJECTION;\n\tpduLength = RDPINPUT_HEADER_LENGTH + 10;\n\ts = Stream_New(NULL, pduLength);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tStream_Seek(s, RDPINPUT_HEADER_LENGTH);\n\tStream_Write_UINT32(s, flags);                   /* flags (4 bytes) */\n\tStream_Write_UINT32(s, RDPINPUT_PROTOCOL_V10);   /* protocolVersion (4 bytes) */\n\tStream_Write_UINT16(s, rdpei->maxTouchContacts); /* maxTouchContacts (2 bytes) */\n\tStream_SealLength(s);\n\tstatus = rdpei_send_pdu(callback, s, EVENTID_CS_READY, pduLength);\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\nstatic void rdpei_print_contact_flags(UINT32 contactFlags)\n{\n\tif (contactFlags & CONTACT_FLAG_DOWN)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_DOWN\");\n\n\tif (contactFlags & CONTACT_FLAG_UPDATE)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_UPDATE\");\n\n\tif (contactFlags & CONTACT_FLAG_UP)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_UP\");\n\n\tif (contactFlags & CONTACT_FLAG_INRANGE)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_INRANGE\");\n\n\tif (contactFlags & CONTACT_FLAG_INCONTACT)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_INCONTACT\");\n\n\tif (contactFlags & CONTACT_FLAG_CANCELED)\n\t\tWLog_DBG(TAG, \" CONTACT_FLAG_CANCELED\");\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_write_touch_frame(wStream* s, RDPINPUT_TOUCH_FRAME* frame)\n{\n\tUINT32 index;\n\tint rectSize = 2;\n\tRDPINPUT_CONTACT_DATA* contact;\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"contactCount: %\" PRIu32 \"\", frame->contactCount);\n\tWLog_DBG(TAG, \"frameOffset: 0x%016\" PRIX64 \"\", frame->frameOffset);\n#endif\n\trdpei_write_2byte_unsigned(s,\n\t                           frame->contactCount); /* contactCount (TWO_BYTE_UNSIGNED_INTEGER) */\n\t/**\n\t * the time offset from the previous frame (in microseconds).\n\t * If this is the first frame being transmitted then this field MUST be set to zero.\n\t */\n\trdpei_write_8byte_unsigned(s, frame->frameOffset *\n\t                                  1000); /* frameOffset (EIGHT_BYTE_UNSIGNED_INTEGER) */\n\n\tif (!Stream_EnsureRemainingCapacity(s, (size_t)frame->contactCount * 64))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tfor (index = 0; index < frame->contactCount; index++)\n\t{\n\t\tcontact = &frame->contacts[index];\n\t\tcontact->fieldsPresent |= CONTACT_DATA_CONTACTRECT_PRESENT;\n\t\tcontact->contactRectLeft = contact->x - rectSize;\n\t\tcontact->contactRectTop = contact->y - rectSize;\n\t\tcontact->contactRectRight = contact->x + rectSize;\n\t\tcontact->contactRectBottom = contact->y + rectSize;\n#ifdef WITH_DEBUG_RDPEI\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].contactId: %\" PRIu32 \"\", index, contact->contactId);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].fieldsPresent: %\" PRIu32 \"\", index,\n\t\t         contact->fieldsPresent);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].x: %\" PRId32 \"\", index, contact->x);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].y: %\" PRId32 \"\", index, contact->y);\n\t\tWLog_DBG(TAG, \"contact[%\" PRIu32 \"].contactFlags: 0x%08\" PRIX32 \"\", index,\n\t\t         contact->contactFlags);\n\t\trdpei_print_contact_flags(contact->contactFlags);\n#endif\n\t\tStream_Write_UINT8(s, contact->contactId); /* contactId (1 byte) */\n\t\t/* fieldsPresent (TWO_BYTE_UNSIGNED_INTEGER) */\n\t\trdpei_write_2byte_unsigned(s, contact->fieldsPresent);\n\t\trdpei_write_4byte_signed(s, contact->x); /* x (FOUR_BYTE_SIGNED_INTEGER) */\n\t\trdpei_write_4byte_signed(s, contact->y); /* y (FOUR_BYTE_SIGNED_INTEGER) */\n\t\t/* contactFlags (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\trdpei_write_4byte_unsigned(s, contact->contactFlags);\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_CONTACTRECT_PRESENT)\n\t\t{\n\t\t\t/* contactRectLeft (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectLeft);\n\t\t\t/* contactRectTop (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectTop);\n\t\t\t/* contactRectRight (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectRight);\n\t\t\t/* contactRectBottom (TWO_BYTE_SIGNED_INTEGER) */\n\t\t\trdpei_write_2byte_signed(s, contact->contactRectBottom);\n\t\t}\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_ORIENTATION_PRESENT)\n\t\t{\n\t\t\t/* orientation (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\t\trdpei_write_4byte_unsigned(s, contact->orientation);\n\t\t}\n\n\t\tif (contact->fieldsPresent & CONTACT_DATA_PRESSURE_PRESENT)\n\t\t{\n\t\t\t/* pressure (FOUR_BYTE_UNSIGNED_INTEGER) */\n\t\t\trdpei_write_4byte_unsigned(s, contact->pressure);\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_send_touch_event_pdu(RDPEI_CHANNEL_CALLBACK* callback,\n                                       RDPINPUT_TOUCH_FRAME* frame)\n{\n\tUINT status;\n\twStream* s;\n\tUINT32 pduLength;\n\tpduLength = 64 + (frame->contactCount * 64);\n\ts = Stream_New(NULL, pduLength);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tStream_Seek(s, RDPINPUT_HEADER_LENGTH);\n\t/**\n\t * the time that has elapsed (in milliseconds) from when the oldest touch frame\n\t * was generated to when it was encoded for transmission by the client.\n\t */\n\trdpei_write_4byte_unsigned(\n\t    s, (UINT32)frame->frameOffset); /* encodeTime (FOUR_BYTE_UNSIGNED_INTEGER) */\n\trdpei_write_2byte_unsigned(s, 1);   /* (frameCount) TWO_BYTE_UNSIGNED_INTEGER */\n\n\tif ((status = rdpei_write_touch_frame(s, frame)))\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_write_touch_frame failed with error %\" PRIu32 \"!\", status);\n\t\tStream_Free(s, TRUE);\n\t\treturn status;\n\t}\n\n\tStream_SealLength(s);\n\tpduLength = Stream_Length(s);\n\tstatus = rdpei_send_pdu(callback, s, EVENTID_TOUCH, pduLength);\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_sc_ready_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT32 protocolVersion;\n\tStream_Read_UINT32(s, protocolVersion); /* protocolVersion (4 bytes) */\n#if 0\n\n\tif (protocolVersion != RDPINPUT_PROTOCOL_V10)\n\t{\n\t\tWLog_ERR(TAG,  \"Unknown [MS-RDPEI] protocolVersion: 0x%08\"PRIX32\"\", protocolVersion);\n\t\treturn -1;\n\t}\n\n#endif\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_suspend_touch_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tRdpeiClientContext* rdpei = (RdpeiClientContext*)callback->plugin->pInterface;\n\tUINT error = CHANNEL_RC_OK;\n\tIFCALLRET(rdpei->SuspendTouch, error, rdpei);\n\n\tif (error)\n\t\tWLog_ERR(TAG, \"rdpei->SuspendTouch failed with error %\" PRIu32 \"!\", error);\n\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_resume_touch_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tRdpeiClientContext* rdpei = (RdpeiClientContext*)callback->plugin->pInterface;\n\tUINT error = CHANNEL_RC_OK;\n\tIFCALLRET(rdpei->ResumeTouch, error, rdpei);\n\n\tif (error)\n\t\tWLog_ERR(TAG, \"rdpei->ResumeTouch failed with error %\" PRIu32 \"!\", error);\n\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT16(s, eventId);   /* eventId (2 bytes) */\n\tStream_Read_UINT32(s, pduLength); /* pduLength (4 bytes) */\n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_data_received(IWTSVirtualChannelCallback* pChannelCallback, wStream* data)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback = (RDPEI_CHANNEL_CALLBACK*)pChannelCallback;\n\treturn rdpei_recv_pdu(callback, data);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_close(IWTSVirtualChannelCallback* pChannelCallback)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback = (RDPEI_CHANNEL_CALLBACK*)pChannelCallback;\n\tfree(callback);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_on_new_channel_connection(IWTSListenerCallback* pListenerCallback,\n                                            IWTSVirtualChannel* pChannel, BYTE* Data,\n                                            BOOL* pbAccept, IWTSVirtualChannelCallback** ppCallback)\n{\n\tRDPEI_CHANNEL_CALLBACK* callback;\n\tRDPEI_LISTENER_CALLBACK* listener_callback = (RDPEI_LISTENER_CALLBACK*)pListenerCallback;\n\tcallback = (RDPEI_CHANNEL_CALLBACK*)calloc(1, sizeof(RDPEI_CHANNEL_CALLBACK));\n\n\tif (!callback)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tcallback->iface.OnDataReceived = rdpei_on_data_received;\n\tcallback->iface.OnClose = rdpei_on_close;\n\tcallback->plugin = listener_callback->plugin;\n\tcallback->channel_mgr = listener_callback->channel_mgr;\n\tcallback->channel = pChannel;\n\tlistener_callback->channel_callback = callback;\n\t*ppCallback = (IWTSVirtualChannelCallback*)callback;\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_plugin_initialize(IWTSPlugin* pPlugin, IWTSVirtualChannelManager* pChannelMgr)\n{\n\tUINT error;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)pPlugin;\n\trdpei->listener_callback = (RDPEI_LISTENER_CALLBACK*)calloc(1, sizeof(RDPEI_LISTENER_CALLBACK));\n\n\tif (!rdpei->listener_callback)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\trdpei->listener_callback->iface.OnNewChannelConnection = rdpei_on_new_channel_connection;\n\trdpei->listener_callback->plugin = pPlugin;\n\trdpei->listener_callback->channel_mgr = pChannelMgr;\n\n\tif ((error = pChannelMgr->CreateListener(pChannelMgr, RDPEI_DVC_CHANNEL_NAME, 0,\n\t                                         (IWTSListenerCallback*)rdpei->listener_callback,\n\t                                         &(rdpei->listener))))\n\t{\n\t\tWLog_ERR(TAG, \"ChannelMgr->CreateListener failed with error %\" PRIu32 \"!\", error);\n\t\tgoto error_out;\n\t}\n\n\trdpei->listener->pInterface = rdpei->iface.pInterface;\n\n\treturn error;\nerror_out:\n\tfree(rdpei->listener_callback);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_plugin_terminated(IWTSPlugin* pPlugin)\n{\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)pPlugin;\n\n\tif (!pPlugin)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfree(rdpei->listener_callback);\n\tfree(rdpei->context);\n\tfree(rdpei);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Channel Client Interface\n */\n\nstatic int rdpei_get_version(RdpeiClientContext* context)\n{\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\treturn rdpei->version;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT rdpei_send_frame(RdpeiClientContext* context)\n{\n\tUINT64 currentTime;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tRDPEI_CHANNEL_CALLBACK* callback = rdpei->listener_callback->channel_callback;\n\tUINT error;\n\tcurrentTime = GetTickCount64();\n\n\tif (!rdpei->previousFrameTime && !rdpei->currentFrameTime)\n\t{\n\t\trdpei->currentFrameTime = currentTime;\n\t\trdpei->frame.frameOffset = 0;\n\t}\n\telse\n\t{\n\t\trdpei->currentFrameTime = currentTime;\n\t\trdpei->frame.frameOffset = rdpei->currentFrameTime - rdpei->previousFrameTime;\n\t}\n\n\tif ((error = rdpei_send_touch_event_pdu(callback, &rdpei->frame)))\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_send_touch_event_pdu failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\trdpei->previousFrameTime = rdpei->currentFrameTime;\n\trdpei->frame.contactCount = 0;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_add_contact(RdpeiClientContext* context, const RDPINPUT_CONTACT_DATA* contact)\n{\n\tUINT error;\n\tRDPINPUT_CONTACT_POINT* contactPoint;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\n\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[contact->contactId];\n\tCopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));\n\tcontactPoint->dirty = TRUE;\n\n\terror = rdpei_add_frame(context);\n\tif (error != CHANNEL_RC_OK)\n\t{\n\t\tWLog_ERR(TAG, \"rdpei_add_frame failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tif (rdpei->frame.contactCount > 0)\n\t{\n\t\terror = rdpei_send_frame(context);\n\t\tif (error != CHANNEL_RC_OK)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdpei_send_frame failed with error %\" PRIu32 \"!\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_begin(RdpeiClientContext* context, int externalId, int x, int y,\n                              int* contactId)\n{\n\tunsigned int i;\n\tINT64 contactIdlocal = -1;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error = CHANNEL_RC_OK;\n\n\t/* Create a new contact point in an empty slot */\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t{\n\t\t\tcontactPoint->contactId = i;\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tcontactPoint->externalId = externalId;\n\t\t\tcontactPoint->active = TRUE;\n\t\t\tcontactPoint->state = RDPINPUT_CONTACT_STATE_ENGAGED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\t\tcontactPoint->lastX = x;\n\t\tcontactPoint->lastY = y;\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_DOWN;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INRANGE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\terror = context->AddContact(context, &contact);\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_update(RdpeiClientContext* context, int externalId, int x, int y,\n                               int* contactId)\n{\n\tunsigned int i;\n\tint contactIdlocal = -1;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error = CHANNEL_RC_OK;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t\tcontinue;\n\n\t\tif (contactPoint->externalId == externalId)\n\t\t{\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\t\tcontactPoint->lastX = x;\n\t\tcontactPoint->lastY = y;\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_UPDATE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INRANGE;\n\t\tcontact.contactFlags |= CONTACT_FLAG_INCONTACT;\n\t\terror = context->AddContact(context, &contact);\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT rdpei_touch_end(RdpeiClientContext* context, int externalId, int x, int y,\n                            int* contactId)\n{\n\tunsigned int i;\n\tint contactIdlocal = -1;\n\tint tempvalue;\n\tRDPINPUT_CONTACT_DATA contact;\n\tRDPINPUT_CONTACT_POINT* contactPoint = NULL;\n\tRDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;\n\tUINT error;\n\n\tfor (i = 0; i < rdpei->maxTouchContacts; i++)\n\t{\n\t\tcontactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];\n\n\t\tif (!contactPoint->active)\n\t\t\tcontinue;\n\n\t\tif (contactPoint->externalId == externalId)\n\t\t{\n\t\t\tcontactIdlocal = contactPoint->contactId;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (contactIdlocal >= 0)\n\t{\n\t\tZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));\n\n\t\tif ((contactPoint->lastX != x) && (contactPoint->lastY != y))\n\t\t{\n\t\t\tif ((error = context->TouchUpdate(context, externalId, x, y, &tempvalue)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"context->TouchUpdate failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tcontact.x = x;\n\t\tcontact.y = y;\n\t\tcontact.contactId = (UINT32)contactIdlocal;\n\t\tcontact.contactFlags |= CONTACT_FLAG_UP;\n\n\t\tif ((error = context->AddContact(context, &contact)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"context->AddContact failed with error %\" PRIu32 \"!\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tcontactPoint->externalId = 0;\n\t\tcontactPoint->active = FALSE;\n\t\tcontactPoint->flags = 0;\n\t\tcontactPoint->contactId = 0;\n\t\tcontactPoint->state = RDPINPUT_CONTACT_STATE_OUT_OF_RANGE;\n\t}\n\n\t*contactId = contactIdlocal;\n\treturn CHANNEL_RC_OK;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DVCPluginEntry rdpei_DVCPluginEntry\n#else\n#define DVCPluginEntry FREERDP_API DVCPluginEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DVCPluginEntry(IDRDYNVC_ENTRY_POINTS* pEntryPoints)\n{\n\tUINT error;\n\tRDPEI_PLUGIN* rdpei = NULL;\n\tRdpeiClientContext* context = NULL;\n\trdpei = (RDPEI_PLUGIN*)pEntryPoints->GetPlugin(pEntryPoints, \"rdpei\");\n\n\tif (!rdpei)\n\t{\n\t\tsize_t size;\n\t\trdpei = (RDPEI_PLUGIN*)calloc(1, sizeof(RDPEI_PLUGIN));\n\n\t\tif (!rdpei)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\trdpei->iface.Initialize = rdpei_plugin_initialize;\n\t\trdpei->iface.Connected = NULL;\n\t\trdpei->iface.Disconnected = NULL;\n\t\trdpei->iface.Terminated = rdpei_plugin_terminated;\n\t\trdpei->version = 1;\n\t\trdpei->currentFrameTime = 0;\n\t\trdpei->previousFrameTime = 0;\n\t\trdpei->frame.contacts = (RDPINPUT_CONTACT_DATA*)rdpei->contacts;\n\t\trdpei->maxTouchContacts = 10;\n\t\tsize = rdpei->maxTouchContacts * sizeof(RDPINPUT_CONTACT_POINT);\n\t\trdpei->contactPoints = (RDPINPUT_CONTACT_POINT*)calloc(1, size);\n\t\trdpei->rdpcontext =\n\t\t    ((freerdp*)((rdpSettings*)pEntryPoints->GetRdpSettings(pEntryPoints))->instance)\n\t\t        ->context;\n\n\t\tif (!rdpei->contactPoints)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tcontext = (RdpeiClientContext*)calloc(1, sizeof(RdpeiClientContext));\n\n\t\tif (!context)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tcontext->handle = (void*)rdpei;\n\t\tcontext->GetVersion = rdpei_get_version;\n\t\tcontext->AddContact = rdpei_add_contact;\n\t\tcontext->TouchBegin = rdpei_touch_begin;\n\t\tcontext->TouchUpdate = rdpei_touch_update;\n\t\tcontext->TouchEnd = rdpei_touch_end;\n\t\trdpei->iface.pInterface = (void*)context;\n\n\t\tif ((error = pEntryPoints->RegisterPlugin(pEntryPoints, \"rdpei\", (IWTSPlugin*)rdpei)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"EntryPoints->RegisterPlugin failed with error %\" PRIu32 \"!\", error);\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\trdpei->context = context;\n\t}\n\n\treturn CHANNEL_RC_OK;\nerror_out:\n\tfree(context);\n\tfree(rdpei->contactPoints);\n\tfree(rdpei);\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Serial Port Device Service Virtual Channel\n *\n * Copyright 2011 O.S. Systems Software Ltda.\n * Copyright 2011 Eduardo Fiss Beloni <beloni@ossystems.com.br>\n * Copyright 2014 Hewlett-Packard Development Company, L.P.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/collections.h>\n#include <winpr/comm.h>\n#include <winpr/crt.h>\n#include <winpr/stream.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/wlog.h>\n\n#include <freerdp/freerdp.h>\n#include <freerdp/channels/rdpdr.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"serial.client\")\n\n/* TODO: all #ifdef __linux__ could be removed once only some generic\n * functions will be used. Replace CommReadFile by ReadFile,\n * CommWriteFile by WriteFile etc..  */\n#if defined __linux__ && !defined ANDROID\n\n#define MAX_IRP_THREADS 5\n\ntypedef struct _SERIAL_DEVICE SERIAL_DEVICE;\n\nstruct _SERIAL_DEVICE\n{\n\tDEVICE device;\n\tBOOL permissive;\n\tSERIAL_DRIVER_ID ServerSerialDriverId;\n\tHANDLE* hComm;\n\n\twLog* log;\n\tHANDLE MainThread;\n\twMessageQueue* MainIrpQueue;\n\n\t/* one thread per pending IRP and indexed according their CompletionId */\n\twListDictionary* IrpThreads;\n\tUINT32 IrpThreadToBeTerminatedCount;\n\tCRITICAL_SECTION TerminatingIrpThreadsLock;\n\trdpContext* rdpcontext;\n};\n\ntypedef struct _IRP_THREAD_DATA IRP_THREAD_DATA;\n\nstruct _IRP_THREAD_DATA\n{\n\tSERIAL_DEVICE* serial;\n\tIRP* irp;\n};\n\nstatic UINT32 _GetLastErrorToIoStatus(SERIAL_DEVICE* serial)\n{\n\t/* http://msdn.microsoft.com/en-us/library/ff547466%28v=vs.85%29.aspx#generic_status_values_for_serial_device_control_requests\n\t */\n\tswitch (GetLastError())\n\t{\n\t\tcase ERROR_BAD_DEVICE:\n\t\t\treturn STATUS_INVALID_DEVICE_REQUEST;\n\n\t\tcase ERROR_CALL_NOT_IMPLEMENTED:\n\t\t\treturn STATUS_NOT_IMPLEMENTED;\n\n\t\tcase ERROR_CANCELLED:\n\t\t\treturn STATUS_CANCELLED;\n\n\t\tcase ERROR_INSUFFICIENT_BUFFER:\n\t\t\treturn STATUS_BUFFER_TOO_SMALL; /* NB: STATUS_BUFFER_SIZE_TOO_SMALL not defined  */\n\n\t\tcase ERROR_INVALID_DEVICE_OBJECT_PARAMETER: /* eg: SerCx2.sys' _purge() */\n\t\t\treturn STATUS_INVALID_DEVICE_STATE;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\treturn STATUS_INVALID_DEVICE_REQUEST;\n\n\t\tcase ERROR_INVALID_PARAMETER:\n\t\t\treturn STATUS_INVALID_PARAMETER;\n\n\t\tcase ERROR_IO_DEVICE:\n\t\t\treturn STATUS_IO_DEVICE_ERROR;\n\n\t\tcase ERROR_IO_PENDING:\n\t\t\treturn STATUS_PENDING;\n\n\t\tcase ERROR_NOT_SUPPORTED:\n\t\t\treturn STATUS_NOT_SUPPORTED;\n\n\t\tcase ERROR_TIMEOUT:\n\t\t\treturn STATUS_TIMEOUT;\n\t\t\t/* no default */\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"unexpected last-error: 0x%08\" PRIX32 \"\", GetLastError());\n\treturn STATUS_UNSUCCESSFUL;\n}\n\nstatic UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tDWORD DesiredAccess;\n\tDWORD SharedAccess;\n\tDWORD CreateDisposition;\n\tUINT32 PathLength;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (!Stream_SafeSeek(irp->input, PathLength)) /* Path (variable) */\n\t\treturn ERROR_INVALID_DATA;\n\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |\n\t * FILE_SHARE_WRITE | FILE_SHARE_READ CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * assert(DesiredAccess == (GENERIC_READ | GENERIC_WRITE));\n\t * assert(SharedAccess == 0);\n\t * assert(CreateDisposition == OPEN_EXISTING);\n\t *\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" PRIX32\n\t           \", CreateDisposition: 0x%\" PRIX32 \"\",\n\t           DesiredAccess, SharedAccess, CreateDisposition);\n\t/* FIXME: As of today only the flags below are supported by CommCreateFileA: */\n\tDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n\tSharedAccess = 0;\n\tCreateDisposition = OPEN_EXISTING;\n#endif\n\tserial->hComm =\n\t    CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL, /* SecurityAttributes */\n\t               CreateDisposition, 0,                                   /* FlagsAndAttributes */\n\t               NULL);                                                  /* TemplateFile */\n\n\tif (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CreateFile failure: %s last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, GetLastError());\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\t_comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId);\n\t_comm_set_permissive(serial->hComm, serial->permissive);\n\t/* NOTE: binary mode/raw mode required for the redirection. On\n\t * Linux, CommCreateFileA forces this setting.\n\t */\n\t/* ZeroMemory(&dcb, sizeof(DCB)); */\n\t/* dcb.DCBlength = sizeof(DCB); */\n\t/* GetCommState(serial->hComm, &dcb); */\n\t/* dcb.fBinary = TRUE; */\n\t/* SetCommState(serial->hComm, &dcb); */\n\tassert(irp->FileId == 0);\n\tirp->FileId = irp->devman->id_sequence++; /* FIXME: why not ((WINPR_COMM*)hComm)->fd? */\n\tirp->IoStatus = STATUS_SUCCESS;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") created.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\nerror_handle:\n\tStream_Write_UINT32(irp->output, irp->FileId); /* FileId (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);            /* Information (1 byte) */\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT serial_process_irp_close(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, 32); /* Padding (32 bytes) */\n\n\tif (!CloseHandle(serial->hComm))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CloseHandle failure: %s (%\" PRIu32 \") closed.\",\n\t\t           serial->device.name, irp->device->id);\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") closed.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\n\tserial->hComm = NULL;\n\tirp->IoStatus = STATUS_SUCCESS;\nerror_handle:\n\tStream_Zero(irp->output, 5); /* Padding (5 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp_read(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tBYTE* buffer = NULL;\n\tDWORD nbRead = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length); /* Length (4 bytes) */\n\tStream_Read_UINT64(irp->input, Offset); /* Offset (8 bytes) */\n\tStream_Seek(irp->input, 20);            /* Padding (20 bytes) */\n\tbuffer = (BYTE*)calloc(Length, sizeof(BYTE));\n\n\tif (buffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\t/* MS-RDPESP 3.2.5.1.4: If the Offset field is not set to 0, the value MUST be ignored\n\t * assert(Offset == 0);\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG, \"reading %\" PRIu32 \" bytes from %s\", Length,\n\t           serial->device.name);\n\n\t/* FIXME: CommReadFile to be replaced by ReadFile */\n\tif (CommReadFile(serial->hComm, buffer, Length, &nbRead, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"read failure to %s, nbRead=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbRead, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes read from %s\", nbRead,\n\t           serial->device.name);\nerror_handle:\n\tStream_Write_UINT32(irp->output, nbRead); /* Length (4 bytes) */\n\n\tif (nbRead > 0)\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(irp->output, nbRead))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\tfree(buffer);\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tStream_Write(irp->output, buffer, nbRead); /* ReadData */\n\t}\n\n\tfree(buffer);\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\tDWORD nbWritten = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length); /* Length (4 bytes) */\n\tStream_Read_UINT64(irp->input, Offset); /* Offset (8 bytes) */\n\tif (!Stream_SafeSeek(irp->input, 20))   /* Padding (20 bytes) */\n\t\treturn ERROR_INVALID_DATA;\n\n\t/* MS-RDPESP 3.2.5.1.5: The Offset field is ignored\n\t * assert(Offset == 0);\n\t *\n\t * Using a serial printer, noticed though this field could be\n\t * set.\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\t/* FIXME: CommWriteFile to be replaced by WriteFile */\n\tif (CommWriteFile(serial->hComm, ptr, Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); /* Length (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);          /* Padding (1 byte) */\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp_device_control(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 IoControlCode;\n\tUINT32 InputBufferLength;\n\tBYTE* InputBuffer = NULL;\n\tUINT32 OutputBufferLength;\n\tBYTE* OutputBuffer = NULL;\n\tDWORD BytesReturned = 0;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, OutputBufferLength); /* OutputBufferLength (4 bytes) */\n\tStream_Read_UINT32(irp->input, InputBufferLength);  /* InputBufferLength (4 bytes) */\n\tStream_Read_UINT32(irp->input, IoControlCode);      /* IoControlCode (4 bytes) */\n\tStream_Seek(irp->input, 20);                        /* Padding (20 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < InputBufferLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tOutputBuffer = (BYTE*)calloc(OutputBufferLength, sizeof(BYTE));\n\n\tif (OutputBuffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\tInputBuffer = (BYTE*)calloc(InputBufferLength, sizeof(BYTE));\n\n\tif (InputBuffer == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_NO_MEMORY;\n\t\tgoto error_handle;\n\t}\n\n\tStream_Read(irp->input, InputBuffer, InputBufferLength);\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"CommDeviceIoControl: CompletionId=%\" PRIu32 \", IoControlCode=[0x%\" PRIX32 \"] %s\",\n\t           irp->CompletionId, IoControlCode, _comm_serial_ioctl_name(IoControlCode));\n\n\t/* FIXME: CommDeviceIoControl to be replaced by DeviceIoControl() */\n\tif (CommDeviceIoControl(serial->hComm, IoControlCode, InputBuffer, InputBufferLength,\n\t                        OutputBuffer, OutputBufferLength, &BytesReturned, NULL))\n\t{\n\t\t/* WLog_Print(serial->log, WLOG_DEBUG, \"CommDeviceIoControl: CompletionId=%\"PRIu32\",\n\t\t * IoControlCode=[0x%\"PRIX32\"] %s done\", irp->CompletionId, IoControlCode,\n\t\t * _comm_serial_ioctl_name(IoControlCode)); */\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"CommDeviceIoControl failure: IoControlCode=[0x%\" PRIX32\n\t\t           \"] %s, last-error: 0x%08\" PRIX32 \"\",\n\t\t           IoControlCode, _comm_serial_ioctl_name(IoControlCode), GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\nerror_handle:\n\t/* FIXME: find out whether it's required or not to get\n\t * BytesReturned == OutputBufferLength when\n\t * CommDeviceIoControl returns FALSE */\n\tassert(OutputBufferLength == BytesReturned);\n\tStream_Write_UINT32(irp->output, BytesReturned); /* OutputBufferLength (4 bytes) */\n\n\tif (BytesReturned > 0)\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(irp->output, BytesReturned))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\tfree(InputBuffer);\n\t\t\tfree(OutputBuffer);\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tStream_Write(irp->output, OutputBuffer, BytesReturned); /* OutputBuffer */\n\t}\n\n\t/* FIXME: Why at least Windows 2008R2 gets lost with this\n\t * extra byte and likely on a IOCTL_SERIAL_SET_BAUD_RATE? The\n\t * extra byte is well required according MS-RDPEFS\n\t * 2.2.1.5.5 */\n\t/* else */\n\t/* { */\n\t/* \tStream_Write_UINT8(irp->output, 0); /\\* Padding (1 byte) *\\/ */\n\t/* } */\n\tfree(InputBuffer);\n\tfree(OutputBuffer);\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_process_irp(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT error = CHANNEL_RC_OK;\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"IRP MajorFunction: 0x%08\" PRIX32 \" MinorFunction: 0x%08\" PRIX32 \"\\n\",\n\t           irp->MajorFunction, irp->MinorFunction);\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = serial_process_irp_create(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = serial_process_irp_close(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\tif ((error = serial_process_irp_read(serial, irp)))\n\t\t\t\tWLog_ERR(TAG, \"serial_process_irp_read failed with error %\" PRIu32 \"!\", error);\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = serial_process_irp_write(serial, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\tif ((error = serial_process_irp_device_control(serial, irp)))\n\t\t\t\tWLog_ERR(TAG, \"serial_process_irp_device_control failed with error %\" PRIu32 \"!\",\n\t\t\t\t         error);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI irp_thread_func(LPVOID arg)\n{\n\tIRP_THREAD_DATA* data = (IRP_THREAD_DATA*)arg;\n\tUINT error;\n\n\t/* blocks until the end of the request */\n\tif ((error = serial_process_irp(data->serial, data->irp)))\n\t{\n\t\tWLog_ERR(TAG, \"serial_process_irp failed with error %\" PRIu32 \"\", error);\n\t\tgoto error_out;\n\t}\n\n\tEnterCriticalSection(&data->serial->TerminatingIrpThreadsLock);\n\tdata->serial->IrpThreadToBeTerminatedCount++;\n\terror = data->irp->Complete(data->irp);\n\tLeaveCriticalSection(&data->serial->TerminatingIrpThreadsLock);\nerror_out:\n\n\tif (error && data->serial->rdpcontext)\n\t\tsetChannelError(data->serial->rdpcontext, error, \"irp_thread_func reported an error\");\n\n\t/* NB: At this point, the server might already being reusing\n\t * the CompletionId whereas the thread is not yet\n\t * terminated */\n\tfree(data);\n\tExitThread(error);\n\treturn error;\n}\n\nstatic void create_irp_thread(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tIRP_THREAD_DATA* data = NULL;\n\tHANDLE irpThread;\n\tHANDLE previousIrpThread;\n\tuintptr_t key;\n\t/* for a test/debug purpose, uncomment the code below to get a\n\t * single thread for all IRPs. NB: two IRPs could not be\n\t * processed at the same time, typically two concurent\n\t * Read/Write operations could block each other. */\n\t/* serial_process_irp(serial, irp); */\n\t/* irp->Complete(irp); */\n\t/* return; */\n\t/* NOTE: for good or bad, this implementation relies on the\n\t * server to avoid a flooding of requests. see also _purge().\n\t */\n\tEnterCriticalSection(&serial->TerminatingIrpThreadsLock);\n\n\twhile (serial->IrpThreadToBeTerminatedCount > 0)\n\t{\n\t\t/* Cleaning up termitating and pending irp\n\t\t * threads. See also: irp_thread_func() */\n\t\tHANDLE irpThread;\n\t\tULONG_PTR* ids;\n\t\tint i, nbIds;\n\t\tnbIds = ListDictionary_GetKeys(serial->IrpThreads, &ids);\n\n\t\tfor (i = 0; i < nbIds; i++)\n\t\t{\n\t\t\t/* Checking if ids[i] is terminating or pending */\n\t\t\tDWORD waitResult;\n\t\t\tULONG_PTR id = ids[i];\n\t\t\tirpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)id);\n\t\t\t/* FIXME: not quite sure a zero timeout is a good thing to check whether a thread is\n\t\t\t * stil alived or not */\n\t\t\twaitResult = WaitForSingleObject(irpThread, 0);\n\n\t\t\tif (waitResult == WAIT_OBJECT_0)\n\t\t\t{\n\t\t\t\t/* terminating thread */\n\t\t\t\t/* WLog_Print(serial->log, WLOG_DEBUG, \"IRP thread with CompletionId=%\"PRIuz\"\n\t\t\t\t * naturally died\", id); */\n\t\t\t\tCloseHandle(irpThread);\n\t\t\t\tListDictionary_Remove(serial->IrpThreads, (void*)id);\n\t\t\t\tserial->IrpThreadToBeTerminatedCount--;\n\t\t\t}\n\t\t\telse if (waitResult != WAIT_TIMEOUT)\n\t\t\t{\n\t\t\t\t/* unexpected thread state */\n\t\t\t\tWLog_Print(serial->log, WLOG_WARN,\n\t\t\t\t           \"WaitForSingleObject, got an unexpected result=0x%\" PRIX32 \"\\n\",\n\t\t\t\t           waitResult);\n\t\t\t\tassert(FALSE);\n\t\t\t}\n\n\t\t\t/* pending thread (but not yet terminating thread) if waitResult == WAIT_TIMEOUT */\n\t\t}\n\n\t\tif (serial->IrpThreadToBeTerminatedCount > 0)\n\t\t{\n\t\t\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" IRP thread(s) not yet terminated\",\n\t\t\t           serial->IrpThreadToBeTerminatedCount);\n\t\t\tSleep(1); /* 1 ms */\n\t\t}\n\n\t\tfree(ids);\n\t}\n\n\tLeaveCriticalSection(&serial->TerminatingIrpThreadsLock);\n\t/* NB: At this point and thanks to the synchronization we're\n\t * sure that the incoming IRP uses well a recycled\n\t * CompletionId or the server sent again an IRP already posted\n\t * which didn't get yet a response (this later server behavior\n\t * at least observed with IOCTL_SERIAL_WAIT_ON_MASK and\n\t * mstsc.exe).\n\t *\n\t * FIXME: behavior documented somewhere? behavior not yet\n\t * observed with FreeRDP).\n\t */\n\tkey = irp->CompletionId;\n\tpreviousIrpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)key);\n\n\tif (previousIrpThread)\n\t{\n\t\t/* Thread still alived <=> Request still pending */\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"IRP recall: IRP with the CompletionId=%\" PRIu32 \" not yet completed!\",\n\t\t           irp->CompletionId);\n\t\tassert(FALSE); /* unimplemented */\n\t\t/* TODO: asserts that previousIrpThread handles well\n\t\t * the same request by checking more details. Need an\n\t\t * access to the IRP object used by previousIrpThread\n\t\t */\n\t\t/* TODO: taking over the pending IRP or sending a kind\n\t\t * of wake up signal to accelerate the pending\n\t\t * request\n\t\t *\n\t\t * To be considered:\n\t\t *   if (IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) {\n\t\t *       pComm->PendingEvents |= SERIAL_EV_FREERDP_*;\n\t\t *   }\n\t\t */\n\t\tirp->Discard(irp);\n\t\treturn;\n\t}\n\n\tif (ListDictionary_Count(serial->IrpThreads) >= MAX_IRP_THREADS)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN,\n\t\t           \"Number of IRP threads threshold reached: %d, keep on anyway\",\n\t\t           ListDictionary_Count(serial->IrpThreads));\n\t\tassert(FALSE); /* unimplemented */\n\t\t               /* TODO: MAX_IRP_THREADS has been thought to avoid a\n\t\t                * flooding of pending requests. Use\n\t\t                * WaitForMultipleObjects() when available in winpr\n\t\t                * for threads.\n\t\t                */\n\t}\n\n\t/* error_handle to be used ... */\n\tdata = (IRP_THREAD_DATA*)calloc(1, sizeof(IRP_THREAD_DATA));\n\n\tif (data == NULL)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"Could not allocate a new IRP_THREAD_DATA.\");\n\t\tgoto error_handle;\n\t}\n\n\tdata->serial = serial;\n\tdata->irp = irp;\n\t/* data freed by irp_thread_func */\n\tirpThread = CreateThread(NULL, 0, irp_thread_func, (void*)data, 0, NULL);\n\n\tif (irpThread == INVALID_HANDLE_VALUE)\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"Could not allocate a new IRP thread.\");\n\t\tgoto error_handle;\n\t}\n\n\tkey = irp->CompletionId;\n\n\tif (!ListDictionary_Add(serial->IrpThreads, (void*)key, irpThread))\n\t{\n\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\tgoto error_handle;\n\t}\n\n\treturn;\nerror_handle:\n\tirp->IoStatus = STATUS_NO_MEMORY;\n\tirp->Complete(irp);\n\tfree(data);\n}\n\nstatic void terminate_pending_irp_threads(SERIAL_DEVICE* serial)\n{\n\tULONG_PTR* ids;\n\tint i, nbIds;\n\tnbIds = ListDictionary_GetKeys(serial->IrpThreads, &ids);\n\tWLog_Print(serial->log, WLOG_DEBUG, \"Terminating %d IRP thread(s)\", nbIds);\n\n\tfor (i = 0; i < nbIds; i++)\n\t{\n\t\tHANDLE irpThread;\n\t\tULONG_PTR id = ids[i];\n\t\tirpThread = ListDictionary_GetItemValue(serial->IrpThreads, (void*)id);\n\t\tTerminateThread(irpThread, 0);\n\n\t\tif (WaitForSingleObject(irpThread, INFINITE) == WAIT_FAILED)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"WaitForSingleObject failed!\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tCloseHandle(irpThread);\n\t\tWLog_Print(serial->log, WLOG_DEBUG, \"IRP thread terminated, CompletionId %p\", (void*)id);\n\t}\n\n\tListDictionary_Clear(serial->IrpThreads);\n\tfree(ids);\n}\n\nstatic DWORD WINAPI serial_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(serial->MainIrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(serial->MainIrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t{\n\t\t\tterminate_pending_irp_threads(serial);\n\t\t\tbreak;\n\t\t}\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t\tcreate_irp_thread(serial, irp);\n\t}\n\n\tif (error && serial->rdpcontext)\n\t\tsetChannelError(serial->rdpcontext, error, \"serial_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_irp_request(DEVICE* device, IRP* irp)\n{\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)device;\n\tassert(irp != NULL);\n\n\tif (irp == NULL)\n\t\treturn CHANNEL_RC_OK;\n\n\t/* NB: ENABLE_ASYNCIO is set, (MS-RDPEFS 2.2.2.7.2) this\n\t * allows the server to send multiple simultaneous read or\n\t * write requests.\n\t */\n\n\tif (!MessageQueue_Post(serial->MainIrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT serial_free(DEVICE* device)\n{\n\tUINT error;\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)device;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"freeing\");\n\tMessageQueue_PostQuit(serial->MainIrpQueue, 0);\n\n\tif (WaitForSingleObject(serial->MainThread, INFINITE) == WAIT_FAILED)\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\n\tCloseHandle(serial->MainThread);\n\n\tif (serial->hComm)\n\t\tCloseHandle(serial->hComm);\n\n\t/* Clean up resources */\n\tStream_Free(serial->device.data, TRUE);\n\tMessageQueue_Free(serial->MainIrpQueue);\n\tListDictionary_Free(serial->IrpThreads);\n\tDeleteCriticalSection(&serial->TerminatingIrpThreadsLock);\n\tfree(serial);\n\treturn CHANNEL_RC_OK;\n}\n\n#endif /* __linux__ */\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry serial_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tchar* name;\n\tchar* path;\n\tchar* driver;\n\tRDPDR_SERIAL* device;\n#if defined __linux__ && !defined ANDROID\n\tsize_t i, len;\n\tSERIAL_DEVICE* serial;\n#endif /* __linux__ */\n\tUINT error = CHANNEL_RC_OK;\n\tdevice = (RDPDR_SERIAL*)pEntryPoints->device;\n\tname = device->Name;\n\tpath = device->Path;\n\tdriver = device->Driver;\n\n\tif (!name || (name[0] == '*'))\n\t{\n\t\t/* TODO: implement auto detection of serial ports */\n\t\treturn CHANNEL_RC_OK;\n\t}\n\n\tif ((name && name[0]) && (path && path[0]))\n\t{\n\t\twLog* log;\n\t\tlog = WLog_Get(\"com.freerdp.channel.serial.client\");\n\t\tWLog_Print(log, WLOG_DEBUG, \"initializing\");\n#ifndef __linux__ /* to be removed */\n\t\tWLog_Print(log, WLOG_WARN, \"Serial ports redirection not supported on this platform.\");\n\t\treturn CHANNEL_RC_INITIALIZATION_ERROR;\n#else /* __linux __ */\n\t\tWLog_Print(log, WLOG_DEBUG, \"Defining %s as %s\", name, path);\n\n\t\tif (!DefineCommDevice(name /* eg: COM1 */, path /* eg: /dev/ttyS0 */))\n\t\t{\n\t\t\tDWORD status = GetLastError();\n\t\t\tWLog_ERR(TAG, \"DefineCommDevice failed with %08\" PRIx32, status);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tserial = (SERIAL_DEVICE*)calloc(1, sizeof(SERIAL_DEVICE));\n\n\t\tif (!serial)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tserial->log = log;\n\t\tserial->device.type = RDPDR_DTYP_SERIAL;\n\t\tserial->device.name = name;\n\t\tserial->device.IRPRequest = serial_irp_request;\n\t\tserial->device.Free = serial_free;\n\t\tserial->rdpcontext = pEntryPoints->rdpcontext;\n\t\tlen = strlen(name);\n\t\tserial->device.data = Stream_New(NULL, len + 1);\n\n\t\tif (!serial->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tfor (i = 0; i <= len; i++)\n\t\t\tStream_Write_UINT8(serial->device.data, name[i] < 0 ? '_' : name[i]);\n\n\t\tif (driver != NULL)\n\t\t{\n\t\t\tif (_stricmp(driver, \"Serial\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t\telse if (_stricmp(driver, \"SerCx\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerCxSys;\n\t\t\telse if (_stricmp(driver, \"SerCx2\") == 0)\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerCx2Sys;\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(FALSE);\n\t\t\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t\t\t           \"Unknown server's serial driver: %s. SerCx2 will be used\", driver);\n\t\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* default driver */\n\t\t\tserial->ServerSerialDriverId = SerialDriverSerialSys;\n\t\t}\n\n\t\tif (device->Permissive != NULL)\n\t\t{\n\t\t\tif (_stricmp(device->Permissive, \"permissive\") == 0)\n\t\t\t{\n\t\t\t\tserial->permissive = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_Print(serial->log, WLOG_DEBUG, \"Unknown flag: %s\", device->Permissive);\n\t\t\t\tassert(FALSE);\n\t\t\t}\n\t\t}\n\n\t\tWLog_Print(serial->log, WLOG_DEBUG, \"Server's serial driver: %s (id: %d)\", driver,\n\t\t           serial->ServerSerialDriverId);\n\t\t/* TODO: implement auto detection of the server's serial driver */\n\t\tserial->MainIrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!serial->MainIrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\t/* IrpThreads content only modified by create_irp_thread() */\n\t\tserial->IrpThreads = ListDictionary_New(FALSE);\n\n\t\tif (!serial->IrpThreads)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tserial->IrpThreadToBeTerminatedCount = 0;\n\t\tInitializeCriticalSection(&serial->TerminatingIrpThreadsLock);\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)serial)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"EntryPoints->RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (!(serial->MainThread =\n\t\t          CreateThread(NULL, 0, serial_thread_func, (void*)serial, 0, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tgoto error_out;\n\t\t}\n\n#endif /* __linux __ */\n\t}\n\n\treturn error;\nerror_out:\n#ifdef __linux__ /* to be removed */\n\tListDictionary_Free(serial->IrpThreads);\n\tMessageQueue_Free(serial->MainIrpQueue);\n\tStream_Free(serial->device.data, TRUE);\n\tfree(serial);\n#endif /* __linux __ */\n\treturn error;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Remote Desktop Gateway (RDG)\n *\n * Copyright 2015 Denis Vincent <dvincent@devolutions.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/print.h>\n#include <winpr/stream.h>\n#include <winpr/winsock.h>\n\n#include <freerdp/log.h>\n#include <freerdp/error.h>\n#include <freerdp/utils/ringbuffer.h>\n\n#include \"rdg.h\"\n#include \"../proxy.h\"\n#include \"../rdp.h\"\n#include \"../../crypto/opensslcompat.h\"\n#include \"rpc_fault.h\"\n\n#define TAG FREERDP_TAG(\"core.gateway.rdg\")\n\n/* HTTP channel response fields present flags. */\n#define HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID 0x1\n#define HTTP_CHANNEL_RESPONSE_OPTIONAL 0x2\n#define HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT 0x4\n\n/* HTTP extended auth. */\n#define HTTP_EXTENDED_AUTH_NONE 0x0\n#define HTTP_EXTENDED_AUTH_SC 0x1         /* Smart card authentication. */\n#define HTTP_EXTENDED_AUTH_PAA 0x02       /* Pluggable authentication. */\n#define HTTP_EXTENDED_AUTH_SSPI_NTLM 0x04 /* NTLM extended authentication. */\n\n/* HTTP packet types. */\n#define PKT_TYPE_HANDSHAKE_REQUEST 0x1\n#define PKT_TYPE_HANDSHAKE_RESPONSE 0x2\n#define PKT_TYPE_EXTENDED_AUTH_MSG 0x3\n#define PKT_TYPE_TUNNEL_CREATE 0x4\n#define PKT_TYPE_TUNNEL_RESPONSE 0x5\n#define PKT_TYPE_TUNNEL_AUTH 0x6\n#define PKT_TYPE_TUNNEL_AUTH_RESPONSE 0x7\n#define PKT_TYPE_CHANNEL_CREATE 0x8\n#define PKT_TYPE_CHANNEL_RESPONSE 0x9\n#define PKT_TYPE_DATA 0xA\n#define PKT_TYPE_SERVICE_MESSAGE 0xB\n#define PKT_TYPE_REAUTH_MESSAGE 0xC\n#define PKT_TYPE_KEEPALIVE 0xD\n#define PKT_TYPE_CLOSE_CHANNEL 0x10\n#define PKT_TYPE_CLOSE_CHANNEL_RESPONSE 0x11\n\n/* HTTP tunnel auth fields present flags. */\n#define HTTP_TUNNEL_AUTH_FIELD_SOH 0x1\n\n/* HTTP tunnel auth response fields present flags. */\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS 0x1\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT 0x2\n#define HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE 0x4\n\n/* HTTP tunnel packet fields present flags. */\n#define HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE 0x1\n#define HTTP_TUNNEL_PACKET_FIELD_REAUTH 0x2\n\n/* HTTP tunnel redir flags. */\n#define HTTP_TUNNEL_REDIR_ENABLE_ALL 0x80000000\n#define HTTP_TUNNEL_REDIR_DISABLE_ALL 0x40000000\n#define HTTP_TUNNEL_REDIR_DISABLE_DRIVE 0x1\n#define HTTP_TUNNEL_REDIR_DISABLE_PRINTER 0x2\n#define HTTP_TUNNEL_REDIR_DISABLE_PORT 0x4\n#define HTTP_TUNNEL_REDIR_DISABLE_CLIPBOARD 0x8\n#define HTTP_TUNNEL_REDIR_DISABLE_PNP 0x10\n\n/* HTTP tunnel response fields present flags. */\n#define HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID 0x1\n#define HTTP_TUNNEL_RESPONSE_FIELD_CAPS 0x2\n#define HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ 0x4\n#define HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG 0x10\n\n/* HTTP capability type enumeration. */\n#define HTTP_CAPABILITY_TYPE_QUAR_SOH 0x1\n#define HTTP_CAPABILITY_IDLE_TIMEOUT 0x2\n#define HTTP_CAPABILITY_MESSAGING_CONSENT_SIGN 0x4\n#define HTTP_CAPABILITY_MESSAGING_SERVICE_MSG 0x8\n#define HTTP_CAPABILITY_REAUTH 0x10\n#define HTTP_CAPABILITY_UDP_TRANSPORT 0x20\n\nstruct rdp_rdg\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tBOOL attached;\n\tBIO* frontBio;\n\trdpTls* tlsIn;\n\trdpTls* tlsOut;\n\trdpNtlm* ntlm;\n\tHttpContext* http;\n\tCRITICAL_SECTION writeSection;\n\n\tUUID guid;\n\n\tint state;\n\tUINT16 packetRemainingCount;\n\tUINT16 reserved1;\n\tint timeout;\n\tUINT16 extAuth;\n\tUINT16 reserved2;\n};\n\nenum\n{\n\tRDG_CLIENT_STATE_INITIAL,\n\tRDG_CLIENT_STATE_HANDSHAKE,\n\tRDG_CLIENT_STATE_TUNNEL_CREATE,\n\tRDG_CLIENT_STATE_TUNNEL_AUTHORIZE,\n\tRDG_CLIENT_STATE_CHANNEL_CREATE,\n\tRDG_CLIENT_STATE_OPENED,\n};\n\n#pragma pack(push, 1)\n\ntypedef struct rdg_packet_header\n{\n\tUINT16 type;\n\tUINT16 reserved;\n\tUINT32 packetLength;\n} RdgPacketHeader;\n\n#pragma pack(pop)\n\ntypedef struct\n{\n\tUINT32 code;\n\tconst char* name;\n} t_err_mapping;\n\nstatic const t_err_mapping tunnel_response_fields_present[] = {\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID, \"HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_CAPS, \"HTTP_TUNNEL_RESPONSE_FIELD_CAPS\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ, \"HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ\" },\n\t{ HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG, \"HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG\" }\n};\n\nstatic const t_err_mapping channel_response_fields_present[] = {\n\t{ HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID, \"HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID\" },\n\t{ HTTP_CHANNEL_RESPONSE_OPTIONAL, \"HTTP_CHANNEL_RESPONSE_OPTIONAL\" },\n\t{ HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT, \"HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT\" }\n};\n\nstatic const t_err_mapping tunnel_authorization_response_fields_present[] = {\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS, \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS\" },\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT,\n\t  \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT\" },\n\t{ HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE,\n\t  \"HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE\" }\n};\n\nstatic const t_err_mapping extended_auth[] = {\n\t{ HTTP_EXTENDED_AUTH_NONE, \"HTTP_EXTENDED_AUTH_NONE\" },\n\t{ HTTP_EXTENDED_AUTH_SC, \"HTTP_EXTENDED_AUTH_SC\" },\n\t{ HTTP_EXTENDED_AUTH_PAA, \"HTTP_EXTENDED_AUTH_PAA\" },\n\t{ HTTP_EXTENDED_AUTH_SSPI_NTLM, \"HTTP_EXTENDED_AUTH_SSPI_NTLM\" }\n};\n\nstatic const char* fields_present_to_string(UINT16 fieldsPresent, const t_err_mapping* map,\n                                            size_t elements)\n{\n\tsize_t x = 0;\n\tstatic char buffer[1024] = { 0 };\n\tchar fields[12];\n\tmemset(buffer, 0, sizeof(buffer));\n\n\tfor (x = 0; x < elements; x++)\n\t{\n\t\tif (buffer[0] != '\\0')\n\t\t\tstrcat(buffer, \"|\");\n\n\t\tif ((map[x].code & fieldsPresent) != 0)\n\t\t\tstrcat(buffer, map[x].name);\n\t}\n\n\tsprintf_s(fields, ARRAYSIZE(fields), \" [%04\" PRIx16 \"]\", fieldsPresent);\n\tstrcat(buffer, fields);\n\treturn buffer;\n}\n\nstatic const char* channel_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, channel_response_fields_present,\n\t                                ARRAYSIZE(channel_response_fields_present));\n}\n\nstatic const char* tunnel_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, tunnel_response_fields_present,\n\t                                ARRAYSIZE(tunnel_response_fields_present));\n}\n\nstatic const char* tunnel_authorization_response_fields_present_to_string(UINT16 fieldsPresent)\n{\n\treturn fields_present_to_string(fieldsPresent, tunnel_authorization_response_fields_present,\n\t                                ARRAYSIZE(tunnel_authorization_response_fields_present));\n}\n\nstatic const char* extended_auth_to_string(UINT16 auth)\n{\n\tif (auth == HTTP_EXTENDED_AUTH_NONE)\n\t\treturn \"HTTP_EXTENDED_AUTH_NONE [0x0000]\";\n\n\treturn fields_present_to_string(auth, extended_auth, ARRAYSIZE(extended_auth));\n}\n\nstatic BOOL rdg_write_packet(rdpRdg* rdg, wStream* sPacket)\n{\n\tsize_t s;\n\tint status;\n\twStream* sChunk;\n\tchar chunkSize[11];\n\tsprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIXz \"\\r\\n\", Stream_Length(sPacket));\n\tsChunk = Stream_New(NULL, strnlen(chunkSize, sizeof(chunkSize)) + Stream_Length(sPacket) + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, strnlen(chunkSize, sizeof(chunkSize)));\n\tStream_Write(sChunk, Stream_Buffer(sPacket), Stream_Length(sPacket));\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s > INT_MAX)\n\t\treturn FALSE;\n\n\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\tStream_Free(sChunk, TRUE);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_read_all(rdpTls* tls, BYTE* buffer, int size)\n{\n\tint status;\n\tint readCount = 0;\n\tBYTE* pBuffer = buffer;\n\n\twhile (readCount < size)\n\t{\n\t\tstatus = BIO_read(tls->bio, pBuffer, size - readCount);\n\n\t\tif (status <= 0)\n\t\t{\n\t\t\tif (!BIO_should_retry(tls->bio))\n\t\t\t\treturn FALSE;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\treadCount += status;\n\t\tpBuffer += status;\n\t}\n\n\treturn TRUE;\n}\n\nstatic wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength) ||\n\t    (packetLength < header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}\n\nstatic BOOL rdg_send_handshake(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\ts = Stream_New(NULL, 14);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, PKT_TYPE_HANDSHAKE_REQUEST); /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                          /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, 14);                         /* PacketLength (4 bytes) */\n\tStream_Write_UINT8(s, 1);                           /* VersionMajor (1 byte) */\n\tStream_Write_UINT8(s, 0);                           /* VersionMinor (1 byte) */\n\tStream_Write_UINT16(s, 0);                          /* ClientVersion (2 bytes), must be 0 */\n\tStream_Write_UINT16(s, rdg->extAuth);               /* ExtendedAuthentication (2 bytes) */\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_HANDSHAKE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_tunnel_request(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\tUINT32 packetSize = 16;\n\tUINT16 fieldsPresent = 0;\n\tWCHAR* PAACookie = NULL;\n\tint PAACookieLen = 0;\n\n\tif (rdg->extAuth == HTTP_EXTENDED_AUTH_PAA)\n\t{\n\t\tPAACookieLen =\n\t\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->GatewayAccessToken, -1, &PAACookie, 0);\n\n\t\tif (!PAACookie || (PAACookieLen < 0) || (PAACookieLen > UINT16_MAX / 2))\n\t\t{\n\t\t\tfree(PAACookie);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpacketSize += 2 + (UINT32)PAACookieLen * sizeof(WCHAR);\n\t\tfieldsPresent = HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE;\n\t}\n\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t{\n\t\tfree(PAACookie);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT16(s, PKT_TYPE_TUNNEL_CREATE);        /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);                    /* PacketLength (4 bytes) */\n\tStream_Write_UINT32(s, HTTP_CAPABILITY_TYPE_QUAR_SOH); /* CapabilityFlags (4 bytes) */\n\tStream_Write_UINT16(s, fieldsPresent);                 /* FieldsPresent (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* Reserved (2 bytes), must be 0 */\n\n\tif (PAACookie)\n\t{\n\t\tStream_Write_UINT16(s, (UINT16)PAACookieLen * 2); /* PAA cookie string length */\n\t\tStream_Write_UTF16_String(s, PAACookie, (size_t)PAACookieLen);\n\t}\n\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\tfree(PAACookie);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_TUNNEL_CREATE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_tunnel_authorization(rdpRdg* rdg)\n{\n\twStream* s;\n\tBOOL status;\n\tWCHAR* clientName = NULL;\n\tUINT32 packetSize;\n\tint clientNameLen =\n\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->ClientHostname, -1, &clientName, 0);\n\n\tif (!clientName || (clientNameLen < 0) || (clientNameLen > UINT16_MAX / 2))\n\t{\n\t\tfree(clientName);\n\t\treturn FALSE;\n\t}\n\n\tpacketSize = 12 + (UINT32)clientNameLen * sizeof(WCHAR);\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t{\n\t\tfree(clientName);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT16(s, PKT_TYPE_TUNNEL_AUTH);      /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                         /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);                /* PacketLength (4 bytes) */\n\tStream_Write_UINT16(s, 0);                         /* FieldsPresent (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)clientNameLen * 2); /* Client name string length */\n\tStream_Write_UTF16_String(s, clientName, (size_t)clientNameLen);\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\n\tStream_Free(s, TRUE);\n\tfree(clientName);\n\n\tif (status)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_TUNNEL_AUTHORIZE;\n\t}\n\n\treturn status;\n}\n\nstatic BOOL rdg_send_channel_create(rdpRdg* rdg)\n{\n\twStream* s = NULL;\n\tBOOL status = FALSE;\n\tWCHAR* serverName = NULL;\n\tint serverNameLen =\n\t    ConvertToUnicode(CP_UTF8, 0, rdg->settings->ServerHostname, -1, &serverName, 0);\n\tUINT32 packetSize = 16 + ((UINT32)serverNameLen) * 2;\n\n\tif ((serverNameLen < 0) || (serverNameLen > UINT16_MAX / 2))\n\t\tgoto fail;\n\n\ts = Stream_New(NULL, packetSize);\n\n\tif (!s)\n\t\tgoto fail;\n\n\tStream_Write_UINT16(s, PKT_TYPE_CHANNEL_CREATE); /* Type (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* Reserved (2 bytes) */\n\tStream_Write_UINT32(s, packetSize);              /* PacketLength (4 bytes) */\n\tStream_Write_UINT8(s, 1);                        /* Number of resources. (1 byte) */\n\tStream_Write_UINT8(s, 0);                        /* Number of alternative resources (1 byte) */\n\tStream_Write_UINT16(s, (UINT16)rdg->settings->ServerPort); /* Resource port (2 bytes) */\n\tStream_Write_UINT16(s, 3);                                 /* Protocol number (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)serverNameLen * 2);\n\tStream_Write_UTF16_String(s, serverName, (size_t)serverNameLen);\n\tStream_SealLength(s);\n\tstatus = rdg_write_packet(rdg, s);\nfail:\n\tfree(serverName);\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t\trdg->state = RDG_CLIENT_STATE_CHANNEL_CREATE;\n\n\treturn status;\n}\n\nstatic BOOL rdg_set_ntlm_auth_header(rdpNtlm* ntlm, HttpRequest* request)\n{\n\tconst SecBuffer* ntlmToken = ntlm_client_get_output_buffer(ntlm);\n\tchar* base64NtlmToken = NULL;\n\n\tif (ntlmToken)\n\t{\n\t\tif (ntlmToken->cbBuffer > INT_MAX)\n\t\t\treturn FALSE;\n\n\t\tbase64NtlmToken = crypto_base64_encode(ntlmToken->pvBuffer, (int)ntlmToken->cbBuffer);\n\t}\n\n\tif (base64NtlmToken)\n\t{\n\t\tBOOL rc = http_request_set_auth_scheme(request, \"NTLM\") &&\n\t\t          http_request_set_auth_param(request, base64NtlmToken);\n\t\tfree(base64NtlmToken);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic wStream* rdg_build_http_request(rdpRdg* rdg, const char* method,\n                                       const char* transferEncoding)\n{\n\twStream* s = NULL;\n\tHttpRequest* request = NULL;\n\tconst char* uri;\n\n\tif (!rdg || !method)\n\t\treturn NULL;\n\n\turi = http_context_get_uri(rdg->http);\n\trequest = http_request_new();\n\n\tif (!request)\n\t\treturn NULL;\n\n\tif (!http_request_set_method(request, method) || !http_request_set_uri(request, uri))\n\t\tgoto out;\n\n\tif (rdg->ntlm)\n\t{\n\t\tif (!rdg_set_ntlm_auth_header(rdg->ntlm, request))\n\t\t\tgoto out;\n\t}\n\n\tif (transferEncoding)\n\t{\n\t\thttp_request_set_transfer_encoding(request, transferEncoding);\n\t}\n\n\ts = http_request_write(rdg->http, request);\nout:\n\thttp_request_free(request);\n\n\tif (s)\n\t\tStream_SealLength(s);\n\n\treturn s;\n}\n\nstatic BOOL rdg_handle_ntlm_challenge(rdpNtlm* ntlm, HttpResponse* response)\n{\n\tBOOL continueNeeded = FALSE;\n\tsize_t len;\n\tconst char* token64 = NULL;\n\tint ntlmTokenLength = 0;\n\tBYTE* ntlmTokenData = NULL;\n\tlong StatusCode;\n\n\tif (!ntlm || !response)\n\t\treturn FALSE;\n\n\tStatusCode = http_response_get_status_code(response);\n\n\tif (StatusCode != HTTP_STATUS_DENIED)\n\t{\n\t\tWLog_DBG(TAG, \"Unexpected NTLM challenge HTTP status: %ld\", StatusCode);\n\t\treturn FALSE;\n\t}\n\n\ttoken64 = http_response_get_auth_token(response, \"NTLM\");\n\n\tif (!token64)\n\t\treturn FALSE;\n\n\tlen = strlen(token64);\n\n\tif (len > INT_MAX)\n\t\treturn FALSE;\n\n\tcrypto_base64_decode(token64, (int)len, &ntlmTokenData, &ntlmTokenLength);\n\n\tif (ntlmTokenLength < 0)\n\t{\n\t\tfree(ntlmTokenData);\n\t\treturn FALSE;\n\t}\n\n\tif (ntlmTokenData && ntlmTokenLength)\n\t{\n\t\tif (!ntlm_client_set_input_buffer(ntlm, FALSE, ntlmTokenData, (size_t)ntlmTokenLength))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!ntlm_authenticate(ntlm, &continueNeeded))\n\t\treturn FALSE;\n\n\tif (continueNeeded)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_skip_seed_payload(rdpTls* tls, SSIZE_T lastResponseLength)\n{\n\tBYTE seed_payload[10];\n\tconst size_t size = sizeof(seed_payload);\n\n\tassert(size < SSIZE_MAX);\n\n\t/* Per [MS-TSGU] 3.3.5.1 step 4, after final OK response RDG server sends\n\t * random \"seed\" payload of limited size. In practice it's 10 bytes.\n\t */\n\tif (lastResponseLength < (SSIZE_T)size)\n\t{\n\t\tif (!rdg_read_all(tls, seed_payload, size - lastResponseLength))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_handshake_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT32 errorCode;\n\tUINT16 serverVersion, extendedAuth;\n\tBYTE verMajor, verMinor;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Handshake response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_HANDSHAKE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 10\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT8(s, verMajor);\n\tStream_Read_UINT8(s, verMinor);\n\tStream_Read_UINT16(s, serverVersion);\n\tStream_Read_UINT16(s, extendedAuth);\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG,\n\t         \"errorCode=%s, verMajor=%\" PRId8 \", verMinor=%\" PRId8 \", serverVersion=%\" PRId16\n\t         \", extendedAuth=%s\",\n\t         error, verMajor, verMinor, serverVersion, extended_auth_to_string(extendedAuth));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Handshake error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_tunnel_request(rdg);\n}\n\nstatic BOOL rdg_process_tunnel_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT16 serverVersion, fieldsPresent;\n\tUINT32 errorCode;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Tunnel response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_TUNNEL_CREATE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 10\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, serverVersion);\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"serverVersion=%\" PRId16 \", errorCode=%s, fieldsPresent=%s\", serverVersion, error,\n\t         tunnel_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Tunnel creation error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_tunnel_authorization(rdg);\n}\n\nstatic BOOL rdg_process_tunnel_authorization_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT32 errorCode;\n\tUINT16 fieldsPresent;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Tunnel authorization received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_TUNNEL_AUTHORIZE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"errorCode=%s, fieldsPresent=%s\", error,\n\t         tunnel_authorization_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"Tunnel authorization error %s\", error);\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\treturn rdg_send_channel_create(rdg);\n}\n\nstatic BOOL rdg_process_channel_response(rdpRdg* rdg, wStream* s)\n{\n\tUINT16 fieldsPresent;\n\tUINT32 errorCode;\n\tconst char* error;\n\tWLog_DBG(TAG, \"Channel response received\");\n\n\tif (rdg->state != RDG_CLIENT_STATE_CHANNEL_CREATE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, errorCode);\n\tStream_Read_UINT16(s, fieldsPresent);\n\tStream_Seek_UINT16(s); /* reserved */\n\terror = rpc_error_to_string(errorCode);\n\tWLog_DBG(TAG, \"channel response errorCode=%s, fieldsPresent=%s\", error,\n\t         channel_response_fields_present_to_string(fieldsPresent));\n\n\tif (FAILED(errorCode))\n\t{\n\t\tWLog_ERR(TAG, \"channel response errorCode=%s, fieldsPresent=%s\", error,\n\t\t         channel_response_fields_present_to_string(fieldsPresent));\n\t\tfreerdp_set_last_error_log(rdg->context, errorCode);\n\t\treturn FALSE;\n\t}\n\n\trdg->state = RDG_CLIENT_STATE_OPENED;\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_packet(rdpRdg* rdg, wStream* s)\n{\n\tBOOL status = TRUE;\n\tUINT16 type;\n\tUINT32 packetLength;\n\tStream_SetPosition(s, 0);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected 8\", __FUNCTION__,\n\t\t         Stream_GetRemainingLength(s));\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, type);\n\tStream_Seek_UINT16(s); /* reserved */\n\tStream_Read_UINT32(s, packetLength);\n\n\tif (Stream_Length(s) < packetLength)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Short packet %\" PRIuz \", expected %\" PRIuz, __FUNCTION__,\n\t\t         Stream_Length(s), packetLength);\n\t\treturn FALSE;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase PKT_TYPE_HANDSHAKE_RESPONSE:\n\t\t\tstatus = rdg_process_handshake_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_TUNNEL_RESPONSE:\n\t\t\tstatus = rdg_process_tunnel_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_TUNNEL_AUTH_RESPONSE:\n\t\t\tstatus = rdg_process_tunnel_authorization_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_CHANNEL_RESPONSE:\n\t\t\tstatus = rdg_process_channel_response(rdg, s);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_DATA:\n\t\t\tWLog_ERR(TAG, \"[%s] Unexpected packet type DATA\", __FUNCTION__);\n\t\t\treturn FALSE;\n\t}\n\n\treturn status;\n}\n\nDWORD rdg_get_event_handles(rdpRdg* rdg, HANDLE* events, DWORD count)\n{\n\tDWORD nCount = 0;\n\tassert(rdg != NULL);\n\n\tif (rdg->tlsOut && rdg->tlsOut->bio)\n\t{\n\t\tif (events && (nCount < count))\n\t\t{\n\t\t\tBIO_get_event(rdg->tlsOut->bio, &events[nCount]);\n\t\t\tnCount++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (rdg->tlsIn && rdg->tlsIn->bio)\n\t{\n\t\tif (events && (nCount < count))\n\t\t{\n\t\t\tBIO_get_event(rdg->tlsIn->bio, &events[nCount]);\n\t\t\tnCount++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn nCount;\n}\n\nstatic BOOL rdg_get_gateway_credentials(rdpContext* context)\n{\n\trdpSettings* settings = context->settings;\n\tfreerdp* instance = context->instance;\n\n\tif (!settings->GatewayPassword || !settings->GatewayUsername ||\n\t    !strlen(settings->GatewayPassword) || !strlen(settings->GatewayUsername))\n\t{\n\t\tif (freerdp_shall_disconnect(instance))\n\t\t\treturn FALSE;\n\n\t\tif (!instance->GatewayAuthenticate)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBOOL proceed =\n\t\t\t    instance->GatewayAuthenticate(instance, &settings->GatewayUsername,\n\t\t\t                                  &settings->GatewayPassword, &settings->GatewayDomain);\n\n\t\t\tif (!proceed)\n\t\t\t{\n\t\t\t\tfreerdp_set_last_error_log(context,\n\t\t\t\t                           FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (settings->GatewayUseSameCredentials)\n\t\t\t{\n\t\t\t\tif (settings->GatewayUsername)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Username);\n\n\t\t\t\t\tif (!(settings->Username = _strdup(settings->GatewayUsername)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (settings->GatewayDomain)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Domain);\n\n\t\t\t\t\tif (!(settings->Domain = _strdup(settings->GatewayDomain)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (settings->GatewayPassword)\n\t\t\t\t{\n\t\t\t\t\tfree(settings->Password);\n\n\t\t\t\t\tif (!(settings->Password = _strdup(settings->GatewayPassword)))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_ntlm_init(rdpRdg* rdg, rdpTls* tls)\n{\n\tBOOL continueNeeded = FALSE;\n\trdpContext* context = rdg->context;\n\trdpSettings* settings = context->settings;\n\trdg->ntlm = ntlm_new();\n\n\tif (!rdg->ntlm)\n\t\treturn FALSE;\n\n\tif (!rdg_get_gateway_credentials(context))\n\t\treturn FALSE;\n\n\tif (!ntlm_client_init(rdg->ntlm, TRUE, settings->GatewayUsername, settings->GatewayDomain,\n\t                      settings->GatewayPassword, tls->Bindings))\n\t\treturn FALSE;\n\n\tif (!ntlm_client_make_spn(rdg->ntlm, _T(\"HTTP\"), settings->GatewayHostname))\n\t\treturn FALSE;\n\n\tif (!ntlm_authenticate(rdg->ntlm, &continueNeeded))\n\t\treturn FALSE;\n\n\treturn continueNeeded;\n}\n\nstatic BOOL rdg_send_http_request(rdpRdg* rdg, rdpTls* tls, const char* method,\n                                  const char* transferEncoding)\n{\n\tsize_t sz;\n\twStream* s = NULL;\n\tint status = -1;\n\ts = rdg_build_http_request(rdg, method, transferEncoding);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tsz = Stream_Length(s);\n\n\tif (sz <= INT_MAX)\n\t\tstatus = tls_write_all(tls, Stream_Buffer(s), (int)sz);\n\n\tStream_Free(s, TRUE);\n\treturn (status >= 0);\n}\n\nstatic BOOL rdg_tls_connect(rdpRdg* rdg, rdpTls* tls, const char* peerAddress, int timeout)\n{\n\tint sockfd = 0;\n\tlong status = 0;\n\tBIO* socketBio = NULL;\n\tBIO* bufferedBio = NULL;\n\trdpSettings* settings = rdg->settings;\n\tconst char* peerHostname = settings->GatewayHostname;\n\tUINT16 peerPort = (UINT16)settings->GatewayPort;\n\tconst char *proxyUsername, *proxyPassword;\n\tBOOL isProxyConnection =\n\t    proxy_prepare(settings, &peerHostname, &peerPort, &proxyUsername, &proxyPassword);\n\n\tif (settings->GatewayPort > UINT16_MAX)\n\t\treturn FALSE;\n\n\tsockfd = freerdp_tcp_connect(rdg->context, settings, peerAddress ? peerAddress : peerHostname,\n\t                             peerPort, timeout);\n\n\tif (sockfd < 0)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tsocketBio = BIO_new(BIO_s_simple_socket());\n\n\tif (!socketBio)\n\t{\n\t\tclosesocket((SOCKET)sockfd);\n\t\treturn FALSE;\n\t}\n\n\tBIO_set_fd(socketBio, sockfd, BIO_CLOSE);\n\tbufferedBio = BIO_new(BIO_s_buffered_socket());\n\n\tif (!bufferedBio)\n\t{\n\t\tBIO_free_all(socketBio);\n\t\treturn FALSE;\n\t}\n\n\tbufferedBio = BIO_push(bufferedBio, socketBio);\n\tstatus = BIO_set_nonblock(bufferedBio, TRUE);\n\n\tif (isProxyConnection)\n\t{\n\t\tif (!proxy_connect(settings, bufferedBio, proxyUsername, proxyPassword,\n\t\t                   settings->GatewayHostname, (UINT16)settings->GatewayPort))\n\t\t{\n\t\t\tBIO_free_all(bufferedBio);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (!status)\n\t{\n\t\tBIO_free_all(bufferedBio);\n\t\treturn FALSE;\n\t}\n\n\ttls->hostname = settings->GatewayHostname;\n\ttls->port = (int)settings->GatewayPort;\n\ttls->isGatewayTransport = TRUE;\n\tstatus = tls_connect(tls, bufferedBio);\n\tif (status < 1)\n\t{\n\t\trdpContext* context = rdg->context;\n\t\tif (status < 0)\n\t\t{\n\t\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_TLS_CONNECT_FAILED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_CONNECT_CANCELLED);\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\treturn (status >= 1);\n}\n\nstatic BOOL rdg_establish_data_connection(rdpRdg* rdg, rdpTls* tls, const char* method,\n                                          const char* peerAddress, int timeout, BOOL* rpcFallback)\n{\n\tHttpResponse* response = NULL;\n\tlong statusCode;\n\tSSIZE_T bodyLength;\n\tlong StatusCode;\n\n\tif (!rdg_tls_connect(rdg, tls, peerAddress, timeout))\n\t\treturn FALSE;\n\n\tif (rdg->extAuth == HTTP_EXTENDED_AUTH_NONE)\n\t{\n\t\tif (!rdg_ntlm_init(rdg, tls))\n\t\t\treturn FALSE;\n\n\t\tif (!rdg_send_http_request(rdg, tls, method, NULL))\n\t\t\treturn FALSE;\n\n\t\tresponse = http_response_recv(tls, TRUE);\n\n\t\tif (!response)\n\t\t\treturn FALSE;\n\n\t\tStatusCode = http_response_get_status_code(response);\n\n\t\tswitch (StatusCode)\n\t\t{\n\t\t\tcase HTTP_STATUS_NOT_FOUND:\n\t\t\t{\n\t\t\t\tWLog_INFO(TAG, \"RD Gateway does not support HTTP transport.\");\n\n\t\t\t\tif (rpcFallback)\n\t\t\t\t\t*rpcFallback = TRUE;\n\n\t\t\t\thttp_response_free(response);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!rdg_handle_ntlm_challenge(rdg->ntlm, response))\n\t\t{\n\t\t\thttp_response_free(response);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\thttp_response_free(response);\n\t}\n\n\tif (!rdg_send_http_request(rdg, tls, method, NULL))\n\t\treturn FALSE;\n\n\tntlm_free(rdg->ntlm);\n\trdg->ntlm = NULL;\n\tresponse = http_response_recv(tls, TRUE);\n\n\tif (!response)\n\t\treturn FALSE;\n\n\tstatusCode = http_response_get_status_code(response);\n\tbodyLength = http_response_get_body_length(response);\n\thttp_response_free(response);\n\tWLog_DBG(TAG, \"%s authorization result: %d\", method, statusCode);\n\n\tswitch (statusCode)\n\t{\n\t\tcase HTTP_STATUS_OK:\n\t\t\tbreak;\n\t\tcase HTTP_STATUS_DENIED:\n\t\t\tfreerdp_set_last_error_log(rdg->context, FREERDP_ERROR_CONNECT_ACCESS_DENIED);\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\tif (strcmp(method, \"RDG_OUT_DATA\") == 0)\n\t{\n\t\tif (!rdg_skip_seed_payload(tls, bodyLength))\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!rdg_send_http_request(rdg, tls, method, \"chunked\"))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL rdg_tunnel_connect(rdpRdg* rdg)\n{\n\tBOOL status;\n\twStream* s;\n\trdg_send_handshake(rdg);\n\n\twhile (rdg->state < RDG_CLIENT_STATE_OPENED)\n\t{\n\t\tstatus = FALSE;\n\t\ts = rdg_receive_packet(rdg);\n\n\t\tif (s)\n\t\t{\n\t\t\tstatus = rdg_process_packet(rdg, s);\n\t\t\tStream_Free(s, TRUE);\n\t\t}\n\n\t\tif (!status)\n\t\t{\n\t\t\trdg->context->rdp->transport->layer = TRANSPORT_LAYER_CLOSED;\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rdg_connect(rdpRdg* rdg, int timeout, BOOL* rpcFallback)\n{\n\tBOOL status;\n\tSOCKET outConnSocket = 0;\n\tchar* peerAddress = NULL;\n\tassert(rdg != NULL);\n\tstatus =\n\t    rdg_establish_data_connection(rdg, rdg->tlsOut, \"RDG_OUT_DATA\", NULL, timeout, rpcFallback);\n\n\tif (status)\n\t{\n\t\t/* Establish IN connection with the same peer/server as OUT connection,\n\t\t * even when server hostname resolves to different IP addresses.\n\t\t */\n\t\tBIO_get_socket(rdg->tlsOut->underlying, &outConnSocket);\n\t\tpeerAddress = freerdp_tcp_get_peer_address(outConnSocket);\n\t\tstatus = rdg_establish_data_connection(rdg, rdg->tlsIn, \"RDG_IN_DATA\", peerAddress, timeout,\n\t\t                                       NULL);\n\t\tfree(peerAddress);\n\t}\n\n\tif (!status)\n\t{\n\t\trdg->context->rdp->transport->layer = TRANSPORT_LAYER_CLOSED;\n\t\treturn FALSE;\n\t}\n\n\tstatus = rdg_tunnel_connect(rdg);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic int rdg_write_data_packet(rdpRdg* rdg, const BYTE* buf, int isize)\n{\n\tint status;\n\tsize_t s;\n\twStream* sChunk;\n\tsize_t size = (size_t)isize;\n\tsize_t packetSize = size + 10;\n\tchar chunkSize[11];\n\n\tif ((isize < 0) || (isize > UINT16_MAX))\n\t\treturn -1;\n\n\tif (size < 1)\n\t\treturn 0;\n\n\tsprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIxz \"\\r\\n\", packetSize);\n\tsChunk = Stream_New(NULL, strnlen(chunkSize, sizeof(chunkSize)) + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn -1;\n\n\tStream_Write(sChunk, chunkSize, strnlen(chunkSize, sizeof(chunkSize)));\n\tStream_Write_UINT16(sChunk, PKT_TYPE_DATA);      /* Type */\n\tStream_Write_UINT16(sChunk, 0);                  /* Reserved */\n\tStream_Write_UINT32(sChunk, (UINT32)packetSize); /* Packet length */\n\tStream_Write_UINT16(sChunk, (UINT16)size);       /* Data size */\n\tStream_Write(sChunk, buf, size);                 /* Data */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s > INT_MAX)\n\t\treturn -1;\n\n\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\tStream_Free(sChunk, TRUE);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\treturn (int)size;\n}\n\nstatic BOOL rdg_process_close_packet(rdpRdg* rdg)\n{\n\tint status = -1;\n\tsize_t s;\n\twStream* sChunk;\n\tUINT32 packetSize = 12;\n\tchar chunkSize[11];\n\tint chunkLen = sprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIx32 \"\\r\\n\", packetSize);\n\n\tif (chunkLen < 0)\n\t\treturn FALSE;\n\n\tsChunk = Stream_New(NULL, (size_t)chunkLen + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, (size_t)chunkLen);\n\tStream_Write_UINT16(sChunk, PKT_TYPE_CLOSE_CHANNEL_RESPONSE); /* Type */\n\tStream_Write_UINT16(sChunk, 0);                               /* Reserved */\n\tStream_Write_UINT32(sChunk, packetSize);                      /* Packet length */\n\tStream_Write_UINT32(sChunk, 0);                               /* Status code */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s <= INT_MAX)\n\t\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\n\tStream_Free(sChunk, TRUE);\n\treturn (status < 0 ? FALSE : TRUE);\n}\n\nstatic BOOL rdg_process_keep_alive_packet(rdpRdg* rdg)\n{\n\tint status = -1;\n\tsize_t s;\n\twStream* sChunk;\n\tsize_t packetSize = 8;\n\tchar chunkSize[11];\n\tint chunkLen = sprintf_s(chunkSize, sizeof(chunkSize), \"%\" PRIxz \"\\r\\n\", packetSize);\n\n\tif ((chunkLen < 0) || (packetSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tsChunk = Stream_New(NULL, (size_t)chunkLen + packetSize + 2);\n\n\tif (!sChunk)\n\t\treturn FALSE;\n\n\tStream_Write(sChunk, chunkSize, (size_t)chunkLen);\n\tStream_Write_UINT16(sChunk, PKT_TYPE_KEEPALIVE); /* Type */\n\tStream_Write_UINT16(sChunk, 0);                  /* Reserved */\n\tStream_Write_UINT32(sChunk, (UINT32)packetSize); /* Packet length */\n\tStream_Write(sChunk, \"\\r\\n\", 2);\n\tStream_SealLength(sChunk);\n\ts = Stream_Length(sChunk);\n\n\tif (s <= INT_MAX)\n\t\tstatus = tls_write_all(rdg->tlsIn, Stream_Buffer(sChunk), (int)s);\n\n\tStream_Free(sChunk, TRUE);\n\treturn (status < 0 ? FALSE : TRUE);\n}\n\nstatic BOOL rdg_process_unknown_packet(rdpRdg* rdg, int type)\n{\n\tWINPR_UNUSED(rdg);\n\tWINPR_UNUSED(type);\n\tWLog_WARN(TAG, \"Unknown Control Packet received: %X\", type);\n\treturn TRUE;\n}\n\nstatic BOOL rdg_process_control_packet(rdpRdg* rdg, int type, size_t packetLength)\n{\n\twStream* s = NULL;\n\tsize_t readCount = 0;\n\tint status;\n\tsize_t payloadSize = packetLength - sizeof(RdgPacketHeader);\n\n\tif (packetLength < sizeof(RdgPacketHeader))\n\t\treturn FALSE;\n\n\tassert(sizeof(RdgPacketHeader) < INT_MAX);\n\n\tif (payloadSize)\n\t{\n\t\ts = Stream_New(NULL, payloadSize);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\twhile (readCount < payloadSize)\n\t\t{\n\t\t\tstatus =\n\t\t\t    BIO_read(rdg->tlsOut->bio, Stream_Pointer(s), (int)payloadSize - (int)readCount);\n\n\t\t\tif (status <= 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t{\n\t\t\t\t\tStream_Free(s, TRUE);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tStream_Seek(s, (size_t)status);\n\t\t\treadCount += (size_t)status;\n\n\t\t\tif (readCount > INT_MAX)\n\t\t\t{\n\t\t\t\tStream_Free(s, TRUE);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase PKT_TYPE_CLOSE_CHANNEL:\n\t\t\tEnterCriticalSection(&rdg->writeSection);\n\t\t\tstatus = rdg_process_close_packet(rdg);\n\t\t\tLeaveCriticalSection(&rdg->writeSection);\n\t\t\tbreak;\n\n\t\tcase PKT_TYPE_KEEPALIVE:\n\t\t\tEnterCriticalSection(&rdg->writeSection);\n\t\t\tstatus = rdg_process_keep_alive_packet(rdg);\n\t\t\tLeaveCriticalSection(&rdg->writeSection);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstatus = rdg_process_unknown_packet(rdg, type);\n\t\t\tbreak;\n\t}\n\n\tStream_Free(s, TRUE);\n\treturn status;\n}\n\nstatic int rdg_read_data_packet(rdpRdg* rdg, BYTE* buffer, int size)\n{\n\tRdgPacketHeader header;\n\tsize_t readCount = 0;\n\tint readSize;\n\tint status;\n\n\tif (!rdg->packetRemainingCount)\n\t{\n\t\tassert(sizeof(RdgPacketHeader) < INT_MAX);\n\n\t\twhile (readCount < sizeof(RdgPacketHeader))\n\t\t{\n\t\t\tstatus = BIO_read(rdg->tlsOut->bio, (BYTE*)(&header) + readCount,\n\t\t\t                  (int)sizeof(RdgPacketHeader) - (int)readCount);\n\n\t\t\tif (status <= 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tif (!readCount)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tBIO_wait_read(rdg->tlsOut->bio, 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treadCount += (size_t)status;\n\n\t\t\tif (readCount > INT_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (header.type != PKT_TYPE_DATA)\n\t\t{\n\t\t\tstatus = rdg_process_control_packet(rdg, header.type, header.packetLength);\n\n\t\t\tif (!status)\n\t\t\t\treturn -1;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treadCount = 0;\n\n\t\twhile (readCount < 2)\n\t\t{\n\t\t\tstatus = BIO_read(rdg->tlsOut->bio, (BYTE*)(&rdg->packetRemainingCount) + readCount,\n\t\t\t                  2 - (int)readCount);\n\n\t\t\tif (status < 0)\n\t\t\t{\n\t\t\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tBIO_wait_read(rdg->tlsOut->bio, 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treadCount += (size_t)status;\n\t\t}\n\t}\n\n\treadSize = (rdg->packetRemainingCount < size ? rdg->packetRemainingCount : size);\n\tstatus = BIO_read(rdg->tlsOut->bio, buffer, readSize);\n\n\tif (status <= 0)\n\t{\n\t\tif (!BIO_should_retry(rdg->tlsOut->bio))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trdg->packetRemainingCount -= status;\n\treturn status;\n}\n\nstatic int rdg_bio_write(BIO* bio, const char* buf, int num)\n{\n\tint status;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\tBIO_clear_flags(bio, BIO_FLAGS_WRITE);\n\tEnterCriticalSection(&rdg->writeSection);\n\tstatus = rdg_write_data_packet(rdg, (const BYTE*)buf, num);\n\tLeaveCriticalSection(&rdg->writeSection);\n\n\tif (status < 0)\n\t{\n\t\tBIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY);\n\t\treturn -1;\n\t}\n\telse if (status < num)\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_WRITE);\n\t\tWSASetLastError(WSAEWOULDBLOCK);\n\t}\n\telse\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_WRITE);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_read(BIO* bio, char* buf, int size)\n{\n\tint status;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\tstatus = rdg_read_data_packet(rdg, (BYTE*)buf, size);\n\n\tif (status < 0)\n\t{\n\t\tBIO_clear_retry_flags(bio);\n\t\treturn -1;\n\t}\n\telse if (status == 0)\n\t{\n\t\tBIO_set_retry_read(bio);\n\t\tWSASetLastError(WSAEWOULDBLOCK);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tBIO_set_flags(bio, BIO_FLAGS_READ);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_puts(BIO* bio, const char* str)\n{\n\tWINPR_UNUSED(bio);\n\tWINPR_UNUSED(str);\n\treturn -2;\n}\n\nstatic int rdg_bio_gets(BIO* bio, char* str, int size)\n{\n\tWINPR_UNUSED(bio);\n\tWINPR_UNUSED(str);\n\tWINPR_UNUSED(size);\n\treturn -2;\n}\n\nstatic long rdg_bio_ctrl(BIO* bio, int cmd, long arg1, void* arg2)\n{\n\tlong status = -1;\n\trdpRdg* rdg = (rdpRdg*)BIO_get_data(bio);\n\trdpTls* tlsOut = rdg->tlsOut;\n\trdpTls* tlsIn = rdg->tlsIn;\n\n\tif (cmd == BIO_CTRL_FLUSH)\n\t{\n\t\t(void)BIO_flush(tlsOut->bio);\n\t\t(void)BIO_flush(tlsIn->bio);\n\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_SET_NONBLOCK)\n\t{\n\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_READ_BLOCKED)\n\t{\n\t\tBIO* bio = tlsOut->bio;\n\t\tstatus = BIO_read_blocked(bio);\n\t}\n\telse if (cmd == BIO_C_WRITE_BLOCKED)\n\t{\n\t\tBIO* bio = tlsIn->bio;\n\t\tstatus = BIO_write_blocked(bio);\n\t}\n\telse if (cmd == BIO_C_WAIT_READ)\n\t{\n\t\tint timeout = (int)arg1;\n\t\tBIO* bio = tlsOut->bio;\n\n\t\tif (BIO_read_blocked(bio))\n\t\t\treturn BIO_wait_read(bio, timeout);\n\t\telse if (BIO_write_blocked(bio))\n\t\t\treturn BIO_wait_write(bio, timeout);\n\t\telse\n\t\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_WAIT_WRITE)\n\t{\n\t\tint timeout = (int)arg1;\n\t\tBIO* bio = tlsIn->bio;\n\n\t\tif (BIO_write_blocked(bio))\n\t\t\tstatus = BIO_wait_write(bio, timeout);\n\t\telse if (BIO_read_blocked(bio))\n\t\t\tstatus = BIO_wait_read(bio, timeout);\n\t\telse\n\t\t\tstatus = 1;\n\t}\n\telse if (cmd == BIO_C_GET_EVENT || cmd == BIO_C_GET_FD)\n\t{\n\t\t/*\n\t\t * A note about BIO_C_GET_FD:\n\t\t * Even if two FDs are part of RDG, only one FD can be returned here.\n\t\t *\n\t\t * In FreeRDP, BIO FDs are only used for polling, so it is safe to use the outgoing FD only\n\t\t *\n\t\t * See issue #3602\n\t\t */\n\t\tstatus = BIO_ctrl(tlsOut->bio, cmd, arg1, arg2);\n\t}\n\n\treturn status;\n}\n\nstatic int rdg_bio_new(BIO* bio)\n{\n\tBIO_set_init(bio, 1);\n\tBIO_set_flags(bio, BIO_FLAGS_SHOULD_RETRY);\n\treturn 1;\n}\n\nstatic int rdg_bio_free(BIO* bio)\n{\n\tWINPR_UNUSED(bio);\n\treturn 1;\n}\n\nstatic BIO_METHOD* BIO_s_rdg(void)\n{\n\tstatic BIO_METHOD* bio_methods = NULL;\n\n\tif (bio_methods == NULL)\n\t{\n\t\tif (!(bio_methods = BIO_meth_new(BIO_TYPE_TSG, \"RDGateway\")))\n\t\t\treturn NULL;\n\n\t\tBIO_meth_set_write(bio_methods, rdg_bio_write);\n\t\tBIO_meth_set_read(bio_methods, rdg_bio_read);\n\t\tBIO_meth_set_puts(bio_methods, rdg_bio_puts);\n\t\tBIO_meth_set_gets(bio_methods, rdg_bio_gets);\n\t\tBIO_meth_set_ctrl(bio_methods, rdg_bio_ctrl);\n\t\tBIO_meth_set_create(bio_methods, rdg_bio_new);\n\t\tBIO_meth_set_destroy(bio_methods, rdg_bio_free);\n\t}\n\n\treturn bio_methods;\n}\n\nrdpRdg* rdg_new(rdpContext* context)\n{\n\trdpRdg* rdg;\n\tRPC_CSTR stringUuid;\n\tchar bracedUuid[40];\n\tRPC_STATUS rpcStatus;\n\n\tif (!context)\n\t\treturn NULL;\n\n\trdg = (rdpRdg*)calloc(1, sizeof(rdpRdg));\n\n\tif (rdg)\n\t{\n\t\trdg->state = RDG_CLIENT_STATE_INITIAL;\n\t\trdg->context = context;\n\t\trdg->settings = rdg->context->settings;\n\t\trdg->extAuth = HTTP_EXTENDED_AUTH_NONE;\n\n\t\tif (rdg->settings->GatewayAccessToken)\n\t\t\trdg->extAuth = HTTP_EXTENDED_AUTH_PAA;\n\n\t\tUuidCreate(&rdg->guid);\n\t\trpcStatus = UuidToStringA(&rdg->guid, &stringUuid);\n\n\t\tif (rpcStatus == RPC_S_OUT_OF_MEMORY)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tsprintf_s(bracedUuid, sizeof(bracedUuid), \"{%s}\", stringUuid);\n\t\tRpcStringFreeA(&stringUuid);\n\t\trdg->tlsOut = tls_new(rdg->settings);\n\n\t\tif (!rdg->tlsOut)\n\t\t\tgoto rdg_alloc_error;\n\n\t\trdg->tlsIn = tls_new(rdg->settings);\n\n\t\tif (!rdg->tlsIn)\n\t\t\tgoto rdg_alloc_error;\n\n\t\trdg->http = http_context_new();\n\n\t\tif (!rdg->http)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tif (!http_context_set_uri(rdg->http, \"/remoteDesktopGateway/\") ||\n\t\t    !http_context_set_accept(rdg->http, \"*/*\") ||\n\t\t    !http_context_set_cache_control(rdg->http, \"no-cache\") ||\n\t\t    !http_context_set_pragma(rdg->http, \"no-cache\") ||\n\t\t    !http_context_set_connection(rdg->http, \"Keep-Alive\") ||\n\t\t    !http_context_set_user_agent(rdg->http, \"MS-RDGateway/1.0\") ||\n\t\t    !http_context_set_host(rdg->http, rdg->settings->GatewayHostname) ||\n\t\t    !http_context_set_rdg_connection_id(rdg->http, bracedUuid))\n\t\t{\n\t\t\tgoto rdg_alloc_error;\n\t\t}\n\n\t\tif (rdg->extAuth != HTTP_EXTENDED_AUTH_NONE)\n\t\t{\n\t\t\tswitch (rdg->extAuth)\n\t\t\t{\n\t\t\t\tcase HTTP_EXTENDED_AUTH_PAA:\n\t\t\t\t\tif (!http_context_set_rdg_auth_scheme(rdg->http, \"PAA\"))\n\t\t\t\t\t\tgoto rdg_alloc_error;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_DBG(TAG, \"RDG extended authentication method %d not supported\",\n\t\t\t\t\t         rdg->extAuth);\n\t\t\t}\n\t\t}\n\n\t\trdg->frontBio = BIO_new(BIO_s_rdg());\n\n\t\tif (!rdg->frontBio)\n\t\t\tgoto rdg_alloc_error;\n\n\t\tBIO_set_data(rdg->frontBio, rdg);\n\t\tInitializeCriticalSection(&rdg->writeSection);\n\t}\n\n\treturn rdg;\nrdg_alloc_error:\n\trdg_free(rdg);\n\treturn NULL;\n}\n\nvoid rdg_free(rdpRdg* rdg)\n{\n\tif (!rdg)\n\t\treturn;\n\n\ttls_free(rdg->tlsOut);\n\ttls_free(rdg->tlsIn);\n\thttp_context_free(rdg->http);\n\tntlm_free(rdg->ntlm);\n\n\tif (!rdg->attached)\n\t\tBIO_free_all(rdg->frontBio);\n\n\tDeleteCriticalSection(&rdg->writeSection);\n\tfree(rdg);\n}\n\nBIO* rdg_get_front_bio_and_take_ownership(rdpRdg* rdg)\n{\n\tif (!rdg)\n\t\treturn NULL;\n\n\trdg->attached = TRUE;\n\treturn rdg->frontBio;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Protocol Security Negotiation\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"tpkt.h\"\n\n#include \"nego.h\"\n\n#include \"transport.h\"\n\n#define TAG FREERDP_TAG(\"core.nego\")\n\nstruct rdp_nego\n{\n\tUINT16 port;\n\tUINT32 flags;\n\tconst char* hostname;\n\tchar* cookie;\n\tBYTE* RoutingToken;\n\tDWORD RoutingTokenLength;\n\tBOOL SendPreconnectionPdu;\n\tUINT32 PreconnectionId;\n\tchar* PreconnectionBlob;\n\n\tNEGO_STATE state;\n\tBOOL TcpConnected;\n\tBOOL SecurityConnected;\n\tUINT32 CookieMaxLength;\n\n\tBOOL sendNegoData;\n\tUINT32 SelectedProtocol;\n\tUINT32 RequestedProtocols;\n\tBOOL NegotiateSecurityLayer;\n\tBOOL EnabledProtocols[16];\n\tBOOL RestrictedAdminModeRequired;\n\tBOOL GatewayEnabled;\n\tBOOL GatewayBypassLocal;\n\n\trdpTransport* transport;\n};\n\nstatic const char* nego_state_string(NEGO_STATE state)\n{\n\tstatic const char* const NEGO_STATE_STRINGS[] = { \"NEGO_STATE_INITIAL\", \"NEGO_STATE_EXT\",\n\t\t                                              \"NEGO_STATE_NLA\",     \"NEGO_STATE_TLS\",\n\t\t                                              \"NEGO_STATE_RDP\",     \"NEGO_STATE_FAIL\",\n\t\t                                              \"NEGO_STATE_FINAL\",   \"NEGO_STATE_INVALID\" };\n\tif (state >= ARRAYSIZE(NEGO_STATE_STRINGS))\n\t\treturn NEGO_STATE_STRINGS[ARRAYSIZE(NEGO_STATE_STRINGS) - 1];\n\treturn NEGO_STATE_STRINGS[state];\n}\n\nstatic const char* protocol_security_string(UINT32 security)\n{\n\tstatic const char* PROTOCOL_SECURITY_STRINGS[] = { \"RDP\", \"TLS\", \"NLA\", \"UNK\", \"UNK\",\n\t\t                                               \"UNK\", \"UNK\", \"UNK\", \"EXT\", \"UNK\" };\n\tif (security >= ARRAYSIZE(PROTOCOL_SECURITY_STRINGS))\n\t\treturn PROTOCOL_SECURITY_STRINGS[ARRAYSIZE(PROTOCOL_SECURITY_STRINGS) - 1];\n\treturn PROTOCOL_SECURITY_STRINGS[security];\n}\n\nstatic BOOL nego_transport_connect(rdpNego* nego);\nstatic BOOL nego_transport_disconnect(rdpNego* nego);\nstatic BOOL nego_security_connect(rdpNego* nego);\nstatic BOOL nego_send_preconnection_pdu(rdpNego* nego);\nstatic BOOL nego_recv_response(rdpNego* nego);\nstatic void nego_send(rdpNego* nego);\nstatic BOOL nego_process_negotiation_request(rdpNego* nego, wStream* s);\nstatic BOOL nego_process_negotiation_response(rdpNego* nego, wStream* s);\nstatic BOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s);\n\n/**\n * Negotiate protocol security and connect.\n * @param nego\n * @return\n */\n\nBOOL nego_connect(rdpNego* nego)\n{\n\trdpSettings* settings = nego->transport->settings;\n\n\tif (nego->state == NEGO_STATE_INITIAL)\n\t{\n\t\tif (nego->EnabledProtocols[PROTOCOL_HYBRID_EX])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_EXT;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_HYBRID])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_NLA;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\t}\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t{\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"No security protocol is enabled\");\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!nego->NegotiateSecurityLayer)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Security Layer Negotiation is disabled\");\n\t\t\t/* attempt only the highest enabled protocol (see nego_attempt_*) */\n\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_SSL] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_RDP] = FALSE;\n\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = FALSE;\n\n\t\t\tif (nego->state == NEGO_STATE_EXT)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = TRUE;\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_HYBRID_EX;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_NLA)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_HYBRID] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_HYBRID;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_TLS)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_SSL] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_SSL;\n\t\t\t}\n\t\t\telse if (nego->state == NEGO_STATE_RDP)\n\t\t\t{\n\t\t\t\tnego->EnabledProtocols[PROTOCOL_RDP] = TRUE;\n\t\t\t\tnego->SelectedProtocol = PROTOCOL_RDP;\n\t\t\t}\n\t\t}\n\n\t\tif (nego->SendPreconnectionPdu)\n\t\t{\n\t\t\tif (!nego_send_preconnection_pdu(nego))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to send preconnection pdu\");\n\t\t\t\tnego->state = NEGO_STATE_FINAL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nego->NegotiateSecurityLayer)\n\t{\n\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tdo\n\t\t{\n\t\t\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\t\t\tnego_send(nego);\n\n\t\t\tif (nego->state == NEGO_STATE_FAIL)\n\t\t\t{\n\t\t\t\tif (freerdp_get_last_error(nego->transport->context) == FREERDP_ERROR_SUCCESS)\n\t\t\t\t\tWLog_ERR(TAG, \"Protocol Security Negotiation Failure\");\n\n\t\t\t\tnego->state = NEGO_STATE_FINAL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} while (nego->state != NEGO_STATE_FINAL);\n\t}\n\n\tWLog_DBG(TAG, \"Negotiated %s security\", protocol_security_string(nego->SelectedProtocol));\n\t/* update settings with negotiated protocol security */\n\tsettings->RequestedProtocols = nego->RequestedProtocols;\n\tsettings->SelectedProtocol = nego->SelectedProtocol;\n\tsettings->NegotiationFlags = nego->flags;\n\n\tif (nego->SelectedProtocol == PROTOCOL_RDP)\n\t{\n\t\tsettings->UseRdpSecurityLayer = TRUE;\n\n\t\tif (!settings->EncryptionMethods)\n\t\t{\n\t\t\t/**\n\t\t\t * Advertise all supported encryption methods if the client\n\t\t\t * implementation did not set any security methods\n\t\t\t */\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_40BIT | ENCRYPTION_METHOD_56BIT |\n\t\t\t                              ENCRYPTION_METHOD_128BIT | ENCRYPTION_METHOD_FIPS;\n\t\t}\n\t}\n\n\t/* finally connect security layer (if not already done) */\n\tif (!nego_security_connect(nego))\n\t{\n\t\tWLog_DBG(TAG, \"Failed to connect with %s security\",\n\t\t         protocol_security_string(nego->SelectedProtocol));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL nego_disconnect(rdpNego* nego)\n{\n\tnego->state = NEGO_STATE_INITIAL;\n\treturn nego_transport_disconnect(nego);\n}\n\n/* connect to selected security layer */\nBOOL nego_security_connect(rdpNego* nego)\n{\n\tif (!nego->TcpConnected)\n\t{\n\t\tnego->SecurityConnected = FALSE;\n\t}\n\telse if (!nego->SecurityConnected)\n\t{\n\t\tif (nego->SelectedProtocol == PROTOCOL_HYBRID)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_HYBRID\");\n\t\t\tnego->SecurityConnected = transport_connect_nla(nego->transport);\n\t\t}\n\t\telse if (nego->SelectedProtocol == PROTOCOL_SSL)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_SSL\");\n\t\t\tnego->SecurityConnected = transport_connect_tls(nego->transport);\n\t\t}\n\t\telse if (nego->SelectedProtocol == PROTOCOL_RDP)\n\t\t{\n\t\t\tWLog_DBG(TAG, \"nego_security_connect with PROTOCOL_RDP\");\n\t\t\tnego->SecurityConnected = transport_connect_rdp(nego->transport);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"cannot connect security layer because no protocol has been selected yet.\");\n\t\t}\n\t}\n\n\treturn nego->SecurityConnected;\n}\n\n/**\n * Connect TCP layer.\n * @param nego\n * @return\n */\n\nstatic BOOL nego_tcp_connect(rdpNego* nego)\n{\n\tif (!nego->TcpConnected)\n\t{\n\t\tif (nego->GatewayEnabled)\n\t\t{\n\t\t\tif (nego->GatewayBypassLocal)\n\t\t\t{\n\t\t\t\t/* Attempt a direct connection first, and then fallback to using the gateway */\n\t\t\t\tWLog_INFO(TAG,\n\t\t\t\t          \"Detecting if host can be reached locally. - This might take some time.\");\n\t\t\t\tWLog_INFO(TAG, \"To disable auto detection use /gateway-usage-method:direct\");\n\t\t\t\ttransport_set_gateway_enabled(nego->transport, FALSE);\n\t\t\t\tnego->TcpConnected =\n\t\t\t\t    transport_connect(nego->transport, nego->hostname, nego->port, 1);\n\t\t\t}\n\n\t\t\tif (!nego->TcpConnected)\n\t\t\t{\n\t\t\t\ttransport_set_gateway_enabled(nego->transport, TRUE);\n\t\t\t\tnego->TcpConnected =\n\t\t\t\t    transport_connect(nego->transport, nego->hostname, nego->port, 15);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnego->TcpConnected = transport_connect(nego->transport, nego->hostname, nego->port, 15);\n\t\t}\n\t}\n\n\treturn nego->TcpConnected;\n}\n\n/**\n * Connect TCP layer. For direct approach, connect security layer as well.\n * @param nego\n * @return\n */\n\nBOOL nego_transport_connect(rdpNego* nego)\n{\n\tif (!nego_tcp_connect(nego))\n\t\treturn FALSE;\n\n\tif (nego->TcpConnected && !nego->NegotiateSecurityLayer)\n\t\treturn nego_security_connect(nego);\n\n\treturn nego->TcpConnected;\n}\n\n/**\n * Disconnect TCP layer.\n * @param nego\n * @return\n */\n\nBOOL nego_transport_disconnect(rdpNego* nego)\n{\n\tif (nego->TcpConnected)\n\t\ttransport_disconnect(nego->transport);\n\n\tnego->TcpConnected = FALSE;\n\tnego->SecurityConnected = FALSE;\n\treturn TRUE;\n}\n\n/**\n * Send preconnection information if enabled.\n * @param nego\n * @return\n */\n\nBOOL nego_send_preconnection_pdu(rdpNego* nego)\n{\n\twStream* s;\n\tUINT32 cbSize;\n\tUINT16 cchPCB = 0;\n\tWCHAR* wszPCB = NULL;\n\tWLog_DBG(TAG, \"Sending preconnection PDU\");\n\n\tif (!nego_tcp_connect(nego))\n\t\treturn FALSE;\n\n\t/* it's easier to always send the version 2 PDU, and it's just 2 bytes overhead */\n\tcbSize = PRECONNECTION_PDU_V2_MIN_SIZE;\n\n\tif (nego->PreconnectionBlob)\n\t{\n\t\tcchPCB = (UINT16)ConvertToUnicode(CP_UTF8, 0, nego->PreconnectionBlob, -1, &wszPCB, 0);\n\t\tcchPCB += 1; /* zero-termination */\n\t\tcbSize += cchPCB * 2;\n\t}\n\n\ts = Stream_New(NULL, cbSize);\n\n\tif (!s)\n\t{\n\t\tfree(wszPCB);\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT32(s, cbSize);                /* cbSize */\n\tStream_Write_UINT32(s, 0);                     /* Flags */\n\tStream_Write_UINT32(s, PRECONNECTION_PDU_V2);  /* Version */\n\tStream_Write_UINT32(s, nego->PreconnectionId); /* Id */\n\tStream_Write_UINT16(s, cchPCB);                /* cchPCB */\n\n\tif (wszPCB)\n\t{\n\t\tStream_Write(s, wszPCB, cchPCB * 2); /* wszPCB */\n\t\tfree(wszPCB);\n\t}\n\n\tStream_SealLength(s);\n\n\tif (transport_write(nego->transport, s) < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\n/**\n * Attempt negotiating NLA + TLS extended security.\n * @param nego\n */\n\nstatic void nego_attempt_ext(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_HYBRID | PROTOCOL_SSL | PROTOCOL_HYBRID_EX;\n\tWLog_DBG(TAG, \"Attempting NLA extended security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_HYBRID])\n\t\t\tnego->state = NEGO_STATE_NLA;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating NLA + TLS security.\n * @param nego\n */\n\nstatic void nego_attempt_nla(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_HYBRID | PROTOCOL_SSL;\n\tWLog_DBG(TAG, \"Attempting NLA security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tWLog_DBG(TAG, \"state: %s\", nego_state_string(nego->state));\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_SSL])\n\t\t\tnego->state = NEGO_STATE_TLS;\n\t\telse if (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating TLS security.\n * @param nego\n */\n\nstatic void nego_attempt_tls(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_SSL;\n\tWLog_DBG(TAG, \"Attempting TLS security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (nego->state != NEGO_STATE_FINAL)\n\t{\n\t\tnego_transport_disconnect(nego);\n\n\t\tif (nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_RDP;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n}\n\n/**\n * Attempt negotiating standard RDP security.\n * @param nego\n */\n\nstatic void nego_attempt_rdp(rdpNego* nego)\n{\n\tnego->RequestedProtocols = PROTOCOL_RDP;\n\tWLog_DBG(TAG, \"Attempting RDP security\");\n\n\tif (!nego_transport_connect(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_send_negotiation_request(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\n\tif (!nego_recv_response(nego))\n\t{\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n}\n\n/**\n * Wait to receive a negotiation response\n * @param nego\n */\n\nBOOL nego_recv_response(rdpNego* nego)\n{\n\tint status;\n\twStream* s;\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tstatus = transport_read_pdu(nego->transport, s);\n\n\tif (status < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tstatus = nego_recv(nego->transport, s, nego);\n\tStream_Free(s, TRUE);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Receive protocol security negotiation message.\\n\n * @msdn{cc240501}\n * @param transport transport\n * @param s stream\n * @param extra nego pointer\n */\n\nint nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\n\tif (li > 6)\n\t{\n\t\t/* rdpNegData (optional) */\n\t\tStream_Read_UINT8(s, type); /* Type */\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tif (!nego_process_negotiation_response(nego, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\n\t\t\t\t/* enhanced security selected ? */\n\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tif (!nego_process_negotiation_failure(nego, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\n/**\n * Read optional routing token or cookie of X.224 Connection Request PDU.\n * @msdn{cc240470}\n * @param nego\n * @param s stream\n */\n\nstatic BOOL nego_read_request_token_or_cookie(rdpNego* nego, wStream* s)\n{\n\t/* routingToken and cookie are optional and mutually exclusive!\n\t *\n\t * routingToken (variable): An optional and variable-length routing\n\t * token (used for load balancing) terminated by a 0x0D0A two-byte\n\t * sequence: (check [MSFT-SDLBTS] for details!)\n\t * Cookie:[space]msts=[ip address].[port].[reserved][\\x0D\\x0A]\n\t *\n\t * cookie (variable): An optional and variable-length ANSI character\n\t * string terminated by a 0x0D0A two-byte sequence:\n\t * Cookie:[space]mstshash=[ANSISTRING][\\x0D\\x0A]\n\t */\n\tBYTE* str = NULL;\n\tUINT16 crlf = 0;\n\tsize_t pos, len;\n\tBOOL result = FALSE;\n\tBOOL isToken = FALSE;\n\tsize_t remain = Stream_GetRemainingLength(s);\n\tstr = Stream_Pointer(s);\n\tpos = Stream_GetPosition(s);\n\n\t/* minimum length for token is 15 */\n\tif (remain < 15)\n\t\treturn TRUE;\n\n\tif (memcmp(Stream_Pointer(s), \"Cookie: mstshash=\", 17) != 0)\n\t{\n\t\tisToken = TRUE;\n\t}\n\telse\n\t{\n\t\t/* not a token, minimum length for cookie is 19 */\n\t\tif (remain < 19)\n\t\t\treturn TRUE;\n\n\t\tStream_Seek(s, 17);\n\t}\n\n\twhile ((remain = Stream_GetRemainingLength(s)) >= 2)\n\t{\n\t\tStream_Read_UINT16(s, crlf);\n\n\t\tif (crlf == 0x0A0D)\n\t\t\tbreak;\n\n\t\tStream_Rewind(s, 1);\n\t}\n\n\tif (crlf == 0x0A0D)\n\t{\n\t\tStream_Rewind(s, 2);\n\t\tlen = Stream_GetPosition(s) - pos;\n\t\tremain = Stream_GetRemainingLength(s);\n\t\tStream_Write_UINT16(s, 0);\n\n\t\tif (strnlen((char*)str, len) == len)\n\t\t{\n\t\t\tif (isToken)\n\t\t\t\tresult = nego_set_routing_token(nego, str, len);\n\t\t\telse\n\t\t\t\tresult = nego_set_cookie(nego, (char*)str);\n\t\t}\n\t}\n\n\tif (!result)\n\t{\n\t\tStream_SetPosition(s, pos);\n\t\tWLog_ERR(TAG, \"invalid %s received\", isToken ? \"routing token\" : \"cookie\");\n\t}\n\telse\n\t{\n\t\tWLog_DBG(TAG, \"received %s [%s]\", isToken ? \"routing token\" : \"cookie\", str);\n\t}\n\n\treturn result;\n}\n\n/**\n * Read protocol security negotiation request message.\\n\n * @param nego\n * @param s stream\n */\n\nBOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\t/* rdpNegData (optional) */\n\t\tStream_Read_UINT8(s, type); /* Type */\n\n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!nego_process_negotiation_request(nego, s))\n\t\t\treturn FALSE;\n\t}\n\n\treturn tpkt_ensure_stream_consumed(s, length);\n}\n\n/**\n * Send protocol security negotiation message.\n * @param nego\n */\n\nvoid nego_send(rdpNego* nego)\n{\n\tif (nego->state == NEGO_STATE_EXT)\n\t\tnego_attempt_ext(nego);\n\telse if (nego->state == NEGO_STATE_NLA)\n\t\tnego_attempt_nla(nego);\n\telse if (nego->state == NEGO_STATE_TLS)\n\t\tnego_attempt_tls(nego);\n\telse if (nego->state == NEGO_STATE_RDP)\n\t\tnego_attempt_rdp(nego);\n\telse\n\t\tWLog_ERR(TAG, \"invalid negotiation state for sending\");\n}\n\n/**\n * Send RDP Negotiation Request (RDP_NEG_REQ).\\n\n * @msdn{cc240500}\\n\n * @msdn{cc240470}\n * @param nego\n */\n\nBOOL nego_send_negotiation_request(rdpNego* nego)\n{\n\tBOOL rc = FALSE;\n\twStream* s;\n\tsize_t length;\n\tsize_t bm, em;\n\tBYTE flags = 0;\n\tsize_t cookie_length;\n\ts = Stream_New(NULL, 512);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tlength = TPDU_CONNECTION_REQUEST_LENGTH;\n\tbm = Stream_GetPosition(s);\n\tStream_Seek(s, length);\n\n\tif (nego->RoutingToken)\n\t{\n\t\tStream_Write(s, nego->RoutingToken, nego->RoutingTokenLength);\n\n\t\t/* Ensure Routing Token is correctly terminated - may already be present in string */\n\n\t\tif ((nego->RoutingTokenLength > 2) &&\n\t\t    (nego->RoutingToken[nego->RoutingTokenLength - 2] == 0x0D) &&\n\t\t    (nego->RoutingToken[nego->RoutingTokenLength - 1] == 0x0A))\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Routing token looks correctly terminated - use verbatim\");\n\t\t\tlength += nego->RoutingTokenLength;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_DBG(TAG, \"Adding terminating CRLF to routing token\");\n\t\t\tStream_Write_UINT8(s, 0x0D); /* CR */\n\t\t\tStream_Write_UINT8(s, 0x0A); /* LF */\n\t\t\tlength += nego->RoutingTokenLength + 2;\n\t\t}\n\t}\n\telse if (nego->cookie)\n\t{\n\t\tcookie_length = strlen(nego->cookie);\n\n\t\tif (cookie_length > nego->CookieMaxLength)\n\t\t\tcookie_length = nego->CookieMaxLength;\n\n\t\tStream_Write(s, \"Cookie: mstshash=\", 17);\n\t\tStream_Write(s, (BYTE*)nego->cookie, cookie_length);\n\t\tStream_Write_UINT8(s, 0x0D); /* CR */\n\t\tStream_Write_UINT8(s, 0x0A); /* LF */\n\t\tlength += cookie_length + 19;\n\t}\n\n\tWLog_DBG(TAG, \"RequestedProtocols: %\" PRIu32 \"\", nego->RequestedProtocols);\n\n\tif ((nego->RequestedProtocols > PROTOCOL_RDP) || (nego->sendNegoData))\n\t{\n\t\t/* RDP_NEG_DATA must be present for TLS and NLA */\n\t\tif (nego->RestrictedAdminModeRequired)\n\t\t\tflags |= RESTRICTED_ADMIN_MODE_REQUIRED;\n\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_REQ);\n\t\tStream_Write_UINT8(s, flags);\n\t\tStream_Write_UINT16(s, 8);                        /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, nego->RequestedProtocols); /* requestedProtocols */\n\t\tlength += 8;\n\t}\n\n\tif (length > UINT16_MAX)\n\t\tgoto fail;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\ttpkt_write_header(s, (UINT16)length);\n\ttpdu_write_connection_request(s, (UINT16)length - 5);\n\tStream_SetPosition(s, em);\n\tStream_SealLength(s);\n\trc = (transport_write(nego->transport, s) >= 0);\nfail:\n\tStream_Free(s, TRUE);\n\treturn rc;\n}\n\n/**\n * Process Negotiation Request from Connection Request message.\n * @param nego\n * @param s\n */\n\nBOOL nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n\treturn TRUE;\n}\n\n/**\n * Process Negotiation Response from Connection Confirm message.\n * @param nego\n * @param s\n */\n\nBOOL nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n\treturn TRUE;\n}\n\n/**\n * Process Negotiation Failure from Connection Confirm message.\n * @param nego\n * @param s\n */\n\nBOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n\treturn TRUE;\n}\n\n/**\n * Send RDP Negotiation Response (RDP_NEG_RSP).\\n\n * @param nego\n */\n\nBOOL nego_send_negotiation_response(rdpNego* nego)\n{\n\tUINT16 length;\n\tsize_t bm, em;\n\tBOOL status;\n\twStream* s;\n\tBYTE flags;\n\trdpSettings* settings;\n\tstatus = TRUE;\n\tsettings = nego->transport->settings;\n\ts = Stream_New(NULL, 512);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn FALSE;\n\t}\n\n\tlength = TPDU_CONNECTION_CONFIRM_LENGTH;\n\tbm = Stream_GetPosition(s);\n\tStream_Seek(s, length);\n\n\tif (nego->SelectedProtocol & PROTOCOL_FAILED_NEGO)\n\t{\n\t\tUINT32 errorCode = (nego->SelectedProtocol & ~PROTOCOL_FAILED_NEGO);\n\t\tflags = 0;\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_FAILURE);\n\t\tStream_Write_UINT8(s, flags); /* flags */\n\t\tStream_Write_UINT16(s, 8);    /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, errorCode);\n\t\tlength += 8;\n\t\tstatus = FALSE;\n\t}\n\telse\n\t{\n\t\tflags = EXTENDED_CLIENT_DATA_SUPPORTED;\n\n\t\tif (settings->SupportGraphicsPipeline)\n\t\t\tflags |= DYNVC_GFX_PROTOCOL_SUPPORTED;\n\n\t\t/* RDP_NEG_DATA must be present for TLS, NLA, and RDP */\n\t\tStream_Write_UINT8(s, TYPE_RDP_NEG_RSP);\n\t\tStream_Write_UINT8(s, flags);                   /* flags */\n\t\tStream_Write_UINT16(s, 8);                      /* RDP_NEG_DATA length (8) */\n\t\tStream_Write_UINT32(s, nego->SelectedProtocol); /* selectedProtocol */\n\t\tlength += 8;\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\ttpkt_write_header(s, length);\n\ttpdu_write_connection_confirm(s, length - 5);\n\tStream_SetPosition(s, em);\n\tStream_SealLength(s);\n\n\tif (transport_write(nego->transport, s) < 0)\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tStream_Free(s, TRUE);\n\n\tif (status)\n\t{\n\t\t/* update settings with negotiated protocol security */\n\t\tsettings->RequestedProtocols = nego->RequestedProtocols;\n\t\tsettings->SelectedProtocol = nego->SelectedProtocol;\n\n\t\tif (settings->SelectedProtocol == PROTOCOL_RDP)\n\t\t{\n\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\tsettings->RdpSecurity = TRUE;\n\t\t\tsettings->UseRdpSecurityLayer = TRUE;\n\n\t\t\tif (settings->EncryptionLevel == ENCRYPTION_LEVEL_NONE)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * If the server implementation did not explicitely set a\n\t\t\t\t * encryption level we default to client compatible\n\t\t\t\t */\n\t\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_CLIENT_COMPATIBLE;\n\t\t\t}\n\n\t\t\tif (settings->LocalConnection)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Note: This hack was firstly introduced in commit 95f5e115 to\n\t\t\t\t * disable the unnecessary encryption with peers connecting to\n\t\t\t\t * 127.0.0.1 or local unix sockets.\n\t\t\t\t * This also affects connections via port tunnels! (e.g. ssh -L)\n\t\t\t\t */\n\t\t\t\tWLog_INFO(TAG, \"Turning off encryption for local peer with standard rdp security\");\n\t\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t\t}\n\n\t\t\tif (!settings->RdpServerRsaKey && !settings->RdpKeyFile && !settings->RdpKeyContent)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Missing server certificate\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse if (settings->SelectedProtocol == PROTOCOL_SSL)\n\t\t{\n\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t}\n\t\telse if (settings->SelectedProtocol == PROTOCOL_HYBRID)\n\t\t{\n\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\tsettings->NlaSecurity = TRUE;\n\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/**\n * Initialize NEGO state machine.\n * @param nego\n */\n\nvoid nego_init(rdpNego* nego)\n{\n\tnego->state = NEGO_STATE_INITIAL;\n\tnego->RequestedProtocols = PROTOCOL_RDP;\n\tnego->CookieMaxLength = DEFAULT_COOKIE_MAX_LENGTH;\n\tnego->sendNegoData = FALSE;\n\tnego->flags = 0;\n}\n\n/**\n * Create a new NEGO state machine instance.\n * @param transport\n * @return\n */\n\nrdpNego* nego_new(rdpTransport* transport)\n{\n\trdpNego* nego = (rdpNego*)calloc(1, sizeof(rdpNego));\n\n\tif (!nego)\n\t\treturn NULL;\n\n\tnego->transport = transport;\n\tnego_init(nego);\n\treturn nego;\n}\n\n/**\n * Free NEGO state machine.\n * @param nego\n */\n\nvoid nego_free(rdpNego* nego)\n{\n\tif (nego)\n\t{\n\t\tfree(nego->RoutingToken);\n\t\tfree(nego->cookie);\n\t\tfree(nego);\n\t}\n}\n\n/**\n * Set target hostname and port.\n * @param nego\n * @param hostname\n * @param port\n */\n\nBOOL nego_set_target(rdpNego* nego, const char* hostname, UINT16 port)\n{\n\tif (!nego || !hostname)\n\t\treturn FALSE;\n\n\tnego->hostname = hostname;\n\tnego->port = port;\n\treturn TRUE;\n}\n\n/**\n * Enable security layer negotiation.\n * @param nego pointer to the negotiation structure\n * @param enable_rdp whether to enable security layer negotiation (TRUE for enabled, FALSE for\n * disabled)\n */\n\nvoid nego_set_negotiation_enabled(rdpNego* nego, BOOL NegotiateSecurityLayer)\n{\n\tWLog_DBG(TAG, \"Enabling security layer negotiation: %s\",\n\t         NegotiateSecurityLayer ? \"TRUE\" : \"FALSE\");\n\tnego->NegotiateSecurityLayer = NegotiateSecurityLayer;\n}\n\n/**\n * Enable restricted admin mode.\n * @param nego pointer to the negotiation structure\n * @param enable_restricted whether to enable security layer negotiation (TRUE for enabled, FALSE\n * for disabled)\n */\n\nvoid nego_set_restricted_admin_mode_required(rdpNego* nego, BOOL RestrictedAdminModeRequired)\n{\n\tWLog_DBG(TAG, \"Enabling restricted admin mode: %s\",\n\t         RestrictedAdminModeRequired ? \"TRUE\" : \"FALSE\");\n\tnego->RestrictedAdminModeRequired = RestrictedAdminModeRequired;\n}\n\nvoid nego_set_gateway_enabled(rdpNego* nego, BOOL GatewayEnabled)\n{\n\tnego->GatewayEnabled = GatewayEnabled;\n}\n\nvoid nego_set_gateway_bypass_local(rdpNego* nego, BOOL GatewayBypassLocal)\n{\n\tnego->GatewayBypassLocal = GatewayBypassLocal;\n}\n\n/**\n * Enable RDP security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_rdp whether to enable normal RDP protocol (TRUE for enabled, FALSE for disabled)\n */\n\nvoid nego_enable_rdp(rdpNego* nego, BOOL enable_rdp)\n{\n\tWLog_DBG(TAG, \"Enabling RDP security: %s\", enable_rdp ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_RDP] = enable_rdp;\n}\n\n/**\n * Enable TLS security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_tls whether to enable TLS + RDP protocol (TRUE for enabled, FALSE for disabled)\n */\n\nvoid nego_enable_tls(rdpNego* nego, BOOL enable_tls)\n{\n\tWLog_DBG(TAG, \"Enabling TLS security: %s\", enable_tls ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_SSL] = enable_tls;\n}\n\n/**\n * Enable NLA security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_nla whether to enable network level authentication protocol (TRUE for enabled,\n * FALSE for disabled)\n */\n\nvoid nego_enable_nla(rdpNego* nego, BOOL enable_nla)\n{\n\tWLog_DBG(TAG, \"Enabling NLA security: %s\", enable_nla ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_HYBRID] = enable_nla;\n}\n\n/**\n * Enable NLA extended security protocol.\n * @param nego pointer to the negotiation structure\n * @param enable_ext whether to enable network level authentication extended protocol (TRUE for\n * enabled, FALSE for disabled)\n */\n\nvoid nego_enable_ext(rdpNego* nego, BOOL enable_ext)\n{\n\tWLog_DBG(TAG, \"Enabling NLA extended security: %s\", enable_ext ? \"TRUE\" : \"FALSE\");\n\tnego->EnabledProtocols[PROTOCOL_HYBRID_EX] = enable_ext;\n}\n\n/**\n * Set routing token.\n * @param nego\n * @param RoutingToken\n * @param RoutingTokenLength\n */\n\nBOOL nego_set_routing_token(rdpNego* nego, BYTE* RoutingToken, DWORD RoutingTokenLength)\n{\n\tif (RoutingTokenLength == 0)\n\t\treturn FALSE;\n\n\tfree(nego->RoutingToken);\n\tnego->RoutingTokenLength = RoutingTokenLength;\n\tnego->RoutingToken = (BYTE*)malloc(nego->RoutingTokenLength);\n\n\tif (!nego->RoutingToken)\n\t\treturn FALSE;\n\n\tCopyMemory(nego->RoutingToken, RoutingToken, nego->RoutingTokenLength);\n\treturn TRUE;\n}\n\n/**\n * Set cookie.\n * @param nego\n * @param cookie\n */\n\nBOOL nego_set_cookie(rdpNego* nego, char* cookie)\n{\n\tif (nego->cookie)\n\t{\n\t\tfree(nego->cookie);\n\t\tnego->cookie = NULL;\n\t}\n\n\tif (!cookie)\n\t\treturn TRUE;\n\n\tnego->cookie = _strdup(cookie);\n\n\tif (!nego->cookie)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Set cookie maximum length\n * @param nego\n * @param CookieMaxLength\n */\n\nvoid nego_set_cookie_max_length(rdpNego* nego, UINT32 CookieMaxLength)\n{\n\tnego->CookieMaxLength = CookieMaxLength;\n}\n\n/**\n * Enable / disable preconnection PDU.\n * @param nego\n * @param send_pcpdu\n */\n\nvoid nego_set_send_preconnection_pdu(rdpNego* nego, BOOL SendPreconnectionPdu)\n{\n\tnego->SendPreconnectionPdu = SendPreconnectionPdu;\n}\n\n/**\n * Set preconnection id.\n * @param nego\n * @param id\n */\n\nvoid nego_set_preconnection_id(rdpNego* nego, UINT32 PreconnectionId)\n{\n\tnego->PreconnectionId = PreconnectionId;\n}\n\n/**\n * Set preconnection blob.\n * @param nego\n * @param blob\n */\n\nvoid nego_set_preconnection_blob(rdpNego* nego, char* PreconnectionBlob)\n{\n\tnego->PreconnectionBlob = PreconnectionBlob;\n}\n\nUINT32 nego_get_selected_protocol(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn 0;\n\n\treturn nego->SelectedProtocol;\n}\n\nBOOL nego_set_selected_protocol(rdpNego* nego, UINT32 SelectedProtocol)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->SelectedProtocol = SelectedProtocol;\n\treturn TRUE;\n}\n\nUINT32 nego_get_requested_protocols(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn 0;\n\n\treturn nego->RequestedProtocols;\n}\n\nBOOL nego_set_requested_protocols(rdpNego* nego, UINT32 RequestedProtocols)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->RequestedProtocols = RequestedProtocols;\n\treturn TRUE;\n}\n\nNEGO_STATE nego_get_state(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn NEGO_STATE_FAIL;\n\n\treturn nego->state;\n}\n\nBOOL nego_set_state(rdpNego* nego, NEGO_STATE state)\n{\n\tif (!nego)\n\t\treturn FALSE;\n\n\tnego->state = state;\n\treturn TRUE;\n}\n\nSEC_WINNT_AUTH_IDENTITY* nego_get_identity(rdpNego* nego)\n{\n\tif (!nego)\n\t\treturn NULL;\n\n\treturn nla_get_identity(nego->transport->nla);\n}\n\nvoid nego_free_nla(rdpNego* nego)\n{\n\tif (!nego || !nego->transport)\n\t\treturn;\n\n\tnla_free(nego->transport->nla);\n\tnego->transport->nla = NULL;\n}\n\nconst BYTE* nego_get_routing_token(rdpNego* nego, DWORD* RoutingTokenLength)\n{\n\tif (!nego)\n\t\treturn NULL;\n\tif (RoutingTokenLength)\n\t\t*RoutingTokenLength = nego->RoutingTokenLength;\n\treturn nego->RoutingToken;\n}\n"], "filenames": ["channels/drive/client/drive_main.c", "channels/printer/client/printer_main.c", "channels/rdpei/client/rdpei_main.c", "channels/serial/client/serial_main.c", "libfreerdp/core/gateway/rdg.c", "libfreerdp/core/nego.c"], "buggy_code_start_loc": [333, 480, 447, 145, 307, 94], "buggy_code_end_loc": [357, 496, 447, 322, 308, 1001], "fixing_code_start_loc": [334, 481, 448, 145, 307, 94], "fixing_code_end_loc": [361, 502, 451, 327, 309, 1013], "type": "CWE-125", "message": "In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0.", "other": {"cve": {"id": "CVE-2020-11089", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-29T20:15:11.017", "lastModified": "2022-07-19T11:52:15.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.0, se presenta una lectura fuera de l\u00edmite en las funciones de irp (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). Esto ha sido corregido en la versi\u00f3n 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "5C5F8D57-1D22-42B4-9E08-9131F7BE8FA5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/795842f4096501fcefc1a7f535ccc8132feb31d7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-hfc7-c5gv-8c2h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16"}}