{"buggy_code": ["#!/bin/bash\n#\n#\n\nRELEASE_VERSION=\nbuildpath=\n\nfunction setuptree() {\n  b=$( mktemp -d $buildpath/gh-ostXXXXXX ) || return 1\n  mkdir -p $b/gh-ost\n  mkdir -p $b/gh-ost/usr/bin\n  echo $b\n}\n\nfunction build {\n  osname=$1\n  osshort=$2\n  GOOS=$3\n  GOARCH=$4\n\n  if ! go version | egrep -q 'go(1\\.1[56])' ; then\n    echo \"go version must be 1.15 or above\"\n    exit 1\n  fi\n\n  # TODO: remove GO111MODULE once gh-ost uses Go modules\n  echo \"Building ${osname} binary\"\n  export GOOS\n  export GOARCH\n  GO111MODULE=off go build -ldflags \"$ldflags\" -o $buildpath/$target go/cmd/gh-ost/main.go\n\n  if [ $? -ne 0 ]; then\n      echo \"Build failed for ${osname}\"\n      exit 1\n  fi\n\n  (cd $buildpath && tar cfz ./gh-ost-binary-${osshort}-${timestamp}.tar.gz $target)\n\n  if [ \"$GOOS\" == \"linux\" ] ; then\n    echo \"Creating Distro full packages\"\n    builddir=$(setuptree)\n    cp $buildpath/$target $builddir/gh-ost/usr/bin\n    cd $buildpath\n    fpm -v \"${RELEASE_VERSION}\" --epoch 1 -f -s dir -n gh-ost -m 'shlomi-noach <shlomi-noach+gh-ost-deb@github.com>' --description \"GitHub's Online Schema Migrations for MySQL \" --url \"https://github.com/github/gh-ost\" --vendor \"GitHub\" --license \"Apache 2.0\" -C $builddir/gh-ost --prefix=/ -t rpm --rpm-rpmbuild-define \"_build_id_links none\" .\n    fpm -v \"${RELEASE_VERSION}\" --epoch 1 -f -s dir -n gh-ost -m 'shlomi-noach <shlomi-noach+gh-ost-deb@github.com>' --description \"GitHub's Online Schema Migrations for MySQL \" --url \"https://github.com/github/gh-ost\" --vendor \"GitHub\" --license \"Apache 2.0\" -C $builddir/gh-ost --prefix=/ -t deb --deb-no-default-config-files .\n  fi\n}\n\nmain() {\n  if [ -z \"${RELEASE_VERSION}\" ] ; then\n    RELEASE_VERSION=$(git describe --abbrev=0 --tags | tr -d 'v')\n  fi\n  if [ -z \"${RELEASE_VERSION}\" ] ; then\n    RELEASE_VERSION=$(cat RELEASE_VERSION)\n  fi\n\n\n  buildpath=/tmp/gh-ost-release\n  target=gh-ost\n  timestamp=$(date \"+%Y%m%d%H%M%S\")\n  ldflags=\"-X main.AppVersion=${RELEASE_VERSION}\"\n\n  mkdir -p ${buildpath}\n  rm -rf ${buildpath:?}/*\n  build GNU/Linux linux linux amd64\n  # build macOS osx darwin amd64\n\n  echo \"Binaries found in:\"\n  find $buildpath/gh-ost* -type f -maxdepth 1\n}\n\nmain \"$@\"\n", "/*\n   Copyright 2016 GitHub Inc.\n\t See https://github.com/github/gh-ost/blob/master/LICENSE\n*/\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/github/gh-ost/go/base\"\n\t\"github.com/github/gh-ost/go/logic\"\n\t\"github.com/github/gh-ost/go/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/outbrain/golib/log\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nvar AppVersion string\n\n// acceptSignals registers for OS signals\nfunc acceptSignals(migrationContext *base.MigrationContext) {\n\tc := make(chan os.Signal, 1)\n\n\tsignal.Notify(c, syscall.SIGHUP)\n\tgo func() {\n\t\tfor sig := range c {\n\t\t\tswitch sig {\n\t\t\tcase syscall.SIGHUP:\n\t\t\t\tmigrationContext.Log.Infof(\"Received SIGHUP. Reloading configuration\")\n\t\t\t\tif err := migrationContext.ReadConfigFile(); err != nil {\n\t\t\t\t\tlog.Errore(err)\n\t\t\t\t} else {\n\t\t\t\t\tmigrationContext.MarkPointOfInterest()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// main is the application's entry point. It will either spawn a CLI or HTTP interfaces.\nfunc main() {\n\tmigrationContext := base.NewMigrationContext()\n\tflag.StringVar(&migrationContext.InspectorConnectionConfig.Key.Hostname, \"host\", \"127.0.0.1\", \"MySQL hostname (preferably a replica, not the master)\")\n\tflag.StringVar(&migrationContext.AssumeMasterHostname, \"assume-master-host\", \"\", \"(optional) explicitly tell gh-ost the identity of the master. Format: some.host.com[:port] This is useful in master-master setups where you wish to pick an explicit master, or in a tungsten-replicator where gh-ost is unable to determine the master\")\n\tflag.IntVar(&migrationContext.InspectorConnectionConfig.Key.Port, \"port\", 3306, \"MySQL port (preferably a replica, not the master)\")\n\tflag.Float64Var(&migrationContext.InspectorConnectionConfig.Timeout, \"mysql-timeout\", 0.0, \"Connect, read and write timeout for MySQL\")\n\tflag.StringVar(&migrationContext.CliUser, \"user\", \"\", \"MySQL user\")\n\tflag.StringVar(&migrationContext.CliPassword, \"password\", \"\", \"MySQL password\")\n\tflag.StringVar(&migrationContext.CliMasterUser, \"master-user\", \"\", \"MySQL user on master, if different from that on replica. Requires --assume-master-host\")\n\tflag.StringVar(&migrationContext.CliMasterPassword, \"master-password\", \"\", \"MySQL password on master, if different from that on replica. Requires --assume-master-host\")\n\tflag.StringVar(&migrationContext.ConfigFile, \"conf\", \"\", \"Config file\")\n\taskPass := flag.Bool(\"ask-pass\", false, \"prompt for MySQL password\")\n\n\tflag.BoolVar(&migrationContext.UseTLS, \"ssl\", false, \"Enable SSL encrypted connections to MySQL hosts\")\n\tflag.StringVar(&migrationContext.TLSCACertificate, \"ssl-ca\", \"\", \"CA certificate in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.StringVar(&migrationContext.TLSCertificate, \"ssl-cert\", \"\", \"Certificate in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.StringVar(&migrationContext.TLSKey, \"ssl-key\", \"\", \"Key in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.BoolVar(&migrationContext.TLSAllowInsecure, \"ssl-allow-insecure\", false, \"Skips verification of MySQL hosts' certificate chain and host name. Requires --ssl\")\n\n\tflag.StringVar(&migrationContext.DatabaseName, \"database\", \"\", \"database name (mandatory)\")\n\tflag.StringVar(&migrationContext.OriginalTableName, \"table\", \"\", \"table name (mandatory)\")\n\tflag.StringVar(&migrationContext.AlterStatement, \"alter\", \"\", \"alter statement (mandatory)\")\n\tflag.BoolVar(&migrationContext.CountTableRows, \"exact-rowcount\", false, \"actually count table rows as opposed to estimate them (results in more accurate progress estimation)\")\n\tflag.BoolVar(&migrationContext.ConcurrentCountTableRows, \"concurrent-rowcount\", true, \"(with --exact-rowcount), when true (default): count rows after row-copy begins, concurrently, and adjust row estimate later on; when false: first count rows, then start row copy\")\n\tflag.BoolVar(&migrationContext.AllowedRunningOnMaster, \"allow-on-master\", false, \"allow this migration to run directly on master. Preferably it would run on a replica\")\n\tflag.BoolVar(&migrationContext.AllowedMasterMaster, \"allow-master-master\", false, \"explicitly allow running in a master-master setup\")\n\tflag.BoolVar(&migrationContext.NullableUniqueKeyAllowed, \"allow-nullable-unique-key\", false, \"allow gh-ost to migrate based on a unique key with nullable columns. As long as no NULL values exist, this should be OK. If NULL values exist in chosen key, data may be corrupted. Use at your own risk!\")\n\tflag.BoolVar(&migrationContext.ApproveRenamedColumns, \"approve-renamed-columns\", false, \"in case your `ALTER` statement renames columns, gh-ost will note that and offer its interpretation of the rename. By default gh-ost does not proceed to execute. This flag approves that gh-ost's interpretation is correct\")\n\tflag.BoolVar(&migrationContext.SkipRenamedColumns, \"skip-renamed-columns\", false, \"in case your `ALTER` statement renames columns, gh-ost will note that and offer its interpretation of the rename. By default gh-ost does not proceed to execute. This flag tells gh-ost to skip the renamed columns, i.e. to treat what gh-ost thinks are renamed columns as unrelated columns. NOTE: you may lose column data\")\n\tflag.BoolVar(&migrationContext.IsTungsten, \"tungsten\", false, \"explicitly let gh-ost know that you are running on a tungsten-replication based topology (you are likely to also provide --assume-master-host)\")\n\tflag.BoolVar(&migrationContext.DiscardForeignKeys, \"discard-foreign-keys\", false, \"DANGER! This flag will migrate a table that has foreign keys and will NOT create foreign keys on the ghost table, thus your altered table will have NO foreign keys. This is useful for intentional dropping of foreign keys\")\n\tflag.BoolVar(&migrationContext.SkipForeignKeyChecks, \"skip-foreign-key-checks\", false, \"set to 'true' when you know for certain there are no foreign keys on your table, and wish to skip the time it takes for gh-ost to verify that\")\n\tflag.BoolVar(&migrationContext.SkipStrictMode, \"skip-strict-mode\", false, \"explicitly tell gh-ost binlog applier not to enforce strict sql mode\")\n\tflag.BoolVar(&migrationContext.AliyunRDS, \"aliyun-rds\", false, \"set to 'true' when you execute on Aliyun RDS.\")\n\tflag.BoolVar(&migrationContext.GoogleCloudPlatform, \"gcp\", false, \"set to 'true' when you execute on a 1st generation Google Cloud Platform (GCP).\")\n\tflag.BoolVar(&migrationContext.AzureMySQL, \"azure\", false, \"set to 'true' when you execute on Azure Database on MySQL.\")\n\n\texecuteFlag := flag.Bool(\"execute\", false, \"actually execute the alter & migrate the table. Default is noop: do some tests and exit\")\n\tflag.BoolVar(&migrationContext.TestOnReplica, \"test-on-replica\", false, \"Have the migration run on a replica, not on the master. At the end of migration replication is stopped, and tables are swapped and immediately swap-revert. Replication remains stopped and you can compare the two tables for building trust\")\n\tflag.BoolVar(&migrationContext.TestOnReplicaSkipReplicaStop, \"test-on-replica-skip-replica-stop\", false, \"When --test-on-replica is enabled, do not issue commands stop replication (requires --test-on-replica)\")\n\tflag.BoolVar(&migrationContext.MigrateOnReplica, \"migrate-on-replica\", false, \"Have the migration run on a replica, not on the master. This will do the full migration on the replica including cut-over (as opposed to --test-on-replica)\")\n\n\tflag.BoolVar(&migrationContext.OkToDropTable, \"ok-to-drop-table\", false, \"Shall the tool drop the old table at end of operation. DROPping tables can be a long locking operation, which is why I'm not doing it by default. I'm an online tool, yes?\")\n\tflag.BoolVar(&migrationContext.InitiallyDropOldTable, \"initially-drop-old-table\", false, \"Drop a possibly existing OLD table (remains from a previous run?) before beginning operation. Default is to panic and abort if such table exists\")\n\tflag.BoolVar(&migrationContext.InitiallyDropGhostTable, \"initially-drop-ghost-table\", false, \"Drop a possibly existing Ghost table (remains from a previous run?) before beginning operation. Default is to panic and abort if such table exists\")\n\tflag.BoolVar(&migrationContext.TimestampOldTable, \"timestamp-old-table\", false, \"Use a timestamp in old table name. This makes old table names unique and non conflicting cross migrations\")\n\tcutOver := flag.String(\"cut-over\", \"atomic\", \"choose cut-over type (default|atomic, two-step)\")\n\tflag.BoolVar(&migrationContext.ForceNamedCutOverCommand, \"force-named-cut-over\", false, \"When true, the 'unpostpone|cut-over' interactive command must name the migrated table\")\n\tflag.BoolVar(&migrationContext.ForceNamedPanicCommand, \"force-named-panic\", false, \"When true, the 'panic' interactive command must name the migrated table\")\n\n\tflag.BoolVar(&migrationContext.SwitchToRowBinlogFormat, \"switch-to-rbr\", false, \"let this tool automatically switch binary log format to 'ROW' on the replica, if needed. The format will NOT be switched back. I'm too scared to do that, and wish to protect you if you happen to execute another migration while this one is running\")\n\tflag.BoolVar(&migrationContext.AssumeRBR, \"assume-rbr\", false, \"set to 'true' when you know for certain your server uses 'ROW' binlog_format. gh-ost is unable to tell, event after reading binlog_format, whether the replication process does indeed use 'ROW', and restarts replication to be certain RBR setting is applied. Such operation requires SUPER privileges which you might not have. Setting this flag avoids restarting replication and you can proceed to use gh-ost without SUPER privileges\")\n\tflag.BoolVar(&migrationContext.CutOverExponentialBackoff, \"cut-over-exponential-backoff\", false, \"Wait exponentially longer intervals between failed cut-over attempts. Wait intervals obey a maximum configurable with 'exponential-backoff-max-interval').\")\n\texponentialBackoffMaxInterval := flag.Int64(\"exponential-backoff-max-interval\", 64, \"Maximum number of seconds to wait between attempts when performing various operations with exponential backoff.\")\n\tchunkSize := flag.Int64(\"chunk-size\", 1000, \"amount of rows to handle in each iteration (allowed range: 100-100,000)\")\n\tdmlBatchSize := flag.Int64(\"dml-batch-size\", 10, \"batch size for DML events to apply in a single transaction (range 1-100)\")\n\tdefaultRetries := flag.Int64(\"default-retries\", 60, \"Default number of retries for various operations before panicking\")\n\tcutOverLockTimeoutSeconds := flag.Int64(\"cut-over-lock-timeout-seconds\", 3, \"Max number of seconds to hold locks on tables while attempting to cut-over (retry attempted when lock exceeds timeout)\")\n\tniceRatio := flag.Float64(\"nice-ratio\", 0, \"force being 'nice', imply sleep time per chunk time; range: [0.0..100.0]. Example values: 0 is aggressive. 1: for every 1ms spent copying rows, sleep additional 1ms (effectively doubling runtime); 0.7: for every 10ms spend in a rowcopy chunk, spend 7ms sleeping immediately after\")\n\n\tmaxLagMillis := flag.Int64(\"max-lag-millis\", 1500, \"replication lag at which to throttle operation\")\n\treplicationLagQuery := flag.String(\"replication-lag-query\", \"\", \"Deprecated. gh-ost uses an internal, subsecond resolution query\")\n\tthrottleControlReplicas := flag.String(\"throttle-control-replicas\", \"\", \"List of replicas on which to check for lag; comma delimited. Example: myhost1.com:3306,myhost2.com,myhost3.com:3307\")\n\tthrottleQuery := flag.String(\"throttle-query\", \"\", \"when given, issued (every second) to check if operation should throttle. Expecting to return zero for no-throttle, >0 for throttle. Query is issued on the migrated server. Make sure this query is lightweight\")\n\tthrottleHTTP := flag.String(\"throttle-http\", \"\", \"when given, gh-ost checks given URL via HEAD request; any response code other than 200 (OK) causes throttling; make sure it has low latency response\")\n\tignoreHTTPErrors := flag.Bool(\"ignore-http-errors\", false, \"ignore HTTP connection errors during throttle check\")\n\theartbeatIntervalMillis := flag.Int64(\"heartbeat-interval-millis\", 100, \"how frequently would gh-ost inject a heartbeat value\")\n\tflag.StringVar(&migrationContext.ThrottleFlagFile, \"throttle-flag-file\", \"\", \"operation pauses when this file exists; hint: use a file that is specific to the table being altered\")\n\tflag.StringVar(&migrationContext.ThrottleAdditionalFlagFile, \"throttle-additional-flag-file\", \"/tmp/gh-ost.throttle\", \"operation pauses when this file exists; hint: keep default, use for throttling multiple gh-ost operations\")\n\tflag.StringVar(&migrationContext.PostponeCutOverFlagFile, \"postpone-cut-over-flag-file\", \"\", \"while this file exists, migration will postpone the final stage of swapping tables, and will keep on syncing the ghost table. Cut-over/swapping would be ready to perform the moment the file is deleted.\")\n\tflag.StringVar(&migrationContext.PanicFlagFile, \"panic-flag-file\", \"\", \"when this file is created, gh-ost will immediately terminate, without cleanup\")\n\n\tflag.BoolVar(&migrationContext.DropServeSocket, \"initially-drop-socket-file\", false, \"Should gh-ost forcibly delete an existing socket file. Be careful: this might drop the socket file of a running migration!\")\n\tflag.StringVar(&migrationContext.ServeSocketFile, \"serve-socket-file\", \"\", \"Unix socket file to serve on. Default: auto-determined and advertised upon startup\")\n\tflag.Int64Var(&migrationContext.ServeTCPPort, \"serve-tcp-port\", 0, \"TCP port to serve on. Default: disabled\")\n\n\tflag.StringVar(&migrationContext.HooksPath, \"hooks-path\", \"\", \"directory where hook files are found (default: empty, ie. hooks disabled). Hook files found on this path, and conforming to hook naming conventions will be executed\")\n\tflag.StringVar(&migrationContext.HooksHintMessage, \"hooks-hint\", \"\", \"arbitrary message to be injected to hooks via GH_OST_HOOKS_HINT, for your convenience\")\n\tflag.StringVar(&migrationContext.HooksHintOwner, \"hooks-hint-owner\", \"\", \"arbitrary name of owner to be injected to hooks via GH_OST_HOOKS_HINT_OWNER, for your convenience\")\n\tflag.StringVar(&migrationContext.HooksHintToken, \"hooks-hint-token\", \"\", \"arbitrary token to be injected to hooks via GH_OST_HOOKS_HINT_TOKEN, for your convenience\")\n\n\tflag.UintVar(&migrationContext.ReplicaServerId, \"replica-server-id\", 99999, \"server id used by gh-ost process. Default: 99999\")\n\n\tmaxLoad := flag.String(\"max-load\", \"\", \"Comma delimited status-name=threshold. e.g: 'Threads_running=100,Threads_connected=500'. When status exceeds threshold, app throttles writes\")\n\tcriticalLoad := flag.String(\"critical-load\", \"\", \"Comma delimited status-name=threshold, same format as --max-load. When status exceeds threshold, app panics and quits\")\n\tflag.Int64Var(&migrationContext.CriticalLoadIntervalMilliseconds, \"critical-load-interval-millis\", 0, \"When 0, migration immediately bails out upon meeting critical-load. When non-zero, a second check is done after given interval, and migration only bails out if 2nd check still meets critical load\")\n\tflag.Int64Var(&migrationContext.CriticalLoadHibernateSeconds, \"critical-load-hibernate-seconds\", 0, \"When non-zero, critical-load does not panic and bail out; instead, gh-ost goes into hibernation for the specified duration. It will not read/write anything from/to any server\")\n\tquiet := flag.Bool(\"quiet\", false, \"quiet\")\n\tverbose := flag.Bool(\"verbose\", false, \"verbose\")\n\tdebug := flag.Bool(\"debug\", false, \"debug mode (very verbose)\")\n\tstack := flag.Bool(\"stack\", false, \"add stack trace upon error\")\n\thelp := flag.Bool(\"help\", false, \"Display usage\")\n\tversion := flag.Bool(\"version\", false, \"Print version & exit\")\n\tcheckFlag := flag.Bool(\"check-flag\", false, \"Check if another flag exists/supported. This allows for cross-version scripting. Exits with 0 when all additional provided flags exist, nonzero otherwise. You must provide (dummy) values for flags that require a value. Example: gh-ost --check-flag --cut-over-lock-timeout-seconds --nice-ratio 0\")\n\tflag.StringVar(&migrationContext.ForceTmpTableName, \"force-table-names\", \"\", \"table name prefix to be used on the temporary tables\")\n\tflag.CommandLine.SetOutput(os.Stdout)\n\n\tflag.Parse()\n\n\tif *checkFlag {\n\t\treturn\n\t}\n\tif *help {\n\t\tfmt.Fprintf(os.Stdout, \"Usage of gh-ost:\\n\")\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\tif *version {\n\t\tappVersion := AppVersion\n\t\tif appVersion == \"\" {\n\t\t\tappVersion = \"unversioned\"\n\t\t}\n\t\tfmt.Println(appVersion)\n\t\treturn\n\t}\n\n\tmigrationContext.Log.SetLevel(log.ERROR)\n\tif *verbose {\n\t\tmigrationContext.Log.SetLevel(log.INFO)\n\t}\n\tif *debug {\n\t\tmigrationContext.Log.SetLevel(log.DEBUG)\n\t}\n\tif *stack {\n\t\tmigrationContext.Log.SetPrintStackTrace(*stack)\n\t}\n\tif *quiet {\n\t\t// Override!!\n\t\tmigrationContext.Log.SetLevel(log.ERROR)\n\t}\n\n\tif migrationContext.AlterStatement == \"\" {\n\t\tlog.Fatalf(\"--alter must be provided and statement must not be empty\")\n\t}\n\tparser := sql.NewParserFromAlterStatement(migrationContext.AlterStatement)\n\tmigrationContext.AlterStatementOptions = parser.GetAlterStatementOptions()\n\n\tif migrationContext.DatabaseName == \"\" {\n\t\tif parser.HasExplicitSchema() {\n\t\t\tmigrationContext.DatabaseName = parser.GetExplicitSchema()\n\t\t} else {\n\t\t\tlog.Fatalf(\"--database must be provided and database name must not be empty, or --alter must specify database name\")\n\t\t}\n\t}\n\tif migrationContext.OriginalTableName == \"\" {\n\t\tif parser.HasExplicitTable() {\n\t\t\tmigrationContext.OriginalTableName = parser.GetExplicitTable()\n\t\t} else {\n\t\t\tlog.Fatalf(\"--table must be provided and table name must not be empty, or --alter must specify table name\")\n\t\t}\n\t}\n\tmigrationContext.Noop = !(*executeFlag)\n\tif migrationContext.AllowedRunningOnMaster && migrationContext.TestOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--allow-on-master and --test-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.AllowedRunningOnMaster && migrationContext.MigrateOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--allow-on-master and --migrate-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.MigrateOnReplica && migrationContext.TestOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--migrate-on-replica and --test-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.SwitchToRowBinlogFormat && migrationContext.AssumeRBR {\n\t\tmigrationContext.Log.Fatalf(\"--switch-to-rbr and --assume-rbr are mutually exclusive\")\n\t}\n\tif migrationContext.TestOnReplicaSkipReplicaStop {\n\t\tif !migrationContext.TestOnReplica {\n\t\t\tmigrationContext.Log.Fatalf(\"--test-on-replica-skip-replica-stop requires --test-on-replica to be enabled\")\n\t\t}\n\t\tmigrationContext.Log.Warning(\"--test-on-replica-skip-replica-stop enabled. We will not stop replication before cut-over. Ensure you have a plugin that does this.\")\n\t}\n\tif migrationContext.CliMasterUser != \"\" && migrationContext.AssumeMasterHostname == \"\" {\n\t\tmigrationContext.Log.Fatalf(\"--master-user requires --assume-master-host\")\n\t}\n\tif migrationContext.CliMasterPassword != \"\" && migrationContext.AssumeMasterHostname == \"\" {\n\t\tmigrationContext.Log.Fatalf(\"--master-password requires --assume-master-host\")\n\t}\n\tif migrationContext.TLSCACertificate != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-ca requires --ssl\")\n\t}\n\tif migrationContext.TLSCertificate != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-cert requires --ssl\")\n\t}\n\tif migrationContext.TLSKey != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-key requires --ssl\")\n\t}\n\tif migrationContext.TLSAllowInsecure && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-allow-insecure requires --ssl\")\n\t}\n\tif *replicationLagQuery != \"\" {\n\t\tmigrationContext.Log.Warningf(\"--replication-lag-query is deprecated\")\n\t}\n\n\tswitch *cutOver {\n\tcase \"atomic\", \"default\", \"\":\n\t\tmigrationContext.CutOverType = base.CutOverAtomic\n\tcase \"two-step\":\n\t\tmigrationContext.CutOverType = base.CutOverTwoStep\n\tdefault:\n\t\tmigrationContext.Log.Fatalf(\"Unknown cut-over: %s\", *cutOver)\n\t}\n\tif err := migrationContext.ReadConfigFile(); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadThrottleControlReplicaKeys(*throttleControlReplicas); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadMaxLoad(*maxLoad); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadCriticalLoad(*criticalLoad); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif migrationContext.ServeSocketFile == \"\" {\n\t\tmigrationContext.ServeSocketFile = fmt.Sprintf(\"/tmp/gh-ost.%s.%s.sock\", migrationContext.DatabaseName, migrationContext.OriginalTableName)\n\t}\n\tif *askPass {\n\t\tfmt.Println(\"Password:\")\n\t\tbytePassword, err := terminal.ReadPassword(int(syscall.Stdin))\n\t\tif err != nil {\n\t\t\tmigrationContext.Log.Fatale(err)\n\t\t}\n\t\tmigrationContext.CliPassword = string(bytePassword)\n\t}\n\tmigrationContext.SetHeartbeatIntervalMilliseconds(*heartbeatIntervalMillis)\n\tmigrationContext.SetNiceRatio(*niceRatio)\n\tmigrationContext.SetChunkSize(*chunkSize)\n\tmigrationContext.SetDMLBatchSize(*dmlBatchSize)\n\tmigrationContext.SetMaxLagMillisecondsThrottleThreshold(*maxLagMillis)\n\tmigrationContext.SetThrottleQuery(*throttleQuery)\n\tmigrationContext.SetThrottleHTTP(*throttleHTTP)\n\tmigrationContext.SetIgnoreHTTPErrors(*ignoreHTTPErrors)\n\tmigrationContext.SetDefaultNumRetries(*defaultRetries)\n\tmigrationContext.ApplyCredentials()\n\tif err := migrationContext.SetupTLS(); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.SetCutOverLockTimeoutSeconds(*cutOverLockTimeoutSeconds); err != nil {\n\t\tmigrationContext.Log.Errore(err)\n\t}\n\tif err := migrationContext.SetExponentialBackoffMaxInterval(*exponentialBackoffMaxInterval); err != nil {\n\t\tmigrationContext.Log.Errore(err)\n\t}\n\n\tlog.Infof(\"starting gh-ost %+v\", AppVersion)\n\tacceptSignals(migrationContext)\n\n\tmigrator := logic.NewMigrator(migrationContext)\n\terr := migrator.Migrate()\n\tif err != nil {\n\t\tmigrator.ExecOnFailureHook()\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tfmt.Fprintf(os.Stdout, \"# Done\\n\")\n}\n"], "fixing_code": ["#!/bin/bash\n#\n#\n\nRELEASE_VERSION=\nbuildpath=\n\nfunction setuptree() {\n  b=$( mktemp -d $buildpath/gh-ostXXXXXX ) || return 1\n  mkdir -p $b/gh-ost\n  mkdir -p $b/gh-ost/usr/bin\n  echo $b\n}\n\nfunction build {\n  osname=$1\n  osshort=$2\n  GOOS=$3\n  GOARCH=$4\n\n  if ! go version | egrep -q 'go1\\.(1[5-9]|[2-9][0-9]{1})' ; then\n    echo \"go version must be 1.15 or above\"\n    exit 1\n  fi\n\n  # TODO: remove GO111MODULE once gh-ost uses Go modules\n  echo \"Building ${osname} binary\"\n  export GOOS\n  export GOARCH\n  GO111MODULE=off go build -ldflags \"$ldflags\" -o $buildpath/$target go/cmd/gh-ost/main.go\n\n  if [ $? -ne 0 ]; then\n      echo \"Build failed for ${osname}\"\n      exit 1\n  fi\n\n  (cd $buildpath && tar cfz ./gh-ost-binary-${osshort}-${timestamp}.tar.gz $target)\n\n  if [ \"$GOOS\" == \"linux\" ] ; then\n    echo \"Creating Distro full packages\"\n    builddir=$(setuptree)\n    cp $buildpath/$target $builddir/gh-ost/usr/bin\n    cd $buildpath\n    fpm -v \"${RELEASE_VERSION}\" --epoch 1 -f -s dir -n gh-ost -m 'shlomi-noach <shlomi-noach+gh-ost-deb@github.com>' --description \"GitHub's Online Schema Migrations for MySQL \" --url \"https://github.com/github/gh-ost\" --vendor \"GitHub\" --license \"Apache 2.0\" -C $builddir/gh-ost --prefix=/ -t rpm --rpm-rpmbuild-define \"_build_id_links none\" .\n    fpm -v \"${RELEASE_VERSION}\" --epoch 1 -f -s dir -n gh-ost -m 'shlomi-noach <shlomi-noach+gh-ost-deb@github.com>' --description \"GitHub's Online Schema Migrations for MySQL \" --url \"https://github.com/github/gh-ost\" --vendor \"GitHub\" --license \"Apache 2.0\" -C $builddir/gh-ost --prefix=/ -t deb --deb-no-default-config-files .\n  fi\n}\n\nmain() {\n  if [ -z \"${RELEASE_VERSION}\" ] ; then\n    RELEASE_VERSION=$(git describe --abbrev=0 --tags | tr -d 'v')\n  fi\n  if [ -z \"${RELEASE_VERSION}\" ] ; then\n    RELEASE_VERSION=$(cat RELEASE_VERSION)\n  fi\n\n\n  buildpath=/tmp/gh-ost-release\n  target=gh-ost\n  timestamp=$(date \"+%Y%m%d%H%M%S\")\n  ldflags=\"-X main.AppVersion=${RELEASE_VERSION}\"\n\n  mkdir -p ${buildpath}\n  rm -rf ${buildpath:?}/*\n  build GNU/Linux linux linux amd64\n  # build macOS osx darwin amd64\n\n  echo \"Binaries found in:\"\n  find $buildpath/gh-ost* -type f -maxdepth 1\n}\n\nmain \"$@\"\n", "/*\n   Copyright 2016 GitHub Inc.\n\t See https://github.com/github/gh-ost/blob/master/LICENSE\n*/\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/github/gh-ost/go/base\"\n\t\"github.com/github/gh-ost/go/logic\"\n\t\"github.com/github/gh-ost/go/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/outbrain/golib/log\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nvar AppVersion string\n\n// acceptSignals registers for OS signals\nfunc acceptSignals(migrationContext *base.MigrationContext) {\n\tc := make(chan os.Signal, 1)\n\n\tsignal.Notify(c, syscall.SIGHUP)\n\tgo func() {\n\t\tfor sig := range c {\n\t\t\tswitch sig {\n\t\t\tcase syscall.SIGHUP:\n\t\t\t\tmigrationContext.Log.Infof(\"Received SIGHUP. Reloading configuration\")\n\t\t\t\tif err := migrationContext.ReadConfigFile(); err != nil {\n\t\t\t\t\tlog.Errore(err)\n\t\t\t\t} else {\n\t\t\t\t\tmigrationContext.MarkPointOfInterest()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// main is the application's entry point. It will either spawn a CLI or HTTP interfaces.\nfunc main() {\n\tmigrationContext := base.NewMigrationContext()\n\tflag.StringVar(&migrationContext.InspectorConnectionConfig.Key.Hostname, \"host\", \"127.0.0.1\", \"MySQL hostname (preferably a replica, not the master)\")\n\tflag.StringVar(&migrationContext.AssumeMasterHostname, \"assume-master-host\", \"\", \"(optional) explicitly tell gh-ost the identity of the master. Format: some.host.com[:port] This is useful in master-master setups where you wish to pick an explicit master, or in a tungsten-replicator where gh-ost is unable to determine the master\")\n\tflag.IntVar(&migrationContext.InspectorConnectionConfig.Key.Port, \"port\", 3306, \"MySQL port (preferably a replica, not the master)\")\n\tflag.Float64Var(&migrationContext.InspectorConnectionConfig.Timeout, \"mysql-timeout\", 0.0, \"Connect, read and write timeout for MySQL\")\n\tflag.StringVar(&migrationContext.CliUser, \"user\", \"\", \"MySQL user\")\n\tflag.StringVar(&migrationContext.CliPassword, \"password\", \"\", \"MySQL password\")\n\tflag.StringVar(&migrationContext.CliMasterUser, \"master-user\", \"\", \"MySQL user on master, if different from that on replica. Requires --assume-master-host\")\n\tflag.StringVar(&migrationContext.CliMasterPassword, \"master-password\", \"\", \"MySQL password on master, if different from that on replica. Requires --assume-master-host\")\n\tflag.StringVar(&migrationContext.ConfigFile, \"conf\", \"\", \"Config file\")\n\taskPass := flag.Bool(\"ask-pass\", false, \"prompt for MySQL password\")\n\n\tflag.BoolVar(&migrationContext.UseTLS, \"ssl\", false, \"Enable SSL encrypted connections to MySQL hosts\")\n\tflag.StringVar(&migrationContext.TLSCACertificate, \"ssl-ca\", \"\", \"CA certificate in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.StringVar(&migrationContext.TLSCertificate, \"ssl-cert\", \"\", \"Certificate in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.StringVar(&migrationContext.TLSKey, \"ssl-key\", \"\", \"Key in PEM format for TLS connections to MySQL hosts. Requires --ssl\")\n\tflag.BoolVar(&migrationContext.TLSAllowInsecure, \"ssl-allow-insecure\", false, \"Skips verification of MySQL hosts' certificate chain and host name. Requires --ssl\")\n\n\tflag.StringVar(&migrationContext.DatabaseName, \"database\", \"\", \"database name (mandatory)\")\n\tflag.StringVar(&migrationContext.OriginalTableName, \"table\", \"\", \"table name (mandatory)\")\n\tflag.StringVar(&migrationContext.AlterStatement, \"alter\", \"\", \"alter statement (mandatory)\")\n\tflag.BoolVar(&migrationContext.CountTableRows, \"exact-rowcount\", false, \"actually count table rows as opposed to estimate them (results in more accurate progress estimation)\")\n\tflag.BoolVar(&migrationContext.ConcurrentCountTableRows, \"concurrent-rowcount\", true, \"(with --exact-rowcount), when true (default): count rows after row-copy begins, concurrently, and adjust row estimate later on; when false: first count rows, then start row copy\")\n\tflag.BoolVar(&migrationContext.AllowedRunningOnMaster, \"allow-on-master\", false, \"allow this migration to run directly on master. Preferably it would run on a replica\")\n\tflag.BoolVar(&migrationContext.AllowedMasterMaster, \"allow-master-master\", false, \"explicitly allow running in a master-master setup\")\n\tflag.BoolVar(&migrationContext.NullableUniqueKeyAllowed, \"allow-nullable-unique-key\", false, \"allow gh-ost to migrate based on a unique key with nullable columns. As long as no NULL values exist, this should be OK. If NULL values exist in chosen key, data may be corrupted. Use at your own risk!\")\n\tflag.BoolVar(&migrationContext.ApproveRenamedColumns, \"approve-renamed-columns\", false, \"in case your `ALTER` statement renames columns, gh-ost will note that and offer its interpretation of the rename. By default gh-ost does not proceed to execute. This flag approves that gh-ost's interpretation is correct\")\n\tflag.BoolVar(&migrationContext.SkipRenamedColumns, \"skip-renamed-columns\", false, \"in case your `ALTER` statement renames columns, gh-ost will note that and offer its interpretation of the rename. By default gh-ost does not proceed to execute. This flag tells gh-ost to skip the renamed columns, i.e. to treat what gh-ost thinks are renamed columns as unrelated columns. NOTE: you may lose column data\")\n\tflag.BoolVar(&migrationContext.IsTungsten, \"tungsten\", false, \"explicitly let gh-ost know that you are running on a tungsten-replication based topology (you are likely to also provide --assume-master-host)\")\n\tflag.BoolVar(&migrationContext.DiscardForeignKeys, \"discard-foreign-keys\", false, \"DANGER! This flag will migrate a table that has foreign keys and will NOT create foreign keys on the ghost table, thus your altered table will have NO foreign keys. This is useful for intentional dropping of foreign keys\")\n\tflag.BoolVar(&migrationContext.SkipForeignKeyChecks, \"skip-foreign-key-checks\", false, \"set to 'true' when you know for certain there are no foreign keys on your table, and wish to skip the time it takes for gh-ost to verify that\")\n\tflag.BoolVar(&migrationContext.SkipStrictMode, \"skip-strict-mode\", false, \"explicitly tell gh-ost binlog applier not to enforce strict sql mode\")\n\tflag.BoolVar(&migrationContext.AliyunRDS, \"aliyun-rds\", false, \"set to 'true' when you execute on Aliyun RDS.\")\n\tflag.BoolVar(&migrationContext.GoogleCloudPlatform, \"gcp\", false, \"set to 'true' when you execute on a 1st generation Google Cloud Platform (GCP).\")\n\tflag.BoolVar(&migrationContext.AzureMySQL, \"azure\", false, \"set to 'true' when you execute on Azure Database on MySQL.\")\n\n\texecuteFlag := flag.Bool(\"execute\", false, \"actually execute the alter & migrate the table. Default is noop: do some tests and exit\")\n\tflag.BoolVar(&migrationContext.TestOnReplica, \"test-on-replica\", false, \"Have the migration run on a replica, not on the master. At the end of migration replication is stopped, and tables are swapped and immediately swap-revert. Replication remains stopped and you can compare the two tables for building trust\")\n\tflag.BoolVar(&migrationContext.TestOnReplicaSkipReplicaStop, \"test-on-replica-skip-replica-stop\", false, \"When --test-on-replica is enabled, do not issue commands stop replication (requires --test-on-replica)\")\n\tflag.BoolVar(&migrationContext.MigrateOnReplica, \"migrate-on-replica\", false, \"Have the migration run on a replica, not on the master. This will do the full migration on the replica including cut-over (as opposed to --test-on-replica)\")\n\n\tflag.BoolVar(&migrationContext.OkToDropTable, \"ok-to-drop-table\", false, \"Shall the tool drop the old table at end of operation. DROPping tables can be a long locking operation, which is why I'm not doing it by default. I'm an online tool, yes?\")\n\tflag.BoolVar(&migrationContext.InitiallyDropOldTable, \"initially-drop-old-table\", false, \"Drop a possibly existing OLD table (remains from a previous run?) before beginning operation. Default is to panic and abort if such table exists\")\n\tflag.BoolVar(&migrationContext.InitiallyDropGhostTable, \"initially-drop-ghost-table\", false, \"Drop a possibly existing Ghost table (remains from a previous run?) before beginning operation. Default is to panic and abort if such table exists\")\n\tflag.BoolVar(&migrationContext.TimestampOldTable, \"timestamp-old-table\", false, \"Use a timestamp in old table name. This makes old table names unique and non conflicting cross migrations\")\n\tcutOver := flag.String(\"cut-over\", \"atomic\", \"choose cut-over type (default|atomic, two-step)\")\n\tflag.BoolVar(&migrationContext.ForceNamedCutOverCommand, \"force-named-cut-over\", false, \"When true, the 'unpostpone|cut-over' interactive command must name the migrated table\")\n\tflag.BoolVar(&migrationContext.ForceNamedPanicCommand, \"force-named-panic\", false, \"When true, the 'panic' interactive command must name the migrated table\")\n\n\tflag.BoolVar(&migrationContext.SwitchToRowBinlogFormat, \"switch-to-rbr\", false, \"let this tool automatically switch binary log format to 'ROW' on the replica, if needed. The format will NOT be switched back. I'm too scared to do that, and wish to protect you if you happen to execute another migration while this one is running\")\n\tflag.BoolVar(&migrationContext.AssumeRBR, \"assume-rbr\", false, \"set to 'true' when you know for certain your server uses 'ROW' binlog_format. gh-ost is unable to tell, event after reading binlog_format, whether the replication process does indeed use 'ROW', and restarts replication to be certain RBR setting is applied. Such operation requires SUPER privileges which you might not have. Setting this flag avoids restarting replication and you can proceed to use gh-ost without SUPER privileges\")\n\tflag.BoolVar(&migrationContext.CutOverExponentialBackoff, \"cut-over-exponential-backoff\", false, \"Wait exponentially longer intervals between failed cut-over attempts. Wait intervals obey a maximum configurable with 'exponential-backoff-max-interval').\")\n\texponentialBackoffMaxInterval := flag.Int64(\"exponential-backoff-max-interval\", 64, \"Maximum number of seconds to wait between attempts when performing various operations with exponential backoff.\")\n\tchunkSize := flag.Int64(\"chunk-size\", 1000, \"amount of rows to handle in each iteration (allowed range: 100-100,000)\")\n\tdmlBatchSize := flag.Int64(\"dml-batch-size\", 10, \"batch size for DML events to apply in a single transaction (range 1-100)\")\n\tdefaultRetries := flag.Int64(\"default-retries\", 60, \"Default number of retries for various operations before panicking\")\n\tcutOverLockTimeoutSeconds := flag.Int64(\"cut-over-lock-timeout-seconds\", 3, \"Max number of seconds to hold locks on tables while attempting to cut-over (retry attempted when lock exceeds timeout)\")\n\tniceRatio := flag.Float64(\"nice-ratio\", 0, \"force being 'nice', imply sleep time per chunk time; range: [0.0..100.0]. Example values: 0 is aggressive. 1: for every 1ms spent copying rows, sleep additional 1ms (effectively doubling runtime); 0.7: for every 10ms spend in a rowcopy chunk, spend 7ms sleeping immediately after\")\n\n\tmaxLagMillis := flag.Int64(\"max-lag-millis\", 1500, \"replication lag at which to throttle operation\")\n\treplicationLagQuery := flag.String(\"replication-lag-query\", \"\", \"Deprecated. gh-ost uses an internal, subsecond resolution query\")\n\tthrottleControlReplicas := flag.String(\"throttle-control-replicas\", \"\", \"List of replicas on which to check for lag; comma delimited. Example: myhost1.com:3306,myhost2.com,myhost3.com:3307\")\n\tthrottleQuery := flag.String(\"throttle-query\", \"\", \"when given, issued (every second) to check if operation should throttle. Expecting to return zero for no-throttle, >0 for throttle. Query is issued on the migrated server. Make sure this query is lightweight\")\n\tthrottleHTTP := flag.String(\"throttle-http\", \"\", \"when given, gh-ost checks given URL via HEAD request; any response code other than 200 (OK) causes throttling; make sure it has low latency response\")\n\tignoreHTTPErrors := flag.Bool(\"ignore-http-errors\", false, \"ignore HTTP connection errors during throttle check\")\n\theartbeatIntervalMillis := flag.Int64(\"heartbeat-interval-millis\", 100, \"how frequently would gh-ost inject a heartbeat value\")\n\tflag.StringVar(&migrationContext.ThrottleFlagFile, \"throttle-flag-file\", \"\", \"operation pauses when this file exists; hint: use a file that is specific to the table being altered\")\n\tflag.StringVar(&migrationContext.ThrottleAdditionalFlagFile, \"throttle-additional-flag-file\", \"/tmp/gh-ost.throttle\", \"operation pauses when this file exists; hint: keep default, use for throttling multiple gh-ost operations\")\n\tflag.StringVar(&migrationContext.PostponeCutOverFlagFile, \"postpone-cut-over-flag-file\", \"\", \"while this file exists, migration will postpone the final stage of swapping tables, and will keep on syncing the ghost table. Cut-over/swapping would be ready to perform the moment the file is deleted.\")\n\tflag.StringVar(&migrationContext.PanicFlagFile, \"panic-flag-file\", \"\", \"when this file is created, gh-ost will immediately terminate, without cleanup\")\n\n\tflag.BoolVar(&migrationContext.DropServeSocket, \"initially-drop-socket-file\", false, \"Should gh-ost forcibly delete an existing socket file. Be careful: this might drop the socket file of a running migration!\")\n\tflag.StringVar(&migrationContext.ServeSocketFile, \"serve-socket-file\", \"\", \"Unix socket file to serve on. Default: auto-determined and advertised upon startup\")\n\tflag.Int64Var(&migrationContext.ServeTCPPort, \"serve-tcp-port\", 0, \"TCP port to serve on. Default: disabled\")\n\n\tflag.StringVar(&migrationContext.HooksPath, \"hooks-path\", \"\", \"directory where hook files are found (default: empty, ie. hooks disabled). Hook files found on this path, and conforming to hook naming conventions will be executed\")\n\tflag.StringVar(&migrationContext.HooksHintMessage, \"hooks-hint\", \"\", \"arbitrary message to be injected to hooks via GH_OST_HOOKS_HINT, for your convenience\")\n\tflag.StringVar(&migrationContext.HooksHintOwner, \"hooks-hint-owner\", \"\", \"arbitrary name of owner to be injected to hooks via GH_OST_HOOKS_HINT_OWNER, for your convenience\")\n\tflag.StringVar(&migrationContext.HooksHintToken, \"hooks-hint-token\", \"\", \"arbitrary token to be injected to hooks via GH_OST_HOOKS_HINT_TOKEN, for your convenience\")\n\n\tflag.UintVar(&migrationContext.ReplicaServerId, \"replica-server-id\", 99999, \"server id used by gh-ost process. Default: 99999\")\n\n\tmaxLoad := flag.String(\"max-load\", \"\", \"Comma delimited status-name=threshold. e.g: 'Threads_running=100,Threads_connected=500'. When status exceeds threshold, app throttles writes\")\n\tcriticalLoad := flag.String(\"critical-load\", \"\", \"Comma delimited status-name=threshold, same format as --max-load. When status exceeds threshold, app panics and quits\")\n\tflag.Int64Var(&migrationContext.CriticalLoadIntervalMilliseconds, \"critical-load-interval-millis\", 0, \"When 0, migration immediately bails out upon meeting critical-load. When non-zero, a second check is done after given interval, and migration only bails out if 2nd check still meets critical load\")\n\tflag.Int64Var(&migrationContext.CriticalLoadHibernateSeconds, \"critical-load-hibernate-seconds\", 0, \"When non-zero, critical-load does not panic and bail out; instead, gh-ost goes into hibernation for the specified duration. It will not read/write anything from/to any server\")\n\tquiet := flag.Bool(\"quiet\", false, \"quiet\")\n\tverbose := flag.Bool(\"verbose\", false, \"verbose\")\n\tdebug := flag.Bool(\"debug\", false, \"debug mode (very verbose)\")\n\tstack := flag.Bool(\"stack\", false, \"add stack trace upon error\")\n\thelp := flag.Bool(\"help\", false, \"Display usage\")\n\tversion := flag.Bool(\"version\", false, \"Print version & exit\")\n\tcheckFlag := flag.Bool(\"check-flag\", false, \"Check if another flag exists/supported. This allows for cross-version scripting. Exits with 0 when all additional provided flags exist, nonzero otherwise. You must provide (dummy) values for flags that require a value. Example: gh-ost --check-flag --cut-over-lock-timeout-seconds --nice-ratio 0\")\n\tflag.StringVar(&migrationContext.ForceTmpTableName, \"force-table-names\", \"\", \"table name prefix to be used on the temporary tables\")\n\tflag.CommandLine.SetOutput(os.Stdout)\n\n\tflag.Parse()\n\n\tif *checkFlag {\n\t\treturn\n\t}\n\tif *help {\n\t\tfmt.Fprintf(os.Stdout, \"Usage of gh-ost:\\n\")\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\tif *version {\n\t\tappVersion := AppVersion\n\t\tif appVersion == \"\" {\n\t\t\tappVersion = \"unversioned\"\n\t\t}\n\t\tfmt.Println(appVersion)\n\t\treturn\n\t}\n\n\tmigrationContext.Log.SetLevel(log.ERROR)\n\tif *verbose {\n\t\tmigrationContext.Log.SetLevel(log.INFO)\n\t}\n\tif *debug {\n\t\tmigrationContext.Log.SetLevel(log.DEBUG)\n\t}\n\tif *stack {\n\t\tmigrationContext.Log.SetPrintStackTrace(*stack)\n\t}\n\tif *quiet {\n\t\t// Override!!\n\t\tmigrationContext.Log.SetLevel(log.ERROR)\n\t}\n\n\tif migrationContext.AlterStatement == \"\" {\n\t\tlog.Fatalf(\"--alter must be provided and statement must not be empty\")\n\t}\n\tparser := sql.NewParserFromAlterStatement(migrationContext.AlterStatement)\n\tmigrationContext.AlterStatementOptions = parser.GetAlterStatementOptions()\n\n\tif migrationContext.DatabaseName == \"\" {\n\t\tif parser.HasExplicitSchema() {\n\t\t\tmigrationContext.DatabaseName = parser.GetExplicitSchema()\n\t\t} else {\n\t\t\tlog.Fatalf(\"--database must be provided and database name must not be empty, or --alter must specify database name\")\n\t\t}\n\t}\n\n\tif err := flag.Set(\"database\", url.QueryEscape(migrationContext.DatabaseName)); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\n\tif migrationContext.OriginalTableName == \"\" {\n\t\tif parser.HasExplicitTable() {\n\t\t\tmigrationContext.OriginalTableName = parser.GetExplicitTable()\n\t\t} else {\n\t\t\tlog.Fatalf(\"--table must be provided and table name must not be empty, or --alter must specify table name\")\n\t\t}\n\t}\n\tmigrationContext.Noop = !(*executeFlag)\n\tif migrationContext.AllowedRunningOnMaster && migrationContext.TestOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--allow-on-master and --test-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.AllowedRunningOnMaster && migrationContext.MigrateOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--allow-on-master and --migrate-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.MigrateOnReplica && migrationContext.TestOnReplica {\n\t\tmigrationContext.Log.Fatalf(\"--migrate-on-replica and --test-on-replica are mutually exclusive\")\n\t}\n\tif migrationContext.SwitchToRowBinlogFormat && migrationContext.AssumeRBR {\n\t\tmigrationContext.Log.Fatalf(\"--switch-to-rbr and --assume-rbr are mutually exclusive\")\n\t}\n\tif migrationContext.TestOnReplicaSkipReplicaStop {\n\t\tif !migrationContext.TestOnReplica {\n\t\t\tmigrationContext.Log.Fatalf(\"--test-on-replica-skip-replica-stop requires --test-on-replica to be enabled\")\n\t\t}\n\t\tmigrationContext.Log.Warning(\"--test-on-replica-skip-replica-stop enabled. We will not stop replication before cut-over. Ensure you have a plugin that does this.\")\n\t}\n\tif migrationContext.CliMasterUser != \"\" && migrationContext.AssumeMasterHostname == \"\" {\n\t\tmigrationContext.Log.Fatalf(\"--master-user requires --assume-master-host\")\n\t}\n\tif migrationContext.CliMasterPassword != \"\" && migrationContext.AssumeMasterHostname == \"\" {\n\t\tmigrationContext.Log.Fatalf(\"--master-password requires --assume-master-host\")\n\t}\n\tif migrationContext.TLSCACertificate != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-ca requires --ssl\")\n\t}\n\tif migrationContext.TLSCertificate != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-cert requires --ssl\")\n\t}\n\tif migrationContext.TLSKey != \"\" && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-key requires --ssl\")\n\t}\n\tif migrationContext.TLSAllowInsecure && !migrationContext.UseTLS {\n\t\tmigrationContext.Log.Fatalf(\"--ssl-allow-insecure requires --ssl\")\n\t}\n\tif *replicationLagQuery != \"\" {\n\t\tmigrationContext.Log.Warningf(\"--replication-lag-query is deprecated\")\n\t}\n\n\tswitch *cutOver {\n\tcase \"atomic\", \"default\", \"\":\n\t\tmigrationContext.CutOverType = base.CutOverAtomic\n\tcase \"two-step\":\n\t\tmigrationContext.CutOverType = base.CutOverTwoStep\n\tdefault:\n\t\tmigrationContext.Log.Fatalf(\"Unknown cut-over: %s\", *cutOver)\n\t}\n\tif err := migrationContext.ReadConfigFile(); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadThrottleControlReplicaKeys(*throttleControlReplicas); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadMaxLoad(*maxLoad); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.ReadCriticalLoad(*criticalLoad); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif migrationContext.ServeSocketFile == \"\" {\n\t\tmigrationContext.ServeSocketFile = fmt.Sprintf(\"/tmp/gh-ost.%s.%s.sock\", migrationContext.DatabaseName, migrationContext.OriginalTableName)\n\t}\n\tif *askPass {\n\t\tfmt.Println(\"Password:\")\n\t\tbytePassword, err := terminal.ReadPassword(int(syscall.Stdin))\n\t\tif err != nil {\n\t\t\tmigrationContext.Log.Fatale(err)\n\t\t}\n\t\tmigrationContext.CliPassword = string(bytePassword)\n\t}\n\tmigrationContext.SetHeartbeatIntervalMilliseconds(*heartbeatIntervalMillis)\n\tmigrationContext.SetNiceRatio(*niceRatio)\n\tmigrationContext.SetChunkSize(*chunkSize)\n\tmigrationContext.SetDMLBatchSize(*dmlBatchSize)\n\tmigrationContext.SetMaxLagMillisecondsThrottleThreshold(*maxLagMillis)\n\tmigrationContext.SetThrottleQuery(*throttleQuery)\n\tmigrationContext.SetThrottleHTTP(*throttleHTTP)\n\tmigrationContext.SetIgnoreHTTPErrors(*ignoreHTTPErrors)\n\tmigrationContext.SetDefaultNumRetries(*defaultRetries)\n\tmigrationContext.ApplyCredentials()\n\tif err := migrationContext.SetupTLS(); err != nil {\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tif err := migrationContext.SetCutOverLockTimeoutSeconds(*cutOverLockTimeoutSeconds); err != nil {\n\t\tmigrationContext.Log.Errore(err)\n\t}\n\tif err := migrationContext.SetExponentialBackoffMaxInterval(*exponentialBackoffMaxInterval); err != nil {\n\t\tmigrationContext.Log.Errore(err)\n\t}\n\n\tlog.Infof(\"starting gh-ost %+v\", AppVersion)\n\tacceptSignals(migrationContext)\n\n\tmigrator := logic.NewMigrator(migrationContext)\n\terr := migrator.Migrate()\n\tif err != nil {\n\t\tmigrator.ExecOnFailureHook()\n\t\tmigrationContext.Log.Fatale(err)\n\t}\n\tfmt.Fprintf(os.Stdout, \"# Done\\n\")\n}\n"], "filenames": ["build.sh", "go/cmd/gh-ost/main.go"], "buggy_code_start_loc": [21, 10], "buggy_code_end_loc": [22, 190], "fixing_code_start_loc": [21, 11], "fixing_code_end_loc": [22, 197], "type": "CWE-20", "message": "gh-ost is a triggerless online schema migration solution for MySQL. Versions prior to 1.1.3 are subject to an arbitrary file read vulnerability. The attacker must have access to the target host or trick an administrator into executing a malicious gh-ost command on a host running gh-ost, plus network access from host running gh-ost to the attack's malicious MySQL server. The `-database` parameter does not properly sanitize user input which can lead to arbitrary file reads.", "other": {"cve": {"id": "CVE-2022-21687", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-01T12:15:08.200", "lastModified": "2022-02-04T17:09:05.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gh-ost is a triggerless online schema migration solution for MySQL. Versions prior to 1.1.3 are subject to an arbitrary file read vulnerability. The attacker must have access to the target host or trick an administrator into executing a malicious gh-ost command on a host running gh-ost, plus network access from host running gh-ost to the attack's malicious MySQL server. The `-database` parameter does not properly sanitize user input which can lead to arbitrary file reads."}, {"lang": "es", "value": "gh-ost es una soluci\u00f3n de migraci\u00f3n de esquemas en l\u00ednea sin disparador para MySQL. Las versiones anteriores a 1.1.3 est\u00e1n sujetas a una vulnerabilidad de lectura arbitraria de archivos. El atacante debe tener acceso al host de destino o enga\u00f1ar a un administrador para que ejecute un comando gh-ost malicioso en un host que ejecute gh-ost, adem\u00e1s de tener acceso a la red desde el host que ejecuta gh-ost al servidor MySQL malicioso del ataque. El par\u00e1metro \"-database\" no sanea apropiadamente la entrada del usuario, lo que puede conllevar a lecturas arbitrarias de archivos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:github:gh-ost:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.3", "matchCriteriaId": "3F0C9B81-DCC1-460B-9A59-613BD49953AA"}]}]}], "references": [{"url": "https://github.com/github/gh-ost/commit/a91ab042de013cfd8fbb633763438932d9080d8f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/github/gh-ost/security/advisories/GHSA-rrp4-2xx3-mv29", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/github/gh-ost/commit/a91ab042de013cfd8fbb633763438932d9080d8f"}}