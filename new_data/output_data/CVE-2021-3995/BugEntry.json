{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2010-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: context-umount\n * @title: Umount context\n * @short_description: high-level API to umount operation.\n */\n\n#include <sys/wait.h>\n#include <sys/mount.h>\n\n#include \"pathnames.h\"\n#include \"loopdev.h\"\n#include \"strutils.h\"\n#include \"mountP.h\"\n\n/*\n * umount2 flags\n */\n#ifndef MNT_FORCE\n# define MNT_FORCE        0x00000001\t/* Attempt to forcibly umount */\n#endif\n\n#ifndef MNT_DETACH\n# define MNT_DETACH       0x00000002\t/* Just detach from the tree */\n#endif\n\n#ifndef UMOUNT_NOFOLLOW\n# define UMOUNT_NOFOLLOW  0x00000008\t/* Don't follow symlink on umount */\n#endif\n\n#ifndef UMOUNT_UNUSED\n# define UMOUNT_UNUSED    0x80000000\t/* Flag guaranteed to be unused */\n#endif\n\n/* search in mountinfo/mtab */\nstatic int __mtab_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t    const char *tgt,\n\t\t\t    struct libmnt_fs **pfs)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\tstruct libmnt_table *mtab = NULL;\n\tstruct libmnt_fs *fs;\n\tchar *loopdev = NULL;\n\n\tassert(cxt);\n\tassert(tgt);\n\tassert(pfs);\n\n\t*pfs = NULL;\n\tDBG(CXT, ul_debugobj(cxt, \" search %s in mountinfo\", tgt));\n\n\t/*\n\t * The mount table may be huge, and on systems with utab we have to\n\t * merge userspace mount options into /proc/self/mountinfo. This all is\n\t * expensive. The tab filter can be used to filter out entries, then a mount\n\t * table and utab are very tiny files.\n\t *\n\t * The filter uses mnt_fs_streq_{target,srcpath} function where all\n\t * paths should be absolute and canonicalized. This is done within\n\t * mnt_context_get_mtab_for_target() where LABEL, UUID or symlinks are\n\t * canonicalized. If --no-canonicalize is enabled than the target path\n\t * is expected already canonical.\n\t *\n\t * Anyway it's better to read huge mount table than canonicalize target\n\t * paths. It means we use the filter only if --no-canonicalize enabled.\n\t *\n\t * It also means that we have to read mount table from kernel\n\t * (non-writable mtab).\n\t */\n\tif (mnt_context_is_nocanonicalize(cxt) &&\n\t    !mnt_context_mtab_writable(cxt) && *tgt == '/')\n\t\trc = mnt_context_get_mtab_for_target(cxt, &mtab, tgt);\n\telse\n\t\trc = mnt_context_get_mtab(cxt, &mtab);\n\n\tif (rc) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: failed to read mtab\"));\n\t\treturn rc;\n\t}\n\n\tif (mnt_table_get_nents(mtab) == 0) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: mtab empty\"));\n\t\treturn 1;\n\t}\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\ntry_loopdev:\n\tfs = mnt_table_find_target(mtab, tgt, MNT_ITER_BACKWARD);\n\tif (!fs && mnt_context_is_swapmatch(cxt)) {\n\t\t/*\n\t\t * Maybe the option is source rather than target (sometimes\n\t\t * people use e.g. \"umount /dev/sda1\")\n\t\t */\n\t\tfs = mnt_table_find_source(mtab, tgt, MNT_ITER_BACKWARD);\n\n\t\tif (fs) {\n\t\t\tstruct libmnt_fs *fs1 = mnt_table_find_target(mtab,\n\t\t\t\t\t\t\tmnt_fs_get_target(fs),\n\t\t\t\t\t\t\tMNT_ITER_BACKWARD);\n\t\t\tif (!fs1) {\n\t\t\t\tDBG(CXT, ul_debugobj(cxt, \"mtab is broken?!?!\"));\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (fs != fs1) {\n\t\t\t\t/* Something was stacked over `file' on the\n\t\t\t\t * same mount point. */\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\t\"umount: %s: %s is mounted \"\n\t\t\t\t\t\t\"over it on the same point\",\n\t\t\t\t\t\ttgt, mnt_fs_get_source(fs1)));\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!fs && !loopdev && mnt_context_is_swapmatch(cxt)) {\n\t\t/*\n\t\t * Maybe the option is /path/file.img, try to convert to /dev/loopN\n\t\t */\n\t\tstruct stat st;\n\n\t\tif (mnt_stat_mountpoint(tgt, &st) == 0 && S_ISREG(st.st_mode)) {\n\t\t\tint count;\n\t\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\t\tconst char *bf = cache ? mnt_resolve_path(tgt, cache) : tgt;\n\n\t\t\tcount = loopdev_count_by_backing_file(bf, &loopdev);\n\t\t\tif (count == 1) {\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount: %s --> %s (retry)\", tgt, loopdev));\n\t\t\t\ttgt = loopdev;\n\t\t\t\tgoto try_loopdev;\n\n\t\t\t} else if (count > 1)\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount: warning: %s is associated \"\n\t\t\t\t\t\"with more than one loopdev\", tgt));\n\t\t}\n\t}\n\n\t*pfs = fs;\n\tfree(loopdev);\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount fs: %s\", fs ? mnt_fs_get_target(fs) :\n\t\t\t\t\t\t\t\"<not found>\"));\n\treturn fs ? 0 : 1;\nerr:\n\tfree(loopdev);\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\treturn rc;\n}\n\n/**\n * mnt_context_find_umount_fs:\n * @cxt: mount context\n * @tgt: mountpoint, device, ...\n * @pfs: returns point to filesystem\n *\n * Returns: 0 on success, <0 on error, 1 if target filesystem not found\n */\nint mnt_context_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t       const char *tgt,\n\t\t\t       struct libmnt_fs **pfs)\n{\n\tif (pfs)\n\t\t*pfs = NULL;\n\n\tif (!cxt || !tgt || !pfs)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: lookup FS for '%s'\", tgt));\n\n\tif (!*tgt)\n\t\treturn 1; /* empty string is not an error */\n\n\t/* In future this function should be extended to support for example\n\t * fsinfo() (or another cheap way kernel will support), for now the\n\t * default is expensive mountinfo/mtab.\n\t */\n\treturn __mtab_find_umount_fs(cxt, tgt, pfs);\n}\n\n/* Check if there is something important in the utab file. The parsed utab is\n * stored in context->utab and deallocated by mnt_free_context().\n *\n * This function exists to avoid (if possible) /proc/self/mountinfo usage, so\n * don't use things like mnt_resolve_target(), mnt_context_get_mtab() etc here.\n * See lookup_umount_fs() for more details.\n */\nstatic int has_utab_entry(struct libmnt_context *cxt, const char *target)\n{\n\tstruct libmnt_cache *cache = NULL;\n\tstruct libmnt_fs *fs;\n\tstruct libmnt_iter itr;\n\tchar *cn = NULL;\n\tint rc = 0;\n\n\tassert(cxt);\n\n\tif (!cxt->utab) {\n\t\tconst char *path = mnt_get_utab_path();\n\n\t\tif (!path || is_file_empty(path))\n\t\t\treturn 0;\n\t\tcxt->utab = mnt_new_table();\n\t\tif (!cxt->utab)\n\t\t\treturn 0;\n\t\tcxt->utab->fmt = MNT_FMT_UTAB;\n\t\tif (mnt_table_parse_file(cxt->utab, path))\n\t\t\treturn 0;\n\t}\n\n\t/* paths in utab are canonicalized */\n\tcache = mnt_context_get_cache(cxt);\n\tcn = mnt_resolve_path(target, cache);\n\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\twhile (mnt_table_next_fs(cxt->utab, &itr, &fs) == 0) {\n\t\tif (mnt_fs_streq_target(fs, cn)) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cache)\n\t\tfree(cn);\n\treturn rc;\n}\n\n/* returns: 1 not found; <0 on error; 1 success */\nstatic int lookup_umount_fs_by_statfs(struct libmnt_context *cxt, const char *tgt)\n{\n\tstruct stat st;\n\tconst char *type;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \" lookup by statfs\"));\n\n\t/*\n\t * Let's try to avoid mountinfo usage at all to minimize performance\n\t * degradation. Don't forget that kernel has to compose *whole*\n\t * mountinfo about all mountpoints although we look for only one entry.\n\t *\n\t * All we need is fstype and to check if there is no userspace mount\n\t * options for the target (e.g. helper=udisks to call /sbin/umount.udisks).\n\t *\n\t * So, let's use statfs() if possible (it's bad idea for --lazy/--force\n\t * umounts as target is probably unreachable NFS, also for --detach-loop\n\t * as this additionally needs to know the name of the loop device).\n\t */\n\tif (mnt_context_is_restricted(cxt)\n\t    || *tgt != '/'\n\t    || (cxt->flags & MNT_FL_HELPER)\n\t    || mnt_context_mtab_writable(cxt)\n\t    || mnt_context_is_force(cxt)\n\t    || mnt_context_is_lazy(cxt)\n\t    || mnt_context_is_nocanonicalize(cxt)\n\t    || mnt_context_is_loopdel(cxt)\n\t    || mnt_stat_mountpoint(tgt, &st) != 0 || !S_ISDIR(st.st_mode)\n\t    || has_utab_entry(cxt, tgt))\n\t\treturn 1; /* not found */\n\n\ttype = mnt_fs_get_fstype(cxt->fs);\n\tif (!type) {\n\t\tstruct statfs vfs;\n\t\tint fd;\n\n\t\tDBG(CXT, ul_debugobj(cxt, \"  trying fstatfs()\"));\n\n\t\t/* O_PATH avoids triggering automount points. */\n\t\tfd = open(tgt, O_PATH);\n\t\tif (fd >= 0) {\n\t\t\tif (fstatfs(fd, &vfs) == 0)\n\t\t\t\ttype = mnt_statfs_get_fstype(&vfs);\n\t\t\tclose(fd);\n\t\t}\n\t\tif (type) {\n\t\t\tint rc = mnt_fs_set_fstype(cxt->fs, type);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\tif (type) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"  umount: disabling mtab\"));\n\t\tmnt_context_disable_mtab(cxt, TRUE);\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"  mountinfo unnecessary [type=%s]\", type));\n\t\treturn 0;\n\t}\n\n\treturn 1; /* not found */\n}\n\n/* returns: 1 not found; <0 on error; 1 success */\nstatic int lookup_umount_fs_by_mountinfo(struct libmnt_context *cxt, const char *tgt)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tint rc;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \" lookup by mountinfo\"));\n\n\t/* search */\n\trc = __mtab_find_umount_fs(cxt, tgt, &fs);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* apply result */\n\tif (fs != cxt->fs) {\n\t\tmnt_fs_set_source(cxt->fs, NULL);\n\t\tmnt_fs_set_target(cxt->fs, NULL);\n\n\t\tif (!mnt_copy_fs(cxt->fs, fs)) {\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"  failed to copy FS\"));\n\t\t\treturn -errno;\n\t\t}\n\t\tDBG(CXT, ul_debugobj(cxt, \"  mtab applied\"));\n\t}\n\n\tcxt->flags |= MNT_FL_TAB_APPLIED;\n\treturn 0;\n}\n\n/* This finction search for FS according to cxt->fs->target,\n * apply result to cxt->fs and it's umount replacement to\n * mnt_context_apply_fstab(), use mnt_context_tab_applied()\n * to check result.\n *\n * The goal is to minimize situations when we need to parse\n * /proc/self/mountinfo.\n */\nstatic int lookup_umount_fs(struct libmnt_context *cxt)\n{\n\tconst char *tgt;\n\tint rc = 0;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: lookup FS\"));\n\n\ttgt = mnt_fs_get_target(cxt->fs);\n\tif (!tgt) {\n\t\tDBG(CXT, ul_debugobj(cxt, \" undefined target\"));\n\t\treturn -EINVAL;\n\t}\n\n\t/* try get fs type by statfs() */\n\trc = lookup_umount_fs_by_statfs(cxt, tgt);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\t/* get complete fs from fs entry from mountinfo */\n\trc = lookup_umount_fs_by_mountinfo(cxt, tgt);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tDBG(CXT, ul_debugobj(cxt, \" cannot find '%s'\", tgt));\n\treturn 0;\t/* this is correct! */\n}\n\n/* check if @devname is loopdev and if the device is associated\n * with a source from @fstab_fs\n */\nstatic int is_associated_fs(const char *devname, struct libmnt_fs *fs)\n{\n\tuintmax_t offset = 0;\n\tconst char *src, *optstr;\n\tchar *val;\n\tsize_t valsz;\n\tint flags = 0;\n\n\t/* check if it begins with /dev/loop */\n\tif (strncmp(devname, _PATH_DEV_LOOP, sizeof(_PATH_DEV_LOOP) - 1) != 0)\n\t\treturn 0;\n\n\tsrc = mnt_fs_get_srcpath(fs);\n\tif (!src)\n\t\treturn 0;\n\n\t/* check for the offset option in @fs */\n\toptstr = mnt_fs_get_user_options(fs);\n\n\tif (optstr &&\n\t    mnt_optstr_get_option(optstr, \"offset\", &val, &valsz) == 0) {\n\t\tflags |= LOOPDEV_FL_OFFSET;\n\n\t\tif (mnt_parse_offset(val, valsz, &offset) != 0)\n\t\t\treturn 0;\n\t}\n\n\treturn loopdev_is_used(devname, src, offset, 0, flags);\n}\n\nstatic int prepare_helper_from_options(struct libmnt_context *cxt,\n\t\t\t\t       const char *name)\n{\n\tchar *suffix = NULL;\n\tconst char *opts;\n\tsize_t valsz;\n\tint rc;\n\n\tif (mnt_context_is_nohelpers(cxt))\n\t\treturn 0;\n\n\topts = mnt_fs_get_user_options(cxt->fs);\n\tif (!opts)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(opts, name, &suffix, &valsz))\n\t\treturn 0;\n\n\tsuffix = strndup(suffix, valsz);\n\tif (!suffix)\n\t\treturn -ENOMEM;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: umount.%s %s requested\", suffix, name));\n\n\trc = mnt_context_prepare_helper(cxt, \"umount\", suffix);\n\tfree(suffix);\n\n\treturn rc;\n}\n\nstatic int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}\n\n/*\n * Note that cxt->fs contains relevant mtab entry!\n */\nstatic int evaluate_permissions(struct libmnt_context *cxt)\n{\n\tstruct libmnt_table *fstab;\n\tunsigned long u_flags = 0;\n\tconst char *tgt, *src, *optstr;\n\tint rc = 0, ok = 0;\n\tstruct libmnt_fs *fs;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\tif (!mnt_context_is_restricted(cxt))\n\t\t return 0;\t\t/* superuser mount */\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: evaluating permissions\"));\n\n\tif (!mnt_context_tab_applied(cxt)) {\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"cannot find %s in mtab and you are not root\",\n\t\t\t\tmnt_fs_get_target(cxt->fs)));\n\t\tgoto eperm;\n\t}\n\n\tif (cxt->user_mountflags & MNT_MS_UHELPER) {\n\t\t/* on uhelper= mount option based helper */\n\t\trc = prepare_helper_from_options(cxt, \"uhelper\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (cxt->helper)\n\t\t\treturn 0;\t/* we'll call /sbin/umount.<uhelper> */\n\t}\n\n\t/*\n\t * Check if this is a fuse mount for the current user,\n\t * if so then unmounting is allowed\n\t */\n\tif (is_fuse_usermount(cxt, &rc)) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"fuse user mount, umount is allowed\"));\n\t\treturn 0;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * User mounts have to be in /etc/fstab\n\t */\n\trc = mnt_context_get_fstab(cxt, &fstab);\n\tif (rc)\n\t\treturn rc;\n\n\ttgt = mnt_fs_get_target(cxt->fs);\n\tsrc = mnt_fs_get_source(cxt->fs);\n\n\tif (mnt_fs_get_bindsrc(cxt->fs)) {\n\t\tsrc = mnt_fs_get_bindsrc(cxt->fs);\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"umount: using bind source: %s\", src));\n\t}\n\n\t/* If fstab contains the two lines\n\t *\t/dev/sda1 /mnt/zip auto user,noauto  0 0\n\t *\t/dev/sda4 /mnt/zip auto user,noauto  0 0\n\t * then \"mount /dev/sda4\" followed by \"umount /mnt/zip\" used to fail.\n\t * So, we must not look for the file, but for the pair (dev,file) in fstab.\n\t  */\n\tfs = mnt_table_find_pair(fstab, src, tgt, MNT_ITER_FORWARD);\n\tif (!fs) {\n\t\t/*\n\t\t * It's possible that there is /path/file.img in fstab and\n\t\t * /dev/loop0 in mtab -- then we have to check the relation\n\t\t * between loopdev and the file.\n\t\t */\n\t\tfs = mnt_table_find_target(fstab, tgt, MNT_ITER_FORWARD);\n\t\tif (fs) {\n\t\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\t\tconst char *sp = mnt_fs_get_srcpath(cxt->fs);\t\t/* devname from mtab */\n\t\t\tconst char *dev = sp && cache ? mnt_resolve_path(sp, cache) : sp;\n\n\t\t\tif (!dev || !is_associated_fs(dev, fs))\n\t\t\t\tfs = NULL;\n\t\t}\n\t\tif (!fs) {\n\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount %s: mtab disagrees with fstab\",\n\t\t\t\t\ttgt));\n\t\t\tgoto eperm;\n\t\t}\n\t}\n\n\t/*\n\t * User mounting and unmounting is allowed only if fstab contains one\n\t * of the options `user', `users' or `owner' or `group'.\n\t *\n\t * The option `users' allows arbitrary users to mount and unmount -\n\t * this may be a security risk.\n\t *\n\t * The options `user', `owner' and `group' only allow unmounting by the\n\t * user that mounted (visible in mtab).\n\t */\n\toptstr = mnt_fs_get_user_options(fs);\t/* FSTAB mount options! */\n\tif (!optstr)\n\t\tgoto eperm;\n\n\tif (mnt_optstr_get_flags(optstr, &u_flags,\n\t\t\t\tmnt_get_builtin_optmap(MNT_USERSPACE_MAP)))\n\t\tgoto eperm;\n\n\tif (u_flags & MNT_MS_USERS) {\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"umount: promiscuous setting ('users') in fstab\"));\n\t\treturn 0;\n\t}\n\t/*\n\t * Check user=<username> setting from mtab if there is a user, owner or\n\t * group option in /etc/fstab\n\t */\n\tif (u_flags & (MNT_MS_USER | MNT_MS_OWNER | MNT_MS_GROUP)) {\n\n\t\tchar *curr_user;\n\t\tchar *mtab_user = NULL;\n\t\tsize_t sz;\n\t\tstruct libmnt_ns *ns_old;\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"umount: checking user=<username> from mtab\"));\n\n\t\tns_old = mnt_context_switch_origin_ns(cxt);\n\t\tif (!ns_old)\n\t\t\treturn -MNT_ERR_NAMESPACE;\n\n\t\tcurr_user = mnt_get_username(getuid());\n\n\t\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t\tfree(curr_user);\n\t\t\treturn -MNT_ERR_NAMESPACE;\n\t\t}\n\t\tif (!curr_user) {\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"umount %s: cannot \"\n\t\t\t\t\"convert %d to username\", tgt, getuid()));\n\t\t\tgoto eperm;\n\t\t}\n\n\t\t/* get options from mtab */\n\t\toptstr = mnt_fs_get_user_options(cxt->fs);\n\t\tif (optstr && !mnt_optstr_get_option(optstr,\n\t\t\t\t\t\"user\", &mtab_user, &sz) && sz)\n\t\t\tok = !strncmp(curr_user, mtab_user, sz);\n\n\t\tfree(curr_user);\n\t}\n\n\tif (ok) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount %s is allowed\", tgt));\n\t\treturn 0;\n\t}\neperm:\n\tDBG(CXT, ul_debugobj(cxt, \"umount is not allowed for you\"));\n\treturn -EPERM;\n}\n\nstatic int exec_helper(struct libmnt_context *cxt)\n{\n\tchar *namespace = NULL;\n\tstruct libmnt_ns *ns_tgt = mnt_context_get_target_ns(cxt);\n\tint rc;\n\tpid_t pid;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\tassert(cxt->helper_exec_status == 1);\n\n\tif (mnt_context_is_fake(cxt)) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"fake mode: does not execute helper\"));\n\t\tcxt->helper_exec_status = rc = 0;\n\t\treturn rc;\n\t}\n\n\tif (ns_tgt->fd != -1\n\t    && asprintf(&namespace, \"/proc/%i/fd/%i\",\n\t\t\tgetpid(), ns_tgt->fd) == -1) {\n\t\treturn -ENOMEM;\n\t}\n\n\tDBG_FLUSH;\n\n\tpid = fork();\n\tswitch (pid) {\n\tcase 0:\n\t{\n\t\tconst char *args[12], *type;\n\t\tint i = 0;\n\n\t\tif (drop_permissions() != 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (!mnt_context_switch_origin_ns(cxt))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\ttype = mnt_fs_get_fstype(cxt->fs);\n\n\t\targs[i++] = cxt->helper;\t\t\t/* 1 */\n\t\targs[i++] = mnt_fs_get_target(cxt->fs);\t\t/* 2 */\n\n\t\tif (mnt_context_is_nomtab(cxt))\n\t\t\targs[i++] = \"-n\";\t\t\t/* 3 */\n\t\tif (mnt_context_is_lazy(cxt))\n\t\t\targs[i++] = \"-l\";\t\t\t/* 4 */\n\t\tif (mnt_context_is_force(cxt))\n\t\t\targs[i++] = \"-f\";\t\t\t/* 5 */\n\t\tif (mnt_context_is_verbose(cxt))\n\t\t\targs[i++] = \"-v\";\t\t\t/* 6 */\n\t\tif (mnt_context_is_rdonly_umount(cxt))\n\t\t\targs[i++] = \"-r\";\t\t\t/* 7 */\n\t\tif (type\n\t\t    && strchr(type, '.')\n\t\t    && !endswith(cxt->helper, type)) {\n\t\t\targs[i++] = \"-t\";\t\t\t/* 8 */\n\t\t\targs[i++] = type;\t\t\t/* 9 */\n\t\t}\n\t\tif (namespace) {\n\t\t\targs[i++] = \"-N\";\t\t\t/* 10 */\n\t\t\targs[i++] = namespace;\t\t\t/* 11 */\n\t\t}\n\n\t\targs[i] = NULL;\t\t\t\t\t/* 12 */\n\t\tfor (i = 0; args[i]; i++)\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"argv[%d] = \\\"%s\\\"\",\n\t\t\t\t\t\t\ti, args[i]));\n\t\tDBG_FLUSH;\n\t\texecv(cxt->helper, (char * const *) args);\n\t\t_exit(EXIT_FAILURE);\n\t}\n\tdefault:\n\t{\n\t\tint st;\n\n\t\tif (waitpid(pid, &st, 0) == (pid_t) -1) {\n\t\t\tcxt->helper_status = -1;\n\t\t\trc = -errno;\n\t\t} else {\n\t\t\tcxt->helper_status = WIFEXITED(st) ? WEXITSTATUS(st) : -1;\n\t\t\tcxt->helper_exec_status = rc = 0;\n\t\t}\n\t\tDBG(CXT, ul_debugobj(cxt, \"%s executed [status=%d, rc=%d%s]\",\n\t\t\t\tcxt->helper,\n\t\t\t\tcxt->helper_status, rc,\n\t\t\t\trc ? \" waitpid failed\" : \"\"));\n\t\tbreak;\n\t}\n\n\tcase -1:\n\t\tcxt->helper_exec_status = rc = -errno;\n\t\tDBG(CXT, ul_debugobj(cxt, \"fork() failed\"));\n\t\tbreak;\n\t}\n\n\tfree(namespace);\n\treturn rc;\n}\n\n/*\n * mnt_context_helper_setopt() backend.\n *\n * This function applies umount.type command line option (for example parsed\n * by getopt() or getopt_long()) to @cxt. All unknown options are ignored and\n * then 1 is returned.\n *\n * Returns: negative number on error, 1 if @c is unknown option, 0 on success.\n */\nint mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg)\n{\n\tint rc = -EINVAL;\n\n\tassert(cxt);\n\tassert(cxt->action == MNT_ACT_UMOUNT);\n\n\tswitch(c) {\n\tcase 'n':\n\t\trc = mnt_context_disable_mtab(cxt, TRUE);\n\t\tbreak;\n\tcase 'l':\n\t\trc = mnt_context_enable_lazy(cxt, TRUE);\n\t\tbreak;\n\tcase 'f':\n\t\trc = mnt_context_enable_force(cxt, TRUE);\n\t\tbreak;\n\tcase 'v':\n\t\trc = mnt_context_enable_verbose(cxt, TRUE);\n\t\tbreak;\n\tcase 'r':\n\t\trc = mnt_context_enable_rdonly_umount(cxt, TRUE);\n\t\tbreak;\n\tcase 't':\n\t\tif (arg)\n\t\t\trc = mnt_context_set_fstype(cxt, arg);\n\t\tbreak;\n\tcase 'N':\n\t\tif (arg)\n\t\t\trc = mnt_context_set_target_ns(cxt, arg);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn rc;\n}\n\n/* Check whether the kernel supports the UMOUNT_NOFOLLOW flag */\nstatic int umount_nofollow_support(void)\n{\n\tint res = umount2(\"\", UMOUNT_UNUSED);\n\tif (res != -1 || errno != EINVAL)\n\t\treturn 0;\n\n\tres = umount2(\"\", UMOUNT_NOFOLLOW);\n\tif (res != -1 || errno != ENOENT)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int do_umount(struct libmnt_context *cxt)\n{\n\tint rc = 0, flags = 0;\n\tconst char *src, *target;\n\tchar *tgtbuf = NULL;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\tassert(cxt->syscall_status == 1);\n\n\tif (cxt->helper)\n\t\treturn exec_helper(cxt);\n\n\tsrc = mnt_fs_get_srcpath(cxt->fs);\n\ttarget = mnt_fs_get_target(cxt->fs);\n\n\tif (!target)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debugobj(cxt, \"do umount\"));\n\n\tif (mnt_context_is_restricted(cxt) && !mnt_context_is_fake(cxt)) {\n\t\t/*\n\t\t * extra paranoia for non-root users\n\t\t * -- chdir to the parent of the mountpoint and use NOFOLLOW\n\t\t *    flag to avoid races and symlink attacks.\n\t\t */\n\t\tif (umount_nofollow_support())\n\t\t\tflags |= UMOUNT_NOFOLLOW;\n\n\t\trc = mnt_chdir_to_parent(target, &tgtbuf);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\ttarget = tgtbuf;\n\t}\n\n\tif (mnt_context_is_lazy(cxt))\n\t\tflags |= MNT_DETACH;\n\n\tif (mnt_context_is_force(cxt))\n\t\tflags |= MNT_FORCE;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount(2) [target='%s', flags=0x%08x]%s\",\n\t\t\t\ttarget, flags,\n\t\t\t\tmnt_context_is_fake(cxt) ? \" (FAKE)\" : \"\"));\n\n\tif (mnt_context_is_fake(cxt))\n\t\trc = 0;\n\telse {\n\t\trc = flags ? umount2(target, flags) : umount(target);\n\t\tif (rc < 0)\n\t\t\tcxt->syscall_status = -errno;\n\t\tfree(tgtbuf);\n\t}\n\n\t/*\n\t * try remount read-only\n\t */\n\tif (rc < 0\n\t    && cxt->syscall_status == -EBUSY\n\t    && mnt_context_is_rdonly_umount(cxt)\n\t    && src) {\n\n\t\tmnt_context_set_mflags(cxt, (cxt->mountflags |\n\t\t\t\t\t     MS_REMOUNT | MS_RDONLY));\n\t\tmnt_context_enable_loopdel(cxt, FALSE);\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"umount(2) failed [errno=%d] -- trying to remount read-only\",\n\t\t\t-cxt->syscall_status));\n\n\t\trc = mount(src, mnt_fs_get_target(cxt->fs), NULL,\n\t\t\t    MS_REMOUNT | MS_RDONLY, NULL);\n\t\tif (rc < 0) {\n\t\t\tcxt->syscall_status = -errno;\n\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"read-only re-mount(2) failed [errno=%d]\",\n\t\t\t\t-cxt->syscall_status));\n\n\t\t\treturn -cxt->syscall_status;\n\t\t}\n\t\tcxt->syscall_status = 0;\n\t\tDBG(CXT, ul_debugobj(cxt, \"read-only re-mount(2) success\"));\n\t\treturn 0;\n\t}\n\n\tif (rc < 0) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount(2) failed [errno=%d]\",\n\t\t\t-cxt->syscall_status));\n\t\treturn -cxt->syscall_status;\n\t}\n\n\tcxt->syscall_status = 0;\n\tDBG(CXT, ul_debugobj(cxt, \"umount(2) success\"));\n\treturn 0;\n}\n\n/**\n * mnt_context_prepare_umount:\n * @cxt: mount context\n *\n * Prepare context for umounting, unnecessary for mnt_context_umount().\n *\n * Returns: 0 on success, and negative number in case of error.\n */\nint mnt_context_prepare_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tif (!cxt || !cxt->fs || mnt_fs_is_swaparea(cxt->fs))\n\t\treturn -EINVAL;\n\tif (!mnt_context_get_source(cxt) && !mnt_context_get_target(cxt))\n\t\treturn -EINVAL;\n\tif (cxt->flags & MNT_FL_PREPARED)\n\t\treturn 0;\n\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\n\tfree(cxt->helper);\t/* be paranoid */\n\tcxt->helper = NULL;\n\tcxt->action = MNT_ACT_UMOUNT;\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = lookup_umount_fs(cxt);\n\tif (!rc)\n\t\trc = mnt_context_merge_mflags(cxt);\n\tif (!rc)\n\t\trc = evaluate_permissions(cxt);\n\n\tif (!rc && !cxt->helper) {\n\n\t\tif (cxt->user_mountflags & MNT_MS_HELPER)\n\t\t\t/* on helper= mount option based helper */\n\t\t\trc = prepare_helper_from_options(cxt, \"helper\");\n\n\t\tif (!rc && !cxt->helper)\n\t\t\t/* on fstype based helper */\n\t\t\trc = mnt_context_prepare_helper(cxt, \"umount\", NULL);\n\t}\n\n\tif (!rc && (cxt->user_mountflags & MNT_MS_LOOP))\n\t\t/* loop option explicitly specified in mtab, detach this loop */\n\t\tmnt_context_enable_loopdel(cxt, TRUE);\n\n\tif (!rc && mnt_context_is_loopdel(cxt) && cxt->fs) {\n\t\tconst char *src = mnt_fs_get_srcpath(cxt->fs);\n\n\t\tif (src && (!is_loopdev(src) || loopdev_is_autoclear(src)))\n\t\t\tmnt_context_enable_loopdel(cxt, FALSE);\n\t}\n\n\tif (rc) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: preparing failed\"));\n\t\treturn rc;\n\t}\n\tcxt->flags |= MNT_FL_PREPARED;\n\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n/**\n * mnt_context_do_umount:\n * @cxt: mount context\n *\n * Umount filesystem by umount(2) or fork()+exec(/sbin/umount.type).\n * Unnecessary for mnt_context_umount().\n *\n * See also mnt_context_disable_helpers().\n *\n * WARNING: non-zero return code does not mean that umount(2) syscall or\n *          umount.type helper wasn't successfully called.\n *\n *          Check mnt_context_get_status() after error!\n*\n * Returns: 0 on success;\n *         >0 in case of umount(2) error (returns syscall errno),\n *         <0 in case of other errors.\n */\nint mnt_context_do_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\tassert((cxt->flags & MNT_FL_PREPARED));\n\tassert((cxt->action == MNT_ACT_UMOUNT));\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = do_umount(cxt);\n\tif (rc)\n\t\tgoto end;\n\n\tif (mnt_context_get_status(cxt) && !mnt_context_is_fake(cxt)) {\n\t\t/*\n\t\t * Umounted, do some post-umount operations\n\t\t *\t- remove loopdev\n\t\t *\t- refresh in-memory mtab stuff if remount rather than\n\t\t *\t  umount has been performed\n\t\t */\n\t\tif (mnt_context_is_loopdel(cxt)\n\t\t    && !(cxt->mountflags & MS_REMOUNT))\n\t\t\trc = mnt_context_delete_loopdev(cxt);\n\n\t\tif (!mnt_context_is_nomtab(cxt)\n\t\t    && mnt_context_get_status(cxt)\n\t\t    && !cxt->helper\n\t\t    && mnt_context_is_rdonly_umount(cxt)\n\t\t    && (cxt->mountflags & MS_REMOUNT)) {\n\n\t\t\t/* use \"remount\" instead of \"umount\" in /etc/mtab */\n\t\t\tif (!rc && cxt->update && mnt_context_mtab_writable(cxt))\n\t\t\t\trc = mnt_update_set_fs(cxt->update,\n\t\t\t\t\t\t       cxt->mountflags, NULL, cxt->fs);\n\t\t}\n\t}\nend:\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n/**\n * mnt_context_finalize_umount:\n * @cxt: context\n *\n * Mtab update, etc. Unnecessary for mnt_context_umount(), but should be called\n * after mnt_context_do_umount(). See also mnt_context_set_syscall_status().\n *\n * Returns: negative number on error, 0 on success.\n */\nint mnt_context_finalize_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_PREPARED));\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\trc = mnt_context_prepare_update(cxt);\n\tif (!rc)\n\t\trc = mnt_context_update_tabs(cxt);\n\treturn rc;\n}\n\n\n/**\n * mnt_context_umount:\n * @cxt: umount context\n *\n * High-level, umounts filesystem by umount(2) or fork()+exec(/sbin/umount.type).\n *\n * This is similar to:\n *\n *\tmnt_context_prepare_umount(cxt);\n *\tmnt_context_do_umount(cxt);\n *\tmnt_context_finalize_umount(cxt);\n *\n * See also mnt_context_disable_helpers().\n *\n * WARNING: non-zero return code does not mean that umount(2) syscall or\n *          umount.type helper wasn't successfully called.\n *\n *          Check mnt_context_get_status() after error!\n *\n * Returns: 0 on success;\n *         >0 in case of umount(2) error (returns syscall errno),\n *         <0 in case of other errors.\n */\nint mnt_context_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: %s\", mnt_context_get_target(cxt)));\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = mnt_context_prepare_umount(cxt);\n\tif (!rc)\n\t\trc = mnt_context_prepare_update(cxt);\n\tif (!rc)\n\t\trc = mnt_context_do_umount(cxt);\n\tif (!rc)\n\t\trc = mnt_context_update_tabs(cxt);\n\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n\n/**\n * mnt_context_next_umount:\n * @cxt: context\n * @itr: iterator\n * @fs: returns the current filesystem\n * @mntrc: returns the return code from mnt_context_umount()\n * @ignored: returns 1 for not matching\n *\n * This function tries to umount the next filesystem from mtab (as returned by\n * mnt_context_get_mtab()).\n *\n * You can filter out filesystems by:\n *\tmnt_context_set_options_pattern() to simulate umount -a -O pattern\n *\tmnt_context_set_fstype_pattern()  to simulate umount -a -t pattern\n *\n * If the filesystem is not mounted or does not match the defined criteria,\n * then the function mnt_context_next_umount() returns zero, but the @ignored is\n * non-zero. Note that the root filesystem is always ignored.\n *\n * If umount(2) syscall or umount.type helper failed, then the\n * mnt_context_next_umount() function returns zero, but the @mntrc is non-zero.\n * Use also mnt_context_get_status() to check if the filesystem was\n * successfully umounted.\n *\n * Returns: 0 on success,\n *         <0 in case of error (!= umount(2) errors)\n *          1 at the end of the list.\n */\nint mnt_context_next_umount(struct libmnt_context *cxt,\n\t\t\t   struct libmnt_iter *itr,\n\t\t\t   struct libmnt_fs **fs,\n\t\t\t   int *mntrc,\n\t\t\t   int *ignored)\n{\n\tstruct libmnt_table *mtab;\n\tconst char *tgt;\n\tint rc;\n\n\tif (ignored)\n\t\t*ignored = 0;\n\tif (mntrc)\n\t\t*mntrc = 0;\n\n\tif (!cxt || !fs || !itr)\n\t\treturn -EINVAL;\n\n\trc = mnt_context_get_mtab(cxt, &mtab);\n\tcxt->mtab = NULL;\t\t/* do not reset mtab */\n\tmnt_reset_context(cxt);\n\n\tif (rc)\n\t\treturn rc;\n\n\tcxt->mtab = mtab;\n\n\tdo {\n\t\trc = mnt_table_next_fs(mtab, itr, fs);\n\t\tif (rc != 0)\n\t\t\treturn rc;\t/* no more filesystems (or error) */\n\n\t\ttgt = mnt_fs_get_target(*fs);\n\t} while (!tgt);\n\n\tDBG(CXT, ul_debugobj(cxt, \"next-umount: trying %s [fstype: %s, t-pattern: %s, options: %s, O-pattern: %s]\", tgt,\n\t\t\t\t mnt_fs_get_fstype(*fs), cxt->fstype_pattern, mnt_fs_get_options(*fs), cxt->optstr_pattern));\n\n\t/* ignore filesystems which don't match options patterns */\n\tif ((cxt->fstype_pattern && !mnt_fs_match_fstype(*fs,\n\t\t\t\t\tcxt->fstype_pattern)) ||\n\n\t/* ignore filesystems which don't match type patterns */\n\t   (cxt->optstr_pattern && !mnt_fs_match_options(*fs,\n\t\t\t\t\tcxt->optstr_pattern))) {\n\t\tif (ignored)\n\t\t\t*ignored = 1;\n\n\t\tDBG(CXT, ul_debugobj(cxt, \"next-umount: not-match\"));\n\t\treturn 0;\n\t}\n\n\trc = mnt_context_set_fs(cxt, *fs);\n\tif (rc)\n\t\treturn rc;\n\trc = mnt_context_umount(cxt);\n\tif (mntrc)\n\t\t*mntrc = rc;\n\treturn 0;\n}\n\n\nint mnt_context_get_umount_excode(\n\t\t\tstruct libmnt_context *cxt,\n\t\t\tint rc,\n\t\t\tchar *buf,\n\t\t\tsize_t bufsz)\n{\n\tif (mnt_context_helper_executed(cxt))\n\t\t/*\n\t\t * /sbin/umount.<type> called, return status\n\t\t */\n\t\treturn mnt_context_get_helper_status(cxt);\n\n\tif (rc == 0 && mnt_context_get_status(cxt) == 1)\n\t\t/*\n\t\t * Libmount success && syscall success.\n\t\t */\n\t\treturn MNT_EX_SUCCESS;\n\n\tif (!mnt_context_syscall_called(cxt)) {\n\t\t/*\n\t\t * libmount errors (extra library checks)\n\t\t */\n\t\tif (rc == -EPERM && !mnt_context_tab_applied(cxt)) {\n\t\t\t/* failed to evaluate permissions because not found\n\t\t\t * relevant entry in mtab */\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"not mounted\"));\n\t\t\treturn MNT_EX_USAGE;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_LOCK) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"locking failed\"));\n\t\t\treturn MNT_EX_FILEIO;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_NAMESPACE) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"failed to switch namespace\"));\n\t\t\treturn MNT_EX_SYSERR;\n\t\t}\n\t\treturn mnt_context_get_generic_excode(rc, buf, bufsz,\n\t\t\t\t\t_(\"umount failed: %m\"));\n\n\t} if (mnt_context_get_syscall_errno(cxt) == 0) {\n\t\t/*\n\t\t * umount(2) syscall success, but something else failed\n\t\t * (probably error in mtab processing).\n\t\t */\n\t\tif (rc == -MNT_ERR_LOCK) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"filesystem was unmounted, but failed to update userspace mount table\"));\n\t\t\treturn MNT_EX_FILEIO;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_NAMESPACE) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"filesystem was unmounted, but failed to switch namespace back\"));\n\t\t\treturn MNT_EX_SYSERR;\n\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\treturn mnt_context_get_generic_excode(rc, buf, bufsz,\n\t\t\t\t_(\"filesystem was unmounted, but any subsequent operation failed: %m\"));\n\n\t\treturn MNT_EX_SOFTWARE;\t/* internal error */\n\t}\n\n\t/*\n\t * umount(2) errors\n\t */\n\tif (buf) {\n\t\tint syserr = mnt_context_get_syscall_errno(cxt);\n\n\t\tswitch (syserr) {\n\t\tcase ENXIO:\n\t\t\tsnprintf(buf, bufsz, _(\"invalid block device\"));\t/* ??? */\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tsnprintf(buf, bufsz, _(\"not mounted\"));\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\tsnprintf(buf, bufsz, _(\"can't write superblock\"));\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tsnprintf(buf, bufsz, _(\"target is busy\"));\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tsnprintf(buf, bufsz, _(\"no mount point specified\"));\n\t\t\tbreak;\n\t\tcase EPERM:\n\t\t\tsnprintf(buf, bufsz, _(\"must be superuser to unmount\"));\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tsnprintf(buf, bufsz, _(\"block devices are not permitted on filesystem\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn mnt_context_get_generic_excode(syserr, buf, bufsz,_(\"umount(2) system call failed: %m\"));\n\t\t}\n\t}\n\treturn MNT_EX_FAIL;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * mountP.h - private library header file\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifndef _LIBMOUNT_PRIVATE_H\n#define _LIBMOUNT_PRIVATE_H\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#include \"c.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"libmount.h\"\n\n/*\n * Debug\n */\n#define MNT_DEBUG_HELP\t\t(1 << 0)\n#define MNT_DEBUG_INIT\t\t(1 << 1)\n#define MNT_DEBUG_CACHE\t\t(1 << 2)\n#define MNT_DEBUG_OPTIONS\t(1 << 3)\n#define MNT_DEBUG_LOCKS\t\t(1 << 4)\n#define MNT_DEBUG_TAB\t\t(1 << 5)\n#define MNT_DEBUG_FS\t\t(1 << 6)\n#define MNT_DEBUG_UPDATE\t(1 << 7)\n#define MNT_DEBUG_UTILS\t\t(1 << 8)\n#define MNT_DEBUG_CXT\t\t(1 << 9)\n#define MNT_DEBUG_DIFF\t\t(1 << 10)\n#define MNT_DEBUG_MONITOR\t(1 << 11)\n#define MNT_DEBUG_BTRFS\t\t(1 << 12)\n#define MNT_DEBUG_LOOP\t\t(1 << 13)\n#define MNT_DEBUG_VERITY\t(1 << 14)\n\n#define MNT_DEBUG_ALL\t\t0xFFFF\n\nUL_DEBUG_DECLARE_MASK(libmount);\n#define DBG(m, x)\t__UL_DBG(libmount, MNT_DEBUG_, m, x)\n#define ON_DBG(m, x)\t__UL_DBG_CALL(libmount, MNT_DEBUG_, m, x)\n#define DBG_FLUSH\t__UL_DBG_FLUSH(libmount, MNT_DEBUG_)\n\n#define UL_DEBUG_CURRENT_MASK\tUL_DEBUG_MASK(libmount)\n#include \"debugobj.h\"\n\n/*\n * NLS -- the library has to be independent on main program, so define\n * UL_TEXTDOMAIN_EXPLICIT before you include nls.h.\n *\n * Now we use util-linux.po (=PACKAGE), rather than maintain the texts\n * in the separate libmount.po file.\n */\n#define LIBMOUNT_TEXTDOMAIN\tPACKAGE\n#define UL_TEXTDOMAIN_EXPLICIT\tLIBMOUNT_TEXTDOMAIN\n#include \"nls.h\"\n\n\n/* extension for files in the directory */\n#define MNT_MNTTABDIR_EXT\t\".fstab\"\n\n/* library private paths */\n#define MNT_RUNTIME_TOPDIR\t\"/run\"\n/* private userspace mount table */\n#define MNT_PATH_UTAB\t\tMNT_RUNTIME_TOPDIR \"/mount/utab\"\n/* temporary mount target */\n#define MNT_PATH_TMPTGT\t\tMNT_RUNTIME_TOPDIR \"/mount/tmptgt\"\n\n#define MNT_UTAB_HEADER\t\"# libmount utab file\\n\"\n\n#ifdef TEST_PROGRAM\nstruct libmnt_test {\n\tconst char\t*name;\n\tint\t\t(*body)(struct libmnt_test *ts, int argc, char *argv[]);\n\tconst char\t*usage;\n};\n\n/* test.c */\nextern int mnt_run_test(struct libmnt_test *tests, int argc, char *argv[]);\n#endif\n\n/* utils.c */\nextern int mnt_valid_tagname(const char *tagname);\n\nextern const char *mnt_statfs_get_fstype(struct statfs *vfs);\nextern int is_file_empty(const char *name);\n\nextern int mnt_is_readonly(const char *path)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_parse_offset(const char *str, size_t len, uintmax_t *res);\n\nextern int mnt_chdir_to_parent(const char *target, char **filename);\n\nextern char *mnt_get_username(const uid_t uid);\nextern int mnt_get_uid(const char *username, uid_t *uid);\nextern int mnt_get_gid(const char *groupname, gid_t *gid);\nextern int mnt_in_group(gid_t gid);\n\nextern int mnt_open_uniq_filename(const char *filename, char **name);\n\nextern int mnt_has_regular_utab(const char **utab, int *writable);\nextern const char *mnt_get_utab_path(void);\n\nextern int mnt_get_filesystems(char ***filesystems, const char *pattern);\nextern void mnt_free_filesystems(char **filesystems);\n\nextern char *mnt_get_kernel_cmdline_option(const char *name);\nextern int mnt_stat_mountpoint(const char *target, struct stat *st);\nextern int mnt_lstat_mountpoint(const char *target, struct stat *st);\n\nextern int mnt_tmptgt_unshare(int *old_ns_fd);\nextern int mnt_tmptgt_cleanup(int old_ns_fd);\n\n/* tab.c */\nextern int is_mountinfo(struct libmnt_table *tb);\nextern int mnt_table_set_parser_fltrcb(\tstruct libmnt_table *tb,\n\t\t\t\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\t\t\t\tvoid *data);\n\nextern int __mnt_table_parse_mtab(struct libmnt_table *tb,\n\t\t\t\t\tconst char *filename,\n\t\t\t\t\tstruct libmnt_table *u_tb);\n\nextern struct libmnt_fs *mnt_table_get_fs_root(struct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fs,\n\t\t\t\t\tunsigned long mountflags,\n\t\t\t\t\tchar **fsroot);\n\nextern int __mnt_table_is_fs_mounted(\tstruct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fstab_fs,\n\t\t\t\t\tconst char *tgt_prefix);\n\n/*\n * Generic iterator\n */\nstruct libmnt_iter {\n        struct list_head        *p;\t\t/* current position */\n        struct list_head        *head;\t\t/* start position */\n\tint\t\t\tdirection;\t/* MNT_ITER_{FOR,BACK}WARD */\n};\n\n#define IS_ITER_FORWARD(_i)\t((_i)->direction == MNT_ITER_FORWARD)\n#define IS_ITER_BACKWARD(_i)\t((_i)->direction == MNT_ITER_BACKWARD)\n\n#define MNT_ITER_INIT(itr, list) \\\n\tdo { \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(list)->next : (list)->prev; \\\n\t\t(itr)->head = (list); \\\n\t} while(0)\n\n#define MNT_ITER_ITERATE(itr, res, restype, member) \\\n\tdo { \\\n\t\tres = list_entry((itr)->p, restype, member); \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(itr)->p->next : (itr)->p->prev; \\\n\t} while(0)\n\n\n/*\n * This struct represents one entry in a mtab/fstab/mountinfo file.\n * (note that fstab[1] means the first column from fstab, and so on...)\n */\nstruct libmnt_fs {\n\tstruct list_head ents;\n\tstruct libmnt_table *tab;\n\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tid;\t\t/* mountinfo[1]: ID */\n\tint\t\tparent;\t\t/* mountinfo[2]: parent */\n\tdev_t\t\tdevno;\t\t/* mountinfo[3]: st_dev */\n\n\tchar\t\t*bindsrc;\t/* utab, full path from fstab[1] for bind mounts */\n\n\tchar\t\t*source;\t/* fstab[1], mountinfo[10], swaps[1]:\n                                         * source dev, file, dir or TAG */\n\tchar\t\t*tagname;\t/* fstab[1]: tag name - \"LABEL\", \"UUID\", ..*/\n\tchar\t\t*tagval;\t/*           tag value */\n\n\tchar\t\t*root;\t\t/* mountinfo[4]: root of the mount within the FS */\n\tchar\t\t*target;\t/* mountinfo[5], fstab[2]: mountpoint */\n\tchar\t\t*fstype;\t/* mountinfo[9], fstab[3]: filesystem type */\n\n\tchar\t\t*optstr;\t/* fstab[4], merged options */\n\tchar\t\t*vfs_optstr;\t/* mountinfo[6]: fs-independent (VFS) options */\n\tchar\t\t*opt_fields;\t/* mountinfo[7]: optional fields */\n\tchar\t\t*fs_optstr;\t/* mountinfo[11]: fs-dependent options */\n\tchar\t\t*user_optstr;\t/* userspace mount options */\n\tchar\t\t*attrs;\t\t/* mount attributes */\n\n\tint\t\tfreq;\t\t/* fstab[5]: dump frequency in days */\n\tint\t\tpassno;\t\t/* fstab[6]: pass number on parallel fsck */\n\n\t/* /proc/swaps */\n\tchar\t\t*swaptype;\t/* swaps[2]: device type (partition, file, ...) */\n\toff_t\t\tsize;\t\t/* swaps[3]: swaparea size */\n\toff_t\t\tusedsize;\t/* swaps[4]: used size */\n\tint\t\tpriority;\t/* swaps[5]: swap priority */\n\n\tint\t\tflags;\t\t/* MNT_FS_* flags */\n\tpid_t\t\ttid;\t\t/* /proc/<tid>/mountinfo otherwise zero */\n\n\tchar\t\t*comment;\t/* fstab comment */\n\n\tvoid\t\t*userdata;\t/* library independent data */\n};\n\n/*\n * fs flags\n */\n#define MNT_FS_PSEUDO\t(1 << 1) /* pseudo filesystem */\n#define MNT_FS_NET\t(1 << 2) /* network filesystem */\n#define MNT_FS_SWAP\t(1 << 3) /* swap device */\n#define MNT_FS_KERNEL\t(1 << 4) /* data from /proc/{mounts,self/mountinfo} */\n#define MNT_FS_MERGED\t(1 << 5) /* already merged data from /run/mount/utab */\n\n/*\n * mtab/fstab/mountinfo file\n */\nstruct libmnt_table {\n\tint\t\tfmt;\t\t/* MNT_FMT_* file format */\n\tint\t\tnents;\t\t/* number of entries */\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tcomms;\t\t/* enable/disable comment parsing */\n\tchar\t\t*comm_intro;\t/* First comment in file */\n\tchar\t\t*comm_tail;\t/* Last comment in file */\n\n\tstruct libmnt_cache *cache;\t\t/* canonicalized paths/tags cache */\n\n        int\t\t(*errcb)(struct libmnt_table *tb,\n\t\t\t\t const char *filename, int line);\n\n\tint\t\t(*fltrcb)(struct libmnt_fs *fs, void *data);\n\tvoid\t\t*fltrcb_data;\n\n\n\tstruct list_head\tents;\t/* list of entries (libmnt_fs) */\n\tvoid\t\t*userdata;\n};\n\nextern struct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent);\n\n/*\n * Tab file format\n */\nenum {\n\tMNT_FMT_GUESS,\n\tMNT_FMT_FSTAB,\t\t\t/* /etc/{fs,m}tab */\n\tMNT_FMT_MTAB = MNT_FMT_FSTAB,\t/* alias */\n\tMNT_FMT_MOUNTINFO,\t\t/* /proc/#/mountinfo */\n\tMNT_FMT_UTAB,\t\t\t/* /run/mount/utab */\n\tMNT_FMT_SWAPS\t\t\t/* /proc/swaps */\n};\n\n/*\n * Additional mounts\n */\nstruct libmnt_addmount {\n\tunsigned long mountflags;\n\n\tstruct list_head\tmounts;\n};\n\nstruct libmnt_ns {\n\tint fd;\t\t\t\t/* file descriptor of namespace, -1 when inactive */\n\tstruct libmnt_cache *cache;\t/* paths cache associated with NS */\n};\n\n/*\n * Mount context -- high-level API\n */\nstruct libmnt_context\n{\n\tint\taction;\t\t/* MNT_ACT_{MOUNT,UMOUNT} */\n\tint\trestricted;\t/* root or not? */\n\n\tchar\t*fstype_pattern;\t/* for mnt_match_fstype() */\n\tchar\t*optstr_pattern;\t/* for mnt_match_options() */\n\n\tchar\t*subdir;\t\t/* X-mount.subdir= */\n\n\tstruct libmnt_fs *fs;\t\t/* filesystem description (type, mountpoint, device, ...) */\n\tstruct libmnt_fs *fs_template;\t/* used for @fs on mnt_reset_context() */\n\n\tstruct libmnt_table *fstab;\t/* fstab (or mtab for some remounts) entries */\n\tstruct libmnt_table *mtab;\t/* mtab entries */\n\tstruct libmnt_table *utab;\t/* rarely used by umount only */\n\n\tint\t(*table_errcb)(struct libmnt_table *tb,\t/* callback for libmnt_table structs */\n\t\t\t const char *filename, int line);\n\n\tint\t(*table_fltrcb)(struct libmnt_fs *fs, void *data);\t/* callback for libmnt_table structs */\n\tvoid\t*table_fltrcb_data;\n\n\tchar\t*(*pwd_get_cb)(struct libmnt_context *);\t\t/* get encryption password */\n\tvoid\t(*pwd_release_cb)(struct libmnt_context *, char *);\t/* release password */\n\n\tint\toptsmode;\t/* fstab optstr mode MNT_OPTSMODE_{AUTO,FORCE,IGNORE} */\n\tint\tloopdev_fd;\t/* open loopdev */\n\n\tunsigned long\tmountflags;\t/* final mount(2) flags */\n\tconst void\t*mountdata;\t/* final mount(2) data, string or binary data */\n\n\tunsigned long\tuser_mountflags;\t/* MNT_MS_* (loop=, user=, ...) */\n\n\tstruct list_head\taddmounts;\t/* additional mounts */\n\n\tstruct libmnt_cache\t*cache;\t/* paths cache */\n\tstruct libmnt_lock\t*lock;\t/* mtab lock */\n\tstruct libmnt_update\t*update;/* mtab/utab update */\n\n\tconst char\t*mtab_path; /* path to mtab */\n\tint\t\tmtab_writable; /* is mtab writable */\n\n\tconst char\t*utab_path; /* path to utab */\n\tint\t\tutab_writable; /* is utab writable */\n\n\tchar\t\t*tgt_prefix;\t/* path used for all targets */\n\n\tint\tflags;\t\t/* private context flags */\n\n\tchar\t*helper;\t/* name of the used /sbin/[u]mount.<type> helper */\n\tint\thelper_status;\t/* helper wait(2) status */\n\tint\thelper_exec_status; /* 1: not called yet, 0: success, <0: -errno */\n\n\tchar\t*orig_user;\t/* original (non-fixed) user= option */\n\n\tpid_t\t*children;\t/* \"mount -a --fork\" PIDs */\n\tint\tnchildren;\t/* number of children */\n\tpid_t\tpid;\t\t/* 0=parent; PID=child */\n\n\n\tint\tsyscall_status;\t/* 1: not called yet, 0: success, <0: -errno */\n\n\tstruct libmnt_ns\tns_orig;\t/* original namespace */\n\tstruct libmnt_ns\tns_tgt;\t\t/* target namespace */\n\tstruct libmnt_ns\t*ns_cur;\t/* pointer to current namespace */\n\n\tunsigned int\tenabled_textdomain : 1;\t\t/* bindtextdomain() called */\n};\n\n/* flags */\n#define MNT_FL_NOMTAB\t\t(1 << 1)\n#define MNT_FL_FAKE\t\t(1 << 2)\n#define MNT_FL_SLOPPY\t\t(1 << 3)\n#define MNT_FL_VERBOSE\t\t(1 << 4)\n#define MNT_FL_NOHELPERS\t(1 << 5)\n#define MNT_FL_LOOPDEL\t\t(1 << 6)\n#define MNT_FL_LAZY\t\t(1 << 7)\n#define MNT_FL_FORCE\t\t(1 << 8)\n#define MNT_FL_NOCANONICALIZE\t(1 << 9)\n#define MNT_FL_RDONLY_UMOUNT\t(1 << 11)\t/* remount,ro after EBUSY umount(2) */\n#define MNT_FL_FORK\t\t(1 << 12)\n#define MNT_FL_NOSWAPMATCH\t(1 << 13)\n#define MNT_FL_RWONLY_MOUNT\t(1 << 14)\t/* explicit mount -w; never try read-only  */\n\n#define MNT_FL_MOUNTDATA\t(1 << 20)\n#define MNT_FL_TAB_APPLIED\t(1 << 21)\t/* mtab/fstab merged to cxt->fs */\n#define MNT_FL_MOUNTFLAGS_MERGED (1 << 22)\t/* MS_* flags was read from optstr */\n#define MNT_FL_SAVED_USER\t(1 << 23)\n#define MNT_FL_PREPARED\t\t(1 << 24)\n#define MNT_FL_HELPER\t\t(1 << 25)\t/* [u]mount.<type> */\n#define MNT_FL_LOOPDEV_READY\t(1 << 26)\t/* /dev/loop<N> initialized by the library */\n#define MNT_FL_MOUNTOPTS_FIXED  (1 << 27)\n#define MNT_FL_TABPATHS_CHECKED\t(1 << 28)\n#define MNT_FL_FORCED_RDONLY\t(1 << 29)\t/* mounted read-only on write-protected device */\n#define MNT_FL_VERITYDEV_READY\t(1 << 30)\t/* /dev/mapper/<FOO> initialized by the library */\n\n/* default flags */\n#define MNT_FL_DEFAULT\t\t0\n\n/* Flags usable with MS_BIND|MS_REMOUNT */\n#define MNT_BIND_SETTABLE\t(MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_NOATIME|MS_NODIRATIME|MS_RELATIME|MS_RDONLY)\n\n/* lock.c */\nextern int mnt_lock_use_simplelock(struct libmnt_lock *ml, int enable);\n\n/* optmap.c */\nextern const struct libmnt_optmap *mnt_optmap_get_entry(\n\t\t\t     struct libmnt_optmap const **maps,\n                             int nmaps,\n\t\t\t     const char *name,\n                             size_t namelen,\n\t\t\t     const struct libmnt_optmap **mapent);\n\n/* optstr.c */\nextern int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end);\nextern int mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_secontext(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_user(char **optstr);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n\t\t\t__attribute__((nonnull));\nextern int __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n\t\t\t__attribute__((nonnull(1)));\nextern int __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n\t\t\t__attribute__((nonnull(1)));\n\n/* context.c */\nextern struct libmnt_context *mnt_copy_context(struct libmnt_context *o);\nextern int mnt_context_mtab_writable(struct libmnt_context *cxt);\nextern int mnt_context_utab_writable(struct libmnt_context *cxt);\nextern const char *mnt_context_get_writable_tabpath(struct libmnt_context *cxt);\n\nextern int mnt_context_get_mtab_for_target(struct libmnt_context *cxt,\n\t\t\t\t    struct libmnt_table **mtab, const char *tgt);\n\nextern int mnt_context_prepare_srcpath(struct libmnt_context *cxt);\nextern int mnt_context_prepare_target(struct libmnt_context *cxt);\nextern int mnt_context_guess_srcpath_fstype(struct libmnt_context *cxt, char **type);\nextern int mnt_context_guess_fstype(struct libmnt_context *cxt);\nextern int mnt_context_prepare_helper(struct libmnt_context *cxt,\n\t\t\t\t      const char *name, const char *type);\nextern int mnt_context_prepare_update(struct libmnt_context *cxt);\nextern int mnt_context_merge_mflags(struct libmnt_context *cxt);\nextern int mnt_context_update_tabs(struct libmnt_context *cxt);\n\nextern int mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg);\nextern int mnt_context_mount_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_is_loopdev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_context_propagation_only(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern struct libmnt_addmount *mnt_new_addmount(void);\nextern void mnt_free_addmount(struct libmnt_addmount *ad);\n\nextern int mnt_context_setup_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_delete_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_clear_loopdev(struct libmnt_context *cxt);\n\nextern int mnt_fork_context(struct libmnt_context *cxt);\n\nextern int mnt_context_set_tabfilter(struct libmnt_context *cxt,\n\t\t\t\t     int (*fltr)(struct libmnt_fs *, void *),\n\t\t\t\t     void *data);\n\nextern int mnt_context_get_generic_excode(int rc, char *buf, size_t bufsz, const char *fmt, ...)\n\t\t\t\t__attribute__ ((__format__ (__printf__, 4, 5)));\nextern int mnt_context_get_mount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\nextern int mnt_context_get_umount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\n\nextern int mnt_context_has_template(struct libmnt_context *cxt);\nextern int mnt_context_apply_template(struct libmnt_context *cxt);\nextern int mnt_context_save_template(struct libmnt_context *cxt);\n\nextern int mnt_context_apply_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\n\nextern int mnt_context_is_veritydev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\nextern int mnt_context_setup_veritydev(struct libmnt_context *cxt);\nextern int mnt_context_deferred_delete_veritydev(struct libmnt_context *cxt);\n\n/* tab_update.c */\nextern int mnt_update_set_filename(struct libmnt_update *upd,\n\t\t\t\t   const char *filename, int userspace_only);\nextern int mnt_update_already_done(struct libmnt_update *upd,\n\t\t\t\t   struct libmnt_lock *lc);\n\n#if __linux__\n/* btrfs.c */\nextern uint64_t btrfs_get_default_subvol_id(const char *path);\n#endif\n\n#endif /* _LIBMOUNT_PRIVATE_H */\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2009-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: optstr\n * @title: Options string\n * @short_description: low-level API for working with mount options\n *\n * This is a simple and low-level API to working with mount options that are stored\n * in a string.\n */\n#include <ctype.h>\n\n#ifdef HAVE_LIBSELINUX\n#include <selinux/selinux.h>\n#include <selinux/context.h>\n#endif\n\n#include \"strutils.h\"\n#include \"mountP.h\"\n#include \"buffer.h\"\n\n/*\n * Option location\n */\nstruct libmnt_optloc {\n\tchar\t*begin;\n\tchar\t*end;\n\tchar\t*value;\n\tsize_t\tvalsz;\n\tsize_t  namesz;\n};\n\n#define MNT_INIT_OPTLOC\t{ .begin = NULL }\n\n#define mnt_optmap_entry_novalue(e) \\\n\t\t(e && (e)->name && !strchr((e)->name, '=') && !((e)->mask & MNT_PREFIX))\n\n/*\n * Parses the first option from @optstr. The @optstr pointer is set to the beginning\n * of the next option.\n *\n * Returns -EINVAL on parse error, 1 at the end of optstr and 0 on success.\n */\nstatic int mnt_optstr_parse_next(char **optstr,\t char **name, size_t *namesz,\n\t\t\t\t\tchar **value, size_t *valsz)\n{\n\tint open_quote = 0;\n\tchar *start = NULL, *stop = NULL, *p, *sep = NULL;\n\tchar *optstr0;\n\n\tassert(optstr);\n\tassert(*optstr);\n\n\toptstr0 = *optstr;\n\n\tif (name)\n\t\t*name = NULL;\n\tif (namesz)\n\t\t*namesz = 0;\n\tif (value)\n\t\t*value = NULL;\n\tif (valsz)\n\t\t*valsz = 0;\n\n\t/* trim leading commas as to not invalidate option\n\t * strings with multiple consecutive commas */\n\twhile (optstr0 && *optstr0 == ',')\n\t\toptstr0++;\n\n\tfor (p = optstr0; p && *p; p++) {\n\t\tif (!start)\n\t\t\tstart = p;\t\t/* beginning of the option item */\n\t\tif (*p == '\"')\n\t\t\topen_quote ^= 1;\t/* reverse the status */\n\t\tif (open_quote)\n\t\t\tcontinue;\t\t/* still in quoted block */\n\t\tif (!sep && p > start && *p == '=')\n\t\t\tsep = p;\t\t/* name and value separator */\n\t\tif (*p == ',')\n\t\t\tstop = p;\t\t/* terminate the option item */\n\t\telse if (*(p + 1) == '\\0')\n\t\t\tstop = p + 1;\t\t/* end of optstr */\n\t\tif (!start || !stop)\n\t\t\tcontinue;\n\t\tif (stop <= start)\n\t\t\tgoto error;\n\n\t\tif (name)\n\t\t\t*name = start;\n\t\tif (namesz)\n\t\t\t*namesz = sep ? sep - start : stop - start;\n\t\t*optstr = *stop ? stop + 1 : stop;\n\n\t\tif (sep) {\n\t\t\tif (value)\n\t\t\t\t*value = sep + 1;\n\t\t\tif (valsz)\n\t\t\t\t*valsz = stop - sep - 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\t\t\t\t/* end of optstr */\n\nerror:\n\tDBG(OPTIONS, ul_debug(\"parse error: \\\"%s\\\"\", optstr0));\n\treturn -EINVAL;\n}\n\n/*\n * Locates the first option that matches @name. The @end is set to the\n * char behind the option (it means ',' or \\0).\n *\n * Returns negative number on parse error, 1 when not found and 0 on success.\n */\nstatic int mnt_optstr_locate_option(char *optstr, const char *name,\n\t\t\t\t\tstruct libmnt_optloc *ol)\n{\n\tchar *n;\n\tsize_t namesz, nsz;\n\tint rc;\n\n\tif (!optstr)\n\t\treturn 1;\n\n\tassert(name);\n\n\tnamesz = strlen(name);\n\n\tdo {\n\t\trc = mnt_optstr_parse_next(&optstr, &n, &nsz,\n\t\t\t\t\t&ol->value, &ol->valsz);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tif (namesz == nsz && strncmp(n, name, nsz) == 0) {\n\t\t\tol->begin = n;\n\t\t\tol->end = *(optstr - 1) == ',' ? optstr - 1 : optstr;\n\t\t\tol->namesz = nsz;\n\t\t\treturn 0;\n\t\t}\n\t} while(1);\n\n\treturn rc;\n}\n\n/**\n * mnt_optstr_next_option:\n * @optstr: option string, returns the position of the next option\n * @name: returns the option name\n * @namesz: returns the option name length\n * @value: returns the option value or NULL\n * @valuesz: returns the option value length or zero\n *\n * Parses the first option in @optstr.\n *\n * Returns: 0 on success, 1 at the end of @optstr or negative number in case of\n * error.\n */\nint mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,\n\t\t\t\t\tchar **value, size_t *valuesz)\n{\n\tif (!optstr || !*optstr)\n\t\treturn -EINVAL;\n\treturn mnt_optstr_parse_next(optstr, name, namesz, value, valuesz);\n}\n\nstatic int __buffer_append_option(struct ul_buffer *buf,\n\t\t\tconst char *name, size_t namesz,\n\t\t\tconst char *val, size_t valsz)\n{\n\tint rc = 0;\n\n\tif (!ul_buffer_is_empty(buf))\n\t\trc = ul_buffer_append_data(buf, \",\", 1);\n\tif (!rc)\n\t\trc = ul_buffer_append_data(buf, name, namesz);\n\tif (val && !rc) {\n\t\t/* we need to append '=' is value is empty string, see\n\t\t * 727c689908c5e68c92aa1dd65e0d3bdb6d91c1e5 */\n\t\trc = ul_buffer_append_data(buf, \"=\", 1);\n\t\tif (!rc && valsz)\n\t\t\trc = ul_buffer_append_data(buf, val, valsz);\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_append_option:\n * @optstr: option string or NULL, returns a reallocated string\n * @name: value name\n * @value: value\n *\n * Returns: 0 on success or <0 in case of error. After an error the @optstr should\n *          be unmodified.\n */\nint mnt_optstr_append_option(char **optstr, const char *name, const char *value)\n{\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tint rc;\n\tsize_t nsz, vsz, osz;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tnsz = strlen(name);\n\tosz = *optstr ? strlen(*optstr) : 0;\n\tvsz = value ? strlen(value) : 0;\n\n\tul_buffer_refer_string(&buf, *optstr);\n\tul_buffer_set_chunksize(&buf, osz + nsz + vsz + 3);\t/* to call realloc() only once */\n\n\trc = __buffer_append_option(&buf, name, nsz, value, vsz);\n\n\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\treturn rc;\n}\n/**\n * mnt_optstr_prepend_option:\n * @optstr: option string or NULL, returns a reallocated string\n * @name: value name\n * @value: value\n *\n * Returns: 0 on success or <0 in case of error. After an error the @optstr should\n *          be unmodified.\n */\nint mnt_optstr_prepend_option(char **optstr, const char *name, const char *value)\n{\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tsize_t nsz, vsz, osz;\n\tint rc;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tnsz = strlen(name);\n\tosz = *optstr ? strlen(*optstr) : 0;\n\tvsz = value ? strlen(value) : 0;\n\n\tul_buffer_set_chunksize(&buf, osz + nsz + vsz + 3);   /* to call realloc() only once */\n\n\trc = __buffer_append_option(&buf, name, nsz, value, vsz);\n\tif (*optstr && !rc) {\n\t\trc = ul_buffer_append_data(&buf, \",\", 1);\n\t\tif (!rc)\n\t\t\trc = ul_buffer_append_data(&buf, *optstr, osz);\n\t\tfree(*optstr);\n\t}\n\n\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\treturn rc;\n}\n\n/**\n * mnt_optstr_get_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n * @value: returns a pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of the value or 0\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_get_option(const char *optstr, const char *name,\n\t\t\t  char **value, size_t *valsz)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\trc = mnt_optstr_locate_option((char *) optstr, name, &ol);\n\tif (!rc) {\n\t\tif (value)\n\t\t\t*value = ol.value;\n\t\tif (valsz)\n\t\t\t*valsz = ol.valsz;\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_deduplicate_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n *\n * Removes all instances of @name except the last one.\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_deduplicate_option(char **optstr, const char *name)\n{\n\tint rc;\n\tchar *begin = NULL, *end = NULL, *opt;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\topt = *optstr;\n\tdo {\n\t\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\n\t\trc = mnt_optstr_locate_option(opt, name, &ol);\n\t\tif (!rc) {\n\t\t\tif (begin) {\n\t\t\t\t/* remove the previous instance */\n\t\t\t\tsize_t shift = strlen(*optstr);\n\n\t\t\t\tmnt_optstr_remove_option_at(optstr, begin, end);\n\n\t\t\t\t/* now all the offsets are not valid anymore - recount */\n\t\t\t\tshift -= strlen(*optstr);\n\t\t\t\tol.begin -= shift;\n\t\t\t\tol.end -= shift;\n\t\t\t}\n\t\t\tbegin = ol.begin;\n\t\t\tend = ol.end;\n\t\t\topt = end && *end ? end + 1 : NULL;\n\t\t}\n\t\tif (opt == NULL)\n\t\t\tbreak;\n\t} while (rc == 0 && *opt);\n\n\treturn rc < 0 ? rc : begin ? 0 : 1;\n}\n\n/*\n * The result never starts or ends with a comma or contains two commas\n *    (e.g. \",aaa,bbb\" or \"aaa,,bbb\" or \"aaa,\")\n */\nint mnt_optstr_remove_option_at(char **optstr, char *begin, char *end)\n{\n\tsize_t sz;\n\n\tif (!optstr || !begin || !end)\n\t\treturn -EINVAL;\n\n\tif ((begin == *optstr || *(begin - 1) == ',') && *end == ',')\n\t\tend++;\n\n\tsz = strlen(end);\n\n\tmemmove(begin, end, sz + 1);\n\tif (!*begin && (begin > *optstr) && *(begin - 1) == ',')\n\t\t*(begin - 1) = '\\0';\n\n\treturn 0;\n}\n\n/* insert 'substr' or '=substr' to @str on position @pos */\nstatic int __attribute__((nonnull(1,2,3)))\ninsert_value(char **str, char *pos, const char *substr, char **next)\n{\n\tsize_t subsz = strlen(substr);\t\t\t/* substring size */\n\tsize_t strsz = strlen(*str);\n\tsize_t possz = strlen(pos);\n\tsize_t posoff;\n\tchar *p;\n\tint sep;\n\n\t/* is it necessary to prepend '=' before the substring ? */\n\tsep = !(pos > *str && *(pos - 1) == '=');\n\n\t/* save an offset of the place where we need to add substr */\n\tposoff = pos - *str;\n\n\tp = realloc(*str, strsz + sep + subsz + 1);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/* zeroize the newly allocated memory -- valgrind loves us... */\n\tmemset(p + strsz, 0, sep + subsz + 1);\n\n\t/* set pointers to the reallocated string */\n\t*str = p;\n\tpos = p + posoff;\n\n\tif (possz)\n\t\t/* create a room for the new substring */\n\t\tmemmove(pos + subsz + sep, pos, possz + 1);\n\tif (sep)\n\t\t*pos++ = '=';\n\n\tmemcpy(pos, substr, subsz);\n\n\tif (next) {\n\t\t/* set pointer to the next option */\n\t\t*next = pos + subsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\treturn 0;\n}\n\n/**\n * mnt_optstr_set_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option\n * @value: new value or NULL\n *\n * Set or unset the option @value.\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_set_option(char **optstr, const char *name, const char *value)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tchar *nameend;\n\tint rc = 1;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\tif (*optstr)\n\t\trc = mnt_optstr_locate_option(*optstr, name, &ol);\n\tif (rc < 0)\n\t\treturn rc;\t\t\t/* parse error */\n\tif (rc == 1)\n\t\treturn mnt_optstr_append_option(optstr, name, value);\t/* not found */\n\n\tnameend = ol.begin + ol.namesz;\n\n\tif (value == NULL && ol.value && ol.valsz)\n\t\t/* remove unwanted \"=value\" */\n\t\tmnt_optstr_remove_option_at(optstr, nameend, ol.end);\n\n\telse if (value && ol.value == NULL)\n\t\t/* insert \"=value\" */\n\t\trc = insert_value(optstr, nameend, value, NULL);\n\n\telse if (value && ol.value && strlen(value) == ol.valsz)\n\t\t/* simply replace =value */\n\t\tmemcpy(ol.value, value, ol.valsz);\n\n\telse if (value && ol.value) {\n\t\tmnt_optstr_remove_option_at(optstr, nameend, ol.end);\n\t\trc = insert_value(optstr, nameend, value, NULL);\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_remove_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_remove_option(char **optstr, const char *name)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\trc = mnt_optstr_locate_option(*optstr, name, &ol);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tmnt_optstr_remove_option_at(optstr, ol.begin, ol.end);\n\treturn 0;\n}\n\n/**\n * mnt_split_optstr:\n * @optstr: string with comma separated list of options\n * @user: returns newly allocated string with userspace options\n * @vfs: returns newly allocated string with VFS options\n * @fs: returns newly allocated string with FS options\n * @ignore_user: option mask for options that should be ignored\n * @ignore_vfs: option mask for options that should be ignored\n *\n * For example:\n *\n *\tmnt_split_optstr(optstr, &u, NULL, NULL, MNT_NOMTAB, 0);\n *\n * returns all userspace options, the options that do not belong to\n * mtab are ignored.\n *\n * Note that FS options are all options that are undefined in MNT_USERSPACE_MAP\n * or MNT_LINUX_MAP.\n *\n * Returns: 0 on success, or a negative number in case of error.\n */\nint mnt_split_optstr(const char *optstr, char **user, char **vfs,\n\t\t     char **fs, int ignore_user, int ignore_vfs)\n{\n\tint rc = 0;\n\tchar *name, *val, *str = (char *) optstr;\n\tsize_t namesz, valsz, chunsz;\n\tstruct libmnt_optmap const *maps[2];\n\tstruct ul_buffer xvfs = UL_INIT_BUFFER,\n\t\t\t xfs = UL_INIT_BUFFER,\n\t\t\t xuser = UL_INIT_BUFFER;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\n\tmaps[0] = mnt_get_builtin_optmap(MNT_LINUX_MAP);\n\tmaps[1] = mnt_get_builtin_optmap(MNT_USERSPACE_MAP);\n\n\tchunsz = strlen(optstr) / 2;\n\n\twhile (!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {\n\t\tstruct ul_buffer *buf = NULL;\n\t\tconst struct libmnt_optmap *ent = NULL;\n\t\tconst struct libmnt_optmap *m =\n\t\t\t mnt_optmap_get_entry(maps, 2, name, namesz, &ent);\n\n\t\tif (ent && !ent->id)\n\t\t\tcontinue;\t/* ignore undefined options (comments) */\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tm = NULL;\n\n\t\tif (ent && m && m == maps[0] && vfs) {\n\t\t\tif (ignore_vfs && (ent->mask & ignore_vfs))\n\t\t\t\tcontinue;\n\t\t\tif (vfs)\n\t\t\t\tbuf = &xvfs;\n\t\t} else if (ent && m && m == maps[1] && user) {\n\t\t\tif (ignore_user && (ent->mask & ignore_user))\n\t\t\t\tcontinue;\n\t\t\tif (user)\n\t\t\t\tbuf = &xuser;\n\t\t} else if (!m && fs) {\n\t\t\tif (fs)\n\t\t\t\tbuf = &xfs;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (ul_buffer_is_empty(buf))\n\t\t\t\tul_buffer_set_chunksize(buf, chunsz);\n\t\t\trc = __buffer_append_option(buf, name, namesz, val, valsz);\n\t\t}\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (vfs)\n\t\t*vfs  = rc ? NULL : ul_buffer_get_data(&xvfs, NULL, NULL);\n\tif (fs)\n\t\t*fs   = rc ? NULL : ul_buffer_get_data(&xfs, NULL, NULL);\n\tif (user)\n\t\t*user = rc ? NULL : ul_buffer_get_data(&xuser, NULL, NULL);\n\tif (rc) {\n\t\tul_buffer_free_data(&xvfs);\n\t\tul_buffer_free_data(&xfs);\n\t\tul_buffer_free_data(&xuser);\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_optstr_get_options\n * @optstr: string with a comma separated list of options\n * @subset: returns newly allocated string with options\n * @map: options map\n * @ignore: mask of the options that should be ignored\n *\n * Extracts options from @optstr that belong to the @map, for example:\n *\n *\t mnt_optstr_get_options(optstr, &p,\n *\t\t\tmnt_get_builtin_optmap(MNT_LINUX_MAP),\n *\t\t\tMNT_NOMTAB);\n *\n * the 'p' returns all VFS options, the options that do not belong to mtab\n * are ignored.\n *\n * Returns: 0 on success, or a negative number in case of error.\n */\nint mnt_optstr_get_options(const char *optstr, char **subset,\n\t\t\t    const struct libmnt_optmap *map, int ignore)\n{\n\tstruct libmnt_optmap const *maps[1];\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tchar *name, *val, *str = (char *) optstr;\n\tsize_t namesz, valsz;\n\tint rc = 0;\n\n\tif (!optstr || !subset)\n\t\treturn -EINVAL;\n\n\tmaps[0] = map;\n\n\tul_buffer_set_chunksize(&buf, strlen(optstr)/2);\n\n\twhile (!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {\n\t\tconst struct libmnt_optmap *ent;\n\n\t\tmnt_optmap_get_entry(maps, 1, name, namesz, &ent);\n\n\t\tif (!ent || !ent->id)\n\t\t\tcontinue;\t/* ignore undefined options (comments) */\n\n\t\tif (ignore && (ent->mask & ignore))\n\t\t\tcontinue;\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tcontinue;\n\n\t\trc = __buffer_append_option(&buf, name, namesz, val, valsz);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\t*subset  = rc ? NULL : ul_buffer_get_data(&buf, NULL, NULL);\n\tif (rc)\n\t\tul_buffer_free_data(&buf);\n\treturn rc;\n}\n\n\n/**\n * mnt_optstr_get_flags:\n * @optstr: string with comma separated list of options\n * @flags: returns mount flags\n * @map: options map\n *\n * Returns in @flags IDs of options from @optstr as defined in the @map.\n *\n * For example:\n *\n *\t\"bind,exec,foo,bar\"   --returns->   MS_BIND\n *\n *\t\"bind,noexec,foo,bar\" --returns->   MS_BIND|MS_NOEXEC\n *\n * Note that @flags are not zeroized by this function! This function sets/unsets\n * bits in the @flags only.\n *\n * Returns: 0 on success or negative number in case of error\n */\nint mnt_optstr_get_flags(const char *optstr, unsigned long *flags,\n\t\tconst struct libmnt_optmap *map)\n{\n\tstruct libmnt_optmap const *maps[2];\n\tchar *name, *str = (char *) optstr;\n\tsize_t namesz = 0, valsz = 0;\n\tint nmaps = 0;\n\n\tif (!optstr || !flags || !map)\n\t\treturn -EINVAL;\n\n\tmaps[nmaps++] = map;\n\n\tif (map == mnt_get_builtin_optmap(MNT_LINUX_MAP))\n\t\t/*\n\t\t * Add userspace map -- the \"user\" is interpreted as\n\t\t *                      MS_NO{EXEC,SUID,DEV}.\n\t\t */\n\t\tmaps[nmaps++] = mnt_get_builtin_optmap(MNT_USERSPACE_MAP);\n\n\twhile(!mnt_optstr_next_option(&str, &name, &namesz, NULL, &valsz)) {\n\t\tconst struct libmnt_optmap *ent;\n\t\tconst struct libmnt_optmap *m;\n\n\t\tm = mnt_optmap_get_entry(maps, nmaps, name, namesz, &ent);\n\t\tif (!m || !ent || !ent->id)\n\t\t\tcontinue;\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tcontinue;\n\n\t\tif (m == map) {\t\t\t\t/* requested map */\n\t\t\tif (ent->mask & MNT_INVERT)\n\t\t\t\t*flags &= ~ent->id;\n\t\t\telse\n\t\t\t\t*flags |= ent->id;\n\n\t\t} else if (nmaps == 2 && m == maps[1] && valsz == 0) {\n\t\t\t/*\n\t\t\t * Special case -- translate \"user\" (but no user=) to\n\t\t\t * MS_ options\n\t\t\t */\n\t\t\tif (ent->mask & MNT_INVERT)\n\t\t\t\tcontinue;\n\t\t\tif (ent->id & (MNT_MS_OWNER | MNT_MS_GROUP))\n\t\t\t\t*flags |= MS_OWNERSECURE;\n\t\t\telse if (ent->id & (MNT_MS_USER | MNT_MS_USERS))\n\t\t\t\t*flags |= MS_SECURE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * mnt_optstr_apply_flags:\n * @optstr: string with comma separated list of options\n * @flags: returns mount flags\n * @map: options map\n *\n * Removes/adds options to the @optstr according to flags. For example:\n *\n *\tMS_NOATIME and \"foo,bar,noexec\"   --returns->  \"foo,bar,noatime\"\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_optstr_apply_flags(char **optstr, unsigned long flags,\n\t\t\t\tconst struct libmnt_optmap *map)\n{\n\tstruct libmnt_optmap const *maps[1];\n\tchar *name, *next, *val;\n\tsize_t namesz = 0, valsz = 0, multi = 0;\n\tunsigned long fl;\n\tint rc = 0;\n\n\tif (!optstr || !map)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"applying 0x%08lx flags to '%s'\", flags, *optstr));\n\n\tmaps[0] = map;\n\tnext = *optstr;\n\tfl = flags;\n\n\t/*\n\t * There is a convention that 'rw/ro' flags are always at the beginning of\n\t * the string (although the 'rw' is unnecessary).\n\t */\n\tif (map == mnt_get_builtin_optmap(MNT_LINUX_MAP)) {\n\t\tconst char *o = (fl & MS_RDONLY) ? \"ro\" : \"rw\";\n\n\t\tif (next &&\n\t\t    (!strncmp(next, \"rw\", 2) || !strncmp(next, \"ro\", 2)) &&\n\t\t    (*(next + 2) == '\\0' || *(next + 2) == ',')) {\n\n\t\t\t/* already set, be paranoid and fix it */\n\t\t\tmemcpy(next, o, 2);\n\t\t} else {\n\t\t\trc = mnt_optstr_prepend_option(optstr, o, NULL);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\t\t\tnext = *optstr;\t\t/* because realloc() */\n\t\t}\n\t\tfl &= ~MS_RDONLY;\n\t\tnext += 2;\n\t\tif (*next == ',')\n\t\t\tnext++;\n\t}\n\n\tif (next && *next) {\n\t\t/*\n\t\t * scan @optstr and remove options that are missing in\n\t\t * @flags\n\t\t */\n\t\twhile(!mnt_optstr_next_option(&next, &name, &namesz,\n\t\t\t\t\t\t\t&val, &valsz)) {\n\t\t\tconst struct libmnt_optmap *ent;\n\n\t\t\tif (mnt_optmap_get_entry(maps, 1, name, namesz, &ent)) {\n\t\t\t\t/*\n\t\t\t\t * remove unwanted option (rw/ro is already set)\n\t\t\t\t */\n\t\t\t\tif (!ent || !ent->id)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* ignore name=<value> if options map expects <name> only */\n\t\t\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (ent->id == MS_RDONLY ||\n\t\t\t\t    (ent->mask & MNT_INVERT) ||\n\t\t\t\t    (fl & ent->id) != (unsigned long) ent->id) {\n\n\t\t\t\t\tchar *end = val ? val + valsz :\n\t\t\t\t\t\t\t  name + namesz;\n\t\t\t\t\tnext = name;\n\t\t\t\t\trc = mnt_optstr_remove_option_at(\n\t\t\t\t\t\t\toptstr, name, end);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (!(ent->mask & MNT_INVERT)) {\n\t\t\t\t\t/* allow options with prefix (X-mount.foo,X-mount.bar) more than once */\n\t\t\t\t\tif (ent->mask & MNT_PREFIX)\n\t\t\t\t\t\tmulti |= ent->id;\n\t\t\t\t\telse\n\t\t\t\t\t\tfl &= ~ent->id;\n\t\t\t\t\tif (ent->id & MS_REC)\n\t\t\t\t\t\tfl |= MS_REC;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove from flags options which are allowed more than once */\n\tfl &= ~multi;\n\n\t/* add missing options (but ignore fl if contains MS_REC only) */\n\tif (fl && fl != MS_REC) {\n\n\t\tconst struct libmnt_optmap *ent;\n\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\tsize_t sz;\n\t\tchar *p;\n\n\t\tul_buffer_refer_string(&buf, *optstr);\n\n\t\tfor (ent = map; ent && ent->name; ent++) {\n\t\t\tif ((ent->mask & MNT_INVERT)\n\t\t\t    || ent->id == 0\n\t\t\t    || (fl & ent->id) != (unsigned long) ent->id)\n\t\t\t\tcontinue;\n\n\t\t\t/* don't add options which require values (e.g. offset=%d) */\n\t\t\tp = strchr(ent->name, '=');\n\t\t\tif (p) {\n\t\t\t\tif (p > ent->name && *(p - 1) == '[')\n\t\t\t\t\tp--;\t\t\t/* name[=] */\n\t\t\t\telse\n\t\t\t\t\tcontinue;\t\t/* name= */\n\t\t\t\tsz = p - ent->name;\n\t\t\t} else\n\t\t\t\tsz = strlen(ent->name);\n\n\t\t\trc = __buffer_append_option(&buf, ent->name, sz, NULL, 0);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t}\n\n\tDBG(CXT, ul_debug(\"new optstr '%s'\", *optstr));\n\treturn rc;\nerr:\n\tDBG(CXT, ul_debug(\"failed to apply flags [rc=%d]\", rc));\n\treturn rc;\n}\n\n/*\n * @optstr: string with comma separated list of options\n * @value: pointer to the begin of the context value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n *\n * Translates SELinux context from human to raw format. The function does not\n * modify @optstr and returns zero if libmount is compiled without SELinux\n * support.\n *\n * Returns: 0 on success, a negative number in case of error.\n */\n#ifndef HAVE_LIBSELINUX\nint mnt_optstr_fix_secontext(char **optstr __attribute__ ((__unused__)),\n\t\t\t     char *value   __attribute__ ((__unused__)),\n\t\t\t     size_t valsz  __attribute__ ((__unused__)),\n\t\t\t     char **next   __attribute__ ((__unused__)))\n{\n\treturn 0;\n}\n#else\nint mnt_optstr_fix_secontext(char **optstr,\n\t\t\t     char *value,\n\t\t\t     size_t valsz,\n\t\t\t     char **next)\n{\n\tint rc = 0;\n\tchar *p, *val, *begin, *end, *raw = NULL;\n\tsize_t sz;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing SELinux context\"));\n\n\tbegin = value;\n\tend = value + valsz;\n\n\t/* the selinux contexts are quoted */\n\tif (*value == '\"') {\n\t\tif (valsz <= 2 || *(value + valsz - 1) != '\"')\n\t\t\treturn -EINVAL;\t\t/* improperly quoted option string */\n\t\tvalue++;\n\t\tvalsz -= 2;\n\t}\n\n\tp = strndup(value, valsz);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\n\t/* translate the context */\n\trc = selinux_trans_to_raw_context(p, &raw);\n\n\tDBG(CXT, ul_debug(\"SELinux context '%s' translated to '%s'\",\n\t\t\tp, rc == -1 ? \"FAILED\" : (char *) raw));\n\n\tfree(p);\n\tif (rc == -1 ||\t!raw)\n\t\treturn -EINVAL;\n\n\n\t/* create a quoted string from the raw context */\n\tsz = strlen((char *) raw);\n\tif (!sz)\n\t\treturn -EINVAL;\n\n\tp = val = malloc(valsz + 3);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\t*p++ = '\"';\n\tmemcpy(p, raw, sz);\n\tp += sz;\n\t*p++ = '\"';\n\t*p = '\\0';\n\n\tfreecon(raw);\n\n\t/* set new context */\n\tmnt_optstr_remove_option_at(optstr, begin, end);\n\trc = insert_value(optstr, begin, val, next);\n\tfree(val);\n\n\treturn rc;\n}\n#endif\n\nstatic int set_uint_value(char **optstr, unsigned int num,\n\t\t\tchar *begin, char *end, char **next)\n{\n\tchar buf[40];\n\tsnprintf(buf, sizeof(buf), \"%u\", num);\n\n\tmnt_optstr_remove_option_at(optstr, begin, end);\n\treturn insert_value(optstr, begin, buf, next);\n}\n\n/*\n * @optstr: string with a comma separated list of options\n * @value: pointer to the beginning of the uid value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n\n * Translates \"username\" or \"useruid\" to the real UID.\n *\n * For example:\n *\tif (!mnt_optstr_get_option(optstr, \"uid\", &val, &valsz))\n *\t\tmnt_optstr_fix_uid(&optstr, val, valsz, NULL);\n *\n * Returns: 0 on success, a negative number in case of error.\n */\nint mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next)\n{\n\tchar *end;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing uid\"));\n\n\tend = value + valsz;\n\n\tif (valsz == 7 && !strncmp(value, \"useruid\", 7) &&\n\t    (*(value + 7) == ',' || !*(value + 7)))\n\t\treturn set_uint_value(optstr, getuid(), value, end, next);\n\n\tif (!isdigit(*value)) {\n\t\tuid_t id;\n\t\tint rc;\n\t\tchar *p = strndup(value, valsz);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\trc = mnt_get_uid(p, &id);\n\t\tfree(p);\n\n\t\tif (!rc)\n\t\t\treturn set_uint_value(optstr, id, value, end, next);\n\t}\n\n\tif (next) {\n\t\t/* no change, let's keep the original value */\n\t\t*next = value + valsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\n\treturn 0;\n}\n\n/*\n * @optstr: string with a comma separated list of options\n * @value: pointer to the beginning of the uid value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n\n * Translates \"groupname\" or \"usergid\" to the real GID.\n *\n * Returns: 0 on success, a negative number in case of error.\n */\nint mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next)\n{\n\tchar *end;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing gid\"));\n\n\tend = value + valsz;\n\n\tif (valsz == 7 && !strncmp(value, \"usergid\", 7) &&\n\t    (*(value + 7) == ',' || !*(value + 7)))\n\t\treturn set_uint_value(optstr, getgid(), value, end, next);\n\n\tif (!isdigit(*value)) {\n\t\tint rc;\n\t\tgid_t id;\n\t\tchar *p = strndup(value, valsz);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\trc = mnt_get_gid(p, &id);\n\t\tfree(p);\n\n\t\tif (!rc)\n\t\t\treturn set_uint_value(optstr, id, value, end, next);\n\n\t}\n\n\tif (next) {\n\t\t/* nothing */\n\t\t*next = value + valsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\treturn 0;\n}\n\n/*\n * Converts \"user\" to \"user=<username>\".\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_optstr_fix_user(char **optstr)\n{\n\tchar *username;\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc = 0;\n\n\tDBG(CXT, ul_debug(\"fixing user\"));\n\n\trc = mnt_optstr_locate_option(*optstr, \"user\", &ol);\n\tif (rc)\n\t\treturn rc == 1 ? 0 : rc;\t/* 1: user= not found */\n\n\tusername = mnt_get_username(getuid());\n\tif (!username)\n\t\treturn -ENOMEM;\n\n\tif (!ol.valsz || (ol.value && strncmp(ol.value, username, ol.valsz) != 0)) {\n\t\tif (ol.valsz)\n\t\t\t/* remove old value */\n\t\t\tmnt_optstr_remove_option_at(optstr, ol.value, ol.end);\n\n\t\trc = insert_value(optstr, ol.value ? ol.value : ol.end,\n\t\t\t\t  username, NULL);\n\t}\n\n\tfree(username);\n\treturn rc;\n}\n\n/**\n * mnt_match_options:\n * @optstr: options string\n * @pattern: comma delimited list of options\n *\n * The \"no\" could be used for individual items in the @options list. The \"no\"\n * prefix does not have a global meaning.\n *\n * Unlike fs type matching, nonetdev,user and nonetdev,nouser have\n * DIFFERENT meanings; each option is matched explicitly as specified.\n *\n * The \"no\" prefix interpretation could be disabled by the \"+\" prefix, for example\n * \"+noauto\" matches if @optstr literally contains the \"noauto\" string.\n *\n * \"xxx,yyy,zzz\" : \"nozzz\"\t-> False\n *\n * \"xxx,yyy,zzz\" : \"xxx,noeee\"\t-> True\n *\n * \"bar,zzz\"     : \"nofoo\"      -> True\t\t(does not contain \"foo\")\n *\n * \"nofoo,bar\"   : \"nofoo\"      -> True\t\t(does not contain \"foo\")\n *\n * \"nofoo,bar\"   : \"+nofoo\"     -> True\t\t(contains \"nofoo\")\n *\n * \"bar,zzz\"     : \"+nofoo\"     -> False\t(does not contain \"nofoo\")\n *\n *\n * Returns: 1 if pattern is matching, else 0. This function also returns 0\n *          if @pattern is NULL and @optstr is non-NULL.\n */\nint mnt_match_options(const char *optstr, const char *pattern)\n{\n\tchar *name, *pat = (char *) pattern;\n\tchar *buf, *patval;\n\tsize_t namesz = 0, patvalsz = 0;\n\tint match = 1;\n\n\tif (!pattern && !optstr)\n\t\treturn 1;\n\tif (!pattern)\n\t\treturn 0;\n\n\tbuf = malloc(strlen(pattern) + 1);\n\tif (!buf)\n\t\treturn 0;\n\n\t/* walk on pattern string\n\t */\n\twhile (match && !mnt_optstr_next_option(&pat, &name, &namesz,\n\t\t\t\t\t\t&patval, &patvalsz)) {\n\t\tchar *val;\n\t\tsize_t sz;\n\t\tint no = 0, rc;\n\n\t\tif (*name == '+')\n\t\t\tname++, namesz--;\n\t\telse if ((no = (startswith(name, \"no\") != NULL)))\n\t\t\tname += 2, namesz -= 2;\n\n\t\txstrncpy(buf, name, namesz + 1);\n\n\t\trc = mnt_optstr_get_option(optstr, buf, &val, &sz);\n\n\t\t/* check also value (if the pattern is \"foo=value\") */\n\t\tif (rc == 0 && patvalsz > 0 &&\n\t\t    (patvalsz != sz || strncmp(patval, val, sz) != 0))\n\t\t\trc = 1;\n\n\t\tswitch (rc) {\n\t\tcase 0:\t\t/* found */\n\t\t\tmatch = no == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 1:\t\t/* not found */\n\t\t\tmatch = no == 1 ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\t/* parse error */\n\t\t\tmatch = 0;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tfree(buf);\n\treturn match;\n}\n\n#ifdef TEST_PROGRAM\n#include \"xalloc.h\"\n\nstatic int test_append(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_append_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_prepend(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_prepend_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_split(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr, *user = NULL, *fs = NULL, *vfs = NULL;\n\tint rc;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\toptstr = xstrdup(argv[1]);\n\n\trc = mnt_split_optstr(optstr, &user, &vfs, &fs, 0, 0);\n\tif (!rc) {\n\t\tprintf(\"user : %s\\n\", user);\n\t\tprintf(\"vfs  : %s\\n\", vfs);\n\t\tprintf(\"fs   : %s\\n\", fs);\n\t}\n\n\tfree(user);\n\tfree(vfs);\n\tfree(fs);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_flags(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc;\n\tunsigned long fl = 0;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\toptstr = xstrdup(argv[1]);\n\n\trc = mnt_optstr_get_flags(optstr, &fl, mnt_get_builtin_optmap(MNT_LINUX_MAP));\n\tif (rc)\n\t\treturn rc;\n\tprintf(\"mountflags:           0x%08lx\\n\", fl);\n\n\tfl = 0;\n\trc = mnt_optstr_get_flags(optstr, &fl, mnt_get_builtin_optmap(MNT_USERSPACE_MAP));\n\tif (rc)\n\t\treturn rc;\n\tprintf(\"userspace-mountflags: 0x%08lx\\n\", fl);\n\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_apply(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc, map;\n\tunsigned long flags;\n\n\tif (argc < 4)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(argv[1], \"--user\"))\n\t\tmap = MNT_USERSPACE_MAP;\n\telse if (!strcmp(argv[1], \"--linux\"))\n\t\tmap = MNT_LINUX_MAP;\n\telse {\n\t\tfprintf(stderr, \"unknown option '%s'\\n\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\toptstr = xstrdup(argv[2]);\n\tflags = strtoul(argv[3], NULL, 16);\n\n\tprintf(\"flags:  0x%08lx\\n\", flags);\n\n\trc = mnt_optstr_apply_flags(&optstr, flags, mnt_get_builtin_optmap(map));\n\tprintf(\"optstr: %s\\n\", optstr);\n\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_set(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_set_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_get(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tconst char *name;\n\tchar *val = NULL;\n\tsize_t sz = 0;\n\tint rc;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\toptstr = argv[1];\n\tname = argv[2];\n\n\trc = mnt_optstr_get_option(optstr, name, &val, &sz);\n\tif (rc == 0) {\n\t\tprintf(\"found; name: %s\", name);\n\t\tif (sz) {\n\t\t\tprintf(\", argument: size=%zd data=\", sz);\n\t\t\tif (fwrite(val, 1, sz, stdout) != sz)\n\t\t\t\treturn -1;\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else if (rc == 1)\n\t\tprintf(\"%s: not found\\n\", name);\n\telse\n\t\tprintf(\"parse error: %s\\n\", optstr);\n\treturn rc;\n}\n\nstatic int test_remove(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\trc = mnt_optstr_remove_option(&optstr, name);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_dedup(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\trc = mnt_optstr_deduplicate_option(&optstr, name);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_fix(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc = 0;\n\tchar *name, *val, *next;\n\tsize_t valsz, namesz;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\tnext = optstr = xstrdup(argv[1]);\n\n\tprintf(\"optstr: %s\\n\", optstr);\n\n\twhile (!mnt_optstr_next_option(&next, &name, &namesz, &val, &valsz)) {\n\n\t\tif (!strncmp(name, \"uid\", 3))\n\t\t\trc = mnt_optstr_fix_uid(&optstr, val, valsz, &next);\n\t\telse if (!strncmp(name, \"gid\", 3))\n\t\t\trc = mnt_optstr_fix_gid(&optstr, val, valsz, &next);\n\t\telse if (!strncmp(name, \"context\", 7))\n\t\t\trc = mnt_optstr_fix_secontext(&optstr, val, valsz, &next);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (rc)\n\t\trc = mnt_optstr_fix_user(&optstr);\n\n\tprintf(\"fixed:  %s\\n\", optstr);\n\n\tfree(optstr);\n\treturn rc;\n\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct libmnt_test tss[] = {\n\t\t{ \"--append\", test_append, \"<optstr> <name> [<value>]  append value to optstr\" },\n\t\t{ \"--prepend\",test_prepend,\"<optstr> <name> [<value>]  prepend value to optstr\" },\n\t\t{ \"--set\",    test_set,    \"<optstr> <name> [<value>]  (un)set value\" },\n\t\t{ \"--get\",    test_get,    \"<optstr> <name>            search name in optstr\" },\n\t\t{ \"--remove\", test_remove, \"<optstr> <name>            remove name in optstr\" },\n\t\t{ \"--dedup\",  test_dedup,  \"<optstr> <name>            deduplicate name in optstr\" },\n\t\t{ \"--split\",  test_split,  \"<optstr>                   split into FS, VFS and userspace\" },\n\t\t{ \"--flags\",  test_flags,  \"<optstr>                   convert options to MS_* flags\" },\n\t\t{ \"--apply\",  test_apply,  \"--{linux,user} <optstr> <mask>    apply mask to optstr\" },\n\t\t{ \"--fix\",    test_fix,    \"<optstr>                   fix uid=, gid=, user, and context=\" },\n\n\t\t{ NULL }\n\t};\n\treturn  mnt_run_test(tss, argc, argv);\n}\n#endif /* TEST_PROGRAM */\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2010-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: context-umount\n * @title: Umount context\n * @short_description: high-level API to umount operation.\n */\n\n#include <sys/wait.h>\n#include <sys/mount.h>\n\n#include \"pathnames.h\"\n#include \"loopdev.h\"\n#include \"strutils.h\"\n#include \"mountP.h\"\n\n/*\n * umount2 flags\n */\n#ifndef MNT_FORCE\n# define MNT_FORCE        0x00000001\t/* Attempt to forcibly umount */\n#endif\n\n#ifndef MNT_DETACH\n# define MNT_DETACH       0x00000002\t/* Just detach from the tree */\n#endif\n\n#ifndef UMOUNT_NOFOLLOW\n# define UMOUNT_NOFOLLOW  0x00000008\t/* Don't follow symlink on umount */\n#endif\n\n#ifndef UMOUNT_UNUSED\n# define UMOUNT_UNUSED    0x80000000\t/* Flag guaranteed to be unused */\n#endif\n\n/* search in mountinfo/mtab */\nstatic int __mtab_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t    const char *tgt,\n\t\t\t    struct libmnt_fs **pfs)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\tstruct libmnt_table *mtab = NULL;\n\tstruct libmnt_fs *fs;\n\tchar *loopdev = NULL;\n\n\tassert(cxt);\n\tassert(tgt);\n\tassert(pfs);\n\n\t*pfs = NULL;\n\tDBG(CXT, ul_debugobj(cxt, \" search %s in mountinfo\", tgt));\n\n\t/*\n\t * The mount table may be huge, and on systems with utab we have to\n\t * merge userspace mount options into /proc/self/mountinfo. This all is\n\t * expensive. The tab filter can be used to filter out entries, then a mount\n\t * table and utab are very tiny files.\n\t *\n\t * The filter uses mnt_fs_streq_{target,srcpath} function where all\n\t * paths should be absolute and canonicalized. This is done within\n\t * mnt_context_get_mtab_for_target() where LABEL, UUID or symlinks are\n\t * canonicalized. If --no-canonicalize is enabled than the target path\n\t * is expected already canonical.\n\t *\n\t * Anyway it's better to read huge mount table than canonicalize target\n\t * paths. It means we use the filter only if --no-canonicalize enabled.\n\t *\n\t * It also means that we have to read mount table from kernel\n\t * (non-writable mtab).\n\t */\n\tif (mnt_context_is_nocanonicalize(cxt) &&\n\t    !mnt_context_mtab_writable(cxt) && *tgt == '/')\n\t\trc = mnt_context_get_mtab_for_target(cxt, &mtab, tgt);\n\telse\n\t\trc = mnt_context_get_mtab(cxt, &mtab);\n\n\tif (rc) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: failed to read mtab\"));\n\t\treturn rc;\n\t}\n\n\tif (mnt_table_get_nents(mtab) == 0) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: mtab empty\"));\n\t\treturn 1;\n\t}\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\ntry_loopdev:\n\tfs = mnt_table_find_target(mtab, tgt, MNT_ITER_BACKWARD);\n\tif (!fs && mnt_context_is_swapmatch(cxt)) {\n\t\t/*\n\t\t * Maybe the option is source rather than target (sometimes\n\t\t * people use e.g. \"umount /dev/sda1\")\n\t\t */\n\t\tfs = mnt_table_find_source(mtab, tgt, MNT_ITER_BACKWARD);\n\n\t\tif (fs) {\n\t\t\tstruct libmnt_fs *fs1 = mnt_table_find_target(mtab,\n\t\t\t\t\t\t\tmnt_fs_get_target(fs),\n\t\t\t\t\t\t\tMNT_ITER_BACKWARD);\n\t\t\tif (!fs1) {\n\t\t\t\tDBG(CXT, ul_debugobj(cxt, \"mtab is broken?!?!\"));\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (fs != fs1) {\n\t\t\t\t/* Something was stacked over `file' on the\n\t\t\t\t * same mount point. */\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\t\"umount: %s: %s is mounted \"\n\t\t\t\t\t\t\"over it on the same point\",\n\t\t\t\t\t\ttgt, mnt_fs_get_source(fs1)));\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!fs && !loopdev && mnt_context_is_swapmatch(cxt)) {\n\t\t/*\n\t\t * Maybe the option is /path/file.img, try to convert to /dev/loopN\n\t\t */\n\t\tstruct stat st;\n\n\t\tif (mnt_stat_mountpoint(tgt, &st) == 0 && S_ISREG(st.st_mode)) {\n\t\t\tint count;\n\t\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\t\tconst char *bf = cache ? mnt_resolve_path(tgt, cache) : tgt;\n\n\t\t\tcount = loopdev_count_by_backing_file(bf, &loopdev);\n\t\t\tif (count == 1) {\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount: %s --> %s (retry)\", tgt, loopdev));\n\t\t\t\ttgt = loopdev;\n\t\t\t\tgoto try_loopdev;\n\n\t\t\t} else if (count > 1)\n\t\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount: warning: %s is associated \"\n\t\t\t\t\t\"with more than one loopdev\", tgt));\n\t\t}\n\t}\n\n\t*pfs = fs;\n\tfree(loopdev);\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount fs: %s\", fs ? mnt_fs_get_target(fs) :\n\t\t\t\t\t\t\t\"<not found>\"));\n\treturn fs ? 0 : 1;\nerr:\n\tfree(loopdev);\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\treturn rc;\n}\n\n/**\n * mnt_context_find_umount_fs:\n * @cxt: mount context\n * @tgt: mountpoint, device, ...\n * @pfs: returns point to filesystem\n *\n * Returns: 0 on success, <0 on error, 1 if target filesystem not found\n */\nint mnt_context_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t       const char *tgt,\n\t\t\t       struct libmnt_fs **pfs)\n{\n\tif (pfs)\n\t\t*pfs = NULL;\n\n\tif (!cxt || !tgt || !pfs)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: lookup FS for '%s'\", tgt));\n\n\tif (!*tgt)\n\t\treturn 1; /* empty string is not an error */\n\n\t/* In future this function should be extended to support for example\n\t * fsinfo() (or another cheap way kernel will support), for now the\n\t * default is expensive mountinfo/mtab.\n\t */\n\treturn __mtab_find_umount_fs(cxt, tgt, pfs);\n}\n\n/* Check if there is something important in the utab file. The parsed utab is\n * stored in context->utab and deallocated by mnt_free_context().\n *\n * This function exists to avoid (if possible) /proc/self/mountinfo usage, so\n * don't use things like mnt_resolve_target(), mnt_context_get_mtab() etc here.\n * See lookup_umount_fs() for more details.\n */\nstatic int has_utab_entry(struct libmnt_context *cxt, const char *target)\n{\n\tstruct libmnt_cache *cache = NULL;\n\tstruct libmnt_fs *fs;\n\tstruct libmnt_iter itr;\n\tchar *cn = NULL;\n\tint rc = 0;\n\n\tassert(cxt);\n\n\tif (!cxt->utab) {\n\t\tconst char *path = mnt_get_utab_path();\n\n\t\tif (!path || is_file_empty(path))\n\t\t\treturn 0;\n\t\tcxt->utab = mnt_new_table();\n\t\tif (!cxt->utab)\n\t\t\treturn 0;\n\t\tcxt->utab->fmt = MNT_FMT_UTAB;\n\t\tif (mnt_table_parse_file(cxt->utab, path))\n\t\t\treturn 0;\n\t}\n\n\t/* paths in utab are canonicalized */\n\tcache = mnt_context_get_cache(cxt);\n\tcn = mnt_resolve_path(target, cache);\n\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\twhile (mnt_table_next_fs(cxt->utab, &itr, &fs) == 0) {\n\t\tif (mnt_fs_streq_target(fs, cn)) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cache)\n\t\tfree(cn);\n\treturn rc;\n}\n\n/* returns: 1 not found; <0 on error; 1 success */\nstatic int lookup_umount_fs_by_statfs(struct libmnt_context *cxt, const char *tgt)\n{\n\tstruct stat st;\n\tconst char *type;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \" lookup by statfs\"));\n\n\t/*\n\t * Let's try to avoid mountinfo usage at all to minimize performance\n\t * degradation. Don't forget that kernel has to compose *whole*\n\t * mountinfo about all mountpoints although we look for only one entry.\n\t *\n\t * All we need is fstype and to check if there is no userspace mount\n\t * options for the target (e.g. helper=udisks to call /sbin/umount.udisks).\n\t *\n\t * So, let's use statfs() if possible (it's bad idea for --lazy/--force\n\t * umounts as target is probably unreachable NFS, also for --detach-loop\n\t * as this additionally needs to know the name of the loop device).\n\t */\n\tif (mnt_context_is_restricted(cxt)\n\t    || *tgt != '/'\n\t    || (cxt->flags & MNT_FL_HELPER)\n\t    || mnt_context_mtab_writable(cxt)\n\t    || mnt_context_is_force(cxt)\n\t    || mnt_context_is_lazy(cxt)\n\t    || mnt_context_is_nocanonicalize(cxt)\n\t    || mnt_context_is_loopdel(cxt)\n\t    || mnt_stat_mountpoint(tgt, &st) != 0 || !S_ISDIR(st.st_mode)\n\t    || has_utab_entry(cxt, tgt))\n\t\treturn 1; /* not found */\n\n\ttype = mnt_fs_get_fstype(cxt->fs);\n\tif (!type) {\n\t\tstruct statfs vfs;\n\t\tint fd;\n\n\t\tDBG(CXT, ul_debugobj(cxt, \"  trying fstatfs()\"));\n\n\t\t/* O_PATH avoids triggering automount points. */\n\t\tfd = open(tgt, O_PATH);\n\t\tif (fd >= 0) {\n\t\t\tif (fstatfs(fd, &vfs) == 0)\n\t\t\t\ttype = mnt_statfs_get_fstype(&vfs);\n\t\t\tclose(fd);\n\t\t}\n\t\tif (type) {\n\t\t\tint rc = mnt_fs_set_fstype(cxt->fs, type);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\tif (type) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"  umount: disabling mtab\"));\n\t\tmnt_context_disable_mtab(cxt, TRUE);\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"  mountinfo unnecessary [type=%s]\", type));\n\t\treturn 0;\n\t}\n\n\treturn 1; /* not found */\n}\n\n/* returns: 1 not found; <0 on error; 1 success */\nstatic int lookup_umount_fs_by_mountinfo(struct libmnt_context *cxt, const char *tgt)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tint rc;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \" lookup by mountinfo\"));\n\n\t/* search */\n\trc = __mtab_find_umount_fs(cxt, tgt, &fs);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* apply result */\n\tif (fs != cxt->fs) {\n\t\tmnt_fs_set_source(cxt->fs, NULL);\n\t\tmnt_fs_set_target(cxt->fs, NULL);\n\n\t\tif (!mnt_copy_fs(cxt->fs, fs)) {\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"  failed to copy FS\"));\n\t\t\treturn -errno;\n\t\t}\n\t\tDBG(CXT, ul_debugobj(cxt, \"  mtab applied\"));\n\t}\n\n\tcxt->flags |= MNT_FL_TAB_APPLIED;\n\treturn 0;\n}\n\n/* This finction search for FS according to cxt->fs->target,\n * apply result to cxt->fs and it's umount replacement to\n * mnt_context_apply_fstab(), use mnt_context_tab_applied()\n * to check result.\n *\n * The goal is to minimize situations when we need to parse\n * /proc/self/mountinfo.\n */\nstatic int lookup_umount_fs(struct libmnt_context *cxt)\n{\n\tconst char *tgt;\n\tint rc = 0;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: lookup FS\"));\n\n\ttgt = mnt_fs_get_target(cxt->fs);\n\tif (!tgt) {\n\t\tDBG(CXT, ul_debugobj(cxt, \" undefined target\"));\n\t\treturn -EINVAL;\n\t}\n\n\t/* try get fs type by statfs() */\n\trc = lookup_umount_fs_by_statfs(cxt, tgt);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\t/* get complete fs from fs entry from mountinfo */\n\trc = lookup_umount_fs_by_mountinfo(cxt, tgt);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tDBG(CXT, ul_debugobj(cxt, \" cannot find '%s'\", tgt));\n\treturn 0;\t/* this is correct! */\n}\n\n/* check if @devname is loopdev and if the device is associated\n * with a source from @fstab_fs\n */\nstatic int is_associated_fs(const char *devname, struct libmnt_fs *fs)\n{\n\tuintmax_t offset = 0;\n\tconst char *src, *optstr;\n\tchar *val;\n\tsize_t valsz;\n\tint flags = 0;\n\n\t/* check if it begins with /dev/loop */\n\tif (strncmp(devname, _PATH_DEV_LOOP, sizeof(_PATH_DEV_LOOP) - 1) != 0)\n\t\treturn 0;\n\n\tsrc = mnt_fs_get_srcpath(fs);\n\tif (!src)\n\t\treturn 0;\n\n\t/* check for the offset option in @fs */\n\toptstr = mnt_fs_get_user_options(fs);\n\n\tif (optstr &&\n\t    mnt_optstr_get_option(optstr, \"offset\", &val, &valsz) == 0) {\n\t\tflags |= LOOPDEV_FL_OFFSET;\n\n\t\tif (mnt_parse_offset(val, valsz, &offset) != 0)\n\t\t\treturn 0;\n\t}\n\n\treturn loopdev_is_used(devname, src, offset, 0, flags);\n}\n\nstatic int prepare_helper_from_options(struct libmnt_context *cxt,\n\t\t\t\t       const char *name)\n{\n\tchar *suffix = NULL;\n\tconst char *opts;\n\tsize_t valsz;\n\tint rc;\n\n\tif (mnt_context_is_nohelpers(cxt))\n\t\treturn 0;\n\n\topts = mnt_fs_get_user_options(cxt->fs);\n\tif (!opts)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(opts, name, &suffix, &valsz))\n\t\treturn 0;\n\n\tsuffix = strndup(suffix, valsz);\n\tif (!suffix)\n\t\treturn -ENOMEM;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: umount.%s %s requested\", suffix, name));\n\n\trc = mnt_context_prepare_helper(cxt, \"umount\", suffix);\n\tfree(suffix);\n\n\treturn rc;\n}\n\nstatic int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tuid_t uid, entry_uid;\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\treturn uid == entry_uid;\n}\n\n/*\n * Note that cxt->fs contains relevant mtab entry!\n */\nstatic int evaluate_permissions(struct libmnt_context *cxt)\n{\n\tstruct libmnt_table *fstab;\n\tunsigned long u_flags = 0;\n\tconst char *tgt, *src, *optstr;\n\tint rc = 0, ok = 0;\n\tstruct libmnt_fs *fs;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\tif (!mnt_context_is_restricted(cxt))\n\t\t return 0;\t\t/* superuser mount */\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: evaluating permissions\"));\n\n\tif (!mnt_context_tab_applied(cxt)) {\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"cannot find %s in mtab and you are not root\",\n\t\t\t\tmnt_fs_get_target(cxt->fs)));\n\t\tgoto eperm;\n\t}\n\n\tif (cxt->user_mountflags & MNT_MS_UHELPER) {\n\t\t/* on uhelper= mount option based helper */\n\t\trc = prepare_helper_from_options(cxt, \"uhelper\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (cxt->helper)\n\t\t\treturn 0;\t/* we'll call /sbin/umount.<uhelper> */\n\t}\n\n\t/*\n\t * Check if this is a fuse mount for the current user,\n\t * if so then unmounting is allowed\n\t */\n\tif (is_fuse_usermount(cxt, &rc)) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"fuse user mount, umount is allowed\"));\n\t\treturn 0;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * User mounts have to be in /etc/fstab\n\t */\n\trc = mnt_context_get_fstab(cxt, &fstab);\n\tif (rc)\n\t\treturn rc;\n\n\ttgt = mnt_fs_get_target(cxt->fs);\n\tsrc = mnt_fs_get_source(cxt->fs);\n\n\tif (mnt_fs_get_bindsrc(cxt->fs)) {\n\t\tsrc = mnt_fs_get_bindsrc(cxt->fs);\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"umount: using bind source: %s\", src));\n\t}\n\n\t/* If fstab contains the two lines\n\t *\t/dev/sda1 /mnt/zip auto user,noauto  0 0\n\t *\t/dev/sda4 /mnt/zip auto user,noauto  0 0\n\t * then \"mount /dev/sda4\" followed by \"umount /mnt/zip\" used to fail.\n\t * So, we must not look for the file, but for the pair (dev,file) in fstab.\n\t  */\n\tfs = mnt_table_find_pair(fstab, src, tgt, MNT_ITER_FORWARD);\n\tif (!fs) {\n\t\t/*\n\t\t * It's possible that there is /path/file.img in fstab and\n\t\t * /dev/loop0 in mtab -- then we have to check the relation\n\t\t * between loopdev and the file.\n\t\t */\n\t\tfs = mnt_table_find_target(fstab, tgt, MNT_ITER_FORWARD);\n\t\tif (fs) {\n\t\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\t\tconst char *sp = mnt_fs_get_srcpath(cxt->fs);\t\t/* devname from mtab */\n\t\t\tconst char *dev = sp && cache ? mnt_resolve_path(sp, cache) : sp;\n\n\t\t\tif (!dev || !is_associated_fs(dev, fs))\n\t\t\t\tfs = NULL;\n\t\t}\n\t\tif (!fs) {\n\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\t\"umount %s: mtab disagrees with fstab\",\n\t\t\t\t\ttgt));\n\t\t\tgoto eperm;\n\t\t}\n\t}\n\n\t/*\n\t * User mounting and unmounting is allowed only if fstab contains one\n\t * of the options `user', `users' or `owner' or `group'.\n\t *\n\t * The option `users' allows arbitrary users to mount and unmount -\n\t * this may be a security risk.\n\t *\n\t * The options `user', `owner' and `group' only allow unmounting by the\n\t * user that mounted (visible in mtab).\n\t */\n\toptstr = mnt_fs_get_user_options(fs);\t/* FSTAB mount options! */\n\tif (!optstr)\n\t\tgoto eperm;\n\n\tif (mnt_optstr_get_flags(optstr, &u_flags,\n\t\t\t\tmnt_get_builtin_optmap(MNT_USERSPACE_MAP)))\n\t\tgoto eperm;\n\n\tif (u_flags & MNT_MS_USERS) {\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"umount: promiscuous setting ('users') in fstab\"));\n\t\treturn 0;\n\t}\n\t/*\n\t * Check user=<username> setting from mtab if there is a user, owner or\n\t * group option in /etc/fstab\n\t */\n\tif (u_flags & (MNT_MS_USER | MNT_MS_OWNER | MNT_MS_GROUP)) {\n\n\t\tchar *curr_user;\n\t\tchar *mtab_user = NULL;\n\t\tsize_t sz;\n\t\tstruct libmnt_ns *ns_old;\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"umount: checking user=<username> from mtab\"));\n\n\t\tns_old = mnt_context_switch_origin_ns(cxt);\n\t\tif (!ns_old)\n\t\t\treturn -MNT_ERR_NAMESPACE;\n\n\t\tcurr_user = mnt_get_username(getuid());\n\n\t\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t\tfree(curr_user);\n\t\t\treturn -MNT_ERR_NAMESPACE;\n\t\t}\n\t\tif (!curr_user) {\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"umount %s: cannot \"\n\t\t\t\t\"convert %d to username\", tgt, getuid()));\n\t\t\tgoto eperm;\n\t\t}\n\n\t\t/* get options from mtab */\n\t\toptstr = mnt_fs_get_user_options(cxt->fs);\n\t\tif (optstr && !mnt_optstr_get_option(optstr,\n\t\t\t\t\t\"user\", &mtab_user, &sz) && sz)\n\t\t\tok = !strncmp(curr_user, mtab_user, sz);\n\n\t\tfree(curr_user);\n\t}\n\n\tif (ok) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount %s is allowed\", tgt));\n\t\treturn 0;\n\t}\neperm:\n\tDBG(CXT, ul_debugobj(cxt, \"umount is not allowed for you\"));\n\treturn -EPERM;\n}\n\nstatic int exec_helper(struct libmnt_context *cxt)\n{\n\tchar *namespace = NULL;\n\tstruct libmnt_ns *ns_tgt = mnt_context_get_target_ns(cxt);\n\tint rc;\n\tpid_t pid;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\tassert(cxt->helper_exec_status == 1);\n\n\tif (mnt_context_is_fake(cxt)) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"fake mode: does not execute helper\"));\n\t\tcxt->helper_exec_status = rc = 0;\n\t\treturn rc;\n\t}\n\n\tif (ns_tgt->fd != -1\n\t    && asprintf(&namespace, \"/proc/%i/fd/%i\",\n\t\t\tgetpid(), ns_tgt->fd) == -1) {\n\t\treturn -ENOMEM;\n\t}\n\n\tDBG_FLUSH;\n\n\tpid = fork();\n\tswitch (pid) {\n\tcase 0:\n\t{\n\t\tconst char *args[12], *type;\n\t\tint i = 0;\n\n\t\tif (drop_permissions() != 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\tif (!mnt_context_switch_origin_ns(cxt))\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\ttype = mnt_fs_get_fstype(cxt->fs);\n\n\t\targs[i++] = cxt->helper;\t\t\t/* 1 */\n\t\targs[i++] = mnt_fs_get_target(cxt->fs);\t\t/* 2 */\n\n\t\tif (mnt_context_is_nomtab(cxt))\n\t\t\targs[i++] = \"-n\";\t\t\t/* 3 */\n\t\tif (mnt_context_is_lazy(cxt))\n\t\t\targs[i++] = \"-l\";\t\t\t/* 4 */\n\t\tif (mnt_context_is_force(cxt))\n\t\t\targs[i++] = \"-f\";\t\t\t/* 5 */\n\t\tif (mnt_context_is_verbose(cxt))\n\t\t\targs[i++] = \"-v\";\t\t\t/* 6 */\n\t\tif (mnt_context_is_rdonly_umount(cxt))\n\t\t\targs[i++] = \"-r\";\t\t\t/* 7 */\n\t\tif (type\n\t\t    && strchr(type, '.')\n\t\t    && !endswith(cxt->helper, type)) {\n\t\t\targs[i++] = \"-t\";\t\t\t/* 8 */\n\t\t\targs[i++] = type;\t\t\t/* 9 */\n\t\t}\n\t\tif (namespace) {\n\t\t\targs[i++] = \"-N\";\t\t\t/* 10 */\n\t\t\targs[i++] = namespace;\t\t\t/* 11 */\n\t\t}\n\n\t\targs[i] = NULL;\t\t\t\t\t/* 12 */\n\t\tfor (i = 0; args[i]; i++)\n\t\t\tDBG(CXT, ul_debugobj(cxt, \"argv[%d] = \\\"%s\\\"\",\n\t\t\t\t\t\t\ti, args[i]));\n\t\tDBG_FLUSH;\n\t\texecv(cxt->helper, (char * const *) args);\n\t\t_exit(EXIT_FAILURE);\n\t}\n\tdefault:\n\t{\n\t\tint st;\n\n\t\tif (waitpid(pid, &st, 0) == (pid_t) -1) {\n\t\t\tcxt->helper_status = -1;\n\t\t\trc = -errno;\n\t\t} else {\n\t\t\tcxt->helper_status = WIFEXITED(st) ? WEXITSTATUS(st) : -1;\n\t\t\tcxt->helper_exec_status = rc = 0;\n\t\t}\n\t\tDBG(CXT, ul_debugobj(cxt, \"%s executed [status=%d, rc=%d%s]\",\n\t\t\t\tcxt->helper,\n\t\t\t\tcxt->helper_status, rc,\n\t\t\t\trc ? \" waitpid failed\" : \"\"));\n\t\tbreak;\n\t}\n\n\tcase -1:\n\t\tcxt->helper_exec_status = rc = -errno;\n\t\tDBG(CXT, ul_debugobj(cxt, \"fork() failed\"));\n\t\tbreak;\n\t}\n\n\tfree(namespace);\n\treturn rc;\n}\n\n/*\n * mnt_context_helper_setopt() backend.\n *\n * This function applies umount.type command line option (for example parsed\n * by getopt() or getopt_long()) to @cxt. All unknown options are ignored and\n * then 1 is returned.\n *\n * Returns: negative number on error, 1 if @c is unknown option, 0 on success.\n */\nint mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg)\n{\n\tint rc = -EINVAL;\n\n\tassert(cxt);\n\tassert(cxt->action == MNT_ACT_UMOUNT);\n\n\tswitch(c) {\n\tcase 'n':\n\t\trc = mnt_context_disable_mtab(cxt, TRUE);\n\t\tbreak;\n\tcase 'l':\n\t\trc = mnt_context_enable_lazy(cxt, TRUE);\n\t\tbreak;\n\tcase 'f':\n\t\trc = mnt_context_enable_force(cxt, TRUE);\n\t\tbreak;\n\tcase 'v':\n\t\trc = mnt_context_enable_verbose(cxt, TRUE);\n\t\tbreak;\n\tcase 'r':\n\t\trc = mnt_context_enable_rdonly_umount(cxt, TRUE);\n\t\tbreak;\n\tcase 't':\n\t\tif (arg)\n\t\t\trc = mnt_context_set_fstype(cxt, arg);\n\t\tbreak;\n\tcase 'N':\n\t\tif (arg)\n\t\t\trc = mnt_context_set_target_ns(cxt, arg);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn rc;\n}\n\n/* Check whether the kernel supports the UMOUNT_NOFOLLOW flag */\nstatic int umount_nofollow_support(void)\n{\n\tint res = umount2(\"\", UMOUNT_UNUSED);\n\tif (res != -1 || errno != EINVAL)\n\t\treturn 0;\n\n\tres = umount2(\"\", UMOUNT_NOFOLLOW);\n\tif (res != -1 || errno != ENOENT)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int do_umount(struct libmnt_context *cxt)\n{\n\tint rc = 0, flags = 0;\n\tconst char *src, *target;\n\tchar *tgtbuf = NULL;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\tassert(cxt->syscall_status == 1);\n\n\tif (cxt->helper)\n\t\treturn exec_helper(cxt);\n\n\tsrc = mnt_fs_get_srcpath(cxt->fs);\n\ttarget = mnt_fs_get_target(cxt->fs);\n\n\tif (!target)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debugobj(cxt, \"do umount\"));\n\n\tif (mnt_context_is_restricted(cxt) && !mnt_context_is_fake(cxt)) {\n\t\t/*\n\t\t * extra paranoia for non-root users\n\t\t * -- chdir to the parent of the mountpoint and use NOFOLLOW\n\t\t *    flag to avoid races and symlink attacks.\n\t\t */\n\t\tif (umount_nofollow_support())\n\t\t\tflags |= UMOUNT_NOFOLLOW;\n\n\t\trc = mnt_chdir_to_parent(target, &tgtbuf);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\ttarget = tgtbuf;\n\t}\n\n\tif (mnt_context_is_lazy(cxt))\n\t\tflags |= MNT_DETACH;\n\n\tif (mnt_context_is_force(cxt))\n\t\tflags |= MNT_FORCE;\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount(2) [target='%s', flags=0x%08x]%s\",\n\t\t\t\ttarget, flags,\n\t\t\t\tmnt_context_is_fake(cxt) ? \" (FAKE)\" : \"\"));\n\n\tif (mnt_context_is_fake(cxt))\n\t\trc = 0;\n\telse {\n\t\trc = flags ? umount2(target, flags) : umount(target);\n\t\tif (rc < 0)\n\t\t\tcxt->syscall_status = -errno;\n\t\tfree(tgtbuf);\n\t}\n\n\t/*\n\t * try remount read-only\n\t */\n\tif (rc < 0\n\t    && cxt->syscall_status == -EBUSY\n\t    && mnt_context_is_rdonly_umount(cxt)\n\t    && src) {\n\n\t\tmnt_context_set_mflags(cxt, (cxt->mountflags |\n\t\t\t\t\t     MS_REMOUNT | MS_RDONLY));\n\t\tmnt_context_enable_loopdel(cxt, FALSE);\n\n\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\"umount(2) failed [errno=%d] -- trying to remount read-only\",\n\t\t\t-cxt->syscall_status));\n\n\t\trc = mount(src, mnt_fs_get_target(cxt->fs), NULL,\n\t\t\t    MS_REMOUNT | MS_RDONLY, NULL);\n\t\tif (rc < 0) {\n\t\t\tcxt->syscall_status = -errno;\n\t\t\tDBG(CXT, ul_debugobj(cxt,\n\t\t\t\t\"read-only re-mount(2) failed [errno=%d]\",\n\t\t\t\t-cxt->syscall_status));\n\n\t\t\treturn -cxt->syscall_status;\n\t\t}\n\t\tcxt->syscall_status = 0;\n\t\tDBG(CXT, ul_debugobj(cxt, \"read-only re-mount(2) success\"));\n\t\treturn 0;\n\t}\n\n\tif (rc < 0) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount(2) failed [errno=%d]\",\n\t\t\t-cxt->syscall_status));\n\t\treturn -cxt->syscall_status;\n\t}\n\n\tcxt->syscall_status = 0;\n\tDBG(CXT, ul_debugobj(cxt, \"umount(2) success\"));\n\treturn 0;\n}\n\n/**\n * mnt_context_prepare_umount:\n * @cxt: mount context\n *\n * Prepare context for umounting, unnecessary for mnt_context_umount().\n *\n * Returns: 0 on success, and negative number in case of error.\n */\nint mnt_context_prepare_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tif (!cxt || !cxt->fs || mnt_fs_is_swaparea(cxt->fs))\n\t\treturn -EINVAL;\n\tif (!mnt_context_get_source(cxt) && !mnt_context_get_target(cxt))\n\t\treturn -EINVAL;\n\tif (cxt->flags & MNT_FL_PREPARED)\n\t\treturn 0;\n\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\n\tfree(cxt->helper);\t/* be paranoid */\n\tcxt->helper = NULL;\n\tcxt->action = MNT_ACT_UMOUNT;\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = lookup_umount_fs(cxt);\n\tif (!rc)\n\t\trc = mnt_context_merge_mflags(cxt);\n\tif (!rc)\n\t\trc = evaluate_permissions(cxt);\n\n\tif (!rc && !cxt->helper) {\n\n\t\tif (cxt->user_mountflags & MNT_MS_HELPER)\n\t\t\t/* on helper= mount option based helper */\n\t\t\trc = prepare_helper_from_options(cxt, \"helper\");\n\n\t\tif (!rc && !cxt->helper)\n\t\t\t/* on fstype based helper */\n\t\t\trc = mnt_context_prepare_helper(cxt, \"umount\", NULL);\n\t}\n\n\tif (!rc && (cxt->user_mountflags & MNT_MS_LOOP))\n\t\t/* loop option explicitly specified in mtab, detach this loop */\n\t\tmnt_context_enable_loopdel(cxt, TRUE);\n\n\tif (!rc && mnt_context_is_loopdel(cxt) && cxt->fs) {\n\t\tconst char *src = mnt_fs_get_srcpath(cxt->fs);\n\n\t\tif (src && (!is_loopdev(src) || loopdev_is_autoclear(src)))\n\t\t\tmnt_context_enable_loopdel(cxt, FALSE);\n\t}\n\n\tif (rc) {\n\t\tDBG(CXT, ul_debugobj(cxt, \"umount: preparing failed\"));\n\t\treturn rc;\n\t}\n\tcxt->flags |= MNT_FL_PREPARED;\n\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n/**\n * mnt_context_do_umount:\n * @cxt: mount context\n *\n * Umount filesystem by umount(2) or fork()+exec(/sbin/umount.type).\n * Unnecessary for mnt_context_umount().\n *\n * See also mnt_context_disable_helpers().\n *\n * WARNING: non-zero return code does not mean that umount(2) syscall or\n *          umount.type helper wasn't successfully called.\n *\n *          Check mnt_context_get_status() after error!\n*\n * Returns: 0 on success;\n *         >0 in case of umount(2) error (returns syscall errno),\n *         <0 in case of other errors.\n */\nint mnt_context_do_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\tassert((cxt->flags & MNT_FL_PREPARED));\n\tassert((cxt->action == MNT_ACT_UMOUNT));\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = do_umount(cxt);\n\tif (rc)\n\t\tgoto end;\n\n\tif (mnt_context_get_status(cxt) && !mnt_context_is_fake(cxt)) {\n\t\t/*\n\t\t * Umounted, do some post-umount operations\n\t\t *\t- remove loopdev\n\t\t *\t- refresh in-memory mtab stuff if remount rather than\n\t\t *\t  umount has been performed\n\t\t */\n\t\tif (mnt_context_is_loopdel(cxt)\n\t\t    && !(cxt->mountflags & MS_REMOUNT))\n\t\t\trc = mnt_context_delete_loopdev(cxt);\n\n\t\tif (!mnt_context_is_nomtab(cxt)\n\t\t    && mnt_context_get_status(cxt)\n\t\t    && !cxt->helper\n\t\t    && mnt_context_is_rdonly_umount(cxt)\n\t\t    && (cxt->mountflags & MS_REMOUNT)) {\n\n\t\t\t/* use \"remount\" instead of \"umount\" in /etc/mtab */\n\t\t\tif (!rc && cxt->update && mnt_context_mtab_writable(cxt))\n\t\t\t\trc = mnt_update_set_fs(cxt->update,\n\t\t\t\t\t\t       cxt->mountflags, NULL, cxt->fs);\n\t\t}\n\t}\nend:\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n/**\n * mnt_context_finalize_umount:\n * @cxt: context\n *\n * Mtab update, etc. Unnecessary for mnt_context_umount(), but should be called\n * after mnt_context_do_umount(). See also mnt_context_set_syscall_status().\n *\n * Returns: negative number on error, 0 on success.\n */\nint mnt_context_finalize_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert((cxt->flags & MNT_FL_PREPARED));\n\tassert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));\n\n\trc = mnt_context_prepare_update(cxt);\n\tif (!rc)\n\t\trc = mnt_context_update_tabs(cxt);\n\treturn rc;\n}\n\n\n/**\n * mnt_context_umount:\n * @cxt: umount context\n *\n * High-level, umounts filesystem by umount(2) or fork()+exec(/sbin/umount.type).\n *\n * This is similar to:\n *\n *\tmnt_context_prepare_umount(cxt);\n *\tmnt_context_do_umount(cxt);\n *\tmnt_context_finalize_umount(cxt);\n *\n * See also mnt_context_disable_helpers().\n *\n * WARNING: non-zero return code does not mean that umount(2) syscall or\n *          umount.type helper wasn't successfully called.\n *\n *          Check mnt_context_get_status() after error!\n *\n * Returns: 0 on success;\n *         >0 in case of umount(2) error (returns syscall errno),\n *         <0 in case of other errors.\n */\nint mnt_context_umount(struct libmnt_context *cxt)\n{\n\tint rc;\n\tstruct libmnt_ns *ns_old;\n\n\tassert(cxt);\n\tassert(cxt->fs);\n\tassert(cxt->helper_exec_status == 1);\n\tassert(cxt->syscall_status == 1);\n\n\tDBG(CXT, ul_debugobj(cxt, \"umount: %s\", mnt_context_get_target(cxt)));\n\n\tns_old = mnt_context_switch_target_ns(cxt);\n\tif (!ns_old)\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\trc = mnt_context_prepare_umount(cxt);\n\tif (!rc)\n\t\trc = mnt_context_prepare_update(cxt);\n\tif (!rc)\n\t\trc = mnt_context_do_umount(cxt);\n\tif (!rc)\n\t\trc = mnt_context_update_tabs(cxt);\n\n\tif (!mnt_context_switch_ns(cxt, ns_old))\n\t\treturn -MNT_ERR_NAMESPACE;\n\n\treturn rc;\n}\n\n\n/**\n * mnt_context_next_umount:\n * @cxt: context\n * @itr: iterator\n * @fs: returns the current filesystem\n * @mntrc: returns the return code from mnt_context_umount()\n * @ignored: returns 1 for not matching\n *\n * This function tries to umount the next filesystem from mtab (as returned by\n * mnt_context_get_mtab()).\n *\n * You can filter out filesystems by:\n *\tmnt_context_set_options_pattern() to simulate umount -a -O pattern\n *\tmnt_context_set_fstype_pattern()  to simulate umount -a -t pattern\n *\n * If the filesystem is not mounted or does not match the defined criteria,\n * then the function mnt_context_next_umount() returns zero, but the @ignored is\n * non-zero. Note that the root filesystem is always ignored.\n *\n * If umount(2) syscall or umount.type helper failed, then the\n * mnt_context_next_umount() function returns zero, but the @mntrc is non-zero.\n * Use also mnt_context_get_status() to check if the filesystem was\n * successfully umounted.\n *\n * Returns: 0 on success,\n *         <0 in case of error (!= umount(2) errors)\n *          1 at the end of the list.\n */\nint mnt_context_next_umount(struct libmnt_context *cxt,\n\t\t\t   struct libmnt_iter *itr,\n\t\t\t   struct libmnt_fs **fs,\n\t\t\t   int *mntrc,\n\t\t\t   int *ignored)\n{\n\tstruct libmnt_table *mtab;\n\tconst char *tgt;\n\tint rc;\n\n\tif (ignored)\n\t\t*ignored = 0;\n\tif (mntrc)\n\t\t*mntrc = 0;\n\n\tif (!cxt || !fs || !itr)\n\t\treturn -EINVAL;\n\n\trc = mnt_context_get_mtab(cxt, &mtab);\n\tcxt->mtab = NULL;\t\t/* do not reset mtab */\n\tmnt_reset_context(cxt);\n\n\tif (rc)\n\t\treturn rc;\n\n\tcxt->mtab = mtab;\n\n\tdo {\n\t\trc = mnt_table_next_fs(mtab, itr, fs);\n\t\tif (rc != 0)\n\t\t\treturn rc;\t/* no more filesystems (or error) */\n\n\t\ttgt = mnt_fs_get_target(*fs);\n\t} while (!tgt);\n\n\tDBG(CXT, ul_debugobj(cxt, \"next-umount: trying %s [fstype: %s, t-pattern: %s, options: %s, O-pattern: %s]\", tgt,\n\t\t\t\t mnt_fs_get_fstype(*fs), cxt->fstype_pattern, mnt_fs_get_options(*fs), cxt->optstr_pattern));\n\n\t/* ignore filesystems which don't match options patterns */\n\tif ((cxt->fstype_pattern && !mnt_fs_match_fstype(*fs,\n\t\t\t\t\tcxt->fstype_pattern)) ||\n\n\t/* ignore filesystems which don't match type patterns */\n\t   (cxt->optstr_pattern && !mnt_fs_match_options(*fs,\n\t\t\t\t\tcxt->optstr_pattern))) {\n\t\tif (ignored)\n\t\t\t*ignored = 1;\n\n\t\tDBG(CXT, ul_debugobj(cxt, \"next-umount: not-match\"));\n\t\treturn 0;\n\t}\n\n\trc = mnt_context_set_fs(cxt, *fs);\n\tif (rc)\n\t\treturn rc;\n\trc = mnt_context_umount(cxt);\n\tif (mntrc)\n\t\t*mntrc = rc;\n\treturn 0;\n}\n\n\nint mnt_context_get_umount_excode(\n\t\t\tstruct libmnt_context *cxt,\n\t\t\tint rc,\n\t\t\tchar *buf,\n\t\t\tsize_t bufsz)\n{\n\tif (mnt_context_helper_executed(cxt))\n\t\t/*\n\t\t * /sbin/umount.<type> called, return status\n\t\t */\n\t\treturn mnt_context_get_helper_status(cxt);\n\n\tif (rc == 0 && mnt_context_get_status(cxt) == 1)\n\t\t/*\n\t\t * Libmount success && syscall success.\n\t\t */\n\t\treturn MNT_EX_SUCCESS;\n\n\tif (!mnt_context_syscall_called(cxt)) {\n\t\t/*\n\t\t * libmount errors (extra library checks)\n\t\t */\n\t\tif (rc == -EPERM && !mnt_context_tab_applied(cxt)) {\n\t\t\t/* failed to evaluate permissions because not found\n\t\t\t * relevant entry in mtab */\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"not mounted\"));\n\t\t\treturn MNT_EX_USAGE;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_LOCK) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"locking failed\"));\n\t\t\treturn MNT_EX_FILEIO;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_NAMESPACE) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"failed to switch namespace\"));\n\t\t\treturn MNT_EX_SYSERR;\n\t\t}\n\t\treturn mnt_context_get_generic_excode(rc, buf, bufsz,\n\t\t\t\t\t_(\"umount failed: %m\"));\n\n\t} if (mnt_context_get_syscall_errno(cxt) == 0) {\n\t\t/*\n\t\t * umount(2) syscall success, but something else failed\n\t\t * (probably error in mtab processing).\n\t\t */\n\t\tif (rc == -MNT_ERR_LOCK) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"filesystem was unmounted, but failed to update userspace mount table\"));\n\t\t\treturn MNT_EX_FILEIO;\n\t\t}\n\n\t\tif (rc == -MNT_ERR_NAMESPACE) {\n\t\t\tif (buf)\n\t\t\t\tsnprintf(buf, bufsz, _(\"filesystem was unmounted, but failed to switch namespace back\"));\n\t\t\treturn MNT_EX_SYSERR;\n\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\treturn mnt_context_get_generic_excode(rc, buf, bufsz,\n\t\t\t\t_(\"filesystem was unmounted, but any subsequent operation failed: %m\"));\n\n\t\treturn MNT_EX_SOFTWARE;\t/* internal error */\n\t}\n\n\t/*\n\t * umount(2) errors\n\t */\n\tif (buf) {\n\t\tint syserr = mnt_context_get_syscall_errno(cxt);\n\n\t\tswitch (syserr) {\n\t\tcase ENXIO:\n\t\t\tsnprintf(buf, bufsz, _(\"invalid block device\"));\t/* ??? */\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tsnprintf(buf, bufsz, _(\"not mounted\"));\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\tsnprintf(buf, bufsz, _(\"can't write superblock\"));\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tsnprintf(buf, bufsz, _(\"target is busy\"));\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tsnprintf(buf, bufsz, _(\"no mount point specified\"));\n\t\t\tbreak;\n\t\tcase EPERM:\n\t\t\tsnprintf(buf, bufsz, _(\"must be superuser to unmount\"));\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tsnprintf(buf, bufsz, _(\"block devices are not permitted on filesystem\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn mnt_context_get_generic_excode(syserr, buf, bufsz,_(\"umount(2) system call failed: %m\"));\n\t\t}\n\t}\n\treturn MNT_EX_FAIL;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * mountP.h - private library header file\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifndef _LIBMOUNT_PRIVATE_H\n#define _LIBMOUNT_PRIVATE_H\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#include \"c.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"libmount.h\"\n\n/*\n * Debug\n */\n#define MNT_DEBUG_HELP\t\t(1 << 0)\n#define MNT_DEBUG_INIT\t\t(1 << 1)\n#define MNT_DEBUG_CACHE\t\t(1 << 2)\n#define MNT_DEBUG_OPTIONS\t(1 << 3)\n#define MNT_DEBUG_LOCKS\t\t(1 << 4)\n#define MNT_DEBUG_TAB\t\t(1 << 5)\n#define MNT_DEBUG_FS\t\t(1 << 6)\n#define MNT_DEBUG_UPDATE\t(1 << 7)\n#define MNT_DEBUG_UTILS\t\t(1 << 8)\n#define MNT_DEBUG_CXT\t\t(1 << 9)\n#define MNT_DEBUG_DIFF\t\t(1 << 10)\n#define MNT_DEBUG_MONITOR\t(1 << 11)\n#define MNT_DEBUG_BTRFS\t\t(1 << 12)\n#define MNT_DEBUG_LOOP\t\t(1 << 13)\n#define MNT_DEBUG_VERITY\t(1 << 14)\n\n#define MNT_DEBUG_ALL\t\t0xFFFF\n\nUL_DEBUG_DECLARE_MASK(libmount);\n#define DBG(m, x)\t__UL_DBG(libmount, MNT_DEBUG_, m, x)\n#define ON_DBG(m, x)\t__UL_DBG_CALL(libmount, MNT_DEBUG_, m, x)\n#define DBG_FLUSH\t__UL_DBG_FLUSH(libmount, MNT_DEBUG_)\n\n#define UL_DEBUG_CURRENT_MASK\tUL_DEBUG_MASK(libmount)\n#include \"debugobj.h\"\n\n/*\n * NLS -- the library has to be independent on main program, so define\n * UL_TEXTDOMAIN_EXPLICIT before you include nls.h.\n *\n * Now we use util-linux.po (=PACKAGE), rather than maintain the texts\n * in the separate libmount.po file.\n */\n#define LIBMOUNT_TEXTDOMAIN\tPACKAGE\n#define UL_TEXTDOMAIN_EXPLICIT\tLIBMOUNT_TEXTDOMAIN\n#include \"nls.h\"\n\n\n/* extension for files in the directory */\n#define MNT_MNTTABDIR_EXT\t\".fstab\"\n\n/* library private paths */\n#define MNT_RUNTIME_TOPDIR\t\"/run\"\n/* private userspace mount table */\n#define MNT_PATH_UTAB\t\tMNT_RUNTIME_TOPDIR \"/mount/utab\"\n/* temporary mount target */\n#define MNT_PATH_TMPTGT\t\tMNT_RUNTIME_TOPDIR \"/mount/tmptgt\"\n\n#define MNT_UTAB_HEADER\t\"# libmount utab file\\n\"\n\n#ifdef TEST_PROGRAM\nstruct libmnt_test {\n\tconst char\t*name;\n\tint\t\t(*body)(struct libmnt_test *ts, int argc, char *argv[]);\n\tconst char\t*usage;\n};\n\n/* test.c */\nextern int mnt_run_test(struct libmnt_test *tests, int argc, char *argv[]);\n#endif\n\n/* utils.c */\nextern int mnt_valid_tagname(const char *tagname);\n\nextern const char *mnt_statfs_get_fstype(struct statfs *vfs);\nextern int is_file_empty(const char *name);\n\nextern int mnt_is_readonly(const char *path)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_parse_offset(const char *str, size_t len, uintmax_t *res);\n\nextern int mnt_chdir_to_parent(const char *target, char **filename);\n\nextern char *mnt_get_username(const uid_t uid);\nextern int mnt_get_uid(const char *username, uid_t *uid);\nextern int mnt_get_gid(const char *groupname, gid_t *gid);\nextern int mnt_in_group(gid_t gid);\n\nextern int mnt_open_uniq_filename(const char *filename, char **name);\n\nextern int mnt_has_regular_utab(const char **utab, int *writable);\nextern const char *mnt_get_utab_path(void);\n\nextern int mnt_get_filesystems(char ***filesystems, const char *pattern);\nextern void mnt_free_filesystems(char **filesystems);\n\nextern char *mnt_get_kernel_cmdline_option(const char *name);\nextern int mnt_stat_mountpoint(const char *target, struct stat *st);\nextern int mnt_lstat_mountpoint(const char *target, struct stat *st);\n\nextern int mnt_tmptgt_unshare(int *old_ns_fd);\nextern int mnt_tmptgt_cleanup(int old_ns_fd);\n\n/* tab.c */\nextern int is_mountinfo(struct libmnt_table *tb);\nextern int mnt_table_set_parser_fltrcb(\tstruct libmnt_table *tb,\n\t\t\t\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\t\t\t\tvoid *data);\n\nextern int __mnt_table_parse_mtab(struct libmnt_table *tb,\n\t\t\t\t\tconst char *filename,\n\t\t\t\t\tstruct libmnt_table *u_tb);\n\nextern struct libmnt_fs *mnt_table_get_fs_root(struct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fs,\n\t\t\t\t\tunsigned long mountflags,\n\t\t\t\t\tchar **fsroot);\n\nextern int __mnt_table_is_fs_mounted(\tstruct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fstab_fs,\n\t\t\t\t\tconst char *tgt_prefix);\n\n/*\n * Generic iterator\n */\nstruct libmnt_iter {\n        struct list_head        *p;\t\t/* current position */\n        struct list_head        *head;\t\t/* start position */\n\tint\t\t\tdirection;\t/* MNT_ITER_{FOR,BACK}WARD */\n};\n\n#define IS_ITER_FORWARD(_i)\t((_i)->direction == MNT_ITER_FORWARD)\n#define IS_ITER_BACKWARD(_i)\t((_i)->direction == MNT_ITER_BACKWARD)\n\n#define MNT_ITER_INIT(itr, list) \\\n\tdo { \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(list)->next : (list)->prev; \\\n\t\t(itr)->head = (list); \\\n\t} while(0)\n\n#define MNT_ITER_ITERATE(itr, res, restype, member) \\\n\tdo { \\\n\t\tres = list_entry((itr)->p, restype, member); \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(itr)->p->next : (itr)->p->prev; \\\n\t} while(0)\n\n\n/*\n * This struct represents one entry in a mtab/fstab/mountinfo file.\n * (note that fstab[1] means the first column from fstab, and so on...)\n */\nstruct libmnt_fs {\n\tstruct list_head ents;\n\tstruct libmnt_table *tab;\n\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tid;\t\t/* mountinfo[1]: ID */\n\tint\t\tparent;\t\t/* mountinfo[2]: parent */\n\tdev_t\t\tdevno;\t\t/* mountinfo[3]: st_dev */\n\n\tchar\t\t*bindsrc;\t/* utab, full path from fstab[1] for bind mounts */\n\n\tchar\t\t*source;\t/* fstab[1], mountinfo[10], swaps[1]:\n                                         * source dev, file, dir or TAG */\n\tchar\t\t*tagname;\t/* fstab[1]: tag name - \"LABEL\", \"UUID\", ..*/\n\tchar\t\t*tagval;\t/*           tag value */\n\n\tchar\t\t*root;\t\t/* mountinfo[4]: root of the mount within the FS */\n\tchar\t\t*target;\t/* mountinfo[5], fstab[2]: mountpoint */\n\tchar\t\t*fstype;\t/* mountinfo[9], fstab[3]: filesystem type */\n\n\tchar\t\t*optstr;\t/* fstab[4], merged options */\n\tchar\t\t*vfs_optstr;\t/* mountinfo[6]: fs-independent (VFS) options */\n\tchar\t\t*opt_fields;\t/* mountinfo[7]: optional fields */\n\tchar\t\t*fs_optstr;\t/* mountinfo[11]: fs-dependent options */\n\tchar\t\t*user_optstr;\t/* userspace mount options */\n\tchar\t\t*attrs;\t\t/* mount attributes */\n\n\tint\t\tfreq;\t\t/* fstab[5]: dump frequency in days */\n\tint\t\tpassno;\t\t/* fstab[6]: pass number on parallel fsck */\n\n\t/* /proc/swaps */\n\tchar\t\t*swaptype;\t/* swaps[2]: device type (partition, file, ...) */\n\toff_t\t\tsize;\t\t/* swaps[3]: swaparea size */\n\toff_t\t\tusedsize;\t/* swaps[4]: used size */\n\tint\t\tpriority;\t/* swaps[5]: swap priority */\n\n\tint\t\tflags;\t\t/* MNT_FS_* flags */\n\tpid_t\t\ttid;\t\t/* /proc/<tid>/mountinfo otherwise zero */\n\n\tchar\t\t*comment;\t/* fstab comment */\n\n\tvoid\t\t*userdata;\t/* library independent data */\n};\n\n/*\n * fs flags\n */\n#define MNT_FS_PSEUDO\t(1 << 1) /* pseudo filesystem */\n#define MNT_FS_NET\t(1 << 2) /* network filesystem */\n#define MNT_FS_SWAP\t(1 << 3) /* swap device */\n#define MNT_FS_KERNEL\t(1 << 4) /* data from /proc/{mounts,self/mountinfo} */\n#define MNT_FS_MERGED\t(1 << 5) /* already merged data from /run/mount/utab */\n\n/*\n * mtab/fstab/mountinfo file\n */\nstruct libmnt_table {\n\tint\t\tfmt;\t\t/* MNT_FMT_* file format */\n\tint\t\tnents;\t\t/* number of entries */\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tcomms;\t\t/* enable/disable comment parsing */\n\tchar\t\t*comm_intro;\t/* First comment in file */\n\tchar\t\t*comm_tail;\t/* Last comment in file */\n\n\tstruct libmnt_cache *cache;\t\t/* canonicalized paths/tags cache */\n\n        int\t\t(*errcb)(struct libmnt_table *tb,\n\t\t\t\t const char *filename, int line);\n\n\tint\t\t(*fltrcb)(struct libmnt_fs *fs, void *data);\n\tvoid\t\t*fltrcb_data;\n\n\n\tstruct list_head\tents;\t/* list of entries (libmnt_fs) */\n\tvoid\t\t*userdata;\n};\n\nextern struct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent);\n\n/*\n * Tab file format\n */\nenum {\n\tMNT_FMT_GUESS,\n\tMNT_FMT_FSTAB,\t\t\t/* /etc/{fs,m}tab */\n\tMNT_FMT_MTAB = MNT_FMT_FSTAB,\t/* alias */\n\tMNT_FMT_MOUNTINFO,\t\t/* /proc/#/mountinfo */\n\tMNT_FMT_UTAB,\t\t\t/* /run/mount/utab */\n\tMNT_FMT_SWAPS\t\t\t/* /proc/swaps */\n};\n\n/*\n * Additional mounts\n */\nstruct libmnt_addmount {\n\tunsigned long mountflags;\n\n\tstruct list_head\tmounts;\n};\n\nstruct libmnt_ns {\n\tint fd;\t\t\t\t/* file descriptor of namespace, -1 when inactive */\n\tstruct libmnt_cache *cache;\t/* paths cache associated with NS */\n};\n\n/*\n * Mount context -- high-level API\n */\nstruct libmnt_context\n{\n\tint\taction;\t\t/* MNT_ACT_{MOUNT,UMOUNT} */\n\tint\trestricted;\t/* root or not? */\n\n\tchar\t*fstype_pattern;\t/* for mnt_match_fstype() */\n\tchar\t*optstr_pattern;\t/* for mnt_match_options() */\n\n\tchar\t*subdir;\t\t/* X-mount.subdir= */\n\n\tstruct libmnt_fs *fs;\t\t/* filesystem description (type, mountpoint, device, ...) */\n\tstruct libmnt_fs *fs_template;\t/* used for @fs on mnt_reset_context() */\n\n\tstruct libmnt_table *fstab;\t/* fstab (or mtab for some remounts) entries */\n\tstruct libmnt_table *mtab;\t/* mtab entries */\n\tstruct libmnt_table *utab;\t/* rarely used by umount only */\n\n\tint\t(*table_errcb)(struct libmnt_table *tb,\t/* callback for libmnt_table structs */\n\t\t\t const char *filename, int line);\n\n\tint\t(*table_fltrcb)(struct libmnt_fs *fs, void *data);\t/* callback for libmnt_table structs */\n\tvoid\t*table_fltrcb_data;\n\n\tchar\t*(*pwd_get_cb)(struct libmnt_context *);\t\t/* get encryption password */\n\tvoid\t(*pwd_release_cb)(struct libmnt_context *, char *);\t/* release password */\n\n\tint\toptsmode;\t/* fstab optstr mode MNT_OPTSMODE_{AUTO,FORCE,IGNORE} */\n\tint\tloopdev_fd;\t/* open loopdev */\n\n\tunsigned long\tmountflags;\t/* final mount(2) flags */\n\tconst void\t*mountdata;\t/* final mount(2) data, string or binary data */\n\n\tunsigned long\tuser_mountflags;\t/* MNT_MS_* (loop=, user=, ...) */\n\n\tstruct list_head\taddmounts;\t/* additional mounts */\n\n\tstruct libmnt_cache\t*cache;\t/* paths cache */\n\tstruct libmnt_lock\t*lock;\t/* mtab lock */\n\tstruct libmnt_update\t*update;/* mtab/utab update */\n\n\tconst char\t*mtab_path; /* path to mtab */\n\tint\t\tmtab_writable; /* is mtab writable */\n\n\tconst char\t*utab_path; /* path to utab */\n\tint\t\tutab_writable; /* is utab writable */\n\n\tchar\t\t*tgt_prefix;\t/* path used for all targets */\n\n\tint\tflags;\t\t/* private context flags */\n\n\tchar\t*helper;\t/* name of the used /sbin/[u]mount.<type> helper */\n\tint\thelper_status;\t/* helper wait(2) status */\n\tint\thelper_exec_status; /* 1: not called yet, 0: success, <0: -errno */\n\n\tchar\t*orig_user;\t/* original (non-fixed) user= option */\n\n\tpid_t\t*children;\t/* \"mount -a --fork\" PIDs */\n\tint\tnchildren;\t/* number of children */\n\tpid_t\tpid;\t\t/* 0=parent; PID=child */\n\n\n\tint\tsyscall_status;\t/* 1: not called yet, 0: success, <0: -errno */\n\n\tstruct libmnt_ns\tns_orig;\t/* original namespace */\n\tstruct libmnt_ns\tns_tgt;\t\t/* target namespace */\n\tstruct libmnt_ns\t*ns_cur;\t/* pointer to current namespace */\n\n\tunsigned int\tenabled_textdomain : 1;\t\t/* bindtextdomain() called */\n};\n\n/* flags */\n#define MNT_FL_NOMTAB\t\t(1 << 1)\n#define MNT_FL_FAKE\t\t(1 << 2)\n#define MNT_FL_SLOPPY\t\t(1 << 3)\n#define MNT_FL_VERBOSE\t\t(1 << 4)\n#define MNT_FL_NOHELPERS\t(1 << 5)\n#define MNT_FL_LOOPDEL\t\t(1 << 6)\n#define MNT_FL_LAZY\t\t(1 << 7)\n#define MNT_FL_FORCE\t\t(1 << 8)\n#define MNT_FL_NOCANONICALIZE\t(1 << 9)\n#define MNT_FL_RDONLY_UMOUNT\t(1 << 11)\t/* remount,ro after EBUSY umount(2) */\n#define MNT_FL_FORK\t\t(1 << 12)\n#define MNT_FL_NOSWAPMATCH\t(1 << 13)\n#define MNT_FL_RWONLY_MOUNT\t(1 << 14)\t/* explicit mount -w; never try read-only  */\n\n#define MNT_FL_MOUNTDATA\t(1 << 20)\n#define MNT_FL_TAB_APPLIED\t(1 << 21)\t/* mtab/fstab merged to cxt->fs */\n#define MNT_FL_MOUNTFLAGS_MERGED (1 << 22)\t/* MS_* flags was read from optstr */\n#define MNT_FL_SAVED_USER\t(1 << 23)\n#define MNT_FL_PREPARED\t\t(1 << 24)\n#define MNT_FL_HELPER\t\t(1 << 25)\t/* [u]mount.<type> */\n#define MNT_FL_LOOPDEV_READY\t(1 << 26)\t/* /dev/loop<N> initialized by the library */\n#define MNT_FL_MOUNTOPTS_FIXED  (1 << 27)\n#define MNT_FL_TABPATHS_CHECKED\t(1 << 28)\n#define MNT_FL_FORCED_RDONLY\t(1 << 29)\t/* mounted read-only on write-protected device */\n#define MNT_FL_VERITYDEV_READY\t(1 << 30)\t/* /dev/mapper/<FOO> initialized by the library */\n\n/* default flags */\n#define MNT_FL_DEFAULT\t\t0\n\n/* Flags usable with MS_BIND|MS_REMOUNT */\n#define MNT_BIND_SETTABLE\t(MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_NOATIME|MS_NODIRATIME|MS_RELATIME|MS_RDONLY)\n\n/* lock.c */\nextern int mnt_lock_use_simplelock(struct libmnt_lock *ml, int enable);\n\n/* optmap.c */\nextern const struct libmnt_optmap *mnt_optmap_get_entry(\n\t\t\t     struct libmnt_optmap const **maps,\n                             int nmaps,\n\t\t\t     const char *name,\n                             size_t namelen,\n\t\t\t     const struct libmnt_optmap **mapent);\n\n/* optstr.c */\nextern int mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid);\nextern int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end);\nextern int mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_secontext(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_user(char **optstr);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n\t\t\t__attribute__((nonnull));\nextern int __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n\t\t\t__attribute__((nonnull(1)));\nextern int __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n\t\t\t__attribute__((nonnull(1)));\n\n/* context.c */\nextern struct libmnt_context *mnt_copy_context(struct libmnt_context *o);\nextern int mnt_context_mtab_writable(struct libmnt_context *cxt);\nextern int mnt_context_utab_writable(struct libmnt_context *cxt);\nextern const char *mnt_context_get_writable_tabpath(struct libmnt_context *cxt);\n\nextern int mnt_context_get_mtab_for_target(struct libmnt_context *cxt,\n\t\t\t\t    struct libmnt_table **mtab, const char *tgt);\n\nextern int mnt_context_prepare_srcpath(struct libmnt_context *cxt);\nextern int mnt_context_prepare_target(struct libmnt_context *cxt);\nextern int mnt_context_guess_srcpath_fstype(struct libmnt_context *cxt, char **type);\nextern int mnt_context_guess_fstype(struct libmnt_context *cxt);\nextern int mnt_context_prepare_helper(struct libmnt_context *cxt,\n\t\t\t\t      const char *name, const char *type);\nextern int mnt_context_prepare_update(struct libmnt_context *cxt);\nextern int mnt_context_merge_mflags(struct libmnt_context *cxt);\nextern int mnt_context_update_tabs(struct libmnt_context *cxt);\n\nextern int mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg);\nextern int mnt_context_mount_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_is_loopdev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_context_propagation_only(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern struct libmnt_addmount *mnt_new_addmount(void);\nextern void mnt_free_addmount(struct libmnt_addmount *ad);\n\nextern int mnt_context_setup_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_delete_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_clear_loopdev(struct libmnt_context *cxt);\n\nextern int mnt_fork_context(struct libmnt_context *cxt);\n\nextern int mnt_context_set_tabfilter(struct libmnt_context *cxt,\n\t\t\t\t     int (*fltr)(struct libmnt_fs *, void *),\n\t\t\t\t     void *data);\n\nextern int mnt_context_get_generic_excode(int rc, char *buf, size_t bufsz, const char *fmt, ...)\n\t\t\t\t__attribute__ ((__format__ (__printf__, 4, 5)));\nextern int mnt_context_get_mount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\nextern int mnt_context_get_umount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\n\nextern int mnt_context_has_template(struct libmnt_context *cxt);\nextern int mnt_context_apply_template(struct libmnt_context *cxt);\nextern int mnt_context_save_template(struct libmnt_context *cxt);\n\nextern int mnt_context_apply_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\n\nextern int mnt_context_is_veritydev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\nextern int mnt_context_setup_veritydev(struct libmnt_context *cxt);\nextern int mnt_context_deferred_delete_veritydev(struct libmnt_context *cxt);\n\n/* tab_update.c */\nextern int mnt_update_set_filename(struct libmnt_update *upd,\n\t\t\t\t   const char *filename, int userspace_only);\nextern int mnt_update_already_done(struct libmnt_update *upd,\n\t\t\t\t   struct libmnt_lock *lc);\n\n#if __linux__\n/* btrfs.c */\nextern uint64_t btrfs_get_default_subvol_id(const char *path);\n#endif\n\n#endif /* _LIBMOUNT_PRIVATE_H */\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2009-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: optstr\n * @title: Options string\n * @short_description: low-level API for working with mount options\n *\n * This is a simple and low-level API to working with mount options that are stored\n * in a string.\n */\n#include <ctype.h>\n\n#ifdef HAVE_LIBSELINUX\n#include <selinux/selinux.h>\n#include <selinux/context.h>\n#endif\n\n#include \"strutils.h\"\n#include \"mountP.h\"\n#include \"buffer.h\"\n\n/*\n * Option location\n */\nstruct libmnt_optloc {\n\tchar\t*begin;\n\tchar\t*end;\n\tchar\t*value;\n\tsize_t\tvalsz;\n\tsize_t  namesz;\n};\n\n#define MNT_INIT_OPTLOC\t{ .begin = NULL }\n\n#define mnt_optmap_entry_novalue(e) \\\n\t\t(e && (e)->name && !strchr((e)->name, '=') && !((e)->mask & MNT_PREFIX))\n\n/*\n * Parses the first option from @optstr. The @optstr pointer is set to the beginning\n * of the next option.\n *\n * Returns -EINVAL on parse error, 1 at the end of optstr and 0 on success.\n */\nstatic int mnt_optstr_parse_next(char **optstr,\t char **name, size_t *namesz,\n\t\t\t\t\tchar **value, size_t *valsz)\n{\n\tint open_quote = 0;\n\tchar *start = NULL, *stop = NULL, *p, *sep = NULL;\n\tchar *optstr0;\n\n\tassert(optstr);\n\tassert(*optstr);\n\n\toptstr0 = *optstr;\n\n\tif (name)\n\t\t*name = NULL;\n\tif (namesz)\n\t\t*namesz = 0;\n\tif (value)\n\t\t*value = NULL;\n\tif (valsz)\n\t\t*valsz = 0;\n\n\t/* trim leading commas as to not invalidate option\n\t * strings with multiple consecutive commas */\n\twhile (optstr0 && *optstr0 == ',')\n\t\toptstr0++;\n\n\tfor (p = optstr0; p && *p; p++) {\n\t\tif (!start)\n\t\t\tstart = p;\t\t/* beginning of the option item */\n\t\tif (*p == '\"')\n\t\t\topen_quote ^= 1;\t/* reverse the status */\n\t\tif (open_quote)\n\t\t\tcontinue;\t\t/* still in quoted block */\n\t\tif (!sep && p > start && *p == '=')\n\t\t\tsep = p;\t\t/* name and value separator */\n\t\tif (*p == ',')\n\t\t\tstop = p;\t\t/* terminate the option item */\n\t\telse if (*(p + 1) == '\\0')\n\t\t\tstop = p + 1;\t\t/* end of optstr */\n\t\tif (!start || !stop)\n\t\t\tcontinue;\n\t\tif (stop <= start)\n\t\t\tgoto error;\n\n\t\tif (name)\n\t\t\t*name = start;\n\t\tif (namesz)\n\t\t\t*namesz = sep ? sep - start : stop - start;\n\t\t*optstr = *stop ? stop + 1 : stop;\n\n\t\tif (sep) {\n\t\t\tif (value)\n\t\t\t\t*value = sep + 1;\n\t\t\tif (valsz)\n\t\t\t\t*valsz = stop - sep - 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\t\t\t\t/* end of optstr */\n\nerror:\n\tDBG(OPTIONS, ul_debug(\"parse error: \\\"%s\\\"\", optstr0));\n\treturn -EINVAL;\n}\n\n/*\n * Locates the first option that matches @name. The @end is set to the\n * char behind the option (it means ',' or \\0).\n *\n * Returns negative number on parse error, 1 when not found and 0 on success.\n */\nstatic int mnt_optstr_locate_option(char *optstr, const char *name,\n\t\t\t\t\tstruct libmnt_optloc *ol)\n{\n\tchar *n;\n\tsize_t namesz, nsz;\n\tint rc;\n\n\tif (!optstr)\n\t\treturn 1;\n\n\tassert(name);\n\n\tnamesz = strlen(name);\n\n\tdo {\n\t\trc = mnt_optstr_parse_next(&optstr, &n, &nsz,\n\t\t\t\t\t&ol->value, &ol->valsz);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tif (namesz == nsz && strncmp(n, name, nsz) == 0) {\n\t\t\tol->begin = n;\n\t\t\tol->end = *(optstr - 1) == ',' ? optstr - 1 : optstr;\n\t\t\tol->namesz = nsz;\n\t\t\treturn 0;\n\t\t}\n\t} while(1);\n\n\treturn rc;\n}\n\n/**\n * mnt_optstr_next_option:\n * @optstr: option string, returns the position of the next option\n * @name: returns the option name\n * @namesz: returns the option name length\n * @value: returns the option value or NULL\n * @valuesz: returns the option value length or zero\n *\n * Parses the first option in @optstr.\n *\n * Returns: 0 on success, 1 at the end of @optstr or negative number in case of\n * error.\n */\nint mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,\n\t\t\t\t\tchar **value, size_t *valuesz)\n{\n\tif (!optstr || !*optstr)\n\t\treturn -EINVAL;\n\treturn mnt_optstr_parse_next(optstr, name, namesz, value, valuesz);\n}\n\nstatic int __buffer_append_option(struct ul_buffer *buf,\n\t\t\tconst char *name, size_t namesz,\n\t\t\tconst char *val, size_t valsz)\n{\n\tint rc = 0;\n\n\tif (!ul_buffer_is_empty(buf))\n\t\trc = ul_buffer_append_data(buf, \",\", 1);\n\tif (!rc)\n\t\trc = ul_buffer_append_data(buf, name, namesz);\n\tif (val && !rc) {\n\t\t/* we need to append '=' is value is empty string, see\n\t\t * 727c689908c5e68c92aa1dd65e0d3bdb6d91c1e5 */\n\t\trc = ul_buffer_append_data(buf, \"=\", 1);\n\t\tif (!rc && valsz)\n\t\t\trc = ul_buffer_append_data(buf, val, valsz);\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_append_option:\n * @optstr: option string or NULL, returns a reallocated string\n * @name: value name\n * @value: value\n *\n * Returns: 0 on success or <0 in case of error. After an error the @optstr should\n *          be unmodified.\n */\nint mnt_optstr_append_option(char **optstr, const char *name, const char *value)\n{\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tint rc;\n\tsize_t nsz, vsz, osz;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tnsz = strlen(name);\n\tosz = *optstr ? strlen(*optstr) : 0;\n\tvsz = value ? strlen(value) : 0;\n\n\tul_buffer_refer_string(&buf, *optstr);\n\tul_buffer_set_chunksize(&buf, osz + nsz + vsz + 3);\t/* to call realloc() only once */\n\n\trc = __buffer_append_option(&buf, name, nsz, value, vsz);\n\n\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\treturn rc;\n}\n/**\n * mnt_optstr_prepend_option:\n * @optstr: option string or NULL, returns a reallocated string\n * @name: value name\n * @value: value\n *\n * Returns: 0 on success or <0 in case of error. After an error the @optstr should\n *          be unmodified.\n */\nint mnt_optstr_prepend_option(char **optstr, const char *name, const char *value)\n{\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tsize_t nsz, vsz, osz;\n\tint rc;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\tif (!name || !*name)\n\t\treturn 0;\n\n\tnsz = strlen(name);\n\tosz = *optstr ? strlen(*optstr) : 0;\n\tvsz = value ? strlen(value) : 0;\n\n\tul_buffer_set_chunksize(&buf, osz + nsz + vsz + 3);   /* to call realloc() only once */\n\n\trc = __buffer_append_option(&buf, name, nsz, value, vsz);\n\tif (*optstr && !rc) {\n\t\trc = ul_buffer_append_data(&buf, \",\", 1);\n\t\tif (!rc)\n\t\t\trc = ul_buffer_append_data(&buf, *optstr, osz);\n\t\tfree(*optstr);\n\t}\n\n\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\treturn rc;\n}\n\n/**\n * mnt_optstr_get_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n * @value: returns a pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of the value or 0\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_get_option(const char *optstr, const char *name,\n\t\t\t  char **value, size_t *valsz)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\trc = mnt_optstr_locate_option((char *) optstr, name, &ol);\n\tif (!rc) {\n\t\tif (value)\n\t\t\t*value = ol.value;\n\t\tif (valsz)\n\t\t\t*valsz = ol.valsz;\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_deduplicate_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n *\n * Removes all instances of @name except the last one.\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_deduplicate_option(char **optstr, const char *name)\n{\n\tint rc;\n\tchar *begin = NULL, *end = NULL, *opt;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\topt = *optstr;\n\tdo {\n\t\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\n\t\trc = mnt_optstr_locate_option(opt, name, &ol);\n\t\tif (!rc) {\n\t\t\tif (begin) {\n\t\t\t\t/* remove the previous instance */\n\t\t\t\tsize_t shift = strlen(*optstr);\n\n\t\t\t\tmnt_optstr_remove_option_at(optstr, begin, end);\n\n\t\t\t\t/* now all the offsets are not valid anymore - recount */\n\t\t\t\tshift -= strlen(*optstr);\n\t\t\t\tol.begin -= shift;\n\t\t\t\tol.end -= shift;\n\t\t\t}\n\t\t\tbegin = ol.begin;\n\t\t\tend = ol.end;\n\t\t\topt = end && *end ? end + 1 : NULL;\n\t\t}\n\t\tif (opt == NULL)\n\t\t\tbreak;\n\t} while (rc == 0 && *opt);\n\n\treturn rc < 0 ? rc : begin ? 0 : 1;\n}\n\n/*\n * The result never starts or ends with a comma or contains two commas\n *    (e.g. \",aaa,bbb\" or \"aaa,,bbb\" or \"aaa,\")\n */\nint mnt_optstr_remove_option_at(char **optstr, char *begin, char *end)\n{\n\tsize_t sz;\n\n\tif (!optstr || !begin || !end)\n\t\treturn -EINVAL;\n\n\tif ((begin == *optstr || *(begin - 1) == ',') && *end == ',')\n\t\tend++;\n\n\tsz = strlen(end);\n\n\tmemmove(begin, end, sz + 1);\n\tif (!*begin && (begin > *optstr) && *(begin - 1) == ',')\n\t\t*(begin - 1) = '\\0';\n\n\treturn 0;\n}\n\n/* insert 'substr' or '=substr' to @str on position @pos */\nstatic int __attribute__((nonnull(1,2,3)))\ninsert_value(char **str, char *pos, const char *substr, char **next)\n{\n\tsize_t subsz = strlen(substr);\t\t\t/* substring size */\n\tsize_t strsz = strlen(*str);\n\tsize_t possz = strlen(pos);\n\tsize_t posoff;\n\tchar *p;\n\tint sep;\n\n\t/* is it necessary to prepend '=' before the substring ? */\n\tsep = !(pos > *str && *(pos - 1) == '=');\n\n\t/* save an offset of the place where we need to add substr */\n\tposoff = pos - *str;\n\n\tp = realloc(*str, strsz + sep + subsz + 1);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/* zeroize the newly allocated memory -- valgrind loves us... */\n\tmemset(p + strsz, 0, sep + subsz + 1);\n\n\t/* set pointers to the reallocated string */\n\t*str = p;\n\tpos = p + posoff;\n\n\tif (possz)\n\t\t/* create a room for the new substring */\n\t\tmemmove(pos + subsz + sep, pos, possz + 1);\n\tif (sep)\n\t\t*pos++ = '=';\n\n\tmemcpy(pos, substr, subsz);\n\n\tif (next) {\n\t\t/* set pointer to the next option */\n\t\t*next = pos + subsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\treturn 0;\n}\n\n/**\n * mnt_optstr_set_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option\n * @value: new value or NULL\n *\n * Set or unset the option @value.\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_set_option(char **optstr, const char *name, const char *value)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tchar *nameend;\n\tint rc = 1;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\tif (*optstr)\n\t\trc = mnt_optstr_locate_option(*optstr, name, &ol);\n\tif (rc < 0)\n\t\treturn rc;\t\t\t/* parse error */\n\tif (rc == 1)\n\t\treturn mnt_optstr_append_option(optstr, name, value);\t/* not found */\n\n\tnameend = ol.begin + ol.namesz;\n\n\tif (value == NULL && ol.value && ol.valsz)\n\t\t/* remove unwanted \"=value\" */\n\t\tmnt_optstr_remove_option_at(optstr, nameend, ol.end);\n\n\telse if (value && ol.value == NULL)\n\t\t/* insert \"=value\" */\n\t\trc = insert_value(optstr, nameend, value, NULL);\n\n\telse if (value && ol.value && strlen(value) == ol.valsz)\n\t\t/* simply replace =value */\n\t\tmemcpy(ol.value, value, ol.valsz);\n\n\telse if (value && ol.value) {\n\t\tmnt_optstr_remove_option_at(optstr, nameend, ol.end);\n\t\trc = insert_value(optstr, nameend, value, NULL);\n\t}\n\treturn rc;\n}\n\n/**\n * mnt_optstr_remove_option:\n * @optstr: string with a comma separated list of options\n * @name: requested option name\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case\n * of error.\n */\nint mnt_optstr_remove_option(char **optstr, const char *name)\n{\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc;\n\n\tif (!optstr || !name)\n\t\treturn -EINVAL;\n\n\trc = mnt_optstr_locate_option(*optstr, name, &ol);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tmnt_optstr_remove_option_at(optstr, ol.begin, ol.end);\n\treturn 0;\n}\n\n/**\n * mnt_split_optstr:\n * @optstr: string with comma separated list of options\n * @user: returns newly allocated string with userspace options\n * @vfs: returns newly allocated string with VFS options\n * @fs: returns newly allocated string with FS options\n * @ignore_user: option mask for options that should be ignored\n * @ignore_vfs: option mask for options that should be ignored\n *\n * For example:\n *\n *\tmnt_split_optstr(optstr, &u, NULL, NULL, MNT_NOMTAB, 0);\n *\n * returns all userspace options, the options that do not belong to\n * mtab are ignored.\n *\n * Note that FS options are all options that are undefined in MNT_USERSPACE_MAP\n * or MNT_LINUX_MAP.\n *\n * Returns: 0 on success, or a negative number in case of error.\n */\nint mnt_split_optstr(const char *optstr, char **user, char **vfs,\n\t\t     char **fs, int ignore_user, int ignore_vfs)\n{\n\tint rc = 0;\n\tchar *name, *val, *str = (char *) optstr;\n\tsize_t namesz, valsz, chunsz;\n\tstruct libmnt_optmap const *maps[2];\n\tstruct ul_buffer xvfs = UL_INIT_BUFFER,\n\t\t\t xfs = UL_INIT_BUFFER,\n\t\t\t xuser = UL_INIT_BUFFER;\n\n\tif (!optstr)\n\t\treturn -EINVAL;\n\n\tmaps[0] = mnt_get_builtin_optmap(MNT_LINUX_MAP);\n\tmaps[1] = mnt_get_builtin_optmap(MNT_USERSPACE_MAP);\n\n\tchunsz = strlen(optstr) / 2;\n\n\twhile (!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {\n\t\tstruct ul_buffer *buf = NULL;\n\t\tconst struct libmnt_optmap *ent = NULL;\n\t\tconst struct libmnt_optmap *m =\n\t\t\t mnt_optmap_get_entry(maps, 2, name, namesz, &ent);\n\n\t\tif (ent && !ent->id)\n\t\t\tcontinue;\t/* ignore undefined options (comments) */\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tm = NULL;\n\n\t\tif (ent && m && m == maps[0] && vfs) {\n\t\t\tif (ignore_vfs && (ent->mask & ignore_vfs))\n\t\t\t\tcontinue;\n\t\t\tif (vfs)\n\t\t\t\tbuf = &xvfs;\n\t\t} else if (ent && m && m == maps[1] && user) {\n\t\t\tif (ignore_user && (ent->mask & ignore_user))\n\t\t\t\tcontinue;\n\t\t\tif (user)\n\t\t\t\tbuf = &xuser;\n\t\t} else if (!m && fs) {\n\t\t\tif (fs)\n\t\t\t\tbuf = &xfs;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (ul_buffer_is_empty(buf))\n\t\t\t\tul_buffer_set_chunksize(buf, chunsz);\n\t\t\trc = __buffer_append_option(buf, name, namesz, val, valsz);\n\t\t}\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (vfs)\n\t\t*vfs  = rc ? NULL : ul_buffer_get_data(&xvfs, NULL, NULL);\n\tif (fs)\n\t\t*fs   = rc ? NULL : ul_buffer_get_data(&xfs, NULL, NULL);\n\tif (user)\n\t\t*user = rc ? NULL : ul_buffer_get_data(&xuser, NULL, NULL);\n\tif (rc) {\n\t\tul_buffer_free_data(&xvfs);\n\t\tul_buffer_free_data(&xfs);\n\t\tul_buffer_free_data(&xuser);\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_optstr_get_options\n * @optstr: string with a comma separated list of options\n * @subset: returns newly allocated string with options\n * @map: options map\n * @ignore: mask of the options that should be ignored\n *\n * Extracts options from @optstr that belong to the @map, for example:\n *\n *\t mnt_optstr_get_options(optstr, &p,\n *\t\t\tmnt_get_builtin_optmap(MNT_LINUX_MAP),\n *\t\t\tMNT_NOMTAB);\n *\n * the 'p' returns all VFS options, the options that do not belong to mtab\n * are ignored.\n *\n * Returns: 0 on success, or a negative number in case of error.\n */\nint mnt_optstr_get_options(const char *optstr, char **subset,\n\t\t\t    const struct libmnt_optmap *map, int ignore)\n{\n\tstruct libmnt_optmap const *maps[1];\n\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\tchar *name, *val, *str = (char *) optstr;\n\tsize_t namesz, valsz;\n\tint rc = 0;\n\n\tif (!optstr || !subset)\n\t\treturn -EINVAL;\n\n\tmaps[0] = map;\n\n\tul_buffer_set_chunksize(&buf, strlen(optstr)/2);\n\n\twhile (!mnt_optstr_next_option(&str, &name, &namesz, &val, &valsz)) {\n\t\tconst struct libmnt_optmap *ent;\n\n\t\tmnt_optmap_get_entry(maps, 1, name, namesz, &ent);\n\n\t\tif (!ent || !ent->id)\n\t\t\tcontinue;\t/* ignore undefined options (comments) */\n\n\t\tif (ignore && (ent->mask & ignore))\n\t\t\tcontinue;\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tcontinue;\n\n\t\trc = __buffer_append_option(&buf, name, namesz, val, valsz);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\t*subset  = rc ? NULL : ul_buffer_get_data(&buf, NULL, NULL);\n\tif (rc)\n\t\tul_buffer_free_data(&buf);\n\treturn rc;\n}\n\n\n/**\n * mnt_optstr_get_flags:\n * @optstr: string with comma separated list of options\n * @flags: returns mount flags\n * @map: options map\n *\n * Returns in @flags IDs of options from @optstr as defined in the @map.\n *\n * For example:\n *\n *\t\"bind,exec,foo,bar\"   --returns->   MS_BIND\n *\n *\t\"bind,noexec,foo,bar\" --returns->   MS_BIND|MS_NOEXEC\n *\n * Note that @flags are not zeroized by this function! This function sets/unsets\n * bits in the @flags only.\n *\n * Returns: 0 on success or negative number in case of error\n */\nint mnt_optstr_get_flags(const char *optstr, unsigned long *flags,\n\t\tconst struct libmnt_optmap *map)\n{\n\tstruct libmnt_optmap const *maps[2];\n\tchar *name, *str = (char *) optstr;\n\tsize_t namesz = 0, valsz = 0;\n\tint nmaps = 0;\n\n\tif (!optstr || !flags || !map)\n\t\treturn -EINVAL;\n\n\tmaps[nmaps++] = map;\n\n\tif (map == mnt_get_builtin_optmap(MNT_LINUX_MAP))\n\t\t/*\n\t\t * Add userspace map -- the \"user\" is interpreted as\n\t\t *                      MS_NO{EXEC,SUID,DEV}.\n\t\t */\n\t\tmaps[nmaps++] = mnt_get_builtin_optmap(MNT_USERSPACE_MAP);\n\n\twhile(!mnt_optstr_next_option(&str, &name, &namesz, NULL, &valsz)) {\n\t\tconst struct libmnt_optmap *ent;\n\t\tconst struct libmnt_optmap *m;\n\n\t\tm = mnt_optmap_get_entry(maps, nmaps, name, namesz, &ent);\n\t\tif (!m || !ent || !ent->id)\n\t\t\tcontinue;\n\n\t\t/* ignore name=<value> if options map expects <name> only */\n\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\tcontinue;\n\n\t\tif (m == map) {\t\t\t\t/* requested map */\n\t\t\tif (ent->mask & MNT_INVERT)\n\t\t\t\t*flags &= ~ent->id;\n\t\t\telse\n\t\t\t\t*flags |= ent->id;\n\n\t\t} else if (nmaps == 2 && m == maps[1] && valsz == 0) {\n\t\t\t/*\n\t\t\t * Special case -- translate \"user\" (but no user=) to\n\t\t\t * MS_ options\n\t\t\t */\n\t\t\tif (ent->mask & MNT_INVERT)\n\t\t\t\tcontinue;\n\t\t\tif (ent->id & (MNT_MS_OWNER | MNT_MS_GROUP))\n\t\t\t\t*flags |= MS_OWNERSECURE;\n\t\t\telse if (ent->id & (MNT_MS_USER | MNT_MS_USERS))\n\t\t\t\t*flags |= MS_SECURE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * mnt_optstr_apply_flags:\n * @optstr: string with comma separated list of options\n * @flags: returns mount flags\n * @map: options map\n *\n * Removes/adds options to the @optstr according to flags. For example:\n *\n *\tMS_NOATIME and \"foo,bar,noexec\"   --returns->  \"foo,bar,noatime\"\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_optstr_apply_flags(char **optstr, unsigned long flags,\n\t\t\t\tconst struct libmnt_optmap *map)\n{\n\tstruct libmnt_optmap const *maps[1];\n\tchar *name, *next, *val;\n\tsize_t namesz = 0, valsz = 0, multi = 0;\n\tunsigned long fl;\n\tint rc = 0;\n\n\tif (!optstr || !map)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"applying 0x%08lx flags to '%s'\", flags, *optstr));\n\n\tmaps[0] = map;\n\tnext = *optstr;\n\tfl = flags;\n\n\t/*\n\t * There is a convention that 'rw/ro' flags are always at the beginning of\n\t * the string (although the 'rw' is unnecessary).\n\t */\n\tif (map == mnt_get_builtin_optmap(MNT_LINUX_MAP)) {\n\t\tconst char *o = (fl & MS_RDONLY) ? \"ro\" : \"rw\";\n\n\t\tif (next &&\n\t\t    (!strncmp(next, \"rw\", 2) || !strncmp(next, \"ro\", 2)) &&\n\t\t    (*(next + 2) == '\\0' || *(next + 2) == ',')) {\n\n\t\t\t/* already set, be paranoid and fix it */\n\t\t\tmemcpy(next, o, 2);\n\t\t} else {\n\t\t\trc = mnt_optstr_prepend_option(optstr, o, NULL);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\t\t\tnext = *optstr;\t\t/* because realloc() */\n\t\t}\n\t\tfl &= ~MS_RDONLY;\n\t\tnext += 2;\n\t\tif (*next == ',')\n\t\t\tnext++;\n\t}\n\n\tif (next && *next) {\n\t\t/*\n\t\t * scan @optstr and remove options that are missing in\n\t\t * @flags\n\t\t */\n\t\twhile(!mnt_optstr_next_option(&next, &name, &namesz,\n\t\t\t\t\t\t\t&val, &valsz)) {\n\t\t\tconst struct libmnt_optmap *ent;\n\n\t\t\tif (mnt_optmap_get_entry(maps, 1, name, namesz, &ent)) {\n\t\t\t\t/*\n\t\t\t\t * remove unwanted option (rw/ro is already set)\n\t\t\t\t */\n\t\t\t\tif (!ent || !ent->id)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* ignore name=<value> if options map expects <name> only */\n\t\t\t\tif (valsz && mnt_optmap_entry_novalue(ent))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (ent->id == MS_RDONLY ||\n\t\t\t\t    (ent->mask & MNT_INVERT) ||\n\t\t\t\t    (fl & ent->id) != (unsigned long) ent->id) {\n\n\t\t\t\t\tchar *end = val ? val + valsz :\n\t\t\t\t\t\t\t  name + namesz;\n\t\t\t\t\tnext = name;\n\t\t\t\t\trc = mnt_optstr_remove_option_at(\n\t\t\t\t\t\t\toptstr, name, end);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (!(ent->mask & MNT_INVERT)) {\n\t\t\t\t\t/* allow options with prefix (X-mount.foo,X-mount.bar) more than once */\n\t\t\t\t\tif (ent->mask & MNT_PREFIX)\n\t\t\t\t\t\tmulti |= ent->id;\n\t\t\t\t\telse\n\t\t\t\t\t\tfl &= ~ent->id;\n\t\t\t\t\tif (ent->id & MS_REC)\n\t\t\t\t\t\tfl |= MS_REC;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove from flags options which are allowed more than once */\n\tfl &= ~multi;\n\n\t/* add missing options (but ignore fl if contains MS_REC only) */\n\tif (fl && fl != MS_REC) {\n\n\t\tconst struct libmnt_optmap *ent;\n\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\tsize_t sz;\n\t\tchar *p;\n\n\t\tul_buffer_refer_string(&buf, *optstr);\n\n\t\tfor (ent = map; ent && ent->name; ent++) {\n\t\t\tif ((ent->mask & MNT_INVERT)\n\t\t\t    || ent->id == 0\n\t\t\t    || (fl & ent->id) != (unsigned long) ent->id)\n\t\t\t\tcontinue;\n\n\t\t\t/* don't add options which require values (e.g. offset=%d) */\n\t\t\tp = strchr(ent->name, '=');\n\t\t\tif (p) {\n\t\t\t\tif (p > ent->name && *(p - 1) == '[')\n\t\t\t\t\tp--;\t\t\t/* name[=] */\n\t\t\t\telse\n\t\t\t\t\tcontinue;\t\t/* name= */\n\t\t\t\tsz = p - ent->name;\n\t\t\t} else\n\t\t\t\tsz = strlen(ent->name);\n\n\t\t\trc = __buffer_append_option(&buf, ent->name, sz, NULL, 0);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t*optstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t}\n\n\tDBG(CXT, ul_debug(\"new optstr '%s'\", *optstr));\n\treturn rc;\nerr:\n\tDBG(CXT, ul_debug(\"failed to apply flags [rc=%d]\", rc));\n\treturn rc;\n}\n\n/*\n * @optstr: string with comma separated list of options\n * @value: pointer to the begin of the context value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n *\n * Translates SELinux context from human to raw format. The function does not\n * modify @optstr and returns zero if libmount is compiled without SELinux\n * support.\n *\n * Returns: 0 on success, a negative number in case of error.\n */\n#ifndef HAVE_LIBSELINUX\nint mnt_optstr_fix_secontext(char **optstr __attribute__ ((__unused__)),\n\t\t\t     char *value   __attribute__ ((__unused__)),\n\t\t\t     size_t valsz  __attribute__ ((__unused__)),\n\t\t\t     char **next   __attribute__ ((__unused__)))\n{\n\treturn 0;\n}\n#else\nint mnt_optstr_fix_secontext(char **optstr,\n\t\t\t     char *value,\n\t\t\t     size_t valsz,\n\t\t\t     char **next)\n{\n\tint rc = 0;\n\tchar *p, *val, *begin, *end, *raw = NULL;\n\tsize_t sz;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing SELinux context\"));\n\n\tbegin = value;\n\tend = value + valsz;\n\n\t/* the selinux contexts are quoted */\n\tif (*value == '\"') {\n\t\tif (valsz <= 2 || *(value + valsz - 1) != '\"')\n\t\t\treturn -EINVAL;\t\t/* improperly quoted option string */\n\t\tvalue++;\n\t\tvalsz -= 2;\n\t}\n\n\tp = strndup(value, valsz);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\n\t/* translate the context */\n\trc = selinux_trans_to_raw_context(p, &raw);\n\n\tDBG(CXT, ul_debug(\"SELinux context '%s' translated to '%s'\",\n\t\t\tp, rc == -1 ? \"FAILED\" : (char *) raw));\n\n\tfree(p);\n\tif (rc == -1 ||\t!raw)\n\t\treturn -EINVAL;\n\n\n\t/* create a quoted string from the raw context */\n\tsz = strlen((char *) raw);\n\tif (!sz)\n\t\treturn -EINVAL;\n\n\tp = val = malloc(valsz + 3);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\t*p++ = '\"';\n\tmemcpy(p, raw, sz);\n\tp += sz;\n\t*p++ = '\"';\n\t*p = '\\0';\n\n\tfreecon(raw);\n\n\t/* set new context */\n\tmnt_optstr_remove_option_at(optstr, begin, end);\n\trc = insert_value(optstr, begin, val, next);\n\tfree(val);\n\n\treturn rc;\n}\n#endif\n\nstatic int set_uint_value(char **optstr, unsigned int num,\n\t\t\tchar *begin, char *end, char **next)\n{\n\tchar buf[40];\n\tsnprintf(buf, sizeof(buf), \"%u\", num);\n\n\tmnt_optstr_remove_option_at(optstr, begin, end);\n\treturn insert_value(optstr, begin, buf, next);\n}\n\n/*\n * @optstr: string with a comma separated list of options\n * @value: pointer to the beginning of the uid value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n\n * Translates \"username\" or \"useruid\" to the real UID.\n *\n * For example:\n *\tif (!mnt_optstr_get_option(optstr, \"uid\", &val, &valsz))\n *\t\tmnt_optstr_fix_uid(&optstr, val, valsz, NULL);\n *\n * Returns: 0 on success, a negative number in case of error.\n */\nint mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next)\n{\n\tchar *end;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing uid\"));\n\n\tend = value + valsz;\n\n\tif (valsz == 7 && !strncmp(value, \"useruid\", 7) &&\n\t    (*(value + 7) == ',' || !*(value + 7)))\n\t\treturn set_uint_value(optstr, getuid(), value, end, next);\n\n\tif (!isdigit(*value)) {\n\t\tuid_t id;\n\t\tint rc;\n\t\tchar *p = strndup(value, valsz);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\trc = mnt_get_uid(p, &id);\n\t\tfree(p);\n\n\t\tif (!rc)\n\t\t\treturn set_uint_value(optstr, id, value, end, next);\n\t}\n\n\tif (next) {\n\t\t/* no change, let's keep the original value */\n\t\t*next = value + valsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\n\treturn 0;\n}\n\n/*\n * @optstr: string with a comma separated list of options\n * @value: pointer to the beginning of the uid value\n * @valsz: size of the value\n * @next: returns pointer to the next option (optional argument)\n\n * Translates \"groupname\" or \"usergid\" to the real GID.\n *\n * Returns: 0 on success, a negative number in case of error.\n */\nint mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next)\n{\n\tchar *end;\n\n\tif (!optstr || !*optstr || !value || !valsz)\n\t\treturn -EINVAL;\n\n\tDBG(CXT, ul_debug(\"fixing gid\"));\n\n\tend = value + valsz;\n\n\tif (valsz == 7 && !strncmp(value, \"usergid\", 7) &&\n\t    (*(value + 7) == ',' || !*(value + 7)))\n\t\treturn set_uint_value(optstr, getgid(), value, end, next);\n\n\tif (!isdigit(*value)) {\n\t\tint rc;\n\t\tgid_t id;\n\t\tchar *p = strndup(value, valsz);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\trc = mnt_get_gid(p, &id);\n\t\tfree(p);\n\n\t\tif (!rc)\n\t\t\treturn set_uint_value(optstr, id, value, end, next);\n\n\t}\n\n\tif (next) {\n\t\t/* nothing */\n\t\t*next = value + valsz;\n\t\tif (**next == ',')\n\t\t\t(*next)++;\n\t}\n\treturn 0;\n}\n\n/*\n * Converts \"user\" to \"user=<username>\".\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_optstr_fix_user(char **optstr)\n{\n\tchar *username;\n\tstruct libmnt_optloc ol = MNT_INIT_OPTLOC;\n\tint rc = 0;\n\n\tDBG(CXT, ul_debug(\"fixing user\"));\n\n\trc = mnt_optstr_locate_option(*optstr, \"user\", &ol);\n\tif (rc)\n\t\treturn rc == 1 ? 0 : rc;\t/* 1: user= not found */\n\n\tusername = mnt_get_username(getuid());\n\tif (!username)\n\t\treturn -ENOMEM;\n\n\tif (!ol.valsz || (ol.value && strncmp(ol.value, username, ol.valsz) != 0)) {\n\t\tif (ol.valsz)\n\t\t\t/* remove old value */\n\t\t\tmnt_optstr_remove_option_at(optstr, ol.value, ol.end);\n\n\t\trc = insert_value(optstr, ol.value ? ol.value : ol.end,\n\t\t\t\t  username, NULL);\n\t}\n\n\tfree(username);\n\treturn rc;\n}\n\n/*\n * Converts value from @optstr addressed by @name to uid.\n *\n * Returns: 0 on success, 1 if not found, <0 on error\n */\nint mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid)\n{\n\tchar *value = NULL;\n\tsize_t valsz = 0;\n\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n\tint rc;\n\tuint64_t num;\n\n\tassert(optstr);\n\tassert(name);\n\tassert(uid);\n\n\trc = mnt_optstr_get_option(optstr, name, &value, &valsz);\n\tif (rc != 0)\n\t\tgoto fail;\n\n\tif (valsz > sizeof(buf) - 1) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\tmem2strcpy(buf, value, valsz, sizeof(buf));\n\n\trc = ul_strtou64(buf, &num, 10);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (num > ULONG_MAX || (uid_t) num != num) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\t*uid = (uid_t) num;\n\n\treturn 0;\nfail:\n\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\", name, rc));\n\treturn rc;\n}\n\n/**\n * mnt_match_options:\n * @optstr: options string\n * @pattern: comma delimited list of options\n *\n * The \"no\" could be used for individual items in the @options list. The \"no\"\n * prefix does not have a global meaning.\n *\n * Unlike fs type matching, nonetdev,user and nonetdev,nouser have\n * DIFFERENT meanings; each option is matched explicitly as specified.\n *\n * The \"no\" prefix interpretation could be disabled by the \"+\" prefix, for example\n * \"+noauto\" matches if @optstr literally contains the \"noauto\" string.\n *\n * \"xxx,yyy,zzz\" : \"nozzz\"\t-> False\n *\n * \"xxx,yyy,zzz\" : \"xxx,noeee\"\t-> True\n *\n * \"bar,zzz\"     : \"nofoo\"      -> True\t\t(does not contain \"foo\")\n *\n * \"nofoo,bar\"   : \"nofoo\"      -> True\t\t(does not contain \"foo\")\n *\n * \"nofoo,bar\"   : \"+nofoo\"     -> True\t\t(contains \"nofoo\")\n *\n * \"bar,zzz\"     : \"+nofoo\"     -> False\t(does not contain \"nofoo\")\n *\n *\n * Returns: 1 if pattern is matching, else 0. This function also returns 0\n *          if @pattern is NULL and @optstr is non-NULL.\n */\nint mnt_match_options(const char *optstr, const char *pattern)\n{\n\tchar *name, *pat = (char *) pattern;\n\tchar *buf, *patval;\n\tsize_t namesz = 0, patvalsz = 0;\n\tint match = 1;\n\n\tif (!pattern && !optstr)\n\t\treturn 1;\n\tif (!pattern)\n\t\treturn 0;\n\n\tbuf = malloc(strlen(pattern) + 1);\n\tif (!buf)\n\t\treturn 0;\n\n\t/* walk on pattern string\n\t */\n\twhile (match && !mnt_optstr_next_option(&pat, &name, &namesz,\n\t\t\t\t\t\t&patval, &patvalsz)) {\n\t\tchar *val;\n\t\tsize_t sz;\n\t\tint no = 0, rc;\n\n\t\tif (*name == '+')\n\t\t\tname++, namesz--;\n\t\telse if ((no = (startswith(name, \"no\") != NULL)))\n\t\t\tname += 2, namesz -= 2;\n\n\t\txstrncpy(buf, name, namesz + 1);\n\n\t\trc = mnt_optstr_get_option(optstr, buf, &val, &sz);\n\n\t\t/* check also value (if the pattern is \"foo=value\") */\n\t\tif (rc == 0 && patvalsz > 0 &&\n\t\t    (patvalsz != sz || strncmp(patval, val, sz) != 0))\n\t\t\trc = 1;\n\n\t\tswitch (rc) {\n\t\tcase 0:\t\t/* found */\n\t\t\tmatch = no == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 1:\t\t/* not found */\n\t\t\tmatch = no == 1 ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\t/* parse error */\n\t\t\tmatch = 0;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tfree(buf);\n\treturn match;\n}\n\n#ifdef TEST_PROGRAM\n#include \"xalloc.h\"\n\nstatic int test_append(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_append_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_prepend(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_prepend_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_split(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr, *user = NULL, *fs = NULL, *vfs = NULL;\n\tint rc;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\toptstr = xstrdup(argv[1]);\n\n\trc = mnt_split_optstr(optstr, &user, &vfs, &fs, 0, 0);\n\tif (!rc) {\n\t\tprintf(\"user : %s\\n\", user);\n\t\tprintf(\"vfs  : %s\\n\", vfs);\n\t\tprintf(\"fs   : %s\\n\", fs);\n\t}\n\n\tfree(user);\n\tfree(vfs);\n\tfree(fs);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_flags(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc;\n\tunsigned long fl = 0;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\toptstr = xstrdup(argv[1]);\n\n\trc = mnt_optstr_get_flags(optstr, &fl, mnt_get_builtin_optmap(MNT_LINUX_MAP));\n\tif (rc)\n\t\treturn rc;\n\tprintf(\"mountflags:           0x%08lx\\n\", fl);\n\n\tfl = 0;\n\trc = mnt_optstr_get_flags(optstr, &fl, mnt_get_builtin_optmap(MNT_USERSPACE_MAP));\n\tif (rc)\n\t\treturn rc;\n\tprintf(\"userspace-mountflags: 0x%08lx\\n\", fl);\n\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_apply(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc, map;\n\tunsigned long flags;\n\n\tif (argc < 4)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(argv[1], \"--user\"))\n\t\tmap = MNT_USERSPACE_MAP;\n\telse if (!strcmp(argv[1], \"--linux\"))\n\t\tmap = MNT_LINUX_MAP;\n\telse {\n\t\tfprintf(stderr, \"unknown option '%s'\\n\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\toptstr = xstrdup(argv[2]);\n\tflags = strtoul(argv[3], NULL, 16);\n\n\tprintf(\"flags:  0x%08lx\\n\", flags);\n\n\trc = mnt_optstr_apply_flags(&optstr, flags, mnt_get_builtin_optmap(map));\n\tprintf(\"optstr: %s\\n\", optstr);\n\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_set(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *value = NULL, *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\tif (argc == 4)\n\t\tvalue = argv[3];\n\n\trc = mnt_optstr_set_option(&optstr, name, value);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_get(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tconst char *name;\n\tchar *val = NULL;\n\tsize_t sz = 0;\n\tint rc;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\toptstr = argv[1];\n\tname = argv[2];\n\n\trc = mnt_optstr_get_option(optstr, name, &val, &sz);\n\tif (rc == 0) {\n\t\tprintf(\"found; name: %s\", name);\n\t\tif (sz) {\n\t\t\tprintf(\", argument: size=%zd data=\", sz);\n\t\t\tif (fwrite(val, 1, sz, stdout) != sz)\n\t\t\t\treturn -1;\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else if (rc == 1)\n\t\tprintf(\"%s: not found\\n\", name);\n\telse\n\t\tprintf(\"parse error: %s\\n\", optstr);\n\treturn rc;\n}\n\nstatic int test_remove(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\trc = mnt_optstr_remove_option(&optstr, name);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_dedup(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tconst char *name;\n\tchar *optstr;\n\tint rc;\n\n\tif (argc < 3)\n\t\treturn -EINVAL;\n\toptstr = xstrdup(argv[1]);\n\tname = argv[2];\n\n\trc = mnt_optstr_deduplicate_option(&optstr, name);\n\tif (!rc)\n\t\tprintf(\"result: >%s<\\n\", optstr);\n\tfree(optstr);\n\treturn rc;\n}\n\nstatic int test_fix(struct libmnt_test *ts, int argc, char *argv[])\n{\n\tchar *optstr;\n\tint rc = 0;\n\tchar *name, *val, *next;\n\tsize_t valsz, namesz;\n\n\tif (argc < 2)\n\t\treturn -EINVAL;\n\n\tnext = optstr = xstrdup(argv[1]);\n\n\tprintf(\"optstr: %s\\n\", optstr);\n\n\twhile (!mnt_optstr_next_option(&next, &name, &namesz, &val, &valsz)) {\n\n\t\tif (!strncmp(name, \"uid\", 3))\n\t\t\trc = mnt_optstr_fix_uid(&optstr, val, valsz, &next);\n\t\telse if (!strncmp(name, \"gid\", 3))\n\t\t\trc = mnt_optstr_fix_gid(&optstr, val, valsz, &next);\n\t\telse if (!strncmp(name, \"context\", 7))\n\t\t\trc = mnt_optstr_fix_secontext(&optstr, val, valsz, &next);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (rc)\n\t\trc = mnt_optstr_fix_user(&optstr);\n\n\tprintf(\"fixed:  %s\\n\", optstr);\n\n\tfree(optstr);\n\treturn rc;\n\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct libmnt_test tss[] = {\n\t\t{ \"--append\", test_append, \"<optstr> <name> [<value>]  append value to optstr\" },\n\t\t{ \"--prepend\",test_prepend,\"<optstr> <name> [<value>]  prepend value to optstr\" },\n\t\t{ \"--set\",    test_set,    \"<optstr> <name> [<value>]  (un)set value\" },\n\t\t{ \"--get\",    test_get,    \"<optstr> <name>            search name in optstr\" },\n\t\t{ \"--remove\", test_remove, \"<optstr> <name>            remove name in optstr\" },\n\t\t{ \"--dedup\",  test_dedup,  \"<optstr> <name>            deduplicate name in optstr\" },\n\t\t{ \"--split\",  test_split,  \"<optstr>                   split into FS, VFS and userspace\" },\n\t\t{ \"--flags\",  test_flags,  \"<optstr>                   convert options to MS_* flags\" },\n\t\t{ \"--apply\",  test_apply,  \"--{linux,user} <optstr> <mask>    apply mask to optstr\" },\n\t\t{ \"--fix\",    test_fix,    \"<optstr>                   fix uid=, gid=, user, and context=\" },\n\n\t\t{ NULL }\n\t};\n\treturn  mnt_run_test(tss, argc, argv);\n}\n#endif /* TEST_PROGRAM */\n"], "filenames": ["libmount/src/context_umount.c", "libmount/src/mountP.h", "libmount/src/optstr.c"], "buggy_code_start_loc": [455, 401, 1085], "buggy_code_end_loc": [498, 401, 1085], "fixing_code_start_loc": [455, 402, 1086], "fixing_code_end_loc": [490, 403, 1128], "type": "CWE-552", "message": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.", "other": {"cve": {"id": "CVE-2021-3995", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T20:15:08.493", "lastModified": "2023-02-03T23:30:56.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems."}, {"lang": "es", "value": "Se ha encontrado un error l\u00f3gico en la biblioteca libmount de util-linux en la funci\u00f3n que permite a un usuario no privilegiado desmontar un sistema de archivos FUSE. Este fallo permite a un atacante local no privilegiado desmontar sistemas de archivos FUSE que pertenecen a otros usuarios determinados que presentan un UID que es un prefijo del UID del atacante en su forma de cadena. Un atacante puede usar este fallo para causar una denegaci\u00f3n de servicio a las aplicaciones que usan los sistemas de archivos afectados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.34", "versionEndExcluding": "2.37.3", "matchCriteriaId": "755D0AAC-24D9-4B39-BCC2-06AC9FF889E2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/170176/snap-confine-must_mkdir_and_open_with_perms-Race-Condition.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2022/Dec/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/11/30/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024631https://access.redhat.com/security/cve/CVE-2021-3995", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking"]}, {"url": "https://github.com/util-linux/util-linux/commit/57202f5713afa2af20ffbb6ab5331481d0396f8d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.37/v2.37.3-ReleaseNotes", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221209-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/01/24/2", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/util-linux/util-linux/commit/57202f5713afa2af20ffbb6ab5331481d0396f8d"}}