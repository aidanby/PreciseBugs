{"buggy_code": ["/*******************************************************************************\n * Filename:  target_core_rd.c\n *\n * This file contains the Storage Engine <-> Ramdisk transport\n * specific functions.\n *\n * (c) Copyright 2003-2013 Datera, Inc.\n *\n * Nicholas A. Bellinger <nab@kernel.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n ******************************************************************************/\n\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n\n#include \"target_core_rd.h\"\n\nstatic inline struct rd_dev *RD_DEV(struct se_device *dev)\n{\n\treturn container_of(dev, struct rd_dev, dev);\n}\n\n/*\trd_attach_hba(): (Part of se_subsystem_api_t template)\n *\n *\n */\nstatic int rd_attach_hba(struct se_hba *hba, u32 host_id)\n{\n\tstruct rd_host *rd_host;\n\n\trd_host = kzalloc(sizeof(struct rd_host), GFP_KERNEL);\n\tif (!rd_host) {\n\t\tpr_err(\"Unable to allocate memory for struct rd_host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trd_host->rd_host_id = host_id;\n\n\thba->hba_ptr = rd_host;\n\n\tpr_debug(\"CORE_HBA[%d] - TCM Ramdisk HBA Driver %s on\"\n\t\t\" Generic Target Core Stack %s\\n\", hba->hba_id,\n\t\tRD_HBA_VERSION, TARGET_CORE_MOD_VERSION);\n\n\treturn 0;\n}\n\nstatic void rd_detach_hba(struct se_hba *hba)\n{\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\tpr_debug(\"CORE_HBA[%d] - Detached Ramdisk HBA: %u from\"\n\t\t\" Generic Target Core\\n\", hba->hba_id, rd_host->rd_host_id);\n\n\tkfree(rd_host);\n\thba->hba_ptr = NULL;\n}\n\n/*\trd_release_device_space():\n *\n *\n */\nstatic void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\n\tsg_table = rd_dev->sg_table_array;\n\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\n\t\tkfree(sg);\n\t}\n\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}\n\n\n/*\trd_build_device_space():\n *\n *\n */\nstatic int rd_build_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t\trd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Don't need backing pages for NULLIO */\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\n\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n\tif (!sg_table) {\n\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n\t\t\t\" scatterlist tables\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_table(sg, sg_per_table);\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\t\t}\n\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\n\tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count);\n\n\treturn 0;\n}\n\nstatic struct se_device *rd_alloc_device(struct se_hba *hba, const char *name)\n{\n\tstruct rd_dev *rd_dev;\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\trd_dev = kzalloc(sizeof(struct rd_dev), GFP_KERNEL);\n\tif (!rd_dev) {\n\t\tpr_err(\"Unable to allocate memory for struct rd_dev\\n\");\n\t\treturn NULL;\n\t}\n\n\trd_dev->rd_host = rd_host;\n\n\treturn &rd_dev->dev;\n}\n\nstatic int rd_configure_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tstruct rd_host *rd_host = dev->se_hba->hba_ptr;\n\tint ret;\n\n\tif (!(rd_dev->rd_flags & RDF_HAS_PAGE_COUNT)) {\n\t\tpr_debug(\"Missing rd_pages= parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rd_build_device_space(rd_dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdev->dev_attrib.hw_block_size = RD_BLOCKSIZE;\n\tdev->dev_attrib.hw_max_sectors = UINT_MAX;\n\tdev->dev_attrib.hw_queue_depth = RD_MAX_DEVICE_QUEUE_DEPTH;\n\n\trd_dev->rd_dev_id = rd_host->rd_host_dev_id_count++;\n\n\tpr_debug(\"CORE_RD[%u] - Added TCM MEMCPY Ramdisk Device ID: %u of\"\n\t\t\" %u pages in %u tables, %lu total bytes\\n\",\n\t\trd_host->rd_host_id, rd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count,\n\t\t(unsigned long)(rd_dev->rd_page_count * PAGE_SIZE));\n\n\treturn 0;\n\nfail:\n\trd_release_device_space(rd_dev);\n\treturn ret;\n}\n\nstatic void rd_free_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\trd_release_device_space(rd_dev);\n\tkfree(rd_dev);\n}\n\nstatic struct rd_dev_sg_table *rd_get_sg_table(struct rd_dev *rd_dev, u32 page)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 i, sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\n\ti = page / sg_per_table;\n\tif (i < rd_dev->sg_table_count) {\n\t\tsg_table = &rd_dev->sg_table_array[i];\n\t\tif ((sg_table->page_start_offset <= page) &&\n\t\t    (sg_table->page_end_offset >= page))\n\t\t\treturn sg_table;\n\t}\n\n\tpr_err(\"Unable to locate struct rd_dev_sg_table for page: %u\\n\",\n\t\t\tpage);\n\n\treturn NULL;\n}\n\nstatic sense_reason_t\nrd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tstruct se_device *se_dev = cmd->se_dev;\n\tstruct rd_dev *dev = RD_DEV(se_dev);\n\tstruct rd_dev_sg_table *table;\n\tstruct scatterlist *rd_sg;\n\tstruct sg_mapping_iter m;\n\tu32 rd_offset;\n\tu32 rd_size;\n\tu32 rd_page;\n\tu32 src_len;\n\tu64 tmp;\n\n\tif (dev->rd_flags & RDF_NULLIO) {\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\t\treturn 0;\n\t}\n\n\ttmp = cmd->t_task_lba * se_dev->dev_attrib.block_size;\n\trd_offset = do_div(tmp, PAGE_SIZE);\n\trd_page = tmp;\n\trd_size = cmd->data_length;\n\n\ttable = rd_get_sg_table(dev, rd_page);\n\tif (!table)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\trd_sg = &table->sg_table[rd_page - table->page_start_offset];\n\n\tpr_debug(\"RD[%u]: %s LBA: %llu, Size: %u Page: %u, Offset: %u\\n\",\n\t\t\tdev->rd_dev_id,\n\t\t\tdata_direction == DMA_FROM_DEVICE ? \"Read\" : \"Write\",\n\t\t\tcmd->t_task_lba, rd_size, rd_page, rd_offset);\n\n\tsrc_len = PAGE_SIZE - rd_offset;\n\tsg_miter_start(&m, sgl, sgl_nents,\n\t\t\tdata_direction == DMA_FROM_DEVICE ?\n\t\t\t\tSG_MITER_TO_SG : SG_MITER_FROM_SG);\n\twhile (rd_size) {\n\t\tu32 len;\n\t\tvoid *rd_addr;\n\n\t\tsg_miter_next(&m);\n\t\tif (!(u32)m.length) {\n\t\t\tpr_debug(\"RD[%u]: invalid sgl %p len %zu\\n\",\n\t\t\t\t dev->rd_dev_id, m.addr, m.length);\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_INCORRECT_AMOUNT_OF_DATA;\n\t\t}\n\t\tlen = min((u32)m.length, src_len);\n\t\tif (len > rd_size) {\n\t\t\tpr_debug(\"RD[%u]: size underrun page %d offset %d \"\n\t\t\t\t \"size %d\\n\", dev->rd_dev_id,\n\t\t\t\t rd_page, rd_offset, rd_size);\n\t\t\tlen = rd_size;\n\t\t}\n\t\tm.consumed = len;\n\n\t\trd_addr = sg_virt(rd_sg) + rd_offset;\n\n\t\tif (data_direction == DMA_FROM_DEVICE)\n\t\t\tmemcpy(m.addr, rd_addr, len);\n\t\telse\n\t\t\tmemcpy(rd_addr, m.addr, len);\n\n\t\trd_size -= len;\n\t\tif (!rd_size)\n\t\t\tcontinue;\n\n\t\tsrc_len -= len;\n\t\tif (src_len) {\n\t\t\trd_offset += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* rd page completed, next one please */\n\t\trd_page++;\n\t\trd_offset = 0;\n\t\tsrc_len = PAGE_SIZE;\n\t\tif (rd_page <= table->page_end_offset) {\n\t\t\trd_sg++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = rd_get_sg_table(dev, rd_page);\n\t\tif (!table) {\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\n\t\t/* since we increment, the first sg entry is correct */\n\t\trd_sg = table->sg_table;\n\t}\n\tsg_miter_stop(&m);\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nenum {\n\tOpt_rd_pages, Opt_rd_nullio, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_rd_pages, \"rd_pages=%d\"},\n\t{Opt_rd_nullio, \"rd_nullio=%d\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t rd_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0, arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_rd_pages:\n\t\t\tmatch_int(args, &arg);\n\t\t\trd_dev->rd_page_count = arg;\n\t\t\tpr_debug(\"RAMDISK: Referencing Page\"\n\t\t\t\t\" Count: %u\\n\", rd_dev->rd_page_count);\n\t\t\trd_dev->rd_flags |= RDF_HAS_PAGE_COUNT;\n\t\t\tbreak;\n\t\tcase Opt_rd_nullio:\n\t\t\tmatch_int(args, &arg);\n\t\t\tif (arg != 1)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"RAMDISK: Setting NULLIO flag: %d\\n\", arg);\n\t\t\trd_dev->rd_flags |= RDF_NULLIO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(orig);\n\treturn (!ret) ? count : ret;\n}\n\nstatic ssize_t rd_show_configfs_dev_params(struct se_device *dev, char *b)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tssize_t bl = sprintf(b, \"TCM RamDisk ID: %u  RamDisk Makeup: rd_mcp\\n\",\n\t\t\trd_dev->rd_dev_id);\n\tbl += sprintf(b + bl, \"        PAGES/PAGE_SIZE: %u*%lu\"\n\t\t\t\"  SG_table_count: %u  nullio: %d\\n\", rd_dev->rd_page_count,\n\t\t\tPAGE_SIZE, rd_dev->sg_table_count,\n\t\t\t!!(rd_dev->rd_flags & RDF_NULLIO));\n\treturn bl;\n}\n\nstatic sector_t rd_get_blocks(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tunsigned long long blocks_long = ((rd_dev->rd_page_count * PAGE_SIZE) /\n\t\t\tdev->dev_attrib.block_size) - 1;\n\n\treturn blocks_long;\n}\n\nstatic struct sbc_ops rd_sbc_ops = {\n\t.execute_rw\t\t= rd_execute_rw,\n};\n\nstatic sense_reason_t\nrd_parse_cdb(struct se_cmd *cmd)\n{\n\treturn sbc_parse_cdb(cmd, &rd_sbc_ops);\n}\n\nstatic struct se_subsystem_api rd_mcp_template = {\n\t.name\t\t\t= \"rd_mcp\",\n\t.inquiry_prod\t\t= \"RAMDISK-MCP\",\n\t.inquiry_rev\t\t= RD_MCP_VERSION,\n\t.transport_type\t\t= TRANSPORT_PLUGIN_VHBA_VDEV,\n\t.attach_hba\t\t= rd_attach_hba,\n\t.detach_hba\t\t= rd_detach_hba,\n\t.alloc_device\t\t= rd_alloc_device,\n\t.configure_device\t= rd_configure_device,\n\t.free_device\t\t= rd_free_device,\n\t.parse_cdb\t\t= rd_parse_cdb,\n\t.set_configfs_dev_params = rd_set_configfs_dev_params,\n\t.show_configfs_dev_params = rd_show_configfs_dev_params,\n\t.get_device_type\t= sbc_get_device_type,\n\t.get_blocks\t\t= rd_get_blocks,\n};\n\nint __init rd_module_init(void)\n{\n\tint ret;\n\n\tret = transport_subsystem_register(&rd_mcp_template);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid rd_module_exit(void)\n{\n\ttransport_subsystem_release(&rd_mcp_template);\n}\n"], "fixing_code": ["/*******************************************************************************\n * Filename:  target_core_rd.c\n *\n * This file contains the Storage Engine <-> Ramdisk transport\n * specific functions.\n *\n * (c) Copyright 2003-2013 Datera, Inc.\n *\n * Nicholas A. Bellinger <nab@kernel.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n ******************************************************************************/\n\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n\n#include \"target_core_rd.h\"\n\nstatic inline struct rd_dev *RD_DEV(struct se_device *dev)\n{\n\treturn container_of(dev, struct rd_dev, dev);\n}\n\n/*\trd_attach_hba(): (Part of se_subsystem_api_t template)\n *\n *\n */\nstatic int rd_attach_hba(struct se_hba *hba, u32 host_id)\n{\n\tstruct rd_host *rd_host;\n\n\trd_host = kzalloc(sizeof(struct rd_host), GFP_KERNEL);\n\tif (!rd_host) {\n\t\tpr_err(\"Unable to allocate memory for struct rd_host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trd_host->rd_host_id = host_id;\n\n\thba->hba_ptr = rd_host;\n\n\tpr_debug(\"CORE_HBA[%d] - TCM Ramdisk HBA Driver %s on\"\n\t\t\" Generic Target Core Stack %s\\n\", hba->hba_id,\n\t\tRD_HBA_VERSION, TARGET_CORE_MOD_VERSION);\n\n\treturn 0;\n}\n\nstatic void rd_detach_hba(struct se_hba *hba)\n{\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\tpr_debug(\"CORE_HBA[%d] - Detached Ramdisk HBA: %u from\"\n\t\t\" Generic Target Core\\n\", hba->hba_id, rd_host->rd_host_id);\n\n\tkfree(rd_host);\n\thba->hba_ptr = NULL;\n}\n\nstatic u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\n\tkfree(sg_table);\n\treturn page_count;\n}\n\nstatic void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 page_count;\n\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\n\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n\t\t\t\t\t  rd_dev->sg_table_count);\n\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}\n\n\n/*\trd_build_device_space():\n *\n *\n */\nstatic int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_table(sg, sg_per_table);\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\n\treturn 0;\n}\n\nstatic int rd_build_device_space(struct rd_dev *rd_dev)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 sg_tables, total_sg_needed;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tint rc;\n\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t       rd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Don't need backing pages for NULLIO */\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\n\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n\tif (!sg_table) {\n\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n\t\t       \" scatterlist tables\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n\n\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n\tif (rc)\n\t\treturn rc;\n\n\tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\t rd_dev->sg_table_count);\n\n\treturn 0;\n}\n\nstatic struct se_device *rd_alloc_device(struct se_hba *hba, const char *name)\n{\n\tstruct rd_dev *rd_dev;\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\trd_dev = kzalloc(sizeof(struct rd_dev), GFP_KERNEL);\n\tif (!rd_dev) {\n\t\tpr_err(\"Unable to allocate memory for struct rd_dev\\n\");\n\t\treturn NULL;\n\t}\n\n\trd_dev->rd_host = rd_host;\n\n\treturn &rd_dev->dev;\n}\n\nstatic int rd_configure_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tstruct rd_host *rd_host = dev->se_hba->hba_ptr;\n\tint ret;\n\n\tif (!(rd_dev->rd_flags & RDF_HAS_PAGE_COUNT)) {\n\t\tpr_debug(\"Missing rd_pages= parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rd_build_device_space(rd_dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdev->dev_attrib.hw_block_size = RD_BLOCKSIZE;\n\tdev->dev_attrib.hw_max_sectors = UINT_MAX;\n\tdev->dev_attrib.hw_queue_depth = RD_MAX_DEVICE_QUEUE_DEPTH;\n\n\trd_dev->rd_dev_id = rd_host->rd_host_dev_id_count++;\n\n\tpr_debug(\"CORE_RD[%u] - Added TCM MEMCPY Ramdisk Device ID: %u of\"\n\t\t\" %u pages in %u tables, %lu total bytes\\n\",\n\t\trd_host->rd_host_id, rd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count,\n\t\t(unsigned long)(rd_dev->rd_page_count * PAGE_SIZE));\n\n\treturn 0;\n\nfail:\n\trd_release_device_space(rd_dev);\n\treturn ret;\n}\n\nstatic void rd_free_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\trd_release_device_space(rd_dev);\n\tkfree(rd_dev);\n}\n\nstatic struct rd_dev_sg_table *rd_get_sg_table(struct rd_dev *rd_dev, u32 page)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 i, sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\n\ti = page / sg_per_table;\n\tif (i < rd_dev->sg_table_count) {\n\t\tsg_table = &rd_dev->sg_table_array[i];\n\t\tif ((sg_table->page_start_offset <= page) &&\n\t\t    (sg_table->page_end_offset >= page))\n\t\t\treturn sg_table;\n\t}\n\n\tpr_err(\"Unable to locate struct rd_dev_sg_table for page: %u\\n\",\n\t\t\tpage);\n\n\treturn NULL;\n}\n\nstatic sense_reason_t\nrd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tstruct se_device *se_dev = cmd->se_dev;\n\tstruct rd_dev *dev = RD_DEV(se_dev);\n\tstruct rd_dev_sg_table *table;\n\tstruct scatterlist *rd_sg;\n\tstruct sg_mapping_iter m;\n\tu32 rd_offset;\n\tu32 rd_size;\n\tu32 rd_page;\n\tu32 src_len;\n\tu64 tmp;\n\n\tif (dev->rd_flags & RDF_NULLIO) {\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\t\treturn 0;\n\t}\n\n\ttmp = cmd->t_task_lba * se_dev->dev_attrib.block_size;\n\trd_offset = do_div(tmp, PAGE_SIZE);\n\trd_page = tmp;\n\trd_size = cmd->data_length;\n\n\ttable = rd_get_sg_table(dev, rd_page);\n\tif (!table)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\trd_sg = &table->sg_table[rd_page - table->page_start_offset];\n\n\tpr_debug(\"RD[%u]: %s LBA: %llu, Size: %u Page: %u, Offset: %u\\n\",\n\t\t\tdev->rd_dev_id,\n\t\t\tdata_direction == DMA_FROM_DEVICE ? \"Read\" : \"Write\",\n\t\t\tcmd->t_task_lba, rd_size, rd_page, rd_offset);\n\n\tsrc_len = PAGE_SIZE - rd_offset;\n\tsg_miter_start(&m, sgl, sgl_nents,\n\t\t\tdata_direction == DMA_FROM_DEVICE ?\n\t\t\t\tSG_MITER_TO_SG : SG_MITER_FROM_SG);\n\twhile (rd_size) {\n\t\tu32 len;\n\t\tvoid *rd_addr;\n\n\t\tsg_miter_next(&m);\n\t\tif (!(u32)m.length) {\n\t\t\tpr_debug(\"RD[%u]: invalid sgl %p len %zu\\n\",\n\t\t\t\t dev->rd_dev_id, m.addr, m.length);\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_INCORRECT_AMOUNT_OF_DATA;\n\t\t}\n\t\tlen = min((u32)m.length, src_len);\n\t\tif (len > rd_size) {\n\t\t\tpr_debug(\"RD[%u]: size underrun page %d offset %d \"\n\t\t\t\t \"size %d\\n\", dev->rd_dev_id,\n\t\t\t\t rd_page, rd_offset, rd_size);\n\t\t\tlen = rd_size;\n\t\t}\n\t\tm.consumed = len;\n\n\t\trd_addr = sg_virt(rd_sg) + rd_offset;\n\n\t\tif (data_direction == DMA_FROM_DEVICE)\n\t\t\tmemcpy(m.addr, rd_addr, len);\n\t\telse\n\t\t\tmemcpy(rd_addr, m.addr, len);\n\n\t\trd_size -= len;\n\t\tif (!rd_size)\n\t\t\tcontinue;\n\n\t\tsrc_len -= len;\n\t\tif (src_len) {\n\t\t\trd_offset += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* rd page completed, next one please */\n\t\trd_page++;\n\t\trd_offset = 0;\n\t\tsrc_len = PAGE_SIZE;\n\t\tif (rd_page <= table->page_end_offset) {\n\t\t\trd_sg++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = rd_get_sg_table(dev, rd_page);\n\t\tif (!table) {\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\n\t\t/* since we increment, the first sg entry is correct */\n\t\trd_sg = table->sg_table;\n\t}\n\tsg_miter_stop(&m);\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nenum {\n\tOpt_rd_pages, Opt_rd_nullio, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_rd_pages, \"rd_pages=%d\"},\n\t{Opt_rd_nullio, \"rd_nullio=%d\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t rd_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0, arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_rd_pages:\n\t\t\tmatch_int(args, &arg);\n\t\t\trd_dev->rd_page_count = arg;\n\t\t\tpr_debug(\"RAMDISK: Referencing Page\"\n\t\t\t\t\" Count: %u\\n\", rd_dev->rd_page_count);\n\t\t\trd_dev->rd_flags |= RDF_HAS_PAGE_COUNT;\n\t\t\tbreak;\n\t\tcase Opt_rd_nullio:\n\t\t\tmatch_int(args, &arg);\n\t\t\tif (arg != 1)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"RAMDISK: Setting NULLIO flag: %d\\n\", arg);\n\t\t\trd_dev->rd_flags |= RDF_NULLIO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(orig);\n\treturn (!ret) ? count : ret;\n}\n\nstatic ssize_t rd_show_configfs_dev_params(struct se_device *dev, char *b)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tssize_t bl = sprintf(b, \"TCM RamDisk ID: %u  RamDisk Makeup: rd_mcp\\n\",\n\t\t\trd_dev->rd_dev_id);\n\tbl += sprintf(b + bl, \"        PAGES/PAGE_SIZE: %u*%lu\"\n\t\t\t\"  SG_table_count: %u  nullio: %d\\n\", rd_dev->rd_page_count,\n\t\t\tPAGE_SIZE, rd_dev->sg_table_count,\n\t\t\t!!(rd_dev->rd_flags & RDF_NULLIO));\n\treturn bl;\n}\n\nstatic sector_t rd_get_blocks(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tunsigned long long blocks_long = ((rd_dev->rd_page_count * PAGE_SIZE) /\n\t\t\tdev->dev_attrib.block_size) - 1;\n\n\treturn blocks_long;\n}\n\nstatic struct sbc_ops rd_sbc_ops = {\n\t.execute_rw\t\t= rd_execute_rw,\n};\n\nstatic sense_reason_t\nrd_parse_cdb(struct se_cmd *cmd)\n{\n\treturn sbc_parse_cdb(cmd, &rd_sbc_ops);\n}\n\nstatic struct se_subsystem_api rd_mcp_template = {\n\t.name\t\t\t= \"rd_mcp\",\n\t.inquiry_prod\t\t= \"RAMDISK-MCP\",\n\t.inquiry_rev\t\t= RD_MCP_VERSION,\n\t.transport_type\t\t= TRANSPORT_PLUGIN_VHBA_VDEV,\n\t.attach_hba\t\t= rd_attach_hba,\n\t.detach_hba\t\t= rd_detach_hba,\n\t.alloc_device\t\t= rd_alloc_device,\n\t.configure_device\t= rd_configure_device,\n\t.free_device\t\t= rd_free_device,\n\t.parse_cdb\t\t= rd_parse_cdb,\n\t.set_configfs_dev_params = rd_set_configfs_dev_params,\n\t.show_configfs_dev_params = rd_show_configfs_dev_params,\n\t.get_device_type\t= sbc_get_device_type,\n\t.get_blocks\t\t= rd_get_blocks,\n};\n\nint __init rd_module_init(void)\n{\n\tint ret;\n\n\tret = transport_subsystem_register(&rd_mcp_template);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid rd_module_exit(void)\n{\n\ttransport_subsystem_release(&rd_mcp_template);\n}\n"], "filenames": ["drivers/target/target_core_rd.c"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [199], "fixing_code_start_loc": [81], "fixing_code_end_loc": [222], "type": "CWE-200", "message": "The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator.", "other": {"cve": {"id": "CVE-2014-4027", "sourceIdentifier": "cve@mitre.org", "published": "2014-06-23T11:21:18.700", "lastModified": "2020-08-21T18:24:46.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator."}, {"lang": "es", "value": "La funci\u00f3n rd_build_device_space en drivers/target/target_core_rd.c en el kernel de Linux anterior a 3.14 no inicializa debidamente cierta estructura de datos, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la memoria ramdisk_mcp mediante el aprovechamiento del acceso a un iniciador SCSI."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14", "matchCriteriaId": "D5673276-6E6D-4AB2-9DA6-7873D78E58CF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3ED68ADD-BBDA-4485-BC76-58F011D72311"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "A3A907A3-2A3A-46D4-8D75-914649877B65"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3DB41B45-D94D-4A58-88B0-B3EC3EC350E2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "E534C201-BCC5-473C-AAA7-AAB97CEB5437"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:*:vmware:*:*", "matchCriteriaId": "2470C6E8-2024-4CF5-9982-CFF50E88EAE9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "B0A477D7-D770-40FA-822E-0686791DCBBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "3B62FEC0-EE22-46E6-B811-8AB0EE4C3E2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.3.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "49BEE6CD-30CA-44B2-8A9E-B8198A44DB34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "532AAF54-64EF-4852-B4F1-D5E660463704"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "A40013D7-C45F-4712-9FBB-12EC55ACA8A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D0EDB8E9-E6FB-406E-B1D3-C620F114804C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.4.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "DD759D15-7861-45DD-9141-4F2855164368"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "3CA2FA6B-3930-432F-8FB5-E73604CEFE42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "EF00C6EB-94E6-47BA-9C73-F7EEF0F5C5F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "62B0A70A-D101-443E-A543-5EC35E23D66F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "524B2D05-508C-47FF-94A0-6CC42060E638"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "9FF30167-0241-4136-82F8-2D2FB545C19A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "FFB9C044-BDFD-44B6-9DEA-F9EC3B793F15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "5F7E38E6-5E18-491B-A4A3-E47EED2F882F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "E90C12AF-44BA-44A2-89ED-0C2497EEC8A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "E48CB17C-616D-4637-9811-93B4291052F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "44F1E5E0-BD63-4A4A-BC4E-A1D5495F8B5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.3.0", "versionEndIncluding": "11.6.0", "matchCriteriaId": "EAA8052D-B8EA-4109-A93B-EDF8F1BF09F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "23FF9627-E561-4CF7-A685-6E33D2F6C98C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_protocol_security_module:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.4.1", "matchCriteriaId": "8C666A18-9DED-4B49-92DE-474403FC17BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_wan_optimization_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "A6B52D60-38DB-4BE9-91F4-B6553F5E5A93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "E1E3204F-9464-4AC3-819B-D1A6B399FAE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_application_delivery_controller:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "222B4DE7-1D3D-40DF-A9EB-EFABDA8FAEA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_cloud:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "8C8BF865-BA45-4711-829F-EC8E5EA22D2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_device:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "3BC0EAFD-DA5E-4A1B-81CB-0D5A964F9EB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_security:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "6B3E56EB-202A-4F58-8E94-B2DDA1693498"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:enterprise_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndIncluding": "3.1.1", "matchCriteriaId": "482E630B-93A1-4B9B-8273-821C116ADC4F"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://permalink.gmane.org/gmane.linux.scsi.target.devel/6618", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/11/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2334-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2335-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1108744", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://support.f5.com/kb/en-us/solutions/public/15000/600/sol15685.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc"}}