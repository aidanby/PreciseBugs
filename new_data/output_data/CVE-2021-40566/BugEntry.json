{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-4 visual p2 xvid decoder filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/filters.h>\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n\n\n/*if we don't have M4V (A)SP parser, we con't get width and height and xvid is then unusable ...*/\n#if !defined(GPAC_DISABLE_AV_PARSERS) && defined(GPAC_HAS_XVID)\n\n#if !defined(__GNUC__)\n# if defined(_WIN32_WCE) || defined (WIN32)\n#  pragma comment(lib, \"libxvidcore\")\n# endif\n#endif\n\n\n#include <xvid.h>\n\n#ifndef XVID_DEC_FRAME\n#define XVID_DEC_FRAME xvid_dec_frame_t\n#define XVID_DEC_PARAM xvid_dec_create_t\n#else\n#define XVID_USE_OLD_API\n#endif\n\n//#undef XVID_USE_OLD_API\n\nstatic Bool xvid_is_init = GF_FALSE;\n\ntypedef struct\n{\n\tBool deblock_y;\n\tBool deblock_uv;\n#ifndef XVID_USE_OLD_API\n\tBool film_effect;\n\tBool dering_y;\n\tBool dering_uv;\n#endif\n\n\tGF_FilterPid *ipid, *opid;\n\tu32 cfg_crc;\n\tvoid *codec;\n\n\tu32 width, height, out_size;\n\tGF_Fraction pixel_ar;\n\tBool first_frame;\n\ts32 base_filters;\n\tFloat FPS;\n\tu32 offset;\n\n\tGF_List *src_packets;\n\tu64 next_cts;\n\n} GF_XVIDCtx;\n\nstatic GF_Err xviddec_initialize(GF_Filter *filter)\n{\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tif (!xvid_is_init) {\n#ifdef XVID_USE_OLD_API\n\t\tXVID_INIT_PARAM init;\n\t\tinit.api_version = 0;\n\t\tinit.core_build = 0;\n\t\t/*get info*/\n\t\tinit.cpu_flags = XVID_CPU_CHKONLY;\n\t\txvid_init(NULL, 0, &init, NULL);\n\t\t/*then init*/\n\t\txvid_init(NULL, 0, &init, NULL);\n#else\n\t\txvid_gbl_init_t init;\n\t\tinit.debug = 0;\n\t\tinit.version = XVID_VERSION;\n\t\tinit.cpu_flags = 0; /*autodetect*/\n\t\txvid_global(NULL, 0, &init, NULL);\n#endif\n\t\txvid_is_init = GF_TRUE;\n\t}\n\n#ifndef XVID_USE_OLD_API\n\tif (ctx->film_effect) ctx->base_filters |= XVID_FILMEFFECT;\n#endif\n\n#ifdef XVID_USE_OLD_API\n\tif (ctx->deblock_y) ctx->base_filters |= XVID_DEC_DEBLOCKY;\n#else\n\tif (ctx->deblock_y) ctx->base_filters |= XVID_DEBLOCKY;\n#endif\n\n#ifdef XVID_USE_OLD_API\n\tif (ctx->deblock_uv) ctx->base_filters |= XVID_DEC_DEBLOCKUV;\n#else\n\tif (ctx->deblock_uv) ctx->base_filters |= XVID_DEBLOCKUV;\n#endif\n\n#ifndef XVID_USE_OLD_API\n\tif (ctx->dering_y) ctx->base_filters |= XVID_DERINGY | XVID_DEBLOCKY;\n\tif (ctx->dering_uv) ctx->base_filters |= XVID_DERINGUV | XVID_DEBLOCKUV;\n#endif\n\tctx->src_packets = gf_list_new();\n\treturn GF_OK;\n}\n\nstatic GF_Err xviddec_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tBool is_first = GF_FALSE;\n#ifdef XVID_USE_OLD_API\n\tXVID_DEC_FRAME frame;\n\tXVID_DEC_PARAM par;\n#else\n\txvid_dec_frame_t frame;\n\txvid_dec_create_t par;\n#endif\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_TRUE);\n\t\tis_first = GF_TRUE;\n\t}\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (p && p->value.data.ptr && p->value.data.size) {\n\t\tu32 ex_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\tif (ctx->cfg_crc == ex_crc) return GF_OK;\n\n\t\t//shoud we flush ?\n\t\tif (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);\n\t\tctx->codec = NULL;\n\n\t\tctx->cfg_crc = ex_crc;\n\t} else if (!is_first) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[XVID] Reconfiguring without DSI not yet supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\n\t/*decode DSI*/\n\te = gf_m4v_get_config(p->value.data.ptr, p->value.data.size, &dsi);\n\tif (e) return e;\n\tif (!dsi.width || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tmemset(&par, 0, sizeof(par));\n\tpar.width = dsi.width;\n\tpar.height = dsi.height;\n\t/*note that this may be irrelevant when used through systems (FPS is driven by systems CTS)*/\n\tctx->FPS = dsi.clock_rate;\n\tctx->FPS /= 1000;\n\tif (!ctx->FPS) ctx->FPS = 30.0f;\n\tctx->pixel_ar.num = dsi.par_num;\n\tctx->pixel_ar.den = dsi.par_den;\n\n#ifndef XVID_USE_OLD_API\n\tpar.version = XVID_VERSION;\n#endif\n\n\tif (xvid_decore(NULL, XVID_DEC_CREATE, &par, NULL) < 0) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tctx->width = par.width;\n\tctx->height = par.height;\n\tctx->codec = par.handle;\n\n\t/*init decoder*/\n\tmemset(&frame, 0, sizeof(frame));\n\tframe.bitstream = (void *) p->value.data.ptr;\n\tframe.length = p->value.data.size;\n#ifndef XVID_USE_OLD_API\n\tframe.version = XVID_VERSION;\n\txvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n#else\n\t/*don't perform error check, XviD doesn't like DSI only frame ...*/\n\txvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n#endif\n\n\tctx->first_frame = GF_TRUE;\n\tctx->out_size = ctx->width * ctx->height * 3 / 2;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STRIDE, &PROP_UINT(ctx->width) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PAR, &PROP_FRAC(ctx->pixel_ar) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_YUV) );\n\n\treturn GF_OK;\n}\n\nstatic void xviddec_finalize(GF_Filter *filter)\n{\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);\n\twhile (gf_list_count(ctx->src_packets)) {\n\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->src_packets);\n\t\tgf_filter_pck_unref(pck);\n\t}\n\tgf_list_del(ctx->src_packets);\n}\n\nstatic GF_Err xviddec_process(GF_Filter *filter)\n{\n#ifdef XVID_USE_OLD_API\n\tXVID_DEC_FRAME frame;\n#else\n\txvid_dec_frame_t frame;\n#endif\n\tu8 *buffer;\n\tu32 i, count;\n\tBool is_seek;\n#if 0\n\ts32 postproc;\n#endif\n\ts32 res;\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *pck_ref, *src_pck, *dst_pck;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\n\tif (!ctx->codec)\n\t\treturn ctx->cfg_crc ? GF_SERVICE_ERROR : GF_OK;\n\n\tmemset(&frame, 0, sizeof(frame));\n\tif (pck) {\n\t\tu64 cts = gf_filter_pck_get_cts(pck);;\n\t\tframe.bitstream = (char *) gf_filter_pck_get_data(pck, &frame.length);\n\n\t\t//append in cts order since we get output frames in cts order\n\t\tpck_ref = pck;\n\t\tgf_filter_pck_ref_props(&pck_ref);\n\t\tcount = gf_list_count(ctx->src_packets);\n\t\tsrc_pck = NULL;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 acts;\n\t\t\tsrc_pck = gf_list_get(ctx->src_packets, i);\n\t\t\tacts = gf_filter_pck_get_cts(src_pck);\n\t\t\tif (acts==cts) {\n\t\t\t\tgf_filter_pck_unref(pck_ref);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acts>cts) {\n\t\t\t\tgf_list_insert(ctx->src_packets, pck_ref, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsrc_pck = NULL;\n\t\t}\n\t\tif (!src_pck)\n\t\t\tgf_list_add(ctx->src_packets, pck_ref);\n\n\n\t} else {\n\t\tframe.bitstream = NULL;\n\t\tframe.length = -1;\n\t}\n\npacked_frame :\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->width*ctx->height*3/2, &buffer);\n\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n#ifdef XVID_USE_OLD_API\n\tframe.colorspace = XVID_CSP_I420;\n\tframe.stride = ctx->width;\n\tframe.image = (void *) buffer;\n#else\n\tframe.version = XVID_VERSION;\n\tframe.output.csp = XVID_CSP_I420;\n\tframe.output.stride[0] = ctx->width;\n\tframe.output.plane[0] = (void *) buffer;\n#endif\n\n\n#if 0\n\tpostproc = ctx->base_filters;\n\t/*to check, not convinced yet by results...*/\n\tswitch (mmlevel) {\n\tcase GF_CODEC_LEVEL_SEEK:\n\tcase GF_CODEC_LEVEL_DROP:\n\t\t/*turn off all post-proc*/\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKY;\n\t\tpostproc &= ~XVID_DEC_DEBLOCKUV;\n#else\n\t\tpostproc &= ~XVID_DEBLOCKY;\n\t\tpostproc &= ~XVID_DEBLOCKUV;\n\t\tpostproc &= ~XVID_FILMEFFECT;\n#endif\n\t\tbreak;\n\tcase GF_CODEC_LEVEL_VERY_LATE:\n\t\t/*turn off post-proc*/\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKY;\n#else\n\t\tpostproc &= ~XVID_FILMEFFECT;\n\t\tpostproc &= ~XVID_DEBLOCKY;\n#endif\n\t\tbreak;\n\tcase GF_CODEC_LEVEL_LATE:\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKUV;\n#else\n\t\tpostproc &= ~XVID_DEBLOCKUV;\n\t\tpostproc &= ~XVID_FILMEFFECT;\n#endif\n\t\tbreak;\n\t}\n#endif\n\n\t/*xvid may keep the first I frame and force a 1-frame delay, so we simply trick it*/\n\tif (ctx->first_frame) {\n\t\tbuffer[0] = 'v';\n\t\tbuffer[1] = 'o';\n\t\tbuffer[2] = 'i';\n\t\tbuffer[3] = 'd';\n\t}\n\tsrc_pck = gf_list_get(ctx->src_packets, 0);\n\n\tres = xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n\tif (res < 0) {\n\t\tgf_filter_pck_discard(dst_pck);\n\t\tif (pck) gf_filter_pid_drop_packet(ctx->ipid);\n\t\tif (src_pck) {\n\t\t\tgf_filter_pck_unref(src_pck);\n\t\t\tgf_list_pop_front(ctx->src_packets);\n\t\t}\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn pck ? GF_NON_COMPLIANT_BITSTREAM : GF_OK;\n\t}\n\n\tif (ctx->first_frame) {\n\t\tctx->first_frame = GF_FALSE;\n\t\tif ((buffer[0] == 'v') && (buffer[1] == 'o') && (buffer[2] == 'i') && (buffer[3] =='d')) {\n\t\t\tgf_filter_pck_discard(dst_pck);\n\t\t\tif (pck) gf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (src_pck) {\n\t\tgf_filter_pck_merge_properties(src_pck, dst_pck);\n\t\tis_seek = gf_filter_pck_get_seek_flag(src_pck);\n\t\tctx->next_cts = gf_filter_pck_get_cts(src_pck);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->next_cts);\n\t\tctx->next_cts += gf_filter_pck_get_duration(src_pck);\n\t\tgf_filter_pck_unref(src_pck);\n\t\tgf_list_pop_front(ctx->src_packets);\n\t} else {\n\t\tis_seek = 0;\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->next_cts);\n\t}\n\n\tif (!pck || !is_seek )\n\t\tgf_filter_pck_send(dst_pck);\n\telse\n\t\tgf_filter_pck_discard(dst_pck);\n\n\tif (res + 6 < frame.length) {\n\t\tframe.bitstream = ((char *)frame.bitstream) + res;\n\t\tframe.length -= res;\n\t\tgoto packed_frame;\n\t}\n\n\tif (pck) {\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\t//flush all frames if eos is detected\n\telse if (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\treturn xviddec_process(filter);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability XVIDCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_XVIDCtx, _n)\n\nstatic const GF_FilterArgs XVIDArgs[] =\n{\n\t{ OFFS(deblock_y), \"enable Y deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(deblock_uv), \"enable UV deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n#ifndef XVID_USE_OLD_API\n\t{ OFFS(film_effect), \"enable film effect\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dering_y), \"enable Y deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dering_uv), \"enable UV deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n#endif\n\t{0}\n};\n\nGF_FilterRegister XVIDRegister = {\n\t.name = \"xviddec\",\n\tGF_FS_SET_DESCRIPTION(\"XVid decoder\")\n\tGF_FS_SET_HELP(\"This filter decodes MPEG-4 part 2 (and DivX) through libxvidcore library.\")\n\t.private_size = sizeof(GF_XVIDCtx),\n\t.args = XVIDArgs,\n\tSETCAPS(XVIDCaps),\n\t.initialize = xviddec_initialize,\n\t.finalize = xviddec_finalize,\n\t.configure_pid = xviddec_configure_pid,\n\t.process = xviddec_process,\n\t//use low priorty, below ffmpeg one, so that hardware decs/other native impl in gpac can take over if needed\n\t//don't use lowest one since we use this for scalable codecs\n\t.priority = 100\n};\n\n#endif\n\nconst GF_FilterRegister *xviddec_register(GF_FilterSession *session)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS) && defined(GPAC_HAS_XVID)\n\treturn &XVIDRegister;\n#else\n\treturn NULL;\n#endif\n}\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-1/2/4(Part2) video reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble start_time;\n} MPGVidIdx;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool vfr, importer;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 cts, dts, prev_dts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tu32 resume_from;\n\tGF_Fraction cur_fps;\n\n\tBool is_mpg12, forced_packed;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tu32 b_frames;\n\tBool is_packed, is_vfr;\n\tGF_List *pck_queue;\n\tu64 last_ref_cts;\n\tBool frame_started;\n\n\tu32 nb_i, nb_p, nb_b, nb_frames, max_b;\n\n\tu32 bytes_in_header;\n\tchar *hdr_store;\n\tu32 hdr_store_size, hdr_store_alloc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool input_is_au_start, input_is_au_end;\n\tBool recompute_cts;\n\n\tGF_FilterPacket *src_pck;\n\n\tMPGVidIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n} GF_MPGVidDmxCtx;\n\n\nGF_Err mpgviddmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool was_mpeg12;\n\tconst GF_PropertyValue *p;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = ctx->cur_fps.num = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\t\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\t}\n\n\twas_mpeg12 = ctx->is_mpg12;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_MPEG1:\n\t\tcase GF_CODECID_MPEG2_422:\n\t\tcase GF_CODECID_MPEG2_SNR:\n\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\tcase GF_CODECID_MPEG2_SIMPLE:\n\t\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\t\tctx->is_mpg12 = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->vparser && (was_mpeg12 != ctx->is_mpg12)) {\n\t\tgf_m4v_parser_del_no_bs(ctx->vparser);\n\t\tctx->vparser = NULL;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mpgviddmx_check_dur(GF_Filter *filter, GF_MPGVidDmxCtx *ctx)\n{\n\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tu64 duration, cur_dur, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen(p->value.string, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tvparser = gf_m4v_parser_bs_new(bs, ctx->is_mpg12);\n\te = gf_m4v_parse_config(vparser, &dsi);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video header - duration  not estimated\\n\"));\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 fsize, start;\n\t\tBool is_coded;\n\t\tu64 pos;\n\t\tpos = gf_m4v_get_object_start(vparser);\n\t\te = gf_m4v_parse_frame(vparser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video frame\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tduration += ctx->cur_fps.den;\n\t\tcur_dur += ctx->cur_fps.den;\n\t\t//only index at I-frame start\n\t\tif (pos && (ftype==0) && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MPGVidIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos;\n\t\t\tctx->indexes[ctx->index_size].start_time = (Double) (duration-ctx->cur_fps.den);\n\t\t\tctx->indexes[ctx->index_size].start_time /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_m4v_parser_del(vparser);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n}\n\n\nstatic void mpgviddmx_enqueue_or_dispatch(GF_MPGVidDmxCtx *ctx, GF_FilterPacket *pck, Bool flush_ref, Bool is_eos)\n{\n\t//TODO: we are dispatching frames in \"negctts mode\", ie we may have DTS>CTS\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue) {\n\t\t//send all reference packet queued\n\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 cts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\tu8 carousel = gf_filter_pck_get_carousel_version(q_pck);\n\t\t\tif (!carousel) {\n\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\t\t//offset the cts of the ref frame to the number of B frames in-between\n\t\t\t\tif (ctx->last_ref_cts == cts) {\n\t\t\t\t\tcts += ctx->b_frames * ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t} else {\n\t\t\t\t\t//shift all other frames (i.e. pending Bs) by 1 frame in the past since we move the ref frame after them\n\t\t\t\t\tassert(cts >= ctx->cur_fps.den);\n\t\t\t\t\tcts -= ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_eos && (i+1==count)) {\n\t\t\t\tBool start, end;\n\t\t\t\tgf_filter_pck_get_framing(q_pck, &start, &end);\n\t\t\t\tgf_filter_pck_set_framing(q_pck, start, GF_TRUE);\n\t\t\t}\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t\tgf_list_reset(ctx->pck_queue);\n\t}\n\tif (!pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, pck);\n}\n\nstatic void mpgviddmx_check_pid(GF_Filter *filter, GF_MPGVidDmxCtx *ctx, u32 vosh_size, u8 *data)\n{\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tmpgviddmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->width == ctx->dsi.width) && (ctx->height == ctx->dsi.height)) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\n\tctx->width = ctx->dsi.width;\n\tctx->height = ctx->dsi.height;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->dsi.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->dsi.height));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC_INT(ctx->dsi.par_num, ctx->dsi.par_den));\n\n\tif (ctx->is_mpg12) {\n\t\tconst GF_PropertyValue *cid = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CODECID);\n\t\tu32 PL = ctx->dsi.VideoPL;\n\t\tif (cid) {\n\t\t\tswitch (cid->value.uint) {\n\t\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\t\tcase GF_CODECID_MPEG2_422:\n\t\t\tcase GF_CODECID_MPEG2_SNR:\n\t\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\t\t\t//keep same signaling\n\t\t\t\tPL = cid->value.uint;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!PL) PL = GF_CODECID_MPEG2_MAIN;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(PL));\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(GF_CODECID_MPEG4_PART2));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->dsi.VideoPL) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tctx->b_frames = 0;\n\n\tif (vosh_size) {\n\t\tu32 i;\n\t\tchar * dcfg = gf_malloc(sizeof(char)*vosh_size);\n\t\tmemcpy(dcfg, data, sizeof(char)*vosh_size);\n\n\t\t/*remove packed flag if any (VOSH user data)*/\n\t\tctx->is_packed = ctx->is_vfr = ctx->forced_packed = GF_FALSE;\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar *frame = dcfg;\n\t\t\twhile ((i+3<vosh_size)  && ((frame[i]!=0) || (frame[i+1]!=0) || (frame[i+2]!=1))) i++;\n\t\t\tif (i+4>=vosh_size) break;\n\t\t\tif (strncmp(frame+i+4, \"DivX\", 4)) {\n\t\t\t\ti += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe = memchr(dcfg + i + 4, 'p', vosh_size - i - 4);\n\t\t\tif (frame) {\n\t\t\t\tctx->forced_packed = GF_TRUE;\n\t\t\t\tframe[0] = 'n';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dcfg, vosh_size));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n}\n\nstatic Bool mpgviddmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t\tctx->bytes_in_header = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range>0.1) ctx->resume_from = 0;\n \t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif ((ctx->indexes[i].start_time > ctx->start_range) || (i+1==ctx->index_size)) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].start_time * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->dts = ctx->cts;\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->bytes_in_header = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tif (ctx->pck_queue) {\n\t\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\t\tGF_FilterPacket *pck=gf_list_pop_front(ctx->pck_queue);\n\t\t\t\tgf_filter_pck_discard(pck);\n\t\t\t}\n\t\t}\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mpgviddmx_update_time(GF_MPGVidDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = 3000;\n\t\tif (ctx->cur_fps.den && ctx->cur_fps.num) {\n\t\t\tinc = ctx->cur_fps.den;\n\t\t\tif (ctx->cur_fps.num != ctx->timescale) {\n\t\t\t\tinc *= ctx->timescale;\n\t\t\t\tinc /= ctx->cur_fps.num;\n\t\t\t}\n\t\t}\n\t\tctx->cts += inc;\n\t\tctx->dts += inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\n\nstatic s32 mpgviddmx_next_start_code(u8 *data, u32 size)\n{\n\tu32 v, bpos, found;\n\ts64 start, end;\n\n\tbpos = 0;\n\tfound = 0;\n\tstart = 0;\n\tend = 0;\n\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\tif (bpos == size)\n\t\t\treturn -1;\n\t\tv = ( (v<<8) & 0xFFFFFF00) | data[bpos];\n\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -1;\n\tassert(end >= start);\n\treturn (s32) (end - start);\n}\n\nGF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mpgviddmx_initialize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->hdr_store_size = 0;\n\tctx->hdr_store_alloc = 8;\n\tctx->hdr_store = gf_malloc(sizeof(char)*8);\n\treturn GF_OK;\n}\n\nstatic void mpgviddmx_finalize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->vparser) gf_m4v_parser_del_no_bs(ctx->vparser);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->hdr_store) gf_free(ctx->hdr_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tif (ctx->importer) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"%s Import results: %d VOPs (%d Is - %d Ps - %d Bs)\\n\", ctx->is_mpg12 ? \"MPEG-1/2\" : \"MPEG-4 (Part 2)\", ctx->nb_frames, ctx->nb_i, ctx->nb_p, ctx->nb_b));\n\t\tif (ctx->nb_b) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"\\t%d max consecutive B-frames%s\\n\", ctx->max_b, ctx->is_packed ? \" - packed bitstream\" : \"\" ));\n\t\t}\n\t\tif (ctx->is_vfr && ctx->nb_b && ctx->is_packed) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"Warning: Mix of non-coded frames: packed bitstream and encoder skiped - unpredictable timing\\n\"));\n\t\t}\n\t}\n}\n\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v);\n\nstatic const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_M4VParser *parser;\n\tu8 ftype;\n\tu32 tinc, nb_frames, o_start=0;\n\tu64 fsize, start;\n\tBool is_coded;\n\tGF_Err e;\n\tGF_M4VDecSpecInfo dsi;\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_FALSE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tu32 otype;\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (!nb_frames && start) o_start = (u32) start;\n\n\t\totype = gf_m4v_parser_get_obj_type(parser);\n\t\tswitch (otype) {\n\t\tcase M4V_VOL_START_CODE:\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_VISOBJ_START_CODE:\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\tcase M4V_UDTA_START_CODE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\totype = 0;\n\t\t}\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\t//except if we have a valid object VOS\n\t\tif (!nb_frames && (start>4) && !otype) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\te = GF_OK;\n\t\t\t//special case if the only frame we have is not coded\n\t\t\tif (otype == M4V_VOP_START_CODE) {\n\t\t\t\tif (!nb_frames) nb_frames++;\n\t\t\t\tis_coded = 1;\n\t\t\t}\n\n\t\t\tif (is_coded) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mp4v-es\";\n\t}\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_TRUE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\tif (!nb_frames && (start>4) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\tif (is_coded) nb_frames++;\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mpgv-es\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MPGVidDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"cmp|m1v|m2v\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/mp4v-es|video/mpgv-es\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MPGVidDmxCtx, _n)\nstatic const GF_FilterArgs MPGVidDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(vfr), \"set variable frame rate import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister MPGVidDmxRegister = {\n\t.name = \"rfmpgvid\",\n\tGF_FS_SET_DESCRIPTION(\"M1V/M2V/M4V reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 and MPEG-4 part 2 video files/data and outputs corresponding video PID and frames.\\n\"\n\t\t\"Note: The demux uses negative CTS offsets: CTS is corrrect, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_MPGVidDmxCtx),\n\t.args = MPGVidDmxArgs,\n\t.initialize = mpgviddmx_initialize,\n\t.finalize = mpgviddmx_finalize,\n\tSETCAPS(MPGVidDmxCaps),\n\t.configure_pid = mpgviddmx_configure_pid,\n\t.process = mpgviddmx_process,\n\t.probe_data = mpgvdmx_probe_data,\n\t.process_event = mpgviddmx_process_event\n};\n\n\nconst GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)\n{\n\treturn &MPGVidDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-4 visual p2 xvid decoder filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/filters.h>\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n\n\n/*if we don't have M4V (A)SP parser, we con't get width and height and xvid is then unusable ...*/\n#if !defined(GPAC_DISABLE_AV_PARSERS) && defined(GPAC_HAS_XVID)\n\n#if !defined(__GNUC__)\n# if defined(_WIN32_WCE) || defined (WIN32)\n#  pragma comment(lib, \"libxvidcore\")\n# endif\n#endif\n\n\n#include <xvid.h>\n\n#ifndef XVID_DEC_FRAME\n#define XVID_DEC_FRAME xvid_dec_frame_t\n#define XVID_DEC_PARAM xvid_dec_create_t\n#else\n#define XVID_USE_OLD_API\n#endif\n\n//#undef XVID_USE_OLD_API\n\nstatic Bool xvid_is_init = GF_FALSE;\n\ntypedef struct\n{\n\tBool deblock_y;\n\tBool deblock_uv;\n#ifndef XVID_USE_OLD_API\n\tBool film_effect;\n\tBool dering_y;\n\tBool dering_uv;\n#endif\n\n\tGF_FilterPid *ipid, *opid;\n\tu32 cfg_crc;\n\tvoid *codec;\n\n\tu32 width, height, out_size;\n\tGF_Fraction pixel_ar;\n\tBool first_frame;\n\ts32 base_filters;\n\tFloat FPS;\n\tu32 offset;\n\n\tGF_List *src_packets;\n\tu64 next_cts;\n\n} GF_XVIDCtx;\n\nstatic GF_Err xviddec_initialize(GF_Filter *filter)\n{\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tif (!xvid_is_init) {\n#ifdef XVID_USE_OLD_API\n\t\tXVID_INIT_PARAM init;\n\t\tinit.api_version = 0;\n\t\tinit.core_build = 0;\n\t\t/*get info*/\n\t\tinit.cpu_flags = XVID_CPU_CHKONLY;\n\t\txvid_init(NULL, 0, &init, NULL);\n\t\t/*then init*/\n\t\txvid_init(NULL, 0, &init, NULL);\n#else\n\t\txvid_gbl_init_t init;\n\t\tinit.debug = 0;\n\t\tinit.version = XVID_VERSION;\n\t\tinit.cpu_flags = 0; /*autodetect*/\n\t\txvid_global(NULL, 0, &init, NULL);\n#endif\n\t\txvid_is_init = GF_TRUE;\n\t}\n\n#ifndef XVID_USE_OLD_API\n\tif (ctx->film_effect) ctx->base_filters |= XVID_FILMEFFECT;\n#endif\n\n#ifdef XVID_USE_OLD_API\n\tif (ctx->deblock_y) ctx->base_filters |= XVID_DEC_DEBLOCKY;\n#else\n\tif (ctx->deblock_y) ctx->base_filters |= XVID_DEBLOCKY;\n#endif\n\n#ifdef XVID_USE_OLD_API\n\tif (ctx->deblock_uv) ctx->base_filters |= XVID_DEC_DEBLOCKUV;\n#else\n\tif (ctx->deblock_uv) ctx->base_filters |= XVID_DEBLOCKUV;\n#endif\n\n#ifndef XVID_USE_OLD_API\n\tif (ctx->dering_y) ctx->base_filters |= XVID_DERINGY | XVID_DEBLOCKY;\n\tif (ctx->dering_uv) ctx->base_filters |= XVID_DERINGUV | XVID_DEBLOCKUV;\n#endif\n\tctx->src_packets = gf_list_new();\n\treturn GF_OK;\n}\n\nstatic GF_Err xviddec_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tBool is_first = GF_FALSE;\n#ifdef XVID_USE_OLD_API\n\tXVID_DEC_FRAME frame;\n\tXVID_DEC_PARAM par;\n#else\n\txvid_dec_frame_t frame;\n\txvid_dec_create_t par;\n#endif\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_TRUE);\n\t\tis_first = GF_TRUE;\n\t}\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (p && p->value.data.ptr && p->value.data.size) {\n\t\tu32 ex_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\tif (ctx->cfg_crc == ex_crc) return GF_OK;\n\n\t\t//shoud we flush ?\n\t\tif (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);\n\t\tctx->codec = NULL;\n\n\t\tctx->cfg_crc = ex_crc;\n\t} else if (!is_first) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[XVID] Reconfiguring without DSI not yet supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\n\t/*decode DSI*/\n\te = gf_m4v_get_config(p->value.data.ptr, p->value.data.size, &dsi);\n\tif (e) return e;\n\tif (!dsi.width || (dsi.width%2) || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tmemset(&par, 0, sizeof(par));\n\tpar.width = dsi.width;\n\tpar.height = dsi.height;\n\t/*note that this may be irrelevant when used through systems (FPS is driven by systems CTS)*/\n\tctx->FPS = dsi.clock_rate;\n\tctx->FPS /= 1000;\n\tif (!ctx->FPS) ctx->FPS = 30.0f;\n\tctx->pixel_ar.num = dsi.par_num;\n\tctx->pixel_ar.den = dsi.par_den;\n\n#ifndef XVID_USE_OLD_API\n\tpar.version = XVID_VERSION;\n#endif\n\n\tif (xvid_decore(NULL, XVID_DEC_CREATE, &par, NULL) < 0) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tctx->width = par.width;\n\tctx->height = par.height;\n\tctx->codec = par.handle;\n\n\t/*init decoder*/\n\tmemset(&frame, 0, sizeof(frame));\n\tframe.bitstream = (void *) p->value.data.ptr;\n\tframe.length = p->value.data.size;\n#ifndef XVID_USE_OLD_API\n\tframe.version = XVID_VERSION;\n\txvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n#else\n\t/*don't perform error check, XviD doesn't like DSI only frame ...*/\n\txvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n#endif\n\n\tctx->first_frame = GF_TRUE;\n\tctx->out_size = ctx->width * ctx->height * 3 / 2;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STRIDE, &PROP_UINT(ctx->width) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PAR, &PROP_FRAC(ctx->pixel_ar) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_YUV) );\n\n\treturn GF_OK;\n}\n\nstatic void xviddec_finalize(GF_Filter *filter)\n{\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);\n\twhile (gf_list_count(ctx->src_packets)) {\n\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->src_packets);\n\t\tgf_filter_pck_unref(pck);\n\t}\n\tgf_list_del(ctx->src_packets);\n}\n\nstatic GF_Err xviddec_process(GF_Filter *filter)\n{\n#ifdef XVID_USE_OLD_API\n\tXVID_DEC_FRAME frame;\n#else\n\txvid_dec_frame_t frame;\n#endif\n\tu8 *buffer;\n\tu32 i, count;\n\tBool is_seek;\n#if 0\n\ts32 postproc;\n#endif\n\ts32 res;\n\tGF_XVIDCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *pck_ref, *src_pck, *dst_pck;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\n\tif (!ctx->codec)\n\t\treturn ctx->cfg_crc ? GF_SERVICE_ERROR : GF_OK;\n\n\tmemset(&frame, 0, sizeof(frame));\n\tif (pck) {\n\t\tu64 cts = gf_filter_pck_get_cts(pck);;\n\t\tframe.bitstream = (char *) gf_filter_pck_get_data(pck, &frame.length);\n\n\t\t//append in cts order since we get output frames in cts order\n\t\tpck_ref = pck;\n\t\tgf_filter_pck_ref_props(&pck_ref);\n\t\tcount = gf_list_count(ctx->src_packets);\n\t\tsrc_pck = NULL;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 acts;\n\t\t\tsrc_pck = gf_list_get(ctx->src_packets, i);\n\t\t\tacts = gf_filter_pck_get_cts(src_pck);\n\t\t\tif (acts==cts) {\n\t\t\t\tgf_filter_pck_unref(pck_ref);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acts>cts) {\n\t\t\t\tgf_list_insert(ctx->src_packets, pck_ref, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsrc_pck = NULL;\n\t\t}\n\t\tif (!src_pck)\n\t\t\tgf_list_add(ctx->src_packets, pck_ref);\n\n\n\t} else {\n\t\tframe.bitstream = NULL;\n\t\tframe.length = -1;\n\t}\n\npacked_frame :\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->width*ctx->height*3/2, &buffer);\n\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n#ifdef XVID_USE_OLD_API\n\tframe.colorspace = XVID_CSP_I420;\n\tframe.stride = ctx->width;\n\tframe.image = (void *) buffer;\n#else\n\tframe.version = XVID_VERSION;\n\tframe.output.csp = XVID_CSP_I420;\n\tframe.output.stride[0] = ctx->width;\n\tframe.output.plane[0] = (void *) buffer;\n#endif\n\n\n#if 0\n\tpostproc = ctx->base_filters;\n\t/*to check, not convinced yet by results...*/\n\tswitch (mmlevel) {\n\tcase GF_CODEC_LEVEL_SEEK:\n\tcase GF_CODEC_LEVEL_DROP:\n\t\t/*turn off all post-proc*/\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKY;\n\t\tpostproc &= ~XVID_DEC_DEBLOCKUV;\n#else\n\t\tpostproc &= ~XVID_DEBLOCKY;\n\t\tpostproc &= ~XVID_DEBLOCKUV;\n\t\tpostproc &= ~XVID_FILMEFFECT;\n#endif\n\t\tbreak;\n\tcase GF_CODEC_LEVEL_VERY_LATE:\n\t\t/*turn off post-proc*/\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKY;\n#else\n\t\tpostproc &= ~XVID_FILMEFFECT;\n\t\tpostproc &= ~XVID_DEBLOCKY;\n#endif\n\t\tbreak;\n\tcase GF_CODEC_LEVEL_LATE:\n#ifdef XVID_USE_OLD_API\n\t\tpostproc &= ~XVID_DEC_DEBLOCKUV;\n#else\n\t\tpostproc &= ~XVID_DEBLOCKUV;\n\t\tpostproc &= ~XVID_FILMEFFECT;\n#endif\n\t\tbreak;\n\t}\n#endif\n\n\t/*xvid may keep the first I frame and force a 1-frame delay, so we simply trick it*/\n\tif (ctx->first_frame) {\n\t\tbuffer[0] = 'v';\n\t\tbuffer[1] = 'o';\n\t\tbuffer[2] = 'i';\n\t\tbuffer[3] = 'd';\n\t}\n\tsrc_pck = gf_list_get(ctx->src_packets, 0);\n\n\tres = xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);\n\tif (res < 0) {\n\t\tgf_filter_pck_discard(dst_pck);\n\t\tif (pck) gf_filter_pid_drop_packet(ctx->ipid);\n\t\tif (src_pck) {\n\t\t\tgf_filter_pck_unref(src_pck);\n\t\t\tgf_list_pop_front(ctx->src_packets);\n\t\t}\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn pck ? GF_NON_COMPLIANT_BITSTREAM : GF_OK;\n\t}\n\n\tif (ctx->first_frame) {\n\t\tctx->first_frame = GF_FALSE;\n\t\tif ((buffer[0] == 'v') && (buffer[1] == 'o') && (buffer[2] == 'i') && (buffer[3] =='d')) {\n\t\t\tgf_filter_pck_discard(dst_pck);\n\t\t\tif (pck) gf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (src_pck) {\n\t\tgf_filter_pck_merge_properties(src_pck, dst_pck);\n\t\tis_seek = gf_filter_pck_get_seek_flag(src_pck);\n\t\tctx->next_cts = gf_filter_pck_get_cts(src_pck);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->next_cts);\n\t\tctx->next_cts += gf_filter_pck_get_duration(src_pck);\n\t\tgf_filter_pck_unref(src_pck);\n\t\tgf_list_pop_front(ctx->src_packets);\n\t} else {\n\t\tis_seek = 0;\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->next_cts);\n\t}\n\n\tif (!pck || !is_seek )\n\t\tgf_filter_pck_send(dst_pck);\n\telse\n\t\tgf_filter_pck_discard(dst_pck);\n\n\tif (res + 6 < frame.length) {\n\t\tframe.bitstream = ((char *)frame.bitstream) + res;\n\t\tframe.length -= res;\n\t\tgoto packed_frame;\n\t}\n\n\tif (pck) {\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\t//flush all frames if eos is detected\n\telse if (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\treturn xviddec_process(filter);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability XVIDCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_XVIDCtx, _n)\n\nstatic const GF_FilterArgs XVIDArgs[] =\n{\n\t{ OFFS(deblock_y), \"enable Y deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(deblock_uv), \"enable UV deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n#ifndef XVID_USE_OLD_API\n\t{ OFFS(film_effect), \"enable film effect\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dering_y), \"enable Y deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dering_uv), \"enable UV deblocking\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n#endif\n\t{0}\n};\n\nGF_FilterRegister XVIDRegister = {\n\t.name = \"xviddec\",\n\tGF_FS_SET_DESCRIPTION(\"XVid decoder\")\n\tGF_FS_SET_HELP(\"This filter decodes MPEG-4 part 2 (and DivX) through libxvidcore library.\")\n\t.private_size = sizeof(GF_XVIDCtx),\n\t.args = XVIDArgs,\n\tSETCAPS(XVIDCaps),\n\t.initialize = xviddec_initialize,\n\t.finalize = xviddec_finalize,\n\t.configure_pid = xviddec_configure_pid,\n\t.process = xviddec_process,\n\t//use low priorty, below ffmpeg one, so that hardware decs/other native impl in gpac can take over if needed\n\t//don't use lowest one since we use this for scalable codecs\n\t.priority = 100\n};\n\n#endif\n\nconst GF_FilterRegister *xviddec_register(GF_FilterSession *session)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS) && defined(GPAC_HAS_XVID)\n\treturn &XVIDRegister;\n#else\n\treturn NULL;\n#endif\n}\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-1/2/4(Part2) video reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble start_time;\n} MPGVidIdx;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool vfr, importer;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 cts, dts, prev_dts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tu32 resume_from;\n\tGF_Fraction cur_fps;\n\n\tBool is_mpg12, forced_packed;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tu32 b_frames;\n\tBool is_packed, is_vfr;\n\tGF_List *pck_queue;\n\tu64 last_ref_cts;\n\tBool frame_started;\n\n\tu32 nb_i, nb_p, nb_b, nb_frames, max_b;\n\n\tu32 bytes_in_header;\n\tchar *hdr_store;\n\tu32 hdr_store_size, hdr_store_alloc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool input_is_au_start, input_is_au_end;\n\tBool recompute_cts;\n\n\tGF_FilterPacket *src_pck;\n\n\tMPGVidIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n} GF_MPGVidDmxCtx;\n\n\nGF_Err mpgviddmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool was_mpeg12;\n\tconst GF_PropertyValue *p;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = ctx->cur_fps.num = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\t\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\t}\n\n\twas_mpeg12 = ctx->is_mpg12;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_MPEG1:\n\t\tcase GF_CODECID_MPEG2_422:\n\t\tcase GF_CODECID_MPEG2_SNR:\n\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\tcase GF_CODECID_MPEG2_SIMPLE:\n\t\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\t\tctx->is_mpg12 = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->vparser && (was_mpeg12 != ctx->is_mpg12)) {\n\t\tgf_m4v_parser_del_no_bs(ctx->vparser);\n\t\tctx->vparser = NULL;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mpgviddmx_check_dur(GF_Filter *filter, GF_MPGVidDmxCtx *ctx)\n{\n\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tu64 duration, cur_dur, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen(p->value.string, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tvparser = gf_m4v_parser_bs_new(bs, ctx->is_mpg12);\n\te = gf_m4v_parse_config(vparser, &dsi);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video header - duration  not estimated\\n\"));\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 fsize, start;\n\t\tBool is_coded;\n\t\tu64 pos;\n\t\tpos = gf_m4v_get_object_start(vparser);\n\t\te = gf_m4v_parse_frame(vparser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video frame\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tduration += ctx->cur_fps.den;\n\t\tcur_dur += ctx->cur_fps.den;\n\t\t//only index at I-frame start\n\t\tif (pos && (ftype==0) && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MPGVidIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos;\n\t\t\tctx->indexes[ctx->index_size].start_time = (Double) (duration-ctx->cur_fps.den);\n\t\t\tctx->indexes[ctx->index_size].start_time /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_m4v_parser_del(vparser);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n}\n\n\nstatic void mpgviddmx_enqueue_or_dispatch(GF_MPGVidDmxCtx *ctx, GF_FilterPacket *pck, Bool flush_ref, Bool is_eos)\n{\n\t//TODO: we are dispatching frames in \"negctts mode\", ie we may have DTS>CTS\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue) {\n\t\t//send all reference packet queued\n\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 cts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\tu8 carousel = gf_filter_pck_get_carousel_version(q_pck);\n\t\t\tif (!carousel) {\n\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\t\t//offset the cts of the ref frame to the number of B frames in-between\n\t\t\t\tif (ctx->last_ref_cts == cts) {\n\t\t\t\t\tcts += ctx->b_frames * ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t} else {\n\t\t\t\t\t//shift all other frames (i.e. pending Bs) by 1 frame in the past since we move the ref frame after them\n\t\t\t\t\tassert(cts >= ctx->cur_fps.den);\n\t\t\t\t\tcts -= ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_eos && (i+1==count)) {\n\t\t\t\tBool start, end;\n\t\t\t\tgf_filter_pck_get_framing(q_pck, &start, &end);\n\t\t\t\tgf_filter_pck_set_framing(q_pck, start, GF_TRUE);\n\t\t\t}\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t\tgf_list_reset(ctx->pck_queue);\n\t}\n\tif (!pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, pck);\n}\n\nstatic void mpgviddmx_check_pid(GF_Filter *filter, GF_MPGVidDmxCtx *ctx, u32 vosh_size, u8 *data)\n{\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tmpgviddmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->width == ctx->dsi.width) && (ctx->height == ctx->dsi.height)) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\n\tctx->width = ctx->dsi.width;\n\tctx->height = ctx->dsi.height;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->dsi.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->dsi.height));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC_INT(ctx->dsi.par_num, ctx->dsi.par_den));\n\n\tif (ctx->is_mpg12) {\n\t\tconst GF_PropertyValue *cid = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CODECID);\n\t\tu32 PL = ctx->dsi.VideoPL;\n\t\tif (cid) {\n\t\t\tswitch (cid->value.uint) {\n\t\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\t\tcase GF_CODECID_MPEG2_422:\n\t\t\tcase GF_CODECID_MPEG2_SNR:\n\t\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\t\t\t//keep same signaling\n\t\t\t\tPL = cid->value.uint;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!PL) PL = GF_CODECID_MPEG2_MAIN;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(PL));\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(GF_CODECID_MPEG4_PART2));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->dsi.VideoPL) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tctx->b_frames = 0;\n\n\tif (vosh_size) {\n\t\tu32 i;\n\t\tchar * dcfg = gf_malloc(sizeof(char)*vosh_size);\n\t\tmemcpy(dcfg, data, sizeof(char)*vosh_size);\n\n\t\t/*remove packed flag if any (VOSH user data)*/\n\t\tctx->is_packed = ctx->is_vfr = ctx->forced_packed = GF_FALSE;\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar *frame = dcfg;\n\t\t\twhile ((i+3<vosh_size)  && ((frame[i]!=0) || (frame[i+1]!=0) || (frame[i+2]!=1))) i++;\n\t\t\tif (i+4>=vosh_size) break;\n\t\t\tif (strncmp(frame+i+4, \"DivX\", 4)) {\n\t\t\t\ti += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe = memchr(dcfg + i + 4, 'p', vosh_size - i - 4);\n\t\t\tif (frame) {\n\t\t\t\tctx->forced_packed = GF_TRUE;\n\t\t\t\tframe[0] = 'n';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dcfg, vosh_size));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n}\n\nstatic Bool mpgviddmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t\tctx->bytes_in_header = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range>0.1) ctx->resume_from = 0;\n \t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif ((ctx->indexes[i].start_time > ctx->start_range) || (i+1==ctx->index_size)) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].start_time * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->dts = ctx->cts;\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->bytes_in_header = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tif (ctx->pck_queue) {\n\t\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\t\tGF_FilterPacket *pck=gf_list_pop_front(ctx->pck_queue);\n\t\t\t\tgf_filter_pck_discard(pck);\n\t\t\t}\n\t\t}\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mpgviddmx_update_time(GF_MPGVidDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = 3000;\n\t\tif (ctx->cur_fps.den && ctx->cur_fps.num) {\n\t\t\tinc = ctx->cur_fps.den;\n\t\t\tif (ctx->cur_fps.num != ctx->timescale) {\n\t\t\t\tinc *= ctx->timescale;\n\t\t\t\tinc /= ctx->cur_fps.num;\n\t\t\t}\n\t\t}\n\t\tctx->cts += inc;\n\t\tctx->dts += inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\n\nstatic s32 mpgviddmx_next_start_code(u8 *data, u32 size)\n{\n\tu32 v, bpos, found;\n\ts64 start, end;\n\n\tbpos = 0;\n\tfound = 0;\n\tstart = 0;\n\tend = 0;\n\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\tif (bpos == size)\n\t\t\treturn -1;\n\t\tv = ( (v<<8) & 0xFFFFFF00) | data[bpos];\n\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -1;\n\tassert(end >= start);\n\treturn (s32) (end - start);\n}\n\nGF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mpgviddmx_initialize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->hdr_store_size = 0;\n\tctx->hdr_store_alloc = 8;\n\tctx->hdr_store = gf_malloc(sizeof(char)*8);\n\treturn GF_OK;\n}\n\nstatic void mpgviddmx_finalize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->vparser) gf_m4v_parser_del_no_bs(ctx->vparser);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->hdr_store) gf_free(ctx->hdr_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tif (ctx->importer) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"%s Import results: %d VOPs (%d Is - %d Ps - %d Bs)\\n\", ctx->is_mpg12 ? \"MPEG-1/2\" : \"MPEG-4 (Part 2)\", ctx->nb_frames, ctx->nb_i, ctx->nb_p, ctx->nb_b));\n\t\tif (ctx->nb_b) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"\\t%d max consecutive B-frames%s\\n\", ctx->max_b, ctx->is_packed ? \" - packed bitstream\" : \"\" ));\n\t\t}\n\t\tif (ctx->is_vfr && ctx->nb_b && ctx->is_packed) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, (\"Warning: Mix of non-coded frames: packed bitstream and encoder skiped - unpredictable timing\\n\"));\n\t\t}\n\t}\n}\n\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v);\n\nstatic const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_M4VParser *parser;\n\tu8 ftype;\n\tu32 tinc, nb_frames, o_start=0;\n\tu64 fsize, start;\n\tBool is_coded;\n\tGF_Err e;\n\tGF_M4VDecSpecInfo dsi;\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_FALSE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tu32 otype;\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (!nb_frames && start) o_start = (u32) start;\n\n\t\totype = gf_m4v_parser_get_obj_type(parser);\n\t\tswitch (otype) {\n\t\tcase M4V_VOL_START_CODE:\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_VISOBJ_START_CODE:\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\tcase M4V_UDTA_START_CODE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\totype = 0;\n\t\t}\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\t//except if we have a valid object VOS\n\t\tif (!nb_frames && (start>4) && !otype) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\te = GF_OK;\n\t\t\t//special case if the only frame we have is not coded\n\t\t\tif (otype == M4V_VOP_START_CODE) {\n\t\t\t\tif (!nb_frames) nb_frames++;\n\t\t\t\tis_coded = 1;\n\t\t\t}\n\n\t\t\tif (is_coded) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mp4v-es\";\n\t}\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_TRUE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\tif (!nb_frames && (start>4) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\tif (is_coded) nb_frames++;\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mpgv-es\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MPGVidDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"cmp|m1v|m2v\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/mp4v-es|video/mpgv-es\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MPGVidDmxCtx, _n)\nstatic const GF_FilterArgs MPGVidDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(vfr), \"set variable frame rate import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister MPGVidDmxRegister = {\n\t.name = \"rfmpgvid\",\n\tGF_FS_SET_DESCRIPTION(\"M1V/M2V/M4V reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 and MPEG-4 part 2 video files/data and outputs corresponding video PID and frames.\\n\"\n\t\t\"Note: The demux uses negative CTS offsets: CTS is corrrect, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_MPGVidDmxCtx),\n\t.args = MPGVidDmxArgs,\n\t.initialize = mpgviddmx_initialize,\n\t.finalize = mpgviddmx_finalize,\n\tSETCAPS(MPGVidDmxCaps),\n\t.configure_pid = mpgviddmx_configure_pid,\n\t.process = mpgviddmx_process,\n\t.probe_data = mpgvdmx_probe_data,\n\t.process_event = mpgviddmx_process_event\n};\n\n\nconst GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)\n{\n\treturn &MPGVidDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n\n\n"], "filenames": ["src/filters/dec_xvid.c", "src/filters/reframe_mpgvid.c"], "buggy_code_start_loc": [184, 808], "buggy_code_end_loc": [185, 853], "fixing_code_start_loc": [184, 808], "fixing_code_end_loc": [185, 862], "type": "CWE-416", "message": "A Segmentation fault casued by heap use after free vulnerability exists in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when using mp4box, which causes a denial of service.", "other": {"cve": {"id": "CVE-2021-40566", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-12T22:15:07.933", "lastModified": "2023-05-27T04:15:16.510", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A Segmentation fault casued by heap use after free vulnerability exists in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when using mp4box, which causes a denial of service."}, {"lang": "es", "value": "Se presenta un fallo de segmentaci\u00f3n causado por una vulnerabilidad de uso de memoria previamente liberada de la pila en Gpac versiones hasta 1.0.1, por medio de la funci\u00f3n mpgviddmx_process en el archivo reframe_mpgvid.c cuando es usado mp4box, que causa una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.1", "matchCriteriaId": "72EEF01B-F945-4AEF-B5C2-6F84A51311C9"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/96047e0e6166407c40cc19f4e94fb35cd7624391", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1887", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/96047e0e6166407c40cc19f4e94fb35cd7624391"}}