{"buggy_code": ["/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n// cl_main.c  -- client main loop\n\n#include \"../server/exe_headers.h\"\n\n#include \"client.h\"\n#include \"client_ui.h\"\n#include <limits.h>\n#include \"../ghoul2/G2.h\"\n#include \"qcommon/stringed_ingame.h\"\n#include \"sys/sys_loadlib.h\"\n#include \"qcommon/ojk_saved_game.h\"\n\n#define\tRETRANSMIT_TIMEOUT\t3000\t// time between connection packet retransmits\n\ncvar_t\t*cl_renderer;\n\ncvar_t\t*cl_nodelta;\ncvar_t\t*cl_debugMove;\n\ncvar_t\t*cl_noprint;\n\ncvar_t\t*cl_timeout;\ncvar_t\t*cl_packetdup;\ncvar_t\t*cl_timeNudge;\ncvar_t\t*cl_showTimeDelta;\ncvar_t\t*cl_newClock=0;\n\ncvar_t\t*cl_shownet;\ncvar_t\t*cl_avidemo;\n\ncvar_t\t*cl_pano;\ncvar_t\t*cl_panoNumShots;\ncvar_t\t*cl_skippingcin;\ncvar_t\t*cl_endcredits;\n\ncvar_t\t*cl_freelook;\ncvar_t\t*cl_sensitivity;\n\ncvar_t\t*cl_mouseAccel;\ncvar_t\t*cl_showMouseRate;\ncvar_t\t*cl_framerate;\n\ncvar_t\t*m_pitch;\ncvar_t\t*m_yaw;\ncvar_t\t*m_forward;\ncvar_t\t*m_side;\ncvar_t\t*m_filter;\n\ncvar_t\t*cl_activeAction;\n\ncvar_t\t*cl_allowAltEnter;\n\ncvar_t\t*cl_inGameVideo;\n\ncvar_t\t*cl_consoleKeys;\ncvar_t\t*cl_consoleUseScanCode;\n\nclientActive_t\t\tcl;\nclientConnection_t\tclc;\nclientStatic_t\t\tcls;\n\n// Structure containing functions exported from refresh DLL\nrefexport_t\tre;\nstatic void *rendererLib = NULL;\n\n//RAZFIXME: BAD BAD, maybe? had to move it out of ghoul2_shared.h -> CGhoul2Info_v at the least..\nIGhoul2InfoArray &_TheGhoul2InfoArray( void ) {\n\treturn re.TheGhoul2InfoArray();\n}\n\nstatic void CL_ShutdownRef( qboolean restarting );\nvoid CL_InitRef( void );\nvoid CL_CheckForResend( void );\n\n/*\n=======================================================================\n\nCLIENT RELIABLE COMMAND COMMUNICATION\n\n=======================================================================\n*/\n\n/*\n======================\nCL_AddReliableCommand\n\nThe given command will be transmitted to the server, and is gauranteed to\nnot have future usercmd_t executed before it is executed\n======================\n*/\nvoid CL_AddReliableCommand( const char *cmd ) {\n\tint\t\tindex;\n\n\t// if we would be losing an old command that hasn't been acknowledged,\n\t// we must drop the connection\n\tif ( clc.reliableSequence - clc.reliableAcknowledge > MAX_RELIABLE_COMMANDS ) {\n\t\tCom_Error( ERR_DROP, \"Client command overflow\" );\n\t}\n\tclc.reliableSequence++;\n\tindex = clc.reliableSequence & ( MAX_RELIABLE_COMMANDS - 1 );\n\tif ( clc.reliableCommands[ index ] ) {\n\t\tZ_Free( clc.reliableCommands[ index ] );\n\t}\n\tclc.reliableCommands[ index ] = CopyString( cmd );\n}\n\n//======================================================================\n\n/*\n=================\nCL_FlushMemory\n\nCalled by CL_MapLoading, CL_Connect_f, and CL_ParseGamestate the only\nways a client gets into a game\nAlso called by Com_Error\n=================\n*/\nvoid CL_FlushMemory( void ) {\n\n\t// clear sounds (moved higher up within this func to avoid the odd sound stutter)\n\tS_DisableSounds();\n\n\t// unload the old VM\n\tCL_ShutdownCGame();\n\n\tCL_ShutdownUI();\n\n\tif ( re.Shutdown ) {\n\t\tre.Shutdown( qfalse, qfalse );\t\t// don't destroy window or context\n\t}\n\n\t//rwwFIXMEFIXME: The game server appears to continue running, so clearing common bsp data causes crashing and other bad things\n\t/*\n\tCM_ClearMap();\n\t*/\n\n\tcls.soundRegistered = qfalse;\n\tcls.rendererStarted = qfalse;\n}\n\n/*\n=====================\nCL_MapLoading\n\nA local server is starting to load a map, so update the\nscreen to let the user know about it, then dump all client\nmemory on the hunk from cgame, ui, and renderer\n=====================\n*/\nvoid CL_MapLoading( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tCon_Close();\n\tKey_SetCatcher( 0 );\n\n\t// if we are already connected to the local host, stay connected\n\tif ( cls.state >= CA_CONNECTED && !Q_stricmp( cls.servername, \"localhost\" ) )  {\n\t\tcls.state = CA_CONNECTED;\t\t// so the connect screen is drawn\n\t\tmemset( cls.updateInfoString, 0, sizeof( cls.updateInfoString ) );\n//\t\tmemset( clc.serverMessage, 0, sizeof( clc.serverMessage ) );\n\t\tmemset( &cl.gameState, 0, sizeof( cl.gameState ) );\n\t\tclc.lastPacketSentTime = -9999;\n\t\tSCR_UpdateScreen();\n\t} else {\n\t\t// clear nextmap so the cinematic shutdown doesn't execute it\n\t\tCvar_Set( \"nextmap\", \"\" );\n\t\tCL_Disconnect();\n\t\tQ_strncpyz( cls.servername, \"localhost\", sizeof(cls.servername) );\n\t\tcls.state = CA_CHALLENGING;\t\t// so the connect screen is drawn\n\t\tKey_SetCatcher( 0 );\n\t\tSCR_UpdateScreen();\n\t\tclc.connectTime = -RETRANSMIT_TIMEOUT;\n\t\tNET_StringToAdr( cls.servername, &clc.serverAddress);\n\t\t// we don't need a challenge on the localhost\n\n\t\tCL_CheckForResend();\n\t}\n\n\tCL_FlushMemory();\n}\n\n/*\n=====================\nCL_ClearState\n\nCalled before parsing a gamestate\n=====================\n*/\nvoid CL_ClearState (void) {\n\tCL_ShutdownCGame();\n\n\tS_StopAllSounds();\n\n\tmemset( &cl, 0, sizeof( cl ) );\n}\n\n/*\n=====================\nCL_FreeReliableCommands\n\nWipes all reliableCommands strings from clc\n=====================\n*/\nvoid CL_FreeReliableCommands( void )\n{\n\t// wipe the client connection\n\tfor ( int i = 0 ; i < MAX_RELIABLE_COMMANDS ; i++ ) {\n\t\tif ( clc.reliableCommands[i] ) {\n\t\t\tZ_Free( clc.reliableCommands[i] );\n\t\t \tclc.reliableCommands[i] = NULL;\n\t\t}\n\t}\n}\n\n\n/*\n=====================\nCL_Disconnect\n\nCalled when a connection, or cinematic is being terminated.\nGoes from a connected state to either a menu state or a console state\nSends a disconnect message to the server\nThis is also called on Com_Error and Com_Quit, so it shouldn't cause any errors\n=====================\n*/\nvoid CL_Disconnect( void ) {\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif (cls.uiStarted)\n\t\tUI_SetActiveMenu( NULL,NULL );\n\n\tSCR_StopCinematic ();\n\tS_ClearSoundBuffer();\n\n\t// send a disconnect message to the server\n\t// send it a few times in case one is dropped\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\tCL_AddReliableCommand( \"disconnect\" );\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t}\n\n\tCL_ClearState ();\n\n\tCL_FreeReliableCommands();\n\n\textern void CL_FreeServerCommands(void);\n\tCL_FreeServerCommands();\n\n\tmemset( &clc, 0, sizeof( clc ) );\n\n\tcls.state = CA_DISCONNECTED;\n\n\t// allow cheats locally\n\tCvar_Set( \"timescale\", \"1\" );//jic we were skipping\n\tCvar_Set( \"skippingCinematic\", \"0\" );//jic we were skipping\n}\n\n\n/*\n===================\nCL_ForwardCommandToServer\n\nadds the current command line as a clientCommand\nthings like godmode, noclip, etc, are commands directed to the server,\nso when they are typed in at the console, they will need to be forwarded.\n===================\n*/\nvoid CL_ForwardCommandToServer( void ) {\n\tconst char\t*cmd;\n\tchar\tstring[MAX_STRING_CHARS];\n\n\tcmd = Cmd_Argv(0);\n\n\t// ignore key up commands\n\tif ( cmd[0] == '-' ) {\n\t\treturn;\n\t}\n\n\tif ( cls.state != CA_ACTIVE || cmd[0] == '+' ) {\n\t\tCom_Printf (\"Unknown command \\\"%s\\\"\\n\", cmd);\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCom_sprintf( string, sizeof(string), \"%s %s\", cmd, Cmd_Args() );\n\t} else {\n\t\tQ_strncpyz( string, cmd, sizeof(string) );\n\t}\n\n\tCL_AddReliableCommand( string );\n}\n\n\n/*\n======================================================================\n\nCONSOLE COMMANDS\n\n======================================================================\n*/\n\n/*\n==================\nCL_ForwardToServer_f\n==================\n*/\nvoid CL_ForwardToServer_f( void ) {\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\t// don't forward the first argument\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( Cmd_Args() );\n\t}\n}\n\n/*\n==================\nCL_Disconnect_f\n==================\n*/\nvoid CL_Disconnect_f( void ) {\n\tSCR_StopCinematic();\n\n\t//FIXME:\n\t// TA codebase added additional CA_CINEMATIC check below, presumably so they could play cinematics\n\t//\tin the menus when disconnected, although having the SCR_StopCinematic() call above is weird.\n\t// Either there's a bug, or the new version of that function conditionally-doesn't stop cinematics...\n\t//\n\tif ( cls.state != CA_DISCONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tCom_Error (ERR_DISCONNECT, \"Disconnected from server\");\n\t}\n}\n\n\n/*\n=================\nCL_Vid_Restart_f\n\nRestart the video subsystem\n=================\n*/\nvoid CL_Vid_Restart_f( void ) {\n\tS_StopAllSounds();\t\t// don't let them loop during the restart\n\tS_BeginRegistration();\t// all sound handles are now invalid\n\tCL_ShutdownRef(qtrue);\n\tCL_ShutdownUI();\n\tCL_ShutdownCGame();\n\n\t//rww - sof2mp does this here, but it seems to cause problems in this codebase.\n//\tCM_ClearMap();\n\n\tCL_InitRef();\n\n\tcls.rendererStarted = qfalse;\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n/*\n=================\nCL_Snd_Restart_f\n\nRestart the sound subsystem\nThe cgame and game must also be forced to restart because\nhandles will be invalid\n=================\n*/\nvoid CL_Snd_Restart_f( void ) {\n\tS_Shutdown();\n\n\tS_Init();\n\n//\tCL_Vid_Restart_f();\n\n\textern qboolean\ts_soundMuted;\n\ts_soundMuted = qfalse;\t\t// we can play again\n\n\tS_RestartMusic();\n\n\textern void S_ReloadAllUsedSounds(void);\n\tS_ReloadAllUsedSounds();\n\n\textern void AS_ParseSets(void);\n\tAS_ParseSets();\n}\n/*\n==================\nCL_Configstrings_f\n==================\n*/\nvoid CL_Configstrings_f( void ) {\n\tint\t\ti;\n\tint\t\tofs;\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf( \"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tofs = cl.gameState.stringOffsets[ i ];\n\t\tif ( !ofs ) {\n\t\t\tcontinue;\n\t\t}\n\t\tCom_Printf( \"%4i: %s\\n\", i, cl.gameState.stringData + ofs );\n\t}\n}\n\n/*\n==============\nCL_Clientinfo_f\n==============\n*/\nvoid CL_Clientinfo_f( void ) {\n\tCom_Printf( \"--------- Client Information ---------\\n\" );\n\tCom_Printf( \"state: %i\\n\", cls.state );\n\tCom_Printf( \"Server: %s\\n\", cls.servername );\n\tCom_Printf (\"User info settings:\\n\");\n\tInfo_Print( Cvar_InfoString( CVAR_USERINFO ) );\n\tCom_Printf( \"--------------------------------------\\n\" );\n}\n\n\n//====================================================================\n\nvoid UI_UpdateConnectionString( const char *string );\n\n/*\n=================\nCL_CheckForResend\n\nResend a connect message if the last one has timed out\n=================\n*/\nvoid CL_CheckForResend( void ) {\n\tint\t\tport;\n\tchar\tinfo[MAX_INFO_STRING];\n\n//\tif ( cls.state == CA_CINEMATIC )\n\tif ( cls.state == CA_CINEMATIC || CL_IsRunningInGameCinematic())\n\t{\n\t\treturn;\n\t}\n\n\t// resend if we haven't gotten a reply yet\n\tif ( cls.state < CA_CONNECTING || cls.state > CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\n\tif ( cls.realtime - clc.connectTime < RETRANSMIT_TIMEOUT ) {\n\t\treturn;\n\t}\n\n\tclc.connectTime = cls.realtime;\t// for retransmit requests\n\tclc.connectPacketCount++;\n\n\t// requesting a challenge\n\tswitch ( cls.state ) {\n\tcase CA_CONNECTING:\n\t\tUI_UpdateConnectionString( va(\"(%i)\", clc.connectPacketCount ) );\n\n\t\tNET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, \"getchallenge\");\n\t\tbreak;\n\n\tcase CA_CHALLENGING:\n\t// sending back the challenge\n\t\tport = Cvar_VariableIntegerValue(\"net_qport\");\n\n\t\tUI_UpdateConnectionString( va(\"(%i)\", clc.connectPacketCount ) );\n\n\t\tQ_strncpyz( info, Cvar_InfoString( CVAR_USERINFO ), sizeof( info ) );\n\t\tInfo_SetValueForKey( info, \"protocol\", va(\"%i\", PROTOCOL_VERSION ) );\n\t\tInfo_SetValueForKey( info, \"qport\", va(\"%i\", port ) );\n\t\tInfo_SetValueForKey( info, \"challenge\", va(\"%i\", clc.challenge ) );\n\t\tNET_OutOfBandPrint( NS_CLIENT, clc.serverAddress, \"connect \\\"%s\\\"\", info );\n\t\t// the most current userinfo has been sent, so watch for any\n\t\t// newer changes to userinfo variables\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tbreak;\n\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"CL_CheckForResend: bad cls.state\" );\n\t}\n}\n\n\n/*\n===================\nCL_DisconnectPacket\n\nSometimes the server can drop the client and the netchan based\ndisconnect can be lost.  If the client continues to send packets\nto the server, the server will send out of band disconnect packets\nto the client so it doesn't have to wait for the full timeout period.\n===================\n*/\nvoid CL_DisconnectPacket( netadr_t from ) {\n\tif ( cls.state != CA_ACTIVE ) {\n\t\treturn;\n\t}\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\treturn;\n\t}\n\n\t// if we have received packets within three seconds, ignore it\n\t// (it might be a malicious spoof)\n\tif ( cls.realtime - clc.lastPacketTime < 3000 ) {\n\t\treturn;\n\t}\n\n\t// drop the connection (FIXME: connection dropped dialog)\n\tCom_Printf( \"Server disconnected for unknown reason\\n\" );\n\tCL_Disconnect();\n}\n\n\n/*\n=================\nCL_ConnectionlessPacket\n\nResponses to broadcasts, etc\n=================\n*/\nvoid CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tconst char\t*c;\n\n\tMSG_BeginReading( msg );\n\tMSG_ReadLong( msg );\t// skip the -1\n\n\ts = MSG_ReadStringLine( msg );\n\n\tCmd_TokenizeString( s );\n\n\tc = Cmd_Argv(0);\n\n\tCom_DPrintf (\"CL packet %s: %s\\n\", NET_AdrToString(from), c);\n\n\t// challenge from the server we are connecting to\n\tif ( !strcmp(c, \"challengeResponse\") ) {\n\t\tif ( cls.state != CA_CONNECTING ) {\n\t\t\tCom_Printf( \"Unwanted challenge response received.  Ignored.\\n\" );\n\t\t} else {\n\t\t\t// start sending challenge repsonse instead of challenge request packets\n\t\t\tclc.challenge = atoi(Cmd_Argv(1));\n\t\t\tcls.state = CA_CHALLENGING;\n\t\t\tclc.connectPacketCount = 0;\n\t\t\tclc.connectTime = -99999;\n\n\t\t\t// take this address as the new server address.  This allows\n\t\t\t// a server proxy to hand off connections to multiple servers\n\t\t\tclc.serverAddress = from;\n\t\t}\n\t\treturn;\n\t}\n\n\t// server connection\n\tif ( !strcmp(c, \"connectResponse\") ) {\n\t\tif ( cls.state >= CA_CONNECTED ) {\n\t\t\tCom_Printf (\"Dup connect received.  Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( cls.state != CA_CHALLENGING ) {\n\t\t\tCom_Printf (\"connectResponse packet while not connecting.  Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( !NET_CompareBaseAdr( from, clc.serverAddress ) ) {\n\t\t\tCom_Printf( \"connectResponse from a different address.  Ignored.\\n\" );\n\t\t\tCom_Printf( \"%s should have been %s\\n\", NET_AdrToString( from ),\n\t\t\t\tNET_AdrToString( clc.serverAddress ) );\n\t\t\treturn;\n\t\t}\n\t\tNetchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableIntegerValue( \"net_qport\" ) );\n\t\tcls.state = CA_CONNECTED;\n\t\tclc.lastPacketSentTime = -9999;\t\t// send first packet immediately\n\t\treturn;\n\t}\n\n\t// a disconnect message from the server, which will happen if the server\n\t// dropped the connection but it is still getting packets from us\n\tif (!strcmp(c, \"disconnect\")) {\n\t\tCL_DisconnectPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !strcmp(c, \"echo\") ) {\n\t\tNET_OutOfBandPrint( NS_CLIENT, from, \"%s\", Cmd_Argv(1) );\n\t\treturn;\n\t}\n\n\t// print request from server\n\tif ( !strcmp(c, \"print\") ) {\n\t\ts = MSG_ReadString( msg );\n\t\tUI_UpdateConnectionMessageString( s );\n\t\tCom_Printf( \"%s\", s );\n\t\treturn;\n\t}\n\n\n\tCom_DPrintf (\"Unknown connectionless packet command.\\n\");\n}\n\n\n/*\n=================\nCL_PacketEvent\n\nA packet has arrived from the main event loop\n=================\n*/\nvoid CL_PacketEvent( netadr_t from, msg_t *msg ) {\n\tclc.lastPacketTime = cls.realtime;\n\n\tif ( msg->cursize >= 4 && *(int *)msg->data == -1 ) {\n\t\tCL_ConnectionlessPacket( from, msg );\n\t\treturn;\n\t}\n\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\t\t// can't be a valid sequenced packet\n\t}\n\n\tif ( msg->cursize < 8 ) {\n\t\tCom_Printf (\"%s: Runt packet\\n\",NET_AdrToString( from ));\n\t\treturn;\n\t}\n\n\t//\n\t// packet from server\n\t//\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\tCom_DPrintf (\"%s:sequenced packet without connection\\n\"\n\t\t\t,NET_AdrToString( from ) );\n\t\t// FIXME: send a client disconnect?\n\t\treturn;\n\t}\n\n\tif (!Netchan_Process( &clc.netchan, msg) ) {\n\t\treturn;\t\t// out of order, duplicated, etc\n\t}\n\n\tclc.lastPacketTime = cls.realtime;\n\tCL_ParseServerMessage( msg );\n}\n\n/*\n==================\nCL_CheckTimeout\n\n==================\n*/\nvoid CL_CheckTimeout( void ) {\n\t//\n\t// check timeout\n\t//\n\tif ( ( !CL_CheckPaused() || !sv_paused->integer )\n//\t\t&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC\n\t\t&& cls.state >= CA_CONNECTED && (cls.state != CA_CINEMATIC && !CL_IsRunningInGameCinematic())\n\t\t&& cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {\n\t\tif (++cl.timeoutcount > 5) {\t// timeoutcount saves debugger\n\t\t\tCom_Printf (\"\\nServer connection timed out.\\n\");\n\t\t\tCL_Disconnect ();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tcl.timeoutcount = 0;\n\t}\n}\n\n/*\n==================\nCL_CheckPaused\nCheck whether client has been paused.\n==================\n*/\nqboolean CL_CheckPaused(void)\n{\n\t// if cl_paused->modified is set, the cvar has only been changed in\n\t// this frame. Keep paused in this frame to ensure the server doesn't\n\t// lag behind.\n\tif(cl_paused->integer || cl_paused->modified)\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n//============================================================================\n\n/*\n==================\nCL_CheckUserinfo\n\n==================\n*/\nvoid CL_CheckUserinfo( void ) {\n\tif ( cls.state < CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\t// don't overflow the reliable command buffer when paused\n\tif ( CL_CheckPaused() ) {\n\t\treturn;\n\t}\n\t// send a reliable userinfo update if needed\n\tif ( cvar_modifiedFlags & CVAR_USERINFO ) {\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tCL_AddReliableCommand( va(\"userinfo \\\"%s\\\"\", Cvar_InfoString( CVAR_USERINFO ) ) );\n\t}\n\n}\n\n\n/*\n==================\nCL_Frame\n\n==================\n*/\nextern cvar_t\t*cl_newClock;\nstatic unsigned int frameCount;\nfloat avgFrametime=0.0;\nvoid CL_Frame ( int msec,float fractionMsec ) {\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// load the ref / cgame if needed\n\tCL_StartHunkUsers();\n\n\tif ( cls.state == CA_DISCONNECTED && !( Key_GetCatcher( ) & KEYCATCH_UI )\n\t\t&& !com_sv_running->integer ) {\n\t\t// if disconnected, bring up the menu\n\t\tif (!CL_CheckPendingCinematic())\t// this avoid having the menu flash for one frame before pending cinematics\n\t\t{\n\t\t\tUI_SetActiveMenu( \"mainMenu\",NULL );\n\t\t}\n\t}\n\n\n\t// if recording an avi, lock to a fixed fps\n\tif ( cl_avidemo->integer ) {\n\t\t// save the current screen\n\t\tif ( cls.state == CA_ACTIVE ) {\n\t\t\tif (cl_avidemo->integer > 0) {\n\t\t\t\tCbuf_ExecuteText( EXEC_NOW, \"screenshot silent\\n\" );\n\t\t\t} else {\n\t\t\t\tCbuf_ExecuteText( EXEC_NOW, \"screenshot_tga silent\\n\" );\n\t\t\t}\n\t\t}\n\t\t// fixed time for next frame\n\t\tif (cl_avidemo->integer > 0) {\n\t\t\tmsec = 1000 / cl_avidemo->integer;\n\t\t} else {\n\t\t\tmsec = 1000 / -cl_avidemo->integer;\n\t\t}\n\t}\n\n\t// save the msec before checking pause\n\tcls.realFrametime = msec;\n\n\t// decide the simulation time\n\tcls.frametime = msec;\n\tif(cl_framerate->integer)\n\t{\n\t\tavgFrametime+=msec;\n\t\tchar mess[256];\n\t\tif(!(frameCount&0x1f))\n\t\t{\n\t\t\tsprintf(mess,\"Frame rate=%f\\n\\n\",1000.0f*(1.0/(avgFrametime/32.0f)));\n\t//\t\tOutputDebugString(mess);\n\t\t\tCom_Printf(mess);\n\t\t\tavgFrametime=0.0f;\n\t\t}\n\t\tframeCount++;\n\t}\n\tcls.frametimeFraction=fractionMsec;\n\tcls.realtime += msec;\n\tcls.realtimeFraction+=fractionMsec;\n\tif (cls.realtimeFraction>=1.0f)\n\t{\n\t\tif (cl_newClock&&cl_newClock->integer)\n\t\t{\n\t\t\tcls.realtime++;\n\t\t}\n\t\tcls.realtimeFraction-=1.0f;\n\t}\n\tif ( cl_timegraph->integer ) {\n\t\tSCR_DebugGraph ( cls.realFrametime * 0.25, 0 );\n\t}\n\n\t// see if we need to update any userinfo\n\tCL_CheckUserinfo();\n\n\t// if we haven't gotten a packet in a long time,\n\t// drop the connection\n\tCL_CheckTimeout();\n\n\t// send intentions now\n\tCL_SendCmd();\n\n\t// resend a connection request if necessary\n\tCL_CheckForResend();\n\n\t// decide on the serverTime to render\n\tCL_SetCGameTime();\n\n\tif (cl_pano->integer && cls.state == CA_ACTIVE) {\t//grab some panoramic shots\n\t\tint i = 1;\n\t\tint pref = cl_pano->integer;\n\t\tint oldnoprint = cl_noprint->integer;\n\t\tCon_Close();\n\t\tcl_noprint->integer = 1;\t//hide the screen shot msgs\n\t\tfor (; i <= cl_panoNumShots->integer; i++) {\n\t\t\tCvar_SetValue( \"pano\", i );\n\t\t\tSCR_UpdateScreen();// update the screen\n\t\t\tCbuf_ExecuteText( EXEC_NOW, va(\"screenshot %dpano%02d\\n\", pref, i) );\t//grab this screen\n\t\t}\n\t\tCvar_SetValue( \"pano\", 0 );\t//done\n\t\tcl_noprint->integer = oldnoprint;\n\t}\n\n\tif (cl_skippingcin->integer && !cl_endcredits->integer && !com_developer->integer ) {\n\t\tif (cl_skippingcin->modified){\n\t\t\tS_StopSounds();\t\t//kill em all but music\n\t\t\tcl_skippingcin->modified=qfalse;\n\t\t\tCom_Printf (S_COLOR_YELLOW \"%s\", SE_GetString(\"CON_TEXT_SKIPPING\"));\n\t\t\tSCR_UpdateScreen();\n\t\t}\n\t} else {\n\t\t// update the screen\n\t\tSCR_UpdateScreen();\n\t}\n\t// update audio\n\tS_Update();\n\n\t// advance local effects for next frame\n\tSCR_RunCinematic();\n\n\tCon_RunConsole();\n\n\tcls.framecount++;\n}\n\n//============================================================================\n\n/*\n============\nCL_ShutdownRef\n============\n*/\nstatic void CL_ShutdownRef( qboolean restarting ) {\n\tif ( re.Shutdown ) {\n\t\tre.Shutdown( qtrue, restarting );\n\t}\n\n\tmemset( &re, 0, sizeof( re ) );\n\n\tif ( rendererLib != NULL ) {\n\t\tSys_UnloadDll (rendererLib);\n\t\trendererLib = NULL;\n\t}\n}\n\n/*\n============================\nCL_StartSound\n\nConvenience function for the sound system to be started\nREALLY early on Xbox, helps with memory fragmentation.\n============================\n*/\nvoid CL_StartSound( void ) {\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n}\n\n/*\n============\nCL_InitRenderer\n============\n*/\nvoid CL_InitRenderer( void ) {\n\t// this sets up the renderer and calls R_Init\n\tre.BeginRegistration( &cls.glconfig );\n\n\t// load character sets\n\tcls.charSetShader = re.RegisterShaderNoMip(\"gfx/2d/charsgrid_med\");\n\tcls.whiteShader = re.RegisterShader( \"white\" );\n\tcls.consoleShader = re.RegisterShader( \"console\" );\n\tg_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;\n\tg_consoleField.widthInChars = g_console_field_width;\n}\n\n/*\n============================\nCL_StartHunkUsers\n\nAfter the server has cleared the hunk, these will need to be restarted\nThis is the only place that any of these functions are called from\n============================\n*/\nvoid CL_StartHunkUsers( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif ( !cls.rendererStarted ) {\n\t\tcls.rendererStarted = qtrue;\n\t\tCL_InitRenderer();\n\t}\n\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n\n\t//we require the ui to be loaded here or else it crashes trying to access the ui on command line map loads\n\tif ( !cls.uiStarted ) {\n\t\tcls.uiStarted = qtrue;\n\t\tCL_InitUI();\n\t}\n\n//\tif ( !cls.cgameStarted && cls.state > CA_CONNECTED && cls.state != CA_CINEMATIC ) {\n\tif ( !cls.cgameStarted && cls.state > CA_CONNECTED && (cls.state != CA_CINEMATIC && !CL_IsRunningInGameCinematic()) )\n\t{\n\t\tcls.cgameStarted = qtrue;\n\t\tCL_InitCGame();\n\t}\n}\n\n/*\n================\nCL_RefPrintf\n\nDLL glue\n================\n*/\nvoid QDECL CL_RefPrintf( int print_level, const char *fmt, ...) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf(msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tif ( print_level == PRINT_ALL ) {\n\t\tCom_Printf (\"%s\", msg);\n\t} else if ( print_level == PRINT_WARNING ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"%s\", msg);\t\t// yellow\n\t} else if ( print_level == PRINT_DEVELOPER ) {\n\t\tCom_DPrintf (S_COLOR_RED \"%s\", msg);\t\t// red\n\t}\n}\n\n/*\n============\nString_GetStringValue\n\nDLL glue, but highly reusuable DLL glue at that\n============\n*/\n\nconst char *String_GetStringValue( const char *reference )\n{\n#ifndef JK2_MODE\n\treturn SE_GetString(reference);\n#else\n\treturn JK2SP_GetStringTextString(reference);\n#endif\n}\n\nextern qboolean gbAlreadyDoingLoad;\nextern void *gpvCachedMapDiskImage;\nextern char  gsCachedMapDiskImage[MAX_QPATH];\nextern qboolean gbUsingCachedMapDataRightNow;\n\nchar *get_gsCachedMapDiskImage( void )\n{\n\treturn gsCachedMapDiskImage;\n}\n\nvoid *get_gpvCachedMapDiskImage( void )\n{\n\treturn gpvCachedMapDiskImage;\n}\n\nqboolean *get_gbUsingCachedMapDataRightNow( void )\n{\n\treturn &gbUsingCachedMapDataRightNow;\n}\n\nqboolean *get_gbAlreadyDoingLoad( void )\n{\n\treturn &gbAlreadyDoingLoad;\n}\n\nint get_com_frameTime( void )\n{\n\treturn com_frameTime;\n}\n\nvoid *CL_Malloc(int iSize, memtag_t eTag, qboolean bZeroit, int iAlign)\n{\n    return Z_Malloc(iSize, eTag, bZeroit);\n}\n\n/*\n============\nCL_InitRef\n============\n*/\nextern qboolean S_FileExists( const char *psFilename );\nextern bool CM_CullWorldBox (const cplane_t *frustum, const vec3pair_t bounds);\nextern qboolean SND_RegisterAudio_LevelLoadEnd(qboolean bDeleteEverythingNotUsedThisLevel /* 99% qfalse */);\nextern cvar_t *Cvar_Set2( const char *var_name, const char *value, qboolean force);\nextern CMiniHeap *G2VertSpaceServer;\nstatic CMiniHeap *GetG2VertSpaceServer( void ) {\n\treturn G2VertSpaceServer;\n}\n\n// NOTENOTE: If you change the output name of rd-vanilla, change this define too!\n#ifdef JK2_MODE\n#define DEFAULT_RENDER_LIBRARY\t\"rdjosp-vanilla\"\n#else\n#define DEFAULT_RENDER_LIBRARY\t\"rdsp-vanilla\"\n#endif\n\nvoid CL_InitRef( void ) {\n\trefexport_t\t*ret;\n\tstatic refimport_t rit;\n\tchar\t\tdllName[MAX_OSPATH];\n\tGetRefAPI_t\tGetRefAPI;\n\n\tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n    cl_renderer = Cvar_Get( \"cl_renderer\", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH );\n\n\tCom_sprintf( dllName, sizeof( dllName ), \"%s_\" ARCH_STRING DLL_EXT, cl_renderer->string );\n\n\tif( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) )\n\t{\n\t\tCom_Printf( \"failed: trying to load fallback renderer\\n\" );\n\t\tCvar_ForceReset( \"cl_renderer\" );\n\n\t\tCom_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY \"_\" ARCH_STRING DLL_EXT );\n\t\trendererLib = Sys_LoadDll( dllName, qfalse );\n\t}\n\n\tif ( !rendererLib ) {\n\t\tCom_Error( ERR_FATAL, \"Failed to load renderer\\n\" );\n\t}\n\n\tmemset( &rit, 0, sizeof( rit ) );\n\n\tGetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, \"GetRefAPI\" );\n\tif ( !GetRefAPI )\n\t\tCom_Error( ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\", Sys_LibraryError() );\n\n#define RIT(y)\trit.y = y\n\tRIT(CIN_PlayCinematic);\n\tRIT(CIN_RunCinematic);\n\tRIT(CIN_UploadCinematic);\n\tRIT(CL_IsRunningInGameCinematic);\n\tRIT(Cmd_AddCommand);\n\tRIT(Cmd_Argc);\n\tRIT(Cmd_ArgsBuffer);\n\tRIT(Cmd_Argv);\n\tRIT(Cmd_ExecuteString);\n\tRIT(Cmd_RemoveCommand);\n\tRIT(CM_ClusterPVS);\n\tRIT(CM_CullWorldBox);\n\tRIT(CM_DeleteCachedMap);\n\tRIT(CM_DrawDebugSurface);\n\tRIT(CM_PointContents);\n\tRIT(Cvar_Get);\n\tRIT(Cvar_Set);\n\tRIT(Cvar_SetValue);\n\tRIT(Cvar_CheckRange);\n\tRIT(Cvar_VariableIntegerValue);\n\tRIT(Cvar_VariableString);\n\tRIT(Cvar_VariableStringBuffer);\n\tRIT(Cvar_VariableValue);\n\tRIT(FS_FCloseFile);\n\tRIT(FS_FileIsInPAK);\n\tRIT(FS_FOpenFileByMode);\n\tRIT(FS_FOpenFileRead);\n\tRIT(FS_FOpenFileWrite);\n\tRIT(FS_FreeFile);\n\tRIT(FS_FreeFileList);\n\tRIT(FS_ListFiles);\n\tRIT(FS_Read);\n\tRIT(FS_ReadFile);\n\tRIT(FS_Write);\n\tRIT(FS_WriteFile);\n\tRIT(Hunk_ClearToMark);\n\tRIT(SND_RegisterAudio_LevelLoadEnd);\n\t//RIT(SV_PointContents);\n\tRIT(SV_Trace);\n\tRIT(S_RestartMusic);\n\tRIT(Z_Free);\n\trit.Malloc=CL_Malloc;\n\tRIT(Z_MemSize);\n\tRIT(Z_MorphMallocTag);\n\n\tRIT(Hunk_ClearToMark);\n\n    rit.WIN_Init = WIN_Init;\n\trit.WIN_SetGamma = WIN_SetGamma;\n    rit.WIN_Shutdown = WIN_Shutdown;\n    rit.WIN_Present = WIN_Present;\n\trit.GL_GetProcAddress = WIN_GL_GetProcAddress;\n\trit.GL_ExtensionSupported = WIN_GL_ExtensionSupported;\n\n\trit.PD_Load = PD_Load;\n\trit.PD_Store = PD_Store;\n\n\trit.Error = Com_Error;\n\trit.FS_FileExists = S_FileExists;\n\trit.GetG2VertSpaceServer = GetG2VertSpaceServer;\n\trit.LowPhysicalMemory = Sys_LowPhysicalMemory;\n\trit.Milliseconds = Sys_Milliseconds2;\n\trit.Printf = CL_RefPrintf;\n\trit.SE_GetString = String_GetStringValue;\n\n\trit.SV_Trace = SV_Trace;\n\n\trit.gpvCachedMapDiskImage = get_gpvCachedMapDiskImage;\n\trit.gsCachedMapDiskImage = get_gsCachedMapDiskImage;\n\trit.gbUsingCachedMapDataRightNow = get_gbUsingCachedMapDataRightNow;\n\trit.gbAlreadyDoingLoad = get_gbAlreadyDoingLoad;\n\trit.com_frameTime = get_com_frameTime;\n\n\trit.SV_PointContents = SV_PointContents;\n\n\trit.saved_game = &ojk::SavedGame::get_instance();\n\n\tret = GetRefAPI( REF_API_VERSION, &rit );\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = *ret;\n\n\tCom_Printf( \"-------------------------------\\n\");\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n\n//===========================================================================================\n\nvoid CL_CompleteCinematic( char *args, int argNum );\n\n/*\n====================\nCL_Init\n====================\n*/\nvoid CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n#ifdef JK2_MODE\n\tJK2SP_Register(\"con_text\", SP_REGISTER_REQUIRED);\t//reference is CON_TEXT\n\tJK2SP_Register(\"keynames\", SP_REGISTER_REQUIRED);\t// reference is KEYNAMES\n#endif\n\n\tCon_Init ();\n\n\tCL_ClearState ();\n\n\tcls.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t//cls.keyCatchers = KEYCATCH_CONSOLE;\n\tcls.realtime = 0;\n\tcls.realtimeFraction=0.0f;\t// fraction of a msec accumulated\n\n\tCL_InitInput ();\n\n\t//\n\t// register our variables\n\t//\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"125\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_newClock = Cvar_Get (\"cl_newClock\", \"1\", 0);\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_avidemo = Cvar_Get (\"cl_avidemo\", \"0\", 0);\n\tcl_pano = Cvar_Get (\"pano\", \"0\", 0);\n\tcl_panoNumShots= Cvar_Get (\"panoNumShots\", \"10\", CVAR_ARCHIVE);\n\tcl_skippingcin = Cvar_Get (\"skippingCinematic\", \"0\", CVAR_ROM);\n\tcl_endcredits = Cvar_Get (\"cg_endcredits\", \"0\", 0);\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", CVAR_ARCHIVE);\n\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n\n\tcl_allowAltEnter = Cvar_Get (\"cl_allowAltEnter\", \"1\", CVAR_ARCHIVE);\n\tcl_inGameVideo = Cvar_Get (\"cl_inGameVideo\", \"1\", CVAR_ARCHIVE);\n\tcl_framerate\t= Cvar_Get (\"cl_framerate\", \"0\", CVAR_TEMP);\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n\n\t// ~ and `, as keys and characters\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60 0xb2\", CVAR_ARCHIVE);\n\tcl_consoleUseScanCode = Cvar_Get( \"cl_consoleUseScanCode\", \"1\", CVAR_ARCHIVE );\n\n\t// userinfo\n#ifdef JK2_MODE\n\tCvar_Get (\"name\", \"Kyle\", CVAR_USERINFO | CVAR_ARCHIVE );\n#else\n\tCvar_Get (\"name\", \"Jaden\", CVAR_USERINFO | CVAR_ARCHIVE );\n#endif\n\n#ifdef JK2_MODE\n\t// this is required for savegame compatibility - not ever actually used\n\tCvar_Get (\"snaps\", \"20\", CVAR_USERINFO );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_SAVEGAME );\n#else\n\tCvar_Get (\"sex\", \"f\", CVAR_USERINFO | CVAR_ARCHIVE | CVAR_SAVEGAME | CVAR_NORESTART );\n\tCvar_Get (\"snd\", \"jaden_fmle\", CVAR_USERINFO | CVAR_ARCHIVE | CVAR_SAVEGAME | CVAR_NORESTART );//UI_SetSexandSoundForModel changes to match sounds.cfg for model\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_SAVEGAME | CVAR_NORESTART);\n#endif\n\n\t//\n\t// register our commands\n\t//\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\n\tCmd_SetCommandCompletionFunc( \"cinematic\", CL_CompleteCinematic );\n\tCmd_AddCommand (\"ingamecinematic\", CL_PlayInGameCinematic_f);\n\tCmd_AddCommand (\"uimenu\", CL_GenericMenu_f);\n\tCmd_AddCommand (\"datapad\", CL_DataPad_f);\n\tCmd_AddCommand (\"endscreendissolve\", CL_EndScreenDissolve_f);\n\n\tCL_InitRef();\n\n\tCL_StartHunkUsers();\n\n\tSCR_Init ();\n\n\tCbuf_Execute ();\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n\n\n/*\n===============\nCL_Shutdown\n\n===============\n*/\nvoid CL_Shutdown( void ) {\n\tstatic qboolean recursive = qfalse;\n\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tCom_Printf( \"----- CL_Shutdown -----\\n\" );\n\n\tif ( recursive ) {\n\t\tCom_Printf( \"WARNING: Recursive shutdown\\n\" );\n\t\treturn;\n\t}\n\trecursive = qtrue;\n\n\tCL_ShutdownUI();\n\tCL_Disconnect();\n\n\tS_Shutdown();\n\tCL_ShutdownRef(qfalse);\n\n\tCmd_RemoveCommand (\"cmd\");\n\tCmd_RemoveCommand (\"configstrings\");\n\tCmd_RemoveCommand (\"clientinfo\");\n\tCmd_RemoveCommand (\"snd_restart\");\n\tCmd_RemoveCommand (\"vid_restart\");\n\tCmd_RemoveCommand (\"disconnect\");\n\tCmd_RemoveCommand (\"cinematic\");\n\tCmd_RemoveCommand (\"ingamecinematic\");\n\tCmd_RemoveCommand (\"uimenu\");\n\tCmd_RemoveCommand (\"datapad\");\n\tCmd_RemoveCommand (\"endscreendissolve\");\n\n\tCvar_Set( \"cl_running\", \"0\" );\n\n\trecursive = qfalse;\n\n\tmemset( &cls, 0, sizeof( cls ) );\n\n\tCom_Printf( \"-----------------------\\n\" );\n}\n\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n/*****************************************************************************\n * name:\t\tfiles.cpp\n *\n * desc:\t\tfile code\n *\n *****************************************************************************/\n\n#include \"q_shared.h\"\n#include \"qcommon.h\"\n\n#ifndef FINAL_BUILD\n#include \"../client/client.h\"\n#endif\n#include <minizip/unzip.h>\n\n// for rmdir\n#if defined (_MSC_VER)\n\t#include <direct.h>\n#else\n\t#include <unistd.h>\n#endif\n\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n/*\n=============================================================================\n\nQUAKE3 FILESYSTEM\n\nAll of Quake's data access is through a hierarchical file system, but the contents of\nthe file system can be transparently merged from several sources.\n\nA \"qpath\" is a reference to game file data.  MAX_ZPATH is 256 characters, which must include\na terminating zero. \"..\", \"\\\\\", and \":\" are explicitly illegal in qpaths to prevent any\nreferences outside the quake directory system.\n\nThe \"base path\" is the path to the directory holding all the game directories and usually\nthe executable.  It defaults to \".\", but can be overridden with a \"+set fs_basepath c:\\quake3\"\ncommand line to allow code debugging in a different directory.  Basepath cannot\nbe modified at all after startup.  Any files that are created (demos, screenshots,\netc) will be created relative to the base path, so base path should usually be writable.\n\nThe \"home path\" is the path used for all write access. On win32 systems we have \"base path\"\n== \"home path\", but on *nix systems the base installation is usually readonly, and\n\"home path\" points to ~/.q3a or similar\n\nThe user can also install custom mods and content in \"home path\", so it should be searched\nalong with \"home path\" and \"cd path\" for game content.\n\n\nThe \"base game\" is the directory under the paths where data comes from by default, and\ncan be either \"baseq3\" or \"demoq3\".\n\nThe \"current game\" may be the same as the base game, or it may be the name of another\ndirectory under the paths that should be searched for files before looking in the base game.\nThis is the basis for addons.\n\nClients automatically set the game directory after receiving a gamestate from a server,\nso only servers need to worry about +set fs_game.\n\nNo other directories outside of the base game and current game will ever be referenced by\nfilesystem functions.\n\nTo save disk space and speed loading, directory trees can be collapsed into zip files.\nThe files use a \".pk3\" extension to prevent users from unzipping them accidentally, but\notherwise the are simply normal uncompressed zip files.  A game directory can have multiple\nzip files of the form \"pak0.pk3\", \"pak1.pk3\", etc.  Zip files are searched in decending order\nfrom the highest number to the lowest, and will always take precedence over the filesystem.\nThis allows a pk3 distributed as a patch to override all existing data.\n\nBecause we will have updated executables freely available online, there is no point to\ntrying to restrict demo / oem versions of the game with code changes.  Demo / oem versions\nshould be exactly the same executables as release versions, but with different data that\nautomatically restricts where game media can come from to prevent add-ons from working.\n\nFile search order: when FS_FOpenFileRead gets called it will go through the fs_searchpaths\nstructure and stop on the first successful hit. fs_searchpaths is built with successive\ncalls to FS_AddGameDirectory\n\nAdditionaly, we search in several subdirectories:\ncurrent game is the current mode\nbase game is a variable to allow mods based on other mods\n(such as baseq3 + missionpack content combination in a mod for instance)\nBASEGAME is the hardcoded base game (\"baseq3\")\n\ne.g. the qpath \"sound/newstuff/test.wav\" would be searched for in the following places:\n\nhome path + current game's zip files\nhome path + current game's directory\nbase path + current game's zip files\nbase path + current game's directory\ncd path + current game's zip files\ncd path + current game's directory\n\nhome path + base game's zip file\nhome path + base game's directory\nbase path + base game's zip file\nbase path + base game's directory\ncd path + base game's zip file\ncd path + base game's directory\n\nhome path + BASEGAME's zip file\nhome path + BASEGAME's directory\nbase path + BASEGAME's zip file\nbase path + BASEGAME's directory\ncd path + BASEGAME's zip file\ncd path + BASEGAME's directory\n\nserver download, to be written to home path + current game's directory\n\n\nThe filesystem can be safely shutdown and reinitialized with different\nbasedir / cddir / game combinations, but all other subsystems that rely on it\n(sound, video) must also be forced to restart.\n\nBecause the same files are loaded by both the clip model (CM_) and renderer (TR_)\nsubsystems, a simple single-file caching scheme is used.  The CM_ subsystems will\nload the file with a request to cache.  Only one file will be kept cached at a time,\nso any models that are going to be referenced by both subsystems should alternate\nbetween the CM_ load function and the ref load function.\n\nTODO: A qpath that starts with a leading slash will always refer to the base game, even if another\ngame is currently active.  This allows character models, skins, and sounds to be downloaded\nto a common directory no matter which game is active.\n\nHow to prevent downloading zip files?\nPass pk3 file names in systeminfo, and download before FS_Restart()?\n\nAborting a download disconnects the client from the server.\n\nHow to mark files as downloadable?  Commercial add-ons won't be downloadable.\n\nNon-commercial downloads will want to download the entire zip file.\nthe game would have to be reset to actually read the zip in\n\nAuto-update information\n\nPath separators\n\nCasing\n\n  separate server gamedir and client gamedir, so if the user starts\n  a local game after having connected to a network game, it won't stick\n  with the network game.\n\n  allow menu options for game selection?\n\nRead / write config to floppy option.\n\nDifferent version coexistance?\n\nWhen building a pak file, make sure a q3config.cfg isn't present in it,\nor configs will never get loaded from disk!\n\n  todo:\n\n  downloading (outside fs?)\n  game directory passing and restarting\n\n=============================================================================\n\n*/\n\n/*static const uint32_t pak_checksums[] = {\n\t0u,\n};\n\nstatic const uint32_t bonuspak_checksum = 0u;*/\n\n#define MAX_ZPATH\t\t\t256\n#define\tMAX_SEARCH_PATHS\t4096\n#define MAX_FILEHASH_SIZE\t1024\n\ntypedef struct fileInPack_s {\n\tchar\t\t\t\t\t*name;\t\t// name of the file\n\tunsigned long\t\t\tpos;\t\t// file info position in zip\n\tunsigned long\t\t\tlen;\t\t// uncompress file size\n\tstruct\tfileInPack_s*\tnext;\t\t// next file in the hash\n} fileInPack_t;\n\ntypedef struct pack_s {\n\tchar\t\t\tpakPathname[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\t\tpakFilename[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\\assets0.pk3\n\tchar\t\t\tpakBasename[MAX_OSPATH];\t// assets0\n\tchar\t\t\tpakGamename[MAX_OSPATH];\t// base\n\tunzFile\t\t\thandle;\t\t\t\t\t\t// handle to zip file\n\tint\t\t\t\tchecksum;\t\t\t\t\t// regular checksum\n\tint\t\t\t\tnumfiles;\t\t\t\t\t// number of files in pk3\n\tint\t\t\t\thashSize;\t\t\t\t\t// hash table size (power of 2)\n\tfileInPack_t*\t*hashTable;\t\t\t\t\t// hash table\n\tfileInPack_t*\tbuildBuffer;\t\t\t\t// buffer with the filenames etc.\n} pack_t;\n\ntypedef struct directory_s {\n\tchar\t\tpath[MAX_OSPATH];\t\t// c:\\jediacademy\\gamedata\n\tchar\t\tfullpath[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\tgamedir[MAX_OSPATH];\t// base\n} directory_t;\n\ntypedef struct searchpath_s {\n\tstruct searchpath_s *next;\n\n\tpack_t\t\t*pack;\t\t// only one of pack / dir will be non NULL\n\tdirectory_t\t*dir;\n} searchpath_t;\n\nstatic char\t\tfs_gamedir[MAX_OSPATH];\t// this will be a single file name with no separators\nstatic cvar_t\t\t*fs_debug;\nstatic cvar_t\t\t*fs_homepath;\n\n#ifdef MACOS_X\n// Also search the .app bundle for .pk3 files\nstatic cvar_t          *fs_apppath;\n#endif\n\nstatic cvar_t\t\t*fs_basepath;\nstatic cvar_t\t\t*fs_basegame;\nstatic cvar_t\t\t*fs_cdpath;\nstatic cvar_t\t\t*fs_copyfiles;\nstatic cvar_t\t\t*fs_gamedirvar;\nstatic cvar_t\t\t*fs_dirbeforepak; //rww - when building search path, keep directories at top and insert pk3's under them\nstatic searchpath_t\t*fs_searchpaths;\nstatic int\t\t\tfs_readCount;\t\t\t// total bytes read\nstatic int\t\t\tfs_loadCount;\t\t\t// total files read\nstatic int\t\t\tfs_packFiles = 0;\t\t// total number of files in packs\n\ntypedef union qfile_gus {\n\tFILE*\t\to;\n\tunzFile\t\tz;\n} qfile_gut;\n\ntypedef struct qfile_us {\n\tqfile_gut\tfile;\n\tqboolean\tunique;\n} qfile_ut;\n\ntypedef struct fileHandleData_s {\n\tqfile_ut\thandleFiles;\n\tqboolean\thandleSync;\n\tint\t\t\tfileSize;\n\tint\t\t\tzipFilePos;\n\tint\t\t\tzipFileLen;\n\tqboolean\tzipFile;\n\tchar\t\tname[MAX_ZPATH];\n} fileHandleData_t;\n\nstatic fileHandleData_t\tfsh[MAX_FILE_HANDLES];\n\n// last valid game folder used\nchar lastValidBase[MAX_OSPATH];\nchar lastValidGame[MAX_OSPATH];\n\n/* C99 defines __func__ */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2 || _MSC_VER >= 1300\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"(unknown)\"\n#  endif\n#endif\n\n/*\n==============\nFS_Initialized\n==============\n*/\n\nqboolean FS_Initialized( void ) {\n\treturn (qboolean)(fs_searchpaths != NULL);\n}\n\nstatic void FS_AssertInitialised( void ) {\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n}\n\n/*\n================\nreturn a hash value for the filename\n================\n*/\nstatic long FS_HashFileName( const char *fname, int hashSize ) {\n\tint\t\ti;\n\tlong\thash;\n\tchar\tletter;\n\n\thash = 0;\n\ti = 0;\n\twhile (fname[i] != '\\0') {\n\t\tletter = tolower(fname[i]);\n\t\tif (letter =='.') break;\t\t\t\t// don't include extension\n\t\tif (letter =='\\\\') letter = '/';\t\t// damn path names\n\t\tif (letter == PATH_SEP) letter = '/';\t\t// damn path names\n\t\thash+=(long)(letter)*(i+119);\n\t\ti++;\n\t}\n\thash = (hash ^ (hash >> 10) ^ (hash >> 20));\n\thash &= (hashSize-1);\n\treturn hash;\n}\n\nstatic fileHandle_t FS_HandleForFile(void) {\n\tint\t\ti;\n\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o == NULL ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tCom_Printf( \"FS_HandleForFile: all handles taken:\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tCom_Printf( \"%d. %s\\n\", i, fsh[i].name);\n\t}\n\tCom_Error( ERR_DROP, \"FS_HandleForFile: none free\" );\n\treturn 0;\n}\n\nstatic FILE\t*FS_FileForHandle( fileHandle_t f ) {\n\tif ( f < 1 || f >= MAX_FILE_HANDLES ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: out of range\" );\n\t}\n\tif (fsh[f].zipFile == qtrue) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: can't get FILE on zip file\" );\n\t}\n\tif ( ! fsh[f].handleFiles.file.o ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: NULL\" );\n\t}\n\n\treturn fsh[f].handleFiles.file.o;\n}\n\nvoid\tFS_ForceFlush( fileHandle_t f ) {\n\tFILE *file;\n\n\tfile = FS_FileForHandle(f);\n\tsetvbuf( file, NULL, _IONBF, 0 );\n}\n\n/*\n================\nFS_fplength\n================\n*/\n\nlong FS_fplength(FILE *h)\n{\n\tlong\t\tpos;\n\tlong\t\tend;\n\n\tpos = ftell(h);\n\tif ( pos == EOF )\n\t\treturn EOF;\n\n\tfseek(h, 0, SEEK_END);\n\tend = ftell(h);\n\tfseek(h, pos, SEEK_SET);\n\n\treturn end;\n}\n\n/*\n================\nFS_filelength\n\nIf this is called on a non-unique FILE (from a pak file),\nit will return the size of the pak file, not the expected\nsize of the file.\n================\n*/\nint FS_filelength( fileHandle_t f ) {\n\tFILE\t*h;\n\n\th = FS_FileForHandle(f);\n\n\tif(h == NULL)\n\t\treturn EOF;\n\telse\n\t\treturn FS_fplength(h);\n}\n\n/*\n====================\nFS_ReplaceSeparators\n\nFix things up differently for win/unix/mac\n====================\n*/\nvoid FS_ReplaceSeparators( char *path ) {\n\tchar\t*s;\n\tqboolean lastCharWasSep = qfalse;\n\n\tfor ( s = path ; *s ; s++ ) {\n\t\tif ( *s == '/' || *s == '\\\\' ) {\n\t\t\tif ( !lastCharWasSep ) {\n\t\t\t\t*s = PATH_SEP;\n\t\t\t\tlastCharWasSep = qtrue;\n\t\t\t} else {\n\t\t\t\tmemmove (s, s + 1, strlen (s));\n\t\t\t}\n\t\t} else {\n\t\t\tlastCharWasSep = qfalse;\n\t\t}\n\t}\n}\n\n/*\n===================\nFS_BuildOSPath\n\nQpath may have either forward or backwards slashes\n===================\n*/\nchar *FS_BuildOSPath( const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\t// Fix for filenames that are given to FS with a leading \"/\" (/botfiles/Foo)\n\tif (qpath[0] == '\\\\' || qpath[0] == '/')\n\t\tqpath++;\n\n\tCom_sprintf( temp, sizeof(temp), \"/base/%s\", qpath ); // FIXME SP used fs_gamedir here as well (not sure if this func is even used)\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", fs_basepath->string, temp );\n\n\treturn ospath[toggle];\n}\n\nchar *FS_BuildOSPath( const char *base, const char *game, const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\tif( !game || !game[0] ) {\n\t\tgame = fs_gamedir;\n\t}\n\n\tCom_sprintf( temp, sizeof(temp), \"/%s/%s\", game, qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", base, temp );\n\n\treturn ospath[toggle];\n}\n\n/*\n============\nFS_CreatePath\n\nCreates any directories needed to store the given filename\n============\n*/\nqboolean FS_CreatePath (char *OSPath) {\n\tchar\t*ofs;\n\tchar\tpath[MAX_OSPATH];\n\n\t// make absolutely sure that it can't back up the path\n\t// FIXME: is c: allowed???\n\tif ( strstr( OSPath, \"..\" ) || strstr( OSPath, \"::\" ) ) {\n\t\tCom_Printf( \"WARNING: refusing to create relative path \\\"%s\\\"\\n\", OSPath );\n\t\treturn qtrue;\n\t}\n\n\tQ_strncpyz( path, OSPath, sizeof( path ) );\n\tFS_ReplaceSeparators( path );\n\n\t// Skip creation of the root directory as it will always be there\n\tofs = strchr( path, PATH_SEP );\n\tif ( ofs ) {\n\t\tofs++;\n\t}\n\n\tfor (; ofs != NULL && *ofs ; ofs++) {\n\t\tif (*ofs == PATH_SEP) {\n\t\t\t// create the directory\n\t\t\t*ofs = 0;\n\t\t\tif (!Sys_Mkdir (path)) {\n\t\t\t\tCom_Error( ERR_FATAL, \"FS_CreatePath: failed to create path \\\"%s\\\"\",\n\t\t\t\t\tpath );\n\t\t\t}\n\t\t\t*ofs = PATH_SEP;\n\t\t}\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_CheckFilenameIsMutable\n\nERR_FATAL if trying to maniuplate a file with the platform library, or pk3 extension\n=================\n*/\nstatic void FS_CheckFilenameIsMutable( const char *filename, const char *function )\n{\n\t// Check if the filename ends with the library, or pk3 extension\n\tif( COM_CompareExtension( filename, DLL_EXT )\n\t\t|| COM_CompareExtension( filename, \".pk3\" ) )\n\t{\n\t\tCom_Error( ERR_FATAL, \"%s: Not allowed to manipulate '%s' due \"\n\t\t\t\"to %s extension\", function, filename, COM_GetExtension( filename ) );\n\t}\n}\n\n/*\n=================\nFS_CopyFile\n\nCopy a fully specified file from one place to another\n=================\n*/\n// added extra param so behind-the-scenes copying in savegames doesn't clutter up the screen -slc\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath, qboolean qbSilent = qfalse );\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath, qboolean qbSilent ) {\n\tFILE\t*f;\n\tint\t\tlen;\n\tbyte\t*buf;\n\n\tFS_CheckFilenameIsMutable( fromOSPath, __func__ );\n\n\tif ( !qbSilent )\n\t\tCom_Printf( \"copy %s to %s\\n\", fromOSPath, toOSPath );\n\n\tf = fopen( fromOSPath, \"rb\" );\n\tif ( !f ) {\n\t\treturn;\n\t}\n\tfseek (f, 0, SEEK_END);\n\tlen = ftell (f);\n\tfseek (f, 0, SEEK_SET);\n\n\tif ( len == EOF )\n\t{\n\t\tfclose( f );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Bad file length in FS_CopyFile()\" );\n\t}\n\n\t// we are using direct malloc instead of Z_Malloc here, so it\n\t// probably won't work on a mac... Its only for developers anyway...\n\tbuf = (unsigned char *)malloc( len );\n\tif (fread( buf, 1, len, f ) != (size_t)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\n\tif( FS_CreatePath( toOSPath ) ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\n\tf = fopen( toOSPath, \"wb\" );\n\tif ( !f ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\tif (fwrite( buf, 1, len, f ) != (size_t)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Short write in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\tfree( buf );\n}\n\n/*\n===========\nFS_Remove\n\n===========\n*/\nvoid FS_Remove( const char *osPath ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tremove( osPath );\n}\n\n/*\n===========\nFS_HomeRemove\n\n===========\n*/\nvoid FS_HomeRemove( const char *homePath ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tremove( FS_BuildOSPath( fs_homepath->string,\n\t\t\tfs_gamedir, homePath ) );\n}\n\n// The following functions with \"UserGen\" in them were added for savegame handling,\n//\tsince outside functions aren't supposed to know about full paths/dirs\n\n// \"filename\" is local to the current gamedir (eg \"saves/blah.sav\")\n//\nvoid FS_DeleteUserGenFile( const char *filename ) {\n\tFS_HomeRemove( filename );\n}\n\n// filenames are local (eg \"saves/blah.sav\")\n//\n// return: qtrue = OK\n//\nqboolean FS_MoveUserGenFile( const char *filename_src, const char *filename_dst ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename_src );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename_dst );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_MoveUserGenFile: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tremove( to_ospath );\n\treturn (qboolean)!rename( from_ospath, to_ospath );\n}\n\n/*\n===========\nFS_Rmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_Rmdir( const char *osPath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tif ( recursive ) {\n\t\tint numfiles;\n\t\tint i;\n\t\tchar **filesToRemove = Sys_ListFiles( osPath, \"\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tchar fileOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( fileOsPath, sizeof( fileOsPath ), \"%s/%s\", osPath, filesToRemove[i] );\n\t\t\tFS_Remove( fileOsPath );\n\t\t}\n\t\tFS_FreeFileList( filesToRemove );\n\n\t\tchar **directoriesToRemove = Sys_ListFiles( osPath, \"/\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tif ( !Q_stricmp( directoriesToRemove[i], \".\" ) || !Q_stricmp( directoriesToRemove[i], \"..\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar directoryOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( directoryOsPath, sizeof( directoryOsPath ), \"%s/%s\", osPath, directoriesToRemove[i] );\n\t\t\tFS_Rmdir( directoryOsPath, qtrue );\n\t\t}\n\t\tFS_FreeFileList( directoriesToRemove );\n\t}\n\n\trmdir( osPath );\n}\n\n/*\n===========\nFS_HomeRmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_HomeRmdir( const char *homePath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tFS_Rmdir( FS_BuildOSPath( fs_homepath->string,\n\t\t\t\t\tfs_gamedir, homePath ), recursive );\n}\n\n/*\n================\nFS_FileInPathExists\n\nTests if path and file exists\n================\n*/\nqboolean FS_FileInPathExists(const char *testpath)\n{\n\tFILE *filep;\n\n\tfilep = fopen(testpath, \"rb\");\n\n\tif(filep)\n\t{\n\t\tfclose(filep);\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_FileExists\n\nTests if the file exists in the current gamedir, this DOES NOT\nsearch the paths.  This is to determine if opening a file to write\n(which always goes into the current gamedir) will cause any overwrites.\nNOTE TTimo: this goes with FS_FOpenFileWrite for opening the file afterwards\n================\n*/\nqboolean FS_FileExists( const char *file )\n{\n\treturn FS_FileInPathExists(FS_BuildOSPath(fs_homepath->string, fs_gamedir, file));\n}\n\n/*\n================\nFS_SV_FileExists\n\nTests if the file exists\n================\n*/\nqboolean FS_SV_FileExists( const char *file )\n{\n\tchar *testpath;\n\n\ttestpath = FS_BuildOSPath( fs_homepath->string, file, \"\");\n\ttestpath[strlen(testpath)-1] = '\\0';\n\n\treturn FS_FileInPathExists(testpath);\n}\n\n/*\n===========\nFS_SV_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_SV_FOpenFileWrite( const char *filename ) {\n\tchar *ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tCom_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_SV_FOpenFileRead\nsearch for a file somewhere below the home path, base path or cd path\nwe search in that order, matching FS_SV_FOpenFileRead order\n===========\n*/\nint FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp ) {\n\tchar *ospath;\n\tfileHandle_t\tf = 0;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\t// search homepath\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\t// remove trailing slash\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_homepath): %s\\n\", ospath );\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// NOTE TTimo on non *nix systems, fs_homepath == fs_basepath, might want to avoid\n\t\tif (Q_stricmp(fs_homepath->string,fs_basepath->string))\n\t\t{\n\t\t\t// search basepath\n\t\t\tospath = FS_BuildOSPath( fs_basepath->string, filename, \"\" );\n\t\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\t\tif ( fs_debug->integer )\n\t\t\t{\n\t\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_basepath): %s\\n\", ospath );\n\t\t\t}\n\n\t\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\t\tfsh[f].handleSync = qfalse;\n\t\t}\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// search cd path\n\t\tospath = FS_BuildOSPath( fs_cdpath->string, filename, \"\" );\n\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\tif (fs_debug->integer)\n\t\t{\n\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_cdpath) : %s\\n\", ospath );\n\t\t}\n\n\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\tfsh[f].handleSync = qfalse;\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\t*fp = f;\n\tif (f) {\n\t\treturn FS_filelength(f);\n\t}\n\treturn 0;\n}\n\n/*\n===========\nFS_SV_Rename\n\n===========\n*/\nvoid FS_SV_Rename( const char *from, const char *to, qboolean safe ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, from, \"\" );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, to, \"\" );\n\tfrom_ospath[strlen(from_ospath)-1] = '\\0';\n\tto_ospath[strlen(to_ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\t}\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_Rename\n\n===========\n*/\nvoid FS_Rename( const char *from, const char *to ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_FCloseFile\n\nClose a file.\n\nThere are three cases handled:\n\n  * normal file: closed with fclose.\n\n  * file in pak3 archive: subfile is closed with unzCloseCurrentFile, but the\n    minizip handle to the pak3 remains open.\n\n  * file in pak3 archive, opened with \"unique\" flag: This file did not use\n    the system minizip handle to the pak3 file, but its own dedicated one.\n    The dedicated handle is closed with unzClose.\n\n===========\n*/\nvoid FS_FCloseFile( fileHandle_t f ) {\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\tunzCloseCurrentFile( fsh[f].handleFiles.file.z );\n\t\tif ( fsh[f].handleFiles.unique ) {\n\t\t\tunzClose( fsh[f].handleFiles.file.z );\n\t\t}\n\t\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n\t\treturn;\n\t}\n\n\t// we didn't find it as a pak, so close it as a unique file\n\tif (fsh[f].handleFiles.file.o) {\n\t\tfclose (fsh[f].handleFiles.file.o);\n\t}\n\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n}\n\n/*\n===========\nFS_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_FOpenFileWrite( const char *filename, qboolean safe ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\t}\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\t// enabling the following line causes a recursive function call loop\n\t// when running with +set logfile 1 +set developer 1\n\t//Com_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FOpenFileAppend\n\n===========\n*/\nfileHandle_t FS_FOpenFileAppend( const char *filename ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileAppend: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"ab\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FilenameCompare\n\nIgnore case and separator char distinctions\n===========\n*/\nqboolean FS_FilenameCompare( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 != c2) {\n\t\t\treturn qtrue;\t\t// strings not equal\n\t\t}\n\t} while (c1);\n\n\treturn qfalse;\t\t// strings are equal\n}\n\n/*\n===========\nFS_IsExt\n\nReturn qtrue if ext matches file extension filename\n===========\n*/\n\nqboolean FS_IsExt(const char *filename, const char *ext, int namelen)\n{\n\tint extlen;\n\n\textlen = strlen(ext);\n\n\tif(extlen > namelen)\n\t\treturn qfalse;\n\n\tfilename += namelen - extlen;\n\n\treturn (qboolean)!Q_stricmp(filename, ext);\n}\n\n/*\n===========\nFS_IsDemoExt\n\nReturn qtrue if filename has a demo extension\n===========\n*/\n\n#define DEMO_EXTENSION \"dm_\"\nqboolean FS_IsDemoExt(const char *filename, int namelen)\n{\n\tconst char *ext_test;\n\n\text_test = strrchr(filename, '.');\n\tif(ext_test && !Q_stricmpn(ext_test + 1, DEMO_EXTENSION, ARRAY_LEN(DEMO_EXTENSION) - 1))\n\t{\n\t\tint protocol = atoi(ext_test + ARRAY_LEN(DEMO_EXTENSION));\n\n\t\tif(protocol == PROTOCOL_VERSION)\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n#ifdef _WIN32\n\nbool Sys_GetFileTime(LPCSTR psFileName, FILETIME &ft)\n{\n\tbool bSuccess = false;\n\tHANDLE hFile = INVALID_HANDLE_VALUE;\n\n\thFile = CreateFile(\tpsFileName,\t// LPCTSTR lpFileName,          // pointer to name of the file\n\t\t\t\t\t\tGENERIC_READ,\t\t\t// DWORD dwDesiredAccess,       // access (read-write) mode\n\t\t\t\t\t\tFILE_SHARE_READ,\t\t// DWORD dwShareMode,           // share mode\n\t\t\t\t\t\tNULL,\t\t\t\t\t// LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t// pointer to security attributes\n\t\t\t\t\t\tOPEN_EXISTING,\t\t\t// DWORD dwCreationDisposition,  // how to create\n\t\t\t\t\t\tFILE_FLAG_NO_BUFFERING,// DWORD dwFlagsAndAttributes,   // file attributes\n\t\t\t\t\t\tNULL\t\t\t\t\t// HANDLE hTemplateFile          // handle to file with attributes to\n\t\t\t\t\t\t);\n\n\tif (hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (GetFileTime(hFile,\t// handle to file\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpCreationTime\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpLastAccessTime\n\t\t\t\t\t\t&ft\t\t// LPFILETIME lpLastWriteTime\n\t\t\t\t\t\t)\n\t\t\t)\n\t\t{\n\t\t\tbSuccess = true;\n\t\t}\n\n\t\tCloseHandle(hFile);\n\t}\n\n\treturn bSuccess;\n}\n\nbool Sys_FileOutOfDate( LPCSTR psFinalFileName /* dest */, LPCSTR psDataFileName /* src */ )\n{\n\tFILETIME ftFinalFile, ftDataFile;\n\n\tif (Sys_GetFileTime(psFinalFileName, ftFinalFile) && Sys_GetFileTime(psDataFileName, ftDataFile))\n\t{\n\t\t// timer res only accurate to within 2 seconds on FAT, so can't do exact compare...\n\t\t//\n\t\t//LONG l = CompareFileTime( &ftFinalFile, &ftDataFile );\n\t\tif (  (abs((double)(ftFinalFile.dwLowDateTime - ftDataFile.dwLowDateTime)) <= 20000000 ) &&\n\t\t\t\t  ftFinalFile.dwHighDateTime == ftDataFile.dwHighDateTime\n\t\t\t)\n\t\t{\n\t\t\treturn false;\t// file not out of date, ie use it.\n\t\t}\n\t\treturn true;\t// flag return code to copy over a replacement version of this file\n\t}\n\n\n\t// extra error check, report as suspicious if you find a file locally but not out on the net.,.\n\t//\n\tif (com_developer->integer)\n\t{\n\t\tif (!Sys_GetFileTime(psDataFileName, ftDataFile))\n\t\t{\n\t\t\tCom_Printf( \"Sys_FileOutOfDate: reading %s but it's not on the net!\\n\", psFinalFileName);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n#endif // _WIN32\n\nbool FS_FileCacheable(const char* const filename)\n{\n\textern\tcvar_t\t*com_buildScript;\n\tif (com_buildScript && com_buildScript->integer)\n\t{\n\t\treturn true;\n\t}\n\treturn( strchr(filename, '/') != 0 );\n}\n\n/*\n===========\nFS_FOpenFileRead\n\nFinds the file in the search path.\nReturns filesize and an open FILE pointer.\nUsed for streaming data out of either a\nseparate file or a ZIP file.\n===========\n*/\nextern qboolean\t\tcom_fullyInitialized;\n\nlong FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE ) {\n\tsearchpath_t\t*search;\n\tchar\t\t\t*netpath;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tdirectory_t\t\t*dir;\n\tlong\t\t\thash;\n\t//unz_s\t\t\t*zfi;\n\t//void\t\t\t*temp;\n\n\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( file == NULL ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'file' parameter passed\\n\" );\n\t}\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t// make sure the q3key file is only readable by the quake3.exe at initialization\n\t// any other time the key should only be accessed in memory using the provided functions\n\tif( com_fullyInitialized && strstr( filename, \"q3key\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\t*file = FS_HandleForFile();\n\tfsh[*file].handleFiles.unique = uniqueFILE;\n\n\t// this new bool is in for an optimisation, if you (eg) opened a BSP file under fs_copyfiles==2,\n\t//\tthen it triggered a copy operation to update your local HD version, then this will re-open the\n\t//\tfile handle on your local version, not the net build. This uses a bit more CPU to re-do the loop\n\t//\tlogic, but should read faster than accessing the net version a second time.\n\t//\n\tqboolean bFasterToReOpenUsingNewLocalFile = qfalse;\n\n\tdo\n\t{\n\t\tbFasterToReOpenUsingNewLocalFile = qfalse;\n\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t//\n\t\t\tif ( search->pack ) {\n\t\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t\t}\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpak = search->pack;\n\t\t\t\tpakFile = pak->hashTable[hash];\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\n\t\t\t\t\t\tif ( uniqueFILE ) {\n\t\t\t\t\t\t\t// open a new file on the pakfile\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = unzOpen (pak->pakFilename);\n\t\t\t\t\t\t\tif (fsh[*file].handleFiles.file.z == NULL) {\n\t\t\t\t\t\t\t\tCom_Error (ERR_FATAL, \"Couldn't open %s\", pak->pakFilename);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = pak->handle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\t\t\tfsh[*file].zipFile = qtrue;\n\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);\n\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile(fsh[*file].handleFiles.file.z);\n\n#if 0\n\t\t\t\t\t\tzfi = (unz_s *)fsh[*file].handleFiles.file.z;\n\t\t\t\t\t\t// in case the file was new\n\t\t\t\t\t\ttemp = zfi->filestream;\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(pak->handle, pakFile->pos);\n\t\t\t\t\t\t// copy the file info into the unzip structure\n\t\t\t\t\t\tCom_Memcpy( zfi, pak->handle, sizeof(unz_s) );\n\t\t\t\t\t\t// we copy this back into the structure\n\t\t\t\t\t\tzfi->filestream = temp;\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile( fsh[*file].handleFiles.file.z );\n#endif\n\t\t\t\t\t\tfsh[*file].zipFilePos = pakFile->pos;\n\t\t\t\t\t\tfsh[*file].zipFileLen = pakFile->len;\n\n\t\t\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s')\\n\",\n\t\t\t\t\t\t\t\tfilename, pak->pakFilename );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn pakFile->len;\n\t\t\t\t\t}\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while(pakFile != NULL);\n\t\t\t} else if ( search->dir ) {\n\t\t\t\t// check a file in the directory tree\n\n\t\t\t\tdir = search->dir;\n\n\t\t\t\tnetpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\t\tfsh[*file].handleFiles.file.o = fopen (netpath, \"rb\");\n\t\t\t\tif ( !fsh[*file].handleFiles.file.o ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if running with fs_copyfiles 2, and search path == local, then we need to fail to open\n\t\t\t\t//\tif the time/date stamp != the network version (so it'll loop round again and use the network path,\n\t\t\t\t//\twhich comes later in the search order)\n\t\t\t\t//\n\t\t\t\tif ( fs_copyfiles->integer == 2 && fs_cdpath->string[0] && !Q_stricmp( dir->path, fs_basepath->string )\n\t\t\t\t\t&& FS_FileCacheable(filename) )\n\t\t\t\t{\n\t\t\t\t\tif ( Sys_FileOutOfDate( netpath, FS_BuildOSPath( fs_cdpath->string, dir->gamedir, filename ) ))\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\tfsh[*file].handleFiles.file.o = 0;\n\t\t\t\t\t\tcontinue;\t//carry on to find the cdpath version.\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\tfsh[*file].zipFile = qfalse;\n\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s%c%s')\\n\", filename,\n\t\t\t\t\t\tdir->path, PATH_SEP, dir->gamedir );\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if we are getting it from the cdpath, optionally copy it\n\t\t\t\t//  to the basepath\n\t\t\t\tif ( fs_copyfiles->integer && !Q_stricmp( dir->path, fs_cdpath->string ) ) {\n\t\t\t\t\tchar\t*copypath;\n\n\t\t\t\t\tcopypath = FS_BuildOSPath( fs_basepath->string, dir->gamedir, filename );\n\t\t\t\t\tswitch ( fs_copyfiles->integer )\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFS_CopyFile( netpath, copypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (FS_FileCacheable(filename) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// maybe change this to Com_DPrintf?   On the other hand...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tCom_Printf( \"fs_copyfiles(2), Copying: %s to %s\\n\", netpath, copypath );\n\n\t\t\t\t\t\t\t\tFS_CreatePath( copypath );\n\n\t\t\t\t\t\t\t\tbool bOk = true;\n\t\t\t\t\t\t\t\tif (!CopyFile( netpath, copypath, FALSE ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDWORD dwAttrs = GetFileAttributes(copypath);\n\t\t\t\t\t\t\t\t\tSetFileAttributes(copypath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);\n\t\t\t\t\t\t\t\t\tbOk = !!CopyFile( netpath, copypath, FALSE );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (bOk)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// clear this handle and setup for re-opening of the new local copy...\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tbFasterToReOpenUsingNewLocalFile = qtrue;\n\t\t\t\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\t\t\t\tfsh[*file].handleFiles.file.o = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (bFasterToReOpenUsingNewLocalFile)\n\t\t\t\t{\n\t\t\t\t\tbreak;\t// and re-read the local copy, not the net version\n\t\t\t\t}\n\n\t\t\t\treturn FS_fplength(fsh[*file].handleFiles.file.o);\n\t\t\t}\n\t\t}\n\t}\n\twhile ( bFasterToReOpenUsingNewLocalFile );\n\n\tCom_DPrintf (\"Can't find %s\\n\", filename);\n\t*file = 0;\n\treturn -1;\n}\n\n/*\n=================\nFS_Read\n\nProperly handles partial reads\n=================\n*/\nint FS_Read( void *buffer, int len, fileHandle_t f ) {\n\tint\t\tblock, remaining;\n\tint\t\tread;\n\tbyte\t*buf;\n\tint\t\ttries;\n\n\tFS_AssertInitialised();\n\n\tif ( !f ) {\n\t\treturn 0;\n\t}\n\n\tbuf = (byte *)buffer;\n\tfs_readCount += len;\n\n\tif (fsh[f].zipFile == qfalse) {\n\t\tremaining = len;\n\t\ttries = 0;\n\t\twhile (remaining) {\n\t\t\tblock = remaining;\n\t\t\tread = fread (buf, 1, block, fsh[f].handleFiles.file.o);\n\t\t\tif (read == 0) {\n\t\t\t\t// we might have been trying to read from a CD, which\n\t\t\t\t// sometimes returns a 0 read on windows\n\t\t\t\tif (!tries) {\n\t\t\t\t\ttries = 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn len-remaining;\t//Com_Error (ERR_FATAL, \"FS_Read: 0 bytes read\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tCom_Error (ERR_FATAL, \"FS_Read: -1 bytes read\");\n\t\t\t}\n\n\t\t\tremaining -= read;\n\t\t\tbuf += read;\n\t\t}\n\t\treturn len;\n\t} else {\n\t\treturn unzReadCurrentFile(fsh[f].handleFiles.file.z, buffer, len);\n\t}\n}\n\n/*\n=================\nFS_Write\n\nProperly handles partial writes\n=================\n*/\nint FS_Write( const void *buffer, int len, fileHandle_t h ) {\n\tint\t\tblock, remaining;\n\tint\t\twritten;\n\tbyte\t*buf;\n\tint\t\ttries;\n\tFILE\t*f;\n\n\tFS_AssertInitialised();\n\n\tif ( !h ) {\n\t\treturn 0;\n\t}\n\n\tf = FS_FileForHandle(h);\n\tbuf = (byte *)buffer;\n\n\tremaining = len;\n\ttries = 0;\n\twhile (remaining) {\n\t\tblock = remaining;\n\t\twritten = fwrite (buf, 1, block, f);\n\t\tif (written == 0) {\n\t\t\tif (!tries) {\n\t\t\t\ttries = 1;\n\t\t\t} else {\n\t\t\t\tCom_Printf( \"FS_Write: 0 bytes written\\n\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (written == -1) {\n\t\t\tCom_Printf( \"FS_Write: -1 bytes written\\n\" );\n\t\t\treturn 0;\n\t\t}\n\n\t\tremaining -= written;\n\t\tbuf += written;\n\t}\n\tif ( fsh[h].handleSync ) {\n\t\tfflush( f );\n\t}\n\treturn len;\n}\n\n#define\tMAXPRINTMSG\t4096\nvoid QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf (msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tFS_Write(msg, strlen(msg), h);\n}\n\n#define PK3_SEEK_BUFFER_SIZE 65536\n/*\n=================\nFS_Seek\n\n=================\n*/\nint FS_Seek( fileHandle_t f, long offset, int origin ) {\n\tint\t\t_origin;\n\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\t//FIXME: this is really, really crappy\n\t\t//(but better than what was here before)\n\t\tbyte\tbuffer[PK3_SEEK_BUFFER_SIZE];\n\t\tint\t\tremainder;\n\t\tint\t\tcurrentPosition = FS_FTell( f );\n\n\t\t// change negative offsets into FS_SEEK_SET\n\t\tif ( offset < 0 ) {\n\t\t\tswitch( origin ) {\n\t\t\t\tcase FS_SEEK_END:\n\t\t\t\t\tremainder = fsh[f].zipFileLen + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_CUR:\n\t\t\t\t\tremainder = currentPosition + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_SET:\n\t\t\t\tdefault:\n\t\t\t\t\tremainder = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( remainder < 0 ) {\n\t\t\t\tremainder = 0;\n\t\t\t}\n\n\t\t\torigin = FS_SEEK_SET;\n\t\t} else {\n\t\t\tif ( origin == FS_SEEK_END ) {\n\t\t\t\tremainder = fsh[f].zipFileLen - currentPosition + offset;\n\t\t\t} else {\n\t\t\t\tremainder = offset;\n\t\t\t}\n\t\t}\n\n\t\tswitch( origin ) {\n\t\t\tcase FS_SEEK_SET:\n\t\t\t\tif ( remainder == currentPosition ) {\n\t\t\t\t\treturn offset;\n\t\t\t\t}\n\t\t\t\tunzSetOffset(fsh[f].handleFiles.file.z, fsh[f].zipFilePos);\n\t\t\t\tunzOpenCurrentFile(fsh[f].handleFiles.file.z);\n\t\t\t\t//fallthrough\n\n\t\t\tcase FS_SEEK_END:\n\t\t\tcase FS_SEEK_CUR:\n\t\t\t\twhile( remainder > PK3_SEEK_BUFFER_SIZE ) {\n\t\t\t\t\tFS_Read( buffer, PK3_SEEK_BUFFER_SIZE, f );\n\t\t\t\t\tremainder -= PK3_SEEK_BUFFER_SIZE;\n\t\t\t\t}\n\t\t\t\tFS_Read( buffer, remainder, f );\n\t\t\t\treturn offset;\n\n\t\t\tdefault:\n\t\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\" );\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tFILE *file;\n\t\tfile = FS_FileForHandle(f);\n\t\tswitch( origin ) {\n\t\tcase FS_SEEK_CUR:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tbreak;\n\t\tcase FS_SEEK_END:\n\t\t\t_origin = SEEK_END;\n\t\t\tbreak;\n\t\tcase FS_SEEK_SET:\n\t\t\t_origin = SEEK_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\\n\" );\n\t\t\tbreak;\n\t\t}\n\n\t\treturn fseek( file, offset, _origin );\n\t}\n}\n\n/*\n======================================================================================\n\nCONVENIENCE FUNCTIONS FOR ENTIRE FILES\n\n======================================================================================\n*/\n\nint\tFS_FileIsInPAK(const char *filename ) {\n\tsearchpath_t\t*search;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tlong\t\t\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t//\n\t\tif (search->pack) {\n\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t}\n\t\t// is the element a pak file?\n\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tpakFile = pak->hashTable[hash];\n\t\t\tdo {\n\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpakFile = pakFile->next;\n\t\t\t} while(pakFile != NULL);\n\t\t}\n\t}\n\treturn -1;\n}\n\n/*\n============\nFS_ReadFile\n\nFilename are relative to the quake search path\na null buffer will just return the file length without loading\n============\n*/\nlong FS_ReadFile( const char *qpath, void **buffer ) {\n\tfileHandle_t\th;\n\tbyte*\t\t\tbuf;\n\tlong\t\t\t\tlen;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !qpath[0] ) {\n\t\tCom_Error( ERR_FATAL, \"FS_ReadFile with empty name\\n\" );\n\t}\n\n\t// stop sounds from repeating\n\tS_ClearSoundBuffer();\n\n\tbuf = NULL;\t// quiet compiler warning\n\n\t// look for it in the filesystem or pack files\n\tlen = FS_FOpenFileRead( qpath, &h, qfalse );\n\tif ( h == 0 ) {\n\t\tif ( buffer ) {\n\t\t\t*buffer = NULL;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( !buffer ) {\n\t\tFS_FCloseFile( h);\n\t\treturn len;\n\t}\n\n\tfs_loadCount++;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\tbuf[len]='\\0';\t// because we're not calling Z_Malloc with optional trailing 'bZeroIt' bool\n\t*buffer = buf;\n\n\tZ_Label(buf, qpath);\n\n\t// PRECACE CHECKER!\n#ifndef FINAL_BUILD\n\tif (com_sv_running && com_sv_running->integer && cls.state >= CA_ACTIVE) {\t//com_cl_running\n\t\tif (strncmp(qpath,\"menu/\",5) ) {\n\t\t\tCom_DPrintf( S_COLOR_MAGENTA\"FS_ReadFile: %s NOT PRECACHED!\\n\", qpath );\n\t\t}\n\t}\n#endif\n\n\tFS_Read (buf, len, h);\n\n\t// guarantee that it will have a trailing 0 for string operations\n\tbuf[len] = 0;\n\tFS_FCloseFile( h );\n\treturn len;\n}\n\n/*\n=============\nFS_FreeFile\n=============\n*/\nvoid FS_FreeFile( void *buffer ) {\n\tFS_AssertInitialised();\n\tif ( !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FreeFile( NULL )\" );\n\t}\n\n\tZ_Free( buffer );\n}\n\n/*\n============\nFS_WriteFile\n\nFilename are reletive to the quake search path\n============\n*/\nvoid FS_WriteFile( const char *qpath, const void *buffer, int size ) {\n\tfileHandle_t f;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_WriteFile: NULL parameter\" );\n\t}\n\n\tf = FS_FOpenFileWrite( qpath );\n\tif ( !f ) {\n\t\tCom_Printf( \"Failed to open %s\\n\", qpath );\n\t\treturn;\n\t}\n\n\tFS_Write( buffer, size, f );\n\n\tFS_FCloseFile( f );\n}\n\n/*\n==========================================================================\n\nZIP FILE LOADING\n\n==========================================================================\n*/\n\n/*\n=================\nFS_LoadZipFile\n\nCreates a new pak_t in the search chain for the contents\nof a zip file.\n=================\n*/\nstatic pack_t *FS_LoadZipFile( const char *zipfile, const char *basename )\n{\n\tfileInPack_t\t*buildBuffer;\n\tpack_t\t\t\t*pack;\n\tunzFile\t\t\tuf;\n\tint\t\t\t\terr;\n\tunz_global_info gi;\n\tchar\t\t\tfilename_inzip[MAX_ZPATH];\n\tunz_file_info\tfile_info;\n\tint\t\t\t\tlen;\n\tsize_t\t\t\ti;\n\tlong\t\t\thash;\n\tint\t\t\t\tfs_numHeaderLongs;\n\tint\t\t\t\t*fs_headerLongs;\n\tchar\t\t\t*namePtr;\n\n\tfs_numHeaderLongs = 0;\n\n\tuf = unzOpen(zipfile);\n\terr = unzGetGlobalInfo (uf,&gi);\n\n\tif (err != UNZ_OK)\n\t\treturn NULL;\n\n\tlen = 0;\n\tunzGoToFirstFile(uf);\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tlen += strlen(filename_inzip) + 1;\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tbuildBuffer = (struct fileInPack_s *)Z_Malloc( (gi.number_entry * sizeof( fileInPack_t )) + len, TAG_FILESYS, qtrue );\n\tnamePtr = ((char *) buildBuffer) + gi.number_entry * sizeof( fileInPack_t );\n\tfs_headerLongs = (int *)Z_Malloc( gi.number_entry * sizeof(int), TAG_FILESYS, qtrue );\n\n\t// get the hash table size from the number of files in the zip\n\t// because lots of custom pk3 files have less than 32 or 64 files\n\tfor (i = 1; i <= MAX_FILEHASH_SIZE; i <<= 1) {\n\t\tif (i > gi.number_entry) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpack = (pack_t *)Z_Malloc( sizeof( pack_t ) + i * sizeof(fileInPack_t *), TAG_FILESYS, qtrue );\n\tpack->hashSize = i;\n\tpack->hashTable = (fileInPack_t **) (((char *) pack) + sizeof( pack_t ));\n\tfor(int j = 0; j < pack->hashSize; j++) {\n\t\tpack->hashTable[j] = NULL;\n\t}\n\n\tQ_strncpyz( pack->pakFilename, zipfile, sizeof( pack->pakFilename ) );\n\tQ_strncpyz( pack->pakBasename, basename, sizeof( pack->pakBasename ) );\n\n\t// strip .pk3 if needed\n\tif ( strlen( pack->pakBasename ) > 4 && !Q_stricmp( pack->pakBasename + strlen( pack->pakBasename ) - 4, \".pk3\" ) ) {\n\t\tpack->pakBasename[strlen( pack->pakBasename ) - 4] = 0;\n\t}\n\n\tpack->handle = uf;\n\tpack->numfiles = gi.number_entry;\n\tunzGoToFirstFile(uf);\n\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tif (file_info.uncompressed_size > 0) {\n\t\t\tfs_headerLongs[fs_numHeaderLongs++] = LittleLong(file_info.crc);\n\t\t}\n\t\tQ_strlwr( filename_inzip );\n\t\thash = FS_HashFileName(filename_inzip, pack->hashSize);\n\t\tbuildBuffer[i].name = namePtr;\n\t\tstrcpy( buildBuffer[i].name, filename_inzip );\n\t\tnamePtr += strlen(filename_inzip) + 1;\n\t\t// store the file position in the zip\n\t\tbuildBuffer[i].pos = unzGetOffset(uf);\n\t\tbuildBuffer[i].len = file_info.uncompressed_size;\n\t\tbuildBuffer[i].next = pack->hashTable[hash];\n\t\tpack->hashTable[hash] = &buildBuffer[i];\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tpack->checksum = Com_BlockChecksum( fs_headerLongs, sizeof(*fs_headerLongs) * fs_numHeaderLongs );\n\tpack->checksum = LittleLong( pack->checksum );\n\n\tZ_Free(fs_headerLongs);\n\n\tpack->buildBuffer = buildBuffer;\n\treturn pack;\n}\n\n/*\n=================\nFS_FreePak\n\nFrees a pak structure and releases all associated resources\n=================\n*/\n\nvoid FS_FreePak(pack_t *thepak)\n{\n\tunzClose(thepak->handle);\n\tZ_Free(thepak->buildBuffer);\n\tZ_Free(thepak);\n}\n\n/*\n=================================================================================\n\nDIRECTORY SCANNING FUNCTIONS\n\n=================================================================================\n*/\n\n#define\tMAX_FOUND_FILES\t0x1000\n\nstatic int FS_ReturnPath( const char *zname, char *zpath, int *depth ) {\n\tint len, at, newdep;\n\n\tnewdep = 0;\n\tzpath[0] = 0;\n\tlen = 0;\n\tat = 0;\n\n\twhile(zname[at] != 0)\n\t{\n\t\tif (zname[at]=='/' || zname[at]=='\\\\') {\n\t\t\tlen = at;\n\t\t\tnewdep++;\n\t\t}\n\t\tat++;\n\t}\n\tstrcpy(zpath, zname);\n\tzpath[len] = 0;\n\t*depth = newdep;\n\n\treturn len;\n}\n\n/*\n==================\nFS_AddFileToList\n==================\n*/\nstatic int FS_AddFileToList( char *name, char *list[MAX_FOUND_FILES], int nfiles ) {\n\tint\t\ti;\n\n\tif ( nfiles == MAX_FOUND_FILES - 1 ) {\n\t\treturn nfiles;\n\t}\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tif ( !Q_stricmp( name, list[i] ) ) {\n\t\t\treturn nfiles;\t\t// allready in list\n\t\t}\n\t}\n\tlist[nfiles] = CopyString( name );\n\tnfiles++;\n\n\treturn nfiles;\n}\n\n/*\n===============\nFS_ListFilteredFiles\n\nReturns a uniqued list of files that match the given criteria\nfrom all search paths\n===============\n*/\nchar **FS_ListFilteredFiles( const char *path, const char *extension, char *filter, int *numfiles ) {\n\tint\t\t\t\tnfiles;\n\tchar\t\t\t**listCopy;\n\tchar\t\t\t*list[MAX_FOUND_FILES];\n\tsearchpath_t\t*search;\n\tint\t\t\t\ti;\n\tint\t\t\t\tpathLength;\n\tint\t\t\t\textensionLength;\n\tint\t\t\t\tlength, pathDepth, temp;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*buildBuffer;\n\tchar\t\t\tzpath[MAX_ZPATH];\n\n\tFS_AssertInitialised();\n\n\tif ( !path ) {\n\t\t*numfiles = 0;\n\t\treturn NULL;\n\t}\n\tif ( !extension ) {\n\t\textension = \"\";\n\t}\n\n\tpathLength = strlen( path );\n\tif ( path[pathLength-1] == '\\\\' || path[pathLength-1] == '/' ) {\n\t\tpathLength--;\n\t}\n\textensionLength = strlen( extension );\n\tnfiles = 0;\n\tFS_ReturnPath(path, zpath, &pathDepth);\n\n\t//\n\t// search through the path, one element at a time, adding to list\n\t//\n\tfor (search = fs_searchpaths ; search ; search = search->next) {\n\t\t// is the element a pak file?\n\t\tif (search->pack) {\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tbuildBuffer = pak->buildBuffer;\n\t\t\tfor (i = 0; i < pak->numfiles; i++) {\n\t\t\t\tchar\t*name;\n\t\t\t\tint\t\tzpathLen, depth;\n\n\t\t\t\t// check for directory match\n\t\t\t\tname = buildBuffer[i].name;\n\t\t\t\t//\n\t\t\t\tif (filter) {\n\t\t\t\t\t// case insensitive\n\t\t\t\t\tif (!Com_FilterPath( filter, name, qfalse ))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// unique the match\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tzpathLen = FS_ReturnPath(name, zpath, &depth);\n\n\t\t\t\t\tif ( (depth-pathDepth)>2 || pathLength > zpathLen || Q_stricmpn( name, path, pathLength ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for extension match\n\t\t\t\t\tlength = strlen( name );\n\t\t\t\t\tif ( length < extensionLength ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Q_stricmp( name + length - extensionLength, extension ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// unique the match\n\n\t\t\t\t\ttemp = pathLength;\n\t\t\t\t\tif (pathLength) {\n\t\t\t\t\t\ttemp++;\t\t// include the '/'\n\t\t\t\t\t}\n\t\t\t\t\tnfiles = FS_AddFileToList( name + temp, list, nfiles );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (search->dir) { // scan for files in the filesystem\n\t\t\tchar\t*netpath;\n\t\t\tint\t\tnumSysFiles;\n\t\t\tchar\t**sysFiles;\n\t\t\tchar\t*name;\n\n\t\t\tnetpath = FS_BuildOSPath( search->dir->path, search->dir->gamedir, path );\n\t\t\tsysFiles = Sys_ListFiles( netpath, extension, filter, &numSysFiles, qfalse );\n\t\t\tfor ( i = 0 ; i < numSysFiles ; i++ ) {\n\t\t\t\t// unique the match\n\t\t\t\tname = sysFiles[i];\n\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t}\n\t\t\tSys_FreeFileList( sysFiles );\n\t\t}\n\t}\n\n\t// return a copy of the list\n\t*numfiles = nfiles;\n\n\tif ( !nfiles ) {\n\t\treturn NULL;\n\t}\n\n\tlistCopy = (char **)Z_Malloc( ( nfiles + 1 ) * sizeof( *listCopy ), TAG_FILESYS, qfalse );\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tlistCopy[i] = list[i];\n\t}\n\tlistCopy[i] = NULL;\n\n\treturn listCopy;\n}\n\n/*\n=================\nFS_ListFiles\n=================\n*/\nchar **FS_ListFiles( const char *path, const char *extension, int *numfiles ) {\n\treturn FS_ListFilteredFiles( path, extension, NULL, numfiles );\n}\n\n/*\n=================\nFS_FreeFileList\n=================\n*/\nvoid FS_FreeFileList( char **fileList ) {\n\t//rwwRMG - changed to fileList to not conflict with list type\n\tint\t\ti;\n\n\tFS_AssertInitialised();\n\n\tif ( !fileList ) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; fileList[i] ; i++ ) {\n\t\tZ_Free( fileList[i] );\n\t}\n\n\tZ_Free( fileList );\n}\n\n\n/*\n================\nFS_GetFileList\n================\n*/\nint\tFS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {\n\tint\t\tnFiles, i, nTotal, nLen;\n\tchar **pFiles = NULL;\n\n\t*listbuf = 0;\n\tnFiles = 0;\n\tnTotal = 0;\n\n\tif (Q_stricmp(path, \"$modlist\") == 0) {\n\t\treturn FS_GetModList(listbuf, bufsize);\n\t}\n\n\tpFiles = FS_ListFiles(path, extension, &nFiles);\n\n\tfor (i =0; i < nFiles; i++) {\n\t\tnLen = strlen(pFiles[i]) + 1;\n\t\tif (nTotal + nLen + 1 < bufsize) {\n\t\t\tstrcpy(listbuf, pFiles[i]);\n\t\t\tlistbuf += nLen;\n\t\t\tnTotal += nLen;\n\t\t}\n\t\telse {\n\t\t\tnFiles = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFS_FreeFileList(pFiles);\n\n\treturn nFiles;\n}\n\n/*\n=======================\nSys_ConcatenateFileLists\n\nmkv: Naive implementation. Concatenates three lists into a\n     new list, and frees the old lists from the heap.\nbk001129 - from cvs1.17 (mkv)\n\nFIXME TTimo those two should move to common.c next to Sys_ListFiles\n=======================\n */\nstatic unsigned int Sys_CountFileList(char **fileList)\n{\n\tint i = 0;\n\n\tif (fileList)\n\t{\n\t\twhile (*fileList)\n\t\t{\n\t\t\tfileList++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic char** Sys_ConcatenateFileLists( char **list0, char **list1, char **list2 )\n{\n\tint totalLength = 0;\n\tchar** cat = NULL, **dst, **src;\n\n\ttotalLength += Sys_CountFileList(list0);\n\ttotalLength += Sys_CountFileList(list1);\n\ttotalLength += Sys_CountFileList(list2);\n\n\t/* Create new list. */\n\tdst = cat = (char **)Z_Malloc( ( totalLength + 1 ) * sizeof( char* ), TAG_FILESYS, qtrue );\n\n\t/* Copy over lists. */\n\tif (list0) {\n\t\tfor (src = list0; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list1) {\n\t\tfor (src = list1; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list2) {\n\t\tfor (src = list2; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\n\t// Terminate the list\n\t*dst = NULL;\n\n\t// Free our old lists.\n\t// NOTE: not freeing their content, it's been merged in dst and still being used\n\tif (list0) Z_Free( list0 );\n\tif (list1) Z_Free( list1 );\n\tif (list2) Z_Free( list2 );\n\n\treturn cat;\n}\n//#endif\n\n// For base game mod listing\nconst char *SE_GetString( const char *psPackageAndStringReference );\n\n/*\n================\nFS_GetModList\n\nReturns a list of mod directory names\nA mod directory is a peer to base with a pk3 in it\nThe directories are searched in base path, cd path and home path\n================\n*/\nint\tFS_GetModList( char *listbuf, int bufsize ) {\n\tint\t\tnMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;\n\tchar **pFiles = NULL;\n\tchar **pPaks = NULL;\n\tchar *name, *path;\n\tchar descPath[MAX_OSPATH];\n\tfileHandle_t descHandle;\n\n\tint dummy;\n\tchar **pFiles0 = NULL;\n\tchar **pFiles1 = NULL;\n\tchar **pFiles2 = NULL;\n\tqboolean bDrop = qfalse;\n\n\t*listbuf = 0;\n\tnMods = nPotential = nTotal = 0;\n\n\tpFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles2 = Sys_ListFiles( fs_cdpath->string, NULL, NULL, &dummy, qtrue );\n\t// we searched for mods in the three paths\n\t// it is likely that we have duplicate names now, which we will cleanup below\n\tpFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1, pFiles2 );\n\tnPotential = Sys_CountFileList(pFiles);\n\n\tfor ( i = 0 ; i < nPotential ; i++ ) {\n\t\tname = pFiles[i];\n\t\t// NOTE: cleaner would involve more changes\n\t\t// ignore duplicate mod directories\n\t\tif (i!=0) {\n\t\t\tbDrop = qfalse;\n\t\t\tfor(j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif (Q_stricmp(pFiles[j],name)==0) {\n\t\t\t\t\t// this one can be dropped\n\t\t\t\t\tbDrop = qtrue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bDrop) {\n\t\t\tcontinue;\n\t\t}\n\t\t// we drop \".\" and \"..\"\n\t\tif (Q_stricmpn(name, \".\", 1)) {\n\t\t\t// now we need to find some .pk3 files to validate the mod\n\t\t\t// NOTE TTimo: (actually I'm not sure why .. what if it's a mod under developement with no .pk3?)\n\t\t\t// we didn't keep the information when we merged the directory names, as to what OS Path it was found under\n\t\t\t//   so it could be in base path, cd path or home path\n\t\t\t//   we will try each three of them here (yes, it's a bit messy)\n\t\t\tpath = FS_BuildOSPath( fs_basepath->string, name, \"\" );\n\t\t\tnPaks = 0;\n\t\t\tpPaks = Sys_ListFiles(path, \".pk3\", NULL, &nPaks, qfalse);\n\t\t\tSys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present\n\n\t\t\t/* Try on cd path */\n\t\t\tif( nPaks <= 0 ) {\n\t\t\t\tpath = FS_BuildOSPath( fs_cdpath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\t/* try on home path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_homepath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\tif (nPaks > 0) {\n\t\t\t\tbool isBase = !Q_stricmp( name, BASEGAME );\n\t\t\t\tnLen = isBase ? 1 : strlen(name) + 1;\n\t\t\t\t// nLen is the length of the mod path\n\t\t\t\t// we need to see if there is a description available\n\t\t\t\tdescPath[0] = '\\0';\n\t\t\t\tstrcpy(descPath, name);\n\t\t\t\tstrcat(descPath, \"/description.txt\");\n\t\t\t\tnDescLen = FS_SV_FOpenFileRead( descPath, &descHandle );\n\t\t\t\tif ( nDescLen > 0 && descHandle) {\n\t\t\t\t\tFILE *file;\n\t\t\t\t\tfile = FS_FileForHandle(descHandle);\n\t\t\t\t\tCom_Memset( descPath, 0, sizeof( descPath ) );\n\t\t\t\t\tnDescLen = fread(descPath, 1, 48, file);\n\t\t\t\t\tif (nDescLen >= 0) {\n\t\t\t\t\t\tdescPath[nDescLen] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tFS_FCloseFile(descHandle);\n\t\t\t\t} else if ( isBase ) {\n\t\t\t\t\tstrcpy(descPath, SE_GetString(\"MENUS_JEDI_ACADEMY\"));\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(descPath, name);\n\t\t\t\t}\n\t\t\t\tnDescLen = strlen(descPath) + 1;\n\n\t\t\t\tif (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {\n\t\t\t\t\tif ( isBase )\n\t\t\t\t\t\tstrcpy(listbuf, \"\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(listbuf, name);\n\t\t\t\t\tlistbuf += nLen;\n\t\t\t\t\tstrcpy(listbuf, descPath);\n\t\t\t\t\tlistbuf += nDescLen;\n\t\t\t\t\tnTotal += nLen + nDescLen;\n\t\t\t\t\tnMods++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSys_FreeFileList( pFiles );\n\n\treturn nMods;\n}\n\n//============================================================================\n\n/*\n================\nFS_Dir_f\n================\n*/\nvoid FS_Dir_f( void ) {\n\tchar\t*path;\n\tchar\t*extension;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {\n\t\tCom_Printf( \"usage: dir <directory> [extension]\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = \"\";\n\t} else {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = Cmd_Argv( 2 );\n\t}\n\n\tCom_Printf( \"Directory of %s %s\\n\", path, extension );\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFiles( path, extension, &ndirs );\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n===========\nFS_ConvertPath\n===========\n*/\nvoid FS_ConvertPath( char *s ) {\n\twhile (*s) {\n\t\tif ( *s == '\\\\' || *s == ':' ) {\n\t\t\t*s = '/';\n\t\t}\n\t\ts++;\n\t}\n}\n\n/*\n===========\nFS_PathCmp\n\nIgnore case and separator char distinctions\n===========\n*/\nint FS_PathCmp( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 < c2) {\n\t\t\treturn -1;\t\t// strings not equal\n\t\t}\n\t\tif (c1 > c2) {\n\t\t\treturn 1;\n\t\t}\n\t} while (c1);\n\n\treturn 0;\t\t// strings are equal\n}\n\n/*\n================\nFS_SortFileList\n================\n*/\nvoid FS_SortFileList(char **filelist, int numfiles) {\n\tint i, j, k, numsortedfiles;\n\tchar **sortedlist;\n\n\tsortedlist = (char **)Z_Malloc( ( numfiles + 1 ) * sizeof( *sortedlist ), TAG_FILESYS, qtrue );\n\tsortedlist[0] = NULL;\n\tnumsortedfiles = 0;\n\tfor (i = 0; i < numfiles; i++) {\n\t\tfor (j = 0; j < numsortedfiles; j++) {\n\t\t\tif (FS_PathCmp(filelist[i], sortedlist[j]) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (k = numsortedfiles; k > j; k--) {\n\t\t\tsortedlist[k] = sortedlist[k-1];\n\t\t}\n\t\tsortedlist[j] = filelist[i];\n\t\tnumsortedfiles++;\n\t}\n\tCom_Memcpy(filelist, sortedlist, numfiles * sizeof( *filelist ) );\n\tZ_Free(sortedlist);\n}\n\n/*\n================\nFS_NewDir_f\n================\n*/\nvoid FS_NewDir_f( void ) {\n\tchar\t*filter;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 ) {\n\t\tCom_Printf( \"usage: fdir <filter>\\n\" );\n\t\tCom_Printf( \"example: fdir *t1*.bsp\\n\");\n\t\treturn;\n\t}\n\n\tfilter = Cmd_Argv( 1 );\n\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFilteredFiles( \"\", \"\", filter, &ndirs );\n\n\tFS_SortFileList(dirnames, ndirs);\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tFS_ConvertPath(dirnames[i]);\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tCom_Printf( \"%d files listed\\n\", ndirs );\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n============\nFS_Path_f\n\n============\n*/\nvoid FS_Path_f( void ) {\n\tsearchpath_t\t*s;\n\tint\t\t\t\ti;\n\n\tCom_Printf (\"Current search path:\\n\");\n\tfor (s = fs_searchpaths; s; s = s->next) {\n\t\tif (s->pack) {\n\t\t\tCom_Printf (\"%s (%i files)\\n\", s->pack->pakFilename, s->pack->numfiles);\n\t\t} else {\n\t\t\tCom_Printf (\"%s%c%s\\n\", s->dir->path, PATH_SEP, s->dir->gamedir );\n\t\t}\n\t}\n\n\tCom_Printf( \"\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o ) {\n\t\t\tCom_Printf( \"handle %i: %s\\n\", i, fsh[i].name );\n\t\t}\n\t}\n}\n\n/*\n============\nFS_TouchFile_f\n\nThe only purpose of this function is to allow game script files to copy\narbitrary files furing an \"fs_copyfiles 1\" run.\n============\n*/\nvoid FS_TouchFile_f( void ) {\n\tfileHandle_t\tf;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"Usage: touchFile <file>\\n\" );\n\t\treturn;\n\t}\n\n\tFS_FOpenFileRead( Cmd_Argv( 1 ), &f, qfalse );\n\tif ( f ) {\n\t\tFS_FCloseFile( f );\n\t}\n}\n\n/*\n============\nFS_Which_f\n============\n*/\nvoid FS_Which_f( void ) {\n\tsearchpath_t\t*search;\n\tchar\t\t*filename;\n\n\tfilename = Cmd_Argv(1);\n\n\tif ( !filename[0] ) {\n\t\tCom_Printf( \"Usage: which <file>\\n\" );\n\t\treturn;\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn;\n\t}\n\n\t// just wants to see if file is there\n\tfor ( search=fs_searchpaths; search; search=search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tlong hash = FS_HashFileName( filename, search->pack->hashSize );\n\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack->hashTable[hash]) {\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpack_t* pak = search->pack;\n\t\t\t\tfileInPack_t* pakFile = pak->hashTable[hash];\n\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\t\t\t\t\t\tCom_Printf( \"File \\\"%s\\\" found in \\\"%s\\\"\\n\", filename, pak->pakFilename );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while ( pakFile != NULL );\n\t\t\t}\n\t\t} else if (search->dir) {\n\t\t\tdirectory_t* dir = search->dir;\n\n\t\t\tchar* netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\tFILE* filep = fopen(netpath, \"rb\");\n\n\t\t\tif ( filep ) {\n\t\t\t\tfclose( filep );\n\n\t\t\t\tchar buf[MAX_OSPATH];\n\t\t\t\tCom_sprintf( buf, sizeof( buf ), \"%s%c%s\", dir->path, PATH_SEP, dir->gamedir );\n\t\t\t\tFS_ReplaceSeparators( buf );\n\t\t\t\tCom_Printf( \"File \\\"%s\\\" found at \\\"%s\\\"\\n\", filename, buf );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tCom_Printf( \"File not found: \\\"%s\\\"\\n\", filename );\n}\n\n//===========================================================================\n\nstatic int QDECL paksort( const void *a, const void *b ) {\n\tchar\t*aa, *bb;\n\n\taa = *(char **)a;\n\tbb = *(char **)b;\n\n\treturn FS_PathCmp( aa, bb );\n}\n\n/*\n================\nFS_AddGameDirectory\n\nSets fs_gamedir, adds the directory to the head of the path,\nthen loads the zip headers\n================\n*/\n#define\tMAX_PAKFILES\t1024\nstatic void FS_AddGameDirectory( const char *path, const char *dir ) {\n\tsearchpath_t\t*sp;\n\tint\t\t\t\ti;\n\tsearchpath_t\t*search;\n\tsearchpath_t\t*thedir;\n\tpack_t\t\t\t*pak;\n\tchar\t\t\tcurpath[MAX_OSPATH + 1], *pakfile;\n\tint\t\t\t\tnumfiles;\n\tchar\t\t\t**pakfiles;\n\tchar\t\t\t*sorted[MAX_PAKFILES];\n\n\t// this fixes the case where fs_basepath is the same as fs_cdpath\n\t// which happens on full installs\n\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\t// TODO Sys_PathCmp SDL-Port will contain this for SP as well\n\t\t// Should be Sys_PathCmp(sp->dir->path, path)\n\t\tif ( sp->dir && !Q_stricmp(sp->dir->path, path) && !Q_stricmp(sp->dir->gamedir, dir)) {\n\t\t\treturn;\t\t\t// we've already got this one\n\t\t}\n\t}\n\n\tQ_strncpyz( fs_gamedir, dir, sizeof( fs_gamedir ) );\n\n\t// find all pak files in this directory\n\tQ_strncpyz(curpath, FS_BuildOSPath(path, dir, \"\"), sizeof(curpath));\n\tcurpath[strlen(curpath) - 1] = '\\0';\t// strip the trailing slash\n\n\t//\n\t// add the directory to the search path\n\t//\n\tsearch = (struct searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\tsearch->dir = (directory_t *)Z_Malloc( sizeof( *search->dir ), TAG_FILESYS, qtrue );\n\n\tQ_strncpyz( search->dir->path, path, sizeof( search->dir->path ) );\n\tQ_strncpyz( search->dir->fullpath, curpath, sizeof( search->dir->fullpath ) );\n\tQ_strncpyz( search->dir->gamedir, dir, sizeof( search->dir->gamedir ) );\n\tsearch->next = fs_searchpaths;\n\tfs_searchpaths = search;\n\n\tthedir = search;\n\n\tpakfiles = Sys_ListFiles( curpath, \".pk3\", NULL, &numfiles, qfalse );\n\n\t// sort them so that later alphabetic matches override\n\t// earlier ones.  This makes pak1.pk3 override pak0.pk3\n\tif ( numfiles > MAX_PAKFILES ) {\n\t\tnumfiles = MAX_PAKFILES;\n\t}\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tsorted[i] = pakfiles[i];\n\t}\n\n\tqsort( sorted, numfiles, sizeof(char*), paksort );\n\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tpakfile = FS_BuildOSPath( path, dir, sorted[i] );\n\t\tif ( ( pak = FS_LoadZipFile( pakfile, sorted[i] ) ) == 0 )\n\t\t\tcontinue;\n\t\tQ_strncpyz(pak->pakPathname, curpath, sizeof(pak->pakPathname));\n\t\t// store the game name for downloading\n\t\tQ_strncpyz(pak->pakGamename, dir, sizeof(pak->pakGamename));\n\n\t\tfs_packFiles += pak->numfiles;\n\n\t\tsearch = (searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\t\tsearch->pack = pak;\n\n\t\tif (fs_dirbeforepak && fs_dirbeforepak->integer && thedir)\n\t\t{\n\t\t\tsearchpath_t *oldnext = thedir->next;\n\t\t\tthedir->next = search;\n\n\t\t\twhile (oldnext)\n\t\t\t{\n\t\t\t\tsearch->next = oldnext;\n\t\t\t\tsearch = search->next;\n\t\t\t\toldnext = oldnext->next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsearch->next = fs_searchpaths;\n\t\t\tfs_searchpaths = search;\n\t\t}\n\t}\n\n\t// done\n\tSys_FreeFileList( pakfiles );\n}\n\n/*\n================\nFS_CheckDirTraversal\n\nCheck whether the string contains stuff like \"../\" to prevent directory traversal bugs\nand return qtrue if it does.\n================\n*/\n\nqboolean FS_CheckDirTraversal(const char *checkdir)\n{\n\tif(strstr(checkdir, \"../\") || strstr(checkdir, \"..\\\\\"))\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_Shutdown\n\nFrees all resources and closes all files\n================\n*/\nvoid FS_Shutdown( void ) {\n\tsearchpath_t\t*p, *next;\n\tint\ti;\n\n\tfor(i = 0; i < MAX_FILE_HANDLES; i++) {\n\t\tif (fsh[i].fileSize) {\n\t\t\tFS_FCloseFile(i);\n\t\t}\n\t}\n\n\t// free everything\n\tfor ( p = fs_searchpaths ; p ; p = next ) {\n\t\tnext = p->next;\n\n\t\tif ( p->pack ) {\n\t\t\tFS_FreePak( p->pack );\n\t\t}\n\t\tif ( p->dir ) {\n\t\t\tZ_Free( p->dir );\n\t\t}\n\t\tZ_Free( p );\n\t}\n\n\t// any FS_ calls will now be an error until reinitialized\n\tfs_searchpaths = NULL;\n\n\tCmd_RemoveCommand( \"path\" );\n\tCmd_RemoveCommand( \"dir\" );\n\tCmd_RemoveCommand( \"fdir\" );\n\tCmd_RemoveCommand( \"touchFile\" );\n\tCmd_RemoveCommand( \"which\" );\n}\n\n/*\n================\nFS_Startup\n================\n*/\nvoid FS_Startup( const char *gameName ) {\n\tconst char *homePath;\n\n\tCom_Printf( \"----- FS_Startup -----\\n\" );\n\n\tfs_packFiles = 0;\n\n\tfs_debug = Cvar_Get( \"fs_debug\", \"0\", 0 );\n\tfs_copyfiles = Cvar_Get( \"fs_copyfiles\", \"0\", CVAR_INIT );\n\tfs_cdpath = Cvar_Get (\"fs_cdpath\", \"\", CVAR_INIT|CVAR_PROTECTED );\n\tfs_basepath = Cvar_Get (\"fs_basepath\", Sys_DefaultInstallPath(), CVAR_INIT|CVAR_PROTECTED );\n\tfs_basegame = Cvar_Get (\"fs_basegame\", \"\", CVAR_INIT );\n\thomePath = Sys_DefaultHomePath();\n\tif (!homePath || !homePath[0]) {\n\t\thomePath = fs_basepath->string;\n\t}\n\tfs_homepath = Cvar_Get (\"fs_homepath\", homePath, CVAR_INIT|CVAR_PROTECTED );\n\tfs_gamedirvar = Cvar_Get (\"fs_game\", \"\", CVAR_INIT|CVAR_SYSTEMINFO );\n\n\tfs_dirbeforepak = Cvar_Get(\"fs_dirbeforepak\", \"0\", CVAR_INIT|CVAR_PROTECTED);\n\n\t// add search path elements in reverse priority order\n\tif (fs_cdpath->string[0]) {\n\t\tFS_AddGameDirectory( fs_cdpath->string, gameName );\n\t}\n\tif (fs_basepath->string[0]) {\n\t\tFS_AddGameDirectory( fs_basepath->string, gameName );\n\t}\n\n#ifdef MACOS_X\n\tfs_apppath = Cvar_Get (\"fs_apppath\", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED );\n\t// Make MacOSX also include the base path included with the .app bundle\n\tif (fs_apppath->string[0]) {\n\t\tFS_AddGameDirectory( fs_apppath->string, gameName );\n\t}\n#endif\n\n\t// fs_homepath is somewhat particular to *nix systems, only add if relevant\n\t// NOTE: same filtering below for mods and basegame\n\t// TODO Sys_PathCmp see previous comment for why\n\t// !Sys_PathCmp(fs_homepath->string, fs_basepath->string)\n\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\tFS_CreatePath ( fs_homepath->string );\n\t\tFS_AddGameDirectory ( fs_homepath->string, gameName );\n\t}\n\n\t// check for additional base game so mods can be based upon other mods\n\tif ( fs_basegame->string[0] && Q_stricmp( fs_basegame->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_basegame->string);\n\t\t}\n\t}\n\n\t// check for additional game folder for mods\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n\n\t// add our commands\n\tCmd_AddCommand (\"path\", FS_Path_f);\n\tCmd_AddCommand (\"dir\", FS_Dir_f );\n\tCmd_AddCommand (\"fdir\", FS_NewDir_f );\n\tCmd_AddCommand (\"touchFile\", FS_TouchFile_f );\n\tCmd_AddCommand (\"which\", FS_Which_f );\n\n\t// print the current search paths\n\tFS_Path_f();\n\n\tfs_gamedirvar->modified = qfalse; // We just loaded, it's not modified\n\n\tCom_Printf( \"----------------------\\n\" );\n\tCom_Printf( \"%d files in pk3 files\\n\", fs_packFiles );\n}\n\n/*\n================\nFS_InitFilesystem\n\nCalled only at inital startup, not when the filesystem\nis resetting due to a game change\n================\n*/\nvoid FS_InitFilesystem( void ) {\n\t// allow command line parms to override our defaults\n\t// we have to specially handle this, because normal command\n\t// line variable sets don't happen until after the filesystem\n\t// has already been initialized\n\tCom_StartupVariable( \"fs_cdpath\" );\n\tCom_StartupVariable( \"fs_basepath\" );\n\tCom_StartupVariable( \"fs_homepath\" );\n\tCom_StartupVariable( \"fs_game\" );\n\tCom_StartupVariable( \"fs_copyfiles\" );\n\tCom_StartupVariable( \"fs_dirbeforepak\" );\n#ifdef MACOS_X\n\tCom_StartupVariable( \"fs_apppath\" );\n#endif\n\n\tconst char *gamedir = Cvar_VariableString(\"fs_game\");\n\tbool requestbase = false;\n\tif ( !FS_FilenameCompare( gamedir, BASEGAME ) )\n\t\trequestbase = true;\n\n\tif ( requestbase )\n\t\tCvar_Set2( \"fs_game\", \"\", qtrue );\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"default.cfg\", NULL ) <= 0 ) {\n\t\tCom_Error( ERR_FATAL, \"Couldn't load default.cfg\" );\n\t\t// bk001208 - SafeMode see below, FIXME?\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n  // bk001208 - SafeMode see below, FIXME?\n}\n\n/*\n================\nFS_Restart\n================\n*/\nvoid FS_Restart( void ) {\n\n\t// free anything we currently have loaded\n\tFS_Shutdown();\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"default.cfg\", NULL ) <= 0 ) {\n\t\t// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3\n\t\t// (for instance a TA demo server)\n\t\tif (lastValidBase[0]) {\n\t\t\tCvar_Set(\"fs_basepath\", lastValidBase);\n\t\t\tCvar_Set(\"fs_game\", lastValidGame);\n\t\t\tlastValidBase[0] = '\\0';\n\t\t\tlastValidGame[0] = '\\0';\n\t\t\tFS_Restart();\n\t\t\tCom_Error( ERR_DROP, \"Invalid game folder\" );\n\t\t\treturn;\n\t\t}\n\t\tCom_Error( ERR_FATAL, \"Couldn't load default.cfg\" );\n\t}\n\n\tif ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {\n\t\t// skip the jaconfig.cfg if \"safe\" is on the command line\n\t\tif ( !Com_SafeMode() ) {\n\t\t\tCbuf_AddText (\"exec \" Q3CONFIG_NAME \"\\n\");\n\t\t}\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n}\n\n/*\n=================\nFS_ConditionalRestart\n\nRestart if necessary\n=================\n*/\nqboolean FS_ConditionalRestart( void ) {\n\tif(fs_gamedirvar->modified) {\n\t\tFS_Restart();\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n========================================================================================\n\nHandle based file calls for virtual machines\n\n========================================================================================\n*/\n\nint\t\tFS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {\n\tint\t\tr;\n\tqboolean\tsync;\n\n\tsync = qfalse;\n\n\tswitch( mode ) {\n\tcase FS_READ:\n\t\tr = FS_FOpenFileRead( qpath, f, qtrue );\n\t\tbreak;\n\tcase FS_WRITE:\n\t\t*f = FS_FOpenFileWrite( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tcase FS_APPEND_SYNC:\n\t\tsync = qtrue;\n\tcase FS_APPEND:\n\t\t*f = FS_FOpenFileAppend( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"FSH_FOpenFile: bad mode\" );\n\t\treturn -1;\n\t}\n\n\tif (!f) {\n\t\treturn r;\n\t}\n\n\tif ( *f ) {\n\t\tfsh[*f].fileSize = r;\n\t}\n\tfsh[*f].handleSync = sync;\n\n\treturn r;\n}\n\nint\t\tFS_FTell( fileHandle_t f ) {\n\tint pos;\n\tif (fsh[f].zipFile == qtrue) {\n\t\tpos = unztell(fsh[f].handleFiles.file.z);\n\t} else {\n\t\tpos = ftell(fsh[f].handleFiles.file.o);\n\t}\n\treturn pos;\n}\n\nvoid\tFS_Flush( fileHandle_t f ) {\n\tfflush(fsh[f].handleFiles.file.o);\n}\n\nvoid FS_FilenameCompletion( const char *dir, const char *ext, qboolean stripExt, callbackFunc_t callback, qboolean allowNonPureFilesOnDisk ) {\n\tint nfiles;\n\tchar **filenames, filename[MAX_STRING_CHARS];\n\n\tfilenames = FS_ListFilteredFiles( dir, ext, NULL, &nfiles );\n\n\tFS_SortFileList( filenames, nfiles );\n\n\t// pass all the files to callback (FindMatches)\n\tfor ( int i=0; i<nfiles; i++ ) {\n\t\tFS_ConvertPath( filenames[i] );\n\t\tQ_strncpyz( filename, filenames[i], MAX_STRING_CHARS );\n\n\t\tif ( stripExt )\n\t\t\tCOM_StripExtension( filename, filename, sizeof( filename ) );\n\n\t\tcallback( filename );\n\t}\n\tFS_FreeFileList( filenames );\n}\n\nconst char *FS_GetCurrentGameDir(bool emptybase)\n{\n\tif(fs_gamedirvar->string[0])\n\t\treturn fs_gamedirvar->string;\n\n\treturn emptybase ? \"\" : BASEGAME;\n}\n\nqboolean FS_WriteToTemporaryFile( const void *data, size_t dataLength, char **tempFilePath )\n{\n\t// SP doesn't need to do this.\n\treturn qfalse;\n}\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n// cl_main.c  -- client main loop\n\n#include \"client.h\"\n\n#include <limits.h>\n#include \"ghoul2/G2.h\"\n#include \"qcommon/cm_public.h\"\n#include \"qcommon/MiniHeap.h\"\n#include \"qcommon/stringed_ingame.h\"\n#include \"cl_cgameapi.h\"\n#include \"cl_uiapi.h\"\n#include \"cl_lan.h\"\n#include \"snd_local.h\"\n#include \"sys/sys_loadlib.h\"\n\ncvar_t\t*cl_renderer;\n\ncvar_t\t*cl_nodelta;\ncvar_t\t*cl_debugMove;\n\ncvar_t\t*cl_noprint;\ncvar_t\t*cl_motd;\ncvar_t\t*cl_motdServer[MAX_MASTER_SERVERS];\n\ncvar_t\t*rcon_client_password;\ncvar_t\t*rconAddress;\n\ncvar_t\t*cl_timeout;\ncvar_t\t*cl_maxpackets;\ncvar_t\t*cl_packetdup;\ncvar_t\t*cl_timeNudge;\ncvar_t\t*cl_showTimeDelta;\ncvar_t\t*cl_freezeDemo;\n\ncvar_t\t*cl_shownet;\ncvar_t\t*cl_showSend;\ncvar_t\t*cl_timedemo;\ncvar_t\t*cl_aviFrameRate;\ncvar_t\t*cl_aviMotionJpeg;\ncvar_t\t*cl_avi2GBLimit;\ncvar_t\t*cl_forceavidemo;\n\ncvar_t\t*cl_freelook;\ncvar_t\t*cl_sensitivity;\n\ncvar_t\t*cl_mouseAccel;\ncvar_t\t*cl_mouseAccelOffset;\ncvar_t\t*cl_mouseAccelStyle;\ncvar_t\t*cl_showMouseRate;\n\ncvar_t\t*m_pitchVeh;\ncvar_t\t*m_pitch;\ncvar_t\t*m_yaw;\ncvar_t\t*m_forward;\ncvar_t\t*m_side;\ncvar_t\t*m_filter;\n\ncvar_t\t*cl_activeAction;\n\ncvar_t\t*cl_motdString;\n\ncvar_t\t*cl_allowDownload;\ncvar_t\t*cl_allowAltEnter;\ncvar_t\t*cl_conXOffset;\ncvar_t\t*cl_inGameVideo;\n\ncvar_t\t*cl_serverStatusResendTime;\ncvar_t\t*cl_framerate;\n\n// cvar to enable sending a \"ja_guid\" player identifier in userinfo to servers\n// ja_guid is a persistent \"cookie\" that allows servers to track players across game sessions\ncvar_t\t*cl_enableGuid;\ncvar_t\t*cl_guidServerUniq;\n\ncvar_t\t*cl_autolodscale;\n\ncvar_t\t*cl_consoleKeys;\ncvar_t\t*cl_consoleUseScanCode;\n\ncvar_t  *cl_lanForcePackets;\n\nvec3_t cl_windVec;\n\n\nclientActive_t\t\tcl;\nclientConnection_t\tclc;\nclientStatic_t\t\tcls;\n\nnetadr_t rcon_address;\n\nchar cl_reconnectArgs[MAX_OSPATH] = {0};\n\n// Structure containing functions exported from refresh DLL\nrefexport_t\t*re = NULL;\nstatic void\t*rendererLib = NULL;\n\nping_t\tcl_pinglist[MAX_PINGREQUESTS];\n\ntypedef struct serverStatus_s\n{\n\tchar string[BIG_INFO_STRING];\n\tnetadr_t address;\n\tint time, startTime;\n\tqboolean pending;\n\tqboolean print;\n\tqboolean retrieved;\n} serverStatus_t;\n\nserverStatus_t cl_serverStatusList[MAX_SERVERSTATUSREQUESTS];\nint serverStatusCount;\n\nIHeapAllocator *G2VertSpaceClient = 0;\n\nextern void SV_BotFrame( int time );\nvoid CL_CheckForResend( void );\nvoid CL_ShowIP_f(void);\nvoid CL_ServerStatus_f(void);\nvoid CL_ServerStatusResponse( netadr_t from, msg_t *msg );\nstatic void CL_ShutdownRef( qboolean restarting );\n\n/*\n=======================================================================\n\nCLIENT RELIABLE COMMAND COMMUNICATION\n\n=======================================================================\n*/\n\n/*\n======================\nCL_AddReliableCommand\n\nThe given command will be transmitted to the server, and is gauranteed to\nnot have future usercmd_t executed before it is executed\n======================\n*/\nvoid CL_AddReliableCommand( const char *cmd, qboolean isDisconnectCmd ) {\n\tint unacknowledged = clc.reliableSequence - clc.reliableAcknowledge;\n\n\t// if we would be losing an old command that hasn't been acknowledged,\n\t// we must drop the connection\n\t// also leave one slot open for the disconnect command in this case.\n\n\tif ((isDisconnectCmd && unacknowledged > MAX_RELIABLE_COMMANDS) ||\n\t    (!isDisconnectCmd && unacknowledged >= MAX_RELIABLE_COMMANDS))\n\t{\n\t\tif(com_errorEntered)\n\t\t\treturn;\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"Client command overflow\");\n\t}\n\n\tQ_strncpyz(clc.reliableCommands[++clc.reliableSequence & (MAX_RELIABLE_COMMANDS - 1)],\n\t\t   cmd, sizeof(*clc.reliableCommands));\n}\n\n/*\n=======================================================================\n\nCLIENT SIDE DEMO RECORDING\n\n=======================================================================\n*/\n\n/*\n====================\nCL_WriteDemoMessage\n\nDumps the current net message, prefixed by the length\n====================\n*/\nvoid CL_WriteDemoMessage ( msg_t *msg, int headerBytes ) {\n\tint\t\tlen, swlen;\n\n\t// write the packet sequence\n\tlen = clc.serverMessageSequence;\n\tswlen = LittleLong( len );\n\tFS_Write (&swlen, 4, clc.demofile);\n\n\t// skip the packet sequencing information\n\tlen = msg->cursize - headerBytes;\n\tswlen = LittleLong(len);\n\tFS_Write (&swlen, 4, clc.demofile);\n\tFS_Write ( msg->data + headerBytes, len, clc.demofile );\n}\n\n\n/*\n====================\nCL_StopRecording_f\n\nstop recording a demo\n====================\n*/\nvoid CL_StopRecord_f( void ) {\n\tint\t\tlen;\n\n\tif ( !clc.demorecording ) {\n\t\tCom_Printf (\"Not recording a demo.\\n\");\n\t\treturn;\n\t}\n\n\t// finish up\n\tlen = -1;\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_FCloseFile (clc.demofile);\n\tclc.demofile = 0;\n\tclc.demorecording = qfalse;\n\tclc.spDemoRecording = qfalse;\n\tCom_Printf (\"Stopped demo.\\n\");\n}\n\n/*\n==================\nCL_DemoFilename\n==================\n*/\nvoid CL_DemoFilename( char *buf, int bufSize ) {\n\ttime_t rawtime;\n\tchar timeStr[32] = {0}; // should really only reach ~19 chars\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\n\tCom_sprintf( buf, bufSize, \"demo%s\", timeStr );\n}\n\n/*\n====================\nCL_Record_f\n\nrecord <demoname>\n\nBegins recording a demo from the current position\n====================\n*/\nstatic char\t\tdemoName[MAX_QPATH];\t// compiler bug workaround\nvoid CL_Record_f( void ) {\n\tchar\t\tname[MAX_OSPATH];\n\tbyte\t\tbufData[MAX_MSGLEN];\n\tmsg_t\tbuf;\n\tint\t\t\ti;\n\tint\t\t\tlen;\n\tentityState_t\t*ent;\n\tentityState_t\tnullstate;\n\tchar\t\t*s;\n\n\tif ( Cmd_Argc() > 2 ) {\n\t\tCom_Printf (\"record <demoname>\\n\");\n\t\treturn;\n\t}\n\n\tif ( clc.demorecording ) {\n\t\tif (!clc.spDemoRecording) {\n\t\t\tCom_Printf (\"Already recording.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf (\"You must be in a level to record.\\n\");\n\t\treturn;\n\t}\n\n\t// sync 0 doesn't prevent recording, so not forcing it off .. everyone does g_sync 1 ; record ; g_sync 0 ..\n\tif ( NET_IsLocalAddress( clc.serverAddress ) && !Cvar_VariableValue( \"g_synchronousClients\" ) ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"WARNING: You should set 'g_synchronousClients 1' for smoother demo recording\\n\");\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\ts = Cmd_Argv(1);\n\t\tQ_strncpyz( demoName, s, sizeof( demoName ) );\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", demoName, PROTOCOL_VERSION );\n\t} else {\n\t\t// timestamp the file\n\t\tCL_DemoFilename( demoName, sizeof( demoName ) );\n\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", demoName, PROTOCOL_VERSION );\n\n\t\tif ( FS_FileExists( name ) ) {\n\t\t\tCom_Printf( \"Record: Couldn't create a file\\n\");\n\t\t\treturn;\n \t\t}\n\t}\n\n\t// open the demo file\n\n\tCom_Printf (\"recording to %s.\\n\", name);\n\tclc.demofile = FS_FOpenFileWrite( name );\n\tif ( !clc.demofile ) {\n\t\tCom_Printf (\"ERROR: couldn't open.\\n\");\n\t\treturn;\n\t}\n\tclc.demorecording = qtrue;\n\tif (Cvar_VariableValue(\"ui_recordSPDemo\")) {\n\t  clc.spDemoRecording = qtrue;\n\t} else {\n\t  clc.spDemoRecording = qfalse;\n\t}\n\n\tQ_strncpyz( clc.demoName, demoName, sizeof( clc.demoName ) );\n\n\t// don't start saving messages until a non-delta compressed message is received\n\tclc.demowaiting = qtrue;\n\n\t// write out the gamestate message\n\tMSG_Init (&buf, bufData, sizeof(bufData));\n\tMSG_Bitstream(&buf);\n\n\t// NOTE, MRE: all server->client messages now acknowledge\n\tMSG_WriteLong( &buf, clc.reliableSequence );\n\n\tMSG_WriteByte (&buf, svc_gamestate);\n\tMSG_WriteLong (&buf, clc.serverCommandSequence );\n\n\t// configstrings\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tif ( !cl.gameState.stringOffsets[i] ) {\n\t\t\tcontinue;\n\t\t}\n\t\ts = cl.gameState.stringData + cl.gameState.stringOffsets[i];\n\t\tMSG_WriteByte (&buf, svc_configstring);\n\t\tMSG_WriteShort (&buf, i);\n\t\tMSG_WriteBigString (&buf, s);\n\t}\n\n\t// baselines\n\tCom_Memset (&nullstate, 0, sizeof(nullstate));\n\tfor ( i = 0; i < MAX_GENTITIES ; i++ ) {\n\t\tent = &cl.entityBaselines[i];\n\t\tif ( !ent->number ) {\n\t\t\tcontinue;\n\t\t}\n\t\tMSG_WriteByte (&buf, svc_baseline);\n\t\tMSG_WriteDeltaEntity (&buf, &nullstate, ent, qtrue );\n\t}\n\n\tMSG_WriteByte( &buf, svc_EOF );\n\n\t// finished writing the gamestate stuff\n\n\t// write the client num\n\tMSG_WriteLong(&buf, clc.clientNum);\n\t// write the checksum feed\n\tMSG_WriteLong(&buf, clc.checksumFeed);\n\n\t// Filler for old RMG system.\n\tMSG_WriteShort ( &buf, 0 );\n\n\t// finished writing the client packet\n\tMSG_WriteByte( &buf, svc_EOF );\n\n\t// write it to the demo file\n\tlen = LittleLong( clc.serverMessageSequence - 1 );\n\tFS_Write (&len, 4, clc.demofile);\n\n\tlen = LittleLong (buf.cursize);\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_Write (buf.data, buf.cursize, clc.demofile);\n\n\t// the rest of the demo file will be copied from net messages\n}\n\n/*\n=======================================================================\n\nCLIENT SIDE DEMO PLAYBACK\n\n=======================================================================\n*/\n\n/*\n=================\nCL_DemoCompleted\n=================\n*/\nvoid CL_DemoCompleted( void ) {\n\tif (cl_timedemo && cl_timedemo->integer) {\n\t\tint\ttime;\n\n\t\ttime = Sys_Milliseconds() - clc.timeDemoStart;\n\t\tif ( time > 0 ) {\n\t\t\tCom_Printf (\"%i frames, %3.1f seconds: %3.1f fps\\n\", clc.timeDemoFrames,\n\t\t\ttime/1000.0, clc.timeDemoFrames*1000.0 / time);\n\t\t}\n\t}\n\n/*\tCL_Disconnect( qtrue );\n\tCL_NextDemo();\n\t*/\n\n\t//rww - The above code seems to just stick you in a no-menu state and you can't do anything there.\n\t//I'm not sure why it ever worked in TA, but whatever. This code will bring us back to the main menu\n\t//after a demo is finished playing instead.\n\tCL_Disconnect_f();\n\tS_StopAllSounds();\n\tUIVM_SetActiveMenu( UIMENU_MAIN );\n\n\tCL_NextDemo();\n}\n\n/*\n=================\nCL_ReadDemoMessage\n=================\n*/\nvoid CL_ReadDemoMessage( void ) {\n\tint\t\t\tr;\n\tmsg_t\t\tbuf;\n\tbyte\t\tbufData[ MAX_MSGLEN ];\n\tint\t\t\ts;\n\n\tif ( !clc.demofile ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\n\t// get the sequence number\n\tr = FS_Read( &s, 4, clc.demofile);\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tclc.serverMessageSequence = LittleLong( s );\n\n\t// init the message\n\tMSG_Init( &buf, bufData, sizeof( bufData ) );\n\n\t// get the length\n\tr = FS_Read (&buf.cursize, 4, clc.demofile);\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tbuf.cursize = LittleLong( buf.cursize );\n\tif ( buf.cursize == -1 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tif ( buf.cursize > buf.maxsize ) {\n\t\tCom_Error (ERR_DROP, \"CL_ReadDemoMessage: demoMsglen > MAX_MSGLEN\");\n\t}\n\tr = FS_Read( buf.data, buf.cursize, clc.demofile );\n\tif ( r != buf.cursize ) {\n\t\tCom_Printf( \"Demo file was truncated.\\n\");\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\n\tclc.lastPacketTime = cls.realtime;\n\tbuf.readcount = 0;\n\tCL_ParseServerMessage( &buf );\n}\n\n/*\n====================\nCL_CompleteDemoName\n====================\n*/\nstatic void CL_CompleteDemoName( char *args, int argNum )\n{\n\tif( argNum == 2 )\n\t{\n\t\tchar demoExt[16];\n\n\t\tCom_sprintf(demoExt, sizeof(demoExt), \".dm_%d\", PROTOCOL_VERSION);\n\t\tField_CompleteFilename( \"demos\", demoExt, qtrue, qtrue );\n\t}\n}\n\n/*\n====================\nCL_PlayDemo_f\n\ndemo <demoname>\n\n====================\n*/\nvoid CL_PlayDemo_f( void ) {\n\tchar\t\tname[MAX_OSPATH], extension[32];\n\tchar\t\t*arg;\n\n\tif (Cmd_Argc() != 2) {\n\t\tCom_Printf (\"demo <demoname>\\n\");\n\t\treturn;\n\t}\n\n\t// make sure a local server is killed\n\t// 2 means don't force disconnect of local client\n\tCvar_Set( \"sv_killserver\", \"2\" );\n\n\t// open the demo file\n\targ = Cmd_Argv(1);\n\n\tCL_Disconnect( qtrue );\n\n\tCom_sprintf(extension, sizeof(extension), \".dm_%d\", PROTOCOL_VERSION);\n\tif ( !Q_stricmp( arg + strlen(arg) - strlen(extension), extension ) ) {\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s\", arg);\n\t} else {\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", arg, PROTOCOL_VERSION);\n\t}\n\n\tFS_FOpenFileRead( name, &clc.demofile, qtrue );\n\tif (!clc.demofile) {\n\t\tif (!Q_stricmp(arg, \"(null)\"))\n\t\t{\n\t\t\tCom_Error( ERR_DROP, SE_GetString(\"CON_TEXT_NO_DEMO_SELECTED\") );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCom_Error( ERR_DROP, \"couldn't open %s\", name);\n\t\t}\n\t\treturn;\n\t}\n\tQ_strncpyz( clc.demoName, Cmd_Argv(1), sizeof( clc.demoName ) );\n\n\tCon_Close();\n\n\tcls.state = CA_CONNECTED;\n\tclc.demoplaying = qtrue;\n\tQ_strncpyz( cls.servername, Cmd_Argv(1), sizeof( cls.servername ) );\n\n\t// read demo messages until connected\n\twhile ( cls.state >= CA_CONNECTED && cls.state < CA_PRIMED ) {\n\t\tCL_ReadDemoMessage();\n\t}\n\t// don't get the first snapshot this frame, to prevent the long\n\t// time from the gamestate load from messing causing a time skip\n\tclc.firstDemoFrameSkipped = qfalse;\n}\n\n\n/*\n====================\nCL_StartDemoLoop\n\nClosing the main menu will restart the demo loop\n====================\n*/\nvoid CL_StartDemoLoop( void ) {\n\t// start the demo loop again\n\tCbuf_AddText (\"d1\\n\");\n\tKey_SetCatcher( 0 );\n}\n\n/*\n==================\nCL_NextDemo\n\nCalled when a demo or cinematic finishes\nIf the \"nextdemo\" cvar is set, that command will be issued\n==================\n*/\nvoid CL_NextDemo( void ) {\n\tchar\tv[MAX_STRING_CHARS];\n\n\tQ_strncpyz( v, Cvar_VariableString (\"nextdemo\"), sizeof(v) );\n\tv[MAX_STRING_CHARS-1] = 0;\n\tCom_DPrintf(\"CL_NextDemo: %s\\n\", v );\n\tif (!v[0]) {\n\t\treturn;\n\t}\n\n\tCvar_Set (\"nextdemo\",\"\");\n\tCbuf_AddText (v);\n\tCbuf_AddText (\"\\n\");\n\tCbuf_Execute();\n}\n\n//======================================================================\n\n/*\n=====================\nCL_ShutdownAll\n=====================\n*/\nvoid CL_ShutdownAll( qboolean shutdownRef ) {\n\tif(CL_VideoRecording())\n\t\tCL_CloseAVI();\n\n\tif(clc.demorecording)\n\t\tCL_StopRecord_f();\n\n#if 0 //rwwFIXMEFIXME: Disable this before release!!!!!! I am just trying to find a crash bug.\n\t//so it doesn't barf on shutdown saying refentities belong to each other\n\ttr.refdef.num_entities = 0;\n#endif\n\n\t// clear sounds\n\tS_DisableSounds();\n\t// shutdown CGame\n\tCL_ShutdownCGame();\n\t// shutdown UI\n\tCL_ShutdownUI();\n\n\t// shutdown the renderer\n\tif(shutdownRef)\n\t\tCL_ShutdownRef( qfalse );\n\tif ( re && re->Shutdown ) {\n\t\tre->Shutdown( qfalse, qfalse );\t\t// don't destroy window or context\n\t}\n\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.rendererStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n}\n\n/*\n=================\nCL_FlushMemory\n\nCalled by CL_MapLoading, CL_Connect_f, CL_PlayDemo_f, and CL_ParseGamestate the only\nways a client gets into a game\nAlso called by Com_Error\n=================\n*/\nvoid CL_FlushMemory( void ) {\n\n\t// shutdown all the client stuff\n\tCL_ShutdownAll( qfalse );\n\n\t// if not running a server clear the whole hunk\n\tif ( !com_sv_running->integer ) {\n\t\t// clear collision map data\n\t\tCM_ClearMap();\n\t\t// clear the whole hunk\n\t\tHunk_Clear();\n\t}\n\telse {\n\t\t// clear all the client data on the hunk\n\t\tHunk_ClearToMark();\n\t}\n\n\tCL_StartHunkUsers();\n}\n\n/*\n=====================\nCL_MapLoading\n\nA local server is starting to load a map, so update the\nscreen to let the user know about it, then dump all client\nmemory on the hunk from cgame, ui, and renderer\n=====================\n*/\nvoid CL_MapLoading( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// Set this to localhost.\n\tCvar_Set( \"cl_currentServerAddress\", \"Localhost\");\n\tCvar_Set( \"cl_currentServerIP\", \"loopback\");\n\n\tCon_Close();\n\tKey_SetCatcher( 0 );\n\n\t// if we are already connected to the local host, stay connected\n\tif ( cls.state >= CA_CONNECTED && !Q_stricmp( cls.servername, \"localhost\" ) ) {\n\t\tcls.state = CA_CONNECTED;\t\t// so the connect screen is drawn\n\t\tCom_Memset( cls.updateInfoString, 0, sizeof( cls.updateInfoString ) );\n\t\tCom_Memset( clc.serverMessage, 0, sizeof( clc.serverMessage ) );\n\t\tCom_Memset( &cl.gameState, 0, sizeof( cl.gameState ) );\n\t\tclc.lastPacketSentTime = -9999;\n\t\tSCR_UpdateScreen();\n\t} else {\n\t\t// clear nextmap so the cinematic shutdown doesn't execute it\n\t\tCvar_Set( \"nextmap\", \"\" );\n\t\tCL_Disconnect( qtrue );\n\t\tQ_strncpyz( cls.servername, \"localhost\", sizeof(cls.servername) );\n\t\tcls.state = CA_CHALLENGING;\t\t// so the connect screen is drawn\n\t\tKey_SetCatcher( 0 );\n\t\tSCR_UpdateScreen();\n\t\tclc.connectTime = -RETRANSMIT_TIMEOUT;\n\t\tNET_StringToAdr( cls.servername, &clc.serverAddress);\n\t\t// we don't need a challenge on the localhost\n\n\t\tCL_CheckForResend();\n\t}\n}\n\n/*\n=====================\nCL_ClearState\n\nCalled before parsing a gamestate\n=====================\n*/\nvoid CL_ClearState (void) {\n\n//\tS_StopAllSounds();\n\tCom_Memset( &cl, 0, sizeof( cl ) );\n}\n\n/*\n====================\nCL_UpdateGUID\n\nupdate cl_guid using QKEY_FILE and optional prefix\n====================\n*/\nstatic void CL_UpdateGUID( const char *prefix, int prefix_len )\n{\n\tif (cl_enableGuid->integer) {\n\t\tfileHandle_t f;\n\t\tint len;\n\n\t\tlen = FS_SV_FOpenFileRead( QKEY_FILE, &f );\n\t\tFS_FCloseFile( f );\n\n\t\t// initialize the cvar here in case it's unset or was user-created\n\t\t// while tracking was disabled (removes CVAR_USER_CREATED)\n\t\tCvar_Get( \"ja_guid\", \"\", CVAR_USERINFO | CVAR_ROM, \"Client GUID\" );\n\n\t\tif( len != QKEY_SIZE ) {\n\t\t\tCvar_Set( \"ja_guid\", \"\" );\n\t\t} else {\n\t\t\tCvar_Set( \"ja_guid\", Com_MD5File( QKEY_FILE, QKEY_SIZE,\n\t\t\t\tprefix, prefix_len ) );\n\t\t}\n\t} else {\n\t\t// Remove the cvar entirely if tracking is disabled\n\t\tuint32_t flags = Cvar_Flags(\"ja_guid\");\n\t\t// keep the cvar if it's user-created, but destroy it otherwise\n\t\tif (flags != CVAR_NONEXISTENT && !(flags & CVAR_USER_CREATED)) {\n\t\t\tcvar_t *ja_guid = Cvar_Get(\"ja_guid\", \"\", 0, \"Client GUID\" );\n\t\t\tCvar_Unset(ja_guid);\n\t\t}\n\t}\n}\n\n/*\n=====================\nCL_Disconnect\n\nCalled when a connection, demo, or cinematic is being terminated.\nGoes from a connected state to either a menu state or a console state\nSends a disconnect message to the server\nThis is also called on Com_Error and Com_Quit, so it shouldn't cause any errors\n=====================\n*/\nvoid CL_Disconnect( qboolean showMainMenu ) {\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// shutting down the client so enter full screen ui mode\n\tCvar_Set(\"r_uiFullScreen\", \"1\");\n\n\tif ( clc.demorecording ) {\n\t\tCL_StopRecord_f ();\n\t}\n\n\tif (clc.download) {\n\t\tFS_FCloseFile( clc.download );\n\t\tclc.download = 0;\n\t}\n\t*clc.downloadTempName = *clc.downloadName = 0;\n\tCvar_Set( \"cl_downloadName\", \"\" );\n\n\tif ( clc.demofile ) {\n\t\tFS_FCloseFile( clc.demofile );\n\t\tclc.demofile = 0;\n\t}\n\n\tif ( cls.uiStarted && showMainMenu ) {\n\t\tUIVM_SetActiveMenu( UIMENU_NONE );\n\t}\n\n\tSCR_StopCinematic ();\n\tS_ClearSoundBuffer();\n\n\t// send a disconnect message to the server\n\t// send it a few times in case one is dropped\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\tCL_AddReliableCommand( \"disconnect\", qtrue );\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t}\n\n\t// Remove pure paks\n\tFS_PureServerSetLoadedPaks(\"\", \"\");\n\tFS_PureServerSetReferencedPaks(\"\", \"\");\n\n\tCL_ClearState ();\n\n\t// wipe the client connection\n\tCom_Memset( &clc, 0, sizeof( clc ) );\n\n\tcls.state = CA_DISCONNECTED;\n\n\t// allow cheats locally\n\tCvar_Set( \"sv_cheats\", \"1\" );\n\n\t// not connected to a pure server anymore\n\tcl_connectedToPureServer = qfalse;\n\n\t// Stop recording any video\n\tif( CL_VideoRecording( ) ) {\n\t\t// Finish rendering current frame\n\t\tSCR_UpdateScreen( );\n\t\tCL_CloseAVI( );\n\t}\n\n\tCL_UpdateGUID( NULL, 0 );\n}\n\n\n/*\n===================\nCL_ForwardCommandToServer\n\nadds the current command line as a clientCommand\nthings like godmode, noclip, etc, are commands directed to the server,\nso when they are typed in at the console, they will need to be forwarded.\n===================\n*/\nvoid CL_ForwardCommandToServer( const char *string ) {\n\tchar\t*cmd;\n\n\tcmd = Cmd_Argv(0);\n\n\t// ignore key up commands\n\tif ( cmd[0] == '-' ) {\n\t\treturn;\n\t}\n\n\tif (clc.demoplaying || cls.state < CA_CONNECTED || cmd[0] == '+' ) {\n\t\tCom_Printf (\"Unknown command \\\"%s\" S_COLOR_WHITE \"\\\"\\n\", cmd);\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( string, qfalse );\n\t} else {\n\t\tCL_AddReliableCommand( cmd, qfalse );\n\t}\n}\n\n/*\n===================\nCL_RequestMotd\n\n===================\n*/\nvoid CL_RequestMotd( void ) {\n\tnetadr_t\tto;\n\tint\t\t\ti;\n\tchar\t\tcommand[MAX_STRING_CHARS], info[MAX_INFO_STRING];\n\tchar\t\t*motdaddress;\n\n\tif ( !cl_motd->integer ) {\n\t\treturn;\n\t}\n\n\tif ( cl_motd->integer < 1 || cl_motd->integer > MAX_MASTER_SERVERS ) {\n\t\tCom_Printf( \"CL_RequestMotd: Invalid motd server num. Valid values are 1-%d or 0 to disable\\n\", MAX_MASTER_SERVERS );\n\t\treturn;\n\t}\n\n\tCom_sprintf( command, sizeof(command), \"cl_motdServer%d\", cl_motd->integer );\n\tmotdaddress = Cvar_VariableString( command );\n\n\tif ( !*motdaddress )\n\t{\n\t\tCom_Printf( \"CL_RequestMotd: Error: No motd server address given.\\n\" );\n\t\treturn;\n\t}\n\n\ti = NET_StringToAdr( motdaddress, &to );\n\n\tif ( !i )\n\t{\n\t\tCom_Printf( \"CL_RequestMotd: Error: could not resolve address of motd server %s\\n\", motdaddress );\n\t\treturn;\n\t}\n\tto.type = NA_IP;\n\tto.port = BigShort( PORT_UPDATE );\n\n\tCom_Printf( \"Requesting motd from update %s (%s)...\\n\", motdaddress, NET_AdrToString( to ) );\n\n\tcls.updateServer = to;\n\n\tinfo[0] = 0;\n  // NOTE TTimo xoring against Com_Milliseconds, otherwise we may not have a true randomization\n  // only srand I could catch before here is tr_noise.c l:26 srand(1001)\n  // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=382\n  // NOTE: the Com_Milliseconds xoring only affects the lower 16-bit word,\n  //   but I decided it was enough randomization\n\tCom_sprintf( cls.updateChallenge, sizeof( cls.updateChallenge ), \"%i\", ((rand() << 16) ^ rand()) ^ Com_Milliseconds());\n\n\tInfo_SetValueForKey( info, \"challenge\", cls.updateChallenge );\n\tInfo_SetValueForKey( info, \"renderer\", cls.glconfig.renderer_string );\n\tInfo_SetValueForKey( info, \"rvendor\", cls.glconfig.vendor_string );\n\tInfo_SetValueForKey( info, \"version\", com_version->string );\n\n\t//If raven starts filtering for this, add this code back in\n#if 0\n\tInfo_SetValueForKey( info, \"cputype\", \"Intel Pentium IV\");\n\tInfo_SetValueForKey( info, \"mhz\", \"3000\" );\n\tInfo_SetValueForKey( info, \"memory\", \"4096\" );\n#endif\n\tInfo_SetValueForKey( info, \"joystick\", Cvar_VariableString(\"in_joystick\") );\n\tInfo_SetValueForKey( info, \"colorbits\", va(\"%d\",cls.glconfig.colorBits) );\n\n\tNET_OutOfBandPrint( NS_CLIENT, cls.updateServer, \"getmotd \\\"%s\\\"\\n\", info );\n}\n\n\n/*\n======================================================================\n\nCONSOLE COMMANDS\n\n======================================================================\n*/\n\n/*\n==================\nCL_ForwardToServer_f\n==================\n*/\nvoid CL_ForwardToServer_f( void ) {\n\tif ( cls.state != CA_ACTIVE || clc.demoplaying ) {\n\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\t// don't forward the first argument\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( Cmd_Args(), qfalse );\n\t}\n}\n\n\n/*\n==================\nCL_Disconnect_f\n==================\n*/\nvoid CL_Disconnect_f( void ) {\n\tSCR_StopCinematic();\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\tif ( cls.state != CA_DISCONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tCom_Error (ERR_DISCONNECT, \"Disconnected from server\");\n\t}\n}\n\n\n/*\n================\nCL_Reconnect_f\n\n================\n*/\nvoid CL_Reconnect_f( void ) {\n\tif ( !strlen( cl_reconnectArgs ) ) {\n\t\treturn;\n\t}\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\tCbuf_AddText( va(\"connect %s\\n\", cl_reconnectArgs ) );\n}\n\n/*\n================\nCL_Connect_f\n\n================\n*/\nvoid CL_Connect_f( void ) {\n\tchar\t*server;\n\tconst char\t*serverString;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: connect [server]\\n\");\n\t\treturn;\n\t}\n\n\t// save arguments for reconnect\n\tQ_strncpyz( cl_reconnectArgs, Cmd_Args(), sizeof( cl_reconnectArgs ) );\n\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\n\t// fire a message off to the motd server\n\tCL_RequestMotd();\n\n\t// clear any previous \"server full\" type messages\n\tclc.serverMessage[0] = 0;\n\n\tserver = Cmd_Argv (1);\n\n\tif ( com_sv_running->integer && !strcmp( server, \"localhost\" ) ) {\n\t\t// if running a local server, kill it\n\t\tSV_Shutdown( \"Server quit\\n\" );\n\t}\n\n\t// make sure a local server is killed\n\tCvar_Set( \"sv_killserver\", \"1\" );\n\tSV_Frame( 0 );\n\n\tCL_Disconnect( qtrue );\n\tCon_Close();\n\n\tQ_strncpyz( cls.servername, server, sizeof(cls.servername) );\n\n\tif (!NET_StringToAdr( cls.servername, &clc.serverAddress) ) {\n\t\tCom_Printf (\"Bad server address\\n\");\n\t\tcls.state = CA_DISCONNECTED;\n\t\treturn;\n\t}\n\tif (clc.serverAddress.port == 0) {\n\t\tclc.serverAddress.port = BigShort( PORT_SERVER );\n\t}\n\n\tserverString = NET_AdrToString(clc.serverAddress);\n\n\tCom_Printf( \"%s resolved to %s\\n\", cls.servername, serverString );\n\n\tif( cl_guidServerUniq->integer )\n\t\tCL_UpdateGUID( serverString, strlen( serverString ) );\n\telse\n\t\tCL_UpdateGUID( NULL, 0 );\n\n\t// if we aren't playing on a lan, we need to authenticate\n\tif ( NET_IsLocalAddress( clc.serverAddress ) ) {\n\t\tcls.state = CA_CHALLENGING;\n\t} else {\n\t\tcls.state = CA_CONNECTING;\n\n\t\t// Set a client challenge number that ideally is mirrored back by the server.\n\t\tclc.challenge = ((rand() << 16) ^ rand()) ^ Com_Milliseconds();\n\t}\n\n\tKey_SetCatcher( 0 );\n\tclc.connectTime = -99999;\t// CL_CheckForResend() will fire immediately\n\tclc.connectPacketCount = 0;\n\n\t// server connection string\n\tCvar_Set( \"cl_currentServerAddress\", server );\n\tCvar_Set( \"cl_currentServerIP\", serverString );\n}\n\n#define MAX_RCON_MESSAGE 1024\n\n/*\n==================\nCL_CompleteRcon\n==================\n*/\nstatic void CL_CompleteRcon( char *args, int argNum )\n{\n\tif( argNum == 2 )\n\t{\n\t\t// Skip \"rcon \"\n\t\tchar *p = Com_SkipTokens( args, 1, \" \" );\n\n\t\tif( p > args )\n\t\t\tField_CompleteCommand( p, qtrue, qtrue );\n\t}\n}\n\n/*\n=====================\nCL_Rcon_f\n\n  Send the rest of the command line over as\n  an unconnected command.\n=====================\n*/\nvoid CL_Rcon_f( void ) {\n\tchar\tmessage[MAX_RCON_MESSAGE];\n\n\tif ( !rcon_client_password->string[0] ) {\n\t\tCom_Printf( \"You must set 'rconpassword' before issuing an rcon command.\\n\" );\n\t\treturn;\n\t}\n\n\tmessage[0] = -1;\n\tmessage[1] = -1;\n\tmessage[2] = -1;\n\tmessage[3] = -1;\n\tmessage[4] = 0;\n\n\tQ_strcat (message, MAX_RCON_MESSAGE, \"rcon \");\n\n\tQ_strcat (message, MAX_RCON_MESSAGE, rcon_client_password->string);\n\tQ_strcat (message, MAX_RCON_MESSAGE, \" \");\n\n\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=543\n\tQ_strcat (message, MAX_RCON_MESSAGE, Cmd_Cmd()+5);\n\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\trcon_address = clc.netchan.remoteAddress;\n\t} else {\n\t\tif (!strlen(rconAddress->string)) {\n\t\t\tCom_Printf (\"You must either be connected,\\n\"\n\t\t\t\t\t\t\"or set the 'rconAddress' cvar\\n\"\n\t\t\t\t\t\t\"to issue rcon commands\\n\");\n\n\t\t\treturn;\n\t\t}\n\t\tNET_StringToAdr (rconAddress->string, &rcon_address);\n\t\tif (rcon_address.port == 0) {\n\t\t\trcon_address.port = BigShort (PORT_SERVER);\n\t\t}\n\t}\n\n\tNET_SendPacket (NS_CLIENT, strlen(message)+1, message, rcon_address);\n}\n\n/*\n=================\nCL_SendPureChecksums\n=================\n*/\nvoid CL_SendPureChecksums( void ) {\n\tchar cMsg[MAX_INFO_VALUE];\n\n\t// if we are pure we need to send back a command with our referenced pk3 checksums\n\tCom_sprintf(cMsg, sizeof(cMsg), \"cp %s\", FS_ReferencedPakPureChecksums());\n\n\tCL_AddReliableCommand( cMsg, qfalse );\n}\n\n/*\n=================\nCL_ResetPureClientAtServer\n=================\n*/\nvoid CL_ResetPureClientAtServer( void ) {\n\tCL_AddReliableCommand( \"vdr\", qfalse );\n}\n\n/*\n=================\nCL_Vid_Restart_f\n\nRestart the video subsystem\n\nwe also have to reload the UI and CGame because the renderer\ndoesn't know what graphics to reload\n=================\n*/\nextern bool g_nOverrideChecked;\nvoid CL_Vid_Restart_f( void ) {\n\t// Settings may have changed so stop recording now\n\tif( CL_VideoRecording( ) ) {\n\t\tCL_CloseAVI( );\n\t}\n\n\tif(clc.demorecording)\n\t\tCL_StopRecord_f();\n\n\t//rww - sort of nasty, but when a user selects a mod\n\t//from the menu all it does is a vid_restart, so we\n\t//have to check for new net overrides for the mod then.\n\tg_nOverrideChecked = false;\n\n\t// don't let them loop during the restart\n\tS_StopAllSounds();\n\t// shutdown the UI\n\tCL_ShutdownUI();\n\t// shutdown the CGame\n\tCL_ShutdownCGame();\n\t// shutdown the renderer and clear the renderer interface\n\tCL_ShutdownRef( qtrue );\n\t// client is no longer pure untill new checksums are sent\n\tCL_ResetPureClientAtServer();\n\t// clear pak references\n\tFS_ClearPakReferences( FS_UI_REF | FS_CGAME_REF );\n\t// reinitialize the filesystem if the game directory or checksum has changed\n\tFS_ConditionalRestart( clc.checksumFeed );\n\n\tcls.rendererStarted = qfalse;\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n\n\t// if not running a server clear the whole hunk\n\tif ( !com_sv_running->integer ) {\n\t\tCM_ClearMap();\n\t\t// clear the whole hunk\n\t\tHunk_Clear();\n\t}\n\telse {\n\t\t// clear all the client data on the hunk\n\t\tHunk_ClearToMark();\n\t}\n\n\t// initialize the renderer interface\n\tCL_InitRef();\n\n\t// startup all the client stuff\n\tCL_StartHunkUsers();\n\n\t// start the cgame if connected\n\tif ( cls.state > CA_CONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tcls.cgameStarted = qtrue;\n\t\tCL_InitCGame();\n\t\t// send pure checksums\n\t\tCL_SendPureChecksums();\n\t}\n}\n\n/*\n=================\nCL_Snd_Restart_f\n\nRestart the sound subsystem\nThe cgame and game must also be forced to restart because\nhandles will be invalid\n=================\n*/\n// extern void S_UnCacheDynamicMusic( void );\nvoid CL_Snd_Restart_f( void ) {\n\tS_Shutdown();\n\tS_Init();\n\n//\tS_FreeAllSFXMem();\t\t\t// These two removed by BTO (VV)\n//\tS_UnCacheDynamicMusic();\t// S_Shutdown() already does this!\n\n//\tCL_Vid_Restart_f();\n\n\textern qboolean\ts_soundMuted;\n\ts_soundMuted = qfalse;\t\t// we can play again\n\n\textern void S_RestartMusic( void );\n\tS_RestartMusic();\n}\n\n\n/*\n==================\nCL_PK3List_f\n==================\n*/\nvoid CL_OpenedPK3List_f( void ) {\n\tCom_Printf(\"Opened PK3 Names: %s\\n\", FS_LoadedPakNames());\n}\n\n/*\n==================\nCL_PureList_f\n==================\n*/\nvoid CL_ReferencedPK3List_f( void ) {\n\tCom_Printf(\"Referenced PK3 Names: %s\\n\", FS_ReferencedPakNames());\n}\n\n/*\n==================\nCL_Configstrings_f\n==================\n*/\nvoid CL_Configstrings_f( void ) {\n\tint\t\ti;\n\tint\t\tofs;\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf( \"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tofs = cl.gameState.stringOffsets[ i ];\n\t\tif ( !ofs ) {\n\t\t\tcontinue;\n\t\t}\n\t\tCom_Printf( \"%4i: %s\\n\", i, cl.gameState.stringData + ofs );\n\t}\n}\n\n/*\n==============\nCL_Clientinfo_f\n==============\n*/\nvoid CL_Clientinfo_f( void ) {\n\tCom_Printf( \"--------- Client Information ---------\\n\" );\n\tCom_Printf( \"state: %i\\n\", cls.state );\n\tCom_Printf( \"Server: %s\\n\", cls.servername );\n\tCom_Printf (\"User info settings:\\n\");\n\tInfo_Print( Cvar_InfoString( CVAR_USERINFO ) );\n\tCom_Printf( \"--------------------------------------\\n\" );\n}\n\n\n//====================================================================\n\n/*\n=================\nCL_DownloadsComplete\n\nCalled when all downloading has been completed\n=================\n*/\nvoid CL_DownloadsComplete( void ) {\n\n\t// if we downloaded files we need to restart the file system\n\tif (clc.downloadRestart) {\n\t\tclc.downloadRestart = qfalse;\n\n\t\tFS_Restart(clc.checksumFeed); // We possibly downloaded a pak, restart the file system to load it\n\n\t\t// inform the server so we get new gamestate info\n\t\tCL_AddReliableCommand( \"donedl\", qfalse );\n\n\t\t// by sending the donedl command we request a new gamestate\n\t\t// so we don't want to load stuff yet\n\t\treturn;\n\t}\n\n\t// let the client game init and load data\n\tcls.state = CA_LOADING;\n\n\t// Pump the loop, this may change gamestate!\n\tCom_EventLoop();\n\n\t// if the gamestate was changed by calling Com_EventLoop\n\t// then we loaded everything already and we don't want to do it again.\n\tif ( cls.state != CA_LOADING ) {\n\t\treturn;\n\t}\n\n\t// starting to load a map so we get out of full screen ui mode\n\tCvar_Set(\"r_uiFullScreen\", \"0\");\n\n\t// flush client memory and start loading stuff\n\t// this will also (re)load the UI\n\t// if this is a local client then only the client part of the hunk\n\t// will be cleared, note that this is done after the hunk mark has been set\n\tCL_FlushMemory();\n\n\t// initialize the CGame\n\tcls.cgameStarted = qtrue;\n\tCL_InitCGame();\n\n\t// set pure checksums\n\tCL_SendPureChecksums();\n\n\tCL_WritePacket();\n\tCL_WritePacket();\n\tCL_WritePacket();\n}\n\n/*\n=================\nCL_BeginDownload\n\nRequests a file to download from the server.  Stores it in the current\ngame directory.\n=================\n*/\n\nvoid CL_BeginDownload( const char *localName, const char *remoteName ) {\n\n\tCom_DPrintf(\"***** CL_BeginDownload *****\\n\"\n\t\t\t\t\"Localname: %s\\n\"\n\t\t\t\t\"Remotename: %s\\n\"\n\t\t\t\t\"****************************\\n\", localName, remoteName);\n\n\tQ_strncpyz ( clc.downloadName, localName, sizeof(clc.downloadName) );\n\tCom_sprintf( clc.downloadTempName, sizeof(clc.downloadTempName), \"%s.tmp\", localName );\n\n\t// Set so UI gets access to it\n\tCvar_Set( \"cl_downloadName\", remoteName );\n\tCvar_Set( \"cl_downloadSize\", \"0\" );\n\tCvar_Set( \"cl_downloadCount\", \"0\" );\n\tCvar_SetValue( \"cl_downloadTime\", (float) cls.realtime );\n\n\tclc.downloadBlock = 0; // Starting new file\n\tclc.downloadCount = 0;\n\n\tCL_AddReliableCommand( va(\"download %s\", remoteName), qfalse );\n}\n\n/*\n=================\nCL_NextDownload\n\nA download completed or failed\n=================\n*/\nvoid CL_NextDownload(void) {\n\tchar *s;\n\tchar *remoteName, *localName;\n\n\t// A download has finished, check whether this matches a referenced checksum\n\tif(*clc.downloadName)\n\t{\n\t\tchar *zippath = FS_BuildOSPath(Cvar_VariableString(\"fs_homepath\"), clc.downloadName, \"\");\n\t\tzippath[strlen(zippath)-1] = '\\0';\n\n\t\tif(!FS_CompareZipChecksum(zippath))\n\t\t\tCom_Error(ERR_DROP, \"Incorrect checksum for file: %s\", clc.downloadName);\n\t}\n\n\t*clc.downloadTempName = *clc.downloadName = 0;\n\tCvar_Set(\"cl_downloadName\", \"\");\n\n\t// We are looking to start a download here\n\tif (*clc.downloadList) {\n\t\ts = clc.downloadList;\n\n\t\t// format is:\n\t\t//  @remotename@localname@remotename@localname, etc.\n\n\t\tif (*s == '@')\n\t\t\ts++;\n\t\tremoteName = s;\n\n\t\tif ( (s = strchr(s, '@')) == NULL ) {\n\t\t\tCL_DownloadsComplete();\n\t\t\treturn;\n\t\t}\n\n\t\t*s++ = 0;\n\t\tlocalName = s;\n\t\tif ( (s = strchr(s, '@')) != NULL )\n\t\t\t*s++ = 0;\n\t\telse\n\t\t\ts = localName + strlen(localName); // point at the nul byte\n\n\t\tif (!cl_allowDownload->integer) {\n\t\t\tCom_Error(ERR_DROP, \"UDP Downloads are disabled on your client. (cl_allowDownload is %d)\", cl_allowDownload->integer);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tCL_BeginDownload( localName, remoteName );\n\t\t}\n\n\t\tclc.downloadRestart = qtrue;\n\n\t\t// move over the rest\n\t\tmemmove( clc.downloadList, s, strlen(s) + 1);\n\n\t\treturn;\n\t}\n\n\tCL_DownloadsComplete();\n}\n\n/*\n=================\nCL_InitDownloads\n\nAfter receiving a valid game state, we valid the cgame and local zip files here\nand determine if we need to download them\n=================\n*/\nvoid CL_InitDownloads(void) {\n  char missingfiles[1024];\n\n\tif ( !cl_allowDownload->integer )\n\t{\n\t\t// autodownload is disabled on the client\n\t\t// but it's possible that some referenced files on the server are missing\n\t\tif (FS_ComparePaks( missingfiles, sizeof( missingfiles ), qfalse ) )\n\t\t{\n\t\t\t// NOTE TTimo I would rather have that printed as a modal message box\n\t\t\t//   but at this point while joining the game we don't know wether we will successfully join or not\n\t\t\tCom_Printf( \"\\nWARNING: You are missing some files referenced by the server:\\n%s\"\n\t\t\t\t\"You might not be able to join the game\\n\"\n\t\t\t\t\"Go to the setting menu to turn on autodownload, or get the file elsewhere\\n\\n\", missingfiles );\n\t\t}\n\t}\n\telse if ( FS_ComparePaks( clc.downloadList, sizeof( clc.downloadList ) , qtrue ) ) {\n\n\t\tCom_Printf(\"Need paks: %s\\n\", clc.downloadList );\n\n\t\tif ( *clc.downloadList ) {\n\t\t\t// if autodownloading is not enabled on the server\n\t\t\tcls.state = CA_CONNECTED;\n\n\t\t\t*clc.downloadTempName = *clc.downloadName = 0;\n\t\t\tCvar_Set( \"cl_downloadName\", \"\" );\n\n\t\t\tCL_NextDownload();\n\t\t\treturn;\n\t\t}\n\n\t}\n\tCL_DownloadsComplete();\n}\n\n/*\n=================\nCL_CheckForResend\n\nResend a connect message if the last one has timed out\n=================\n*/\nvoid CL_CheckForResend( void ) {\n\tint\t\tport;\n\tchar\tinfo[MAX_INFO_STRING];\n\tchar\tdata[MAX_INFO_STRING+10];\n\n\t// don't send anything if playing back a demo\n\tif ( clc.demoplaying ) {\n\t\treturn;\n\t}\n\n\t// resend if we haven't gotten a reply yet\n\tif ( cls.state != CA_CONNECTING && cls.state != CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\n\tif ( cls.realtime - clc.connectTime < RETRANSMIT_TIMEOUT ) {\n\t\treturn;\n\t}\n\n\tclc.connectTime = cls.realtime;\t// for retransmit requests\n\tclc.connectPacketCount++;\n\n\n\tswitch ( cls.state ) {\n\tcase CA_CONNECTING:\n\t\t// requesting a challenge\n\n\t\t// The challenge request shall be followed by a client challenge so no malicious server can hijack this connection.\n\t\tCom_sprintf(data, sizeof(data), \"getchallenge %d\", clc.challenge);\n\n\t\tNET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, data);\n\t\tbreak;\n\n\tcase CA_CHALLENGING:\n\t\t// sending back the challenge\n\t\tport = (int) Cvar_VariableValue (\"net_qport\");\n\n\t\tQ_strncpyz( info, Cvar_InfoString( CVAR_USERINFO ), sizeof( info ) );\n\t\tInfo_SetValueForKey( info, \"protocol\", va(\"%i\", PROTOCOL_VERSION ) );\n\t\tInfo_SetValueForKey( info, \"qport\", va(\"%i\", port ) );\n\t\tInfo_SetValueForKey( info, \"challenge\", va(\"%i\", clc.challenge ) );\n\n\t\tCom_sprintf(data, sizeof(data), \"connect \\\"%s\\\"\", info );\n\t\tNET_OutOfBandData( NS_CLIENT, clc.serverAddress, (byte *)data, strlen(data) );\n\n\t\t// the most current userinfo has been sent, so watch for any\n\t\t// newer changes to userinfo variables\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tbreak;\n\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"CL_CheckForResend: bad cls.state\" );\n\t}\n}\n\n\n/*\n===================\nCL_DisconnectPacket\n\nSometimes the server can drop the client and the netchan based\ndisconnect can be lost.  If the client continues to send packets\nto the server, the server will send out of band disconnect packets\nto the client so it doesn't have to wait for the full timeout period.\n===================\n*/\nvoid CL_DisconnectPacket( netadr_t from ) {\n\tif ( cls.state < CA_AUTHORIZING ) {\n\t\treturn;\n\t}\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\treturn;\n\t}\n\n\t// if we have received packets within three seconds, ignore it\n\t// (it might be a malicious spoof)\n\tif ( cls.realtime - clc.lastPacketTime < 3000 ) {\n\t\treturn;\n\t}\n\n\t// drop the connection (FIXME: connection dropped dialog)\n\tCom_Printf( \"Server disconnected for unknown reason\\n\" );\n\n\tCL_Disconnect( qtrue );\n}\n\n\n/*\n===================\nCL_MotdPacket\n\n===================\n*/\nvoid CL_MotdPacket( netadr_t from ) {\n\tchar\t*challenge;\n\tchar\t*info;\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, cls.updateServer ) ) {\n\t\treturn;\n\t}\n\n\tinfo = Cmd_Argv(1);\n\n\t// check challenge\n\tchallenge = Info_ValueForKey( info, \"challenge\" );\n\tif ( strcmp( challenge, cls.updateChallenge ) ) {\n\t\treturn;\n\t}\n\n\tchallenge = Info_ValueForKey( info, \"motd\" );\n\n\tQ_strncpyz( cls.updateInfoString, info, sizeof( cls.updateInfoString ) );\n\tCvar_Set( \"cl_motdString\", challenge );\n}\n\n/*\n===================\nCL_InitServerInfo\n===================\n*/\nvoid CL_InitServerInfo( serverInfo_t *server, netadr_t *address ) {\n\tserver->adr = *address;\n\tserver->clients = 0;\n\tserver->hostName[0] = '\\0';\n\tserver->mapName[0] = '\\0';\n\tserver->maxClients = 0;\n\tserver->maxPing = 0;\n\tserver->minPing = 0;\n\tserver->netType = 0;\n\tserver->needPassword = qfalse;\n\tserver->trueJedi = 0;\n\tserver->weaponDisable = 0;\n\tserver->forceDisable = 0;\n\tserver->ping = -1;\n\tserver->game[0] = '\\0';\n\tserver->gameType = 0;\n\tserver->humans = server->bots = 0;\n}\n\n#define MAX_SERVERSPERPACKET\t256\n\n/*\n===================\nCL_ServersResponsePacket\n===================\n*/\nvoid CL_ServersResponsePacket( const netadr_t *from, msg_t *msg ) {\n\tint\t\t\t\ti, j, count, total;\n\tnetadr_t addresses[MAX_SERVERSPERPACKET];\n\tint\t\t\t\tnumservers;\n\tbyte*\t\t\tbuffptr;\n\tbyte*\t\t\tbuffend;\n\n\tCom_Printf(\"CL_ServersResponsePacket\\n\");\n\n\tif (cls.numglobalservers == -1) {\n\t\t// state to detect lack of servers or lack of response\n\t\tcls.numglobalservers = 0;\n\t\tcls.numGlobalServerAddresses = 0;\n\t}\n\n\t// parse through server response string\n\tnumservers = 0;\n\tbuffptr    = msg->data;\n\tbuffend    = buffptr + msg->cursize;\n\n\t// advance to initial token\n\tdo\n\t{\n\t\tif(*buffptr == '\\\\')\n\t\t\tbreak;\n\n\t\tbuffptr++;\n\t} while (buffptr < buffend);\n\n\twhile (buffptr + 1 < buffend)\n\t{\n\t\t// IPv4 address\n\t\tif (*buffptr == '\\\\')\n\t\t{\n\t\t\tbuffptr++;\n\n\t\t\tif (buffend - buffptr < (int)(sizeof(addresses[numservers].ip) + sizeof(addresses[numservers].port) + 1))\n\t\t\t\tbreak;\n\n\t\t\tfor(size_t i = 0; i < sizeof(addresses[numservers].ip); i++)\n\t\t\t\taddresses[numservers].ip[i] = *buffptr++;\n\n\t\t\taddresses[numservers].type = NA_IP;\n\t\t}\n\t\telse\n\t\t\t// syntax error!\n\t\t\tbreak;\n\n\t\t// parse out port\n\t\taddresses[numservers].port = (*buffptr++) << 8;\n\t\taddresses[numservers].port += *buffptr++;\n\t\taddresses[numservers].port = BigShort( addresses[numservers].port );\n\n\t\t// syntax check\n\t\tif (*buffptr != '\\\\')\n\t\t\tbreak;\n\n\t\tnumservers++;\n\t\tif (numservers >= MAX_SERVERSPERPACKET)\n\t\t\tbreak;\n\t}\n\n\tcount = cls.numglobalservers;\n\n\tfor (i = 0; i < numservers && count < MAX_GLOBAL_SERVERS; i++) {\n\t\t// build net address\n\t\tserverInfo_t *server = &cls.globalServers[count];\n\n\t\t// Tequila: It's possible to have sent many master server requests. Then\n\t\t// we may receive many times the same addresses from the master server.\n\t\t// We just avoid to add a server if it is still in the global servers list.\n\t\tfor (j = 0; j < count; j++)\n\t\t{\n\t\t\tif (NET_CompareAdr(cls.globalServers[j].adr, addresses[i]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < count)\n\t\t\tcontinue;\n\n\t\tCL_InitServerInfo( server, &addresses[i] );\n\t\t// advance to next slot\n\t\tcount++;\n\t}\n\n\t// if getting the global list\n\tif ( count >= MAX_GLOBAL_SERVERS && cls.numGlobalServerAddresses < MAX_GLOBAL_SERVERS )\n\t{\n\t\t// if we couldn't store the servers in the main list anymore\n\t\tfor (; i < numservers && cls.numGlobalServerAddresses < MAX_GLOBAL_SERVERS; i++)\n\t\t{\n\t\t\t// just store the addresses in an additional list\n\t\t\tcls.globalServerAddresses[cls.numGlobalServerAddresses++] = addresses[i];\n\t\t}\n\t}\n\n\tcls.numglobalservers = count;\n\ttotal = count + cls.numGlobalServerAddresses;\n\n\tCom_Printf(\"%d servers parsed (total %d)\\n\", numservers, total);\n}\n\n#ifndef MAX_STRINGED_SV_STRING\n#define MAX_STRINGED_SV_STRING 1024\n#endif\nstatic void CL_CheckSVStringEdRef(char *buf, const char *str)\n{ //I don't really like doing this. But it utilizes the system that was already in place.\n\tint i = 0;\n\tint b = 0;\n\tint strLen = 0;\n\tqboolean gotStrip = qfalse;\n\n\tif (!str || !str[0])\n\t{\n\t\tif (str)\n\t\t{\n\t\t\tstrcpy(buf, str);\n\t\t}\n\t\treturn;\n\t}\n\n\tstrcpy(buf, str);\n\n\tstrLen = strlen(str);\n\n\tif (strLen >= MAX_STRINGED_SV_STRING)\n\t{\n\t\treturn;\n\t}\n\n\twhile (i < strLen && str[i])\n\t{\n\t\tgotStrip = qfalse;\n\n\t\tif (str[i] == '@' && (i+1) < strLen)\n\t\t{\n\t\t\tif (str[i+1] == '@' && (i+2) < strLen)\n\t\t\t{\n\t\t\t\tif (str[i+2] == '@' && (i+3) < strLen)\n\t\t\t\t{ //@@@ should mean to insert a stringed reference here, so insert it into buf at the current place\n\t\t\t\t\tchar stripRef[MAX_STRINGED_SV_STRING];\n\t\t\t\t\tint r = 0;\n\n\t\t\t\t\twhile (i < strLen && str[i] == '@')\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (i < strLen && str[i] && str[i] != ' ' && str[i] != ':' && str[i] != '.' && str[i] != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tstripRef[r] = str[i];\n\t\t\t\t\t\tr++;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tstripRef[r] = 0;\n\n\t\t\t\t\tbuf[b] = 0;\n\t\t\t\t\tQ_strcat(buf, MAX_STRINGED_SV_STRING, SE_GetString(va(\"MP_SVGAME_%s\", stripRef)));\n\t\t\t\t\tb = strlen(buf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!gotStrip)\n\t\t{\n\t\t\tbuf[b] = str[i];\n\t\t\tb++;\n\t\t}\n\t\ti++;\n\t}\n\n\tbuf[b] = 0;\n}\n\n\n/*\n=================\nCL_ConnectionlessPacket\n\nResponses to broadcasts, etc\n=================\n*/\nvoid CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tchar\t*c;\n\tint challenge = 0;\n\n\tMSG_BeginReadingOOB( msg );\n\tMSG_ReadLong( msg );\t// skip the -1\n\n\ts = MSG_ReadStringLine( msg );\n\n\tCmd_TokenizeString( s );\n\n\tc = Cmd_Argv(0);\n\n\tCom_DPrintf (\"CL packet %s: %s\\n\", NET_AdrToString(from), c);\n\n\t// challenge from the server we are connecting to\n\tif ( !Q_stricmp(c, \"challengeResponse\") )\n\t{\n\t\tif ( cls.state != CA_CONNECTING )\n\t\t{\n\t\t\tCom_Printf( \"Unwanted challenge response received.  Ignored.\\n\" );\n\t\t\treturn;\n\t\t}\n\n\t\tc = Cmd_Argv(2);\n\t\tif(*c)\n\t\t\tchallenge = atoi(c);\n\n\t\tif(!NET_CompareAdr(from, clc.serverAddress))\n\t\t{\n\t\t\t// This challenge response is not coming from the expected address.\n\t\t\t// Check whether we have a matching client challenge to prevent\n\t\t\t// connection hi-jacking.\n\n\t\t\tif(!*c || challenge != clc.challenge)\n\t\t\t{\n\t\t\t\tCom_DPrintf(\"Challenge response received from unexpected source. Ignored.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// start sending challenge response instead of challenge request packets\n\t\tclc.challenge = atoi(Cmd_Argv(1));\n\t\tcls.state = CA_CHALLENGING;\n\t\tclc.connectPacketCount = 0;\n\t\tclc.connectTime = -99999;\n\n\t\t// take this address as the new server address.  This allows\n\t\t// a server proxy to hand off connections to multiple servers\n\t\tclc.serverAddress = from;\n\t\tCom_DPrintf (\"challengeResponse: %d\\n\", clc.challenge);\n\t\treturn;\n\t}\n\n\t// server connection\n\tif ( !Q_stricmp(c, \"connectResponse\") ) {\n\t\tif ( cls.state >= CA_CONNECTED ) {\n\t\t\tCom_Printf (\"Dup connect received. Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( cls.state != CA_CHALLENGING ) {\n\t\t\tCom_Printf (\"connectResponse packet while not connecting. Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( !NET_CompareAdr( from, clc.serverAddress ) ) {\n\t\t\tCom_Printf( \"connectResponse from wrong address. Ignored.\\n\" );\n\t\t\treturn;\n\t\t}\n\t\tNetchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableValue( \"net_qport\" ) );\n\t\tcls.state = CA_CONNECTED;\n\t\tclc.lastPacketSentTime = -9999;\t\t// send first packet immediately\n\t\treturn;\n\t}\n\n\t// server responding to an info broadcast\n\tif ( !Q_stricmp(c, \"infoResponse\") ) {\n\t\tCL_ServerInfoPacket( from, msg );\n\t\treturn;\n\t}\n\n\t// server responding to a get playerlist\n\tif ( !Q_stricmp(c, \"statusResponse\") ) {\n\t\tCL_ServerStatusResponse( from, msg );\n\t\treturn;\n\t}\n\n\t// a disconnect message from the server, which will happen if the server\n\t// dropped the connection but it is still getting packets from us\n\tif (!Q_stricmp(c, \"disconnect\")) {\n\t\tCL_DisconnectPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !Q_stricmp(c, \"echo\") ) {\n\t\tNET_OutOfBandPrint( NS_CLIENT, from, \"%s\", Cmd_Argv(1) );\n\t\treturn;\n\t}\n\n\t// cd check\n\tif ( !Q_stricmp(c, \"keyAuthorize\") ) {\n\t\t// we don't use these now, so dump them on the floor\n\t\treturn;\n\t}\n\n\t// global MOTD from id\n\tif ( !Q_stricmp(c, \"motd\") ) {\n\t\tCL_MotdPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !Q_stricmp(c, \"print\") )\n\t{\n\t\t// NOTE: we may have to add exceptions for auth and update servers\n\t\tif (NET_CompareAdr(from, clc.serverAddress) || NET_CompareAdr(from, rcon_address))\n\t\t{\n\t\t\tchar sTemp[MAX_STRINGED_SV_STRING];\n\n\t\t\ts = MSG_ReadString( msg );\n\t\t\tCL_CheckSVStringEdRef(sTemp, s);\n\t\t\tQ_strncpyz( clc.serverMessage, sTemp, sizeof( clc.serverMessage ) );\n\t\t\tCom_Printf( \"%s\", sTemp );\n\t\t}\n\t\treturn;\n\t}\n\n\t// list of servers sent back by a master server (classic)\n\tif ( !Q_strncmp(c, \"getserversResponse\", 18) ) {\n\t\tCL_ServersResponsePacket( &from, msg );\n\t\treturn;\n\t}\n\n\tCom_DPrintf (\"Unknown connectionless packet command.\\n\");\n}\n\n\n/*\n=================\nCL_PacketEvent\n\nA packet has arrived from the main event loop\n=================\n*/\nvoid CL_PacketEvent( netadr_t from, msg_t *msg ) {\n\tint\t\theaderBytes;\n\n\tclc.lastPacketTime = cls.realtime;\n\n\tif ( msg->cursize >= 4 && *(int *)msg->data == -1 ) {\n\t\tCL_ConnectionlessPacket( from, msg );\n\t\treturn;\n\t}\n\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\t\t// can't be a valid sequenced packet\n\t}\n\n\tif ( msg->cursize < 4 ) {\n\t\tCom_Printf (\"%s: Runt packet\\n\",NET_AdrToString( from ));\n\t\treturn;\n\t}\n\n\t//\n\t// packet from server\n\t//\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\tCom_DPrintf (\"%s:sequenced packet without connection\\n\"\n\t\t\t,NET_AdrToString( from ) );\n\t\t// FIXME: send a client disconnect?\n\t\treturn;\n\t}\n\n\tif (!CL_Netchan_Process( &clc.netchan, msg) ) {\n\t\treturn;\t\t// out of order, duplicated, etc\n\t}\n\n\t// the header is different lengths for reliable and unreliable messages\n\theaderBytes = msg->readcount;\n\n\t// track the last message received so it can be returned in\n\t// client messages, allowing the server to detect a dropped\n\t// gamestate\n\tclc.serverMessageSequence = LittleLong( *(int *)msg->data );\n\n\tclc.lastPacketTime = cls.realtime;\n\tCL_ParseServerMessage( msg );\n\n\t//\n\t// we don't know if it is ok to save a demo message until\n\t// after we have parsed the frame\n\t//\n\tif ( clc.demorecording && !clc.demowaiting ) {\n\t\tCL_WriteDemoMessage( msg, headerBytes );\n\t}\n}\n\n/*\n==================\nCL_CheckTimeout\n\n==================\n*/\nvoid CL_CheckTimeout( void ) {\n\t//\n\t// check timeout\n\t//\n\tif ( ( !CL_CheckPaused() || !sv_paused->integer )\n\t\t&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC\n\t    && cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {\n\t\tif (++cl.timeoutcount > 5) {\t// timeoutcount saves debugger\n\t\t\tconst char *psTimedOut = SE_GetString(\"MP_SVGAME_SERVER_CONNECTION_TIMED_OUT\");\n\t\t\tCom_Printf (\"\\n%s\\n\",psTimedOut);\n\t\t\tCom_Error(ERR_DROP, psTimedOut);\n\t\t\t//CL_Disconnect( qtrue );\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tcl.timeoutcount = 0;\n\t}\n}\n\n/*\n==================\nCL_CheckPaused\nCheck whether client has been paused.\n==================\n*/\nqboolean CL_CheckPaused(void)\n{\n\t// if cl_paused->modified is set, the cvar has only been changed in\n\t// this frame. Keep paused in this frame to ensure the server doesn't\n\t// lag behind.\n\tif(cl_paused->integer || cl_paused->modified)\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n//============================================================================\n\n/*\n==================\nCL_CheckUserinfo\n\n==================\n*/\nvoid CL_CheckUserinfo( void ) {\n\t// don't add reliable commands when not yet connected\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\n\t}\n\t// don't overflow the reliable command buffer when paused\n\tif ( CL_CheckPaused() ) {\n\t\treturn;\n\t}\n\t// send a reliable userinfo update if needed\n\tif ( cvar_modifiedFlags & CVAR_USERINFO ) {\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tCL_AddReliableCommand( va(\"userinfo \\\"%s\\\"\", Cvar_InfoString( CVAR_USERINFO ) ), qfalse );\n\t}\n\n}\n\n/*\n==================\nCL_Frame\n\n==================\n*/\nstatic unsigned int frameCount;\nstatic float avgFrametime=0.0;\nextern void SE_CheckForLanguageUpdates(void);\nvoid CL_Frame ( int msec ) {\n\tqboolean takeVideoFrame = qfalse;\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tSE_CheckForLanguageUpdates();\t// will take zero time to execute unless language changes, then will reload strings.\n\t\t\t\t\t\t\t\t\t//\tof course this still doesn't work for menus...\n\n\tif ( cls.state == CA_DISCONNECTED && !( Key_GetCatcher( ) & KEYCATCH_UI )\n\t\t&& !com_sv_running->integer && cls.uiStarted ) {\n\t\t// if disconnected, bring up the menu\n\t\tS_StopAllSounds();\n\t\tUIVM_SetActiveMenu( UIMENU_MAIN );\n\t}\n\n\t// if recording an avi, lock to a fixed fps\n\tif ( CL_VideoRecording( ) && cl_aviFrameRate->integer && msec) {\n\t\tif ( cls.state == CA_ACTIVE || cl_forceavidemo->integer) {\n\t\t\tfloat fps = Q_min(cl_aviFrameRate->value * com_timescale->value, 1000.0f);\n\t\t\tfloat frameDuration = Q_max(1000.0f / fps, 1.0f) + clc.aviVideoFrameRemainder;\n\t\t\ttakeVideoFrame = qtrue;\n\n\t\t\tmsec = (int)frameDuration;\n\t\t\tclc.aviVideoFrameRemainder = frameDuration - msec;\n\t\t}\n\t}\n\n\t// save the msec before checking pause\n\tcls.realFrametime = msec;\n\n\t// decide the simulation time\n\tcls.frametime = msec;\n\tif(cl_framerate->integer)\n\t{\n\t\tavgFrametime+=msec;\n\t\tchar mess[256];\n\t\tif(!(frameCount&0x1f))\n\t\t{\n\t\t\tCom_sprintf(mess,sizeof(mess),\"Frame rate=%f\\n\\n\",1000.0f*(1.0/(avgFrametime/32.0f)));\n\t//\t\tCom_OPrintf(\"%s\", mess);\n\t\t\tCom_Printf(\"%s\", mess);\n\t\t\tavgFrametime=0.0f;\n\t\t}\n\t\tframeCount++;\n\t}\n\n\tcls.realtime += cls.frametime;\n\n\tif ( cl_timegraph->integer ) {\n\t\tSCR_DebugGraph ( cls.realFrametime * 0.25, 0 );\n\t}\n\n\t// see if we need to update any userinfo\n\tCL_CheckUserinfo();\n\n\t// if we haven't gotten a packet in a long time,\n\t// drop the connection\n\tCL_CheckTimeout();\n\n\t// send intentions now\n\tCL_SendCmd();\n\n\t// resend a connection request if necessary\n\tCL_CheckForResend();\n\n\t// decide on the serverTime to render\n\tCL_SetCGameTime();\n\n\t// update the screen\n\tSCR_UpdateScreen();\n\n\t// update audio\n\tS_Update();\n\n\t// advance local effects for next frame\n\tSCR_RunCinematic();\n\n\tCon_RunConsole();\n\n\t// reset the heap for Ghoul2 vert transform space gameside\n\tif (G2VertSpaceServer)\n\t{\n\t\tG2VertSpaceServer->ResetHeap();\n\t}\n\n\tcls.framecount++;\n\n\tif ( takeVideoFrame ) {\n\t\t// save the current screen\n\t\tCL_TakeVideoFrame( );\n\t}\n}\n\n\n//============================================================================\n\n/*\n================\nCL_RefPrintf\n\nDLL glue\n================\n*/\nvoid QDECL CL_RefPrintf( int print_level, const char *fmt, ...) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf(msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tif ( print_level == PRINT_ALL ) {\n\t\tCom_Printf (\"%s\", msg);\n\t} else if ( print_level == PRINT_WARNING ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"%s\", msg);\t\t// yellow\n\t} else if ( print_level == PRINT_DEVELOPER ) {\n\t\tCom_DPrintf (S_COLOR_RED \"%s\", msg);\t\t// red\n\t}\n}\n\n\n\n/*\n============\nCL_ShutdownRef\n============\n*/\nstatic void CL_ShutdownRef( qboolean restarting ) {\n\tif ( re )\n\t{\n\t\tif ( re->Shutdown )\n\t\t{\n\t\t\tre->Shutdown( qtrue, restarting );\n\t\t}\n\t}\n\n\tre = NULL;\n\n\tif ( rendererLib != NULL ) {\n\t\tSys_UnloadDll (rendererLib);\n\t\trendererLib = NULL;\n\t}\n}\n\n/*\n============\nCL_InitRenderer\n============\n*/\nvoid CL_InitRenderer( void ) {\n\t// this sets up the renderer and calls R_Init\n\tre->BeginRegistration( &cls.glconfig );\n\n\t// load character sets\n\tcls.charSetShader = re->RegisterShaderNoMip(\"gfx/2d/charsgrid_med\");\n\n\tcls.whiteShader = re->RegisterShader( \"white\" );\n\tcls.consoleShader = re->RegisterShader( \"console\" );\n\tg_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;\n\tg_consoleField.widthInChars = g_console_field_width;\n}\n\n/*\n============================\nCL_StartHunkUsers\n\nAfter the server has cleared the hunk, these will need to be restarted\nThis is the only place that any of these functions are called from\n============================\n*/\nvoid CL_StartHunkUsers( void ) {\n\tif (!com_cl_running) {\n\t\treturn;\n\t}\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif ( !cls.rendererStarted ) {\n\t\tcls.rendererStarted = qtrue;\n\t\tCL_InitRenderer();\n\t}\n\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n\n\tif ( !cls.uiStarted ) {\n\t\tcls.uiStarted = qtrue;\n\t\tCL_InitUI();\n\t}\n}\n\n/*\n============\nCL_InitRef\n============\n*/\nqboolean Com_TheHunkMarkHasBeenMade(void);\n\n//qcommon/cm_load.cpp\nextern void *gpvCachedMapDiskImage;\nextern qboolean gbUsingCachedMapDataRightNow;\n\nstatic char *GetSharedMemory( void ) { return cl.mSharedMemory; }\nstatic vm_t *GetCurrentVM( void ) { return currentVM; }\nstatic qboolean CGVMLoaded( void ) { return (qboolean)cls.cgameStarted; }\nstatic void *CM_GetCachedMapDiskImage( void ) { return gpvCachedMapDiskImage; }\nstatic void CM_SetCachedMapDiskImage( void *ptr ) { gpvCachedMapDiskImage = ptr; }\nstatic void CM_SetUsingCache( qboolean usingCache ) { gbUsingCachedMapDataRightNow = usingCache; }\n\n#define G2_VERT_SPACE_SERVER_SIZE 256\nIHeapAllocator *G2VertSpaceServer = NULL;\nCMiniHeap IHeapAllocator_singleton(G2_VERT_SPACE_SERVER_SIZE * 1024);\n\nstatic IHeapAllocator *GetG2VertSpaceServer( void ) {\n\treturn G2VertSpaceServer;\n}\n\n#define DEFAULT_RENDER_LIBRARY \"rd-vanilla\"\n\nvoid CL_InitRef( void ) {\n\tstatic refimport_t ri;\n\trefexport_t\t*ret;\n\tGetRefAPI_t\tGetRefAPI;\n\tchar\t\tdllName[MAX_OSPATH];\n\n\tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n\n\tcl_renderer = Cvar_Get( \"cl_renderer\", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH, \"Which renderer library to use\" );\n\n\tCom_sprintf( dllName, sizeof( dllName ), \"%s_\" ARCH_STRING DLL_EXT, cl_renderer->string );\n\n\tif( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) )\n\t{\n\t\tCom_Printf( \"failed: trying to load fallback renderer\\n\" );\n\t\tCvar_ForceReset( \"cl_renderer\" );\n\n\t\tCom_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY \"_\" ARCH_STRING DLL_EXT );\n\t\trendererLib = Sys_LoadDll( dllName, qfalse );\n\t}\n\n\tif ( !rendererLib ) {\n\t\tCom_Error( ERR_FATAL, \"Failed to load renderer\\n\" );\n\t}\n\n\tmemset( &ri, 0, sizeof( ri ) );\n\n\tGetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, \"GetRefAPI\" );\n\tif ( !GetRefAPI )\n\t\tCom_Error( ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\", Sys_LibraryError() );\n\n\t//set up the import table\n\tri.Printf = CL_RefPrintf;\n\tri.Error = Com_Error;\n\tri.OPrintf = Com_OPrintf;\n\tri.Milliseconds = Sys_Milliseconds2; //FIXME: unix+mac need this\n\tri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;\n\tri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;\n\tri.Hunk_Alloc = Hunk_Alloc;\n\tri.Hunk_MemoryRemaining = Hunk_MemoryRemaining;\n\tri.Z_Malloc = Z_Malloc;\n\tri.Z_Free = Z_Free;\n\tri.Z_MemSize = Z_MemSize;\n\tri.Z_MorphMallocTag = Z_MorphMallocTag;\n\tri.Cmd_ExecuteString = Cmd_ExecuteString;\n\tri.Cmd_Argc = Cmd_Argc;\n\tri.Cmd_Argv = Cmd_Argv;\n\tri.Cmd_ArgsBuffer = Cmd_ArgsBuffer;\n\tri.Cmd_AddCommand = Cmd_AddCommand;\n\tri.Cmd_RemoveCommand = Cmd_RemoveCommand;\n\tri.Cvar_Set = Cvar_Set;\n\tri.Cvar_Get = Cvar_Get;\n\tri.Cvar_SetValue = Cvar_SetValue;\n\tri.Cvar_CheckRange = Cvar_CheckRange;\n\tri.Cvar_VariableStringBuffer = Cvar_VariableStringBuffer;\n\tri.Cvar_VariableString = Cvar_VariableString;\n\tri.Cvar_VariableValue = Cvar_VariableValue;\n\tri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;\n\tri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;\n\tri.SE_GetString = SE_GetString;\n\tri.FS_FreeFile = FS_FreeFile;\n\tri.FS_FreeFileList = FS_FreeFileList;\n\tri.FS_Read = FS_Read;\n\tri.FS_ReadFile = FS_ReadFile;\n\tri.FS_FCloseFile = FS_FCloseFile;\n\tri.FS_FOpenFileRead = FS_FOpenFileRead;\n\tri.FS_FOpenFileWrite = FS_FOpenFileWrite;\n\tri.FS_FOpenFileByMode = FS_FOpenFileByMode;\n\tri.FS_FileExists = FS_FileExists;\n\tri.FS_FileIsInPAK = FS_FileIsInPAK;\n\tri.FS_ListFiles = FS_ListFiles;\n\tri.FS_Write = FS_Write;\n\tri.FS_WriteFile = FS_WriteFile;\n\tri.CM_BoxTrace = CM_BoxTrace;\n\tri.CM_DrawDebugSurface = CM_DrawDebugSurface;\n\tri.CM_CullWorldBox = CM_CullWorldBox;\n\tri.CM_ClusterPVS = CM_ClusterPVS;\n\tri.CM_LeafArea = CM_LeafArea;\n\tri.CM_LeafCluster = CM_LeafCluster;\n\tri.CM_PointLeafnum = CM_PointLeafnum;\n\tri.CM_PointContents = CM_PointContents;\n\tri.Com_TheHunkMarkHasBeenMade = Com_TheHunkMarkHasBeenMade;\n\tri.S_RestartMusic = S_RestartMusic;\n\tri.SND_RegisterAudio_LevelLoadEnd = SND_RegisterAudio_LevelLoadEnd;\n\tri.CIN_RunCinematic = CIN_RunCinematic;\n\tri.CIN_PlayCinematic = CIN_PlayCinematic;\n\tri.CIN_UploadCinematic = CIN_UploadCinematic;\n\tri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;\n\n\t// g2 data access\n\tri.GetSharedMemory = GetSharedMemory;\n\n\t// (c)g vm callbacks\n\tri.GetCurrentVM = GetCurrentVM;\n\tri.CGVMLoaded = CGVMLoaded;\n\tri.CGVM_RagCallback = CGVM_RagCallback;\n\n    ri.WIN_Init = WIN_Init;\n\tri.WIN_SetGamma = WIN_SetGamma;\n    ri.WIN_Shutdown = WIN_Shutdown;\n    ri.WIN_Present = WIN_Present;\n\tri.GL_GetProcAddress = WIN_GL_GetProcAddress;\n\tri.GL_ExtensionSupported = WIN_GL_ExtensionSupported;\n\n\tri.CM_GetCachedMapDiskImage = CM_GetCachedMapDiskImage;\n\tri.CM_SetCachedMapDiskImage = CM_SetCachedMapDiskImage;\n\tri.CM_SetUsingCache = CM_SetUsingCache;\n\n\t//FIXME: Might have to do something about this...\n\tri.GetG2VertSpaceServer = GetG2VertSpaceServer;\n\tG2VertSpaceServer = &IHeapAllocator_singleton;\n\n\tri.PD_Store = PD_Store;\n\tri.PD_Load = PD_Load;\n\n\tret = GetRefAPI( REF_API_VERSION, &ri );\n\n//\tCom_Printf( \"-------------------------------\\n\");\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = ret;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n\n//===========================================================================================\n\n#define MODEL_CHANGE_DELAY 5000\nint gCLModelDelay = 0;\n\nvoid CL_SetModel_f( void ) {\n\tchar\t*arg;\n\tchar\tname[256];\n\n\targ = Cmd_Argv( 1 );\n\tif (arg[0])\n\t{\n\t\t/*\n\t\t//If you wanted to be foolproof you would put this on the server I guess. But that\n\t\t//tends to put things out of sync regarding cvar status. And I sort of doubt someone\n\t\t//is going to write a client and figure out the protocol so that they can annoy people\n\t\t//by changing models real fast.\n\t\tint curTime = Com_Milliseconds();\n\t\tif (gCLModelDelay > curTime)\n\t\t{\n\t\t\tCom_Printf(\"You can only change your model every %i seconds.\\n\", (MODEL_CHANGE_DELAY/1000));\n\t\t\treturn;\n\t\t}\n\n\t\tgCLModelDelay = curTime + MODEL_CHANGE_DELAY;\n\t\t*/\n\t\t//rwwFIXMEFIXME: This is currently broken and doesn't seem to work for connecting clients\n\t\tCvar_Set( \"model\", arg );\n\t}\n\telse\n\t{\n\t\tCvar_VariableStringBuffer( \"model\", name, sizeof(name) );\n\t\tCom_Printf(\"model is set to %s\\n\", name);\n\t}\n}\n\nvoid CL_SetForcePowers_f( void ) {\n\treturn;\n}\n\n/*\n==================\nCL_VideoFilename\n==================\n*/\nvoid CL_VideoFilename( char *buf, int bufSize ) {\n\ttime_t rawtime;\n\tchar timeStr[32] = {0}; // should really only reach ~19 chars\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\n\tCom_sprintf( buf, bufSize, \"videos/video%s.avi\", timeStr );\n}\n\n/*\n===============\nCL_Video_f\n\nvideo\nvideo [filename]\n===============\n*/\nvoid CL_Video_f( void )\n{\n\tchar  filename[ MAX_OSPATH ];\n\n\tif( !clc.demoplaying )\n\t{\n\t\tCom_Printf( \"The video command can only be used when playing back demos\\n\" );\n\t\treturn;\n\t}\n\n\tif( Cmd_Argc( ) == 2 )\n\t{\n\t\t// explicit filename\n\t\tCom_sprintf( filename, MAX_OSPATH, \"videos/%s.avi\", Cmd_Argv( 1 ) );\n\t}\n\telse\n\t{\n\t\tCL_VideoFilename( filename, MAX_OSPATH );\n\n\t\tif ( FS_FileExists( filename ) ) {\n\t\t\tCom_Printf( \"Video: Couldn't create a file\\n\");\n\t\t\treturn;\n \t\t}\n\t}\n\n\tCL_OpenAVIForWriting( filename );\n}\n\n/*\n===============\nCL_StopVideo_f\n===============\n*/\nvoid CL_StopVideo_f( void )\n{\n\tCL_CloseAVI( );\n}\n\nstatic void CL_AddFavorite_f( void ) {\n\tconst bool connected = (cls.state == CA_ACTIVE) && !clc.demoplaying;\n\tconst int argc = Cmd_Argc();\n\tif ( !connected && argc != 2 ) {\n\t\tCom_Printf( \"syntax: addFavorite <ip or hostname>\\n\" );\n\t\treturn;\n\t}\n\n\tconst char *server = (argc == 2) ? Cmd_Argv( 1 ) : NET_AdrToString( clc.serverAddress );\n\tconst int status = LAN_AddFavAddr( server );\n\tswitch ( status ) {\n\tcase -1:\n\t\tCom_Printf( \"error adding favorite server: too many favorite servers\\n\" );\n\t\tbreak;\n\tcase 0:\n\t\tCom_Printf( \"error adding favorite server: server already exists\\n\" );\n\t\tbreak;\n\tcase 1:\n\t\tCom_Printf( \"successfully added favorite server \\\"%s\\\"\\n\", server );\n\t\tbreak;\n\tdefault:\n\t\tCom_Printf( \"unknown error (%i) adding favorite server\\n\", status );\n\t\tbreak;\n\t}\n}\n\n#define G2_VERT_SPACE_CLIENT_SIZE 256\n\n/*\n===============\nCL_GenerateQKey\n\ntest to see if a valid QKEY_FILE exists.  If one does not, try to generate\nit by filling it with 2048 bytes of random data.\n===============\n*/\n\nstatic void CL_GenerateQKey(void)\n{\n\tif (cl_enableGuid->integer) {\n\t\tint len = 0;\n\t\tunsigned char buff[ QKEY_SIZE ];\n\t\tfileHandle_t f;\n\n\t\tlen = FS_SV_FOpenFileRead( QKEY_FILE, &f );\n\t\tFS_FCloseFile( f );\n\t\tif( len == QKEY_SIZE ) {\n\t\t\tCom_Printf( \"QKEY found.\\n\" );\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif( len > 0 ) {\n\t\t\t\tCom_Printf( \"QKEY file size != %d, regenerating\\n\",\n\t\t\t\t\tQKEY_SIZE );\n\t\t\t}\n\n\t\t\tCom_Printf( \"QKEY building random string\\n\" );\n\t\t\tCom_RandomBytes( buff, sizeof(buff) );\n\n\t\t\tf = FS_SV_FOpenFileWrite( QKEY_FILE );\n\t\t\tif( !f ) {\n\t\t\t\tCom_Printf( \"QKEY could not open %s for write\\n\",\n\t\t\t\t\tQKEY_FILE );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFS_Write( buff, sizeof(buff), f );\n\t\t\tFS_FCloseFile( f );\n\t\t\tCom_Printf( \"QKEY generated\\n\" );\n\t\t}\n\t}\n}\n\n/*\n====================\nCL_Init\n====================\n*/\nvoid CL_Init( void ) {\n//\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init ();\n\n\tCL_ClearState ();\n\n\tcls.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\n\tcls.realtime = 0;\n\n\tCL_InitInput ();\n\n\t//\n\t// register our variables\n\t//\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n\tcl_motd = Cvar_Get (\"cl_motd\", \"1\", CVAR_ARCHIVE, \"Display welcome message from master server on the bottom of connection screen\" );\n\tcl_motdServer[0] = Cvar_Get( \"cl_motdServer1\", UPDATE_SERVER_NAME, 0 );\n\tcl_motdServer[1] = Cvar_Get( \"cl_motdServer2\", JKHUB_UPDATE_SERVER_NAME, 0 );\n\tfor ( int index = 2; index < MAX_MASTER_SERVERS; index++ )\n\t\tcl_motdServer[index] = Cvar_Get( va( \"cl_motdServer%d\", index + 1 ), \"\", CVAR_ARCHIVE );\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP, \"Password for remote console access\" );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_avi2GBLimit = Cvar_Get (\"cl_avi2GBLimit\", \"1\", CVAR_ARCHIVE );\n\tcl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\n\n\trconAddress = Cvar_Get (\"rconAddress\", \"\", 0, \"Alternate server address to remotely access via rcon protocol\");\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", CVAR_ARCHIVE);\n\n\tcl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"63\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE, \"Always run\");\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE, \"Mouse sensitivity value\");\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE, \"Mouse acceleration value\");\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE, \"Mouse look\" );\n\n\t// 0: legacy mouse acceleration\n\t// 1: new implementation\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE, \"Mouse accelration style (0:legacy, 1:QuakeLive)\" );\n\t// offset for the power function (for style 1, ignored otherwise)\n\t// this should be set to the max rate value\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE, \"Mouse acceleration offset for style 1\" );\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n\tcl_framerate\t= Cvar_Get (\"cl_framerate\", \"0\", CVAR_TEMP);\n\tcl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE, \"Allow downloading custom paks from server\");\n\tcl_allowAltEnter = Cvar_Get (\"cl_allowAltEnter\", \"1\", CVAR_ARCHIVE, \"Enables use of ALT+ENTER keyboard combo to toggle fullscreen\" );\n\n\tcl_autolodscale = Cvar_Get( \"cl_autolodscale\", \"1\", CVAR_ARCHIVE );\n\n\tcl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n\n\tcl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitchVeh = Cvar_Get (\"m_pitchVeh\", \"0.022\", CVAR_ARCHIVE);\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef MACOS_X\n        // Input is jittery on OS X w/o this\n\tm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE, \"Max. ping for servers when searching the serverlist\" );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\t// enable the ja_guid player identifier in userinfo by default in OpenJK\n\tcl_enableGuid = Cvar_Get(\"cl_enableGuid\", \"1\", CVAR_ARCHIVE, \"Enable GUID userinfo identifier\" );\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE, \"Use a unique guid value per server\" );\n\n\t// ~ and `, as keys and characters\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60 0xb2\", CVAR_ARCHIVE, \"Which keys are used to toggle the console\");\n\tcl_consoleUseScanCode = Cvar_Get( \"cl_consoleUseScanCode\", \"1\", CVAR_ARCHIVE, \"Use native console key detection\" );\n\n\t// userinfo\n\tCvar_Get (\"name\", \"Padawan\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player name\" );\n\tCvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE, \"Data rate\" );\n\tCvar_Get (\"snaps\", \"40\", CVAR_USERINFO | CVAR_ARCHIVE, \"Client snapshots per second\" );\n\tCvar_Get (\"model\", DEFAULT_MODEL\"/default\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player model\" );\n\tCvar_Get (\"forcepowers\", \"7-1-032330000000001333\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player forcepowers\" );\n//\tCvar_Get (\"g_redTeam\", DEFAULT_REDTEAM_NAME, CVAR_SERVERINFO | CVAR_ARCHIVE);\n//\tCvar_Get (\"g_blueTeam\", DEFAULT_BLUETEAM_NAME, CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player saber1 color\" );\n\tCvar_Get (\"color2\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player saber2 color\" );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player handicap\" );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player sex\" );\n\tCvar_Get (\"password\", \"\", CVAR_USERINFO, \"Password to join server\" );\n\tCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\t//default sabers\n\tCvar_Get (\"saber1\",  DEFAULT_SABER, CVAR_USERINFO | CVAR_ARCHIVE, \"Player default right hand saber\" );\n\tCvar_Get (\"saber2\",  \"none\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player left hand saber\" );\n\n\t//skin color\n\tCvar_Get (\"char_color_red\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Red)\" );\n\tCvar_Get (\"char_color_green\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Green)\" );\n\tCvar_Get (\"char_color_blue\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Blue)\" );\n\n\t// cgame might not be initialized before menu is used\n\tCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\n\t//\n\t// register our commands\n\t//\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f, \"Forward command to server\" );\n\tCmd_AddCommand (\"globalservers\", CL_GlobalServers_f, \"Query the masterserver for serverlist\" );\n\tCmd_AddCommand( \"addFavorite\", CL_AddFavorite_f, \"Add server to favorites\" );\n\tCmd_AddCommand (\"record\", CL_Record_f, \"Record a demo\" );\n\tCmd_AddCommand (\"demo\", CL_PlayDemo_f, \"Playback a demo\" );\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand (\"stoprecord\", CL_StopRecord_f, \"Stop recording a demo\" );\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f, \"Prints the configstrings list\" );\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f, \"Prints the userinfo variables\" );\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f, \"Restart sound\" );\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f, \"Restart the renderer - or change the resolution\" );\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f, \"Disconnect from current server\" );\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f, \"Play a cinematic video\" );\n\tCmd_AddCommand (\"connect\", CL_Connect_f, \"Connect to a server\" );\n\tCmd_AddCommand (\"reconnect\", CL_Reconnect_f, \"Reconnect to current server\" );\n\tCmd_AddCommand (\"localservers\", CL_LocalServers_f, \"Query LAN for local servers\" );\n\tCmd_AddCommand (\"rcon\", CL_Rcon_f, \"Execute commands remotely to a server\" );\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand (\"ping\", CL_Ping_f, \"Ping a server for info response\" );\n\tCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f, \"Retrieve current or specified server's status\" );\n\tCmd_AddCommand (\"showip\", CL_ShowIP_f, \"Shows local IP\" );\n\tCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f, \"Lists open pak files\" );\n\tCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f, \"Lists referenced pak files\" );\n\tCmd_AddCommand (\"model\", CL_SetModel_f, \"Set the player model\" );\n\tCmd_AddCommand (\"forcepowers\", CL_SetForcePowers_f );\n\tCmd_AddCommand (\"video\", CL_Video_f, \"Record demo to avi\" );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f, \"Stop avi recording\" );\n\n\tCL_InitRef();\n\n\tSCR_Init ();\n\n\tCbuf_Execute ();\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tG2VertSpaceClient = new CMiniHeap (G2_VERT_SPACE_CLIENT_SIZE * 1024);\n\n\tCL_GenerateQKey();\n\tCL_UpdateGUID( NULL, 0 );\n\n//\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n\n\n/*\n===============\nCL_Shutdown\n\n===============\n*/\nvoid CL_Shutdown( void ) {\n\tstatic qboolean recursive = qfalse;\n\n\t//Com_Printf( \"----- CL_Shutdown -----\\n\" );\n\n\tif ( recursive ) {\n\t\tprintf (\"recursive CL_Shutdown shutdown\\n\");\n\t\treturn;\n\t}\n\trecursive = qtrue;\n\n\tif (G2VertSpaceClient)\n\t{\n\t\tdelete G2VertSpaceClient;\n\t\tG2VertSpaceClient = 0;\n\t}\n\n\tCL_Disconnect( qtrue );\n\n\t// RJ: added the shutdown all to close down the cgame (to free up some memory, such as in the fx system)\n\tCL_ShutdownAll( qtrue );\n\n\tS_Shutdown();\n\t//CL_ShutdownUI();\n\n\tCmd_RemoveCommand (\"cmd\");\n\tCmd_RemoveCommand (\"configstrings\");\n\tCmd_RemoveCommand (\"clientinfo\");\n\tCmd_RemoveCommand (\"snd_restart\");\n\tCmd_RemoveCommand (\"vid_restart\");\n\tCmd_RemoveCommand (\"disconnect\");\n\tCmd_RemoveCommand (\"record\");\n\tCmd_RemoveCommand (\"demo\");\n\tCmd_RemoveCommand (\"cinematic\");\n\tCmd_RemoveCommand (\"stoprecord\");\n\tCmd_RemoveCommand (\"connect\");\n\tCmd_RemoveCommand (\"reconnect\");\n\tCmd_RemoveCommand (\"localservers\");\n\tCmd_RemoveCommand (\"globalservers\");\n\tCmd_RemoveCommand( \"addFavorite\" );\n\tCmd_RemoveCommand (\"rcon\");\n\tCmd_RemoveCommand (\"ping\");\n\tCmd_RemoveCommand (\"serverstatus\");\n\tCmd_RemoveCommand (\"showip\");\n\tCmd_RemoveCommand (\"fs_openedList\");\n\tCmd_RemoveCommand (\"fs_referencedList\");\n\tCmd_RemoveCommand (\"model\");\n\tCmd_RemoveCommand (\"forcepowers\");\n\tCmd_RemoveCommand (\"video\");\n\tCmd_RemoveCommand (\"stopvideo\");\n\n\tCL_ShutdownInput();\n\tCon_Shutdown();\n\n\tCvar_Set( \"cl_running\", \"0\" );\n\n\trecursive = qfalse;\n\n\tCom_Memset( &cls, 0, sizeof( cls ) );\n\tKey_SetCatcher( 0 );\n\n\t//Com_Printf( \"-----------------------\\n\" );\n\n}\n\nqboolean CL_ConnectedToRemoteServer( void ) {\n\treturn (qboolean)( com_sv_running && !com_sv_running->integer && cls.state >= CA_CONNECTED && !clc.demoplaying );\n}\n\nstatic void CL_SetServerInfo(serverInfo_t *server, const char *info, int ping) {\n\tif (server) {\n\t\tif (info) {\n\t\t\tserver->clients = atoi(Info_ValueForKey(info, \"clients\"));\n\t\t\tQ_strncpyz(server->hostName,Info_ValueForKey(info, \"hostname\"), MAX_NAME_LENGTH);\n\t\t\tQ_strncpyz(server->mapName, Info_ValueForKey(info, \"mapname\"), MAX_NAME_LENGTH);\n\t\t\tserver->maxClients = atoi(Info_ValueForKey(info, \"sv_maxclients\"));\n\t\t\tQ_strncpyz(server->game,Info_ValueForKey(info, \"game\"), MAX_NAME_LENGTH);\n\t\t\tserver->gameType = atoi(Info_ValueForKey(info, \"gametype\"));\n\t\t\tserver->netType = atoi(Info_ValueForKey(info, \"nettype\"));\n\t\t\tserver->minPing = atoi(Info_ValueForKey(info, \"minping\"));\n\t\t\tserver->maxPing = atoi(Info_ValueForKey(info, \"maxping\"));\n//\t\t\tserver->allowAnonymous = atoi(Info_ValueForKey(info, \"sv_allowAnonymous\"));\n\t\t\tserver->needPassword = (qboolean)atoi(Info_ValueForKey(info, \"needpass\" ));\n\t\t\tserver->trueJedi = atoi(Info_ValueForKey(info, \"truejedi\" ));\n\t\t\tserver->weaponDisable = atoi(Info_ValueForKey(info, \"wdisable\" ));\n\t\t\tserver->forceDisable = atoi(Info_ValueForKey(info, \"fdisable\" ));\n\t\t\tserver->humans = atoi( Info_ValueForKey( info, \"g_humanplayers\" ) );\n\t\t\tserver->bots = atoi( Info_ValueForKey( info, \"bots\" ) );\n//\t\t\tserver->pure = (qboolean)atoi(Info_ValueForKey(info, \"pure\" ));\n\t\t}\n\t\tserver->ping = ping;\n\t}\n}\n\nstatic void CL_SetServerInfoByAddress(netadr_t from, const char *info, int ping) {\n\tint i;\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.localServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.localServers[i], info, ping);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_GLOBAL_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.globalServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.globalServers[i], info, ping);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.favoriteServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.favoriteServers[i], info, ping);\n\t\t}\n\t}\n}\n\n/*\n===================\nCL_ServerInfoPacket\n===================\n*/\nvoid CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {\n\tint\t\ti, type;\n\tchar\tinfo[MAX_INFO_STRING];\n\tchar\t*infoString;\n\tint\t\tprot;\n\n\tinfoString = MSG_ReadString( msg );\n\n\t// if this isn't the correct protocol version, ignore it\n\tprot = atoi( Info_ValueForKey( infoString, \"protocol\" ) );\n\tif ( prot != PROTOCOL_VERSION ) {\n\t\tCom_DPrintf( \"Different protocol info packet: %s\\n\", infoString );\n\t\treturn;\n\t}\n\n\t// iterate servers waiting for ping response\n\tfor (i=0; i<MAX_PINGREQUESTS; i++)\n\t{\n\t\tif ( cl_pinglist[i].adr.port && !cl_pinglist[i].time && NET_CompareAdr( from, cl_pinglist[i].adr ) )\n\t\t{\n\t\t\t// calc ping time\n\t\t\tcl_pinglist[i].time = Sys_Milliseconds() - cl_pinglist[i].start;\n\t\t\tCom_DPrintf( \"ping time %dms from %s\\n\", cl_pinglist[i].time, NET_AdrToString( from ) );\n\n\t\t\t// save of info\n\t\t\tQ_strncpyz( cl_pinglist[i].info, infoString, sizeof( cl_pinglist[i].info ) );\n\n\t\t\t// tack on the net type\n\t\t\t// NOTE: make sure these types are in sync with the netnames strings in the UI\n\t\t\tswitch (from.type)\n\t\t\t{\n\t\t\t\tcase NA_BROADCAST:\n\t\t\t\tcase NA_IP:\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\ttype = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tInfo_SetValueForKey( cl_pinglist[i].info, \"nettype\", va(\"%d\", type) );\n\t\t\tCL_SetServerInfoByAddress(from, infoString, cl_pinglist[i].time);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// if not just sent a local broadcast or pinging local servers\n\tif (cls.pingUpdateSource != AS_LOCAL) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_OTHER_SERVERS ; i++ ) {\n\t\t// empty slot\n\t\tif ( cls.localServers[i].adr.port == 0 ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// avoid duplicate\n\t\tif ( NET_CompareAdr( from, cls.localServers[i].adr ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( i == MAX_OTHER_SERVERS ) {\n\t\tCom_DPrintf( \"MAX_OTHER_SERVERS hit, dropping infoResponse\\n\" );\n\t\treturn;\n\t}\n\n\t// add this to the list\n\tcls.numlocalservers = i+1;\n\tCL_InitServerInfo( &cls.localServers[i], &from );\n\n\tQ_strncpyz( info, MSG_ReadString( msg ), MAX_INFO_STRING );\n\tif (strlen(info)) {\n\t\tif (info[strlen(info)-1] != '\\n') {\n\t\t\tstrncat(info, \"\\n\", sizeof(info) -1);\n\t\t}\n\t\tCom_Printf( \"%s: %s\", NET_AdrToString( from ), info );\n\t}\n}\n\n/*\n===================\nCL_GetServerStatus\n===================\n*/\nserverStatus_t *CL_GetServerStatus( netadr_t from ) {\n\tint i, oldest, oldestTime;\n\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( NET_CompareAdr( from, cl_serverStatusList[i].address ) ) {\n\t\t\treturn &cl_serverStatusList[i];\n\t\t}\n\t}\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( cl_serverStatusList[i].retrieved ) {\n\t\t\treturn &cl_serverStatusList[i];\n\t\t}\n\t}\n\toldest = -1;\n\toldestTime = 0;\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif (oldest == -1 || cl_serverStatusList[i].startTime < oldestTime) {\n\t\t\toldest = i;\n\t\t\toldestTime = cl_serverStatusList[i].startTime;\n\t\t}\n\t}\n\tif (oldest != -1) {\n\t\treturn &cl_serverStatusList[oldest];\n\t}\n\tserverStatusCount++;\n\treturn &cl_serverStatusList[serverStatusCount & (MAX_SERVERSTATUSREQUESTS-1)];\n}\n\n/*\n===================\nCL_ServerStatus\n===================\n*/\nint CL_ServerStatus( const char *serverAddress, char *serverStatusString, int maxLen ) {\n\tint i;\n\tnetadr_t\tto;\n\tserverStatus_t *serverStatus;\n\n\t// if no server address then reset all server status requests\n\tif ( !serverAddress ) {\n\t\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\t\tcl_serverStatusList[i].address.port = 0;\n\t\t\tcl_serverStatusList[i].retrieved = qtrue;\n\t\t}\n\t\treturn qfalse;\n\t}\n\t// get the address\n\tif ( !NET_StringToAdr( serverAddress, &to ) ) {\n\t\treturn qfalse;\n\t}\n\tserverStatus = CL_GetServerStatus( to );\n\t// if no server status string then reset the server status request for this address\n\tif ( !serverStatusString ) {\n\t\tserverStatus->retrieved = qtrue;\n\t\treturn qfalse;\n\t}\n\n\t// if this server status request has the same address\n\tif ( NET_CompareAdr( to, serverStatus->address) ) {\n\t\t// if we received a response for this server status request\n\t\tif (!serverStatus->pending) {\n\t\t\tQ_strncpyz(serverStatusString, serverStatus->string, maxLen);\n\t\t\tserverStatus->retrieved = qtrue;\n\t\t\tserverStatus->startTime = 0;\n\t\t\treturn qtrue;\n\t\t}\n\t\t// resend the request regularly\n\t\telse if ( serverStatus->startTime < Com_Milliseconds() - cl_serverStatusResendTime->integer ) {\n\t\t\tserverStatus->print = qfalse;\n\t\t\tserverStatus->pending = qtrue;\n\t\t\tserverStatus->retrieved = qfalse;\n\t\t\tserverStatus->time = 0;\n\t\t\tserverStatus->startTime = Com_Milliseconds();\n\t\t\tNET_OutOfBandPrint( NS_CLIENT, to, \"getstatus\" );\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t// if retrieved\n\telse if ( serverStatus->retrieved ) {\n\t\tserverStatus->address = to;\n\t\tserverStatus->print = qfalse;\n\t\tserverStatus->pending = qtrue;\n\t\tserverStatus->retrieved = qfalse;\n\t\tserverStatus->startTime = Com_Milliseconds();\n\t\tserverStatus->time = 0;\n\t\tNET_OutOfBandPrint( NS_CLIENT, to, \"getstatus\" );\n\t\treturn qfalse;\n\t}\n\treturn qfalse;\n}\n\n/*\n===================\nCL_ServerStatusResponse\n===================\n*/\nvoid CL_ServerStatusResponse( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tchar\tinfo[MAX_INFO_STRING];\n\tint\t\ti, l, score, ping;\n\tint\t\tlen;\n\tserverStatus_t *serverStatus;\n\n\tserverStatus = NULL;\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( NET_CompareAdr( from, cl_serverStatusList[i].address ) ) {\n\t\t\tserverStatus = &cl_serverStatusList[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if we didn't request this server status\n\tif (!serverStatus) {\n\t\treturn;\n\t}\n\n\ts = MSG_ReadStringLine( msg );\n\n\tlen = 0;\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"%s\", s);\n\n\tif (serverStatus->print) {\n\t\tCom_Printf( \"Server (%s)\\n\",\n\t\t\tNET_AdrToString( serverStatus->address ) );\n\t\tCom_Printf(\"Server settings:\\n\");\n\t\t// print cvars\n\t\twhile (*s) {\n\t\t\tfor (i = 0; i < 2 && *s; i++) {\n\t\t\t\tif (*s == '\\\\')\n\t\t\t\t\ts++;\n\t\t\t\tl = 0;\n\t\t\t\twhile (*s) {\n\t\t\t\t\tinfo[l++] = *s;\n\t\t\t\t\tif (l >= MAX_INFO_STRING-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts++;\n\t\t\t\t\tif (*s == '\\\\') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo[l] = '\\0';\n\t\t\t\tif (i) {\n\t\t\t\t\tCom_Printf(\"%s\\n\", info);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCom_Printf(\"%-24s\", info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlen = strlen(serverStatus->string);\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\\");\n\n\tif (serverStatus->print) {\n\t\tCom_Printf(\"\\nPlayers:\\n\");\n\t\tCom_Printf(\"num: score: ping: name:\\n\");\n\t}\n\tfor (i = 0, s = MSG_ReadStringLine( msg ); *s; s = MSG_ReadStringLine( msg ), i++) {\n\n\t\tlen = strlen(serverStatus->string);\n\t\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\%s\", s);\n\n\t\tif (serverStatus->print) {\n\t\t\tscore = ping = 0;\n\t\t\tsscanf(s, \"%d %d\", &score, &ping);\n\t\t\ts = strchr(s, ' ');\n\t\t\tif (s)\n\t\t\t\ts = strchr(s+1, ' ');\n\t\t\tif (s)\n\t\t\t\ts++;\n\t\t\telse\n\t\t\t\ts = \"unknown\";\n\t\t\tCom_Printf(\"%-2d   %-3d    %-3d   %s\\n\", i, score, ping, s );\n\t\t}\n\t}\n\tlen = strlen(serverStatus->string);\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\\");\n\n\tserverStatus->time = Com_Milliseconds();\n\tserverStatus->address = from;\n\tserverStatus->pending = qfalse;\n\tif (serverStatus->print) {\n\t\tserverStatus->retrieved = qtrue;\n\t}\n}\n\n/*\n==================\nCL_LocalServers_f\n==================\n*/\nvoid CL_LocalServers_f( void ) {\n\tchar\t\t*message;\n\tint\t\t\ti, j;\n\tnetadr_t\tto;\n\n\tCom_Printf( \"Scanning for servers on the local network...\\n\");\n\n\t// reset the list, waiting for response\n\tcls.numlocalservers = 0;\n\tcls.pingUpdateSource = AS_LOCAL;\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tqboolean b = cls.localServers[i].visible;\n\t\tCom_Memset(&cls.localServers[i], 0, sizeof(cls.localServers[i]));\n\t\tcls.localServers[i].visible = b;\n\t}\n\tCom_Memset( &to, 0, sizeof( to ) );\n\n\t// The 'xxx' in the message is a challenge that will be echoed back\n\t// by the server.  We don't care about that here, but master servers\n\t// can use that to prevent spoofed server responses from invalid ip\n\tmessage = \"\\377\\377\\377\\377getinfo xxx\";\n\n\t// send each message twice in case one is dropped\n\tfor ( i = 0 ; i < 2 ; i++ ) {\n\t\t// send a broadcast packet on each server port\n\t\t// we support multiple server ports so a single machine\n\t\t// can nicely run multiple servers\n\t\tfor ( j = 0 ; j < NUM_SERVER_PORTS ; j++ ) {\n\t\t\tto.port = BigShort( (short)(PORT_SERVER + j) );\n\n\t\t\tto.type = NA_BROADCAST;\n\t\t\tNET_SendPacket( NS_CLIENT, strlen( message ), message, to );\n\t\t}\n\t}\n}\n\n/*\n==================\nCL_GlobalServers_f\n==================\n*/\nvoid CL_GlobalServers_f( void ) {\n\tnetadr_t\tto;\n\tint\t\t\tcount, i, masterNum;\n\tchar\t\tcommand[1024], *masteraddress;\n\n\tif ((count = Cmd_Argc()) < 3 || (masterNum = atoi(Cmd_Argv(1))) < 0 || masterNum > MAX_MASTER_SERVERS - 1)\n\t{\n\t\tCom_Printf(\"usage: globalservers <master# 0-%d> <protocol> [keywords]\\n\", MAX_MASTER_SERVERS - 1);\n\t\treturn;\n\t}\n\n\tCom_sprintf( command, sizeof(command), \"sv_master%d\", masterNum + 1 );\n\tmasteraddress = Cvar_VariableString( command );\n\n\tif ( !*masteraddress )\n\t{\n\t\tCom_Printf( \"CL_GlobalServers_f: Error: No master server address given.\\n\" );\n\t\treturn;\n\t}\n\n\t// reset the list, waiting for response\n\t// -1 is used to distinguish a \"no response\"\n\n\ti = NET_StringToAdr( masteraddress, &to );\n\n\tif (!i)\n\t{\n\t\tCom_Printf( \"CL_GlobalServers_f: Error: could not resolve address of master %s\\n\", masteraddress );\n\t\treturn;\n\t}\n\tto.type = NA_IP;\n\tto.port = BigShort(PORT_MASTER);\n\n\tCom_Printf( \"Requesting servers from the master %s (%s)...\\n\", masteraddress, NET_AdrToString( to ) );\n\n\tcls.numglobalservers = -1;\n\tcls.pingUpdateSource = AS_GLOBAL;\n\n\tCom_sprintf(command, sizeof(command), \"getservers %s\", Cmd_Argv(2));\n\n\t// tack on keywords\n\tfor (i = 3; i < count; i++)\n\t{\n\t\tQ_strcat(command, sizeof(command), \" \");\n\t\tQ_strcat(command, sizeof(command), Cmd_Argv(i));\n\t}\n\n\tNET_OutOfBandPrint( NS_SERVER, to, \"%s\", command );\n}\n\n/*\n==================\nCL_GetPing\n==================\n*/\nvoid CL_GetPing( int n, char *buf, int buflen, int *pingtime )\n{\n\tconst char\t*str;\n\tint\t\ttime;\n\tint\t\tmaxPing;\n\n\tif (n < 0 || n >= MAX_PINGREQUESTS || !cl_pinglist[n].adr.port)\n\t{\n\t\t// empty or invalid slot\n\t\tbuf[0]    = '\\0';\n\t\t*pingtime = 0;\n\t\treturn;\n\t}\n\n\tstr = NET_AdrToString( cl_pinglist[n].adr );\n\tQ_strncpyz( buf, str, buflen );\n\n\ttime = cl_pinglist[n].time;\n\tif (!time)\n\t{\n\t\t// check for timeout\n\t\ttime = Sys_Milliseconds() - cl_pinglist[n].start;\n\t\tmaxPing = Cvar_VariableIntegerValue( \"cl_maxPing\" );\n\t\tif( maxPing < 100 ) {\n\t\t\tmaxPing = 100;\n\t\t}\n\t\tif (time < maxPing)\n\t\t{\n\t\t\t// not timed out yet\n\t\t\ttime = 0;\n\t\t}\n\t}\n\n\tCL_SetServerInfoByAddress(cl_pinglist[n].adr, cl_pinglist[n].info, cl_pinglist[n].time);\n\n\t*pingtime = time;\n}\n\n/*\n==================\nCL_GetPingInfo\n==================\n*/\nvoid CL_GetPingInfo( int n, char *buf, int buflen )\n{\n\tif (n < 0 || n >= MAX_PINGREQUESTS || !cl_pinglist[n].adr.port)\n\t{\n\t\t// empty or invalid slot\n\t\tif (buflen)\n\t\t\tbuf[0] = '\\0';\n\t\treturn;\n\t}\n\n\tQ_strncpyz( buf, cl_pinglist[n].info, buflen );\n}\n\n/*\n==================\nCL_ClearPing\n==================\n*/\nvoid CL_ClearPing( int n )\n{\n\tif (n < 0 || n >= MAX_PINGREQUESTS)\n\t\treturn;\n\n\tcl_pinglist[n].adr.port = 0;\n}\n\n/*\n==================\nCL_GetPingQueueCount\n==================\n*/\nint CL_GetPingQueueCount( void )\n{\n\tint\t\ti;\n\tint\t\tcount;\n\tping_t*\tpingptr;\n\n\tcount   = 0;\n\tpingptr = cl_pinglist;\n\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ ) {\n\t\tif (pingptr->adr.port) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn (count);\n}\n\n/*\n==================\nCL_GetFreePing\n==================\n*/\nping_t* CL_GetFreePing( void )\n{\n\tping_t*\tpingptr;\n\tping_t*\tbest;\n\tint\t\toldest;\n\tint\t\ti;\n\tint\t\ttime;\n\n\tpingptr = cl_pinglist;\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ )\n\t{\n\t\t// find free ping slot\n\t\tif (pingptr->adr.port)\n\t\t{\n\t\t\tif (!pingptr->time)\n\t\t\t{\n\t\t\t\tif (Sys_Milliseconds() - pingptr->start < 500)\n\t\t\t\t{\n\t\t\t\t\t// still waiting for response\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pingptr->time < 500)\n\t\t\t{\n\t\t\t\t// results have not been queried\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// clear it\n\t\tpingptr->adr.port = 0;\n\t\treturn (pingptr);\n\t}\n\n\t// use oldest entry\n\tpingptr = cl_pinglist;\n\tbest    = cl_pinglist;\n\toldest  = INT_MIN;\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ )\n\t{\n\t\t// scan for oldest\n\t\ttime = Sys_Milliseconds() - pingptr->start;\n\t\tif (time > oldest)\n\t\t{\n\t\t\toldest = time;\n\t\t\tbest   = pingptr;\n\t\t}\n\t}\n\n\treturn (best);\n}\n\n/*\n==================\nCL_Ping_f\n==================\n*/\nvoid CL_Ping_f( void ) {\n\tnetadr_t\tto;\n\tping_t*\t\tpingptr;\n\tchar*\t\tserver;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: ping [server]\\n\");\n\t\treturn;\n\t}\n\n\tCom_Memset( &to, 0, sizeof(netadr_t) );\n\n\tserver = Cmd_Argv(1);\n\n\tif ( !NET_StringToAdr( server, &to ) ) {\n\t\treturn;\n\t}\n\n\tpingptr = CL_GetFreePing();\n\n\tmemcpy( &pingptr->adr, &to, sizeof (netadr_t) );\n\tpingptr->start = Sys_Milliseconds();\n\tpingptr->time  = 0;\n\n\tCL_SetServerInfoByAddress(pingptr->adr, NULL, 0);\n\n\tNET_OutOfBandPrint( NS_CLIENT, to, \"getinfo xxx\" );\n}\n\n/*\n==================\nCL_UpdateVisiblePings_f\n==================\n*/\nqboolean CL_UpdateVisiblePings_f(int source) {\n\tint\t\t\tslots, i;\n\tchar\t\tbuff[MAX_STRING_CHARS];\n\tint\t\t\tpingTime;\n\tint\t\t\tmax;\n\tqboolean status = qfalse;\n\n\tif (source < 0 || source > AS_FAVORITES) {\n\t\treturn qfalse;\n\t}\n\n\tcls.pingUpdateSource = source;\n\n\tslots = CL_GetPingQueueCount();\n\tif (slots < MAX_PINGREQUESTS) {\n\t\tserverInfo_t *server = NULL;\n\n\t\tswitch (source) {\n\t\t\tcase AS_LOCAL :\n\t\t\t\tserver = &cls.localServers[0];\n\t\t\t\tmax = cls.numlocalservers;\n\t\t\tbreak;\n\t\t\tcase AS_GLOBAL :\n\t\t\t\tserver = &cls.globalServers[0];\n\t\t\t\tmax = cls.numglobalservers;\n\t\t\tbreak;\n\t\t\tcase AS_FAVORITES :\n\t\t\t\tserver = &cls.favoriteServers[0];\n\t\t\t\tmax = cls.numfavoriteservers;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn qfalse;\n\t\t}\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tif (server[i].visible) {\n\t\t\t\tif (server[i].ping == -1) {\n\t\t\t\t\tint j;\n\n\t\t\t\t\tif (slots >= MAX_PINGREQUESTS) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < MAX_PINGREQUESTS; j++) {\n\t\t\t\t\t\tif (!cl_pinglist[j].adr.port) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {\n\t\t\t\t\t\t\t// already on the list\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j >= MAX_PINGREQUESTS) {\n\t\t\t\t\t\tstatus = qtrue;\n\t\t\t\t\t\tfor (j = 0; j < MAX_PINGREQUESTS; j++) {\n\t\t\t\t\t\t\tif (!cl_pinglist[j].adr.port) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(&cl_pinglist[j].adr, &server[i].adr, sizeof(netadr_t));\n\t\t\t\t\t\tcl_pinglist[j].start = Sys_Milliseconds();\n\t\t\t\t\t\tcl_pinglist[j].time = 0;\n\t\t\t\t\t\tNET_OutOfBandPrint( NS_CLIENT, cl_pinglist[j].adr, \"getinfo xxx\" );\n\t\t\t\t\t\tslots++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the server has a ping higher than cl_maxPing or\n\t\t\t\t// the ping packet got lost\n\t\t\t\telse if (server[i].ping == 0) {\n\t\t\t\t\t// if we are updating global servers\n\t\t\t\t\tif (source == AS_GLOBAL) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif ( cls.numGlobalServerAddresses > 0 ) {\n\t\t\t\t\t\t\t// overwrite this server with one from the additional global servers\n\t\t\t\t\t\t\tcls.numGlobalServerAddresses--;\n\t\t\t\t\t\t\tCL_InitServerInfo(&server[i], &cls.globalServerAddresses[cls.numGlobalServerAddresses]);\n\t\t\t\t\t\t\t// NOTE: the server[i].visible flag stays untouched\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slots) {\n\t\tstatus = qtrue;\n\t}\n\tfor (i = 0; i < MAX_PINGREQUESTS; i++) {\n\t\tif (!cl_pinglist[i].adr.port) {\n\t\t\tcontinue;\n\t\t}\n\t\tCL_GetPing( i, buff, MAX_STRING_CHARS, &pingTime );\n\t\tif (pingTime != 0) {\n\t\t\tCL_ClearPing(i);\n\t\t\tstatus = qtrue;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/*\n==================\nCL_ServerStatus_f\n==================\n*/\nvoid CL_ServerStatus_f(void) {\n\tnetadr_t\tto, *toptr = NULL;\n\tchar\t\t*server;\n\tserverStatus_t *serverStatus;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tif ( cls.state != CA_ACTIVE || clc.demoplaying ) {\n\t\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\t\tCom_Printf( \"Usage: serverstatus [server]\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ttoptr = &clc.serverAddress;\n\t}\n\n\tif(!toptr)\n\t{\n\t\tCom_Memset( &to, 0, sizeof(netadr_t) );\n\n\t\tserver = Cmd_Argv(1);\n\n\t\ttoptr = &to;\n\t\tif ( !NET_StringToAdr( server, toptr ) )\n\t\t\treturn;\n\t}\n\n\tNET_OutOfBandPrint( NS_CLIENT, *toptr, \"getstatus\" );\n\n\tserverStatus = CL_GetServerStatus( *toptr );\n\tserverStatus->address = *toptr;\n\tserverStatus->print = qtrue;\n\tserverStatus->pending = qtrue;\n}\n\n/*\n==================\nCL_ShowIP_f\n==================\n*/\nvoid CL_ShowIP_f(void) {\n\tSys_ShowIP();\n}\n\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n/*****************************************************************************\n\n * name:\t\tfiles.cpp\n *\n * desc:\t\tfile code\n *\n *****************************************************************************/\n\n#include \"qcommon/qcommon.h\"\n\n#ifndef DEDICATED\n#ifndef FINAL_BUILD\n#include \"client/client.h\"\n#endif\n#endif\n#include <minizip/unzip.h>\n\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n// for rmdir\n#if defined (_MSC_VER)\n\t#include <direct.h>\n#else\n\t#include <unistd.h>\n#endif\n\n/*\n=============================================================================\n\nQUAKE3 FILESYSTEM\n\nAll of Quake's data access is through a hierarchical file system, but the contents of\nthe file system can be transparently merged from several sources.\n\nA \"qpath\" is a reference to game file data.  MAX_ZPATH is 256 characters, which must include\na terminating zero. \"..\", \"\\\\\", and \":\" are explicitly illegal in qpaths to prevent any\nreferences outside the quake directory system.\n\nThe \"base path\" is the path to the directory holding all the game directories and usually\nthe executable.  It defaults to \".\", but can be overridden with a \"+set fs_basepath c:\\quake3\"\ncommand line to allow code debugging in a different directory.  Basepath cannot\nbe modified at all after startup.  Any files that are created (demos, screenshots,\netc) will be created relative to the base path, so base path should usually be writable.\n\nThe \"home path\" is the path used for all write access. On win32 systems we have \"base path\"\n== \"home path\", but on *nix systems the base installation is usually readonly, and\n\"home path\" points to ~/.q3a or similar\n\nThe user can also install custom mods and content in \"home path\", so it should be searched\nalong with \"home path\" and \"cd path\" for game content.\n\n\nThe \"base game\" is the directory under the paths where data comes from by default, and\ncan be either \"baseq3\" or \"demoq3\".\n\nThe \"current game\" may be the same as the base game, or it may be the name of another\ndirectory under the paths that should be searched for files before looking in the base game.\nThis is the basis for addons.\n\nClients automatically set the game directory after receiving a gamestate from a server,\nso only servers need to worry about +set fs_game.\n\nNo other directories outside of the base game and current game will ever be referenced by\nfilesystem functions.\n\nTo save disk space and speed loading, directory trees can be collapsed into zip files.\nThe files use a \".pk3\" extension to prevent users from unzipping them accidentally, but\notherwise the are simply normal uncompressed zip files.  A game directory can have multiple\nzip files of the form \"pak0.pk3\", \"pak1.pk3\", etc.  Zip files are searched in decending order\nfrom the highest number to the lowest, and will always take precedence over the filesystem.\nThis allows a pk3 distributed as a patch to override all existing data.\n\nBecause we will have updated executables freely available online, there is no point to\ntrying to restrict demo / oem versions of the game with code changes.  Demo / oem versions\nshould be exactly the same executables as release versions, but with different data that\nautomatically restricts where game media can come from to prevent add-ons from working.\n\nFile search order: when FS_FOpenFileRead gets called it will go through the fs_searchpaths\nstructure and stop on the first successful hit. fs_searchpaths is built with successive\ncalls to FS_AddGameDirectory\n\nAdditionaly, we search in several subdirectories:\ncurrent game is the current mode\nbase game is a variable to allow mods based on other mods\n(such as baseq3 + missionpack content combination in a mod for instance)\nBASEGAME is the hardcoded base game (\"baseq3\")\n\ne.g. the qpath \"sound/newstuff/test.wav\" would be searched for in the following places:\n\nhome path + current game's zip files\nhome path + current game's directory\nbase path + current game's zip files\nbase path + current game's directory\ncd path + current game's zip files\ncd path + current game's directory\n\nhome path + base game's zip file\nhome path + base game's directory\nbase path + base game's zip file\nbase path + base game's directory\ncd path + base game's zip file\ncd path + base game's directory\n\nhome path + BASEGAME's zip file\nhome path + BASEGAME's directory\nbase path + BASEGAME's zip file\nbase path + BASEGAME's directory\ncd path + BASEGAME's zip file\ncd path + BASEGAME's directory\n\nserver download, to be written to home path + current game's directory\n\n\nThe filesystem can be safely shutdown and reinitialized with different\nbasedir / cddir / game combinations, but all other subsystems that rely on it\n(sound, video) must also be forced to restart.\n\nBecause the same files are loaded by both the clip model (CM_) and renderer (TR_)\nsubsystems, a simple single-file caching scheme is used.  The CM_ subsystems will\nload the file with a request to cache.  Only one file will be kept cached at a time,\nso any models that are going to be referenced by both subsystems should alternate\nbetween the CM_ load function and the ref load function.\n\nTODO: A qpath that starts with a leading slash will always refer to the base game, even if another\ngame is currently active.  This allows character models, skins, and sounds to be downloaded\nto a common directory no matter which game is active.\n\nHow to prevent downloading zip files?\nPass pk3 file names in systeminfo, and download before FS_Restart()?\n\nAborting a download disconnects the client from the server.\n\nHow to mark files as downloadable?  Commercial add-ons won't be downloadable.\n\nNon-commercial downloads will want to download the entire zip file.\nthe game would have to be reset to actually read the zip in\n\nAuto-update information\n\nPath separators\n\nCasing\n\n  separate server gamedir and client gamedir, so if the user starts\n  a local game after having connected to a network game, it won't stick\n  with the network game.\n\n  allow menu options for game selection?\n\nRead / write config to floppy option.\n\nDifferent version coexistance?\n\nWhen building a pak file, make sure a q3config.cfg isn't present in it,\nor configs will never get loaded from disk!\n\n  todo:\n\n  downloading (outside fs?)\n  game directory passing and restarting\n\n=============================================================================\n\n*/\n\n#define MAX_ZPATH\t\t\t256\n#define\tMAX_SEARCH_PATHS\t4096\n#define MAX_FILEHASH_SIZE\t1024\n\ntypedef struct fileInPack_s {\n\tchar\t\t\t\t\t*name;\t\t// name of the file\n\tunsigned long\t\t\tpos;\t\t// file info position in zip\n\tunsigned long\t\t\tlen;\t\t// uncompress file size\n\tstruct\tfileInPack_s*\tnext;\t\t// next file in the hash\n} fileInPack_t;\n\ntypedef struct pack_s {\n\tchar\t\t\tpakPathname[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\t\tpakFilename[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\\assets0.pk3\n\tchar\t\t\tpakBasename[MAX_OSPATH];\t// assets0\n\tchar\t\t\tpakGamename[MAX_OSPATH];\t// base\n\tunzFile\t\t\thandle;\t\t\t\t\t\t// handle to zip file\n\tint\t\t\t\tchecksum;\t\t\t\t\t// regular checksum\n\tint\t\t\t\tpure_checksum;\t\t\t\t// checksum for pure\n\tint\t\t\t\tnumfiles;\t\t\t\t\t// number of files in pk3\n\tint\t\t\t\treferenced;\t\t\t\t\t// referenced file flags\n\tint\t\t\t\thashSize;\t\t\t\t\t// hash table size (power of 2)\n\tfileInPack_t*\t*hashTable;\t\t\t\t\t// hash table\n\tfileInPack_t*\tbuildBuffer;\t\t\t\t// buffer with the filenames etc.\n} pack_t;\n\ntypedef struct directory_s {\n\tchar\t\tpath[MAX_OSPATH];\t\t// c:\\jediacademy\\gamedata\n\tchar\t\tfullpath[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\tgamedir[MAX_OSPATH];\t// base\n} directory_t;\n\ntypedef struct searchpath_s {\n\tstruct searchpath_s *next;\n\n\tpack_t\t\t*pack;\t\t// only one of pack / dir will be non NULL\n\tdirectory_t\t*dir;\n} searchpath_t;\n\nstatic char\t\tfs_gamedir[MAX_OSPATH];\t// this will be a single file name with no separators\nstatic cvar_t\t\t*fs_debug;\nstatic cvar_t\t\t*fs_homepath;\n\n#ifdef MACOS_X\n// Also search the .app bundle for .pk3 files\nstatic cvar_t          *fs_apppath;\n#endif\n\nstatic cvar_t\t\t*fs_basepath;\nstatic cvar_t\t\t*fs_basegame;\nstatic cvar_t\t\t*fs_cdpath;\nstatic cvar_t\t\t*fs_copyfiles;\nstatic cvar_t\t\t*fs_gamedirvar;\nstatic cvar_t\t\t*fs_dirbeforepak; //rww - when building search path, keep directories at top and insert pk3's under them\nstatic searchpath_t\t*fs_searchpaths;\nstatic int\t\t\tfs_readCount;\t\t\t// total bytes read\nstatic int\t\t\tfs_loadCount;\t\t\t// total files read\nstatic int\t\t\tfs_packFiles = 0;\t\t// total number of files in packs\n\nstatic int\t\t\tfs_fakeChkSum;\nstatic int\t\t\tfs_checksumFeed;\n\ntypedef union qfile_gus {\n\tFILE*\t\to;\n\tunzFile\t\tz;\n} qfile_gut;\n\ntypedef struct qfile_us {\n\tqfile_gut\tfile;\n\tqboolean\tunique;\n} qfile_ut;\n\ntypedef struct fileHandleData_s {\n\tqfile_ut\thandleFiles;\n\tqboolean\thandleSync;\n\tint\t\t\tfileSize;\n\tint\t\t\tzipFilePos;\n\tint\t\t\tzipFileLen;\n\tqboolean\tzipFile;\n\tchar\t\tname[MAX_ZPATH];\n} fileHandleData_t;\n\nstatic fileHandleData_t\tfsh[MAX_FILE_HANDLES];\n\n// TTimo - https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n// wether we did a reorder on the current search path when joining the server\nstatic qboolean fs_reordered = qfalse;\n\n// never load anything from pk3 files that are not present at the server when pure\nstatic int\t\tfs_numServerPaks = 0;\nstatic int\t\tfs_serverPaks[MAX_SEARCH_PATHS];\t\t\t\t// checksums\nstatic char\t\t*fs_serverPakNames[MAX_SEARCH_PATHS];\t\t\t// pk3 names\n\n// only used for autodownload, to make sure the client has at least\n// all the pk3 files that are referenced at the server side\nstatic int\t\tfs_numServerReferencedPaks;\nstatic int\t\tfs_serverReferencedPaks[MAX_SEARCH_PATHS];\t\t\t// checksums\nstatic char\t*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];\t\t// pk3 names\n\n#if defined(_WIN32)\n// temporary files - store them in a circular buffer. We're pretty\n// much guaranteed to not need more than 8 temp files at a time.\nstatic int\t\tfs_temporaryFileWriteIdx = 0;\nstatic char\t\tfs_temporaryFileNames[8][MAX_OSPATH];\n#endif\n\n// last valid game folder used\nchar lastValidBase[MAX_OSPATH];\nchar lastValidGame[MAX_OSPATH];\n\n#ifdef FS_MISSING\nFILE*\t\tmissingFiles = NULL;\n#endif\n\n/* C99 defines __func__ */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2 || _MSC_VER >= 1300\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"(unknown)\"\n#  endif\n#endif\n\n/*\n==============\nFS_Initialized\n==============\n*/\n\nqboolean FS_Initialized( void ) {\n\treturn (qboolean)(fs_searchpaths != NULL);\n}\n\nstatic void FS_AssertInitialised( void ) {\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n}\n\n/*\n=================\nFS_PakIsPure\n=================\n*/\nqboolean FS_PakIsPure( pack_t *pack ) {\n\tint i;\n\n\tif ( fs_numServerPaks ) {\n    // NOTE TTimo we are matching checksums without checking the pak names\n    //   this means you can have the same pk3 as the server under a different name, you will still get through sv_pure validation\n    //   (what happens when two pk3's have the same checkums? is it a likely situation?)\n    //   also, if there's a wrong checksumed pk3 and autodownload is enabled, the checksum will be appended to the downloaded pk3 name\n\t\tfor ( i = 0 ; i < fs_numServerPaks ; i++ ) {\n\t\t\t// FIXME: also use hashed file names\n\t\t\tif ( pack->checksum == fs_serverPaks[i] ) {\n\t\t\t\treturn qtrue;\t\t// on the aproved list\n\t\t\t}\n\t\t}\n\t\treturn qfalse;\t// not on the pure server pak list\n\t}\n\treturn qtrue;\n}\n\n/*\n================\nreturn a hash value for the filename\n================\n*/\nstatic long FS_HashFileName( const char *fname, int hashSize ) {\n\tint\t\ti;\n\tlong\thash;\n\tchar\tletter;\n\n\thash = 0;\n\ti = 0;\n\twhile (fname[i] != '\\0') {\n\t\tletter = tolower(fname[i]);\n\t\tif (letter =='.') break;\t\t\t\t// don't include extension\n\t\tif (letter =='\\\\') letter = '/';\t\t// damn path names\n\t\tif (letter == PATH_SEP) letter = '/';\t\t// damn path names\n\t\thash+=(long)(letter)*(i+119);\n\t\ti++;\n\t}\n\thash = (hash ^ (hash >> 10) ^ (hash >> 20));\n\thash &= (hashSize-1);\n\treturn hash;\n}\n\nstatic fileHandle_t FS_HandleForFile(void) {\n\tint\t\ti;\n\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o == NULL ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tCom_Error( ERR_DROP, \"FS_HandleForFile: none free\" );\n\treturn 0;\n}\n\nstatic FILE\t*FS_FileForHandle( fileHandle_t f ) {\n\tif ( f < 1 || f >= MAX_FILE_HANDLES ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: out of range\" );\n\t}\n\tif (fsh[f].zipFile == qtrue) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: can't get FILE on zip file\" );\n\t}\n\tif ( ! fsh[f].handleFiles.file.o ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: NULL\" );\n\t}\n\n\treturn fsh[f].handleFiles.file.o;\n}\n\nvoid\tFS_ForceFlush( fileHandle_t f ) {\n\tFILE *file;\n\n\tfile = FS_FileForHandle(f);\n\tsetvbuf( file, NULL, _IONBF, 0 );\n}\n\n/*\n================\nFS_fplength\n================\n*/\n\nlong FS_fplength(FILE *h)\n{\n\tlong\t\tpos;\n\tlong\t\tend;\n\n\tpos = ftell(h);\n\tif ( pos == EOF )\n\t\treturn EOF;\n\n\tfseek(h, 0, SEEK_END);\n\tend = ftell(h);\n\tfseek(h, pos, SEEK_SET);\n\n\treturn end;\n}\n\n/*\n================\nFS_filelength\n\nIf this is called on a non-unique FILE (from a pak file),\nit will return the size of the pak file, not the expected\nsize of the file.\n================\n*/\nint FS_filelength( fileHandle_t f ) {\n\tFILE\t*h;\n\n\th = FS_FileForHandle(f);\n\n\tif(h == NULL)\n\t\treturn EOF;\n\telse\n\t\treturn FS_fplength(h);\n}\n\n/*\n====================\nFS_ReplaceSeparators\n\nFix things up differently for win/unix/mac\n====================\n*/\nvoid FS_ReplaceSeparators( char *path ) {\n\tchar\t*s;\n\tqboolean lastCharWasSep = qfalse;\n\n\tfor ( s = path ; *s ; s++ ) {\n\t\tif ( *s == '/' || *s == '\\\\' ) {\n\t\t\tif ( !lastCharWasSep ) {\n\t\t\t\t*s = PATH_SEP;\n\t\t\t\tlastCharWasSep = qtrue;\n\t\t\t} else {\n\t\t\t\tmemmove (s, s + 1, strlen (s));\n\t\t\t}\n\t\t} else {\n\t\t\tlastCharWasSep = qfalse;\n\t\t}\n\t}\n}\n\n/*\n===================\nFS_BuildOSPath\n\nQpath may have either forward or backwards slashes\n===================\n*/\nchar *FS_BuildOSPath( const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\t// Fix for filenames that are given to FS with a leading \"/\" (/botfiles/Foo)\n\tif (qpath[0] == '\\\\' || qpath[0] == '/')\n\t\tqpath++;\n\n\tCom_sprintf( temp, sizeof(temp), \"/base/%s\", qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", fs_basepath->string, temp );\n\n\treturn ospath[toggle];\n}\n\nchar *FS_BuildOSPath( const char *base, const char *game, const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\tif( !game || !game[0] ) {\n\t\tgame = fs_gamedir;\n\t}\n\n\tCom_sprintf( temp, sizeof(temp), \"/%s/%s\", game, qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", base, temp );\n\n\treturn ospath[toggle];\n}\n\n/*\n============\nFS_CreatePath\n\nCreates any directories needed to store the given filename\n============\n*/\nqboolean FS_CreatePath (char *OSPath) {\n\tchar\t*ofs;\n\tchar\tpath[MAX_OSPATH];\n\n\t// make absolutely sure that it can't back up the path\n\t// FIXME: is c: allowed???\n\tif ( strstr( OSPath, \"..\" ) || strstr( OSPath, \"::\" ) ) {\n\t\tCom_Printf( \"WARNING: refusing to create relative path \\\"%s\\\"\\n\", OSPath );\n\t\treturn qtrue;\n\t}\n\n\tQ_strncpyz( path, OSPath, sizeof( path ) );\n\tFS_ReplaceSeparators( path );\n\n\t// Skip creation of the root directory as it will always be there\n\tofs = strchr( path, PATH_SEP );\n\tif ( ofs ) {\n\t\tofs++;\n\t}\n\n\tfor (; ofs != NULL && *ofs ; ofs++) {\n\t\tif (*ofs == PATH_SEP) {\n\t\t\t// create the directory\n\t\t\t*ofs = 0;\n\t\t\tif (!Sys_Mkdir (path)) {\n\t\t\t\tCom_Error( ERR_FATAL, \"FS_CreatePath: failed to create path \\\"%s\\\"\",\n\t\t\t\t\tpath );\n\t\t\t}\n\t\t\t*ofs = PATH_SEP;\n\t\t}\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_CheckFilenameIsMutable\n\nERR_FATAL if trying to maniuplate a file with the platform library, or pk3 extension\n=================\n*/\nstatic void FS_CheckFilenameIsMutable( const char *filename, const char *function )\n{\n\t// Check if the filename ends with the library, or pk3 extension\n\tif( COM_CompareExtension( filename, DLL_EXT )\n\t\t|| COM_CompareExtension( filename, \".pk3\" ) )\n\t{\n\t\tCom_Error( ERR_FATAL, \"%s: Not allowed to manipulate '%s' due \"\n\t\t\t\"to %s extension\", function, filename, COM_GetExtension( filename ) );\n\t}\n}\n\n/*\n=================\nFS_CopyFile\n\nCopy a fully specified file from one place to another\n=================\n*/\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath ) {\n\tFILE\t*f;\n\tint\t\tlen;\n\tbyte\t*buf;\n\n\tFS_CheckFilenameIsMutable( fromOSPath, __func__ );\n\n\tCom_Printf( \"copy %s to %s\\n\", fromOSPath, toOSPath );\n\n\tif (strstr(fromOSPath, \"journal.dat\") || strstr(fromOSPath, \"journaldata.dat\")) {\n\t\tCom_Printf( \"Ignoring journal files\\n\");\n\t\treturn;\n\t}\n\n\tf = fopen( fromOSPath, \"rb\" );\n\tif ( !f ) {\n\t\treturn;\n\t}\n\tfseek (f, 0, SEEK_END);\n\tlen = ftell (f);\n\tfseek (f, 0, SEEK_SET);\n\n\tif ( len == EOF )\n\t{\n\t\tfclose( f );\n\t\tCom_Error( ERR_FATAL, \"Bad file length in FS_CopyFile()\" );\n\t}\n\n\t// we are using direct malloc instead of Z_Malloc here, so it\n\t// probably won't work on a mac... Its only for developers anyway...\n\tbuf = (unsigned char *)malloc( len );\n\tif (fread( buf, 1, len, f ) != (unsigned)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\n\tif( FS_CreatePath( toOSPath ) ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\n\tf = fopen( toOSPath, \"wb\" );\n\tif ( !f ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\tif (fwrite( buf, 1, len, f ) != (unsigned)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tCom_Error( ERR_FATAL, \"Short write in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\tfree( buf );\n}\n\n/*\n===========\nFS_Remove\n\n===========\n*/\nvoid FS_Remove( const char *osPath ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tremove( osPath );\n}\n\n/*\n===========\nFS_HomeRemove\n\n===========\n*/\nvoid FS_HomeRemove( const char *homePath ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tremove( FS_BuildOSPath( fs_homepath->string,\n\t\t\tfs_gamedir, homePath ) );\n}\n\n/*\n===========\nFS_Rmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_Rmdir( const char *osPath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tif ( recursive ) {\n\t\tint numfiles;\n\t\tint i;\n\t\tchar **filesToRemove = Sys_ListFiles( osPath, \"\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tchar fileOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( fileOsPath, sizeof( fileOsPath ), \"%s/%s\", osPath, filesToRemove[i] );\n\t\t\tFS_Remove( fileOsPath );\n\t\t}\n\t\tFS_FreeFileList( filesToRemove );\n\n\t\tchar **directoriesToRemove = Sys_ListFiles( osPath, \"/\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tif ( !Q_stricmp( directoriesToRemove[i], \".\" ) || !Q_stricmp( directoriesToRemove[i], \"..\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar directoryOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( directoryOsPath, sizeof( directoryOsPath ), \"%s/%s\", osPath, directoriesToRemove[i] );\n\t\t\tFS_Rmdir( directoryOsPath, qtrue );\n\t\t}\n\t\tFS_FreeFileList( directoriesToRemove );\n\t}\n\n\trmdir( osPath );\n}\n\n/*\n===========\nFS_HomeRmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_HomeRmdir( const char *homePath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tFS_Rmdir( FS_BuildOSPath( fs_homepath->string,\n\t\t\t\t\tfs_gamedir, homePath ), recursive );\n}\n\n/*\n================\nFS_FileInPathExists\n\nTests if path and file exists\n================\n*/\nqboolean FS_FileInPathExists(const char *testpath)\n{\n\tFILE *filep;\n\n\tfilep = fopen(testpath, \"rb\");\n\n\tif(filep)\n\t{\n\t\tfclose(filep);\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_FileExists\n\nTests if the file exists in the current gamedir, this DOES NOT\nsearch the paths.  This is to determine if opening a file to write\n(which always goes into the current gamedir) will cause any overwrites.\nNOTE TTimo: this goes with FS_FOpenFileWrite for opening the file afterwards\n================\n*/\nqboolean FS_FileExists( const char *file )\n{\n\treturn FS_FileInPathExists(FS_BuildOSPath(fs_homepath->string, fs_gamedir, file));\n}\n\n/*\n================\nFS_SV_FileExists\n\nTests if the file exists\n================\n*/\nqboolean FS_SV_FileExists( const char *file )\n{\n\tchar *testpath;\n\n\ttestpath = FS_BuildOSPath( fs_homepath->string, file, \"\");\n\ttestpath[strlen(testpath)-1] = '\\0';\n\n\treturn FS_FileInPathExists(testpath);\n}\n\n/*\n===========\nFS_SV_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_SV_FOpenFileWrite( const char *filename ) {\n\tchar *ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tCom_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_SV_FOpenFileRead\nsearch for a file somewhere below the home path, base path or cd path\nwe search in that order, matching FS_SV_FOpenFileRead order\n===========\n*/\nint FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp ) {\n\tchar *ospath;\n\tfileHandle_t\tf = 0;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\t// search homepath\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\t// remove trailing slash\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_homepath): %s\\n\", ospath );\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// NOTE TTimo on non *nix systems, fs_homepath == fs_basepath, might want to avoid\n\t\tif (Q_stricmp(fs_homepath->string,fs_basepath->string))\n\t\t{\n\t\t\t// search basepath\n\t\t\tospath = FS_BuildOSPath( fs_basepath->string, filename, \"\" );\n\t\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\t\tif ( fs_debug->integer )\n\t\t\t{\n\t\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_basepath): %s\\n\", ospath );\n\t\t\t}\n\n\t\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\t\tfsh[f].handleSync = qfalse;\n\t\t}\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// search cd path\n\t\tospath = FS_BuildOSPath( fs_cdpath->string, filename, \"\" );\n\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\tif (fs_debug->integer)\n\t\t{\n\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_cdpath) : %s\\n\", ospath );\n\t\t}\n\n\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\tfsh[f].handleSync = qfalse;\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\t*fp = f;\n\tif (f) {\n\t\treturn FS_filelength(f);\n\t}\n\treturn 0;\n}\n\n/*\n===========\nFS_SV_Rename\n\n===========\n*/\nvoid FS_SV_Rename( const char *from, const char *to, qboolean safe ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, from, \"\" );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, to, \"\" );\n\tfrom_ospath[strlen(from_ospath)-1] = '\\0';\n\tto_ospath[strlen(to_ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\t}\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_Rename\n\n===========\n*/\nvoid FS_Rename( const char *from, const char *to ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_FCloseFile\n\nClose a file.\n\nThere are three cases handled:\n\n  * normal file: closed with fclose.\n\n  * file in pak3 archive: subfile is closed with unzCloseCurrentFile, but the\n    minizip handle to the pak3 remains open.\n\n  * file in pak3 archive, opened with \"unique\" flag: This file did not use\n    the system minizip handle to the pak3 file, but its own dedicated one.\n    The dedicated handle is closed with unzClose.\n\n===========\n*/\nvoid FS_FCloseFile( fileHandle_t f ) {\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\tunzCloseCurrentFile( fsh[f].handleFiles.file.z );\n\t\tif ( fsh[f].handleFiles.unique ) {\n\t\t\tunzClose( fsh[f].handleFiles.file.z );\n\t\t}\n\t\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n\t\treturn;\n\t}\n\n\t// we didn't find it as a pak, so close it as a unique file\n\tif (fsh[f].handleFiles.file.o) {\n\t\tfclose (fsh[f].handleFiles.file.o);\n\t}\n\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n}\n\n/*\n===========\nFS_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_FOpenFileWrite( const char *filename, qboolean safe ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\t}\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\t// enabling the following line causes a recursive function call loop\n\t// when running with +set logfile 1 +set developer 1\n\t//Com_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FOpenFileAppend\n\n===========\n*/\nfileHandle_t FS_FOpenFileAppend( const char *filename ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileAppend: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"ab\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FilenameCompare\n\nIgnore case and separator char distinctions\n===========\n*/\nqboolean FS_FilenameCompare( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 != c2) {\n\t\t\treturn qtrue;\t\t// strings not equal\n\t\t}\n\t} while (c1);\n\n\treturn qfalse;\t\t// strings are equal\n}\n\n/*\n===========\nFS_IsExt\n\nReturn qtrue if ext matches file extension filename\n===========\n*/\n\nqboolean FS_IsExt(const char *filename, const char *ext, int namelen)\n{\n\tint extlen;\n\n\textlen = strlen(ext);\n\n\tif(extlen > namelen)\n\t\treturn qfalse;\n\n\tfilename += namelen - extlen;\n\n\treturn (qboolean)!Q_stricmp(filename, ext);\n}\n\n/*\n===========\nFS_IsDemoExt\n\nReturn qtrue if filename has a demo extension\n===========\n*/\n\n#define DEMO_EXTENSION \"dm_\"\nqboolean FS_IsDemoExt(const char *filename, int namelen)\n{\n\tconst char *ext_test;\n\n\text_test = strrchr(filename, '.');\n\tif(ext_test && !Q_stricmpn(ext_test + 1, DEMO_EXTENSION, ARRAY_LEN(DEMO_EXTENSION) - 1))\n\t{\n\t\tint protocol = atoi(ext_test + ARRAY_LEN(DEMO_EXTENSION));\n\n\t\tif(protocol == PROTOCOL_VERSION)\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n#ifdef _WIN32\n\nbool Sys_GetFileTime(LPCSTR psFileName, FILETIME &ft)\n{\n\tbool bSuccess = false;\n\tHANDLE hFile = INVALID_HANDLE_VALUE;\n\n\thFile = CreateFile(\tpsFileName,\t// LPCTSTR lpFileName,          // pointer to name of the file\n\t\t\t\t\t\tGENERIC_READ,\t\t\t// DWORD dwDesiredAccess,       // access (read-write) mode\n\t\t\t\t\t\tFILE_SHARE_READ,\t\t// DWORD dwShareMode,           // share mode\n\t\t\t\t\t\tNULL,\t\t\t\t\t// LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t// pointer to security attributes\n\t\t\t\t\t\tOPEN_EXISTING,\t\t\t// DWORD dwCreationDisposition,  // how to create\n\t\t\t\t\t\tFILE_FLAG_NO_BUFFERING,// DWORD dwFlagsAndAttributes,   // file attributes\n\t\t\t\t\t\tNULL\t\t\t\t\t// HANDLE hTemplateFile          // handle to file with attributes to\n\t\t\t\t\t\t);\n\n\tif (hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (GetFileTime(hFile,\t// handle to file\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpCreationTime\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpLastAccessTime\n\t\t\t\t\t\t&ft\t\t// LPFILETIME lpLastWriteTime\n\t\t\t\t\t\t)\n\t\t\t)\n\t\t{\n\t\t\tbSuccess = true;\n\t\t}\n\n\t\tCloseHandle(hFile);\n\t}\n\n\treturn bSuccess;\n}\n\nbool Sys_FileOutOfDate( LPCSTR psFinalFileName /* dest */, LPCSTR psDataFileName /* src */ )\n{\n\tFILETIME ftFinalFile, ftDataFile;\n\n\tif (Sys_GetFileTime(psFinalFileName, ftFinalFile) && Sys_GetFileTime(psDataFileName, ftDataFile))\n\t{\n\t\t// timer res only accurate to within 2 seconds on FAT, so can't do exact compare...\n\t\t//\n\t\t//LONG l = CompareFileTime( &ftFinalFile, &ftDataFile );\n\t\tif (  (fabs((double)(ftFinalFile.dwLowDateTime - ftDataFile.dwLowDateTime)) <= 20000000 ) &&\n\t\t\t\t  ftFinalFile.dwHighDateTime == ftDataFile.dwHighDateTime\n\t\t\t)\n\t\t{\n\t\t\treturn false;\t// file not out of date, ie use it.\n\t\t}\n\t\treturn true;\t// flag return code to copy over a replacement version of this file\n\t}\n\n\n\t// extra error check, report as suspicious if you find a file locally but not out on the net.,.\n\t//\n\tif (com_developer->integer)\n\t{\n\t\tif (!Sys_GetFileTime(psDataFileName, ftDataFile))\n\t\t{\n\t\t\tCom_Printf( \"Sys_FileOutOfDate: reading %s but it's not on the net!\\n\", psFinalFileName);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n#endif // _WIN32\n\nbool FS_FileCacheable(const char* const filename)\n{\n\textern\tcvar_t\t*com_buildScript;\n\tif (com_buildScript && com_buildScript->integer)\n\t{\n\t\treturn true;\n\t}\n\treturn( strchr(filename, '/') != 0 );\n}\n\n/*\n===========\nFS_FOpenFileRead\n\nFinds the file in the search path.\nReturns filesize and an open FILE pointer.\nUsed for streaming data out of either a\nseparate file or a ZIP file.\n===========\n*/\nextern qboolean\t\tcom_fullyInitialized;\n\nlong FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE ) {\n\tsearchpath_t\t*search;\n\tchar\t\t\t*netpath;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tdirectory_t\t\t*dir;\n\tlong\t\t\thash;\n\t//unz_s\t\t\t*zfi;\n\t//void\t\t\t*temp;\n\tint\t\t\t\tl;\n\n\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( file == NULL ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'file' parameter passed\\n\" );\n\t}\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t// make sure the q3key file is only readable by the quake3.exe at initialization\n\t// any other time the key should only be accessed in memory using the provided functions\n\tif( com_fullyInitialized && strstr( filename, \"q3key\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\t*file = FS_HandleForFile();\n\tfsh[*file].handleFiles.unique = uniqueFILE;\n\n\t// this new bool is in for an optimisation, if you (eg) opened a BSP file under fs_copyfiles==2,\n\t//\tthen it triggered a copy operation to update your local HD version, then this will re-open the\n\t//\tfile handle on your local version, not the net build. This uses a bit more CPU to re-do the loop\n\t//\tlogic, but should read faster than accessing the net version a second time.\n\t//\n\tqboolean bFasterToReOpenUsingNewLocalFile = qfalse;\n\n\tdo\n\t{\n\t\tbFasterToReOpenUsingNewLocalFile = qfalse;\n\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t//\n\t\t\tif ( search->pack ) {\n\t\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t\t}\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t\t// disregard if it doesn't match one of the allowed pure pak files\n\t\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpak = search->pack;\n\t\t\t\tpakFile = pak->hashTable[hash];\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\n\t\t\t\t\t\t// mark the pak as having been referenced and mark specifics on cgame and ui\n\t\t\t\t\t\t// shaders, txt, arena files  by themselves do not count as a reference as\n\t\t\t\t\t\t// these are loaded from all pk3s\n\t\t\t\t\t\t// from every pk3 file..\n\n\t\t\t\t\t\t// The x86.dll suffixes are needed in order for sv_pure to continue to\n\t\t\t\t\t\t// work on non-x86/windows systems...\n\n\t\t\t\t\t\tl = strlen( filename );\n\t\t\t\t\t\tif ( !(pak->referenced & FS_GENERAL_REF)) {\n\t\t\t\t\t\t\tif( !FS_IsExt(filename, \".shader\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".txt\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".str\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".cfg\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".config\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".bot\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".arena\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".menu\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".fcf\", l) &&\n\t\t\t\t\t\t\t    Q_stricmp(filename, \"jampgamex86.dll\") != 0 &&\n\t\t\t\t\t\t\t    //Q_stricmp(filename, \"vm/qagame.qvm\") != 0 &&\n\t\t\t\t\t\t\t    !strstr(filename, \"levelshots\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_GENERAL_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(pak->referenced & FS_CGAME_REF))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( Q_stricmp( filename, \"cgame.qvm\" ) == 0 ||\n\t\t\t\t\t\t\t\t\tQ_stricmp( filename, \"cgamex86.dll\" ) == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_CGAME_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(pak->referenced & FS_UI_REF))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( Q_stricmp( filename, \"ui.qvm\" ) == 0 ||\n\t\t\t\t\t\t\t\t\tQ_stricmp( filename, \"uix86.dll\" ) == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_UI_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( uniqueFILE ) {\n\t\t\t\t\t\t\t// open a new file on the pakfile\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = unzOpen (pak->pakFilename);\n\t\t\t\t\t\t\tif (fsh[*file].handleFiles.file.z == NULL) {\n\t\t\t\t\t\t\t\tCom_Error (ERR_FATAL, \"Couldn't open %s\", pak->pakFilename);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = pak->handle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\t\t\tfsh[*file].zipFile = qtrue;\n\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);\n\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile(fsh[*file].handleFiles.file.z);\n\n#if 0\n\t\t\t\t\t\tzfi = (unz_s *)fsh[*file].handleFiles.file.z;\n\t\t\t\t\t\t// in case the file was new\n\t\t\t\t\t\ttemp = zfi->filestream;\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(pak->handle, pakFile->pos);\n\t\t\t\t\t\t// copy the file info into the unzip structure\n\t\t\t\t\t\tCom_Memcpy( zfi, pak->handle, sizeof(unz_s) );\n\t\t\t\t\t\t// we copy this back into the structure\n\t\t\t\t\t\tzfi->filestream = temp;\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile( fsh[*file].handleFiles.file.z );\n#endif\n\t\t\t\t\t\tfsh[*file].zipFilePos = pakFile->pos;\n\t\t\t\t\t\tfsh[*file].zipFileLen = pakFile->len;\n\n\t\t\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s')\\n\",\n\t\t\t\t\t\t\t\tfilename, pak->pakFilename );\n\t\t\t\t\t\t}\n\t#ifndef DEDICATED\n\t#ifndef FINAL_BUILD\n\t\t\t\t\t\t// Check for unprecached files when in game but not in the menus\n\t\t\t\t\t\tif((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCom_Printf(S_COLOR_YELLOW \"WARNING: File %s not precached\\n\", filename);\n\t\t\t\t\t\t}\n\t#endif\n\t#endif // DEDICATED\n\t\t\t\t\t\treturn pakFile->len;\n\t\t\t\t\t}\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while(pakFile != NULL);\n\t\t\t} else if ( search->dir ) {\n\t\t\t\t// check a file in the directory tree\n\n\t\t\t\t// if we are running restricted, the only files we\n\t\t\t\t// will allow to come from the directory are .cfg files\n\t\t\t\tl = strlen( filename );\n\t\t  // FIXME TTimo I'm not sure about the fs_numServerPaks test\n\t\t  // if you are using FS_ReadFile to find out if a file exists,\n\t\t  //   this test can make the search fail although the file is in the directory\n\t\t  // I had the problem on https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=8\n\t\t  // turned out I used FS_FileExists instead\n\t\t\t\tif ( fs_numServerPaks ) {\n\t\t\t\t\tif ( !FS_IsExt( filename, \".cfg\", l ) &&\t\t// for config files\n\t\t\t\t\t    !FS_IsExt( filename, \".fcf\", l ) &&\t\t// force configuration files\n\t\t\t\t\t    !FS_IsExt( filename, \".menu\", l ) &&\t\t// menu files\n\t\t\t\t\t    !FS_IsExt( filename, \".game\", l ) &&\t\t// menu files\n\t\t\t\t\t    !FS_IsExt( filename, \".dat\", l ) &&\t\t// for journal files\n\t\t\t\t\t    !FS_IsDemoExt( filename, l ) ) {\t\t\t// demos\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdir = search->dir;\n\n\t\t\t\tnetpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\t\tfsh[*file].handleFiles.file.o = fopen (netpath, \"rb\");\n\t\t\t\tif ( !fsh[*file].handleFiles.file.o ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !FS_IsExt( filename, \".cfg\", l ) &&\t\t// for config files\n\t\t\t\t\t!FS_IsExt( filename, \".fcf\", l ) &&\t\t// force configuration files\n\t\t\t\t\t!FS_IsExt( filename, \".menu\", l ) &&\t\t// menu files\n\t\t\t\t\t!FS_IsExt( filename, \".game\", l ) &&\t\t// menu files\n\t\t\t\t\t!FS_IsExt( filename, \".dat\", l ) &&\t\t// for journal files\n\t\t\t\t\t!FS_IsDemoExt( filename, l ) ) {\t\t\t// demos\n\t\t\t\t\tfs_fakeChkSum = Q_flrand(0.0f, 1.0f);\n\t\t\t\t}\n#ifdef _WIN32\n\t\t\t\t// if running with fs_copyfiles 2, and search path == local, then we need to fail to open\n\t\t\t\t//\tif the time/date stamp != the network version (so it'll loop round again and use the network path,\n\t\t\t\t//\twhich comes later in the search order)\n\t\t\t\t//\n\t\t\t\tif ( fs_copyfiles->integer == 2 && fs_cdpath->string[0] && !Q_stricmp( dir->path, fs_basepath->string )\n\t\t\t\t\t&& FS_FileCacheable(filename) )\n\t\t\t\t{\n\t\t\t\t\tif ( Sys_FileOutOfDate( netpath, FS_BuildOSPath( fs_cdpath->string, dir->gamedir, filename ) ))\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\tfsh[*file].handleFiles.file.o = 0;\n\t\t\t\t\t\tcontinue;\t//carry on to find the cdpath version.\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\tfsh[*file].zipFile = qfalse;\n\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s%c%s')\\n\", filename,\n\t\t\t\t\t\tdir->path, PATH_SEP, dir->gamedir );\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if we are getting it from the cdpath, optionally copy it\n\t\t\t\t//  to the basepath\n\t\t\t\tif ( fs_copyfiles->integer && !Q_stricmp( dir->path, fs_cdpath->string ) ) {\n\t\t\t\t\tchar\t*copypath;\n\n\t\t\t\t\tcopypath = FS_BuildOSPath( fs_basepath->string, dir->gamedir, filename );\n\t\t\t\t\tswitch ( fs_copyfiles->integer )\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFS_CopyFile( netpath, copypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (FS_FileCacheable(filename) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// maybe change this to Com_DPrintf?   On the other hand...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tCom_Printf( \"fs_copyfiles(2), Copying: %s to %s\\n\", netpath, copypath );\n\n\t\t\t\t\t\t\t\tFS_CreatePath( copypath );\n\n\t\t\t\t\t\t\t\tbool bOk = true;\n\t\t\t\t\t\t\t\tif (!CopyFile( netpath, copypath, FALSE ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDWORD dwAttrs = GetFileAttributes(copypath);\n\t\t\t\t\t\t\t\t\tSetFileAttributes(copypath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);\n\t\t\t\t\t\t\t\t\tbOk = !!CopyFile( netpath, copypath, FALSE );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (bOk)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// clear this handle and setup for re-opening of the new local copy...\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tbFasterToReOpenUsingNewLocalFile = qtrue;\n\t\t\t\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\t\t\t\tfsh[*file].handleFiles.file.o = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (bFasterToReOpenUsingNewLocalFile)\n\t\t\t\t{\n\t\t\t\t\tbreak;\t// and re-read the local copy, not the net version\n\t\t\t\t}\n\n\t#ifndef DEDICATED\n\t#ifndef FINAL_BUILD\n\t\t\t\t// Check for unprecached files when in game but not in the menus\n\t\t\t\tif((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))\n\t\t\t\t{\n\t\t\t\t\tCom_Printf(S_COLOR_YELLOW \"WARNING: File %s not precached\\n\", filename);\n\t\t\t\t}\n\t#endif\n\t#endif // dedicated\n\t\t\t\treturn FS_fplength(fsh[*file].handleFiles.file.o);\n\t\t\t}\n\t\t}\n\t}\n\twhile ( bFasterToReOpenUsingNewLocalFile );\n\n\tCom_DPrintf (\"Can't find %s\\n\", filename);\n#ifdef FS_MISSING\n\tif (missingFiles) {\n\t\tfprintf(missingFiles, \"%s\\n\", filename);\n\t}\n#endif\n\t*file = 0;\n\treturn -1;\n}\n\n// This is a bit of a hack but it is used for other OS'/arch to still be acceptable with pure servers.\n// Intentionally looking for x86.dll because this is all that exists in pk3s.\nqboolean FS_FindPureDLL(const char *name)\n{\n\tchar dllName[MAX_OSPATH];\n\tfileHandle_t h;\n\n\tif(!fs_searchpaths)\n\t\tCom_Error(ERR_FATAL, \"Filesystem call made without initialization\");\n\n\tif ( !Cvar_VariableValue( \"sv_pure\" ) )\n\t\treturn qtrue;\n\n\tCom_sprintf(dllName, sizeof(dllName), \"%sx86.dll\", name);\n\n\tif(FS_FOpenFileRead(dllName, &h, qtrue) > 0)\n\t{\n\t\tFS_FCloseFile( h );\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_Read\n\nProperly handles partial reads\n=================\n*/\nint FS_Read( void *buffer, int len, fileHandle_t f ) {\n\tint\t\tblock, remaining;\n\tint\t\tread;\n\tbyte\t*buf;\n\tint\t\ttries;\n\n\tFS_AssertInitialised();\n\n\tif ( !f ) {\n\t\treturn 0;\n\t}\n\n\tbuf = (byte *)buffer;\n\tfs_readCount += len;\n\n\tif (fsh[f].zipFile == qfalse) {\n\t\tremaining = len;\n\t\ttries = 0;\n\t\twhile (remaining) {\n\t\t\tblock = remaining;\n\t\t\tread = fread (buf, 1, block, fsh[f].handleFiles.file.o);\n\t\t\tif (read == 0) {\n\t\t\t\t// we might have been trying to read from a CD, which\n\t\t\t\t// sometimes returns a 0 read on windows\n\t\t\t\tif (!tries) {\n\t\t\t\t\ttries = 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn len-remaining;\t//Com_Error (ERR_FATAL, \"FS_Read: 0 bytes read\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tCom_Error (ERR_FATAL, \"FS_Read: -1 bytes read\");\n\t\t\t}\n\n\t\t\tremaining -= read;\n\t\t\tbuf += read;\n\t\t}\n\t\treturn len;\n\t} else {\n\t\treturn unzReadCurrentFile(fsh[f].handleFiles.file.z, buffer, len);\n\t}\n}\n\n/*\n=================\nFS_Write\n\nProperly handles partial writes\n=================\n*/\nint FS_Write( const void *buffer, int len, fileHandle_t h ) {\n\tint\t\tblock, remaining;\n\tint\t\twritten;\n\tbyte\t*buf;\n\tint\t\ttries;\n\tFILE\t*f;\n\n\tFS_AssertInitialised();\n\n\tif ( !h ) {\n\t\treturn 0;\n\t}\n\n\tf = FS_FileForHandle(h);\n\tbuf = (byte *)buffer;\n\n\tremaining = len;\n\ttries = 0;\n\twhile (remaining) {\n\t\tblock = remaining;\n\t\twritten = fwrite (buf, 1, block, f);\n\t\tif (written == 0) {\n\t\t\tif (!tries) {\n\t\t\t\ttries = 1;\n\t\t\t} else {\n\t\t\t\tCom_Printf( \"FS_Write: 0 bytes written\\n\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (written == -1) {\n\t\t\tCom_Printf( \"FS_Write: -1 bytes written\\n\" );\n\t\t\treturn 0;\n\t\t}\n\n\t\tremaining -= written;\n\t\tbuf += written;\n\t}\n\tif ( fsh[h].handleSync ) {\n\t\tfflush( f );\n\t}\n\treturn len;\n}\n\nvoid QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf (msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tFS_Write(msg, strlen(msg), h);\n}\n\n#define PK3_SEEK_BUFFER_SIZE 65536\n/*\n=================\nFS_Seek\n\n=================\n*/\nint FS_Seek( fileHandle_t f, long offset, int origin ) {\n\tint\t\t_origin;\n\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\t//FIXME: this is really, really crappy\n\t\t//(but better than what was here before)\n\t\tbyte\tbuffer[PK3_SEEK_BUFFER_SIZE];\n\t\tint\t\tremainder;\n\t\tint\t\tcurrentPosition = FS_FTell( f );\n\n\t\t// change negative offsets into FS_SEEK_SET\n\t\tif ( offset < 0 ) {\n\t\t\tswitch( origin ) {\n\t\t\t\tcase FS_SEEK_END:\n\t\t\t\t\tremainder = fsh[f].zipFileLen + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_CUR:\n\t\t\t\t\tremainder = currentPosition + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_SET:\n\t\t\t\tdefault:\n\t\t\t\t\tremainder = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( remainder < 0 ) {\n\t\t\t\tremainder = 0;\n\t\t\t}\n\n\t\t\torigin = FS_SEEK_SET;\n\t\t} else {\n\t\t\tif ( origin == FS_SEEK_END ) {\n\t\t\t\tremainder = fsh[f].zipFileLen - currentPosition + offset;\n\t\t\t} else {\n\t\t\t\tremainder = offset;\n\t\t\t}\n\t\t}\n\n\t\tswitch( origin ) {\n\t\t\tcase FS_SEEK_SET:\n\t\t\t\tif ( remainder == currentPosition ) {\n\t\t\t\t\treturn offset;\n\t\t\t\t}\n\t\t\t\tunzSetOffset(fsh[f].handleFiles.file.z, fsh[f].zipFilePos);\n\t\t\t\tunzOpenCurrentFile(fsh[f].handleFiles.file.z);\n\t\t\t\t//fallthrough\n\n\t\t\tcase FS_SEEK_END:\n\t\t\tcase FS_SEEK_CUR:\n\t\t\t\twhile( remainder > PK3_SEEK_BUFFER_SIZE ) {\n\t\t\t\t\tFS_Read( buffer, PK3_SEEK_BUFFER_SIZE, f );\n\t\t\t\t\tremainder -= PK3_SEEK_BUFFER_SIZE;\n\t\t\t\t}\n\t\t\t\tFS_Read( buffer, remainder, f );\n\t\t\t\treturn offset;\n\n\t\t\tdefault:\n\t\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\" );\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tFILE *file;\n\t\tfile = FS_FileForHandle(f);\n\t\tswitch( origin ) {\n\t\tcase FS_SEEK_CUR:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tbreak;\n\t\tcase FS_SEEK_END:\n\t\t\t_origin = SEEK_END;\n\t\t\tbreak;\n\t\tcase FS_SEEK_SET:\n\t\t\t_origin = SEEK_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\\n\" );\n\t\t\tbreak;\n\t\t}\n\n\t\treturn fseek( file, offset, _origin );\n\t}\n}\n\n/*\n======================================================================================\n\nCONVENIENCE FUNCTIONS FOR ENTIRE FILES\n\n======================================================================================\n*/\n\nint\tFS_FileIsInPAK(const char *filename, int *pChecksum ) {\n\tsearchpath_t\t*search;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tlong\t\t\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t//\n\t\tif (search->pack) {\n\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t}\n\t\t// is the element a pak file?\n\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t// disregard if it doesn't match one of the allowed pure pak files\n\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tpakFile = pak->hashTable[hash];\n\t\t\tdo {\n\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\tif (pChecksum) {\n\t\t\t\t\t\t*pChecksum = pak->pure_checksum;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpakFile = pakFile->next;\n\t\t\t} while(pakFile != NULL);\n\t\t}\n\t}\n\treturn -1;\n}\n\n/*\n============\nFS_ReadFile\n\nFilename are relative to the quake search path\na null buffer will just return the file length without loading\n============\n*/\nlong FS_ReadFile( const char *qpath, void **buffer ) {\n\tfileHandle_t\th;\n\tbyte*\t\t\tbuf;\n\tqboolean\t\tisConfig;\n\tlong\t\t\t\tlen;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !qpath[0] ) {\n\t\tCom_Error( ERR_FATAL, \"FS_ReadFile with empty name\\n\" );\n\t}\n\n\tbuf = NULL;\t// quiet compiler warning\n\n\t// if this is a .cfg file and we are playing back a journal, read\n\t// it from the journal file\n\tif ( strstr( qpath, \".cfg\" ) ) {\n\t\tisConfig = qtrue;\n\t\tif ( com_journal && com_journal->integer == 2 ) {\n\t\t\tint\t\tr;\n\n\t\t\tCom_DPrintf( \"Loading %s from journal file.\\n\", qpath );\n\t\t\tr = FS_Read( &len, sizeof( len ), com_journalDataFile );\n\t\t\tif ( r != sizeof( len ) ) {\n\t\t\t\tif (buffer != NULL) *buffer = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// if the file didn't exist when the journal was created\n\t\t\tif (!len) {\n\t\t\t\tif (buffer == NULL) {\n\t\t\t\t\treturn 1;\t\t\t// hack for old journal files\n\t\t\t\t}\n\t\t\t\t*buffer = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (buffer == NULL) {\n\t\t\t\treturn len;\n\t\t\t}\n\n\t\t\tbuf = (unsigned char *)Hunk_AllocateTempMemory(len+1);\n\t\t\t*buffer = buf;\n\n\t\t\tr = FS_Read( buf, len, com_journalDataFile );\n\t\t\tif ( r != len ) {\n\t\t\t\tCom_Error( ERR_FATAL, \"Read from journalDataFile failed\" );\n\t\t\t}\n\n\t\t\tfs_loadCount++;\n\n\t\t\t// guarantee that it will have a trailing 0 for string operations\n\t\t\tbuf[len] = 0;\n\n\t\t\treturn len;\n\t\t}\n\t} else {\n\t\tisConfig = qfalse;\n\t}\n\n\t// look for it in the filesystem or pack files\n\tlen = FS_FOpenFileRead( qpath, &h, qfalse );\n\tif ( h == 0 ) {\n\t\tif ( buffer ) {\n\t\t\t*buffer = NULL;\n\t\t}\n\t\t// if we are journalling and it is a config file, write a zero to the journal file\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing zero for %s to journal file.\\n\", qpath );\n\t\t\tlen = 0;\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( !buffer ) {\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing len for %s to journal file.\\n\", qpath );\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\tFS_FCloseFile( h);\n\t\treturn len;\n\t}\n\n\tfs_loadCount++;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\tbuf[len]='\\0';\t// because we're not calling Z_Malloc with optional trailing 'bZeroIt' bool\n\t*buffer = buf;\n\n//\tZ_Label(buf, qpath);\n\n\tFS_Read (buf, len, h);\n\n\t// guarantee that it will have a trailing 0 for string operations\n\tbuf[len] = 0;\n\tFS_FCloseFile( h );\n\n\t// if we are journalling and it is a config file, write it to the journal file\n\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\tCom_DPrintf( \"Writing %s to journal file.\\n\", qpath );\n\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\tFS_Write( buf, len, com_journalDataFile );\n\t\tFS_Flush( com_journalDataFile );\n\t}\n\treturn len;\n}\n\n/*\n=============\nFS_FreeFile\n=============\n*/\nvoid FS_FreeFile( void *buffer ) {\n\tFS_AssertInitialised();\n\tif ( !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FreeFile( NULL )\" );\n\t}\n\n\tZ_Free( buffer );\n}\n\n/*\n============\nFS_WriteFile\n\nFilename are reletive to the quake search path\n============\n*/\nvoid FS_WriteFile( const char *qpath, const void *buffer, int size ) {\n\tfileHandle_t f;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_WriteFile: NULL parameter\" );\n\t}\n\n\tf = FS_FOpenFileWrite( qpath );\n\tif ( !f ) {\n\t\tCom_Printf( \"Failed to open %s\\n\", qpath );\n\t\treturn;\n\t}\n\n\tFS_Write( buffer, size, f );\n\n\tFS_FCloseFile( f );\n}\n\n/*\n==========================================================================\n\nZIP FILE LOADING\n\n==========================================================================\n*/\n\n/*\n=================\nFS_LoadZipFile\n\nCreates a new pak_t in the search chain for the contents\nof a zip file.\n=================\n*/\nstatic pack_t *FS_LoadZipFile( const char *zipfile, const char *basename )\n{\n\tfileInPack_t\t*buildBuffer;\n\tpack_t\t\t\t*pack;\n\tunzFile\t\t\tuf;\n\tint\t\t\t\terr;\n\tunz_global_info gi;\n\tchar\t\t\tfilename_inzip[MAX_ZPATH];\n\tunz_file_info\tfile_info;\n\tint\t\t\t\tlen;\n\tsize_t\t\t\ti;\n\tlong\t\t\thash;\n\tint\t\t\t\tfs_numHeaderLongs;\n\tint\t\t\t\t*fs_headerLongs;\n\tchar\t\t\t*namePtr;\n\n\tfs_numHeaderLongs = 0;\n\n\tuf = unzOpen(zipfile);\n\terr = unzGetGlobalInfo (uf,&gi);\n\n\tif (err != UNZ_OK)\n\t\treturn NULL;\n\n\tlen = 0;\n\tunzGoToFirstFile(uf);\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tlen += strlen(filename_inzip) + 1;\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tbuildBuffer = (struct fileInPack_s *)Z_Malloc( (gi.number_entry * sizeof( fileInPack_t )) + len, TAG_FILESYS, qtrue );\n\tnamePtr = ((char *) buildBuffer) + gi.number_entry * sizeof( fileInPack_t );\n\tfs_headerLongs = (int *)Z_Malloc( ( gi.number_entry + 1 ) * sizeof(int), TAG_FILESYS, qtrue );\n\tfs_headerLongs[ fs_numHeaderLongs++ ] = LittleLong( fs_checksumFeed );\n\n\t// get the hash table size from the number of files in the zip\n\t// because lots of custom pk3 files have less than 32 or 64 files\n\tfor (i = 1; i <= MAX_FILEHASH_SIZE; i <<= 1) {\n\t\tif (i > gi.number_entry) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpack = (pack_t *)Z_Malloc( sizeof( pack_t ) + i * sizeof(fileInPack_t *), TAG_FILESYS, qtrue );\n\tpack->hashSize = i;\n\tpack->hashTable = (fileInPack_t **) (((char *) pack) + sizeof( pack_t ));\n\tfor(int j = 0; j < pack->hashSize; j++) {\n\t\tpack->hashTable[j] = NULL;\n\t}\n\n\tQ_strncpyz( pack->pakFilename, zipfile, sizeof( pack->pakFilename ) );\n\tQ_strncpyz( pack->pakBasename, basename, sizeof( pack->pakBasename ) );\n\n\t// strip .pk3 if needed\n\tif ( strlen( pack->pakBasename ) > 4 && !Q_stricmp( pack->pakBasename + strlen( pack->pakBasename ) - 4, \".pk3\" ) ) {\n\t\tpack->pakBasename[strlen( pack->pakBasename ) - 4] = 0;\n\t}\n\n\tpack->handle = uf;\n\tpack->numfiles = gi.number_entry;\n\tunzGoToFirstFile(uf);\n\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tif (file_info.uncompressed_size > 0) {\n\t\t\tfs_headerLongs[fs_numHeaderLongs++] = LittleLong(file_info.crc);\n\t\t}\n\t\tQ_strlwr( filename_inzip );\n\t\thash = FS_HashFileName(filename_inzip, pack->hashSize);\n\t\tbuildBuffer[i].name = namePtr;\n\t\tstrcpy( buildBuffer[i].name, filename_inzip );\n\t\tnamePtr += strlen(filename_inzip) + 1;\n\t\t// store the file position in the zip\n\t\tbuildBuffer[i].pos = unzGetOffset(uf);\n\t\tbuildBuffer[i].len = file_info.uncompressed_size;\n\t\tbuildBuffer[i].next = pack->hashTable[hash];\n\t\tpack->hashTable[hash] = &buildBuffer[i];\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tpack->checksum = Com_BlockChecksum( &fs_headerLongs[ 1 ], sizeof(*fs_headerLongs) * ( fs_numHeaderLongs - 1 ) );\n\tpack->pure_checksum = Com_BlockChecksum( fs_headerLongs, sizeof(*fs_headerLongs) * fs_numHeaderLongs );\n\tpack->checksum = LittleLong( pack->checksum );\n\tpack->pure_checksum = LittleLong( pack->pure_checksum );\n\n\tZ_Free(fs_headerLongs);\n\n\tpack->buildBuffer = buildBuffer;\n\treturn pack;\n}\n\n/*\n=================\nFS_FreePak\n\nFrees a pak structure and releases all associated resources\n=================\n*/\n\nvoid FS_FreePak(pack_t *thepak)\n{\n\tunzClose(thepak->handle);\n\tZ_Free(thepak->buildBuffer);\n\tZ_Free(thepak);\n}\n\n/*\n=================\nFS_GetZipChecksum\n\nCompares whether the given pak file matches a referenced checksum\n=================\n*/\nqboolean FS_CompareZipChecksum(const char *zipfile)\n{\n\tpack_t *thepak;\n\tint index, checksum;\n\n\tthepak = FS_LoadZipFile(zipfile, \"\");\n\n\tif(!thepak)\n\t\treturn qfalse;\n\n\tchecksum = thepak->checksum;\n\tFS_FreePak(thepak);\n\n\tfor(index = 0; index < fs_numServerReferencedPaks; index++)\n\t{\n\t\tif(checksum == fs_serverReferencedPaks[index])\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n=================================================================================\n\nDIRECTORY SCANNING FUNCTIONS\n\n=================================================================================\n*/\n\n#define\tMAX_FOUND_FILES\t0x1000\n\nstatic int FS_ReturnPath( const char *zname, char *zpath, int *depth ) {\n\tint len, at, newdep;\n\n\tnewdep = 0;\n\tzpath[0] = 0;\n\tlen = 0;\n\tat = 0;\n\n\twhile(zname[at] != 0)\n\t{\n\t\tif (zname[at]=='/' || zname[at]=='\\\\') {\n\t\t\tlen = at;\n\t\t\tnewdep++;\n\t\t}\n\t\tat++;\n\t}\n\tstrcpy(zpath, zname);\n\tzpath[len] = 0;\n\t*depth = newdep;\n\n\treturn len;\n}\n\n/*\n==================\nFS_AddFileToList\n==================\n*/\nstatic int FS_AddFileToList( char *name, char *list[MAX_FOUND_FILES], int nfiles ) {\n\tint\t\ti;\n\n\tif ( nfiles == MAX_FOUND_FILES - 1 ) {\n\t\treturn nfiles;\n\t}\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tif ( !Q_stricmp( name, list[i] ) ) {\n\t\t\treturn nfiles;\t\t// allready in list\n\t\t}\n\t}\n\tlist[nfiles] = CopyString( name );\n\tnfiles++;\n\n\treturn nfiles;\n}\n\n/*\n===============\nFS_ListFilteredFiles\n\nReturns a uniqued list of files that match the given criteria\nfrom all search paths\n===============\n*/\nchar **FS_ListFilteredFiles( const char *path, const char *extension, char *filter, int *numfiles ) {\n\tint\t\t\t\tnfiles;\n\tchar\t\t\t**listCopy;\n\tchar\t\t\t*list[MAX_FOUND_FILES];\n\tsearchpath_t\t*search;\n\tint\t\t\t\ti;\n\tint\t\t\t\tpathLength;\n\tint\t\t\t\textensionLength;\n\tint\t\t\t\tlength, pathDepth, temp;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*buildBuffer;\n\tchar\t\t\tzpath[MAX_ZPATH];\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n\n\tif ( !path ) {\n\t\t*numfiles = 0;\n\t\treturn NULL;\n\t}\n\tif ( !extension ) {\n\t\textension = \"\";\n\t}\n\n\tpathLength = strlen( path );\n\tif ( path[pathLength-1] == '\\\\' || path[pathLength-1] == '/' ) {\n\t\tpathLength--;\n\t}\n\textensionLength = strlen( extension );\n\tnfiles = 0;\n\tFS_ReturnPath(path, zpath, &pathDepth);\n\n\t//\n\t// search through the path, one element at a time, adding to list\n\t//\n\tfor (search = fs_searchpaths ; search ; search = search->next) {\n\t\t// is the element a pak file?\n\t\tif (search->pack) {\n\n\t\t\t//ZOID:  If we are pure, don't search for files on paks that\n\t\t\t// aren't on the pure list\n\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tbuildBuffer = pak->buildBuffer;\n\t\t\tfor (i = 0; i < pak->numfiles; i++) {\n\t\t\t\tchar\t*name;\n\t\t\t\tint\t\tzpathLen, depth;\n\n\t\t\t\t// check for directory match\n\t\t\t\tname = buildBuffer[i].name;\n\t\t\t\t//\n\t\t\t\tif (filter) {\n\t\t\t\t\t// case insensitive\n\t\t\t\t\tif (!Com_FilterPath( filter, name, qfalse ))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// unique the match\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tzpathLen = FS_ReturnPath(name, zpath, &depth);\n\n\t\t\t\t\tif ( (depth-pathDepth)>2 || pathLength > zpathLen || Q_stricmpn( name, path, pathLength ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for extension match\n\t\t\t\t\tlength = strlen( name );\n\t\t\t\t\tif ( length < extensionLength ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Q_stricmp( name + length - extensionLength, extension ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// unique the match\n\n\t\t\t\t\ttemp = pathLength;\n\t\t\t\t\tif (pathLength) {\n\t\t\t\t\t\ttemp++;\t\t// include the '/'\n\t\t\t\t\t}\n\t\t\t\t\tnfiles = FS_AddFileToList( name + temp, list, nfiles );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (search->dir) { // scan for files in the filesystem\n\t\t\tchar\t*netpath;\n\t\t\tint\t\tnumSysFiles;\n\t\t\tchar\t**sysFiles;\n\t\t\tchar\t*name;\n\n\t\t\t// don't scan directories for files if we are pure or restricted\n\t\t\tif ( fs_numServerPaks &&\n\t\t\t\t (!extension || Q_stricmp(extension, \"fcf\")) )\n\t\t\t{\n\t\t\t\t//rww - allow scanning for fcf files outside of pak even if pure\n\t\t\t    continue;\n\t\t    }\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetpath = FS_BuildOSPath( search->dir->path, search->dir->gamedir, path );\n\t\t\t\tsysFiles = Sys_ListFiles( netpath, extension, filter, &numSysFiles, qfalse );\n\t\t\t\tfor ( i = 0 ; i < numSysFiles ; i++ ) {\n\t\t\t\t\t// unique the match\n\t\t\t\t\tname = sysFiles[i];\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\tSys_FreeFileList( sysFiles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// return a copy of the list\n\t*numfiles = nfiles;\n\n\tif ( !nfiles ) {\n\t\treturn NULL;\n\t}\n\n\tlistCopy = (char **)Z_Malloc( ( nfiles + 1 ) * sizeof( *listCopy ), TAG_FILESYS );\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tlistCopy[i] = list[i];\n\t}\n\tlistCopy[i] = NULL;\n\n\treturn listCopy;\n}\n\n/*\n=================\nFS_ListFiles\n=================\n*/\nchar **FS_ListFiles( const char *path, const char *extension, int *numfiles ) {\n\treturn FS_ListFilteredFiles( path, extension, NULL, numfiles );\n}\n\n/*\n=================\nFS_FreeFileList\n=================\n*/\nvoid FS_FreeFileList( char **fileList ) {\n\t//rwwRMG - changed to fileList to not conflict with list type\n\tint\t\ti;\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n\n\tif ( !fileList ) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; fileList[i] ; i++ ) {\n\t\tZ_Free( fileList[i] );\n\t}\n\n\tZ_Free( fileList );\n}\n\n\n/*\n================\nFS_GetFileList\n================\n*/\nint\tFS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {\n\tint\t\tnFiles, i, nTotal, nLen;\n\tchar **pFiles = NULL;\n\n\t*listbuf = 0;\n\tnFiles = 0;\n\tnTotal = 0;\n\n\tif (Q_stricmp(path, \"$modlist\") == 0) {\n\t\treturn FS_GetModList(listbuf, bufsize);\n\t}\n\n\tpFiles = FS_ListFiles(path, extension, &nFiles);\n\n\tfor (i =0; i < nFiles; i++) {\n\t\tnLen = strlen(pFiles[i]) + 1;\n\t\tif (nTotal + nLen + 1 < bufsize) {\n\t\t\tstrcpy(listbuf, pFiles[i]);\n\t\t\tlistbuf += nLen;\n\t\t\tnTotal += nLen;\n\t\t}\n\t\telse {\n\t\t\tnFiles = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFS_FreeFileList(pFiles);\n\n\treturn nFiles;\n}\n\n/*\n=======================\nSys_ConcatenateFileLists\n\nmkv: Naive implementation. Concatenates three lists into a\n     new list, and frees the old lists from the heap.\nbk001129 - from cvs1.17 (mkv)\n\nFIXME TTimo those two should move to common.c next to Sys_ListFiles\n=======================\n */\nstatic unsigned int Sys_CountFileList(char **fileList)\n{\n\tint i = 0;\n\n\tif (fileList)\n\t{\n\t\twhile (*fileList)\n\t\t{\n\t\t\tfileList++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic char** Sys_ConcatenateFileLists( char **list0, char **list1, char **list2 )\n{\n\tint totalLength = 0;\n\tchar** cat = NULL, **dst, **src;\n\n\ttotalLength += Sys_CountFileList(list0);\n\ttotalLength += Sys_CountFileList(list1);\n\ttotalLength += Sys_CountFileList(list2);\n\n\t/* Create new list. */\n\tdst = cat = (char **)Z_Malloc( ( totalLength + 1 ) * sizeof( char* ), TAG_FILESYS, qtrue );\n\n\t/* Copy over lists. */\n\tif (list0) {\n\t\tfor (src = list0; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list1) {\n\t\tfor (src = list1; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list2) {\n\t\tfor (src = list2; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\n\t// Terminate the list\n\t*dst = NULL;\n\n\t// Free our old lists.\n\t// NOTE: not freeing their content, it's been merged in dst and still being used\n\tif (list0) Z_Free( list0 );\n\tif (list1) Z_Free( list1 );\n\tif (list2) Z_Free( list2 );\n\n\treturn cat;\n}\n//#endif\n\n// For base game mod listing\nconst char *SE_GetString( const char *psPackageAndStringReference );\n\n/*\n================\nFS_GetModList\n\nReturns a list of mod directory names\nA mod directory is a peer to base with a pk3 in it\nThe directories are searched in base path, cd path and home path\n================\n*/\nint\tFS_GetModList( char *listbuf, int bufsize ) {\n\tint\t\tnMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;\n\tchar **pFiles = NULL;\n\tchar **pPaks = NULL;\n\tchar *name, *path;\n\tchar descPath[MAX_OSPATH];\n\tfileHandle_t descHandle;\n\n\tint dummy;\n\tchar **pFiles0 = NULL;\n\tchar **pFiles1 = NULL;\n\tchar **pFiles2 = NULL;\n\tqboolean bDrop = qfalse;\n\n\t*listbuf = 0;\n\tnMods = nPotential = nTotal = 0;\n\n\tpFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles2 = Sys_ListFiles( fs_cdpath->string, NULL, NULL, &dummy, qtrue );\n\t// we searched for mods in the three paths\n\t// it is likely that we have duplicate names now, which we will cleanup below\n\tpFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1, pFiles2 );\n\tnPotential = Sys_CountFileList(pFiles);\n\n\tfor ( i = 0 ; i < nPotential ; i++ ) {\n\t\tname = pFiles[i];\n\t\t// NOTE: cleaner would involve more changes\n\t\t// ignore duplicate mod directories\n\t\tif (i!=0) {\n\t\t\tbDrop = qfalse;\n\t\t\tfor(j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif (Q_stricmp(pFiles[j],name)==0) {\n\t\t\t\t\t// this one can be dropped\n\t\t\t\t\tbDrop = qtrue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bDrop) {\n\t\t\tcontinue;\n\t\t}\n\t\t// we drop \".\" and \"..\"\n\t\tif (Q_stricmpn(name, \".\", 1)) {\n\t\t\t// now we need to find some .pk3 files to validate the mod\n\t\t\t// NOTE TTimo: (actually I'm not sure why .. what if it's a mod under developement with no .pk3?)\n\t\t\t// we didn't keep the information when we merged the directory names, as to what OS Path it was found under\n\t\t\t//   so it could be in base path, cd path or home path\n\t\t\t//   we will try each three of them here (yes, it's a bit messy)\n\t\t\tpath = FS_BuildOSPath( fs_basepath->string, name, \"\" );\n\t\t\tnPaks = 0;\n\t\t\tpPaks = Sys_ListFiles(path, \".pk3\", NULL, &nPaks, qfalse);\n\t\t\tSys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present\n\n\t\t\t/* Try on cd path */\n\t\t\tif( nPaks <= 0 ) {\n\t\t\t\tpath = FS_BuildOSPath( fs_cdpath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\t/* try on home path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_homepath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\tif (nPaks > 0) {\n\t\t\t\tbool isBase = !Q_stricmp( name, BASEGAME );\n\t\t\t\tnLen = isBase ? 1 : strlen(name) + 1;\n\t\t\t\t// nLen is the length of the mod path\n\t\t\t\t// we need to see if there is a description available\n\t\t\t\tdescPath[0] = '\\0';\n\t\t\t\tstrcpy(descPath, name);\n\t\t\t\tstrcat(descPath, \"/description.txt\");\n\t\t\t\tnDescLen = FS_SV_FOpenFileRead( descPath, &descHandle );\n\t\t\t\tif ( nDescLen > 0 && descHandle) {\n\t\t\t\t\tFILE *file;\n\t\t\t\t\tfile = FS_FileForHandle(descHandle);\n\t\t\t\t\tCom_Memset( descPath, 0, sizeof( descPath ) );\n\t\t\t\t\tnDescLen = fread(descPath, 1, 48, file);\n\t\t\t\t\tif (nDescLen >= 0) {\n\t\t\t\t\t\tdescPath[nDescLen] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tFS_FCloseFile(descHandle);\n\t\t\t\t} else if ( isBase ) {\n\t\t\t\t\tstrcpy(descPath, SE_GetString(\"MENUS_JEDI_ACADEMY\"));\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(descPath, name);\n\t\t\t\t}\n\t\t\t\tnDescLen = strlen(descPath) + 1;\n\n\t\t\t\tif (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {\n\t\t\t\t\tif ( isBase )\n\t\t\t\t\t\tstrcpy(listbuf, \"\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(listbuf, name);\n\t\t\t\t\tlistbuf += nLen;\n\t\t\t\t\tstrcpy(listbuf, descPath);\n\t\t\t\t\tlistbuf += nDescLen;\n\t\t\t\t\tnTotal += nLen + nDescLen;\n\t\t\t\t\tnMods++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSys_FreeFileList( pFiles );\n\n\treturn nMods;\n}\n\n//============================================================================\n\n/*\n================\nFS_Dir_f\n================\n*/\nvoid FS_Dir_f( void ) {\n\tchar\t*path;\n\tchar\t*extension;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {\n\t\tCom_Printf( \"usage: dir <directory> [extension]\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = \"\";\n\t} else {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = Cmd_Argv( 2 );\n\t}\n\n\tCom_Printf( \"Directory of %s %s\\n\", path, extension );\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFiles( path, extension, &ndirs );\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n===========\nFS_ConvertPath\n===========\n*/\nvoid FS_ConvertPath( char *s ) {\n\twhile (*s) {\n\t\tif ( *s == '\\\\' || *s == ':' ) {\n\t\t\t*s = '/';\n\t\t}\n\t\ts++;\n\t}\n}\n\n/*\n===========\nFS_PathCmp\n\nIgnore case and separator char distinctions\n===========\n*/\nint FS_PathCmp( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 < c2) {\n\t\t\treturn -1;\t\t// strings not equal\n\t\t}\n\t\tif (c1 > c2) {\n\t\t\treturn 1;\n\t\t}\n\t} while (c1);\n\n\treturn 0;\t\t// strings are equal\n}\n\n/*\n================\nFS_SortFileList\n================\n*/\nvoid FS_SortFileList(char **filelist, int numfiles) {\n\tint i, j, k, numsortedfiles;\n\tchar **sortedlist;\n\n\tsortedlist = (char **)Z_Malloc( ( numfiles + 1 ) * sizeof( *sortedlist ), TAG_FILESYS, qtrue );\n\tsortedlist[0] = NULL;\n\tnumsortedfiles = 0;\n\tfor (i = 0; i < numfiles; i++) {\n\t\tfor (j = 0; j < numsortedfiles; j++) {\n\t\t\tif (FS_PathCmp(filelist[i], sortedlist[j]) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (k = numsortedfiles; k > j; k--) {\n\t\t\tsortedlist[k] = sortedlist[k-1];\n\t\t}\n\t\tsortedlist[j] = filelist[i];\n\t\tnumsortedfiles++;\n\t}\n\tCom_Memcpy(filelist, sortedlist, numfiles * sizeof( *filelist ) );\n\tZ_Free(sortedlist);\n}\n\n/*\n================\nFS_NewDir_f\n================\n*/\nvoid FS_NewDir_f( void ) {\n\tchar\t*filter;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 ) {\n\t\tCom_Printf( \"usage: fdir <filter>\\n\" );\n\t\tCom_Printf( \"example: fdir *ffa*.bsp\\n\");\n\t\treturn;\n\t}\n\n\tfilter = Cmd_Argv( 1 );\n\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFilteredFiles( \"\", \"\", filter, &ndirs );\n\n\tFS_SortFileList(dirnames, ndirs);\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tFS_ConvertPath(dirnames[i]);\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tCom_Printf( \"%d files listed\\n\", ndirs );\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n============\nFS_Path_f\n\n============\n*/\nvoid FS_Path_f( void ) {\n\tsearchpath_t\t*s;\n\tint\t\t\t\ti;\n\n\tCom_Printf (\"Current search path:\\n\");\n\tfor (s = fs_searchpaths; s; s = s->next) {\n\t\tif (s->pack) {\n\t\t\tCom_Printf (\"%s (%i files)\\n\", s->pack->pakFilename, s->pack->numfiles);\n\t\t\tif ( fs_numServerPaks ) {\n\t\t\t\tif ( !FS_PakIsPure(s->pack) ) {\n\t\t\t\t\tCom_Printf( \"    not on the pure list\\n\" );\n\t\t\t\t} else {\n\t\t\t\t\tCom_Printf( \"    on the pure list\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tCom_Printf (\"%s%c%s\\n\", s->dir->path, PATH_SEP, s->dir->gamedir );\n\t\t}\n\t}\n\n\tCom_Printf( \"\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o ) {\n\t\t\tCom_Printf( \"handle %i: %s\\n\", i, fsh[i].name );\n\t\t}\n\t}\n}\n\n/*\n============\nFS_TouchFile_f\n\nThe only purpose of this function is to allow game script files to copy\narbitrary files furing an \"fs_copyfiles 1\" run.\n============\n*/\nvoid FS_TouchFile_f( void ) {\n\tfileHandle_t\tf;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"Usage: touchFile <file>\\n\" );\n\t\treturn;\n\t}\n\n\tFS_FOpenFileRead( Cmd_Argv( 1 ), &f, qfalse );\n\tif ( f ) {\n\t\tFS_FCloseFile( f );\n\t}\n}\n\n/*\n============\nFS_Which_f\n============\n*/\nvoid FS_Which_f( void ) {\n\tsearchpath_t\t*search;\n\tchar\t\t*filename;\n\n\tfilename = Cmd_Argv(1);\n\n\tif ( !filename[0] ) {\n\t\tCom_Printf( \"Usage: which <file>\\n\" );\n\t\treturn;\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn;\n\t}\n\n\t// just wants to see if file is there\n\tfor ( search=fs_searchpaths; search; search=search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tlong hash = FS_HashFileName( filename, search->pack->hashSize );\n\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack->hashTable[hash]) {\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpack_t* pak = search->pack;\n\t\t\t\tfileInPack_t* pakFile = pak->hashTable[hash];\n\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\t\t\t\t\t\tCom_Printf( \"File \\\"%s\\\" found in \\\"%s\\\"\\n\", filename, pak->pakFilename );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while ( pakFile != NULL );\n\t\t\t}\n\t\t} else if (search->dir) {\n\t\t\tdirectory_t* dir = search->dir;\n\n\t\t\tchar* netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\tFILE* filep = fopen(netpath, \"rb\");\n\n\t\t\tif ( filep ) {\n\t\t\t\tfclose( filep );\n\n\t\t\t\tchar buf[MAX_OSPATH];\n\t\t\t\tCom_sprintf( buf, sizeof( buf ), \"%s%c%s\", dir->path, PATH_SEP, dir->gamedir );\n\t\t\t\tFS_ReplaceSeparators( buf );\n\t\t\t\tCom_Printf( \"File \\\"%s\\\" found at \\\"%s\\\"\\n\", filename, buf );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tCom_Printf( \"File not found: \\\"%s\\\"\\n\", filename );\n}\n\n//===========================================================================\n\nstatic int QDECL paksort( const void *a, const void *b ) {\n\tchar\t*aa, *bb;\n\n\taa = *(char **)a;\n\tbb = *(char **)b;\n\n\treturn FS_PathCmp( aa, bb );\n}\n\n/*\n================\nFS_AddGameDirectory\n\nSets fs_gamedir, adds the directory to the head of the path,\nthen loads the zip headers\n================\n*/\n#define\tMAX_PAKFILES\t1024\nstatic void FS_AddGameDirectory( const char *path, const char *dir ) {\n\tsearchpath_t\t*sp;\n\tint\t\t\t\ti;\n\tsearchpath_t\t*search;\n\tsearchpath_t\t*thedir;\n\tpack_t\t\t\t*pak;\n\tchar\t\t\tcurpath[MAX_OSPATH + 1], *pakfile;\n\tint\t\t\t\tnumfiles;\n\tchar\t\t\t**pakfiles;\n\tchar\t\t\t*sorted[MAX_PAKFILES];\n\n\t// this fixes the case where fs_basepath is the same as fs_cdpath\n\t// which happens on full installs\n\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\tif ( sp->dir && Sys_PathCmp(sp->dir->path, path) && !Q_stricmp(sp->dir->gamedir, dir)) {\n\t\t\treturn;\t\t\t// we've already got this one\n\t\t}\n\t}\n\n\tQ_strncpyz( fs_gamedir, dir, sizeof( fs_gamedir ) );\n\n\t// find all pak files in this directory\n\tQ_strncpyz(curpath, FS_BuildOSPath(path, dir, \"\"), sizeof(curpath));\n\tcurpath[strlen(curpath) - 1] = '\\0';\t// strip the trailing slash\n\n\t//\n\t// add the directory to the search path\n\t//\n\tsearch = (struct searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\tsearch->dir = (directory_t *)Z_Malloc( sizeof( *search->dir ), TAG_FILESYS, qtrue );\n\n\tQ_strncpyz( search->dir->path, path, sizeof( search->dir->path ) );\n\tQ_strncpyz( search->dir->fullpath, curpath, sizeof( search->dir->fullpath ) );\n\tQ_strncpyz( search->dir->gamedir, dir, sizeof( search->dir->gamedir ) );\n\tsearch->next = fs_searchpaths;\n\tfs_searchpaths = search;\n\n\tthedir = search;\n\n\tpakfiles = Sys_ListFiles( curpath, \".pk3\", NULL, &numfiles, qfalse );\n\n\t// sort them so that later alphabetic matches override\n\t// earlier ones.  This makes pak1.pk3 override pak0.pk3\n\tif ( numfiles > MAX_PAKFILES ) {\n\t\tnumfiles = MAX_PAKFILES;\n\t}\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tsorted[i] = pakfiles[i];\n\t}\n\n\tqsort( sorted, numfiles, sizeof(char*), paksort );\n\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tpakfile = FS_BuildOSPath( path, dir, sorted[i] );\n\t\tif ( ( pak = FS_LoadZipFile( pakfile, sorted[i] ) ) == 0 )\n\t\t\tcontinue;\n\t\tQ_strncpyz(pak->pakPathname, curpath, sizeof(pak->pakPathname));\n\t\t// store the game name for downloading\n\t\tQ_strncpyz(pak->pakGamename, dir, sizeof(pak->pakGamename));\n\n\t\tfs_packFiles += pak->numfiles;\n\n\t\tsearch = (searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\t\tsearch->pack = pak;\n\n\t\tif (fs_dirbeforepak && fs_dirbeforepak->integer && thedir)\n\t\t{\n\t\t\tsearchpath_t *oldnext = thedir->next;\n\t\t\tthedir->next = search;\n\n\t\t\twhile (oldnext)\n\t\t\t{\n\t\t\t\tsearch->next = oldnext;\n\t\t\t\tsearch = search->next;\n\t\t\t\toldnext = oldnext->next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsearch->next = fs_searchpaths;\n\t\t\tfs_searchpaths = search;\n\t\t}\n\t}\n\n\t// done\n\tSys_FreeFileList( pakfiles );\n}\n\n/*\n================\nFS_idPak\n================\n*/\nqboolean FS_idPak( char *pak, char *base ) {\n\tint i;\n\n\tfor (i = 0; i < NUM_ID_PAKS; i++) {\n\t\tif ( !FS_FilenameCompare(pak, va(\"%s/assets%d\", base, i)) ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < NUM_ID_PAKS) {\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n================\nFS_CheckDirTraversal\n\nCheck whether the string contains stuff like \"../\" to prevent directory traversal bugs\nand return qtrue if it does.\n================\n*/\n\nqboolean FS_CheckDirTraversal(const char *checkdir)\n{\n\tif(strstr(checkdir, \"../\") || strstr(checkdir, \"..\\\\\"))\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_ComparePaks\n\nif dlstring == qtrue\n\nReturns a list of pak files that we should download from the server. They all get stored\nin the current gamedir and an FS_Restart will be fired up after we download them all.\n\nThe string is the format:\n\n@remotename@localname [repeat]\n\nstatic int\t\tfs_numServerReferencedPaks;\nstatic int\t\tfs_serverReferencedPaks[MAX_SEARCH_PATHS];\nstatic char\t\t*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];\n\n----------------\ndlstring == qfalse\n\nwe are not interested in a download string format, we want something human-readable\n(this is used for diagnostics while connecting to a pure server)\n================\n*/\nqboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring ) {\n\tsearchpath_t\t*sp;\n\tqboolean havepak;\n\tchar *origpos = neededpaks;\n\tint i;\n\n\tif ( !fs_numServerReferencedPaks ) {\n\t\treturn qfalse; // Server didn't send any pack information along\n\t}\n\n\t*neededpaks = 0;\n\n\tfor ( i = 0 ; i < fs_numServerReferencedPaks ; i++ ) {\n\t\t// Ok, see if we have this pak file\n\t\thavepak = qfalse;\n\n\t\t// never autodownload any of the id paks\n\t\tif ( FS_idPak(fs_serverReferencedPakNames[i], \"base\") || FS_idPak(fs_serverReferencedPakNames[i], \"missionpack\") ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Make sure the server cannot make us write to non-quake3 directories.\n\t\tif(FS_CheckDirTraversal(fs_serverReferencedPakNames[i]))\n\t\t{\n\t\t\tCom_Printf(\"WARNING: Invalid download name %s\\n\", fs_serverReferencedPakNames[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\t\tif ( sp->pack && sp->pack->checksum == fs_serverReferencedPaks[i] ) {\n\t\t\t\thavepak = qtrue; // This is it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( !havepak && fs_serverReferencedPakNames[i] && *fs_serverReferencedPakNames[i] ) {\n\t\t\t// Don't got it\n\n\t\t\tif (dlstring)\n\t\t\t{\n\t\t\t\t// We need this to make sure we won't hit the end of the buffer or the server could\n\t\t\t\t// overwrite non-pk3 files on clients by writing so much crap into neededpaks that\n\t\t\t\t// Q_strcat cuts off the .pk3 extension.\n\n\t\t\t\torigpos += strlen(origpos);\n\n\t\t\t\t// Remote name\n\t\t\t\tQ_strcat( neededpaks, len, \"@\");\n\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\n\t\t\t\t// Local name\n\t\t\t\tQ_strcat( neededpaks, len, \"@\");\n\t\t\t\t// Do we have one with the same name?\n\t\t\t\tif ( FS_SV_FileExists( va( \"%s.pk3\", fs_serverReferencedPakNames[i] ) ) ) {\n\t\t\t\t\tchar st[MAX_ZPATH];\n\t\t\t\t\t// We already have one called this, we need to download it to another name\n\t\t\t\t\t// Make something up with the checksum in it\n\t\t\t\t\tCom_sprintf( st, sizeof( st ), \"%s.%08x.pk3\", fs_serverReferencedPakNames[i], fs_serverReferencedPaks[i] );\n\t\t\t\t\tQ_strcat( neededpaks, len, st );\n\t\t\t\t} else {\n\t\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\t\t\t\t}\n\n\t\t\t\t// Find out whether it might have overflowed the buffer and don't add this file to the\n\t\t\t\t// list if that is the case.\n\t\t\t\tif(strlen(origpos) + (origpos - neededpaks) >= (unsigned)(len - 1))\n\t\t\t\t{\n\t\t\t\t\t*origpos = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\t\t\t\t// Do we have one with the same name?\n\t\t\t\tif ( FS_SV_FileExists( va( \"%s.pk3\", fs_serverReferencedPakNames[i] ) ) )\n\t\t\t\t{\n\t\t\t\t\tQ_strcat( neededpaks, len, \" (local file exists with wrong checksum)\");\n\t\t\t\t}\n\t\t\t\tQ_strcat( neededpaks, len, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif ( *neededpaks ) {\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse; // We have them all\n}\n\n/*\n================\nFS_Shutdown\n\nFrees all resources and closes all files\n================\n*/\nvoid FS_Shutdown( qboolean closemfp ) {\n\tsearchpath_t\t*p, *next;\n\tint\ti;\n\n#if defined(_WIN32)\n\t// Delete temporary files\n\tfs_temporaryFileWriteIdx = 0;\n\tfor ( size_t i = 0; i < ARRAY_LEN(fs_temporaryFileNames); i++ )\n\t{\n\t\tif (fs_temporaryFileNames[i][0] != '\\0')\n\t\t{\n\t\t\tif ( !DeleteFile(fs_temporaryFileNames[i]) )\n\t\t\t{\n\t\t\t\tDWORD error = GetLastError();\n\t\t\t\tCom_DPrintf(\"FS_Shutdown: failed to delete '%s'. \"\n\t\t\t\t\t\t\t\"Win32 error code: 0x08x\",\n\t\t\t\t\t\t\tfs_temporaryFileNames[i],\n\t\t\t\t\t\t\terror);\n\t\t\t}\n\n\t\t\tfs_temporaryFileNames[i][0] = '\\0';\n\t\t}\n\t}\n#endif\n\n\tfor(i = 0; i < MAX_FILE_HANDLES; i++) {\n\t\tif (fsh[i].fileSize) {\n\t\t\tFS_FCloseFile(i);\n\t\t}\n\t}\n\n\t// free everything\n\tfor ( p = fs_searchpaths ; p ; p = next ) {\n\t\tnext = p->next;\n\n\t\tif ( p->pack ) {\n\t\t\tFS_FreePak( p->pack );\n\t\t}\n\t\tif ( p->dir ) {\n\t\t\tZ_Free( p->dir );\n\t\t}\n\t\tZ_Free( p );\n\t}\n\n\t// any FS_ calls will now be an error until reinitialized\n\tfs_searchpaths = NULL;\n\n\tCmd_RemoveCommand( \"path\" );\n\tCmd_RemoveCommand( \"dir\" );\n\tCmd_RemoveCommand( \"fdir\" );\n\tCmd_RemoveCommand( \"touchFile\" );\n\tCmd_RemoveCommand( \"which\" );\n\n#ifdef FS_MISSING\n\tif (closemfp) {\n\t\tfclose(missingFiles);\n\t}\n#endif\n}\n\n//rww - add search paths in for received svc_setgame\n//Ensiform - this is so wrong rww\nvoid FS_UpdateGamedir(void)\n{\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, BASEGAME ) )\n\t{\n\t\tif (fs_cdpath->string[0])\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0])\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string))\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n}\n\n/*\n================\nFS_ReorderPurePaks\nNOTE TTimo: the reordering that happens here is not reflected in the cvars (\\cvarlist *pak*)\n  this can lead to misleading situations, see https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n================\n*/\nstatic void FS_ReorderPurePaks()\n{\n\tsearchpath_t *s;\n\tint i;\n\tsearchpath_t **p_insert_index, // for linked list reordering\n\t\t**p_previous; // when doing the scan\n\n\t// only relevant when connected to pure server\n\tif ( !fs_numServerPaks )\n\t\treturn;\n\n\tfs_reordered = qfalse;\n\n\tp_insert_index = &fs_searchpaths; // we insert in order at the beginning of the list\n\tfor ( i = 0 ; i < fs_numServerPaks ; i++ ) {\n\t\tp_previous = p_insert_index; // track the pointer-to-current-item\n\t\tfor (s = *p_insert_index; s; s = s->next) {\n\t\t\t// the part of the list before p_insert_index has been sorted already\n\t\t\tif (s->pack && fs_serverPaks[i] == s->pack->checksum) {\n\t\t\t\tfs_reordered = qtrue;\n\t\t\t\t// move this element to the insert list\n\t\t\t\t*p_previous = s->next;\n\t\t\t\ts->next = *p_insert_index;\n\t\t\t\t*p_insert_index = s;\n\t\t\t\t// increment insert list\n\t\t\t\tp_insert_index = &s->next;\n\t\t\t\tbreak; // iterate to next server pack\n\t\t\t}\n\t\t\tp_previous = &s->next;\n\t\t}\n\t}\n}\n\n/**\n\t@brief Mount the asset archives (.pk3) and register commands.\n\n\tMounts in this order the archives from:\n\n\t1.  <fs_cdpath>/<gameName>/\n\t2.  <fs_basepath>/<gameName>/\n\t3.  <fs_apppath>/<gameName>/ (Mac Only)\n\t4.  <fs_homepath>/<gameName>/\n\t5.  <fs_cdpath>/<fs_basegame>/\n\t6.  <fs_basepath>/<fs_basegame>/\n\t7.  <fs_homepath>/<fs_basegame>/\n\t8.  <fs_cdpath>/<fs_game>/\n\t9.  <fs_basepath>/<fs_game>/\n\t10. <fs_homepath>/<fs_game>/\n\n\t@param gameName Name of the default folder (i.e. always BASEGAME = \"base\" in OpenJK)\n*/\nvoid FS_Startup( const char *gameName ) {\n\tconst char *homePath;\n\n\tCom_Printf( \"----- FS_Startup -----\\n\" );\n\n\tfs_packFiles = 0;\n\n\tfs_debug = Cvar_Get( \"fs_debug\", \"0\", 0 );\n\tfs_copyfiles = Cvar_Get( \"fs_copyfiles\", \"0\", CVAR_INIT );\n\tfs_cdpath = Cvar_Get (\"fs_cdpath\", \"\", CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location for development files\" );\n\tfs_basepath = Cvar_Get (\"fs_basepath\", Sys_DefaultInstallPath(), CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location for game files\" );\n\tfs_basegame = Cvar_Get (\"fs_basegame\", \"\", CVAR_INIT );\n\thomePath = Sys_DefaultHomePath();\n\tif (!homePath || !homePath[0]) {\n\t\thomePath = fs_basepath->string;\n\t}\n\tfs_homepath = Cvar_Get (\"fs_homepath\", homePath, CVAR_INIT|CVAR_PROTECTED, \"(Read/Write) Location for user generated files\" );\n\tfs_gamedirvar = Cvar_Get (\"fs_game\", \"\", CVAR_INIT|CVAR_SYSTEMINFO, \"Mod directory\" );\n\n\tfs_dirbeforepak = Cvar_Get(\"fs_dirbeforepak\", \"0\", CVAR_INIT|CVAR_PROTECTED, \"Prioritize directories before paks if not pure\" );\n\n\t// add search path elements in reverse priority order (lowest priority first)\n\tif (fs_cdpath->string[0]) {\n\t\tFS_AddGameDirectory( fs_cdpath->string, gameName );\n\t}\n\tif (fs_basepath->string[0]) {\n\t\tFS_AddGameDirectory( fs_basepath->string, gameName );\n\t}\n\n#ifdef MACOS_X\n\tfs_apppath = Cvar_Get (\"fs_apppath\", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location of OSX .app bundle\" );\n\t// Make MacOSX also include the base path included with the .app bundle\n\tif (fs_apppath->string[0]) {\n\t\tFS_AddGameDirectory( fs_apppath->string, gameName );\n\t}\n#endif\n\n\t// fs_homepath is somewhat particular to *nix systems, only add if relevant\n\t// NOTE: same filtering below for mods and basegame\n\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\tFS_CreatePath ( fs_homepath->string );\n\t\tFS_AddGameDirectory ( fs_homepath->string, gameName );\n\t}\n\n\t// check for additional base game so mods can be based upon other mods\n\tif ( fs_basegame->string[0] && Q_stricmp( fs_basegame->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_basegame->string);\n\t\t}\n\t}\n\n\t// check for additional game folder for mods\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n\n\t// add our commands\n\tCmd_AddCommand (\"path\", FS_Path_f, \"Lists search paths\" );\n\tCmd_AddCommand (\"dir\", FS_Dir_f, \"Lists a folder\" );\n\tCmd_AddCommand (\"fdir\", FS_NewDir_f, \"Lists a folder with filters\" );\n\tCmd_AddCommand (\"touchFile\", FS_TouchFile_f, \"Touches a file\" );\n\tCmd_AddCommand (\"which\", FS_Which_f, \"Determines which search path a file was loaded from\" );\n\n\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=506\n\t// reorder the pure pk3 files according to server order\n\tFS_ReorderPurePaks();\n\n\t// print the current search paths\n\tFS_Path_f();\n\n\tfs_gamedirvar->modified = qfalse; // We just loaded, it's not modified\n\n\tCom_Printf( \"----------------------\\n\" );\n\n#ifdef FS_MISSING\n\tif (missingFiles == NULL) {\n\t\tmissingFiles = fopen( \"\\\\missing.txt\", \"ab\" );\n\t}\n#endif\n\tCom_Printf( \"%d files in pk3 files\\n\", fs_packFiles );\n}\n\n/*\n=====================\nFS_LoadedPakChecksums\n\nReturns a space separated string containing the checksums of all loaded pk3 files.\nServers with sv_pure set will get this string and pass it to clients.\n=====================\n*/\nconst char *FS_LoadedPakChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->checksum ) );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_LoadedPakNames\n\nReturns a space separated string containing the names of all loaded pk3 files.\nServers with sv_pure set will get this string and pass it to clients.\n=====================\n*/\nconst char *FS_LoadedPakNames( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*info) {\n\t\t\tQ_strcat(info, sizeof( info ), \" \" );\n\t\t}\n\t\tQ_strcat( info, sizeof( info ), search->pack->pakBasename );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_LoadedPakPureChecksums\n\nReturns a space separated string containing the pure checksums of all loaded pk3 files.\nServers with sv_pure use these checksums to compare with the checksums the clients send\nback to the server.\n=====================\n*/\nconst char *FS_LoadedPakPureChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->pure_checksum ) );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakChecksums\n\nReturns a space separated string containing the checksums of all referenced pk3 files.\nThe server will send this to the clients so they can check which files should be auto-downloaded.\n=====================\n*/\nconst char *FS_ReferencedPakChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t *search;\n\n\tinfo[0] = 0;\n\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( search->pack ) {\n\t\t\tif (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, BASEGAME, strlen(BASEGAME))) {\n\t\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->checksum ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakPureChecksums\n\nReturns a space separated string containing the pure checksums of all referenced pk3 files.\nServers with sv_pure set will get this string back from clients for pure validation\n\nThe string has a specific order, \"cgame ui @ ref1 ref2 ref3 ...\"\n=====================\n*/\nconst char *FS_ReferencedPakPureChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\tint nFlags, numPaks, checksum;\n\n\tinfo[0] = 0;\n\n\tchecksum = fs_checksumFeed;\n\tnumPaks = 0;\n\tfor (nFlags = FS_CGAME_REF; nFlags; nFlags = nFlags >> 1) {\n\t\tif (nFlags & FS_GENERAL_REF) {\n\t\t\t// add a delimter between must haves and general refs\n\t\t\t//Q_strcat(info, sizeof(info), \"@ \");\n\t\t\tinfo[strlen(info)+1] = '\\0';\n\t\t\tinfo[strlen(info)+2] = '\\0';\n\t\t\tinfo[strlen(info)] = '@';\n\t\t\tinfo[strlen(info)] = ' ';\n\t\t}\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t// is the element a pak file and has it been referenced based on flag?\n\t\t\tif ( search->pack && (search->pack->referenced & nFlags)) {\n\t\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->pure_checksum ) );\n\t\t\t\tif (nFlags & (FS_CGAME_REF | FS_UI_REF)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchecksum ^= search->pack->pure_checksum;\n\t\t\t\tnumPaks++;\n\t\t\t}\n\t\t}\n\t\tif (fs_fakeChkSum != 0) {\n\t\t\t// only added if a non-pure file is referenced\n\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", fs_fakeChkSum ) );\n\t\t}\n\t}\n\t// last checksum is the encoded number of referenced pk3s\n\tchecksum ^= numPaks;\n\tQ_strcat( info, sizeof( info ), va(\"%i \", checksum ) );\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakNames\n\nReturns a space separated string containing the names of all referenced pk3 files.\nThe server will send this to the clients so they can check which files should be auto-downloaded.\n=====================\n*/\nconst char *FS_ReferencedPakNames( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\t// we want to return ALL pk3's from the fs_game path\n\t// and referenced one's from base\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( search->pack ) {\n\t\t\tif (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, BASEGAME, strlen(BASEGAME))) {\n\t\t\t\tif (*info) {\n\t\t\t\t\tQ_strcat(info, sizeof( info ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( info, sizeof( info ), search->pack->pakGamename );\n\t\t\t\tQ_strcat( info, sizeof( info ), \"/\" );\n\t\t\t\tQ_strcat( info, sizeof( info ), search->pack->pakBasename );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ClearPakReferences\n=====================\n*/\nvoid FS_ClearPakReferences( int flags ) {\n\tsearchpath_t *search;\n\n\tif ( !flags ) {\n\t\tflags = -1;\n\t}\n\tfor ( search = fs_searchpaths; search; search = search->next ) {\n\t\t// is the element a pak file and has it been referenced?\n\t\tif ( search->pack ) {\n\t\t\tsearch->pack->referenced &= ~flags;\n\t\t}\n\t}\n}\n\n\n/*\n=====================\nFS_PureServerSetLoadedPaks\n\nIf the string is empty, all data sources will be allowed.\nIf not empty, only pk3 files that match one of the space\nseparated checksums will be checked for files, with the\nexception of .cfg and .dat files.\n=====================\n*/\nvoid FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames ) {\n\tint\t\ti, c, d;\n\n\tCmd_TokenizeString( pakSums );\n\n\tc = Cmd_Argc();\n\tif ( c > MAX_SEARCH_PATHS ) {\n\t\tc = MAX_SEARCH_PATHS;\n\t}\n\n\tfs_numServerPaks = c;\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tfs_serverPaks[i] = atoi( Cmd_Argv( i ) );\n\t}\n\n\tif (fs_numServerPaks) {\n\t\tCom_DPrintf( \"Connected to a pure server.\\n\" );\n\t}\n\telse\n\t{\n\t\tif (fs_reordered)\n\t\t{\n\t\t\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n\t\t\t// force a restart to make sure the search order will be correct\n\t\t\tCom_DPrintf( \"FS search reorder is required\\n\" );\n\t\t\tFS_Restart(fs_checksumFeed);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tif (fs_serverPakNames[i]) {\n\t\t\tZ_Free(fs_serverPakNames[i]);\n\t\t}\n\t\tfs_serverPakNames[i] = NULL;\n\t}\n\tif ( pakNames && *pakNames ) {\n\t\tCmd_TokenizeString( pakNames );\n\n\t\td = Cmd_Argc();\n\t\tif ( d > MAX_SEARCH_PATHS ) {\n\t\t\td = MAX_SEARCH_PATHS;\n\t\t}\n\n\t\tfor ( i = 0 ; i < d ; i++ ) {\n\t\t\tfs_serverPakNames[i] = CopyString( Cmd_Argv( i ) );\n\t\t}\n\t}\n}\n\n/*\n=====================\nFS_PureServerSetReferencedPaks\n\nThe checksums and names of the pk3 files referenced at the server\nare sent to the client and stored here. The client will use these\nchecksums to see if any pk3 files need to be auto-downloaded.\n=====================\n*/\nvoid FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames ) {\n\tint\t\ti, c, d = 0;\n\n\tCmd_TokenizeString( pakSums );\n\n\tc = Cmd_Argc();\n\tif ( c > MAX_SEARCH_PATHS ) {\n\t\tc = MAX_SEARCH_PATHS;\n\t}\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tfs_serverReferencedPaks[i] = atoi( Cmd_Argv( i ) );\n\t}\n\n\tfor (i = 0 ; i < (int)ARRAY_LEN(fs_serverReferencedPakNames); i++)\n\t{\n\t\tif(fs_serverReferencedPakNames[i])\n\t\t\tZ_Free(fs_serverReferencedPakNames[i]);\n\n\t\tfs_serverReferencedPakNames[i] = NULL;\n\t}\n\n\tif ( pakNames && *pakNames ) {\n\t\tCmd_TokenizeString( pakNames );\n\n\t\td = Cmd_Argc();\n\t\tif ( d > c ) {\n\t\t\td = c;\n\t\t}\n\n\t\tfor ( i = 0 ; i < d ; i++ ) {\n\t\t\tfs_serverReferencedPakNames[i] = CopyString( Cmd_Argv( i ) );\n\t\t}\n\t}\n\n\t// ensure that there are as many checksums as there are pak names.\n\tif(d < c)\n\t\tc = d;\n\n\tfs_numServerReferencedPaks = c;\n}\n\n/*\n================\nFS_InitFilesystem\n\nCalled only at inital startup, not when the filesystem\nis resetting due to a game change\n================\n*/\nvoid FS_InitFilesystem( void ) {\n\t// allow command line parms to override our defaults\n\t// we have to specially handle this, because normal command\n\t// line variable sets don't happen until after the filesystem\n\t// has already been initialized\n\tCom_StartupVariable( \"fs_cdpath\" );\n\tCom_StartupVariable( \"fs_basepath\" );\n\tCom_StartupVariable( \"fs_homepath\" );\n\tCom_StartupVariable( \"fs_game\" );\n\tCom_StartupVariable( \"fs_copyfiles\" );\n\tCom_StartupVariable( \"fs_dirbeforepak\" );\n#ifdef MACOS_X\n\tCom_StartupVariable( \"fs_apppath\" );\n#endif\n\n\tif(!FS_FilenameCompare(Cvar_VariableString(\"fs_game\"), BASEGAME))\n\t\tCvar_Set(\"fs_game\", \"\");\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"mpdefault.cfg\", NULL ) <= 0 ) {\n\t\tCom_Error( ERR_FATAL, \"Couldn't load mpdefault.cfg\" );\n\t\t// bk001208 - SafeMode see below, FIXME?\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n#if defined(_WIN32)\n\tCom_Memset(fs_temporaryFileNames, 0, sizeof(fs_temporaryFileNames));\n#endif\n\n  // bk001208 - SafeMode see below, FIXME?\n}\n\n/*\n================\nFS_Restart\n================\n*/\nvoid FS_Restart( int checksumFeed ) {\n\n\t// free anything we currently have loaded\n\tFS_Shutdown(qfalse);\n\n\t// set the checksum feed\n\tfs_checksumFeed = checksumFeed;\n\n\t// clear pak references\n\tFS_ClearPakReferences(0);\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"mpdefault.cfg\", NULL ) <= 0 ) {\n\t\t// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3\n\t\t// (for instance a TA demo server)\n\t\tif (lastValidBase[0]) {\n\t\t\tFS_PureServerSetLoadedPaks(\"\", \"\");\n\t\t\tCvar_Set(\"fs_basepath\", lastValidBase);\n\t\t\tCvar_Set(\"fs_game\", lastValidGame);\n\t\t\tlastValidBase[0] = '\\0';\n\t\t\tlastValidGame[0] = '\\0';\n\t\t\tFS_Restart(checksumFeed);\n\t\t\tCom_Error( ERR_DROP, \"Invalid game folder\\n\" );\n\t\t\treturn;\n\t\t}\n\t\tCom_Error( ERR_FATAL, \"Couldn't load mpdefault.cfg\" );\n\t}\n\n\tif ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {\n\t\t// skip the jampconfig.cfg if \"safe\" is on the command line\n\t\tif ( !Com_SafeMode() ) {\n\t\t\tCbuf_AddText (\"exec \" Q3CONFIG_CFG \"\\n\");\n\t\t}\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n}\n\n/*\n=================\nFS_ConditionalRestart\nrestart if necessary\n=================\n*/\nqboolean FS_ConditionalRestart( int checksumFeed ) {\n\tif( fs_gamedirvar->modified || checksumFeed != fs_checksumFeed ) {\n\t\tFS_Restart( checksumFeed );\n\t\treturn qtrue;\n\t}\n#if 0\n\tif(fs_gamedirvar->modified)\n\t{\n\t\tif(FS_FilenameCompare(lastValidGame, fs_gamedirvar->string) &&\n\t\t\t\t(*lastValidGame || FS_FilenameCompare(fs_gamedirvar->string, BASEGAME)) &&\n\t\t\t\t(*fs_gamedirvar->string || FS_FilenameCompare(lastValidGame, BASEGAME)))\n\t\t{\n\t\t\tFS_Restart(checksumFeed);\n\t\t\t//Cvar_Restart(qtrue);\n\t\t\treturn qtrue;\n\t\t}\n\t\telse\n\t\t\tfs_gamedirvar->modified = qfalse;\n\t}\n\n\tif(checksumFeed != fs_checksumFeed)\n\t\tFS_Restart(checksumFeed);\n\telse if(fs_numServerPaks && !fs_reordered)\n\t\tFS_ReorderPurePaks();\n#endif\n\treturn qfalse;\n}\n\n/*\n========================================================================================\n\nHandle based file calls for virtual machines\n\n========================================================================================\n*/\n\nint\t\tFS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {\n\tint\t\tr;\n\tqboolean\tsync;\n\n\tsync = qfalse;\n\n\tswitch( mode ) {\n\tcase FS_READ:\n\t\tr = FS_FOpenFileRead( qpath, f, qtrue );\n\t\tbreak;\n\tcase FS_WRITE:\n\t\t*f = FS_FOpenFileWrite( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tcase FS_APPEND_SYNC:\n\t\tsync = qtrue;\n\tcase FS_APPEND:\n\t\t*f = FS_FOpenFileAppend( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"FSH_FOpenFile: bad mode\" );\n\t\treturn -1;\n\t}\n\n\tif (!f) {\n\t\treturn r;\n\t}\n\n\tif ( *f ) {\n\t\tfsh[*f].fileSize = r;\n\t}\n\tfsh[*f].handleSync = sync;\n\n\treturn r;\n}\n\nint\t\tFS_FTell( fileHandle_t f ) {\n\tint pos;\n\tif (fsh[f].zipFile == qtrue) {\n\t\tpos = unztell(fsh[f].handleFiles.file.z);\n\t} else {\n\t\tpos = ftell(fsh[f].handleFiles.file.o);\n\t}\n\treturn pos;\n}\n\nvoid\tFS_Flush( fileHandle_t f ) {\n\tfflush(fsh[f].handleFiles.file.o);\n}\n\nvoid FS_FilenameCompletion( const char *dir, const char *ext, qboolean stripExt, callbackFunc_t callback, qboolean allowNonPureFilesOnDisk ) {\n\tint nfiles;\n\tchar **filenames, filename[MAX_STRING_CHARS];\n\n\tfilenames = FS_ListFilteredFiles( dir, ext, NULL, &nfiles );\n\n\tFS_SortFileList( filenames, nfiles );\n\n\t// pass all the files to callback (FindMatches)\n\tfor ( int i=0; i<nfiles; i++ ) {\n\t\tFS_ConvertPath( filenames[i] );\n\t\tQ_strncpyz( filename, filenames[i], MAX_STRING_CHARS );\n\n\t\tif ( stripExt )\n\t\t\tCOM_StripExtension( filename, filename, sizeof( filename ) );\n\n\t\tcallback( filename );\n\t}\n\tFS_FreeFileList( filenames );\n}\n\nconst char *FS_GetCurrentGameDir(bool emptybase)\n{\n\tif(fs_gamedirvar->string[0])\n\t\treturn fs_gamedirvar->string;\n\n\treturn emptybase ? \"\" : BASEGAME;\n}\n\n#ifdef MACOS_X\nbool FS_LoadMachOBundle( const char *name )\n{\n\tint     len;\n\tvoid    *data;\n\tfileHandle_t    f;\n\tchar    *fn;\n\tunzFile dll;\n\tbyte* buf;\n\tchar    dllName[MAX_QPATH];\n\tchar    *tempName;\n\tunz_file_info   zfi;\n\n\t//read zipped bundle from pk3\n\tlen = FS_ReadFile(name, &data);\n\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\t//write temporary file of zipped bundle to e.g. uixxxxxx\n\t//unique filename to avoid any clashes\n\tCom_sprintf( dllName, sizeof(dllName), \"%sXXXXXX\", name );\n\n\ttempName = mktemp( dllName );\n\n\tf = FS_FOpenFileWrite( dllName );\n\n\tif ( !f )\n\t{\n\t\tFS_FreeFile(data);\n\t\treturn false;\n\t}\n\n\tif (FS_Write( data, len, f ) < len)\n\t{\n\t\tFS_FreeFile(data);\n\t\treturn false;\n\t}\n\n\tFS_FCloseFile( f );\n\tFS_FreeFile(data);\n\n\t//unzOpen zipped bundle, find the dylib, and try to write it\n\tfn = FS_BuildOSPath( fs_homepath->string, fs_gamedir, dllName );\n\n\tdll = unzOpen( fn );\n\n\tCom_sprintf (dllName, sizeof(dllName), \"%s.bundle/Contents/MacOS/%s\", name, name);\n\n\tif (unzLocateFile(dll, dllName, 0) != UNZ_OK)\n\t{\n\t\tunzClose(dll);\n\t\tremove( fn );\n\t\treturn false;\n\t}\n\n\tunzOpenCurrentFile( dll );\n\n\tCom_sprintf( dllName, sizeof(dllName), \"%s_pk3\" DLL_EXT, name );\n\n\tf = FS_FOpenFileWrite( dllName, qfalse );\n\n\tif ( !f )\n\t{\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\tremove( fn );\n\t\treturn false;\n\t}\n\n\tunzGetCurrentFileInfo( dll, &zfi, NULL, 0, NULL, 0, NULL, 0 );\n\n\tlen = zfi.uncompressed_size;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\n\tif (unzReadCurrentFile( dll, buf, len ) < len)\n\t{\n\t\tFS_FCloseFile( f );\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\treturn false;\n\t}\n\n\tif (FS_Write(buf, len, f) < len)\n\t{\n\t\tFS_FCloseFile( f );\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\treturn false;\n\t}\n\n\tFS_FCloseFile( f );\n\tunzCloseCurrentFile( dll );\n\tunzClose( dll );\n\tZ_Free( buf );\n\n\t//remove temporary zipped bundle\n\tremove( fn );\n\n\treturn true;\n}\n#endif\n\nqboolean FS_WriteToTemporaryFile( const void *data, size_t dataLength, char **tempFilePath )\n{\n#if defined(_WIN32)\n\tDWORD error;\n\tTCHAR tempPath[MAX_PATH];\n\tDWORD tempPathResult = GetTempPath(MAX_PATH, tempPath);\n\tif ( tempPathResult )\n\t{\n\t\tTCHAR tempFileName[MAX_PATH];\n\t\tUINT tempFileNameResult = GetTempFileName(tempPath, \"OJK\", 0, tempFileName);\n\t\tif ( tempFileNameResult )\n\t\t{\n\t\t\tHANDLE file = CreateFile(\n\t\t\t\ttempFileName, GENERIC_WRITE, 0, NULL,\n\t\t\t\tCREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);\n\t\t\tif ( file != INVALID_HANDLE_VALUE )\n\t\t\t{\n\t\t\t\tDWORD bytesWritten = 0;\n\t\t\t\tif (WriteFile(file, data, dataLength, &bytesWritten, NULL))\n\t\t\t\t{\n\t\t\t\t\tint deletesRemaining = ARRAY_LEN(fs_temporaryFileNames);\n\n\t\t\t\t\tCloseHandle(file);\n\n\t\t\t\t\twhile ( deletesRemaining > 0 &&\n\t\t\t\t\t\t\tfs_temporaryFileNames[fs_temporaryFileWriteIdx][0] != '\\0' )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete old temporary file as we need to\n\t\t\t\t\t\tif ( DeleteFile(fs_temporaryFileNames[fs_temporaryFileWriteIdx]) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terror = GetLastError();\n\t\t\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed for '%s'. \"\n\t\t\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\t\t\tfs_temporaryFileNames[fs_temporaryFileWriteIdx],\n\t\t\t\t\t\t\t\t\terror);\n\n\t\t\t\t\t\t// Failed to delete, possibly because DLL was still in use. This can\n\t\t\t\t\t\t// happen when running a listen server and you continually restart\n\t\t\t\t\t\t// the map. The game DLL is reloaded, but cgame and ui DLLs are not.\n\t\t\t\t\t\tfs_temporaryFileWriteIdx =\n\t\t\t\t\t\t\t(fs_temporaryFileWriteIdx + 1) % ARRAY_LEN(fs_temporaryFileNames);\n\t\t\t\t\t\tdeletesRemaining--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If this happened, then all slots are used and we some how have 8 DLLs\n\t\t\t\t\t// loaded at once?!\n\t\t\t\t\tassert(deletesRemaining > 0);\n\n\t\t\t\t\tQ_strncpyz(fs_temporaryFileNames[fs_temporaryFileWriteIdx],\n\t\t\t\t\t\t\t\ttempFileName, sizeof(fs_temporaryFileNames[0]));\n\t\t\t\t\tfs_temporaryFileWriteIdx =\n\t\t\t\t\t\t(fs_temporaryFileWriteIdx + 1) % ARRAY_LEN(fs_temporaryFileNames);\n\n\t\t\t\t\tif ( tempFilePath )\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t fileNameLen = strlen(tempFileName);\n\t\t\t\t\t\t*tempFilePath = (char *)Z_Malloc(fileNameLen + 1, TAG_FILESYS);\n\t\t\t\t\t\tQ_strncpyz(*tempFilePath, tempFileName, fileNameLen + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn qtrue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror = GetLastError();\n\t\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to write '%s'. \"\n\t\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\t\ttempFileName, error);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\terror = GetLastError();\n\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to create '%s'. \"\n\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\ttempFileName, error);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror = GetLastError();\n\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to generate temporary file name. \"\n\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\", error);\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = GetLastError();\n\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to get temporary file folder. \"\n\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\", error);\n\t}\n#endif\n\n\treturn qfalse;\n}\n", "/*\n===========================================================================\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n#include <csignal>\n#include <cstdlib>\n#include <cstdarg>\n#include <cstdio>\n#include <sys/stat.h>\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n#include \"qcommon/qcommon.h\"\n#include \"sys_local.h\"\n#include \"sys_loadlib.h\"\n#include \"sys_public.h\"\n#include \"con_local.h\"\n\nstatic char binaryPath[ MAX_OSPATH ] = { 0 };\nstatic char installPath[ MAX_OSPATH ] = { 0 };\n\ncvar_t *com_minimized;\ncvar_t *com_unfocused;\ncvar_t *com_maxfps;\ncvar_t *com_maxfpsMinimized;\ncvar_t *com_maxfpsUnfocused;\n\n/*\n=================\nSys_SetBinaryPath\n=================\n*/\nvoid Sys_SetBinaryPath(const char *path)\n{\n\tQ_strncpyz(binaryPath, path, sizeof(binaryPath));\n}\n\n/*\n=================\nSys_BinaryPath\n=================\n*/\nchar *Sys_BinaryPath(void)\n{\n\treturn binaryPath;\n}\n\n/*\n=================\nSys_SetDefaultInstallPath\n=================\n*/\nvoid Sys_SetDefaultInstallPath(const char *path)\n{\n\tQ_strncpyz(installPath, path, sizeof(installPath));\n}\n\n/*\n=================\nSys_DefaultInstallPath\n=================\n*/\nchar *Sys_DefaultInstallPath(void)\n{\n\tif (*installPath)\n\t\treturn installPath;\n\telse\n\t\treturn Sys_Cwd();\n}\n\n/*\n=================\nSys_DefaultAppPath\n=================\n*/\nchar *Sys_DefaultAppPath(void)\n{\n\treturn Sys_BinaryPath();\n}\n\n/*\n==================\nSys_GetClipboardData\n==================\n*/\nchar *Sys_GetClipboardData( void ) {\n#ifdef DEDICATED\n\treturn NULL;\n#else\n\tif ( !SDL_HasClipboardText() )\n\t\treturn NULL;\n\n\tchar *cbText = SDL_GetClipboardText();\n\tsize_t len = strlen( cbText ) + 1;\n\n\tchar *buf = (char *)Z_Malloc( len, TAG_CLIPBOARD );\n\tQ_strncpyz( buf, cbText, len );\n\n\tSDL_free( cbText );\n\treturn buf;\n#endif\n}\n\n/*\n=================\nSys_ConsoleInput\n\nHandle new console input\n=================\n*/\nchar *Sys_ConsoleInput(void)\n{\n\treturn CON_Input( );\n}\n\nvoid Sys_Print( const char *msg ) {\n\t// TTimo - prefix for text that shows up in console but not in notify\n\t// backported from RTCW\n\tif ( !Q_strncmp( msg, \"[skipnotify]\", 12 ) ) {\n\t\tmsg += 12;\n\t}\n\tif ( msg[0] == '*' ) {\n\t\tmsg += 1;\n\t}\n\tConsoleLogAppend( msg );\n\tCON_Print( msg );\n}\n\n/*\n================\nSys_Init\n\nCalled after the common systems (cvars, files, etc)\nare initialized\n================\n*/\nvoid Sys_Init( void ) {\n\tCmd_AddCommand (\"in_restart\", IN_Restart);\n\tCvar_Get( \"arch\", OS_STRING \" \" ARCH_STRING, CVAR_ROM );\n\tCvar_Get( \"username\", Sys_GetCurrentUser(), CVAR_ROM );\n\n\tcom_unfocused = Cvar_Get( \"com_unfocused\", \"0\", CVAR_ROM );\n\tcom_minimized = Cvar_Get( \"com_minimized\", \"0\", CVAR_ROM );\n#ifdef _JK2EXE\n\tcom_maxfps = Cvar_Get (\"com_maxfps\", \"125\", CVAR_ARCHIVE );\n#else\n\tcom_maxfps = Cvar_Get( \"com_maxfps\", \"125\", CVAR_ARCHIVE, \"Maximum frames per second\" );\n#endif\n\tcom_maxfpsUnfocused = Cvar_Get( \"com_maxfpsUnfocused\", \"0\", CVAR_ARCHIVE );\n\tcom_maxfpsMinimized = Cvar_Get( \"com_maxfpsMinimized\", \"50\", CVAR_ARCHIVE );\n}\n\nstatic void NORETURN Sys_Exit( int ex ) {\n\tIN_Shutdown();\n#ifndef DEDICATED\n\tSDL_Quit();\n#endif\n\n\tNET_Shutdown();\n\n\tSys_PlatformExit();\n\n\tCom_ShutdownHunkMemory();\n\tCom_ShutdownZoneMemory();\n\n\tCON_Shutdown();\n\n    exit( ex );\n}\n\n#if !defined(DEDICATED)\nstatic void Sys_ErrorDialog( const char *error )\n{\n\ttime_t rawtime;\n\tchar timeStr[32] = {}; // should really only reach ~19 chars\n\tchar crashLogPath[MAX_OSPATH];\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\tCom_sprintf( crashLogPath, sizeof( crashLogPath ),\n\t\t\t\t\t\"%s%ccrashlog-%s.txt\",\n\t\t\t\t\tSys_DefaultHomePath(), PATH_SEP, timeStr );\n\n\tSys_Mkdir( Sys_DefaultHomePath() );\n\n\tFILE *fp = fopen( crashLogPath, \"w\" );\n\tif ( fp )\n\t{\n\t\tConsoleLogWriteOut( fp );\n\t\tfclose( fp );\n\n\t\tconst char *errorMessage = va( \"%s\\n\\nThe crash log was written to %s\", error, crashLogPath );\n\t\tif ( SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, \"Error\", errorMessage, NULL ) < 0 )\n\t\t{\n\t\t\tfprintf( stderr, \"%s\", errorMessage );\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Getting pretty desperate now\n\t\tConsoleLogWriteOut( stderr );\n\t\tfflush( stderr );\n\n\t\tconst char *errorMessage = va( \"%s\\nCould not write the crash log file, but we printed it to stderr.\\n\"\n\t\t\t\t\t\t\t\t\t\t\"Try running the game using a command line interface.\", error );\n\t\tif ( SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, \"Error\", errorMessage, NULL ) < 0 )\n\t\t{\n\t\t\t// We really have hit rock bottom here :(\n\t\t\tfprintf( stderr, \"%s\", errorMessage );\n\t\t}\n\t}\n}\n#endif\n\nvoid NORETURN QDECL Sys_Error( const char *error, ... )\n{\n\tva_list argptr;\n\tchar    string[1024];\n\n\tva_start (argptr,error);\n\tQ_vsnprintf (string, sizeof(string), error, argptr);\n\tva_end (argptr);\n\n\tSys_Print( string );\n\n\t// Only print Sys_ErrorDialog for client binary. The dedicated\n\t// server binary is meant to be a command line program so you would\n\t// expect to see the error printed.\n#if !defined(DEDICATED)\n\tSys_ErrorDialog( string );\n#endif\n\n\tSys_Exit( 3 );\n}\n\nvoid NORETURN Sys_Quit (void) {\n    Sys_Exit(0);\n}\n\n/*\n============\nSys_FileTime\n\nreturns -1 if not present\n============\n*/\ntime_t Sys_FileTime( const char *path )\n{\n\tstruct stat buf;\n\n\tif ( stat( path, &buf ) == -1 )\n\t\treturn -1;\n\n\treturn buf.st_mtime;\n}\n\n/*\n=================\nSys_UnloadDll\n=================\n*/\nvoid Sys_UnloadDll( void *dllHandle )\n{\n\tif( !dllHandle )\n\t{\n\t\tCom_Printf(\"Sys_UnloadDll(NULL)\\n\");\n\t\treturn;\n\t}\n\n\tSys_UnloadLibrary(dllHandle);\n}\n\n/*\n=================\nSys_LoadDll\n\nFirst try to load library name from system library path,\nfrom executable path, then fs_basepath.\n=================\n*/\nvoid *Sys_LoadDll( const char *name, qboolean useSystemLib )\n{\n\tvoid *dllhandle = NULL;\n\n\tif ( useSystemLib )\n\t{\n\t\tCom_Printf( \"Trying to load \\\"%s\\\"...\\n\", name );\n\n\t\tdllhandle = Sys_LoadLibrary( name );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t}\n\n\tconst char *binarypath = Sys_BinaryPath();\n\tconst char *basepath = Cvar_VariableString( \"fs_basepath\" );\n\n\tif ( !*binarypath )\n\t\tbinarypath = \".\";\n\n\tconst char *searchPaths[] = {\n\t\tbinarypath,\n\t\tbasepath,\n\t};\n\tconst size_t numPaths = ARRAY_LEN( searchPaths );\n\n\tfor ( size_t i = 0; i < numPaths; i++ )\n\t{\n\t\tconst char *libDir = searchPaths[i];\n\t\tif ( !libDir[0] )\n\t\t\tcontinue;\n\n\t\tCom_Printf( \"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, libDir );\n\t\tchar *fn = va( \"%s%c%s\", libDir, PATH_SEP, name );\n\t\tdllhandle = Sys_LoadLibrary( fn );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, fn, Sys_LibraryError() );\n\t}\n\treturn NULL;\n}\n\n#if defined(MACOS_X) && !defined(_JK2EXE)\nvoid *Sys_LoadMachOBundle( const char *name )\n{\n\tif ( !FS_LoadMachOBundle(name) )\n\t\treturn NULL;\n\n\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n\tchar dllName[MAX_QPATH];\n\n\tCom_sprintf( dllName, sizeof(dllName), \"%s_pk3\" DLL_EXT, name );\n\n\t//load the unzipped library\n\tchar *fn = FS_BuildOSPath( homepath, gamedir, dllName );\n\n\tvoid    *libHandle = Sys_LoadLibrary( fn );\n\n\tif ( libHandle != NULL ) {\n\t\tCom_Printf( \"Loaded pk3 bundle %s.\\n\", name );\n\t}\n\n\treturn libHandle;\n}\n#endif\n\nenum SearchPathFlag\n{\n\tSEARCH_PATH_MOD\t\t= 1 << 0,\n\tSEARCH_PATH_BASE\t= 1 << 1,\n\tSEARCH_PATH_OPENJK\t= 1 << 2,\n\tSEARCH_PATH_ROOT\t= 1 << 3\n};\n\nstatic void *Sys_LoadDllFromPaths( const char *filename, const char *gamedir, const char **searchPaths,\n\t\t\t\t\t\t\t\t\tsize_t numPaths, uint32_t searchFlags, const char *callerName )\n{\n\tchar *fn;\n\tvoid *libHandle;\n\n\tif ( searchFlags & SEARCH_PATH_MOD )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, gamedir, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_BASE )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, BASEGAME, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_OPENJK )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, OPENJKGAME, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_ROOT )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = va( \"%s%c%s\", libDir, PATH_SEP, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void FreeUnpackDLLResult(UnpackDLLResult *result)\n{\n\tif ( result->tempDLLPath )\n\t\tZ_Free((void *)result->tempDLLPath);\n}\n\nvoid *Sys_LoadLegacyGameDll( const char *name, VMMainProc **vmMain, SystemCallProc *systemcalls )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(_DEBUG)\n\tlibHandle = Sys_LoadLibrary( name );\n\tif ( !libHandle )\n#endif\n\t{\n\t\tUnpackDLLResult unpackResult = Sys_UnpackDLL(filename);\n\t\tif ( !unpackResult.succeeded )\n\t\t{\n\t\t\tif ( Sys_DLLNeedsUnpacking() )\n\t\t\t{\n\t\t\t\tFreeUnpackDLLResult(&unpackResult);\n\t\t\t\tCom_DPrintf( \"Sys_LoadLegacyGameDll: Failed to unpack %s from PK3.\\n\", filename );\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibHandle = Sys_LoadLibrary(unpackResult.tempDLLPath);\n\t\t}\n\n\t\tFreeUnpackDLLResult(&unpackResult);\n\n\t\tif ( !libHandle )\n\t\t{\n#if defined(MACOS_X) && !defined(_JK2EXE)\n\t\t\t//First, look for the old-style mac .bundle that's inside a pk3\n\t\t\t//It's actually zipped, and the zipfile has the same name as 'name'\n\t\t\tlibHandle = Sys_LoadMachOBundle( name );\n#endif\n\n\t\t\tif (!libHandle) {\n\t\t\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\t\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\t\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\t\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n\t\t#ifdef MACOS_X\n\t\t\t\tchar *apppath = Cvar_VariableString( \"fs_apppath\" );\n\t\t#endif\n\n\t\t\t\tconst char *searchPaths[] = {\n\t\t\t\t\thomepath,\n\t\t#ifdef MACOS_X\n\t\t\t\t\tapppath,\n\t\t#endif\n\t\t\t\t\tbasepath,\n\t\t\t\t\tcdpath,\n\t\t\t\t};\n\t\t\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\t\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths, SEARCH_PATH_BASE | SEARCH_PATH_MOD, __FUNCTION__ );\n\t\t\t\tif ( !libHandle )\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\ttypedef void QDECL DllEntryProc( SystemCallProc *syscallptr );\n\n\tDllEntryProc *dllEntry = (DllEntryProc *)Sys_LoadFunction( libHandle, \"dllEntry\" );\n\t*vmMain = (VMMainProc *)Sys_LoadFunction( libHandle, \"vmMain\" );\n\n\tif ( !*vmMain || !dllEntry ) {\n\t\tCom_DPrintf ( \"Sys_LoadLegacyGameDll(%s) failed to find vmMain function:\\n...%s!\\n\", name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\tCom_DPrintf ( \"Sys_LoadLegacyGameDll(%s) found vmMain function at 0x%\" PRIxPTR \"\\n\", name, *vmMain );\n\tdllEntry( systemcalls );\n\n\treturn libHandle;\n}\n\nvoid *Sys_LoadSPGameDll( const char *name, GetGameAPIProc **GetGameAPI )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tassert( GetGameAPI );\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(MACOS_X) && !defined(_JK2EXE)\n    //First, look for the old-style mac .bundle that's inside a pk3\n    //It's actually zipped, and the zipfile has the same name as 'name'\n    libHandle = Sys_LoadMachOBundle( filename );\n#endif\n\n\tif (!libHandle) {\n\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n#ifdef MACOS_X\n        char *apppath = Cvar_VariableString( \"fs_apppath\" );\n#endif\n\n\t\tconst char *searchPaths[] = {\n\t\t\thomepath,\n#ifdef MACOS_X\n\t\t\tapppath,\n#endif\n\t\t\tbasepath,\n\t\t\tcdpath,\n\t\t};\n\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths,\n\t\t\t\t\t\t\t\t\t\t\tSEARCH_PATH_BASE | SEARCH_PATH_MOD | SEARCH_PATH_OPENJK | SEARCH_PATH_ROOT,\n\t\t\t\t\t\t\t\t\t\t\t__FUNCTION__ );\n\t\tif ( !libHandle )\n\t\t\treturn NULL;\n\t}\n\n\t*GetGameAPI = (GetGameAPIProc *)Sys_LoadFunction( libHandle, \"GetGameAPI\" );\n\tif ( !*GetGameAPI ) {\n\t\tCom_DPrintf ( \"%s(%s) failed to find GetGameAPI function:\\n...%s!\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\treturn libHandle;\n}\n\nvoid *Sys_LoadGameDll( const char *name, GetModuleAPIProc **moduleAPI )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(_DEBUG)\n\tlibHandle = Sys_LoadLibrary( filename );\n\tif ( !libHandle )\n#endif\n\t{\n\t\tUnpackDLLResult unpackResult = Sys_UnpackDLL(filename);\n\t\tif ( !unpackResult.succeeded )\n\t\t{\n\t\t\tif ( Sys_DLLNeedsUnpacking() )\n\t\t\t{\n\t\t\t\tFreeUnpackDLLResult(&unpackResult);\n\t\t\t\tCom_DPrintf( \"Sys_LoadLegacyGameDll: Failed to unpack %s from PK3.\\n\", filename );\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibHandle = Sys_LoadLibrary(unpackResult.tempDLLPath);\n\t\t}\n\n\t\tFreeUnpackDLLResult(&unpackResult);\n\n\t\tif ( !libHandle )\n\t\t{\n#if defined(MACOS_X) && !defined(_JK2EXE)\n\t\t\t//First, look for the old-style mac .bundle that's inside a pk3\n\t\t\t//It's actually zipped, and the zipfile has the same name as 'name'\n\t\t\tlibHandle = Sys_LoadMachOBundle( name );\n#endif\n\n\t\t\tif (!libHandle) {\n\t\t\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\t\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\t\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\t\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n#ifdef MACOS_X\n\t\t\t\tchar *apppath = Cvar_VariableString( \"fs_apppath\" );\n#endif\n\n\t\t\t\tconst char *searchPaths[] = {\n\t\t\t\t\thomepath,\n#ifdef MACOS_X\n\t\t\t\t\tapppath,\n#endif\n\t\t\t\t\tbasepath,\n\t\t\t\t\tcdpath,\n\t\t\t\t};\n\t\t\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\t\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths, SEARCH_PATH_BASE | SEARCH_PATH_MOD, __FUNCTION__ );\n\t\t\t\tif ( !libHandle )\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t*moduleAPI = (GetModuleAPIProc *)Sys_LoadFunction( libHandle, \"GetModuleAPI\" );\n\tif ( !*moduleAPI ) {\n\t\tCom_DPrintf ( \"Sys_LoadGameDll(%s) failed to find GetModuleAPI function:\\n...%s!\\n\", name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\treturn libHandle;\n}\n\n/*\n=================\nSys_SigHandler\n=================\n*/\nvoid Sys_SigHandler( int signal )\n{\n\tstatic qboolean signalcaught = qfalse;\n\n\tif( signalcaught )\n\t{\n\t\tfprintf( stderr, \"DOUBLE SIGNAL FAULT: Received signal %d, exiting...\\n\",\n\t\t\tsignal );\n\t}\n\telse\n\t{\n\t\tsignalcaught = qtrue;\n\t\t//VM_Forced_Unload_Start();\n#ifndef DEDICATED\n\t\tCL_Shutdown();\n\t\t//CL_Shutdown(va(\"Received signal %d\", signal), qtrue, qtrue);\n#endif\n\t\tSV_Shutdown(va(\"Received signal %d\", signal) );\n\t\t//VM_Forced_Unload_Done();\n\t}\n\n\tif( signal == SIGTERM || signal == SIGINT )\n\t\tSys_Exit( 1 );\n\telse\n\t\tSys_Exit( 2 );\n}\n\n#ifdef MACOS_X\n/*\n =================\n Sys_StripAppBundle\n\n Discovers if passed dir is suffixed with the directory structure of a Mac OS X\n .app bundle. If it is, the .app directory structure is stripped off the end and\n the result is returned. If not, dir is returned untouched.\n =================\n */\nchar *Sys_StripAppBundle( char *dir )\n{\n\tstatic char cwd[MAX_OSPATH];\n\n\tQ_strncpyz(cwd, dir, sizeof(cwd));\n\tif(strcmp(Sys_Basename(cwd), \"MacOS\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\tif(strcmp(Sys_Basename(cwd), \"Contents\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\tif(!strstr(Sys_Basename(cwd), \".app\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\treturn cwd;\n}\n#endif\n\n#ifndef DEFAULT_BASEDIR\n#\tifdef MACOS_X\n#\t\tdefine DEFAULT_BASEDIR Sys_StripAppBundle(Sys_BinaryPath())\n#\telse\n#\t\tdefine DEFAULT_BASEDIR Sys_BinaryPath()\n#\tendif\n#endif\n\nint main ( int argc, char* argv[] )\n{\n\tint\t\ti;\n\tchar\tcommandLine[ MAX_STRING_CHARS ] = { 0 };\n\n\tSys_PlatformInit();\n\tCON_Init();\n\n\t// get the initial time base\n\tSys_Milliseconds();\n\n#ifdef MACOS_X\n\t// This is passed if we are launched by double-clicking\n\tif ( argc >= 2 && Q_strncmp ( argv[1], \"-psn\", 4 ) == 0 )\n\t\targc = 1;\n#endif\n\n\tSys_SetBinaryPath( Sys_Dirname( argv[ 0 ] ) );\n\tSys_SetDefaultInstallPath( DEFAULT_BASEDIR );\n\n\t// Concatenate the command line for passing to Com_Init\n\tfor( i = 1; i < argc; i++ )\n\t{\n\t\tconst bool containsSpaces = (strchr(argv[i], ' ') != NULL);\n\t\tif (containsSpaces)\n\t\t\tQ_strcat( commandLine, sizeof( commandLine ), \"\\\"\" );\n\n\t\tQ_strcat( commandLine, sizeof( commandLine ), argv[ i ] );\n\n\t\tif (containsSpaces)\n\t\t\tQ_strcat( commandLine, sizeof( commandLine ), \"\\\"\" );\n\n\t\tQ_strcat( commandLine, sizeof( commandLine ), \" \" );\n\t}\n\n\tCom_Init (commandLine);\n\n\tNET_Init();\n\n\t// main game loop\n\twhile (1)\n\t{\n\t\tif ( com_busyWait->integer )\n\t\t{\n\t\t\tbool shouldSleep = false;\n\n#if !defined(_JK2EXE)\n\t\t\tif ( com_dedicated->integer )\n\t\t\t{\n\t\t\t\tshouldSleep = true;\n\t\t\t}\n#endif\n\n\t\t\tif ( com_minimized->integer )\n\t\t\t{\n\t\t\t\tshouldSleep = true;\n\t\t\t}\n\n\t\t\tif ( shouldSleep )\n\t\t\t{\n\t\t\t\tSys_Sleep( 5 );\n\t\t\t}\n\t\t}\n\n\t\t// run the game\n\t\tCom_Frame();\n\t}\n\n\t// never gets here\n\treturn 0;\n}\n"], "fixing_code": ["/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n// cl_main.c  -- client main loop\n\n#include \"../server/exe_headers.h\"\n\n#include \"client.h\"\n#include \"client_ui.h\"\n#include <limits.h>\n#include \"../ghoul2/G2.h\"\n#include \"qcommon/stringed_ingame.h\"\n#include \"sys/sys_loadlib.h\"\n#include \"qcommon/ojk_saved_game.h\"\n\n#define\tRETRANSMIT_TIMEOUT\t3000\t// time between connection packet retransmits\n\ncvar_t\t*cl_renderer;\n\ncvar_t\t*cl_nodelta;\ncvar_t\t*cl_debugMove;\n\ncvar_t\t*cl_noprint;\n\ncvar_t\t*cl_timeout;\ncvar_t\t*cl_packetdup;\ncvar_t\t*cl_timeNudge;\ncvar_t\t*cl_showTimeDelta;\ncvar_t\t*cl_newClock=0;\n\ncvar_t\t*cl_shownet;\ncvar_t\t*cl_avidemo;\n\ncvar_t\t*cl_pano;\ncvar_t\t*cl_panoNumShots;\ncvar_t\t*cl_skippingcin;\ncvar_t\t*cl_endcredits;\n\ncvar_t\t*cl_freelook;\ncvar_t\t*cl_sensitivity;\n\ncvar_t\t*cl_mouseAccel;\ncvar_t\t*cl_showMouseRate;\ncvar_t\t*cl_framerate;\n\ncvar_t\t*m_pitch;\ncvar_t\t*m_yaw;\ncvar_t\t*m_forward;\ncvar_t\t*m_side;\ncvar_t\t*m_filter;\n\ncvar_t\t*cl_activeAction;\n\ncvar_t\t*cl_allowAltEnter;\n\ncvar_t\t*cl_inGameVideo;\n\ncvar_t\t*cl_consoleKeys;\ncvar_t\t*cl_consoleUseScanCode;\n\nclientActive_t\t\tcl;\nclientConnection_t\tclc;\nclientStatic_t\t\tcls;\n\n// Structure containing functions exported from refresh DLL\nrefexport_t\tre;\nstatic void *rendererLib = NULL;\n\n//RAZFIXME: BAD BAD, maybe? had to move it out of ghoul2_shared.h -> CGhoul2Info_v at the least..\nIGhoul2InfoArray &_TheGhoul2InfoArray( void ) {\n\treturn re.TheGhoul2InfoArray();\n}\n\nstatic void CL_ShutdownRef( qboolean restarting );\nvoid CL_InitRef( void );\nvoid CL_CheckForResend( void );\n\n/*\n=======================================================================\n\nCLIENT RELIABLE COMMAND COMMUNICATION\n\n=======================================================================\n*/\n\n/*\n======================\nCL_AddReliableCommand\n\nThe given command will be transmitted to the server, and is gauranteed to\nnot have future usercmd_t executed before it is executed\n======================\n*/\nvoid CL_AddReliableCommand( const char *cmd ) {\n\tint\t\tindex;\n\n\t// if we would be losing an old command that hasn't been acknowledged,\n\t// we must drop the connection\n\tif ( clc.reliableSequence - clc.reliableAcknowledge > MAX_RELIABLE_COMMANDS ) {\n\t\tCom_Error( ERR_DROP, \"Client command overflow\" );\n\t}\n\tclc.reliableSequence++;\n\tindex = clc.reliableSequence & ( MAX_RELIABLE_COMMANDS - 1 );\n\tif ( clc.reliableCommands[ index ] ) {\n\t\tZ_Free( clc.reliableCommands[ index ] );\n\t}\n\tclc.reliableCommands[ index ] = CopyString( cmd );\n}\n\n//======================================================================\n\n/*\n=================\nCL_FlushMemory\n\nCalled by CL_MapLoading, CL_Connect_f, and CL_ParseGamestate the only\nways a client gets into a game\nAlso called by Com_Error\n=================\n*/\nvoid CL_FlushMemory( void ) {\n\n\t// clear sounds (moved higher up within this func to avoid the odd sound stutter)\n\tS_DisableSounds();\n\n\t// unload the old VM\n\tCL_ShutdownCGame();\n\n\tCL_ShutdownUI();\n\n\tif ( re.Shutdown ) {\n\t\tre.Shutdown( qfalse, qfalse );\t\t// don't destroy window or context\n\t}\n\n\t//rwwFIXMEFIXME: The game server appears to continue running, so clearing common bsp data causes crashing and other bad things\n\t/*\n\tCM_ClearMap();\n\t*/\n\n\tcls.soundRegistered = qfalse;\n\tcls.rendererStarted = qfalse;\n}\n\n/*\n=====================\nCL_MapLoading\n\nA local server is starting to load a map, so update the\nscreen to let the user know about it, then dump all client\nmemory on the hunk from cgame, ui, and renderer\n=====================\n*/\nvoid CL_MapLoading( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tCon_Close();\n\tKey_SetCatcher( 0 );\n\n\t// if we are already connected to the local host, stay connected\n\tif ( cls.state >= CA_CONNECTED && !Q_stricmp( cls.servername, \"localhost\" ) )  {\n\t\tcls.state = CA_CONNECTED;\t\t// so the connect screen is drawn\n\t\tmemset( cls.updateInfoString, 0, sizeof( cls.updateInfoString ) );\n//\t\tmemset( clc.serverMessage, 0, sizeof( clc.serverMessage ) );\n\t\tmemset( &cl.gameState, 0, sizeof( cl.gameState ) );\n\t\tclc.lastPacketSentTime = -9999;\n\t\tSCR_UpdateScreen();\n\t} else {\n\t\t// clear nextmap so the cinematic shutdown doesn't execute it\n\t\tCvar_Set( \"nextmap\", \"\" );\n\t\tCL_Disconnect();\n\t\tQ_strncpyz( cls.servername, \"localhost\", sizeof(cls.servername) );\n\t\tcls.state = CA_CHALLENGING;\t\t// so the connect screen is drawn\n\t\tKey_SetCatcher( 0 );\n\t\tSCR_UpdateScreen();\n\t\tclc.connectTime = -RETRANSMIT_TIMEOUT;\n\t\tNET_StringToAdr( cls.servername, &clc.serverAddress);\n\t\t// we don't need a challenge on the localhost\n\n\t\tCL_CheckForResend();\n\t}\n\n\tCL_FlushMemory();\n}\n\n/*\n=====================\nCL_ClearState\n\nCalled before parsing a gamestate\n=====================\n*/\nvoid CL_ClearState (void) {\n\tCL_ShutdownCGame();\n\n\tS_StopAllSounds();\n\n\tmemset( &cl, 0, sizeof( cl ) );\n}\n\n/*\n=====================\nCL_FreeReliableCommands\n\nWipes all reliableCommands strings from clc\n=====================\n*/\nvoid CL_FreeReliableCommands( void )\n{\n\t// wipe the client connection\n\tfor ( int i = 0 ; i < MAX_RELIABLE_COMMANDS ; i++ ) {\n\t\tif ( clc.reliableCommands[i] ) {\n\t\t\tZ_Free( clc.reliableCommands[i] );\n\t\t \tclc.reliableCommands[i] = NULL;\n\t\t}\n\t}\n}\n\n\n/*\n=====================\nCL_Disconnect\n\nCalled when a connection, or cinematic is being terminated.\nGoes from a connected state to either a menu state or a console state\nSends a disconnect message to the server\nThis is also called on Com_Error and Com_Quit, so it shouldn't cause any errors\n=====================\n*/\nvoid CL_Disconnect( void ) {\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif (cls.uiStarted)\n\t\tUI_SetActiveMenu( NULL,NULL );\n\n\tSCR_StopCinematic ();\n\tS_ClearSoundBuffer();\n\n\t// send a disconnect message to the server\n\t// send it a few times in case one is dropped\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\tCL_AddReliableCommand( \"disconnect\" );\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t}\n\n\tCL_ClearState ();\n\n\tCL_FreeReliableCommands();\n\n\textern void CL_FreeServerCommands(void);\n\tCL_FreeServerCommands();\n\n\tmemset( &clc, 0, sizeof( clc ) );\n\n\tcls.state = CA_DISCONNECTED;\n\n\t// allow cheats locally\n\tCvar_Set( \"timescale\", \"1\" );//jic we were skipping\n\tCvar_Set( \"skippingCinematic\", \"0\" );//jic we were skipping\n}\n\n\n/*\n===================\nCL_ForwardCommandToServer\n\nadds the current command line as a clientCommand\nthings like godmode, noclip, etc, are commands directed to the server,\nso when they are typed in at the console, they will need to be forwarded.\n===================\n*/\nvoid CL_ForwardCommandToServer( void ) {\n\tconst char\t*cmd;\n\tchar\tstring[MAX_STRING_CHARS];\n\n\tcmd = Cmd_Argv(0);\n\n\t// ignore key up commands\n\tif ( cmd[0] == '-' ) {\n\t\treturn;\n\t}\n\n\tif ( cls.state != CA_ACTIVE || cmd[0] == '+' ) {\n\t\tCom_Printf (\"Unknown command \\\"%s\\\"\\n\", cmd);\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCom_sprintf( string, sizeof(string), \"%s %s\", cmd, Cmd_Args() );\n\t} else {\n\t\tQ_strncpyz( string, cmd, sizeof(string) );\n\t}\n\n\tCL_AddReliableCommand( string );\n}\n\n\n/*\n======================================================================\n\nCONSOLE COMMANDS\n\n======================================================================\n*/\n\n/*\n==================\nCL_ForwardToServer_f\n==================\n*/\nvoid CL_ForwardToServer_f( void ) {\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\t// don't forward the first argument\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( Cmd_Args() );\n\t}\n}\n\n/*\n==================\nCL_Disconnect_f\n==================\n*/\nvoid CL_Disconnect_f( void ) {\n\tSCR_StopCinematic();\n\n\t//FIXME:\n\t// TA codebase added additional CA_CINEMATIC check below, presumably so they could play cinematics\n\t//\tin the menus when disconnected, although having the SCR_StopCinematic() call above is weird.\n\t// Either there's a bug, or the new version of that function conditionally-doesn't stop cinematics...\n\t//\n\tif ( cls.state != CA_DISCONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tCom_Error (ERR_DISCONNECT, \"Disconnected from server\");\n\t}\n}\n\n\n/*\n=================\nCL_Vid_Restart_f\n\nRestart the video subsystem\n=================\n*/\nvoid CL_Vid_Restart_f( void ) {\n\tS_StopAllSounds();\t\t// don't let them loop during the restart\n\tS_BeginRegistration();\t// all sound handles are now invalid\n\tCL_ShutdownRef(qtrue);\n\tCL_ShutdownUI();\n\tCL_ShutdownCGame();\n\n\t//rww - sof2mp does this here, but it seems to cause problems in this codebase.\n//\tCM_ClearMap();\n\n\tCL_InitRef();\n\n\tcls.rendererStarted = qfalse;\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n/*\n=================\nCL_Snd_Restart_f\n\nRestart the sound subsystem\nThe cgame and game must also be forced to restart because\nhandles will be invalid\n=================\n*/\nvoid CL_Snd_Restart_f( void ) {\n\tS_Shutdown();\n\n\tS_Init();\n\n//\tCL_Vid_Restart_f();\n\n\textern qboolean\ts_soundMuted;\n\ts_soundMuted = qfalse;\t\t// we can play again\n\n\tS_RestartMusic();\n\n\textern void S_ReloadAllUsedSounds(void);\n\tS_ReloadAllUsedSounds();\n\n\textern void AS_ParseSets(void);\n\tAS_ParseSets();\n}\n/*\n==================\nCL_Configstrings_f\n==================\n*/\nvoid CL_Configstrings_f( void ) {\n\tint\t\ti;\n\tint\t\tofs;\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf( \"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tofs = cl.gameState.stringOffsets[ i ];\n\t\tif ( !ofs ) {\n\t\t\tcontinue;\n\t\t}\n\t\tCom_Printf( \"%4i: %s\\n\", i, cl.gameState.stringData + ofs );\n\t}\n}\n\n/*\n==============\nCL_Clientinfo_f\n==============\n*/\nvoid CL_Clientinfo_f( void ) {\n\tCom_Printf( \"--------- Client Information ---------\\n\" );\n\tCom_Printf( \"state: %i\\n\", cls.state );\n\tCom_Printf( \"Server: %s\\n\", cls.servername );\n\tCom_Printf (\"User info settings:\\n\");\n\tInfo_Print( Cvar_InfoString( CVAR_USERINFO ) );\n\tCom_Printf( \"--------------------------------------\\n\" );\n}\n\n\n//====================================================================\n\nvoid UI_UpdateConnectionString( const char *string );\n\n/*\n=================\nCL_CheckForResend\n\nResend a connect message if the last one has timed out\n=================\n*/\nvoid CL_CheckForResend( void ) {\n\tint\t\tport;\n\tchar\tinfo[MAX_INFO_STRING];\n\n//\tif ( cls.state == CA_CINEMATIC )\n\tif ( cls.state == CA_CINEMATIC || CL_IsRunningInGameCinematic())\n\t{\n\t\treturn;\n\t}\n\n\t// resend if we haven't gotten a reply yet\n\tif ( cls.state < CA_CONNECTING || cls.state > CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\n\tif ( cls.realtime - clc.connectTime < RETRANSMIT_TIMEOUT ) {\n\t\treturn;\n\t}\n\n\tclc.connectTime = cls.realtime;\t// for retransmit requests\n\tclc.connectPacketCount++;\n\n\t// requesting a challenge\n\tswitch ( cls.state ) {\n\tcase CA_CONNECTING:\n\t\tUI_UpdateConnectionString( va(\"(%i)\", clc.connectPacketCount ) );\n\n\t\tNET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, \"getchallenge\");\n\t\tbreak;\n\n\tcase CA_CHALLENGING:\n\t// sending back the challenge\n\t\tport = Cvar_VariableIntegerValue(\"net_qport\");\n\n\t\tUI_UpdateConnectionString( va(\"(%i)\", clc.connectPacketCount ) );\n\n\t\tQ_strncpyz( info, Cvar_InfoString( CVAR_USERINFO ), sizeof( info ) );\n\t\tInfo_SetValueForKey( info, \"protocol\", va(\"%i\", PROTOCOL_VERSION ) );\n\t\tInfo_SetValueForKey( info, \"qport\", va(\"%i\", port ) );\n\t\tInfo_SetValueForKey( info, \"challenge\", va(\"%i\", clc.challenge ) );\n\t\tNET_OutOfBandPrint( NS_CLIENT, clc.serverAddress, \"connect \\\"%s\\\"\", info );\n\t\t// the most current userinfo has been sent, so watch for any\n\t\t// newer changes to userinfo variables\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tbreak;\n\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"CL_CheckForResend: bad cls.state\" );\n\t}\n}\n\n\n/*\n===================\nCL_DisconnectPacket\n\nSometimes the server can drop the client and the netchan based\ndisconnect can be lost.  If the client continues to send packets\nto the server, the server will send out of band disconnect packets\nto the client so it doesn't have to wait for the full timeout period.\n===================\n*/\nvoid CL_DisconnectPacket( netadr_t from ) {\n\tif ( cls.state != CA_ACTIVE ) {\n\t\treturn;\n\t}\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\treturn;\n\t}\n\n\t// if we have received packets within three seconds, ignore it\n\t// (it might be a malicious spoof)\n\tif ( cls.realtime - clc.lastPacketTime < 3000 ) {\n\t\treturn;\n\t}\n\n\t// drop the connection (FIXME: connection dropped dialog)\n\tCom_Printf( \"Server disconnected for unknown reason\\n\" );\n\tCL_Disconnect();\n}\n\n\n/*\n=================\nCL_ConnectionlessPacket\n\nResponses to broadcasts, etc\n=================\n*/\nvoid CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tconst char\t*c;\n\n\tMSG_BeginReading( msg );\n\tMSG_ReadLong( msg );\t// skip the -1\n\n\ts = MSG_ReadStringLine( msg );\n\n\tCmd_TokenizeString( s );\n\n\tc = Cmd_Argv(0);\n\n\tCom_DPrintf (\"CL packet %s: %s\\n\", NET_AdrToString(from), c);\n\n\t// challenge from the server we are connecting to\n\tif ( !strcmp(c, \"challengeResponse\") ) {\n\t\tif ( cls.state != CA_CONNECTING ) {\n\t\t\tCom_Printf( \"Unwanted challenge response received.  Ignored.\\n\" );\n\t\t} else {\n\t\t\t// start sending challenge repsonse instead of challenge request packets\n\t\t\tclc.challenge = atoi(Cmd_Argv(1));\n\t\t\tcls.state = CA_CHALLENGING;\n\t\t\tclc.connectPacketCount = 0;\n\t\t\tclc.connectTime = -99999;\n\n\t\t\t// take this address as the new server address.  This allows\n\t\t\t// a server proxy to hand off connections to multiple servers\n\t\t\tclc.serverAddress = from;\n\t\t}\n\t\treturn;\n\t}\n\n\t// server connection\n\tif ( !strcmp(c, \"connectResponse\") ) {\n\t\tif ( cls.state >= CA_CONNECTED ) {\n\t\t\tCom_Printf (\"Dup connect received.  Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( cls.state != CA_CHALLENGING ) {\n\t\t\tCom_Printf (\"connectResponse packet while not connecting.  Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( !NET_CompareBaseAdr( from, clc.serverAddress ) ) {\n\t\t\tCom_Printf( \"connectResponse from a different address.  Ignored.\\n\" );\n\t\t\tCom_Printf( \"%s should have been %s\\n\", NET_AdrToString( from ),\n\t\t\t\tNET_AdrToString( clc.serverAddress ) );\n\t\t\treturn;\n\t\t}\n\t\tNetchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableIntegerValue( \"net_qport\" ) );\n\t\tcls.state = CA_CONNECTED;\n\t\tclc.lastPacketSentTime = -9999;\t\t// send first packet immediately\n\t\treturn;\n\t}\n\n\t// a disconnect message from the server, which will happen if the server\n\t// dropped the connection but it is still getting packets from us\n\tif (!strcmp(c, \"disconnect\")) {\n\t\tCL_DisconnectPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !strcmp(c, \"echo\") ) {\n\t\tNET_OutOfBandPrint( NS_CLIENT, from, \"%s\", Cmd_Argv(1) );\n\t\treturn;\n\t}\n\n\t// print request from server\n\tif ( !strcmp(c, \"print\") ) {\n\t\ts = MSG_ReadString( msg );\n\t\tUI_UpdateConnectionMessageString( s );\n\t\tCom_Printf( \"%s\", s );\n\t\treturn;\n\t}\n\n\n\tCom_DPrintf (\"Unknown connectionless packet command.\\n\");\n}\n\n\n/*\n=================\nCL_PacketEvent\n\nA packet has arrived from the main event loop\n=================\n*/\nvoid CL_PacketEvent( netadr_t from, msg_t *msg ) {\n\tclc.lastPacketTime = cls.realtime;\n\n\tif ( msg->cursize >= 4 && *(int *)msg->data == -1 ) {\n\t\tCL_ConnectionlessPacket( from, msg );\n\t\treturn;\n\t}\n\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\t\t// can't be a valid sequenced packet\n\t}\n\n\tif ( msg->cursize < 8 ) {\n\t\tCom_Printf (\"%s: Runt packet\\n\",NET_AdrToString( from ));\n\t\treturn;\n\t}\n\n\t//\n\t// packet from server\n\t//\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\tCom_DPrintf (\"%s:sequenced packet without connection\\n\"\n\t\t\t,NET_AdrToString( from ) );\n\t\t// FIXME: send a client disconnect?\n\t\treturn;\n\t}\n\n\tif (!Netchan_Process( &clc.netchan, msg) ) {\n\t\treturn;\t\t// out of order, duplicated, etc\n\t}\n\n\tclc.lastPacketTime = cls.realtime;\n\tCL_ParseServerMessage( msg );\n}\n\n/*\n==================\nCL_CheckTimeout\n\n==================\n*/\nvoid CL_CheckTimeout( void ) {\n\t//\n\t// check timeout\n\t//\n\tif ( ( !CL_CheckPaused() || !sv_paused->integer )\n//\t\t&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC\n\t\t&& cls.state >= CA_CONNECTED && (cls.state != CA_CINEMATIC && !CL_IsRunningInGameCinematic())\n\t\t&& cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {\n\t\tif (++cl.timeoutcount > 5) {\t// timeoutcount saves debugger\n\t\t\tCom_Printf (\"\\nServer connection timed out.\\n\");\n\t\t\tCL_Disconnect ();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tcl.timeoutcount = 0;\n\t}\n}\n\n/*\n==================\nCL_CheckPaused\nCheck whether client has been paused.\n==================\n*/\nqboolean CL_CheckPaused(void)\n{\n\t// if cl_paused->modified is set, the cvar has only been changed in\n\t// this frame. Keep paused in this frame to ensure the server doesn't\n\t// lag behind.\n\tif(cl_paused->integer || cl_paused->modified)\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n//============================================================================\n\n/*\n==================\nCL_CheckUserinfo\n\n==================\n*/\nvoid CL_CheckUserinfo( void ) {\n\tif ( cls.state < CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\t// don't overflow the reliable command buffer when paused\n\tif ( CL_CheckPaused() ) {\n\t\treturn;\n\t}\n\t// send a reliable userinfo update if needed\n\tif ( cvar_modifiedFlags & CVAR_USERINFO ) {\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tCL_AddReliableCommand( va(\"userinfo \\\"%s\\\"\", Cvar_InfoString( CVAR_USERINFO ) ) );\n\t}\n\n}\n\n\n/*\n==================\nCL_Frame\n\n==================\n*/\nextern cvar_t\t*cl_newClock;\nstatic unsigned int frameCount;\nfloat avgFrametime=0.0;\nvoid CL_Frame ( int msec,float fractionMsec ) {\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// load the ref / cgame if needed\n\tCL_StartHunkUsers();\n\n\tif ( cls.state == CA_DISCONNECTED && !( Key_GetCatcher( ) & KEYCATCH_UI )\n\t\t&& !com_sv_running->integer ) {\n\t\t// if disconnected, bring up the menu\n\t\tif (!CL_CheckPendingCinematic())\t// this avoid having the menu flash for one frame before pending cinematics\n\t\t{\n\t\t\tUI_SetActiveMenu( \"mainMenu\",NULL );\n\t\t}\n\t}\n\n\n\t// if recording an avi, lock to a fixed fps\n\tif ( cl_avidemo->integer ) {\n\t\t// save the current screen\n\t\tif ( cls.state == CA_ACTIVE ) {\n\t\t\tif (cl_avidemo->integer > 0) {\n\t\t\t\tCbuf_ExecuteText( EXEC_NOW, \"screenshot silent\\n\" );\n\t\t\t} else {\n\t\t\t\tCbuf_ExecuteText( EXEC_NOW, \"screenshot_tga silent\\n\" );\n\t\t\t}\n\t\t}\n\t\t// fixed time for next frame\n\t\tif (cl_avidemo->integer > 0) {\n\t\t\tmsec = 1000 / cl_avidemo->integer;\n\t\t} else {\n\t\t\tmsec = 1000 / -cl_avidemo->integer;\n\t\t}\n\t}\n\n\t// save the msec before checking pause\n\tcls.realFrametime = msec;\n\n\t// decide the simulation time\n\tcls.frametime = msec;\n\tif(cl_framerate->integer)\n\t{\n\t\tavgFrametime+=msec;\n\t\tchar mess[256];\n\t\tif(!(frameCount&0x1f))\n\t\t{\n\t\t\tsprintf(mess,\"Frame rate=%f\\n\\n\",1000.0f*(1.0/(avgFrametime/32.0f)));\n\t//\t\tOutputDebugString(mess);\n\t\t\tCom_Printf(mess);\n\t\t\tavgFrametime=0.0f;\n\t\t}\n\t\tframeCount++;\n\t}\n\tcls.frametimeFraction=fractionMsec;\n\tcls.realtime += msec;\n\tcls.realtimeFraction+=fractionMsec;\n\tif (cls.realtimeFraction>=1.0f)\n\t{\n\t\tif (cl_newClock&&cl_newClock->integer)\n\t\t{\n\t\t\tcls.realtime++;\n\t\t}\n\t\tcls.realtimeFraction-=1.0f;\n\t}\n\tif ( cl_timegraph->integer ) {\n\t\tSCR_DebugGraph ( cls.realFrametime * 0.25, 0 );\n\t}\n\n\t// see if we need to update any userinfo\n\tCL_CheckUserinfo();\n\n\t// if we haven't gotten a packet in a long time,\n\t// drop the connection\n\tCL_CheckTimeout();\n\n\t// send intentions now\n\tCL_SendCmd();\n\n\t// resend a connection request if necessary\n\tCL_CheckForResend();\n\n\t// decide on the serverTime to render\n\tCL_SetCGameTime();\n\n\tif (cl_pano->integer && cls.state == CA_ACTIVE) {\t//grab some panoramic shots\n\t\tint i = 1;\n\t\tint pref = cl_pano->integer;\n\t\tint oldnoprint = cl_noprint->integer;\n\t\tCon_Close();\n\t\tcl_noprint->integer = 1;\t//hide the screen shot msgs\n\t\tfor (; i <= cl_panoNumShots->integer; i++) {\n\t\t\tCvar_SetValue( \"pano\", i );\n\t\t\tSCR_UpdateScreen();// update the screen\n\t\t\tCbuf_ExecuteText( EXEC_NOW, va(\"screenshot %dpano%02d\\n\", pref, i) );\t//grab this screen\n\t\t}\n\t\tCvar_SetValue( \"pano\", 0 );\t//done\n\t\tcl_noprint->integer = oldnoprint;\n\t}\n\n\tif (cl_skippingcin->integer && !cl_endcredits->integer && !com_developer->integer ) {\n\t\tif (cl_skippingcin->modified){\n\t\t\tS_StopSounds();\t\t//kill em all but music\n\t\t\tcl_skippingcin->modified=qfalse;\n\t\t\tCom_Printf (S_COLOR_YELLOW \"%s\", SE_GetString(\"CON_TEXT_SKIPPING\"));\n\t\t\tSCR_UpdateScreen();\n\t\t}\n\t} else {\n\t\t// update the screen\n\t\tSCR_UpdateScreen();\n\t}\n\t// update audio\n\tS_Update();\n\n\t// advance local effects for next frame\n\tSCR_RunCinematic();\n\n\tCon_RunConsole();\n\n\tcls.framecount++;\n}\n\n//============================================================================\n\n/*\n============\nCL_ShutdownRef\n============\n*/\nstatic void CL_ShutdownRef( qboolean restarting ) {\n\tif ( re.Shutdown ) {\n\t\tre.Shutdown( qtrue, restarting );\n\t}\n\n\tmemset( &re, 0, sizeof( re ) );\n\n\tif ( rendererLib != NULL ) {\n\t\tSys_UnloadDll (rendererLib);\n\t\trendererLib = NULL;\n\t}\n}\n\n/*\n============================\nCL_StartSound\n\nConvenience function for the sound system to be started\nREALLY early on Xbox, helps with memory fragmentation.\n============================\n*/\nvoid CL_StartSound( void ) {\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n}\n\n/*\n============\nCL_InitRenderer\n============\n*/\nvoid CL_InitRenderer( void ) {\n\t// this sets up the renderer and calls R_Init\n\tre.BeginRegistration( &cls.glconfig );\n\n\t// load character sets\n\tcls.charSetShader = re.RegisterShaderNoMip(\"gfx/2d/charsgrid_med\");\n\tcls.whiteShader = re.RegisterShader( \"white\" );\n\tcls.consoleShader = re.RegisterShader( \"console\" );\n\tg_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;\n\tg_consoleField.widthInChars = g_console_field_width;\n}\n\n/*\n============================\nCL_StartHunkUsers\n\nAfter the server has cleared the hunk, these will need to be restarted\nThis is the only place that any of these functions are called from\n============================\n*/\nvoid CL_StartHunkUsers( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif ( !cls.rendererStarted ) {\n\t\tcls.rendererStarted = qtrue;\n\t\tCL_InitRenderer();\n\t}\n\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n\n\t//we require the ui to be loaded here or else it crashes trying to access the ui on command line map loads\n\tif ( !cls.uiStarted ) {\n\t\tcls.uiStarted = qtrue;\n\t\tCL_InitUI();\n\t}\n\n//\tif ( !cls.cgameStarted && cls.state > CA_CONNECTED && cls.state != CA_CINEMATIC ) {\n\tif ( !cls.cgameStarted && cls.state > CA_CONNECTED && (cls.state != CA_CINEMATIC && !CL_IsRunningInGameCinematic()) )\n\t{\n\t\tcls.cgameStarted = qtrue;\n\t\tCL_InitCGame();\n\t}\n}\n\n/*\n================\nCL_RefPrintf\n\nDLL glue\n================\n*/\nvoid QDECL CL_RefPrintf( int print_level, const char *fmt, ...) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf(msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tif ( print_level == PRINT_ALL ) {\n\t\tCom_Printf (\"%s\", msg);\n\t} else if ( print_level == PRINT_WARNING ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"%s\", msg);\t\t// yellow\n\t} else if ( print_level == PRINT_DEVELOPER ) {\n\t\tCom_DPrintf (S_COLOR_RED \"%s\", msg);\t\t// red\n\t}\n}\n\n/*\n============\nString_GetStringValue\n\nDLL glue, but highly reusuable DLL glue at that\n============\n*/\n\nconst char *String_GetStringValue( const char *reference )\n{\n#ifndef JK2_MODE\n\treturn SE_GetString(reference);\n#else\n\treturn JK2SP_GetStringTextString(reference);\n#endif\n}\n\nextern qboolean gbAlreadyDoingLoad;\nextern void *gpvCachedMapDiskImage;\nextern char  gsCachedMapDiskImage[MAX_QPATH];\nextern qboolean gbUsingCachedMapDataRightNow;\n\nchar *get_gsCachedMapDiskImage( void )\n{\n\treturn gsCachedMapDiskImage;\n}\n\nvoid *get_gpvCachedMapDiskImage( void )\n{\n\treturn gpvCachedMapDiskImage;\n}\n\nqboolean *get_gbUsingCachedMapDataRightNow( void )\n{\n\treturn &gbUsingCachedMapDataRightNow;\n}\n\nqboolean *get_gbAlreadyDoingLoad( void )\n{\n\treturn &gbAlreadyDoingLoad;\n}\n\nint get_com_frameTime( void )\n{\n\treturn com_frameTime;\n}\n\nvoid *CL_Malloc(int iSize, memtag_t eTag, qboolean bZeroit, int iAlign)\n{\n    return Z_Malloc(iSize, eTag, bZeroit);\n}\n\n/*\n============\nCL_InitRef\n============\n*/\nextern qboolean S_FileExists( const char *psFilename );\nextern bool CM_CullWorldBox (const cplane_t *frustum, const vec3pair_t bounds);\nextern qboolean SND_RegisterAudio_LevelLoadEnd(qboolean bDeleteEverythingNotUsedThisLevel /* 99% qfalse */);\nextern cvar_t *Cvar_Set2( const char *var_name, const char *value, qboolean force);\nextern CMiniHeap *G2VertSpaceServer;\nstatic CMiniHeap *GetG2VertSpaceServer( void ) {\n\treturn G2VertSpaceServer;\n}\n\n// NOTENOTE: If you change the output name of rd-vanilla, change this define too!\n#ifdef JK2_MODE\n#define DEFAULT_RENDER_LIBRARY\t\"rdjosp-vanilla\"\n#else\n#define DEFAULT_RENDER_LIBRARY\t\"rdsp-vanilla\"\n#endif\n\nvoid CL_InitRef( void ) {\n\trefexport_t\t*ret;\n\tstatic refimport_t rit;\n\tchar\t\tdllName[MAX_OSPATH];\n\tGetRefAPI_t\tGetRefAPI;\n\n\tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n    cl_renderer = Cvar_Get( \"cl_renderer\", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED );\n\n\tCom_sprintf( dllName, sizeof( dllName ), \"%s_\" ARCH_STRING DLL_EXT, cl_renderer->string );\n\n\tif( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) )\n\t{\n\t\tCom_Printf( \"failed: trying to load fallback renderer\\n\" );\n\t\tCvar_ForceReset( \"cl_renderer\" );\n\n\t\tCom_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY \"_\" ARCH_STRING DLL_EXT );\n\t\trendererLib = Sys_LoadDll( dllName, qfalse );\n\t}\n\n\tif ( !rendererLib ) {\n\t\tCom_Error( ERR_FATAL, \"Failed to load renderer\\n\" );\n\t}\n\n\tmemset( &rit, 0, sizeof( rit ) );\n\n\tGetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, \"GetRefAPI\" );\n\tif ( !GetRefAPI )\n\t\tCom_Error( ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\", Sys_LibraryError() );\n\n#define RIT(y)\trit.y = y\n\tRIT(CIN_PlayCinematic);\n\tRIT(CIN_RunCinematic);\n\tRIT(CIN_UploadCinematic);\n\tRIT(CL_IsRunningInGameCinematic);\n\tRIT(Cmd_AddCommand);\n\tRIT(Cmd_Argc);\n\tRIT(Cmd_ArgsBuffer);\n\tRIT(Cmd_Argv);\n\tRIT(Cmd_ExecuteString);\n\tRIT(Cmd_RemoveCommand);\n\tRIT(CM_ClusterPVS);\n\tRIT(CM_CullWorldBox);\n\tRIT(CM_DeleteCachedMap);\n\tRIT(CM_DrawDebugSurface);\n\tRIT(CM_PointContents);\n\tRIT(Cvar_Get);\n\tRIT(Cvar_Set);\n\tRIT(Cvar_SetValue);\n\tRIT(Cvar_CheckRange);\n\tRIT(Cvar_VariableIntegerValue);\n\tRIT(Cvar_VariableString);\n\tRIT(Cvar_VariableStringBuffer);\n\tRIT(Cvar_VariableValue);\n\tRIT(FS_FCloseFile);\n\tRIT(FS_FileIsInPAK);\n\tRIT(FS_FOpenFileByMode);\n\tRIT(FS_FOpenFileRead);\n\tRIT(FS_FOpenFileWrite);\n\tRIT(FS_FreeFile);\n\tRIT(FS_FreeFileList);\n\tRIT(FS_ListFiles);\n\tRIT(FS_Read);\n\tRIT(FS_ReadFile);\n\tRIT(FS_Write);\n\tRIT(FS_WriteFile);\n\tRIT(Hunk_ClearToMark);\n\tRIT(SND_RegisterAudio_LevelLoadEnd);\n\t//RIT(SV_PointContents);\n\tRIT(SV_Trace);\n\tRIT(S_RestartMusic);\n\tRIT(Z_Free);\n\trit.Malloc=CL_Malloc;\n\tRIT(Z_MemSize);\n\tRIT(Z_MorphMallocTag);\n\n\tRIT(Hunk_ClearToMark);\n\n    rit.WIN_Init = WIN_Init;\n\trit.WIN_SetGamma = WIN_SetGamma;\n    rit.WIN_Shutdown = WIN_Shutdown;\n    rit.WIN_Present = WIN_Present;\n\trit.GL_GetProcAddress = WIN_GL_GetProcAddress;\n\trit.GL_ExtensionSupported = WIN_GL_ExtensionSupported;\n\n\trit.PD_Load = PD_Load;\n\trit.PD_Store = PD_Store;\n\n\trit.Error = Com_Error;\n\trit.FS_FileExists = S_FileExists;\n\trit.GetG2VertSpaceServer = GetG2VertSpaceServer;\n\trit.LowPhysicalMemory = Sys_LowPhysicalMemory;\n\trit.Milliseconds = Sys_Milliseconds2;\n\trit.Printf = CL_RefPrintf;\n\trit.SE_GetString = String_GetStringValue;\n\n\trit.SV_Trace = SV_Trace;\n\n\trit.gpvCachedMapDiskImage = get_gpvCachedMapDiskImage;\n\trit.gsCachedMapDiskImage = get_gsCachedMapDiskImage;\n\trit.gbUsingCachedMapDataRightNow = get_gbUsingCachedMapDataRightNow;\n\trit.gbAlreadyDoingLoad = get_gbAlreadyDoingLoad;\n\trit.com_frameTime = get_com_frameTime;\n\n\trit.SV_PointContents = SV_PointContents;\n\n\trit.saved_game = &ojk::SavedGame::get_instance();\n\n\tret = GetRefAPI( REF_API_VERSION, &rit );\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = *ret;\n\n\tCom_Printf( \"-------------------------------\\n\");\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n\n//===========================================================================================\n\nvoid CL_CompleteCinematic( char *args, int argNum );\n\n/*\n====================\nCL_Init\n====================\n*/\nvoid CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n#ifdef JK2_MODE\n\tJK2SP_Register(\"con_text\", SP_REGISTER_REQUIRED);\t//reference is CON_TEXT\n\tJK2SP_Register(\"keynames\", SP_REGISTER_REQUIRED);\t// reference is KEYNAMES\n#endif\n\n\tCon_Init ();\n\n\tCL_ClearState ();\n\n\tcls.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t//cls.keyCatchers = KEYCATCH_CONSOLE;\n\tcls.realtime = 0;\n\tcls.realtimeFraction=0.0f;\t// fraction of a msec accumulated\n\n\tCL_InitInput ();\n\n\t//\n\t// register our variables\n\t//\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"125\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_newClock = Cvar_Get (\"cl_newClock\", \"1\", 0);\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_avidemo = Cvar_Get (\"cl_avidemo\", \"0\", 0);\n\tcl_pano = Cvar_Get (\"pano\", \"0\", 0);\n\tcl_panoNumShots= Cvar_Get (\"panoNumShots\", \"10\", CVAR_ARCHIVE);\n\tcl_skippingcin = Cvar_Get (\"skippingCinematic\", \"0\", CVAR_ROM);\n\tcl_endcredits = Cvar_Get (\"cg_endcredits\", \"0\", 0);\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", CVAR_ARCHIVE);\n\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n\n\tcl_allowAltEnter = Cvar_Get (\"cl_allowAltEnter\", \"1\", CVAR_ARCHIVE);\n\tcl_inGameVideo = Cvar_Get (\"cl_inGameVideo\", \"1\", CVAR_ARCHIVE);\n\tcl_framerate\t= Cvar_Get (\"cl_framerate\", \"0\", CVAR_TEMP);\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n\n\t// ~ and `, as keys and characters\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60 0xb2\", CVAR_ARCHIVE);\n\tcl_consoleUseScanCode = Cvar_Get( \"cl_consoleUseScanCode\", \"1\", CVAR_ARCHIVE );\n\n\t// userinfo\n#ifdef JK2_MODE\n\tCvar_Get (\"name\", \"Kyle\", CVAR_USERINFO | CVAR_ARCHIVE );\n#else\n\tCvar_Get (\"name\", \"Jaden\", CVAR_USERINFO | CVAR_ARCHIVE );\n#endif\n\n#ifdef JK2_MODE\n\t// this is required for savegame compatibility - not ever actually used\n\tCvar_Get (\"snaps\", \"20\", CVAR_USERINFO );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_SAVEGAME );\n#else\n\tCvar_Get (\"sex\", \"f\", CVAR_USERINFO | CVAR_ARCHIVE | CVAR_SAVEGAME | CVAR_NORESTART );\n\tCvar_Get (\"snd\", \"jaden_fmle\", CVAR_USERINFO | CVAR_ARCHIVE | CVAR_SAVEGAME | CVAR_NORESTART );//UI_SetSexandSoundForModel changes to match sounds.cfg for model\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_SAVEGAME | CVAR_NORESTART);\n#endif\n\n\t//\n\t// register our commands\n\t//\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\n\tCmd_SetCommandCompletionFunc( \"cinematic\", CL_CompleteCinematic );\n\tCmd_AddCommand (\"ingamecinematic\", CL_PlayInGameCinematic_f);\n\tCmd_AddCommand (\"uimenu\", CL_GenericMenu_f);\n\tCmd_AddCommand (\"datapad\", CL_DataPad_f);\n\tCmd_AddCommand (\"endscreendissolve\", CL_EndScreenDissolve_f);\n\n\tCL_InitRef();\n\n\tCL_StartHunkUsers();\n\n\tSCR_Init ();\n\n\tCbuf_Execute ();\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n\n\n/*\n===============\nCL_Shutdown\n\n===============\n*/\nvoid CL_Shutdown( void ) {\n\tstatic qboolean recursive = qfalse;\n\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tCom_Printf( \"----- CL_Shutdown -----\\n\" );\n\n\tif ( recursive ) {\n\t\tCom_Printf( \"WARNING: Recursive shutdown\\n\" );\n\t\treturn;\n\t}\n\trecursive = qtrue;\n\n\tCL_ShutdownUI();\n\tCL_Disconnect();\n\n\tS_Shutdown();\n\tCL_ShutdownRef(qfalse);\n\n\tCmd_RemoveCommand (\"cmd\");\n\tCmd_RemoveCommand (\"configstrings\");\n\tCmd_RemoveCommand (\"clientinfo\");\n\tCmd_RemoveCommand (\"snd_restart\");\n\tCmd_RemoveCommand (\"vid_restart\");\n\tCmd_RemoveCommand (\"disconnect\");\n\tCmd_RemoveCommand (\"cinematic\");\n\tCmd_RemoveCommand (\"ingamecinematic\");\n\tCmd_RemoveCommand (\"uimenu\");\n\tCmd_RemoveCommand (\"datapad\");\n\tCmd_RemoveCommand (\"endscreendissolve\");\n\n\tCvar_Set( \"cl_running\", \"0\" );\n\n\trecursive = qfalse;\n\n\tmemset( &cls, 0, sizeof( cls ) );\n\n\tCom_Printf( \"-----------------------\\n\" );\n}\n\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n/*****************************************************************************\n * name:\t\tfiles.cpp\n *\n * desc:\t\tfile code\n *\n *****************************************************************************/\n\n#include \"q_shared.h\"\n#include \"qcommon.h\"\n\n#ifndef FINAL_BUILD\n#include \"../client/client.h\"\n#endif\n#include <minizip/unzip.h>\n\n// for rmdir\n#if defined (_MSC_VER)\n\t#include <direct.h>\n#else\n\t#include <unistd.h>\n#endif\n\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n/*\n=============================================================================\n\nQUAKE3 FILESYSTEM\n\nAll of Quake's data access is through a hierarchical file system, but the contents of\nthe file system can be transparently merged from several sources.\n\nA \"qpath\" is a reference to game file data.  MAX_ZPATH is 256 characters, which must include\na terminating zero. \"..\", \"\\\\\", and \":\" are explicitly illegal in qpaths to prevent any\nreferences outside the quake directory system.\n\nThe \"base path\" is the path to the directory holding all the game directories and usually\nthe executable.  It defaults to \".\", but can be overridden with a \"+set fs_basepath c:\\quake3\"\ncommand line to allow code debugging in a different directory.  Basepath cannot\nbe modified at all after startup.  Any files that are created (demos, screenshots,\netc) will be created relative to the base path, so base path should usually be writable.\n\nThe \"home path\" is the path used for all write access. On win32 systems we have \"base path\"\n== \"home path\", but on *nix systems the base installation is usually readonly, and\n\"home path\" points to ~/.q3a or similar\n\nThe user can also install custom mods and content in \"home path\", so it should be searched\nalong with \"home path\" and \"cd path\" for game content.\n\n\nThe \"base game\" is the directory under the paths where data comes from by default, and\ncan be either \"baseq3\" or \"demoq3\".\n\nThe \"current game\" may be the same as the base game, or it may be the name of another\ndirectory under the paths that should be searched for files before looking in the base game.\nThis is the basis for addons.\n\nClients automatically set the game directory after receiving a gamestate from a server,\nso only servers need to worry about +set fs_game.\n\nNo other directories outside of the base game and current game will ever be referenced by\nfilesystem functions.\n\nTo save disk space and speed loading, directory trees can be collapsed into zip files.\nThe files use a \".pk3\" extension to prevent users from unzipping them accidentally, but\notherwise the are simply normal uncompressed zip files.  A game directory can have multiple\nzip files of the form \"pak0.pk3\", \"pak1.pk3\", etc.  Zip files are searched in decending order\nfrom the highest number to the lowest, and will always take precedence over the filesystem.\nThis allows a pk3 distributed as a patch to override all existing data.\n\nBecause we will have updated executables freely available online, there is no point to\ntrying to restrict demo / oem versions of the game with code changes.  Demo / oem versions\nshould be exactly the same executables as release versions, but with different data that\nautomatically restricts where game media can come from to prevent add-ons from working.\n\nFile search order: when FS_FOpenFileRead gets called it will go through the fs_searchpaths\nstructure and stop on the first successful hit. fs_searchpaths is built with successive\ncalls to FS_AddGameDirectory\n\nAdditionaly, we search in several subdirectories:\ncurrent game is the current mode\nbase game is a variable to allow mods based on other mods\n(such as baseq3 + missionpack content combination in a mod for instance)\nBASEGAME is the hardcoded base game (\"baseq3\")\n\ne.g. the qpath \"sound/newstuff/test.wav\" would be searched for in the following places:\n\nhome path + current game's zip files\nhome path + current game's directory\nbase path + current game's zip files\nbase path + current game's directory\ncd path + current game's zip files\ncd path + current game's directory\n\nhome path + base game's zip file\nhome path + base game's directory\nbase path + base game's zip file\nbase path + base game's directory\ncd path + base game's zip file\ncd path + base game's directory\n\nhome path + BASEGAME's zip file\nhome path + BASEGAME's directory\nbase path + BASEGAME's zip file\nbase path + BASEGAME's directory\ncd path + BASEGAME's zip file\ncd path + BASEGAME's directory\n\nserver download, to be written to home path + current game's directory\n\n\nThe filesystem can be safely shutdown and reinitialized with different\nbasedir / cddir / game combinations, but all other subsystems that rely on it\n(sound, video) must also be forced to restart.\n\nBecause the same files are loaded by both the clip model (CM_) and renderer (TR_)\nsubsystems, a simple single-file caching scheme is used.  The CM_ subsystems will\nload the file with a request to cache.  Only one file will be kept cached at a time,\nso any models that are going to be referenced by both subsystems should alternate\nbetween the CM_ load function and the ref load function.\n\nTODO: A qpath that starts with a leading slash will always refer to the base game, even if another\ngame is currently active.  This allows character models, skins, and sounds to be downloaded\nto a common directory no matter which game is active.\n\nHow to prevent downloading zip files?\nPass pk3 file names in systeminfo, and download before FS_Restart()?\n\nAborting a download disconnects the client from the server.\n\nHow to mark files as downloadable?  Commercial add-ons won't be downloadable.\n\nNon-commercial downloads will want to download the entire zip file.\nthe game would have to be reset to actually read the zip in\n\nAuto-update information\n\nPath separators\n\nCasing\n\n  separate server gamedir and client gamedir, so if the user starts\n  a local game after having connected to a network game, it won't stick\n  with the network game.\n\n  allow menu options for game selection?\n\nRead / write config to floppy option.\n\nDifferent version coexistance?\n\nWhen building a pak file, make sure a q3config.cfg isn't present in it,\nor configs will never get loaded from disk!\n\n  todo:\n\n  downloading (outside fs?)\n  game directory passing and restarting\n\n=============================================================================\n\n*/\n\n/*static const uint32_t pak_checksums[] = {\n\t0u,\n};\n\nstatic const uint32_t bonuspak_checksum = 0u;*/\n\n#define MAX_ZPATH\t\t\t256\n#define\tMAX_SEARCH_PATHS\t4096\n#define MAX_FILEHASH_SIZE\t1024\n\ntypedef struct fileInPack_s {\n\tchar\t\t\t\t\t*name;\t\t// name of the file\n\tunsigned long\t\t\tpos;\t\t// file info position in zip\n\tunsigned long\t\t\tlen;\t\t// uncompress file size\n\tstruct\tfileInPack_s*\tnext;\t\t// next file in the hash\n} fileInPack_t;\n\ntypedef struct pack_s {\n\tchar\t\t\tpakPathname[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\t\tpakFilename[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\\assets0.pk3\n\tchar\t\t\tpakBasename[MAX_OSPATH];\t// assets0\n\tchar\t\t\tpakGamename[MAX_OSPATH];\t// base\n\tunzFile\t\t\thandle;\t\t\t\t\t\t// handle to zip file\n\tint\t\t\t\tchecksum;\t\t\t\t\t// regular checksum\n\tint\t\t\t\tnumfiles;\t\t\t\t\t// number of files in pk3\n\tint\t\t\t\thashSize;\t\t\t\t\t// hash table size (power of 2)\n\tfileInPack_t*\t*hashTable;\t\t\t\t\t// hash table\n\tfileInPack_t*\tbuildBuffer;\t\t\t\t// buffer with the filenames etc.\n} pack_t;\n\ntypedef struct directory_s {\n\tchar\t\tpath[MAX_OSPATH];\t\t// c:\\jediacademy\\gamedata\n\tchar\t\tfullpath[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\tgamedir[MAX_OSPATH];\t// base\n} directory_t;\n\ntypedef struct searchpath_s {\n\tstruct searchpath_s *next;\n\n\tpack_t\t\t*pack;\t\t// only one of pack / dir will be non NULL\n\tdirectory_t\t*dir;\n} searchpath_t;\n\nstatic char\t\tfs_gamedir[MAX_OSPATH];\t// this will be a single file name with no separators\nstatic cvar_t\t\t*fs_debug;\nstatic cvar_t\t\t*fs_homepath;\n\n#ifdef MACOS_X\n// Also search the .app bundle for .pk3 files\nstatic cvar_t          *fs_apppath;\n#endif\n\nstatic cvar_t\t\t*fs_basepath;\nstatic cvar_t\t\t*fs_basegame;\nstatic cvar_t\t\t*fs_cdpath;\nstatic cvar_t\t\t*fs_copyfiles;\nstatic cvar_t\t\t*fs_gamedirvar;\nstatic cvar_t\t\t*fs_dirbeforepak; //rww - when building search path, keep directories at top and insert pk3's under them\nstatic searchpath_t\t*fs_searchpaths;\nstatic int\t\t\tfs_readCount;\t\t\t// total bytes read\nstatic int\t\t\tfs_loadCount;\t\t\t// total files read\nstatic int\t\t\tfs_packFiles = 0;\t\t// total number of files in packs\n\ntypedef union qfile_gus {\n\tFILE*\t\to;\n\tunzFile\t\tz;\n} qfile_gut;\n\ntypedef struct qfile_us {\n\tqfile_gut\tfile;\n\tqboolean\tunique;\n} qfile_ut;\n\ntypedef struct fileHandleData_s {\n\tqfile_ut\thandleFiles;\n\tqboolean\thandleSync;\n\tint\t\t\tfileSize;\n\tint\t\t\tzipFilePos;\n\tint\t\t\tzipFileLen;\n\tqboolean\tzipFile;\n\tchar\t\tname[MAX_ZPATH];\n} fileHandleData_t;\n\nstatic fileHandleData_t\tfsh[MAX_FILE_HANDLES];\n\n// last valid game folder used\nchar lastValidBase[MAX_OSPATH];\nchar lastValidGame[MAX_OSPATH];\n\n/* C99 defines __func__ */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2 || _MSC_VER >= 1300\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"(unknown)\"\n#  endif\n#endif\n\n/*\n==============\nFS_Initialized\n==============\n*/\n\nqboolean FS_Initialized( void ) {\n\treturn (qboolean)(fs_searchpaths != NULL);\n}\n\nstatic void FS_AssertInitialised( void ) {\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n}\n\n/*\n================\nreturn a hash value for the filename\n================\n*/\nstatic long FS_HashFileName( const char *fname, int hashSize ) {\n\tint\t\ti;\n\tlong\thash;\n\tchar\tletter;\n\n\thash = 0;\n\ti = 0;\n\twhile (fname[i] != '\\0') {\n\t\tletter = tolower(fname[i]);\n\t\tif (letter =='.') break;\t\t\t\t// don't include extension\n\t\tif (letter =='\\\\') letter = '/';\t\t// damn path names\n\t\tif (letter == PATH_SEP) letter = '/';\t\t// damn path names\n\t\thash+=(long)(letter)*(i+119);\n\t\ti++;\n\t}\n\thash = (hash ^ (hash >> 10) ^ (hash >> 20));\n\thash &= (hashSize-1);\n\treturn hash;\n}\n\nstatic fileHandle_t FS_HandleForFile(void) {\n\tint\t\ti;\n\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o == NULL ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tCom_Printf( \"FS_HandleForFile: all handles taken:\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tCom_Printf( \"%d. %s\\n\", i, fsh[i].name);\n\t}\n\tCom_Error( ERR_DROP, \"FS_HandleForFile: none free\" );\n\treturn 0;\n}\n\nstatic FILE\t*FS_FileForHandle( fileHandle_t f ) {\n\tif ( f < 1 || f >= MAX_FILE_HANDLES ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: out of range\" );\n\t}\n\tif (fsh[f].zipFile == qtrue) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: can't get FILE on zip file\" );\n\t}\n\tif ( ! fsh[f].handleFiles.file.o ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: NULL\" );\n\t}\n\n\treturn fsh[f].handleFiles.file.o;\n}\n\nvoid\tFS_ForceFlush( fileHandle_t f ) {\n\tFILE *file;\n\n\tfile = FS_FileForHandle(f);\n\tsetvbuf( file, NULL, _IONBF, 0 );\n}\n\n/*\n================\nFS_fplength\n================\n*/\n\nlong FS_fplength(FILE *h)\n{\n\tlong\t\tpos;\n\tlong\t\tend;\n\n\tpos = ftell(h);\n\tif ( pos == EOF )\n\t\treturn EOF;\n\n\tfseek(h, 0, SEEK_END);\n\tend = ftell(h);\n\tfseek(h, pos, SEEK_SET);\n\n\treturn end;\n}\n\n/*\n================\nFS_filelength\n\nIf this is called on a non-unique FILE (from a pak file),\nit will return the size of the pak file, not the expected\nsize of the file.\n================\n*/\nint FS_filelength( fileHandle_t f ) {\n\tFILE\t*h;\n\n\th = FS_FileForHandle(f);\n\n\tif(h == NULL)\n\t\treturn EOF;\n\telse\n\t\treturn FS_fplength(h);\n}\n\n/*\n====================\nFS_ReplaceSeparators\n\nFix things up differently for win/unix/mac\n====================\n*/\nvoid FS_ReplaceSeparators( char *path ) {\n\tchar\t*s;\n\tqboolean lastCharWasSep = qfalse;\n\n\tfor ( s = path ; *s ; s++ ) {\n\t\tif ( *s == '/' || *s == '\\\\' ) {\n\t\t\tif ( !lastCharWasSep ) {\n\t\t\t\t*s = PATH_SEP;\n\t\t\t\tlastCharWasSep = qtrue;\n\t\t\t} else {\n\t\t\t\tmemmove (s, s + 1, strlen (s));\n\t\t\t}\n\t\t} else {\n\t\t\tlastCharWasSep = qfalse;\n\t\t}\n\t}\n}\n\n/*\n===================\nFS_BuildOSPath\n\nQpath may have either forward or backwards slashes\n===================\n*/\nchar *FS_BuildOSPath( const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\t// Fix for filenames that are given to FS with a leading \"/\" (/botfiles/Foo)\n\tif (qpath[0] == '\\\\' || qpath[0] == '/')\n\t\tqpath++;\n\n\tCom_sprintf( temp, sizeof(temp), \"/base/%s\", qpath ); // FIXME SP used fs_gamedir here as well (not sure if this func is even used)\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", fs_basepath->string, temp );\n\n\treturn ospath[toggle];\n}\n\nchar *FS_BuildOSPath( const char *base, const char *game, const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\tif( !game || !game[0] ) {\n\t\tgame = fs_gamedir;\n\t}\n\n\tCom_sprintf( temp, sizeof(temp), \"/%s/%s\", game, qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", base, temp );\n\n\treturn ospath[toggle];\n}\n\n/*\n============\nFS_CreatePath\n\nCreates any directories needed to store the given filename\n============\n*/\nqboolean FS_CreatePath (char *OSPath) {\n\tchar\t*ofs;\n\tchar\tpath[MAX_OSPATH];\n\n\t// make absolutely sure that it can't back up the path\n\t// FIXME: is c: allowed???\n\tif ( strstr( OSPath, \"..\" ) || strstr( OSPath, \"::\" ) ) {\n\t\tCom_Printf( \"WARNING: refusing to create relative path \\\"%s\\\"\\n\", OSPath );\n\t\treturn qtrue;\n\t}\n\n\tQ_strncpyz( path, OSPath, sizeof( path ) );\n\tFS_ReplaceSeparators( path );\n\n\t// Skip creation of the root directory as it will always be there\n\tofs = strchr( path, PATH_SEP );\n\tif ( ofs ) {\n\t\tofs++;\n\t}\n\n\tfor (; ofs != NULL && *ofs ; ofs++) {\n\t\tif (*ofs == PATH_SEP) {\n\t\t\t// create the directory\n\t\t\t*ofs = 0;\n\t\t\tif (!Sys_Mkdir (path)) {\n\t\t\t\tCom_Error( ERR_FATAL, \"FS_CreatePath: failed to create path \\\"%s\\\"\",\n\t\t\t\t\tpath );\n\t\t\t}\n\t\t\t*ofs = PATH_SEP;\n\t\t}\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_CheckFilenameIsMutable\n\nERR_FATAL if trying to maniuplate a file with the platform library, or pk3 extension\n=================\n*/\nstatic void FS_CheckFilenameIsMutable( const char *filename, const char *function )\n{\n\t// Check if the filename ends with the library, or pk3 extension\n\tif( COM_CompareExtension( filename, DLL_EXT )\n\t\t|| COM_CompareExtension( filename, \".pk3\" ) )\n\t{\n\t\tCom_Error( ERR_FATAL, \"%s: Not allowed to manipulate '%s' due \"\n\t\t\t\"to %s extension\", function, filename, COM_GetExtension( filename ) );\n\t}\n}\n\n/*\n=================\nFS_CopyFile\n\nCopy a fully specified file from one place to another\n=================\n*/\n// added extra param so behind-the-scenes copying in savegames doesn't clutter up the screen -slc\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath, qboolean qbSilent = qfalse );\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath, qboolean qbSilent ) {\n\tFILE\t*f;\n\tint\t\tlen;\n\tbyte\t*buf;\n\n\tFS_CheckFilenameIsMutable( fromOSPath, __func__ );\n\n\tif ( !qbSilent )\n\t\tCom_Printf( \"copy %s to %s\\n\", fromOSPath, toOSPath );\n\n\tf = fopen( fromOSPath, \"rb\" );\n\tif ( !f ) {\n\t\treturn;\n\t}\n\tfseek (f, 0, SEEK_END);\n\tlen = ftell (f);\n\tfseek (f, 0, SEEK_SET);\n\n\tif ( len == EOF )\n\t{\n\t\tfclose( f );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Bad file length in FS_CopyFile()\" );\n\t}\n\n\t// we are using direct malloc instead of Z_Malloc here, so it\n\t// probably won't work on a mac... Its only for developers anyway...\n\tbuf = (unsigned char *)malloc( len );\n\tif (fread( buf, 1, len, f ) != (size_t)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\n\tif( FS_CreatePath( toOSPath ) ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\n\tf = fopen( toOSPath, \"wb\" );\n\tif ( !f ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\tif (fwrite( buf, 1, len, f ) != (size_t)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tif ( qbSilent )\n\t\t\treturn;\n\t\tCom_Error( ERR_FATAL, \"Short write in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\tfree( buf );\n}\n\n/*\n===========\nFS_Remove\n\n===========\n*/\nvoid FS_Remove( const char *osPath ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tremove( osPath );\n}\n\n/*\n===========\nFS_HomeRemove\n\n===========\n*/\nvoid FS_HomeRemove( const char *homePath ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tremove( FS_BuildOSPath( fs_homepath->string,\n\t\t\tfs_gamedir, homePath ) );\n}\n\n// The following functions with \"UserGen\" in them were added for savegame handling,\n//\tsince outside functions aren't supposed to know about full paths/dirs\n\n// \"filename\" is local to the current gamedir (eg \"saves/blah.sav\")\n//\nvoid FS_DeleteUserGenFile( const char *filename ) {\n\tFS_HomeRemove( filename );\n}\n\n// filenames are local (eg \"saves/blah.sav\")\n//\n// return: qtrue = OK\n//\nqboolean FS_MoveUserGenFile( const char *filename_src, const char *filename_dst ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename_src );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename_dst );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_MoveUserGenFile: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tremove( to_ospath );\n\treturn (qboolean)!rename( from_ospath, to_ospath );\n}\n\n/*\n===========\nFS_Rmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_Rmdir( const char *osPath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tif ( recursive ) {\n\t\tint numfiles;\n\t\tint i;\n\t\tchar **filesToRemove = Sys_ListFiles( osPath, \"\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tchar fileOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( fileOsPath, sizeof( fileOsPath ), \"%s/%s\", osPath, filesToRemove[i] );\n\t\t\tFS_Remove( fileOsPath );\n\t\t}\n\t\tFS_FreeFileList( filesToRemove );\n\n\t\tchar **directoriesToRemove = Sys_ListFiles( osPath, \"/\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tif ( !Q_stricmp( directoriesToRemove[i], \".\" ) || !Q_stricmp( directoriesToRemove[i], \"..\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar directoryOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( directoryOsPath, sizeof( directoryOsPath ), \"%s/%s\", osPath, directoriesToRemove[i] );\n\t\t\tFS_Rmdir( directoryOsPath, qtrue );\n\t\t}\n\t\tFS_FreeFileList( directoriesToRemove );\n\t}\n\n\trmdir( osPath );\n}\n\n/*\n===========\nFS_HomeRmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_HomeRmdir( const char *homePath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tFS_Rmdir( FS_BuildOSPath( fs_homepath->string,\n\t\t\t\t\tfs_gamedir, homePath ), recursive );\n}\n\n/*\n================\nFS_FileInPathExists\n\nTests if path and file exists\n================\n*/\nqboolean FS_FileInPathExists(const char *testpath)\n{\n\tFILE *filep;\n\n\tfilep = fopen(testpath, \"rb\");\n\n\tif(filep)\n\t{\n\t\tfclose(filep);\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_FileExists\n\nTests if the file exists in the current gamedir, this DOES NOT\nsearch the paths.  This is to determine if opening a file to write\n(which always goes into the current gamedir) will cause any overwrites.\nNOTE TTimo: this goes with FS_FOpenFileWrite for opening the file afterwards\n================\n*/\nqboolean FS_FileExists( const char *file )\n{\n\treturn FS_FileInPathExists(FS_BuildOSPath(fs_homepath->string, fs_gamedir, file));\n}\n\n/*\n================\nFS_SV_FileExists\n\nTests if the file exists\n================\n*/\nqboolean FS_SV_FileExists( const char *file )\n{\n\tchar *testpath;\n\n\ttestpath = FS_BuildOSPath( fs_homepath->string, file, \"\");\n\ttestpath[strlen(testpath)-1] = '\\0';\n\n\treturn FS_FileInPathExists(testpath);\n}\n\n/*\n===========\nFS_SV_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_SV_FOpenFileWrite( const char *filename ) {\n\tchar *ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tCom_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_SV_FOpenFileRead\nsearch for a file somewhere below the home path, base path or cd path\nwe search in that order, matching FS_SV_FOpenFileRead order\n===========\n*/\nint FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp ) {\n\tchar *ospath;\n\tfileHandle_t\tf = 0;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\t// search homepath\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\t// remove trailing slash\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_homepath): %s\\n\", ospath );\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// NOTE TTimo on non *nix systems, fs_homepath == fs_basepath, might want to avoid\n\t\tif (Q_stricmp(fs_homepath->string,fs_basepath->string))\n\t\t{\n\t\t\t// search basepath\n\t\t\tospath = FS_BuildOSPath( fs_basepath->string, filename, \"\" );\n\t\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\t\tif ( fs_debug->integer )\n\t\t\t{\n\t\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_basepath): %s\\n\", ospath );\n\t\t\t}\n\n\t\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\t\tfsh[f].handleSync = qfalse;\n\t\t}\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// search cd path\n\t\tospath = FS_BuildOSPath( fs_cdpath->string, filename, \"\" );\n\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\tif (fs_debug->integer)\n\t\t{\n\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_cdpath) : %s\\n\", ospath );\n\t\t}\n\n\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\tfsh[f].handleSync = qfalse;\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\t*fp = f;\n\tif (f) {\n\t\treturn FS_filelength(f);\n\t}\n\treturn 0;\n}\n\n/*\n===========\nFS_SV_Rename\n\n===========\n*/\nvoid FS_SV_Rename( const char *from, const char *to, qboolean safe ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, from, \"\" );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, to, \"\" );\n\tfrom_ospath[strlen(from_ospath)-1] = '\\0';\n\tto_ospath[strlen(to_ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\t}\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_Rename\n\n===========\n*/\nvoid FS_Rename( const char *from, const char *to ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_FCloseFile\n\nClose a file.\n\nThere are three cases handled:\n\n  * normal file: closed with fclose.\n\n  * file in pak3 archive: subfile is closed with unzCloseCurrentFile, but the\n    minizip handle to the pak3 remains open.\n\n  * file in pak3 archive, opened with \"unique\" flag: This file did not use\n    the system minizip handle to the pak3 file, but its own dedicated one.\n    The dedicated handle is closed with unzClose.\n\n===========\n*/\nvoid FS_FCloseFile( fileHandle_t f ) {\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\tunzCloseCurrentFile( fsh[f].handleFiles.file.z );\n\t\tif ( fsh[f].handleFiles.unique ) {\n\t\t\tunzClose( fsh[f].handleFiles.file.z );\n\t\t}\n\t\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n\t\treturn;\n\t}\n\n\t// we didn't find it as a pak, so close it as a unique file\n\tif (fsh[f].handleFiles.file.o) {\n\t\tfclose (fsh[f].handleFiles.file.o);\n\t}\n\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n}\n\n/*\n===========\nFS_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_FOpenFileWrite( const char *filename, qboolean safe ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\t}\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\t// enabling the following line causes a recursive function call loop\n\t// when running with +set logfile 1 +set developer 1\n\t//Com_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FOpenFileAppend\n\n===========\n*/\nfileHandle_t FS_FOpenFileAppend( const char *filename ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileAppend: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"ab\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FilenameCompare\n\nIgnore case and separator char distinctions\n===========\n*/\nqboolean FS_FilenameCompare( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 != c2) {\n\t\t\treturn qtrue;\t\t// strings not equal\n\t\t}\n\t} while (c1);\n\n\treturn qfalse;\t\t// strings are equal\n}\n\n/*\n===========\nFS_IsExt\n\nReturn qtrue if ext matches file extension filename\n===========\n*/\n\nqboolean FS_IsExt(const char *filename, const char *ext, int namelen)\n{\n\tint extlen;\n\n\textlen = strlen(ext);\n\n\tif(extlen > namelen)\n\t\treturn qfalse;\n\n\tfilename += namelen - extlen;\n\n\treturn (qboolean)!Q_stricmp(filename, ext);\n}\n\n/*\n===========\nFS_IsDemoExt\n\nReturn qtrue if filename has a demo extension\n===========\n*/\n\n#define DEMO_EXTENSION \"dm_\"\nqboolean FS_IsDemoExt(const char *filename, int namelen)\n{\n\tconst char *ext_test;\n\n\text_test = strrchr(filename, '.');\n\tif(ext_test && !Q_stricmpn(ext_test + 1, DEMO_EXTENSION, ARRAY_LEN(DEMO_EXTENSION) - 1))\n\t{\n\t\tint protocol = atoi(ext_test + ARRAY_LEN(DEMO_EXTENSION));\n\n\t\tif(protocol == PROTOCOL_VERSION)\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n#ifdef _WIN32\n\nbool Sys_GetFileTime(LPCSTR psFileName, FILETIME &ft)\n{\n\tbool bSuccess = false;\n\tHANDLE hFile = INVALID_HANDLE_VALUE;\n\n\thFile = CreateFile(\tpsFileName,\t// LPCTSTR lpFileName,          // pointer to name of the file\n\t\t\t\t\t\tGENERIC_READ,\t\t\t// DWORD dwDesiredAccess,       // access (read-write) mode\n\t\t\t\t\t\tFILE_SHARE_READ,\t\t// DWORD dwShareMode,           // share mode\n\t\t\t\t\t\tNULL,\t\t\t\t\t// LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t// pointer to security attributes\n\t\t\t\t\t\tOPEN_EXISTING,\t\t\t// DWORD dwCreationDisposition,  // how to create\n\t\t\t\t\t\tFILE_FLAG_NO_BUFFERING,// DWORD dwFlagsAndAttributes,   // file attributes\n\t\t\t\t\t\tNULL\t\t\t\t\t// HANDLE hTemplateFile          // handle to file with attributes to\n\t\t\t\t\t\t);\n\n\tif (hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (GetFileTime(hFile,\t// handle to file\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpCreationTime\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpLastAccessTime\n\t\t\t\t\t\t&ft\t\t// LPFILETIME lpLastWriteTime\n\t\t\t\t\t\t)\n\t\t\t)\n\t\t{\n\t\t\tbSuccess = true;\n\t\t}\n\n\t\tCloseHandle(hFile);\n\t}\n\n\treturn bSuccess;\n}\n\nbool Sys_FileOutOfDate( LPCSTR psFinalFileName /* dest */, LPCSTR psDataFileName /* src */ )\n{\n\tFILETIME ftFinalFile, ftDataFile;\n\n\tif (Sys_GetFileTime(psFinalFileName, ftFinalFile) && Sys_GetFileTime(psDataFileName, ftDataFile))\n\t{\n\t\t// timer res only accurate to within 2 seconds on FAT, so can't do exact compare...\n\t\t//\n\t\t//LONG l = CompareFileTime( &ftFinalFile, &ftDataFile );\n\t\tif (  (abs((double)(ftFinalFile.dwLowDateTime - ftDataFile.dwLowDateTime)) <= 20000000 ) &&\n\t\t\t\t  ftFinalFile.dwHighDateTime == ftDataFile.dwHighDateTime\n\t\t\t)\n\t\t{\n\t\t\treturn false;\t// file not out of date, ie use it.\n\t\t}\n\t\treturn true;\t// flag return code to copy over a replacement version of this file\n\t}\n\n\n\t// extra error check, report as suspicious if you find a file locally but not out on the net.,.\n\t//\n\tif (com_developer->integer)\n\t{\n\t\tif (!Sys_GetFileTime(psDataFileName, ftDataFile))\n\t\t{\n\t\t\tCom_Printf( \"Sys_FileOutOfDate: reading %s but it's not on the net!\\n\", psFinalFileName);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n#endif // _WIN32\n\nbool FS_FileCacheable(const char* const filename)\n{\n\textern\tcvar_t\t*com_buildScript;\n\tif (com_buildScript && com_buildScript->integer)\n\t{\n\t\treturn true;\n\t}\n\treturn( strchr(filename, '/') != 0 );\n}\n\n/*\n===========\nFS_FOpenFileRead\n\nFinds the file in the search path.\nReturns filesize and an open FILE pointer.\nUsed for streaming data out of either a\nseparate file or a ZIP file.\n===========\n*/\nextern qboolean\t\tcom_fullyInitialized;\n\nlong FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE ) {\n\tsearchpath_t\t*search;\n\tchar\t\t\t*netpath;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tdirectory_t\t\t*dir;\n\tlong\t\t\thash;\n\t//unz_s\t\t\t*zfi;\n\t//void\t\t\t*temp;\n\tbool\t\t\tisUserConfig = false;\n\n\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( file == NULL ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'file' parameter passed\\n\" );\n\t}\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t// make sure the q3key file is only readable by the quake3.exe at initialization\n\t// any other time the key should only be accessed in memory using the provided functions\n\tif( com_fullyInitialized && strstr( filename, \"q3key\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\tisUserConfig = !Q_stricmp( filename, \"autoexec_sp.cfg\" ) || !Q_stricmp( filename, Q3CONFIG_NAME );\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\t*file = FS_HandleForFile();\n\tfsh[*file].handleFiles.unique = uniqueFILE;\n\n\t// this new bool is in for an optimisation, if you (eg) opened a BSP file under fs_copyfiles==2,\n\t//\tthen it triggered a copy operation to update your local HD version, then this will re-open the\n\t//\tfile handle on your local version, not the net build. This uses a bit more CPU to re-do the loop\n\t//\tlogic, but should read faster than accessing the net version a second time.\n\t//\n\tqboolean bFasterToReOpenUsingNewLocalFile = qfalse;\n\n\tdo\n\t{\n\t\tbFasterToReOpenUsingNewLocalFile = qfalse;\n\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t//\n\t\t\tif ( search->pack ) {\n\t\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t\t}\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t\t// autoexec_sp.cfg and openjk_sp.cfg can only be loaded outside of pk3 files.\n\t\t\t\tif ( isUserConfig ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpak = search->pack;\n\t\t\t\tpakFile = pak->hashTable[hash];\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\n\t\t\t\t\t\tif ( uniqueFILE ) {\n\t\t\t\t\t\t\t// open a new file on the pakfile\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = unzOpen (pak->pakFilename);\n\t\t\t\t\t\t\tif (fsh[*file].handleFiles.file.z == NULL) {\n\t\t\t\t\t\t\t\tCom_Error (ERR_FATAL, \"Couldn't open %s\", pak->pakFilename);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = pak->handle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\t\t\tfsh[*file].zipFile = qtrue;\n\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);\n\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile(fsh[*file].handleFiles.file.z);\n\n#if 0\n\t\t\t\t\t\tzfi = (unz_s *)fsh[*file].handleFiles.file.z;\n\t\t\t\t\t\t// in case the file was new\n\t\t\t\t\t\ttemp = zfi->filestream;\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(pak->handle, pakFile->pos);\n\t\t\t\t\t\t// copy the file info into the unzip structure\n\t\t\t\t\t\tCom_Memcpy( zfi, pak->handle, sizeof(unz_s) );\n\t\t\t\t\t\t// we copy this back into the structure\n\t\t\t\t\t\tzfi->filestream = temp;\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile( fsh[*file].handleFiles.file.z );\n#endif\n\t\t\t\t\t\tfsh[*file].zipFilePos = pakFile->pos;\n\t\t\t\t\t\tfsh[*file].zipFileLen = pakFile->len;\n\n\t\t\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s')\\n\",\n\t\t\t\t\t\t\t\tfilename, pak->pakFilename );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn pakFile->len;\n\t\t\t\t\t}\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while(pakFile != NULL);\n\t\t\t} else if ( search->dir ) {\n\t\t\t\t// check a file in the directory tree\n\n\t\t\t\tdir = search->dir;\n\n\t\t\t\tnetpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\t\tfsh[*file].handleFiles.file.o = fopen (netpath, \"rb\");\n\t\t\t\tif ( !fsh[*file].handleFiles.file.o ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if running with fs_copyfiles 2, and search path == local, then we need to fail to open\n\t\t\t\t//\tif the time/date stamp != the network version (so it'll loop round again and use the network path,\n\t\t\t\t//\twhich comes later in the search order)\n\t\t\t\t//\n\t\t\t\tif ( fs_copyfiles->integer == 2 && fs_cdpath->string[0] && !Q_stricmp( dir->path, fs_basepath->string )\n\t\t\t\t\t&& FS_FileCacheable(filename) )\n\t\t\t\t{\n\t\t\t\t\tif ( Sys_FileOutOfDate( netpath, FS_BuildOSPath( fs_cdpath->string, dir->gamedir, filename ) ))\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\tfsh[*file].handleFiles.file.o = 0;\n\t\t\t\t\t\tcontinue;\t//carry on to find the cdpath version.\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\tfsh[*file].zipFile = qfalse;\n\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s%c%s')\\n\", filename,\n\t\t\t\t\t\tdir->path, PATH_SEP, dir->gamedir );\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if we are getting it from the cdpath, optionally copy it\n\t\t\t\t//  to the basepath\n\t\t\t\tif ( fs_copyfiles->integer && !Q_stricmp( dir->path, fs_cdpath->string ) ) {\n\t\t\t\t\tchar\t*copypath;\n\n\t\t\t\t\tcopypath = FS_BuildOSPath( fs_basepath->string, dir->gamedir, filename );\n\t\t\t\t\tswitch ( fs_copyfiles->integer )\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFS_CopyFile( netpath, copypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (FS_FileCacheable(filename) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// maybe change this to Com_DPrintf?   On the other hand...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tCom_Printf( \"fs_copyfiles(2), Copying: %s to %s\\n\", netpath, copypath );\n\n\t\t\t\t\t\t\t\tFS_CreatePath( copypath );\n\n\t\t\t\t\t\t\t\tbool bOk = true;\n\t\t\t\t\t\t\t\tif (!CopyFile( netpath, copypath, FALSE ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDWORD dwAttrs = GetFileAttributes(copypath);\n\t\t\t\t\t\t\t\t\tSetFileAttributes(copypath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);\n\t\t\t\t\t\t\t\t\tbOk = !!CopyFile( netpath, copypath, FALSE );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (bOk)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// clear this handle and setup for re-opening of the new local copy...\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tbFasterToReOpenUsingNewLocalFile = qtrue;\n\t\t\t\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\t\t\t\tfsh[*file].handleFiles.file.o = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (bFasterToReOpenUsingNewLocalFile)\n\t\t\t\t{\n\t\t\t\t\tbreak;\t// and re-read the local copy, not the net version\n\t\t\t\t}\n\n\t\t\t\treturn FS_fplength(fsh[*file].handleFiles.file.o);\n\t\t\t}\n\t\t}\n\t}\n\twhile ( bFasterToReOpenUsingNewLocalFile );\n\n\tCom_DPrintf (\"Can't find %s\\n\", filename);\n\t*file = 0;\n\treturn -1;\n}\n\n/*\n=================\nFS_Read\n\nProperly handles partial reads\n=================\n*/\nint FS_Read( void *buffer, int len, fileHandle_t f ) {\n\tint\t\tblock, remaining;\n\tint\t\tread;\n\tbyte\t*buf;\n\tint\t\ttries;\n\n\tFS_AssertInitialised();\n\n\tif ( !f ) {\n\t\treturn 0;\n\t}\n\n\tbuf = (byte *)buffer;\n\tfs_readCount += len;\n\n\tif (fsh[f].zipFile == qfalse) {\n\t\tremaining = len;\n\t\ttries = 0;\n\t\twhile (remaining) {\n\t\t\tblock = remaining;\n\t\t\tread = fread (buf, 1, block, fsh[f].handleFiles.file.o);\n\t\t\tif (read == 0) {\n\t\t\t\t// we might have been trying to read from a CD, which\n\t\t\t\t// sometimes returns a 0 read on windows\n\t\t\t\tif (!tries) {\n\t\t\t\t\ttries = 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn len-remaining;\t//Com_Error (ERR_FATAL, \"FS_Read: 0 bytes read\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tCom_Error (ERR_FATAL, \"FS_Read: -1 bytes read\");\n\t\t\t}\n\n\t\t\tremaining -= read;\n\t\t\tbuf += read;\n\t\t}\n\t\treturn len;\n\t} else {\n\t\treturn unzReadCurrentFile(fsh[f].handleFiles.file.z, buffer, len);\n\t}\n}\n\n/*\n=================\nFS_Write\n\nProperly handles partial writes\n=================\n*/\nint FS_Write( const void *buffer, int len, fileHandle_t h ) {\n\tint\t\tblock, remaining;\n\tint\t\twritten;\n\tbyte\t*buf;\n\tint\t\ttries;\n\tFILE\t*f;\n\n\tFS_AssertInitialised();\n\n\tif ( !h ) {\n\t\treturn 0;\n\t}\n\n\tf = FS_FileForHandle(h);\n\tbuf = (byte *)buffer;\n\n\tremaining = len;\n\ttries = 0;\n\twhile (remaining) {\n\t\tblock = remaining;\n\t\twritten = fwrite (buf, 1, block, f);\n\t\tif (written == 0) {\n\t\t\tif (!tries) {\n\t\t\t\ttries = 1;\n\t\t\t} else {\n\t\t\t\tCom_Printf( \"FS_Write: 0 bytes written\\n\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (written == -1) {\n\t\t\tCom_Printf( \"FS_Write: -1 bytes written\\n\" );\n\t\t\treturn 0;\n\t\t}\n\n\t\tremaining -= written;\n\t\tbuf += written;\n\t}\n\tif ( fsh[h].handleSync ) {\n\t\tfflush( f );\n\t}\n\treturn len;\n}\n\n#define\tMAXPRINTMSG\t4096\nvoid QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf (msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tFS_Write(msg, strlen(msg), h);\n}\n\n#define PK3_SEEK_BUFFER_SIZE 65536\n/*\n=================\nFS_Seek\n\n=================\n*/\nint FS_Seek( fileHandle_t f, long offset, int origin ) {\n\tint\t\t_origin;\n\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\t//FIXME: this is really, really crappy\n\t\t//(but better than what was here before)\n\t\tbyte\tbuffer[PK3_SEEK_BUFFER_SIZE];\n\t\tint\t\tremainder;\n\t\tint\t\tcurrentPosition = FS_FTell( f );\n\n\t\t// change negative offsets into FS_SEEK_SET\n\t\tif ( offset < 0 ) {\n\t\t\tswitch( origin ) {\n\t\t\t\tcase FS_SEEK_END:\n\t\t\t\t\tremainder = fsh[f].zipFileLen + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_CUR:\n\t\t\t\t\tremainder = currentPosition + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_SET:\n\t\t\t\tdefault:\n\t\t\t\t\tremainder = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( remainder < 0 ) {\n\t\t\t\tremainder = 0;\n\t\t\t}\n\n\t\t\torigin = FS_SEEK_SET;\n\t\t} else {\n\t\t\tif ( origin == FS_SEEK_END ) {\n\t\t\t\tremainder = fsh[f].zipFileLen - currentPosition + offset;\n\t\t\t} else {\n\t\t\t\tremainder = offset;\n\t\t\t}\n\t\t}\n\n\t\tswitch( origin ) {\n\t\t\tcase FS_SEEK_SET:\n\t\t\t\tif ( remainder == currentPosition ) {\n\t\t\t\t\treturn offset;\n\t\t\t\t}\n\t\t\t\tunzSetOffset(fsh[f].handleFiles.file.z, fsh[f].zipFilePos);\n\t\t\t\tunzOpenCurrentFile(fsh[f].handleFiles.file.z);\n\t\t\t\t//fallthrough\n\n\t\t\tcase FS_SEEK_END:\n\t\t\tcase FS_SEEK_CUR:\n\t\t\t\twhile( remainder > PK3_SEEK_BUFFER_SIZE ) {\n\t\t\t\t\tFS_Read( buffer, PK3_SEEK_BUFFER_SIZE, f );\n\t\t\t\t\tremainder -= PK3_SEEK_BUFFER_SIZE;\n\t\t\t\t}\n\t\t\t\tFS_Read( buffer, remainder, f );\n\t\t\t\treturn offset;\n\n\t\t\tdefault:\n\t\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\" );\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tFILE *file;\n\t\tfile = FS_FileForHandle(f);\n\t\tswitch( origin ) {\n\t\tcase FS_SEEK_CUR:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tbreak;\n\t\tcase FS_SEEK_END:\n\t\t\t_origin = SEEK_END;\n\t\t\tbreak;\n\t\tcase FS_SEEK_SET:\n\t\t\t_origin = SEEK_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\\n\" );\n\t\t\tbreak;\n\t\t}\n\n\t\treturn fseek( file, offset, _origin );\n\t}\n}\n\n/*\n======================================================================================\n\nCONVENIENCE FUNCTIONS FOR ENTIRE FILES\n\n======================================================================================\n*/\n\nint\tFS_FileIsInPAK(const char *filename ) {\n\tsearchpath_t\t*search;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tlong\t\t\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t//\n\t\tif (search->pack) {\n\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t}\n\t\t// is the element a pak file?\n\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tpakFile = pak->hashTable[hash];\n\t\t\tdo {\n\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpakFile = pakFile->next;\n\t\t\t} while(pakFile != NULL);\n\t\t}\n\t}\n\treturn -1;\n}\n\n/*\n============\nFS_ReadFile\n\nFilename are relative to the quake search path\na null buffer will just return the file length without loading\n============\n*/\nlong FS_ReadFile( const char *qpath, void **buffer ) {\n\tfileHandle_t\th;\n\tbyte*\t\t\tbuf;\n\tlong\t\t\t\tlen;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !qpath[0] ) {\n\t\tCom_Error( ERR_FATAL, \"FS_ReadFile with empty name\\n\" );\n\t}\n\n\t// stop sounds from repeating\n\tS_ClearSoundBuffer();\n\n\tbuf = NULL;\t// quiet compiler warning\n\n\t// look for it in the filesystem or pack files\n\tlen = FS_FOpenFileRead( qpath, &h, qfalse );\n\tif ( h == 0 ) {\n\t\tif ( buffer ) {\n\t\t\t*buffer = NULL;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( !buffer ) {\n\t\tFS_FCloseFile( h);\n\t\treturn len;\n\t}\n\n\tfs_loadCount++;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\tbuf[len]='\\0';\t// because we're not calling Z_Malloc with optional trailing 'bZeroIt' bool\n\t*buffer = buf;\n\n\tZ_Label(buf, qpath);\n\n\t// PRECACE CHECKER!\n#ifndef FINAL_BUILD\n\tif (com_sv_running && com_sv_running->integer && cls.state >= CA_ACTIVE) {\t//com_cl_running\n\t\tif (strncmp(qpath,\"menu/\",5) ) {\n\t\t\tCom_DPrintf( S_COLOR_MAGENTA\"FS_ReadFile: %s NOT PRECACHED!\\n\", qpath );\n\t\t}\n\t}\n#endif\n\n\tFS_Read (buf, len, h);\n\n\t// guarantee that it will have a trailing 0 for string operations\n\tbuf[len] = 0;\n\tFS_FCloseFile( h );\n\treturn len;\n}\n\n/*\n=============\nFS_FreeFile\n=============\n*/\nvoid FS_FreeFile( void *buffer ) {\n\tFS_AssertInitialised();\n\tif ( !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FreeFile( NULL )\" );\n\t}\n\n\tZ_Free( buffer );\n}\n\n/*\n============\nFS_WriteFile\n\nFilename are reletive to the quake search path\n============\n*/\nvoid FS_WriteFile( const char *qpath, const void *buffer, int size ) {\n\tfileHandle_t f;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_WriteFile: NULL parameter\" );\n\t}\n\n\tf = FS_FOpenFileWrite( qpath );\n\tif ( !f ) {\n\t\tCom_Printf( \"Failed to open %s\\n\", qpath );\n\t\treturn;\n\t}\n\n\tFS_Write( buffer, size, f );\n\n\tFS_FCloseFile( f );\n}\n\n/*\n==========================================================================\n\nZIP FILE LOADING\n\n==========================================================================\n*/\n\n/*\n=================\nFS_LoadZipFile\n\nCreates a new pak_t in the search chain for the contents\nof a zip file.\n=================\n*/\nstatic pack_t *FS_LoadZipFile( const char *zipfile, const char *basename )\n{\n\tfileInPack_t\t*buildBuffer;\n\tpack_t\t\t\t*pack;\n\tunzFile\t\t\tuf;\n\tint\t\t\t\terr;\n\tunz_global_info gi;\n\tchar\t\t\tfilename_inzip[MAX_ZPATH];\n\tunz_file_info\tfile_info;\n\tint\t\t\t\tlen;\n\tsize_t\t\t\ti;\n\tlong\t\t\thash;\n\tint\t\t\t\tfs_numHeaderLongs;\n\tint\t\t\t\t*fs_headerLongs;\n\tchar\t\t\t*namePtr;\n\n\tfs_numHeaderLongs = 0;\n\n\tuf = unzOpen(zipfile);\n\terr = unzGetGlobalInfo (uf,&gi);\n\n\tif (err != UNZ_OK)\n\t\treturn NULL;\n\n\tlen = 0;\n\tunzGoToFirstFile(uf);\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tlen += strlen(filename_inzip) + 1;\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tbuildBuffer = (struct fileInPack_s *)Z_Malloc( (gi.number_entry * sizeof( fileInPack_t )) + len, TAG_FILESYS, qtrue );\n\tnamePtr = ((char *) buildBuffer) + gi.number_entry * sizeof( fileInPack_t );\n\tfs_headerLongs = (int *)Z_Malloc( gi.number_entry * sizeof(int), TAG_FILESYS, qtrue );\n\n\t// get the hash table size from the number of files in the zip\n\t// because lots of custom pk3 files have less than 32 or 64 files\n\tfor (i = 1; i <= MAX_FILEHASH_SIZE; i <<= 1) {\n\t\tif (i > gi.number_entry) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpack = (pack_t *)Z_Malloc( sizeof( pack_t ) + i * sizeof(fileInPack_t *), TAG_FILESYS, qtrue );\n\tpack->hashSize = i;\n\tpack->hashTable = (fileInPack_t **) (((char *) pack) + sizeof( pack_t ));\n\tfor(int j = 0; j < pack->hashSize; j++) {\n\t\tpack->hashTable[j] = NULL;\n\t}\n\n\tQ_strncpyz( pack->pakFilename, zipfile, sizeof( pack->pakFilename ) );\n\tQ_strncpyz( pack->pakBasename, basename, sizeof( pack->pakBasename ) );\n\n\t// strip .pk3 if needed\n\tif ( strlen( pack->pakBasename ) > 4 && !Q_stricmp( pack->pakBasename + strlen( pack->pakBasename ) - 4, \".pk3\" ) ) {\n\t\tpack->pakBasename[strlen( pack->pakBasename ) - 4] = 0;\n\t}\n\n\tpack->handle = uf;\n\tpack->numfiles = gi.number_entry;\n\tunzGoToFirstFile(uf);\n\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tif (file_info.uncompressed_size > 0) {\n\t\t\tfs_headerLongs[fs_numHeaderLongs++] = LittleLong(file_info.crc);\n\t\t}\n\t\tQ_strlwr( filename_inzip );\n\t\thash = FS_HashFileName(filename_inzip, pack->hashSize);\n\t\tbuildBuffer[i].name = namePtr;\n\t\tstrcpy( buildBuffer[i].name, filename_inzip );\n\t\tnamePtr += strlen(filename_inzip) + 1;\n\t\t// store the file position in the zip\n\t\tbuildBuffer[i].pos = unzGetOffset(uf);\n\t\tbuildBuffer[i].len = file_info.uncompressed_size;\n\t\tbuildBuffer[i].next = pack->hashTable[hash];\n\t\tpack->hashTable[hash] = &buildBuffer[i];\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tpack->checksum = Com_BlockChecksum( fs_headerLongs, sizeof(*fs_headerLongs) * fs_numHeaderLongs );\n\tpack->checksum = LittleLong( pack->checksum );\n\n\tZ_Free(fs_headerLongs);\n\n\tpack->buildBuffer = buildBuffer;\n\treturn pack;\n}\n\n/*\n=================\nFS_FreePak\n\nFrees a pak structure and releases all associated resources\n=================\n*/\n\nvoid FS_FreePak(pack_t *thepak)\n{\n\tunzClose(thepak->handle);\n\tZ_Free(thepak->buildBuffer);\n\tZ_Free(thepak);\n}\n\n/*\n=================================================================================\n\nDIRECTORY SCANNING FUNCTIONS\n\n=================================================================================\n*/\n\n#define\tMAX_FOUND_FILES\t0x1000\n\nstatic int FS_ReturnPath( const char *zname, char *zpath, int *depth ) {\n\tint len, at, newdep;\n\n\tnewdep = 0;\n\tzpath[0] = 0;\n\tlen = 0;\n\tat = 0;\n\n\twhile(zname[at] != 0)\n\t{\n\t\tif (zname[at]=='/' || zname[at]=='\\\\') {\n\t\t\tlen = at;\n\t\t\tnewdep++;\n\t\t}\n\t\tat++;\n\t}\n\tstrcpy(zpath, zname);\n\tzpath[len] = 0;\n\t*depth = newdep;\n\n\treturn len;\n}\n\n/*\n==================\nFS_AddFileToList\n==================\n*/\nstatic int FS_AddFileToList( char *name, char *list[MAX_FOUND_FILES], int nfiles ) {\n\tint\t\ti;\n\n\tif ( nfiles == MAX_FOUND_FILES - 1 ) {\n\t\treturn nfiles;\n\t}\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tif ( !Q_stricmp( name, list[i] ) ) {\n\t\t\treturn nfiles;\t\t// allready in list\n\t\t}\n\t}\n\tlist[nfiles] = CopyString( name );\n\tnfiles++;\n\n\treturn nfiles;\n}\n\n/*\n===============\nFS_ListFilteredFiles\n\nReturns a uniqued list of files that match the given criteria\nfrom all search paths\n===============\n*/\nchar **FS_ListFilteredFiles( const char *path, const char *extension, char *filter, int *numfiles ) {\n\tint\t\t\t\tnfiles;\n\tchar\t\t\t**listCopy;\n\tchar\t\t\t*list[MAX_FOUND_FILES];\n\tsearchpath_t\t*search;\n\tint\t\t\t\ti;\n\tint\t\t\t\tpathLength;\n\tint\t\t\t\textensionLength;\n\tint\t\t\t\tlength, pathDepth, temp;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*buildBuffer;\n\tchar\t\t\tzpath[MAX_ZPATH];\n\n\tFS_AssertInitialised();\n\n\tif ( !path ) {\n\t\t*numfiles = 0;\n\t\treturn NULL;\n\t}\n\tif ( !extension ) {\n\t\textension = \"\";\n\t}\n\n\tpathLength = strlen( path );\n\tif ( path[pathLength-1] == '\\\\' || path[pathLength-1] == '/' ) {\n\t\tpathLength--;\n\t}\n\textensionLength = strlen( extension );\n\tnfiles = 0;\n\tFS_ReturnPath(path, zpath, &pathDepth);\n\n\t//\n\t// search through the path, one element at a time, adding to list\n\t//\n\tfor (search = fs_searchpaths ; search ; search = search->next) {\n\t\t// is the element a pak file?\n\t\tif (search->pack) {\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tbuildBuffer = pak->buildBuffer;\n\t\t\tfor (i = 0; i < pak->numfiles; i++) {\n\t\t\t\tchar\t*name;\n\t\t\t\tint\t\tzpathLen, depth;\n\n\t\t\t\t// check for directory match\n\t\t\t\tname = buildBuffer[i].name;\n\t\t\t\t//\n\t\t\t\tif (filter) {\n\t\t\t\t\t// case insensitive\n\t\t\t\t\tif (!Com_FilterPath( filter, name, qfalse ))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// unique the match\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tzpathLen = FS_ReturnPath(name, zpath, &depth);\n\n\t\t\t\t\tif ( (depth-pathDepth)>2 || pathLength > zpathLen || Q_stricmpn( name, path, pathLength ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for extension match\n\t\t\t\t\tlength = strlen( name );\n\t\t\t\t\tif ( length < extensionLength ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Q_stricmp( name + length - extensionLength, extension ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// unique the match\n\n\t\t\t\t\ttemp = pathLength;\n\t\t\t\t\tif (pathLength) {\n\t\t\t\t\t\ttemp++;\t\t// include the '/'\n\t\t\t\t\t}\n\t\t\t\t\tnfiles = FS_AddFileToList( name + temp, list, nfiles );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (search->dir) { // scan for files in the filesystem\n\t\t\tchar\t*netpath;\n\t\t\tint\t\tnumSysFiles;\n\t\t\tchar\t**sysFiles;\n\t\t\tchar\t*name;\n\n\t\t\tnetpath = FS_BuildOSPath( search->dir->path, search->dir->gamedir, path );\n\t\t\tsysFiles = Sys_ListFiles( netpath, extension, filter, &numSysFiles, qfalse );\n\t\t\tfor ( i = 0 ; i < numSysFiles ; i++ ) {\n\t\t\t\t// unique the match\n\t\t\t\tname = sysFiles[i];\n\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t}\n\t\t\tSys_FreeFileList( sysFiles );\n\t\t}\n\t}\n\n\t// return a copy of the list\n\t*numfiles = nfiles;\n\n\tif ( !nfiles ) {\n\t\treturn NULL;\n\t}\n\n\tlistCopy = (char **)Z_Malloc( ( nfiles + 1 ) * sizeof( *listCopy ), TAG_FILESYS, qfalse );\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tlistCopy[i] = list[i];\n\t}\n\tlistCopy[i] = NULL;\n\n\treturn listCopy;\n}\n\n/*\n=================\nFS_ListFiles\n=================\n*/\nchar **FS_ListFiles( const char *path, const char *extension, int *numfiles ) {\n\treturn FS_ListFilteredFiles( path, extension, NULL, numfiles );\n}\n\n/*\n=================\nFS_FreeFileList\n=================\n*/\nvoid FS_FreeFileList( char **fileList ) {\n\t//rwwRMG - changed to fileList to not conflict with list type\n\tint\t\ti;\n\n\tFS_AssertInitialised();\n\n\tif ( !fileList ) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; fileList[i] ; i++ ) {\n\t\tZ_Free( fileList[i] );\n\t}\n\n\tZ_Free( fileList );\n}\n\n\n/*\n================\nFS_GetFileList\n================\n*/\nint\tFS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {\n\tint\t\tnFiles, i, nTotal, nLen;\n\tchar **pFiles = NULL;\n\n\t*listbuf = 0;\n\tnFiles = 0;\n\tnTotal = 0;\n\n\tif (Q_stricmp(path, \"$modlist\") == 0) {\n\t\treturn FS_GetModList(listbuf, bufsize);\n\t}\n\n\tpFiles = FS_ListFiles(path, extension, &nFiles);\n\n\tfor (i =0; i < nFiles; i++) {\n\t\tnLen = strlen(pFiles[i]) + 1;\n\t\tif (nTotal + nLen + 1 < bufsize) {\n\t\t\tstrcpy(listbuf, pFiles[i]);\n\t\t\tlistbuf += nLen;\n\t\t\tnTotal += nLen;\n\t\t}\n\t\telse {\n\t\t\tnFiles = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFS_FreeFileList(pFiles);\n\n\treturn nFiles;\n}\n\n/*\n=======================\nSys_ConcatenateFileLists\n\nmkv: Naive implementation. Concatenates three lists into a\n     new list, and frees the old lists from the heap.\nbk001129 - from cvs1.17 (mkv)\n\nFIXME TTimo those two should move to common.c next to Sys_ListFiles\n=======================\n */\nstatic unsigned int Sys_CountFileList(char **fileList)\n{\n\tint i = 0;\n\n\tif (fileList)\n\t{\n\t\twhile (*fileList)\n\t\t{\n\t\t\tfileList++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic char** Sys_ConcatenateFileLists( char **list0, char **list1, char **list2 )\n{\n\tint totalLength = 0;\n\tchar** cat = NULL, **dst, **src;\n\n\ttotalLength += Sys_CountFileList(list0);\n\ttotalLength += Sys_CountFileList(list1);\n\ttotalLength += Sys_CountFileList(list2);\n\n\t/* Create new list. */\n\tdst = cat = (char **)Z_Malloc( ( totalLength + 1 ) * sizeof( char* ), TAG_FILESYS, qtrue );\n\n\t/* Copy over lists. */\n\tif (list0) {\n\t\tfor (src = list0; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list1) {\n\t\tfor (src = list1; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list2) {\n\t\tfor (src = list2; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\n\t// Terminate the list\n\t*dst = NULL;\n\n\t// Free our old lists.\n\t// NOTE: not freeing their content, it's been merged in dst and still being used\n\tif (list0) Z_Free( list0 );\n\tif (list1) Z_Free( list1 );\n\tif (list2) Z_Free( list2 );\n\n\treturn cat;\n}\n//#endif\n\n// For base game mod listing\nconst char *SE_GetString( const char *psPackageAndStringReference );\n\n/*\n================\nFS_GetModList\n\nReturns a list of mod directory names\nA mod directory is a peer to base with a pk3 in it\nThe directories are searched in base path, cd path and home path\n================\n*/\nint\tFS_GetModList( char *listbuf, int bufsize ) {\n\tint\t\tnMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;\n\tchar **pFiles = NULL;\n\tchar **pPaks = NULL;\n\tchar *name, *path;\n\tchar descPath[MAX_OSPATH];\n\tfileHandle_t descHandle;\n\n\tint dummy;\n\tchar **pFiles0 = NULL;\n\tchar **pFiles1 = NULL;\n\tchar **pFiles2 = NULL;\n\tqboolean bDrop = qfalse;\n\n\t*listbuf = 0;\n\tnMods = nPotential = nTotal = 0;\n\n\tpFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles2 = Sys_ListFiles( fs_cdpath->string, NULL, NULL, &dummy, qtrue );\n\t// we searched for mods in the three paths\n\t// it is likely that we have duplicate names now, which we will cleanup below\n\tpFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1, pFiles2 );\n\tnPotential = Sys_CountFileList(pFiles);\n\n\tfor ( i = 0 ; i < nPotential ; i++ ) {\n\t\tname = pFiles[i];\n\t\t// NOTE: cleaner would involve more changes\n\t\t// ignore duplicate mod directories\n\t\tif (i!=0) {\n\t\t\tbDrop = qfalse;\n\t\t\tfor(j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif (Q_stricmp(pFiles[j],name)==0) {\n\t\t\t\t\t// this one can be dropped\n\t\t\t\t\tbDrop = qtrue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bDrop) {\n\t\t\tcontinue;\n\t\t}\n\t\t// we drop \".\" and \"..\"\n\t\tif (Q_stricmpn(name, \".\", 1)) {\n\t\t\t// now we need to find some .pk3 files to validate the mod\n\t\t\t// NOTE TTimo: (actually I'm not sure why .. what if it's a mod under developement with no .pk3?)\n\t\t\t// we didn't keep the information when we merged the directory names, as to what OS Path it was found under\n\t\t\t//   so it could be in base path, cd path or home path\n\t\t\t//   we will try each three of them here (yes, it's a bit messy)\n\t\t\tpath = FS_BuildOSPath( fs_basepath->string, name, \"\" );\n\t\t\tnPaks = 0;\n\t\t\tpPaks = Sys_ListFiles(path, \".pk3\", NULL, &nPaks, qfalse);\n\t\t\tSys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present\n\n\t\t\t/* Try on cd path */\n\t\t\tif( nPaks <= 0 ) {\n\t\t\t\tpath = FS_BuildOSPath( fs_cdpath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\t/* try on home path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_homepath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\tif (nPaks > 0) {\n\t\t\t\tbool isBase = !Q_stricmp( name, BASEGAME );\n\t\t\t\tnLen = isBase ? 1 : strlen(name) + 1;\n\t\t\t\t// nLen is the length of the mod path\n\t\t\t\t// we need to see if there is a description available\n\t\t\t\tdescPath[0] = '\\0';\n\t\t\t\tstrcpy(descPath, name);\n\t\t\t\tstrcat(descPath, \"/description.txt\");\n\t\t\t\tnDescLen = FS_SV_FOpenFileRead( descPath, &descHandle );\n\t\t\t\tif ( nDescLen > 0 && descHandle) {\n\t\t\t\t\tFILE *file;\n\t\t\t\t\tfile = FS_FileForHandle(descHandle);\n\t\t\t\t\tCom_Memset( descPath, 0, sizeof( descPath ) );\n\t\t\t\t\tnDescLen = fread(descPath, 1, 48, file);\n\t\t\t\t\tif (nDescLen >= 0) {\n\t\t\t\t\t\tdescPath[nDescLen] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tFS_FCloseFile(descHandle);\n\t\t\t\t} else if ( isBase ) {\n\t\t\t\t\tstrcpy(descPath, SE_GetString(\"MENUS_JEDI_ACADEMY\"));\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(descPath, name);\n\t\t\t\t}\n\t\t\t\tnDescLen = strlen(descPath) + 1;\n\n\t\t\t\tif (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {\n\t\t\t\t\tif ( isBase )\n\t\t\t\t\t\tstrcpy(listbuf, \"\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(listbuf, name);\n\t\t\t\t\tlistbuf += nLen;\n\t\t\t\t\tstrcpy(listbuf, descPath);\n\t\t\t\t\tlistbuf += nDescLen;\n\t\t\t\t\tnTotal += nLen + nDescLen;\n\t\t\t\t\tnMods++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSys_FreeFileList( pFiles );\n\n\treturn nMods;\n}\n\n//============================================================================\n\n/*\n================\nFS_Dir_f\n================\n*/\nvoid FS_Dir_f( void ) {\n\tchar\t*path;\n\tchar\t*extension;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {\n\t\tCom_Printf( \"usage: dir <directory> [extension]\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = \"\";\n\t} else {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = Cmd_Argv( 2 );\n\t}\n\n\tCom_Printf( \"Directory of %s %s\\n\", path, extension );\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFiles( path, extension, &ndirs );\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n===========\nFS_ConvertPath\n===========\n*/\nvoid FS_ConvertPath( char *s ) {\n\twhile (*s) {\n\t\tif ( *s == '\\\\' || *s == ':' ) {\n\t\t\t*s = '/';\n\t\t}\n\t\ts++;\n\t}\n}\n\n/*\n===========\nFS_PathCmp\n\nIgnore case and separator char distinctions\n===========\n*/\nint FS_PathCmp( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 < c2) {\n\t\t\treturn -1;\t\t// strings not equal\n\t\t}\n\t\tif (c1 > c2) {\n\t\t\treturn 1;\n\t\t}\n\t} while (c1);\n\n\treturn 0;\t\t// strings are equal\n}\n\n/*\n================\nFS_SortFileList\n================\n*/\nvoid FS_SortFileList(char **filelist, int numfiles) {\n\tint i, j, k, numsortedfiles;\n\tchar **sortedlist;\n\n\tsortedlist = (char **)Z_Malloc( ( numfiles + 1 ) * sizeof( *sortedlist ), TAG_FILESYS, qtrue );\n\tsortedlist[0] = NULL;\n\tnumsortedfiles = 0;\n\tfor (i = 0; i < numfiles; i++) {\n\t\tfor (j = 0; j < numsortedfiles; j++) {\n\t\t\tif (FS_PathCmp(filelist[i], sortedlist[j]) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (k = numsortedfiles; k > j; k--) {\n\t\t\tsortedlist[k] = sortedlist[k-1];\n\t\t}\n\t\tsortedlist[j] = filelist[i];\n\t\tnumsortedfiles++;\n\t}\n\tCom_Memcpy(filelist, sortedlist, numfiles * sizeof( *filelist ) );\n\tZ_Free(sortedlist);\n}\n\n/*\n================\nFS_NewDir_f\n================\n*/\nvoid FS_NewDir_f( void ) {\n\tchar\t*filter;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 ) {\n\t\tCom_Printf( \"usage: fdir <filter>\\n\" );\n\t\tCom_Printf( \"example: fdir *t1*.bsp\\n\");\n\t\treturn;\n\t}\n\n\tfilter = Cmd_Argv( 1 );\n\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFilteredFiles( \"\", \"\", filter, &ndirs );\n\n\tFS_SortFileList(dirnames, ndirs);\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tFS_ConvertPath(dirnames[i]);\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tCom_Printf( \"%d files listed\\n\", ndirs );\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n============\nFS_Path_f\n\n============\n*/\nvoid FS_Path_f( void ) {\n\tsearchpath_t\t*s;\n\tint\t\t\t\ti;\n\n\tCom_Printf (\"Current search path:\\n\");\n\tfor (s = fs_searchpaths; s; s = s->next) {\n\t\tif (s->pack) {\n\t\t\tCom_Printf (\"%s (%i files)\\n\", s->pack->pakFilename, s->pack->numfiles);\n\t\t} else {\n\t\t\tCom_Printf (\"%s%c%s\\n\", s->dir->path, PATH_SEP, s->dir->gamedir );\n\t\t}\n\t}\n\n\tCom_Printf( \"\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o ) {\n\t\t\tCom_Printf( \"handle %i: %s\\n\", i, fsh[i].name );\n\t\t}\n\t}\n}\n\n/*\n============\nFS_TouchFile_f\n\nThe only purpose of this function is to allow game script files to copy\narbitrary files furing an \"fs_copyfiles 1\" run.\n============\n*/\nvoid FS_TouchFile_f( void ) {\n\tfileHandle_t\tf;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"Usage: touchFile <file>\\n\" );\n\t\treturn;\n\t}\n\n\tFS_FOpenFileRead( Cmd_Argv( 1 ), &f, qfalse );\n\tif ( f ) {\n\t\tFS_FCloseFile( f );\n\t}\n}\n\n/*\n============\nFS_Which_f\n============\n*/\nvoid FS_Which_f( void ) {\n\tsearchpath_t\t*search;\n\tchar\t\t*filename;\n\n\tfilename = Cmd_Argv(1);\n\n\tif ( !filename[0] ) {\n\t\tCom_Printf( \"Usage: which <file>\\n\" );\n\t\treturn;\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn;\n\t}\n\n\t// just wants to see if file is there\n\tfor ( search=fs_searchpaths; search; search=search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tlong hash = FS_HashFileName( filename, search->pack->hashSize );\n\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack->hashTable[hash]) {\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpack_t* pak = search->pack;\n\t\t\t\tfileInPack_t* pakFile = pak->hashTable[hash];\n\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\t\t\t\t\t\tCom_Printf( \"File \\\"%s\\\" found in \\\"%s\\\"\\n\", filename, pak->pakFilename );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while ( pakFile != NULL );\n\t\t\t}\n\t\t} else if (search->dir) {\n\t\t\tdirectory_t* dir = search->dir;\n\n\t\t\tchar* netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\tFILE* filep = fopen(netpath, \"rb\");\n\n\t\t\tif ( filep ) {\n\t\t\t\tfclose( filep );\n\n\t\t\t\tchar buf[MAX_OSPATH];\n\t\t\t\tCom_sprintf( buf, sizeof( buf ), \"%s%c%s\", dir->path, PATH_SEP, dir->gamedir );\n\t\t\t\tFS_ReplaceSeparators( buf );\n\t\t\t\tCom_Printf( \"File \\\"%s\\\" found at \\\"%s\\\"\\n\", filename, buf );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tCom_Printf( \"File not found: \\\"%s\\\"\\n\", filename );\n}\n\n//===========================================================================\n\nstatic int QDECL paksort( const void *a, const void *b ) {\n\tchar\t*aa, *bb;\n\n\taa = *(char **)a;\n\tbb = *(char **)b;\n\n\treturn FS_PathCmp( aa, bb );\n}\n\n/*\n================\nFS_AddGameDirectory\n\nSets fs_gamedir, adds the directory to the head of the path,\nthen loads the zip headers\n================\n*/\n#define\tMAX_PAKFILES\t1024\nstatic void FS_AddGameDirectory( const char *path, const char *dir ) {\n\tsearchpath_t\t*sp;\n\tint\t\t\t\ti;\n\tsearchpath_t\t*search;\n\tsearchpath_t\t*thedir;\n\tpack_t\t\t\t*pak;\n\tchar\t\t\tcurpath[MAX_OSPATH + 1], *pakfile;\n\tint\t\t\t\tnumfiles;\n\tchar\t\t\t**pakfiles;\n\tchar\t\t\t*sorted[MAX_PAKFILES];\n\n\t// this fixes the case where fs_basepath is the same as fs_cdpath\n\t// which happens on full installs\n\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\t// TODO Sys_PathCmp SDL-Port will contain this for SP as well\n\t\t// Should be Sys_PathCmp(sp->dir->path, path)\n\t\tif ( sp->dir && !Q_stricmp(sp->dir->path, path) && !Q_stricmp(sp->dir->gamedir, dir)) {\n\t\t\treturn;\t\t\t// we've already got this one\n\t\t}\n\t}\n\n\tQ_strncpyz( fs_gamedir, dir, sizeof( fs_gamedir ) );\n\n\t// find all pak files in this directory\n\tQ_strncpyz(curpath, FS_BuildOSPath(path, dir, \"\"), sizeof(curpath));\n\tcurpath[strlen(curpath) - 1] = '\\0';\t// strip the trailing slash\n\n\t//\n\t// add the directory to the search path\n\t//\n\tsearch = (struct searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\tsearch->dir = (directory_t *)Z_Malloc( sizeof( *search->dir ), TAG_FILESYS, qtrue );\n\n\tQ_strncpyz( search->dir->path, path, sizeof( search->dir->path ) );\n\tQ_strncpyz( search->dir->fullpath, curpath, sizeof( search->dir->fullpath ) );\n\tQ_strncpyz( search->dir->gamedir, dir, sizeof( search->dir->gamedir ) );\n\tsearch->next = fs_searchpaths;\n\tfs_searchpaths = search;\n\n\tthedir = search;\n\n\tpakfiles = Sys_ListFiles( curpath, \".pk3\", NULL, &numfiles, qfalse );\n\n\t// sort them so that later alphabetic matches override\n\t// earlier ones.  This makes pak1.pk3 override pak0.pk3\n\tif ( numfiles > MAX_PAKFILES ) {\n\t\tnumfiles = MAX_PAKFILES;\n\t}\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tsorted[i] = pakfiles[i];\n\t}\n\n\tqsort( sorted, numfiles, sizeof(char*), paksort );\n\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tpakfile = FS_BuildOSPath( path, dir, sorted[i] );\n\t\tif ( ( pak = FS_LoadZipFile( pakfile, sorted[i] ) ) == 0 )\n\t\t\tcontinue;\n\t\tQ_strncpyz(pak->pakPathname, curpath, sizeof(pak->pakPathname));\n\t\t// store the game name for downloading\n\t\tQ_strncpyz(pak->pakGamename, dir, sizeof(pak->pakGamename));\n\n\t\tfs_packFiles += pak->numfiles;\n\n\t\tsearch = (searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\t\tsearch->pack = pak;\n\n\t\tif (fs_dirbeforepak && fs_dirbeforepak->integer && thedir)\n\t\t{\n\t\t\tsearchpath_t *oldnext = thedir->next;\n\t\t\tthedir->next = search;\n\n\t\t\twhile (oldnext)\n\t\t\t{\n\t\t\t\tsearch->next = oldnext;\n\t\t\t\tsearch = search->next;\n\t\t\t\toldnext = oldnext->next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsearch->next = fs_searchpaths;\n\t\t\tfs_searchpaths = search;\n\t\t}\n\t}\n\n\t// done\n\tSys_FreeFileList( pakfiles );\n}\n\n/*\n================\nFS_CheckDirTraversal\n\nCheck whether the string contains stuff like \"../\" to prevent directory traversal bugs\nand return qtrue if it does.\n================\n*/\n\nqboolean FS_CheckDirTraversal(const char *checkdir)\n{\n\tif(strstr(checkdir, \"../\") || strstr(checkdir, \"..\\\\\"))\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_Shutdown\n\nFrees all resources and closes all files\n================\n*/\nvoid FS_Shutdown( void ) {\n\tsearchpath_t\t*p, *next;\n\tint\ti;\n\n\tfor(i = 0; i < MAX_FILE_HANDLES; i++) {\n\t\tif (fsh[i].fileSize) {\n\t\t\tFS_FCloseFile(i);\n\t\t}\n\t}\n\n\t// free everything\n\tfor ( p = fs_searchpaths ; p ; p = next ) {\n\t\tnext = p->next;\n\n\t\tif ( p->pack ) {\n\t\t\tFS_FreePak( p->pack );\n\t\t}\n\t\tif ( p->dir ) {\n\t\t\tZ_Free( p->dir );\n\t\t}\n\t\tZ_Free( p );\n\t}\n\n\t// any FS_ calls will now be an error until reinitialized\n\tfs_searchpaths = NULL;\n\n\tCmd_RemoveCommand( \"path\" );\n\tCmd_RemoveCommand( \"dir\" );\n\tCmd_RemoveCommand( \"fdir\" );\n\tCmd_RemoveCommand( \"touchFile\" );\n\tCmd_RemoveCommand( \"which\" );\n}\n\n/*\n================\nFS_Startup\n================\n*/\nvoid FS_Startup( const char *gameName ) {\n\tconst char *homePath;\n\n\tCom_Printf( \"----- FS_Startup -----\\n\" );\n\n\tfs_packFiles = 0;\n\n\tfs_debug = Cvar_Get( \"fs_debug\", \"0\", 0 );\n\tfs_copyfiles = Cvar_Get( \"fs_copyfiles\", \"0\", CVAR_INIT );\n\tfs_cdpath = Cvar_Get (\"fs_cdpath\", \"\", CVAR_INIT|CVAR_PROTECTED );\n\tfs_basepath = Cvar_Get (\"fs_basepath\", Sys_DefaultInstallPath(), CVAR_INIT|CVAR_PROTECTED );\n\tfs_basegame = Cvar_Get (\"fs_basegame\", \"\", CVAR_INIT );\n\thomePath = Sys_DefaultHomePath();\n\tif (!homePath || !homePath[0]) {\n\t\thomePath = fs_basepath->string;\n\t}\n\tfs_homepath = Cvar_Get (\"fs_homepath\", homePath, CVAR_INIT|CVAR_PROTECTED );\n\tfs_gamedirvar = Cvar_Get (\"fs_game\", \"\", CVAR_INIT|CVAR_SYSTEMINFO );\n\n\tfs_dirbeforepak = Cvar_Get(\"fs_dirbeforepak\", \"0\", CVAR_INIT|CVAR_PROTECTED);\n\n\t// add search path elements in reverse priority order\n\tif (fs_cdpath->string[0]) {\n\t\tFS_AddGameDirectory( fs_cdpath->string, gameName );\n\t}\n\tif (fs_basepath->string[0]) {\n\t\tFS_AddGameDirectory( fs_basepath->string, gameName );\n\t}\n\n#ifdef MACOS_X\n\tfs_apppath = Cvar_Get (\"fs_apppath\", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED );\n\t// Make MacOSX also include the base path included with the .app bundle\n\tif (fs_apppath->string[0]) {\n\t\tFS_AddGameDirectory( fs_apppath->string, gameName );\n\t}\n#endif\n\n\t// fs_homepath is somewhat particular to *nix systems, only add if relevant\n\t// NOTE: same filtering below for mods and basegame\n\t// TODO Sys_PathCmp see previous comment for why\n\t// !Sys_PathCmp(fs_homepath->string, fs_basepath->string)\n\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\tFS_CreatePath ( fs_homepath->string );\n\t\tFS_AddGameDirectory ( fs_homepath->string, gameName );\n\t}\n\n\t// check for additional base game so mods can be based upon other mods\n\tif ( fs_basegame->string[0] && Q_stricmp( fs_basegame->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_basegame->string);\n\t\t}\n\t}\n\n\t// check for additional game folder for mods\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && Q_stricmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n\n\t// add our commands\n\tCmd_AddCommand (\"path\", FS_Path_f);\n\tCmd_AddCommand (\"dir\", FS_Dir_f );\n\tCmd_AddCommand (\"fdir\", FS_NewDir_f );\n\tCmd_AddCommand (\"touchFile\", FS_TouchFile_f );\n\tCmd_AddCommand (\"which\", FS_Which_f );\n\n\t// print the current search paths\n\tFS_Path_f();\n\n\tfs_gamedirvar->modified = qfalse; // We just loaded, it's not modified\n\n\tCom_Printf( \"----------------------\\n\" );\n\tCom_Printf( \"%d files in pk3 files\\n\", fs_packFiles );\n}\n\n/*\n================\nFS_InitFilesystem\n\nCalled only at inital startup, not when the filesystem\nis resetting due to a game change\n================\n*/\nvoid FS_InitFilesystem( void ) {\n\t// allow command line parms to override our defaults\n\t// we have to specially handle this, because normal command\n\t// line variable sets don't happen until after the filesystem\n\t// has already been initialized\n\tCom_StartupVariable( \"fs_cdpath\" );\n\tCom_StartupVariable( \"fs_basepath\" );\n\tCom_StartupVariable( \"fs_homepath\" );\n\tCom_StartupVariable( \"fs_game\" );\n\tCom_StartupVariable( \"fs_copyfiles\" );\n\tCom_StartupVariable( \"fs_dirbeforepak\" );\n#ifdef MACOS_X\n\tCom_StartupVariable( \"fs_apppath\" );\n#endif\n\n\tconst char *gamedir = Cvar_VariableString(\"fs_game\");\n\tbool requestbase = false;\n\tif ( !FS_FilenameCompare( gamedir, BASEGAME ) )\n\t\trequestbase = true;\n\n\tif ( requestbase )\n\t\tCvar_Set2( \"fs_game\", \"\", qtrue );\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"default.cfg\", NULL ) <= 0 ) {\n\t\tCom_Error( ERR_FATAL, \"Couldn't load default.cfg\" );\n\t\t// bk001208 - SafeMode see below, FIXME?\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n  // bk001208 - SafeMode see below, FIXME?\n}\n\n/*\n================\nFS_Restart\n================\n*/\nvoid FS_Restart( void ) {\n\n\t// free anything we currently have loaded\n\tFS_Shutdown();\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"default.cfg\", NULL ) <= 0 ) {\n\t\t// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3\n\t\t// (for instance a TA demo server)\n\t\tif (lastValidBase[0]) {\n\t\t\tCvar_Set(\"fs_basepath\", lastValidBase);\n\t\t\tCvar_Set(\"fs_game\", lastValidGame);\n\t\t\tlastValidBase[0] = '\\0';\n\t\t\tlastValidGame[0] = '\\0';\n\t\t\tFS_Restart();\n\t\t\tCom_Error( ERR_DROP, \"Invalid game folder\" );\n\t\t\treturn;\n\t\t}\n\t\tCom_Error( ERR_FATAL, \"Couldn't load default.cfg\" );\n\t}\n\n\tif ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {\n\t\t// skip the jaconfig.cfg if \"safe\" is on the command line\n\t\tif ( !Com_SafeMode() ) {\n\t\t\tCbuf_AddText (\"exec \" Q3CONFIG_NAME \"\\n\");\n\t\t}\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n}\n\n/*\n=================\nFS_ConditionalRestart\n\nRestart if necessary\n=================\n*/\nqboolean FS_ConditionalRestart( void ) {\n\tif(fs_gamedirvar->modified) {\n\t\tFS_Restart();\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n========================================================================================\n\nHandle based file calls for virtual machines\n\n========================================================================================\n*/\n\nint\t\tFS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {\n\tint\t\tr;\n\tqboolean\tsync;\n\n\tsync = qfalse;\n\n\tswitch( mode ) {\n\tcase FS_READ:\n\t\tr = FS_FOpenFileRead( qpath, f, qtrue );\n\t\tbreak;\n\tcase FS_WRITE:\n\t\t*f = FS_FOpenFileWrite( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tcase FS_APPEND_SYNC:\n\t\tsync = qtrue;\n\tcase FS_APPEND:\n\t\t*f = FS_FOpenFileAppend( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"FSH_FOpenFile: bad mode\" );\n\t\treturn -1;\n\t}\n\n\tif (!f) {\n\t\treturn r;\n\t}\n\n\tif ( *f ) {\n\t\tfsh[*f].fileSize = r;\n\t}\n\tfsh[*f].handleSync = sync;\n\n\treturn r;\n}\n\nint\t\tFS_FTell( fileHandle_t f ) {\n\tint pos;\n\tif (fsh[f].zipFile == qtrue) {\n\t\tpos = unztell(fsh[f].handleFiles.file.z);\n\t} else {\n\t\tpos = ftell(fsh[f].handleFiles.file.o);\n\t}\n\treturn pos;\n}\n\nvoid\tFS_Flush( fileHandle_t f ) {\n\tfflush(fsh[f].handleFiles.file.o);\n}\n\nvoid FS_FilenameCompletion( const char *dir, const char *ext, qboolean stripExt, callbackFunc_t callback, qboolean allowNonPureFilesOnDisk ) {\n\tint nfiles;\n\tchar **filenames, filename[MAX_STRING_CHARS];\n\n\tfilenames = FS_ListFilteredFiles( dir, ext, NULL, &nfiles );\n\n\tFS_SortFileList( filenames, nfiles );\n\n\t// pass all the files to callback (FindMatches)\n\tfor ( int i=0; i<nfiles; i++ ) {\n\t\tFS_ConvertPath( filenames[i] );\n\t\tQ_strncpyz( filename, filenames[i], MAX_STRING_CHARS );\n\n\t\tif ( stripExt )\n\t\t\tCOM_StripExtension( filename, filename, sizeof( filename ) );\n\n\t\tcallback( filename );\n\t}\n\tFS_FreeFileList( filenames );\n}\n\nconst char *FS_GetCurrentGameDir(bool emptybase)\n{\n\tif(fs_gamedirvar->string[0])\n\t\treturn fs_gamedirvar->string;\n\n\treturn emptybase ? \"\" : BASEGAME;\n}\n\nqboolean FS_WriteToTemporaryFile( const void *data, size_t dataLength, char **tempFilePath )\n{\n\t// SP doesn't need to do this.\n\treturn qfalse;\n}\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n// cl_main.c  -- client main loop\n\n#include \"client.h\"\n\n#include <limits.h>\n#include \"ghoul2/G2.h\"\n#include \"qcommon/cm_public.h\"\n#include \"qcommon/MiniHeap.h\"\n#include \"qcommon/stringed_ingame.h\"\n#include \"cl_cgameapi.h\"\n#include \"cl_uiapi.h\"\n#include \"cl_lan.h\"\n#include \"snd_local.h\"\n#include \"sys/sys_loadlib.h\"\n\ncvar_t\t*cl_renderer;\n\ncvar_t\t*cl_nodelta;\ncvar_t\t*cl_debugMove;\n\ncvar_t\t*cl_noprint;\ncvar_t\t*cl_motd;\ncvar_t\t*cl_motdServer[MAX_MASTER_SERVERS];\n\ncvar_t\t*rcon_client_password;\ncvar_t\t*rconAddress;\n\ncvar_t\t*cl_timeout;\ncvar_t\t*cl_maxpackets;\ncvar_t\t*cl_packetdup;\ncvar_t\t*cl_timeNudge;\ncvar_t\t*cl_showTimeDelta;\ncvar_t\t*cl_freezeDemo;\n\ncvar_t\t*cl_shownet;\ncvar_t\t*cl_showSend;\ncvar_t\t*cl_timedemo;\ncvar_t\t*cl_aviFrameRate;\ncvar_t\t*cl_aviMotionJpeg;\ncvar_t\t*cl_avi2GBLimit;\ncvar_t\t*cl_forceavidemo;\n\ncvar_t\t*cl_freelook;\ncvar_t\t*cl_sensitivity;\n\ncvar_t\t*cl_mouseAccel;\ncvar_t\t*cl_mouseAccelOffset;\ncvar_t\t*cl_mouseAccelStyle;\ncvar_t\t*cl_showMouseRate;\n\ncvar_t\t*m_pitchVeh;\ncvar_t\t*m_pitch;\ncvar_t\t*m_yaw;\ncvar_t\t*m_forward;\ncvar_t\t*m_side;\ncvar_t\t*m_filter;\n\ncvar_t\t*cl_activeAction;\n\ncvar_t\t*cl_motdString;\n\ncvar_t\t*cl_allowDownload;\ncvar_t\t*cl_allowAltEnter;\ncvar_t\t*cl_conXOffset;\ncvar_t\t*cl_inGameVideo;\n\ncvar_t\t*cl_serverStatusResendTime;\ncvar_t\t*cl_framerate;\n\n// cvar to enable sending a \"ja_guid\" player identifier in userinfo to servers\n// ja_guid is a persistent \"cookie\" that allows servers to track players across game sessions\ncvar_t\t*cl_enableGuid;\ncvar_t\t*cl_guidServerUniq;\n\ncvar_t\t*cl_autolodscale;\n\ncvar_t\t*cl_consoleKeys;\ncvar_t\t*cl_consoleUseScanCode;\n\ncvar_t  *cl_lanForcePackets;\n\nvec3_t cl_windVec;\n\n\nclientActive_t\t\tcl;\nclientConnection_t\tclc;\nclientStatic_t\t\tcls;\n\nnetadr_t rcon_address;\n\nchar cl_reconnectArgs[MAX_OSPATH] = {0};\n\n// Structure containing functions exported from refresh DLL\nrefexport_t\t*re = NULL;\nstatic void\t*rendererLib = NULL;\n\nping_t\tcl_pinglist[MAX_PINGREQUESTS];\n\ntypedef struct serverStatus_s\n{\n\tchar string[BIG_INFO_STRING];\n\tnetadr_t address;\n\tint time, startTime;\n\tqboolean pending;\n\tqboolean print;\n\tqboolean retrieved;\n} serverStatus_t;\n\nserverStatus_t cl_serverStatusList[MAX_SERVERSTATUSREQUESTS];\nint serverStatusCount;\n\nIHeapAllocator *G2VertSpaceClient = 0;\n\nextern void SV_BotFrame( int time );\nvoid CL_CheckForResend( void );\nvoid CL_ShowIP_f(void);\nvoid CL_ServerStatus_f(void);\nvoid CL_ServerStatusResponse( netadr_t from, msg_t *msg );\nstatic void CL_ShutdownRef( qboolean restarting );\n\n/*\n=======================================================================\n\nCLIENT RELIABLE COMMAND COMMUNICATION\n\n=======================================================================\n*/\n\n/*\n======================\nCL_AddReliableCommand\n\nThe given command will be transmitted to the server, and is gauranteed to\nnot have future usercmd_t executed before it is executed\n======================\n*/\nvoid CL_AddReliableCommand( const char *cmd, qboolean isDisconnectCmd ) {\n\tint unacknowledged = clc.reliableSequence - clc.reliableAcknowledge;\n\n\t// if we would be losing an old command that hasn't been acknowledged,\n\t// we must drop the connection\n\t// also leave one slot open for the disconnect command in this case.\n\n\tif ((isDisconnectCmd && unacknowledged > MAX_RELIABLE_COMMANDS) ||\n\t    (!isDisconnectCmd && unacknowledged >= MAX_RELIABLE_COMMANDS))\n\t{\n\t\tif(com_errorEntered)\n\t\t\treturn;\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"Client command overflow\");\n\t}\n\n\tQ_strncpyz(clc.reliableCommands[++clc.reliableSequence & (MAX_RELIABLE_COMMANDS - 1)],\n\t\t   cmd, sizeof(*clc.reliableCommands));\n}\n\n/*\n=======================================================================\n\nCLIENT SIDE DEMO RECORDING\n\n=======================================================================\n*/\n\n/*\n====================\nCL_WriteDemoMessage\n\nDumps the current net message, prefixed by the length\n====================\n*/\nvoid CL_WriteDemoMessage ( msg_t *msg, int headerBytes ) {\n\tint\t\tlen, swlen;\n\n\t// write the packet sequence\n\tlen = clc.serverMessageSequence;\n\tswlen = LittleLong( len );\n\tFS_Write (&swlen, 4, clc.demofile);\n\n\t// skip the packet sequencing information\n\tlen = msg->cursize - headerBytes;\n\tswlen = LittleLong(len);\n\tFS_Write (&swlen, 4, clc.demofile);\n\tFS_Write ( msg->data + headerBytes, len, clc.demofile );\n}\n\n\n/*\n====================\nCL_StopRecording_f\n\nstop recording a demo\n====================\n*/\nvoid CL_StopRecord_f( void ) {\n\tint\t\tlen;\n\n\tif ( !clc.demorecording ) {\n\t\tCom_Printf (\"Not recording a demo.\\n\");\n\t\treturn;\n\t}\n\n\t// finish up\n\tlen = -1;\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_FCloseFile (clc.demofile);\n\tclc.demofile = 0;\n\tclc.demorecording = qfalse;\n\tclc.spDemoRecording = qfalse;\n\tCom_Printf (\"Stopped demo.\\n\");\n}\n\n/*\n==================\nCL_DemoFilename\n==================\n*/\nvoid CL_DemoFilename( char *buf, int bufSize ) {\n\ttime_t rawtime;\n\tchar timeStr[32] = {0}; // should really only reach ~19 chars\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\n\tCom_sprintf( buf, bufSize, \"demo%s\", timeStr );\n}\n\n/*\n====================\nCL_Record_f\n\nrecord <demoname>\n\nBegins recording a demo from the current position\n====================\n*/\nstatic char\t\tdemoName[MAX_QPATH];\t// compiler bug workaround\nvoid CL_Record_f( void ) {\n\tchar\t\tname[MAX_OSPATH];\n\tbyte\t\tbufData[MAX_MSGLEN];\n\tmsg_t\tbuf;\n\tint\t\t\ti;\n\tint\t\t\tlen;\n\tentityState_t\t*ent;\n\tentityState_t\tnullstate;\n\tchar\t\t*s;\n\n\tif ( Cmd_Argc() > 2 ) {\n\t\tCom_Printf (\"record <demoname>\\n\");\n\t\treturn;\n\t}\n\n\tif ( clc.demorecording ) {\n\t\tif (!clc.spDemoRecording) {\n\t\t\tCom_Printf (\"Already recording.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf (\"You must be in a level to record.\\n\");\n\t\treturn;\n\t}\n\n\t// sync 0 doesn't prevent recording, so not forcing it off .. everyone does g_sync 1 ; record ; g_sync 0 ..\n\tif ( NET_IsLocalAddress( clc.serverAddress ) && !Cvar_VariableValue( \"g_synchronousClients\" ) ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"WARNING: You should set 'g_synchronousClients 1' for smoother demo recording\\n\");\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\ts = Cmd_Argv(1);\n\t\tQ_strncpyz( demoName, s, sizeof( demoName ) );\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", demoName, PROTOCOL_VERSION );\n\t} else {\n\t\t// timestamp the file\n\t\tCL_DemoFilename( demoName, sizeof( demoName ) );\n\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", demoName, PROTOCOL_VERSION );\n\n\t\tif ( FS_FileExists( name ) ) {\n\t\t\tCom_Printf( \"Record: Couldn't create a file\\n\");\n\t\t\treturn;\n \t\t}\n\t}\n\n\t// open the demo file\n\n\tCom_Printf (\"recording to %s.\\n\", name);\n\tclc.demofile = FS_FOpenFileWrite( name );\n\tif ( !clc.demofile ) {\n\t\tCom_Printf (\"ERROR: couldn't open.\\n\");\n\t\treturn;\n\t}\n\tclc.demorecording = qtrue;\n\tif (Cvar_VariableValue(\"ui_recordSPDemo\")) {\n\t  clc.spDemoRecording = qtrue;\n\t} else {\n\t  clc.spDemoRecording = qfalse;\n\t}\n\n\tQ_strncpyz( clc.demoName, demoName, sizeof( clc.demoName ) );\n\n\t// don't start saving messages until a non-delta compressed message is received\n\tclc.demowaiting = qtrue;\n\n\t// write out the gamestate message\n\tMSG_Init (&buf, bufData, sizeof(bufData));\n\tMSG_Bitstream(&buf);\n\n\t// NOTE, MRE: all server->client messages now acknowledge\n\tMSG_WriteLong( &buf, clc.reliableSequence );\n\n\tMSG_WriteByte (&buf, svc_gamestate);\n\tMSG_WriteLong (&buf, clc.serverCommandSequence );\n\n\t// configstrings\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tif ( !cl.gameState.stringOffsets[i] ) {\n\t\t\tcontinue;\n\t\t}\n\t\ts = cl.gameState.stringData + cl.gameState.stringOffsets[i];\n\t\tMSG_WriteByte (&buf, svc_configstring);\n\t\tMSG_WriteShort (&buf, i);\n\t\tMSG_WriteBigString (&buf, s);\n\t}\n\n\t// baselines\n\tCom_Memset (&nullstate, 0, sizeof(nullstate));\n\tfor ( i = 0; i < MAX_GENTITIES ; i++ ) {\n\t\tent = &cl.entityBaselines[i];\n\t\tif ( !ent->number ) {\n\t\t\tcontinue;\n\t\t}\n\t\tMSG_WriteByte (&buf, svc_baseline);\n\t\tMSG_WriteDeltaEntity (&buf, &nullstate, ent, qtrue );\n\t}\n\n\tMSG_WriteByte( &buf, svc_EOF );\n\n\t// finished writing the gamestate stuff\n\n\t// write the client num\n\tMSG_WriteLong(&buf, clc.clientNum);\n\t// write the checksum feed\n\tMSG_WriteLong(&buf, clc.checksumFeed);\n\n\t// Filler for old RMG system.\n\tMSG_WriteShort ( &buf, 0 );\n\n\t// finished writing the client packet\n\tMSG_WriteByte( &buf, svc_EOF );\n\n\t// write it to the demo file\n\tlen = LittleLong( clc.serverMessageSequence - 1 );\n\tFS_Write (&len, 4, clc.demofile);\n\n\tlen = LittleLong (buf.cursize);\n\tFS_Write (&len, 4, clc.demofile);\n\tFS_Write (buf.data, buf.cursize, clc.demofile);\n\n\t// the rest of the demo file will be copied from net messages\n}\n\n/*\n=======================================================================\n\nCLIENT SIDE DEMO PLAYBACK\n\n=======================================================================\n*/\n\n/*\n=================\nCL_DemoCompleted\n=================\n*/\nvoid CL_DemoCompleted( void ) {\n\tif (cl_timedemo && cl_timedemo->integer) {\n\t\tint\ttime;\n\n\t\ttime = Sys_Milliseconds() - clc.timeDemoStart;\n\t\tif ( time > 0 ) {\n\t\t\tCom_Printf (\"%i frames, %3.1f seconds: %3.1f fps\\n\", clc.timeDemoFrames,\n\t\t\ttime/1000.0, clc.timeDemoFrames*1000.0 / time);\n\t\t}\n\t}\n\n/*\tCL_Disconnect( qtrue );\n\tCL_NextDemo();\n\t*/\n\n\t//rww - The above code seems to just stick you in a no-menu state and you can't do anything there.\n\t//I'm not sure why it ever worked in TA, but whatever. This code will bring us back to the main menu\n\t//after a demo is finished playing instead.\n\tCL_Disconnect_f();\n\tS_StopAllSounds();\n\tUIVM_SetActiveMenu( UIMENU_MAIN );\n\n\tCL_NextDemo();\n}\n\n/*\n=================\nCL_ReadDemoMessage\n=================\n*/\nvoid CL_ReadDemoMessage( void ) {\n\tint\t\t\tr;\n\tmsg_t\t\tbuf;\n\tbyte\t\tbufData[ MAX_MSGLEN ];\n\tint\t\t\ts;\n\n\tif ( !clc.demofile ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\n\t// get the sequence number\n\tr = FS_Read( &s, 4, clc.demofile);\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tclc.serverMessageSequence = LittleLong( s );\n\n\t// init the message\n\tMSG_Init( &buf, bufData, sizeof( bufData ) );\n\n\t// get the length\n\tr = FS_Read (&buf.cursize, 4, clc.demofile);\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tbuf.cursize = LittleLong( buf.cursize );\n\tif ( buf.cursize == -1 ) {\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\tif ( buf.cursize > buf.maxsize ) {\n\t\tCom_Error (ERR_DROP, \"CL_ReadDemoMessage: demoMsglen > MAX_MSGLEN\");\n\t}\n\tr = FS_Read( buf.data, buf.cursize, clc.demofile );\n\tif ( r != buf.cursize ) {\n\t\tCom_Printf( \"Demo file was truncated.\\n\");\n\t\tCL_DemoCompleted ();\n\t\treturn;\n\t}\n\n\tclc.lastPacketTime = cls.realtime;\n\tbuf.readcount = 0;\n\tCL_ParseServerMessage( &buf );\n}\n\n/*\n====================\nCL_CompleteDemoName\n====================\n*/\nstatic void CL_CompleteDemoName( char *args, int argNum )\n{\n\tif( argNum == 2 )\n\t{\n\t\tchar demoExt[16];\n\n\t\tCom_sprintf(demoExt, sizeof(demoExt), \".dm_%d\", PROTOCOL_VERSION);\n\t\tField_CompleteFilename( \"demos\", demoExt, qtrue, qtrue );\n\t}\n}\n\n/*\n====================\nCL_PlayDemo_f\n\ndemo <demoname>\n\n====================\n*/\nvoid CL_PlayDemo_f( void ) {\n\tchar\t\tname[MAX_OSPATH], extension[32];\n\tchar\t\t*arg;\n\n\tif (Cmd_Argc() != 2) {\n\t\tCom_Printf (\"demo <demoname>\\n\");\n\t\treturn;\n\t}\n\n\t// make sure a local server is killed\n\t// 2 means don't force disconnect of local client\n\tCvar_Set( \"sv_killserver\", \"2\" );\n\n\t// open the demo file\n\targ = Cmd_Argv(1);\n\n\tCL_Disconnect( qtrue );\n\n\tCom_sprintf(extension, sizeof(extension), \".dm_%d\", PROTOCOL_VERSION);\n\tif ( !Q_stricmp( arg + strlen(arg) - strlen(extension), extension ) ) {\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s\", arg);\n\t} else {\n\t\tCom_sprintf (name, sizeof(name), \"demos/%s.dm_%d\", arg, PROTOCOL_VERSION);\n\t}\n\n\tFS_FOpenFileRead( name, &clc.demofile, qtrue );\n\tif (!clc.demofile) {\n\t\tif (!Q_stricmp(arg, \"(null)\"))\n\t\t{\n\t\t\tCom_Error( ERR_DROP, SE_GetString(\"CON_TEXT_NO_DEMO_SELECTED\") );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCom_Error( ERR_DROP, \"couldn't open %s\", name);\n\t\t}\n\t\treturn;\n\t}\n\tQ_strncpyz( clc.demoName, Cmd_Argv(1), sizeof( clc.demoName ) );\n\n\tCon_Close();\n\n\tcls.state = CA_CONNECTED;\n\tclc.demoplaying = qtrue;\n\tQ_strncpyz( cls.servername, Cmd_Argv(1), sizeof( cls.servername ) );\n\n\t// read demo messages until connected\n\twhile ( cls.state >= CA_CONNECTED && cls.state < CA_PRIMED ) {\n\t\tCL_ReadDemoMessage();\n\t}\n\t// don't get the first snapshot this frame, to prevent the long\n\t// time from the gamestate load from messing causing a time skip\n\tclc.firstDemoFrameSkipped = qfalse;\n}\n\n\n/*\n====================\nCL_StartDemoLoop\n\nClosing the main menu will restart the demo loop\n====================\n*/\nvoid CL_StartDemoLoop( void ) {\n\t// start the demo loop again\n\tCbuf_AddText (\"d1\\n\");\n\tKey_SetCatcher( 0 );\n}\n\n/*\n==================\nCL_NextDemo\n\nCalled when a demo or cinematic finishes\nIf the \"nextdemo\" cvar is set, that command will be issued\n==================\n*/\nvoid CL_NextDemo( void ) {\n\tchar\tv[MAX_STRING_CHARS];\n\n\tQ_strncpyz( v, Cvar_VariableString (\"nextdemo\"), sizeof(v) );\n\tv[MAX_STRING_CHARS-1] = 0;\n\tCom_DPrintf(\"CL_NextDemo: %s\\n\", v );\n\tif (!v[0]) {\n\t\treturn;\n\t}\n\n\tCvar_Set (\"nextdemo\",\"\");\n\tCbuf_AddText (v);\n\tCbuf_AddText (\"\\n\");\n\tCbuf_Execute();\n}\n\n//======================================================================\n\n/*\n=====================\nCL_ShutdownAll\n=====================\n*/\nvoid CL_ShutdownAll( qboolean shutdownRef ) {\n\tif(CL_VideoRecording())\n\t\tCL_CloseAVI();\n\n\tif(clc.demorecording)\n\t\tCL_StopRecord_f();\n\n#if 0 //rwwFIXMEFIXME: Disable this before release!!!!!! I am just trying to find a crash bug.\n\t//so it doesn't barf on shutdown saying refentities belong to each other\n\ttr.refdef.num_entities = 0;\n#endif\n\n\t// clear sounds\n\tS_DisableSounds();\n\t// shutdown CGame\n\tCL_ShutdownCGame();\n\t// shutdown UI\n\tCL_ShutdownUI();\n\n\t// shutdown the renderer\n\tif(shutdownRef)\n\t\tCL_ShutdownRef( qfalse );\n\tif ( re && re->Shutdown ) {\n\t\tre->Shutdown( qfalse, qfalse );\t\t// don't destroy window or context\n\t}\n\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.rendererStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n}\n\n/*\n=================\nCL_FlushMemory\n\nCalled by CL_MapLoading, CL_Connect_f, CL_PlayDemo_f, and CL_ParseGamestate the only\nways a client gets into a game\nAlso called by Com_Error\n=================\n*/\nvoid CL_FlushMemory( void ) {\n\n\t// shutdown all the client stuff\n\tCL_ShutdownAll( qfalse );\n\n\t// if not running a server clear the whole hunk\n\tif ( !com_sv_running->integer ) {\n\t\t// clear collision map data\n\t\tCM_ClearMap();\n\t\t// clear the whole hunk\n\t\tHunk_Clear();\n\t}\n\telse {\n\t\t// clear all the client data on the hunk\n\t\tHunk_ClearToMark();\n\t}\n\n\tCL_StartHunkUsers();\n}\n\n/*\n=====================\nCL_MapLoading\n\nA local server is starting to load a map, so update the\nscreen to let the user know about it, then dump all client\nmemory on the hunk from cgame, ui, and renderer\n=====================\n*/\nvoid CL_MapLoading( void ) {\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// Set this to localhost.\n\tCvar_Set( \"cl_currentServerAddress\", \"Localhost\");\n\tCvar_Set( \"cl_currentServerIP\", \"loopback\");\n\n\tCon_Close();\n\tKey_SetCatcher( 0 );\n\n\t// if we are already connected to the local host, stay connected\n\tif ( cls.state >= CA_CONNECTED && !Q_stricmp( cls.servername, \"localhost\" ) ) {\n\t\tcls.state = CA_CONNECTED;\t\t// so the connect screen is drawn\n\t\tCom_Memset( cls.updateInfoString, 0, sizeof( cls.updateInfoString ) );\n\t\tCom_Memset( clc.serverMessage, 0, sizeof( clc.serverMessage ) );\n\t\tCom_Memset( &cl.gameState, 0, sizeof( cl.gameState ) );\n\t\tclc.lastPacketSentTime = -9999;\n\t\tSCR_UpdateScreen();\n\t} else {\n\t\t// clear nextmap so the cinematic shutdown doesn't execute it\n\t\tCvar_Set( \"nextmap\", \"\" );\n\t\tCL_Disconnect( qtrue );\n\t\tQ_strncpyz( cls.servername, \"localhost\", sizeof(cls.servername) );\n\t\tcls.state = CA_CHALLENGING;\t\t// so the connect screen is drawn\n\t\tKey_SetCatcher( 0 );\n\t\tSCR_UpdateScreen();\n\t\tclc.connectTime = -RETRANSMIT_TIMEOUT;\n\t\tNET_StringToAdr( cls.servername, &clc.serverAddress);\n\t\t// we don't need a challenge on the localhost\n\n\t\tCL_CheckForResend();\n\t}\n}\n\n/*\n=====================\nCL_ClearState\n\nCalled before parsing a gamestate\n=====================\n*/\nvoid CL_ClearState (void) {\n\n//\tS_StopAllSounds();\n\tCom_Memset( &cl, 0, sizeof( cl ) );\n}\n\n/*\n====================\nCL_UpdateGUID\n\nupdate cl_guid using QKEY_FILE and optional prefix\n====================\n*/\nstatic void CL_UpdateGUID( const char *prefix, int prefix_len )\n{\n\tif (cl_enableGuid->integer) {\n\t\tfileHandle_t f;\n\t\tint len;\n\n\t\tlen = FS_SV_FOpenFileRead( QKEY_FILE, &f );\n\t\tFS_FCloseFile( f );\n\n\t\t// initialize the cvar here in case it's unset or was user-created\n\t\t// while tracking was disabled (removes CVAR_USER_CREATED)\n\t\tCvar_Get( \"ja_guid\", \"\", CVAR_USERINFO | CVAR_ROM, \"Client GUID\" );\n\n\t\tif( len != QKEY_SIZE ) {\n\t\t\tCvar_Set( \"ja_guid\", \"\" );\n\t\t} else {\n\t\t\tCvar_Set( \"ja_guid\", Com_MD5File( QKEY_FILE, QKEY_SIZE,\n\t\t\t\tprefix, prefix_len ) );\n\t\t}\n\t} else {\n\t\t// Remove the cvar entirely if tracking is disabled\n\t\tuint32_t flags = Cvar_Flags(\"ja_guid\");\n\t\t// keep the cvar if it's user-created, but destroy it otherwise\n\t\tif (flags != CVAR_NONEXISTENT && !(flags & CVAR_USER_CREATED)) {\n\t\t\tcvar_t *ja_guid = Cvar_Get(\"ja_guid\", \"\", 0, \"Client GUID\" );\n\t\t\tCvar_Unset(ja_guid);\n\t\t}\n\t}\n}\n\n/*\n=====================\nCL_Disconnect\n\nCalled when a connection, demo, or cinematic is being terminated.\nGoes from a connected state to either a menu state or a console state\nSends a disconnect message to the server\nThis is also called on Com_Error and Com_Quit, so it shouldn't cause any errors\n=====================\n*/\nvoid CL_Disconnect( qboolean showMainMenu ) {\n\tif ( !com_cl_running || !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\t// shutting down the client so enter full screen ui mode\n\tCvar_Set(\"r_uiFullScreen\", \"1\");\n\n\tif ( clc.demorecording ) {\n\t\tCL_StopRecord_f ();\n\t}\n\n\tif (clc.download) {\n\t\tFS_FCloseFile( clc.download );\n\t\tclc.download = 0;\n\t}\n\t*clc.downloadTempName = *clc.downloadName = 0;\n\tCvar_Set( \"cl_downloadName\", \"\" );\n\n\tif ( clc.demofile ) {\n\t\tFS_FCloseFile( clc.demofile );\n\t\tclc.demofile = 0;\n\t}\n\n\tif ( cls.uiStarted && showMainMenu ) {\n\t\tUIVM_SetActiveMenu( UIMENU_NONE );\n\t}\n\n\tSCR_StopCinematic ();\n\tS_ClearSoundBuffer();\n\n\t// send a disconnect message to the server\n\t// send it a few times in case one is dropped\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\tCL_AddReliableCommand( \"disconnect\", qtrue );\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t\tCL_WritePacket();\n\t}\n\n\t// Remove pure paks\n\tFS_PureServerSetLoadedPaks(\"\", \"\");\n\tFS_PureServerSetReferencedPaks(\"\", \"\");\n\n\tCL_ClearState ();\n\n\t// wipe the client connection\n\tCom_Memset( &clc, 0, sizeof( clc ) );\n\n\tcls.state = CA_DISCONNECTED;\n\n\t// allow cheats locally\n\tCvar_Set( \"sv_cheats\", \"1\" );\n\n\t// not connected to a pure server anymore\n\tcl_connectedToPureServer = qfalse;\n\n\t// Stop recording any video\n\tif( CL_VideoRecording( ) ) {\n\t\t// Finish rendering current frame\n\t\tSCR_UpdateScreen( );\n\t\tCL_CloseAVI( );\n\t}\n\n\tCL_UpdateGUID( NULL, 0 );\n}\n\n\n/*\n===================\nCL_ForwardCommandToServer\n\nadds the current command line as a clientCommand\nthings like godmode, noclip, etc, are commands directed to the server,\nso when they are typed in at the console, they will need to be forwarded.\n===================\n*/\nvoid CL_ForwardCommandToServer( const char *string ) {\n\tchar\t*cmd;\n\n\tcmd = Cmd_Argv(0);\n\n\t// ignore key up commands\n\tif ( cmd[0] == '-' ) {\n\t\treturn;\n\t}\n\n\tif (clc.demoplaying || cls.state < CA_CONNECTED || cmd[0] == '+' ) {\n\t\tCom_Printf (\"Unknown command \\\"%s\" S_COLOR_WHITE \"\\\"\\n\", cmd);\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( string, qfalse );\n\t} else {\n\t\tCL_AddReliableCommand( cmd, qfalse );\n\t}\n}\n\n/*\n===================\nCL_RequestMotd\n\n===================\n*/\nvoid CL_RequestMotd( void ) {\n\tnetadr_t\tto;\n\tint\t\t\ti;\n\tchar\t\tcommand[MAX_STRING_CHARS], info[MAX_INFO_STRING];\n\tchar\t\t*motdaddress;\n\n\tif ( !cl_motd->integer ) {\n\t\treturn;\n\t}\n\n\tif ( cl_motd->integer < 1 || cl_motd->integer > MAX_MASTER_SERVERS ) {\n\t\tCom_Printf( \"CL_RequestMotd: Invalid motd server num. Valid values are 1-%d or 0 to disable\\n\", MAX_MASTER_SERVERS );\n\t\treturn;\n\t}\n\n\tCom_sprintf( command, sizeof(command), \"cl_motdServer%d\", cl_motd->integer );\n\tmotdaddress = Cvar_VariableString( command );\n\n\tif ( !*motdaddress )\n\t{\n\t\tCom_Printf( \"CL_RequestMotd: Error: No motd server address given.\\n\" );\n\t\treturn;\n\t}\n\n\ti = NET_StringToAdr( motdaddress, &to );\n\n\tif ( !i )\n\t{\n\t\tCom_Printf( \"CL_RequestMotd: Error: could not resolve address of motd server %s\\n\", motdaddress );\n\t\treturn;\n\t}\n\tto.type = NA_IP;\n\tto.port = BigShort( PORT_UPDATE );\n\n\tCom_Printf( \"Requesting motd from update %s (%s)...\\n\", motdaddress, NET_AdrToString( to ) );\n\n\tcls.updateServer = to;\n\n\tinfo[0] = 0;\n  // NOTE TTimo xoring against Com_Milliseconds, otherwise we may not have a true randomization\n  // only srand I could catch before here is tr_noise.c l:26 srand(1001)\n  // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=382\n  // NOTE: the Com_Milliseconds xoring only affects the lower 16-bit word,\n  //   but I decided it was enough randomization\n\tCom_sprintf( cls.updateChallenge, sizeof( cls.updateChallenge ), \"%i\", ((rand() << 16) ^ rand()) ^ Com_Milliseconds());\n\n\tInfo_SetValueForKey( info, \"challenge\", cls.updateChallenge );\n\tInfo_SetValueForKey( info, \"renderer\", cls.glconfig.renderer_string );\n\tInfo_SetValueForKey( info, \"rvendor\", cls.glconfig.vendor_string );\n\tInfo_SetValueForKey( info, \"version\", com_version->string );\n\n\t//If raven starts filtering for this, add this code back in\n#if 0\n\tInfo_SetValueForKey( info, \"cputype\", \"Intel Pentium IV\");\n\tInfo_SetValueForKey( info, \"mhz\", \"3000\" );\n\tInfo_SetValueForKey( info, \"memory\", \"4096\" );\n#endif\n\tInfo_SetValueForKey( info, \"joystick\", Cvar_VariableString(\"in_joystick\") );\n\tInfo_SetValueForKey( info, \"colorbits\", va(\"%d\",cls.glconfig.colorBits) );\n\n\tNET_OutOfBandPrint( NS_CLIENT, cls.updateServer, \"getmotd \\\"%s\\\"\\n\", info );\n}\n\n\n/*\n======================================================================\n\nCONSOLE COMMANDS\n\n======================================================================\n*/\n\n/*\n==================\nCL_ForwardToServer_f\n==================\n*/\nvoid CL_ForwardToServer_f( void ) {\n\tif ( cls.state != CA_ACTIVE || clc.demoplaying ) {\n\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\t// don't forward the first argument\n\tif ( Cmd_Argc() > 1 ) {\n\t\tCL_AddReliableCommand( Cmd_Args(), qfalse );\n\t}\n}\n\n\n/*\n==================\nCL_Disconnect_f\n==================\n*/\nvoid CL_Disconnect_f( void ) {\n\tSCR_StopCinematic();\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\tif ( cls.state != CA_DISCONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tCom_Error (ERR_DISCONNECT, \"Disconnected from server\");\n\t}\n}\n\n\n/*\n================\nCL_Reconnect_f\n\n================\n*/\nvoid CL_Reconnect_f( void ) {\n\tif ( !strlen( cl_reconnectArgs ) ) {\n\t\treturn;\n\t}\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\tCbuf_AddText( va(\"connect %s\\n\", cl_reconnectArgs ) );\n}\n\n/*\n================\nCL_Connect_f\n\n================\n*/\nvoid CL_Connect_f( void ) {\n\tchar\t*server;\n\tconst char\t*serverString;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: connect [server]\\n\");\n\t\treturn;\n\t}\n\n\t// save arguments for reconnect\n\tQ_strncpyz( cl_reconnectArgs, Cmd_Args(), sizeof( cl_reconnectArgs ) );\n\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\n\t// fire a message off to the motd server\n\tCL_RequestMotd();\n\n\t// clear any previous \"server full\" type messages\n\tclc.serverMessage[0] = 0;\n\n\tserver = Cmd_Argv (1);\n\n\tif ( com_sv_running->integer && !strcmp( server, \"localhost\" ) ) {\n\t\t// if running a local server, kill it\n\t\tSV_Shutdown( \"Server quit\\n\" );\n\t}\n\n\t// make sure a local server is killed\n\tCvar_Set( \"sv_killserver\", \"1\" );\n\tSV_Frame( 0 );\n\n\tCL_Disconnect( qtrue );\n\tCon_Close();\n\n\tQ_strncpyz( cls.servername, server, sizeof(cls.servername) );\n\n\tif (!NET_StringToAdr( cls.servername, &clc.serverAddress) ) {\n\t\tCom_Printf (\"Bad server address\\n\");\n\t\tcls.state = CA_DISCONNECTED;\n\t\treturn;\n\t}\n\tif (clc.serverAddress.port == 0) {\n\t\tclc.serverAddress.port = BigShort( PORT_SERVER );\n\t}\n\n\tserverString = NET_AdrToString(clc.serverAddress);\n\n\tCom_Printf( \"%s resolved to %s\\n\", cls.servername, serverString );\n\n\tif( cl_guidServerUniq->integer )\n\t\tCL_UpdateGUID( serverString, strlen( serverString ) );\n\telse\n\t\tCL_UpdateGUID( NULL, 0 );\n\n\t// if we aren't playing on a lan, we need to authenticate\n\tif ( NET_IsLocalAddress( clc.serverAddress ) ) {\n\t\tcls.state = CA_CHALLENGING;\n\t} else {\n\t\tcls.state = CA_CONNECTING;\n\n\t\t// Set a client challenge number that ideally is mirrored back by the server.\n\t\tclc.challenge = ((rand() << 16) ^ rand()) ^ Com_Milliseconds();\n\t}\n\n\tKey_SetCatcher( 0 );\n\tclc.connectTime = -99999;\t// CL_CheckForResend() will fire immediately\n\tclc.connectPacketCount = 0;\n\n\t// server connection string\n\tCvar_Set( \"cl_currentServerAddress\", server );\n\tCvar_Set( \"cl_currentServerIP\", serverString );\n}\n\n#define MAX_RCON_MESSAGE 1024\n\n/*\n==================\nCL_CompleteRcon\n==================\n*/\nstatic void CL_CompleteRcon( char *args, int argNum )\n{\n\tif( argNum == 2 )\n\t{\n\t\t// Skip \"rcon \"\n\t\tchar *p = Com_SkipTokens( args, 1, \" \" );\n\n\t\tif( p > args )\n\t\t\tField_CompleteCommand( p, qtrue, qtrue );\n\t}\n}\n\n/*\n=====================\nCL_Rcon_f\n\n  Send the rest of the command line over as\n  an unconnected command.\n=====================\n*/\nvoid CL_Rcon_f( void ) {\n\tchar\tmessage[MAX_RCON_MESSAGE];\n\n\tif ( !rcon_client_password->string[0] ) {\n\t\tCom_Printf( \"You must set 'rconpassword' before issuing an rcon command.\\n\" );\n\t\treturn;\n\t}\n\n\tmessage[0] = -1;\n\tmessage[1] = -1;\n\tmessage[2] = -1;\n\tmessage[3] = -1;\n\tmessage[4] = 0;\n\n\tQ_strcat (message, MAX_RCON_MESSAGE, \"rcon \");\n\n\tQ_strcat (message, MAX_RCON_MESSAGE, rcon_client_password->string);\n\tQ_strcat (message, MAX_RCON_MESSAGE, \" \");\n\n\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=543\n\tQ_strcat (message, MAX_RCON_MESSAGE, Cmd_Cmd()+5);\n\n\tif ( cls.state >= CA_CONNECTED ) {\n\t\trcon_address = clc.netchan.remoteAddress;\n\t} else {\n\t\tif (!strlen(rconAddress->string)) {\n\t\t\tCom_Printf (\"You must either be connected,\\n\"\n\t\t\t\t\t\t\"or set the 'rconAddress' cvar\\n\"\n\t\t\t\t\t\t\"to issue rcon commands\\n\");\n\n\t\t\treturn;\n\t\t}\n\t\tNET_StringToAdr (rconAddress->string, &rcon_address);\n\t\tif (rcon_address.port == 0) {\n\t\t\trcon_address.port = BigShort (PORT_SERVER);\n\t\t}\n\t}\n\n\tNET_SendPacket (NS_CLIENT, strlen(message)+1, message, rcon_address);\n}\n\n/*\n=================\nCL_SendPureChecksums\n=================\n*/\nvoid CL_SendPureChecksums( void ) {\n\tchar cMsg[MAX_INFO_VALUE];\n\n\t// if we are pure we need to send back a command with our referenced pk3 checksums\n\tCom_sprintf(cMsg, sizeof(cMsg), \"cp %s\", FS_ReferencedPakPureChecksums());\n\n\tCL_AddReliableCommand( cMsg, qfalse );\n}\n\n/*\n=================\nCL_ResetPureClientAtServer\n=================\n*/\nvoid CL_ResetPureClientAtServer( void ) {\n\tCL_AddReliableCommand( \"vdr\", qfalse );\n}\n\n/*\n=================\nCL_Vid_Restart_f\n\nRestart the video subsystem\n\nwe also have to reload the UI and CGame because the renderer\ndoesn't know what graphics to reload\n=================\n*/\nextern bool g_nOverrideChecked;\nvoid CL_Vid_Restart_f( void ) {\n\t// Settings may have changed so stop recording now\n\tif( CL_VideoRecording( ) ) {\n\t\tCL_CloseAVI( );\n\t}\n\n\tif(clc.demorecording)\n\t\tCL_StopRecord_f();\n\n\t//rww - sort of nasty, but when a user selects a mod\n\t//from the menu all it does is a vid_restart, so we\n\t//have to check for new net overrides for the mod then.\n\tg_nOverrideChecked = false;\n\n\t// don't let them loop during the restart\n\tS_StopAllSounds();\n\t// shutdown the UI\n\tCL_ShutdownUI();\n\t// shutdown the CGame\n\tCL_ShutdownCGame();\n\t// shutdown the renderer and clear the renderer interface\n\tCL_ShutdownRef( qtrue );\n\t// client is no longer pure untill new checksums are sent\n\tCL_ResetPureClientAtServer();\n\t// clear pak references\n\tFS_ClearPakReferences( FS_UI_REF | FS_CGAME_REF );\n\t// reinitialize the filesystem if the game directory or checksum has changed\n\tFS_ConditionalRestart( clc.checksumFeed );\n\n\tcls.rendererStarted = qfalse;\n\tcls.uiStarted = qfalse;\n\tcls.cgameStarted = qfalse;\n\tcls.soundRegistered = qfalse;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n\n\t// if not running a server clear the whole hunk\n\tif ( !com_sv_running->integer ) {\n\t\tCM_ClearMap();\n\t\t// clear the whole hunk\n\t\tHunk_Clear();\n\t}\n\telse {\n\t\t// clear all the client data on the hunk\n\t\tHunk_ClearToMark();\n\t}\n\n\t// initialize the renderer interface\n\tCL_InitRef();\n\n\t// startup all the client stuff\n\tCL_StartHunkUsers();\n\n\t// start the cgame if connected\n\tif ( cls.state > CA_CONNECTED && cls.state != CA_CINEMATIC ) {\n\t\tcls.cgameStarted = qtrue;\n\t\tCL_InitCGame();\n\t\t// send pure checksums\n\t\tCL_SendPureChecksums();\n\t}\n}\n\n/*\n=================\nCL_Snd_Restart_f\n\nRestart the sound subsystem\nThe cgame and game must also be forced to restart because\nhandles will be invalid\n=================\n*/\n// extern void S_UnCacheDynamicMusic( void );\nvoid CL_Snd_Restart_f( void ) {\n\tS_Shutdown();\n\tS_Init();\n\n//\tS_FreeAllSFXMem();\t\t\t// These two removed by BTO (VV)\n//\tS_UnCacheDynamicMusic();\t// S_Shutdown() already does this!\n\n//\tCL_Vid_Restart_f();\n\n\textern qboolean\ts_soundMuted;\n\ts_soundMuted = qfalse;\t\t// we can play again\n\n\textern void S_RestartMusic( void );\n\tS_RestartMusic();\n}\n\n\n/*\n==================\nCL_PK3List_f\n==================\n*/\nvoid CL_OpenedPK3List_f( void ) {\n\tCom_Printf(\"Opened PK3 Names: %s\\n\", FS_LoadedPakNames());\n}\n\n/*\n==================\nCL_PureList_f\n==================\n*/\nvoid CL_ReferencedPK3List_f( void ) {\n\tCom_Printf(\"Referenced PK3 Names: %s\\n\", FS_ReferencedPakNames());\n}\n\n/*\n==================\nCL_Configstrings_f\n==================\n*/\nvoid CL_Configstrings_f( void ) {\n\tint\t\ti;\n\tint\t\tofs;\n\n\tif ( cls.state != CA_ACTIVE ) {\n\t\tCom_Printf( \"Not connected to a server.\\n\");\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {\n\t\tofs = cl.gameState.stringOffsets[ i ];\n\t\tif ( !ofs ) {\n\t\t\tcontinue;\n\t\t}\n\t\tCom_Printf( \"%4i: %s\\n\", i, cl.gameState.stringData + ofs );\n\t}\n}\n\n/*\n==============\nCL_Clientinfo_f\n==============\n*/\nvoid CL_Clientinfo_f( void ) {\n\tCom_Printf( \"--------- Client Information ---------\\n\" );\n\tCom_Printf( \"state: %i\\n\", cls.state );\n\tCom_Printf( \"Server: %s\\n\", cls.servername );\n\tCom_Printf (\"User info settings:\\n\");\n\tInfo_Print( Cvar_InfoString( CVAR_USERINFO ) );\n\tCom_Printf( \"--------------------------------------\\n\" );\n}\n\n\n//====================================================================\n\n/*\n=================\nCL_DownloadsComplete\n\nCalled when all downloading has been completed\n=================\n*/\nvoid CL_DownloadsComplete( void ) {\n\n\t// if we downloaded files we need to restart the file system\n\tif (clc.downloadRestart) {\n\t\tclc.downloadRestart = qfalse;\n\n\t\tFS_Restart(clc.checksumFeed); // We possibly downloaded a pak, restart the file system to load it\n\n\t\t// inform the server so we get new gamestate info\n\t\tCL_AddReliableCommand( \"donedl\", qfalse );\n\n\t\t// by sending the donedl command we request a new gamestate\n\t\t// so we don't want to load stuff yet\n\t\treturn;\n\t}\n\n\t// let the client game init and load data\n\tcls.state = CA_LOADING;\n\n\t// Pump the loop, this may change gamestate!\n\tCom_EventLoop();\n\n\t// if the gamestate was changed by calling Com_EventLoop\n\t// then we loaded everything already and we don't want to do it again.\n\tif ( cls.state != CA_LOADING ) {\n\t\treturn;\n\t}\n\n\t// starting to load a map so we get out of full screen ui mode\n\tCvar_Set(\"r_uiFullScreen\", \"0\");\n\n\t// flush client memory and start loading stuff\n\t// this will also (re)load the UI\n\t// if this is a local client then only the client part of the hunk\n\t// will be cleared, note that this is done after the hunk mark has been set\n\tCL_FlushMemory();\n\n\t// initialize the CGame\n\tcls.cgameStarted = qtrue;\n\tCL_InitCGame();\n\n\t// set pure checksums\n\tCL_SendPureChecksums();\n\n\tCL_WritePacket();\n\tCL_WritePacket();\n\tCL_WritePacket();\n}\n\n/*\n=================\nCL_BeginDownload\n\nRequests a file to download from the server.  Stores it in the current\ngame directory.\n=================\n*/\n\nvoid CL_BeginDownload( const char *localName, const char *remoteName ) {\n\n\tCom_DPrintf(\"***** CL_BeginDownload *****\\n\"\n\t\t\t\t\"Localname: %s\\n\"\n\t\t\t\t\"Remotename: %s\\n\"\n\t\t\t\t\"****************************\\n\", localName, remoteName);\n\n\tQ_strncpyz ( clc.downloadName, localName, sizeof(clc.downloadName) );\n\tCom_sprintf( clc.downloadTempName, sizeof(clc.downloadTempName), \"%s.tmp\", localName );\n\n\t// Set so UI gets access to it\n\tCvar_Set( \"cl_downloadName\", remoteName );\n\tCvar_Set( \"cl_downloadSize\", \"0\" );\n\tCvar_Set( \"cl_downloadCount\", \"0\" );\n\tCvar_SetValue( \"cl_downloadTime\", (float) cls.realtime );\n\n\tclc.downloadBlock = 0; // Starting new file\n\tclc.downloadCount = 0;\n\n\tCL_AddReliableCommand( va(\"download %s\", remoteName), qfalse );\n}\n\n/*\n=================\nCL_NextDownload\n\nA download completed or failed\n=================\n*/\nvoid CL_NextDownload(void) {\n\tchar *s;\n\tchar *remoteName, *localName;\n\n\t// A download has finished, check whether this matches a referenced checksum\n\tif(*clc.downloadName)\n\t{\n\t\tchar *zippath = FS_BuildOSPath(Cvar_VariableString(\"fs_homepath\"), clc.downloadName, \"\");\n\t\tzippath[strlen(zippath)-1] = '\\0';\n\n\t\tif(!FS_CompareZipChecksum(zippath))\n\t\t\tCom_Error(ERR_DROP, \"Incorrect checksum for file: %s\", clc.downloadName);\n\t}\n\n\t*clc.downloadTempName = *clc.downloadName = 0;\n\tCvar_Set(\"cl_downloadName\", \"\");\n\n\t// We are looking to start a download here\n\tif (*clc.downloadList) {\n\t\ts = clc.downloadList;\n\n\t\t// format is:\n\t\t//  @remotename@localname@remotename@localname, etc.\n\n\t\tif (*s == '@')\n\t\t\ts++;\n\t\tremoteName = s;\n\n\t\tif ( (s = strchr(s, '@')) == NULL ) {\n\t\t\tCL_DownloadsComplete();\n\t\t\treturn;\n\t\t}\n\n\t\t*s++ = 0;\n\t\tlocalName = s;\n\t\tif ( (s = strchr(s, '@')) != NULL )\n\t\t\t*s++ = 0;\n\t\telse\n\t\t\ts = localName + strlen(localName); // point at the nul byte\n\n\t\tif (!cl_allowDownload->integer) {\n\t\t\tCom_Error(ERR_DROP, \"UDP Downloads are disabled on your client. (cl_allowDownload is %d)\", cl_allowDownload->integer);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tCL_BeginDownload( localName, remoteName );\n\t\t}\n\n\t\tclc.downloadRestart = qtrue;\n\n\t\t// move over the rest\n\t\tmemmove( clc.downloadList, s, strlen(s) + 1);\n\n\t\treturn;\n\t}\n\n\tCL_DownloadsComplete();\n}\n\n/*\n=================\nCL_InitDownloads\n\nAfter receiving a valid game state, we valid the cgame and local zip files here\nand determine if we need to download them\n=================\n*/\nvoid CL_InitDownloads(void) {\n  char missingfiles[1024];\n\n\tif ( !cl_allowDownload->integer )\n\t{\n\t\t// autodownload is disabled on the client\n\t\t// but it's possible that some referenced files on the server are missing\n\t\tif (FS_ComparePaks( missingfiles, sizeof( missingfiles ), qfalse ) )\n\t\t{\n\t\t\t// NOTE TTimo I would rather have that printed as a modal message box\n\t\t\t//   but at this point while joining the game we don't know wether we will successfully join or not\n\t\t\tCom_Printf( \"\\nWARNING: You are missing some files referenced by the server:\\n%s\"\n\t\t\t\t\"You might not be able to join the game\\n\"\n\t\t\t\t\"Go to the setting menu to turn on autodownload, or get the file elsewhere\\n\\n\", missingfiles );\n\t\t}\n\t}\n\telse if ( FS_ComparePaks( clc.downloadList, sizeof( clc.downloadList ) , qtrue ) ) {\n\n\t\tCom_Printf(\"Need paks: %s\\n\", clc.downloadList );\n\n\t\tif ( *clc.downloadList ) {\n\t\t\t// if autodownloading is not enabled on the server\n\t\t\tcls.state = CA_CONNECTED;\n\n\t\t\t*clc.downloadTempName = *clc.downloadName = 0;\n\t\t\tCvar_Set( \"cl_downloadName\", \"\" );\n\n\t\t\tCL_NextDownload();\n\t\t\treturn;\n\t\t}\n\n\t}\n\tCL_DownloadsComplete();\n}\n\n/*\n=================\nCL_CheckForResend\n\nResend a connect message if the last one has timed out\n=================\n*/\nvoid CL_CheckForResend( void ) {\n\tint\t\tport;\n\tchar\tinfo[MAX_INFO_STRING];\n\tchar\tdata[MAX_INFO_STRING+10];\n\n\t// don't send anything if playing back a demo\n\tif ( clc.demoplaying ) {\n\t\treturn;\n\t}\n\n\t// resend if we haven't gotten a reply yet\n\tif ( cls.state != CA_CONNECTING && cls.state != CA_CHALLENGING ) {\n\t\treturn;\n\t}\n\n\tif ( cls.realtime - clc.connectTime < RETRANSMIT_TIMEOUT ) {\n\t\treturn;\n\t}\n\n\tclc.connectTime = cls.realtime;\t// for retransmit requests\n\tclc.connectPacketCount++;\n\n\n\tswitch ( cls.state ) {\n\tcase CA_CONNECTING:\n\t\t// requesting a challenge\n\n\t\t// The challenge request shall be followed by a client challenge so no malicious server can hijack this connection.\n\t\tCom_sprintf(data, sizeof(data), \"getchallenge %d\", clc.challenge);\n\n\t\tNET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, data);\n\t\tbreak;\n\n\tcase CA_CHALLENGING:\n\t\t// sending back the challenge\n\t\tport = (int) Cvar_VariableValue (\"net_qport\");\n\n\t\tQ_strncpyz( info, Cvar_InfoString( CVAR_USERINFO ), sizeof( info ) );\n\t\tInfo_SetValueForKey( info, \"protocol\", va(\"%i\", PROTOCOL_VERSION ) );\n\t\tInfo_SetValueForKey( info, \"qport\", va(\"%i\", port ) );\n\t\tInfo_SetValueForKey( info, \"challenge\", va(\"%i\", clc.challenge ) );\n\n\t\tCom_sprintf(data, sizeof(data), \"connect \\\"%s\\\"\", info );\n\t\tNET_OutOfBandData( NS_CLIENT, clc.serverAddress, (byte *)data, strlen(data) );\n\n\t\t// the most current userinfo has been sent, so watch for any\n\t\t// newer changes to userinfo variables\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tbreak;\n\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"CL_CheckForResend: bad cls.state\" );\n\t}\n}\n\n\n/*\n===================\nCL_DisconnectPacket\n\nSometimes the server can drop the client and the netchan based\ndisconnect can be lost.  If the client continues to send packets\nto the server, the server will send out of band disconnect packets\nto the client so it doesn't have to wait for the full timeout period.\n===================\n*/\nvoid CL_DisconnectPacket( netadr_t from ) {\n\tif ( cls.state < CA_AUTHORIZING ) {\n\t\treturn;\n\t}\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\treturn;\n\t}\n\n\t// if we have received packets within three seconds, ignore it\n\t// (it might be a malicious spoof)\n\tif ( cls.realtime - clc.lastPacketTime < 3000 ) {\n\t\treturn;\n\t}\n\n\t// drop the connection (FIXME: connection dropped dialog)\n\tCom_Printf( \"Server disconnected for unknown reason\\n\" );\n\n\tCL_Disconnect( qtrue );\n}\n\n\n/*\n===================\nCL_MotdPacket\n\n===================\n*/\nvoid CL_MotdPacket( netadr_t from ) {\n\tchar\t*challenge;\n\tchar\t*info;\n\n\t// if not from our server, ignore it\n\tif ( !NET_CompareAdr( from, cls.updateServer ) ) {\n\t\treturn;\n\t}\n\n\tinfo = Cmd_Argv(1);\n\n\t// check challenge\n\tchallenge = Info_ValueForKey( info, \"challenge\" );\n\tif ( strcmp( challenge, cls.updateChallenge ) ) {\n\t\treturn;\n\t}\n\n\tchallenge = Info_ValueForKey( info, \"motd\" );\n\n\tQ_strncpyz( cls.updateInfoString, info, sizeof( cls.updateInfoString ) );\n\tCvar_Set( \"cl_motdString\", challenge );\n}\n\n/*\n===================\nCL_InitServerInfo\n===================\n*/\nvoid CL_InitServerInfo( serverInfo_t *server, netadr_t *address ) {\n\tserver->adr = *address;\n\tserver->clients = 0;\n\tserver->hostName[0] = '\\0';\n\tserver->mapName[0] = '\\0';\n\tserver->maxClients = 0;\n\tserver->maxPing = 0;\n\tserver->minPing = 0;\n\tserver->netType = 0;\n\tserver->needPassword = qfalse;\n\tserver->trueJedi = 0;\n\tserver->weaponDisable = 0;\n\tserver->forceDisable = 0;\n\tserver->ping = -1;\n\tserver->game[0] = '\\0';\n\tserver->gameType = 0;\n\tserver->humans = server->bots = 0;\n}\n\n#define MAX_SERVERSPERPACKET\t256\n\n/*\n===================\nCL_ServersResponsePacket\n===================\n*/\nvoid CL_ServersResponsePacket( const netadr_t *from, msg_t *msg ) {\n\tint\t\t\t\ti, j, count, total;\n\tnetadr_t addresses[MAX_SERVERSPERPACKET];\n\tint\t\t\t\tnumservers;\n\tbyte*\t\t\tbuffptr;\n\tbyte*\t\t\tbuffend;\n\n\tCom_Printf(\"CL_ServersResponsePacket\\n\");\n\n\tif (cls.numglobalservers == -1) {\n\t\t// state to detect lack of servers or lack of response\n\t\tcls.numglobalservers = 0;\n\t\tcls.numGlobalServerAddresses = 0;\n\t}\n\n\t// parse through server response string\n\tnumservers = 0;\n\tbuffptr    = msg->data;\n\tbuffend    = buffptr + msg->cursize;\n\n\t// advance to initial token\n\tdo\n\t{\n\t\tif(*buffptr == '\\\\')\n\t\t\tbreak;\n\n\t\tbuffptr++;\n\t} while (buffptr < buffend);\n\n\twhile (buffptr + 1 < buffend)\n\t{\n\t\t// IPv4 address\n\t\tif (*buffptr == '\\\\')\n\t\t{\n\t\t\tbuffptr++;\n\n\t\t\tif (buffend - buffptr < (int)(sizeof(addresses[numservers].ip) + sizeof(addresses[numservers].port) + 1))\n\t\t\t\tbreak;\n\n\t\t\tfor(size_t i = 0; i < sizeof(addresses[numservers].ip); i++)\n\t\t\t\taddresses[numservers].ip[i] = *buffptr++;\n\n\t\t\taddresses[numservers].type = NA_IP;\n\t\t}\n\t\telse\n\t\t\t// syntax error!\n\t\t\tbreak;\n\n\t\t// parse out port\n\t\taddresses[numservers].port = (*buffptr++) << 8;\n\t\taddresses[numservers].port += *buffptr++;\n\t\taddresses[numservers].port = BigShort( addresses[numservers].port );\n\n\t\t// syntax check\n\t\tif (*buffptr != '\\\\')\n\t\t\tbreak;\n\n\t\tnumservers++;\n\t\tif (numservers >= MAX_SERVERSPERPACKET)\n\t\t\tbreak;\n\t}\n\n\tcount = cls.numglobalservers;\n\n\tfor (i = 0; i < numservers && count < MAX_GLOBAL_SERVERS; i++) {\n\t\t// build net address\n\t\tserverInfo_t *server = &cls.globalServers[count];\n\n\t\t// Tequila: It's possible to have sent many master server requests. Then\n\t\t// we may receive many times the same addresses from the master server.\n\t\t// We just avoid to add a server if it is still in the global servers list.\n\t\tfor (j = 0; j < count; j++)\n\t\t{\n\t\t\tif (NET_CompareAdr(cls.globalServers[j].adr, addresses[i]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < count)\n\t\t\tcontinue;\n\n\t\tCL_InitServerInfo( server, &addresses[i] );\n\t\t// advance to next slot\n\t\tcount++;\n\t}\n\n\t// if getting the global list\n\tif ( count >= MAX_GLOBAL_SERVERS && cls.numGlobalServerAddresses < MAX_GLOBAL_SERVERS )\n\t{\n\t\t// if we couldn't store the servers in the main list anymore\n\t\tfor (; i < numservers && cls.numGlobalServerAddresses < MAX_GLOBAL_SERVERS; i++)\n\t\t{\n\t\t\t// just store the addresses in an additional list\n\t\t\tcls.globalServerAddresses[cls.numGlobalServerAddresses++] = addresses[i];\n\t\t}\n\t}\n\n\tcls.numglobalservers = count;\n\ttotal = count + cls.numGlobalServerAddresses;\n\n\tCom_Printf(\"%d servers parsed (total %d)\\n\", numservers, total);\n}\n\n#ifndef MAX_STRINGED_SV_STRING\n#define MAX_STRINGED_SV_STRING 1024\n#endif\nstatic void CL_CheckSVStringEdRef(char *buf, const char *str)\n{ //I don't really like doing this. But it utilizes the system that was already in place.\n\tint i = 0;\n\tint b = 0;\n\tint strLen = 0;\n\tqboolean gotStrip = qfalse;\n\n\tif (!str || !str[0])\n\t{\n\t\tif (str)\n\t\t{\n\t\t\tstrcpy(buf, str);\n\t\t}\n\t\treturn;\n\t}\n\n\tstrcpy(buf, str);\n\n\tstrLen = strlen(str);\n\n\tif (strLen >= MAX_STRINGED_SV_STRING)\n\t{\n\t\treturn;\n\t}\n\n\twhile (i < strLen && str[i])\n\t{\n\t\tgotStrip = qfalse;\n\n\t\tif (str[i] == '@' && (i+1) < strLen)\n\t\t{\n\t\t\tif (str[i+1] == '@' && (i+2) < strLen)\n\t\t\t{\n\t\t\t\tif (str[i+2] == '@' && (i+3) < strLen)\n\t\t\t\t{ //@@@ should mean to insert a stringed reference here, so insert it into buf at the current place\n\t\t\t\t\tchar stripRef[MAX_STRINGED_SV_STRING];\n\t\t\t\t\tint r = 0;\n\n\t\t\t\t\twhile (i < strLen && str[i] == '@')\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (i < strLen && str[i] && str[i] != ' ' && str[i] != ':' && str[i] != '.' && str[i] != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tstripRef[r] = str[i];\n\t\t\t\t\t\tr++;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tstripRef[r] = 0;\n\n\t\t\t\t\tbuf[b] = 0;\n\t\t\t\t\tQ_strcat(buf, MAX_STRINGED_SV_STRING, SE_GetString(va(\"MP_SVGAME_%s\", stripRef)));\n\t\t\t\t\tb = strlen(buf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!gotStrip)\n\t\t{\n\t\t\tbuf[b] = str[i];\n\t\t\tb++;\n\t\t}\n\t\ti++;\n\t}\n\n\tbuf[b] = 0;\n}\n\n\n/*\n=================\nCL_ConnectionlessPacket\n\nResponses to broadcasts, etc\n=================\n*/\nvoid CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tchar\t*c;\n\tint challenge = 0;\n\n\tMSG_BeginReadingOOB( msg );\n\tMSG_ReadLong( msg );\t// skip the -1\n\n\ts = MSG_ReadStringLine( msg );\n\n\tCmd_TokenizeString( s );\n\n\tc = Cmd_Argv(0);\n\n\tCom_DPrintf (\"CL packet %s: %s\\n\", NET_AdrToString(from), c);\n\n\t// challenge from the server we are connecting to\n\tif ( !Q_stricmp(c, \"challengeResponse\") )\n\t{\n\t\tif ( cls.state != CA_CONNECTING )\n\t\t{\n\t\t\tCom_Printf( \"Unwanted challenge response received.  Ignored.\\n\" );\n\t\t\treturn;\n\t\t}\n\n\t\tc = Cmd_Argv(2);\n\t\tif(*c)\n\t\t\tchallenge = atoi(c);\n\n\t\tif(!NET_CompareAdr(from, clc.serverAddress))\n\t\t{\n\t\t\t// This challenge response is not coming from the expected address.\n\t\t\t// Check whether we have a matching client challenge to prevent\n\t\t\t// connection hi-jacking.\n\n\t\t\tif(!*c || challenge != clc.challenge)\n\t\t\t{\n\t\t\t\tCom_DPrintf(\"Challenge response received from unexpected source. Ignored.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// start sending challenge response instead of challenge request packets\n\t\tclc.challenge = atoi(Cmd_Argv(1));\n\t\tcls.state = CA_CHALLENGING;\n\t\tclc.connectPacketCount = 0;\n\t\tclc.connectTime = -99999;\n\n\t\t// take this address as the new server address.  This allows\n\t\t// a server proxy to hand off connections to multiple servers\n\t\tclc.serverAddress = from;\n\t\tCom_DPrintf (\"challengeResponse: %d\\n\", clc.challenge);\n\t\treturn;\n\t}\n\n\t// server connection\n\tif ( !Q_stricmp(c, \"connectResponse\") ) {\n\t\tif ( cls.state >= CA_CONNECTED ) {\n\t\t\tCom_Printf (\"Dup connect received. Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( cls.state != CA_CHALLENGING ) {\n\t\t\tCom_Printf (\"connectResponse packet while not connecting. Ignored.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif ( !NET_CompareAdr( from, clc.serverAddress ) ) {\n\t\t\tCom_Printf( \"connectResponse from wrong address. Ignored.\\n\" );\n\t\t\treturn;\n\t\t}\n\t\tNetchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableValue( \"net_qport\" ) );\n\t\tcls.state = CA_CONNECTED;\n\t\tclc.lastPacketSentTime = -9999;\t\t// send first packet immediately\n\t\treturn;\n\t}\n\n\t// server responding to an info broadcast\n\tif ( !Q_stricmp(c, \"infoResponse\") ) {\n\t\tCL_ServerInfoPacket( from, msg );\n\t\treturn;\n\t}\n\n\t// server responding to a get playerlist\n\tif ( !Q_stricmp(c, \"statusResponse\") ) {\n\t\tCL_ServerStatusResponse( from, msg );\n\t\treturn;\n\t}\n\n\t// a disconnect message from the server, which will happen if the server\n\t// dropped the connection but it is still getting packets from us\n\tif (!Q_stricmp(c, \"disconnect\")) {\n\t\tCL_DisconnectPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !Q_stricmp(c, \"echo\") ) {\n\t\tNET_OutOfBandPrint( NS_CLIENT, from, \"%s\", Cmd_Argv(1) );\n\t\treturn;\n\t}\n\n\t// cd check\n\tif ( !Q_stricmp(c, \"keyAuthorize\") ) {\n\t\t// we don't use these now, so dump them on the floor\n\t\treturn;\n\t}\n\n\t// global MOTD from id\n\tif ( !Q_stricmp(c, \"motd\") ) {\n\t\tCL_MotdPacket( from );\n\t\treturn;\n\t}\n\n\t// echo request from server\n\tif ( !Q_stricmp(c, \"print\") )\n\t{\n\t\t// NOTE: we may have to add exceptions for auth and update servers\n\t\tif (NET_CompareAdr(from, clc.serverAddress) || NET_CompareAdr(from, rcon_address))\n\t\t{\n\t\t\tchar sTemp[MAX_STRINGED_SV_STRING];\n\n\t\t\ts = MSG_ReadString( msg );\n\t\t\tCL_CheckSVStringEdRef(sTemp, s);\n\t\t\tQ_strncpyz( clc.serverMessage, sTemp, sizeof( clc.serverMessage ) );\n\t\t\tCom_Printf( \"%s\", sTemp );\n\t\t}\n\t\treturn;\n\t}\n\n\t// list of servers sent back by a master server (classic)\n\tif ( !Q_strncmp(c, \"getserversResponse\", 18) ) {\n\t\tCL_ServersResponsePacket( &from, msg );\n\t\treturn;\n\t}\n\n\tCom_DPrintf (\"Unknown connectionless packet command.\\n\");\n}\n\n\n/*\n=================\nCL_PacketEvent\n\nA packet has arrived from the main event loop\n=================\n*/\nvoid CL_PacketEvent( netadr_t from, msg_t *msg ) {\n\tint\t\theaderBytes;\n\n\tclc.lastPacketTime = cls.realtime;\n\n\tif ( msg->cursize >= 4 && *(int *)msg->data == -1 ) {\n\t\tCL_ConnectionlessPacket( from, msg );\n\t\treturn;\n\t}\n\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\t\t// can't be a valid sequenced packet\n\t}\n\n\tif ( msg->cursize < 4 ) {\n\t\tCom_Printf (\"%s: Runt packet\\n\",NET_AdrToString( from ));\n\t\treturn;\n\t}\n\n\t//\n\t// packet from server\n\t//\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\tCom_DPrintf (\"%s:sequenced packet without connection\\n\"\n\t\t\t,NET_AdrToString( from ) );\n\t\t// FIXME: send a client disconnect?\n\t\treturn;\n\t}\n\n\tif (!CL_Netchan_Process( &clc.netchan, msg) ) {\n\t\treturn;\t\t// out of order, duplicated, etc\n\t}\n\n\t// the header is different lengths for reliable and unreliable messages\n\theaderBytes = msg->readcount;\n\n\t// track the last message received so it can be returned in\n\t// client messages, allowing the server to detect a dropped\n\t// gamestate\n\tclc.serverMessageSequence = LittleLong( *(int *)msg->data );\n\n\tclc.lastPacketTime = cls.realtime;\n\tCL_ParseServerMessage( msg );\n\n\t//\n\t// we don't know if it is ok to save a demo message until\n\t// after we have parsed the frame\n\t//\n\tif ( clc.demorecording && !clc.demowaiting ) {\n\t\tCL_WriteDemoMessage( msg, headerBytes );\n\t}\n}\n\n/*\n==================\nCL_CheckTimeout\n\n==================\n*/\nvoid CL_CheckTimeout( void ) {\n\t//\n\t// check timeout\n\t//\n\tif ( ( !CL_CheckPaused() || !sv_paused->integer )\n\t\t&& cls.state >= CA_CONNECTED && cls.state != CA_CINEMATIC\n\t    && cls.realtime - clc.lastPacketTime > cl_timeout->value*1000) {\n\t\tif (++cl.timeoutcount > 5) {\t// timeoutcount saves debugger\n\t\t\tconst char *psTimedOut = SE_GetString(\"MP_SVGAME_SERVER_CONNECTION_TIMED_OUT\");\n\t\t\tCom_Printf (\"\\n%s\\n\",psTimedOut);\n\t\t\tCom_Error(ERR_DROP, psTimedOut);\n\t\t\t//CL_Disconnect( qtrue );\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tcl.timeoutcount = 0;\n\t}\n}\n\n/*\n==================\nCL_CheckPaused\nCheck whether client has been paused.\n==================\n*/\nqboolean CL_CheckPaused(void)\n{\n\t// if cl_paused->modified is set, the cvar has only been changed in\n\t// this frame. Keep paused in this frame to ensure the server doesn't\n\t// lag behind.\n\tif(cl_paused->integer || cl_paused->modified)\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n//============================================================================\n\n/*\n==================\nCL_CheckUserinfo\n\n==================\n*/\nvoid CL_CheckUserinfo( void ) {\n\t// don't add reliable commands when not yet connected\n\tif ( cls.state < CA_CONNECTED ) {\n\t\treturn;\n\t}\n\t// don't overflow the reliable command buffer when paused\n\tif ( CL_CheckPaused() ) {\n\t\treturn;\n\t}\n\t// send a reliable userinfo update if needed\n\tif ( cvar_modifiedFlags & CVAR_USERINFO ) {\n\t\tcvar_modifiedFlags &= ~CVAR_USERINFO;\n\t\tCL_AddReliableCommand( va(\"userinfo \\\"%s\\\"\", Cvar_InfoString( CVAR_USERINFO ) ), qfalse );\n\t}\n\n}\n\n/*\n==================\nCL_Frame\n\n==================\n*/\nstatic unsigned int frameCount;\nstatic float avgFrametime=0.0;\nextern void SE_CheckForLanguageUpdates(void);\nvoid CL_Frame ( int msec ) {\n\tqboolean takeVideoFrame = qfalse;\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tSE_CheckForLanguageUpdates();\t// will take zero time to execute unless language changes, then will reload strings.\n\t\t\t\t\t\t\t\t\t//\tof course this still doesn't work for menus...\n\n\tif ( cls.state == CA_DISCONNECTED && !( Key_GetCatcher( ) & KEYCATCH_UI )\n\t\t&& !com_sv_running->integer && cls.uiStarted ) {\n\t\t// if disconnected, bring up the menu\n\t\tS_StopAllSounds();\n\t\tUIVM_SetActiveMenu( UIMENU_MAIN );\n\t}\n\n\t// if recording an avi, lock to a fixed fps\n\tif ( CL_VideoRecording( ) && cl_aviFrameRate->integer && msec) {\n\t\tif ( cls.state == CA_ACTIVE || cl_forceavidemo->integer) {\n\t\t\tfloat fps = Q_min(cl_aviFrameRate->value * com_timescale->value, 1000.0f);\n\t\t\tfloat frameDuration = Q_max(1000.0f / fps, 1.0f) + clc.aviVideoFrameRemainder;\n\t\t\ttakeVideoFrame = qtrue;\n\n\t\t\tmsec = (int)frameDuration;\n\t\t\tclc.aviVideoFrameRemainder = frameDuration - msec;\n\t\t}\n\t}\n\n\t// save the msec before checking pause\n\tcls.realFrametime = msec;\n\n\t// decide the simulation time\n\tcls.frametime = msec;\n\tif(cl_framerate->integer)\n\t{\n\t\tavgFrametime+=msec;\n\t\tchar mess[256];\n\t\tif(!(frameCount&0x1f))\n\t\t{\n\t\t\tCom_sprintf(mess,sizeof(mess),\"Frame rate=%f\\n\\n\",1000.0f*(1.0/(avgFrametime/32.0f)));\n\t//\t\tCom_OPrintf(\"%s\", mess);\n\t\t\tCom_Printf(\"%s\", mess);\n\t\t\tavgFrametime=0.0f;\n\t\t}\n\t\tframeCount++;\n\t}\n\n\tcls.realtime += cls.frametime;\n\n\tif ( cl_timegraph->integer ) {\n\t\tSCR_DebugGraph ( cls.realFrametime * 0.25, 0 );\n\t}\n\n\t// see if we need to update any userinfo\n\tCL_CheckUserinfo();\n\n\t// if we haven't gotten a packet in a long time,\n\t// drop the connection\n\tCL_CheckTimeout();\n\n\t// send intentions now\n\tCL_SendCmd();\n\n\t// resend a connection request if necessary\n\tCL_CheckForResend();\n\n\t// decide on the serverTime to render\n\tCL_SetCGameTime();\n\n\t// update the screen\n\tSCR_UpdateScreen();\n\n\t// update audio\n\tS_Update();\n\n\t// advance local effects for next frame\n\tSCR_RunCinematic();\n\n\tCon_RunConsole();\n\n\t// reset the heap for Ghoul2 vert transform space gameside\n\tif (G2VertSpaceServer)\n\t{\n\t\tG2VertSpaceServer->ResetHeap();\n\t}\n\n\tcls.framecount++;\n\n\tif ( takeVideoFrame ) {\n\t\t// save the current screen\n\t\tCL_TakeVideoFrame( );\n\t}\n}\n\n\n//============================================================================\n\n/*\n================\nCL_RefPrintf\n\nDLL glue\n================\n*/\nvoid QDECL CL_RefPrintf( int print_level, const char *fmt, ...) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf(msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tif ( print_level == PRINT_ALL ) {\n\t\tCom_Printf (\"%s\", msg);\n\t} else if ( print_level == PRINT_WARNING ) {\n\t\tCom_Printf (S_COLOR_YELLOW \"%s\", msg);\t\t// yellow\n\t} else if ( print_level == PRINT_DEVELOPER ) {\n\t\tCom_DPrintf (S_COLOR_RED \"%s\", msg);\t\t// red\n\t}\n}\n\n\n\n/*\n============\nCL_ShutdownRef\n============\n*/\nstatic void CL_ShutdownRef( qboolean restarting ) {\n\tif ( re )\n\t{\n\t\tif ( re->Shutdown )\n\t\t{\n\t\t\tre->Shutdown( qtrue, restarting );\n\t\t}\n\t}\n\n\tre = NULL;\n\n\tif ( rendererLib != NULL ) {\n\t\tSys_UnloadDll (rendererLib);\n\t\trendererLib = NULL;\n\t}\n}\n\n/*\n============\nCL_InitRenderer\n============\n*/\nvoid CL_InitRenderer( void ) {\n\t// this sets up the renderer and calls R_Init\n\tre->BeginRegistration( &cls.glconfig );\n\n\t// load character sets\n\tcls.charSetShader = re->RegisterShaderNoMip(\"gfx/2d/charsgrid_med\");\n\n\tcls.whiteShader = re->RegisterShader( \"white\" );\n\tcls.consoleShader = re->RegisterShader( \"console\" );\n\tg_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;\n\tg_consoleField.widthInChars = g_console_field_width;\n}\n\n/*\n============================\nCL_StartHunkUsers\n\nAfter the server has cleared the hunk, these will need to be restarted\nThis is the only place that any of these functions are called from\n============================\n*/\nvoid CL_StartHunkUsers( void ) {\n\tif (!com_cl_running) {\n\t\treturn;\n\t}\n\n\tif ( !com_cl_running->integer ) {\n\t\treturn;\n\t}\n\n\tif ( !cls.rendererStarted ) {\n\t\tcls.rendererStarted = qtrue;\n\t\tCL_InitRenderer();\n\t}\n\n\tif ( !cls.soundStarted ) {\n\t\tcls.soundStarted = qtrue;\n\t\tS_Init();\n\t}\n\n\tif ( !cls.soundRegistered ) {\n\t\tcls.soundRegistered = qtrue;\n\t\tS_BeginRegistration();\n\t}\n\n\tif ( !cls.uiStarted ) {\n\t\tcls.uiStarted = qtrue;\n\t\tCL_InitUI();\n\t}\n}\n\n/*\n============\nCL_InitRef\n============\n*/\nqboolean Com_TheHunkMarkHasBeenMade(void);\n\n//qcommon/cm_load.cpp\nextern void *gpvCachedMapDiskImage;\nextern qboolean gbUsingCachedMapDataRightNow;\n\nstatic char *GetSharedMemory( void ) { return cl.mSharedMemory; }\nstatic vm_t *GetCurrentVM( void ) { return currentVM; }\nstatic qboolean CGVMLoaded( void ) { return (qboolean)cls.cgameStarted; }\nstatic void *CM_GetCachedMapDiskImage( void ) { return gpvCachedMapDiskImage; }\nstatic void CM_SetCachedMapDiskImage( void *ptr ) { gpvCachedMapDiskImage = ptr; }\nstatic void CM_SetUsingCache( qboolean usingCache ) { gbUsingCachedMapDataRightNow = usingCache; }\n\n#define G2_VERT_SPACE_SERVER_SIZE 256\nIHeapAllocator *G2VertSpaceServer = NULL;\nCMiniHeap IHeapAllocator_singleton(G2_VERT_SPACE_SERVER_SIZE * 1024);\n\nstatic IHeapAllocator *GetG2VertSpaceServer( void ) {\n\treturn G2VertSpaceServer;\n}\n\n#define DEFAULT_RENDER_LIBRARY \"rd-vanilla\"\n\nvoid CL_InitRef( void ) {\n\tstatic refimport_t ri;\n\trefexport_t\t*ret;\n\tGetRefAPI_t\tGetRefAPI;\n\tchar\t\tdllName[MAX_OSPATH];\n\n\tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n\n\tcl_renderer = Cvar_Get( \"cl_renderer\", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED, \"Which renderer library to use\" );\n\n\tCom_sprintf( dllName, sizeof( dllName ), \"%s_\" ARCH_STRING DLL_EXT, cl_renderer->string );\n\n\tif( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) )\n\t{\n\t\tCom_Printf( \"failed: trying to load fallback renderer\\n\" );\n\t\tCvar_ForceReset( \"cl_renderer\" );\n\n\t\tCom_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY \"_\" ARCH_STRING DLL_EXT );\n\t\trendererLib = Sys_LoadDll( dllName, qfalse );\n\t}\n\n\tif ( !rendererLib ) {\n\t\tCom_Error( ERR_FATAL, \"Failed to load renderer\\n\" );\n\t}\n\n\tmemset( &ri, 0, sizeof( ri ) );\n\n\tGetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, \"GetRefAPI\" );\n\tif ( !GetRefAPI )\n\t\tCom_Error( ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\", Sys_LibraryError() );\n\n\t//set up the import table\n\tri.Printf = CL_RefPrintf;\n\tri.Error = Com_Error;\n\tri.OPrintf = Com_OPrintf;\n\tri.Milliseconds = Sys_Milliseconds2; //FIXME: unix+mac need this\n\tri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;\n\tri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;\n\tri.Hunk_Alloc = Hunk_Alloc;\n\tri.Hunk_MemoryRemaining = Hunk_MemoryRemaining;\n\tri.Z_Malloc = Z_Malloc;\n\tri.Z_Free = Z_Free;\n\tri.Z_MemSize = Z_MemSize;\n\tri.Z_MorphMallocTag = Z_MorphMallocTag;\n\tri.Cmd_ExecuteString = Cmd_ExecuteString;\n\tri.Cmd_Argc = Cmd_Argc;\n\tri.Cmd_Argv = Cmd_Argv;\n\tri.Cmd_ArgsBuffer = Cmd_ArgsBuffer;\n\tri.Cmd_AddCommand = Cmd_AddCommand;\n\tri.Cmd_RemoveCommand = Cmd_RemoveCommand;\n\tri.Cvar_Set = Cvar_Set;\n\tri.Cvar_Get = Cvar_Get;\n\tri.Cvar_SetValue = Cvar_SetValue;\n\tri.Cvar_CheckRange = Cvar_CheckRange;\n\tri.Cvar_VariableStringBuffer = Cvar_VariableStringBuffer;\n\tri.Cvar_VariableString = Cvar_VariableString;\n\tri.Cvar_VariableValue = Cvar_VariableValue;\n\tri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;\n\tri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;\n\tri.SE_GetString = SE_GetString;\n\tri.FS_FreeFile = FS_FreeFile;\n\tri.FS_FreeFileList = FS_FreeFileList;\n\tri.FS_Read = FS_Read;\n\tri.FS_ReadFile = FS_ReadFile;\n\tri.FS_FCloseFile = FS_FCloseFile;\n\tri.FS_FOpenFileRead = FS_FOpenFileRead;\n\tri.FS_FOpenFileWrite = FS_FOpenFileWrite;\n\tri.FS_FOpenFileByMode = FS_FOpenFileByMode;\n\tri.FS_FileExists = FS_FileExists;\n\tri.FS_FileIsInPAK = FS_FileIsInPAK;\n\tri.FS_ListFiles = FS_ListFiles;\n\tri.FS_Write = FS_Write;\n\tri.FS_WriteFile = FS_WriteFile;\n\tri.CM_BoxTrace = CM_BoxTrace;\n\tri.CM_DrawDebugSurface = CM_DrawDebugSurface;\n\tri.CM_CullWorldBox = CM_CullWorldBox;\n\tri.CM_ClusterPVS = CM_ClusterPVS;\n\tri.CM_LeafArea = CM_LeafArea;\n\tri.CM_LeafCluster = CM_LeafCluster;\n\tri.CM_PointLeafnum = CM_PointLeafnum;\n\tri.CM_PointContents = CM_PointContents;\n\tri.Com_TheHunkMarkHasBeenMade = Com_TheHunkMarkHasBeenMade;\n\tri.S_RestartMusic = S_RestartMusic;\n\tri.SND_RegisterAudio_LevelLoadEnd = SND_RegisterAudio_LevelLoadEnd;\n\tri.CIN_RunCinematic = CIN_RunCinematic;\n\tri.CIN_PlayCinematic = CIN_PlayCinematic;\n\tri.CIN_UploadCinematic = CIN_UploadCinematic;\n\tri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;\n\n\t// g2 data access\n\tri.GetSharedMemory = GetSharedMemory;\n\n\t// (c)g vm callbacks\n\tri.GetCurrentVM = GetCurrentVM;\n\tri.CGVMLoaded = CGVMLoaded;\n\tri.CGVM_RagCallback = CGVM_RagCallback;\n\n    ri.WIN_Init = WIN_Init;\n\tri.WIN_SetGamma = WIN_SetGamma;\n    ri.WIN_Shutdown = WIN_Shutdown;\n    ri.WIN_Present = WIN_Present;\n\tri.GL_GetProcAddress = WIN_GL_GetProcAddress;\n\tri.GL_ExtensionSupported = WIN_GL_ExtensionSupported;\n\n\tri.CM_GetCachedMapDiskImage = CM_GetCachedMapDiskImage;\n\tri.CM_SetCachedMapDiskImage = CM_SetCachedMapDiskImage;\n\tri.CM_SetUsingCache = CM_SetUsingCache;\n\n\t//FIXME: Might have to do something about this...\n\tri.GetG2VertSpaceServer = GetG2VertSpaceServer;\n\tG2VertSpaceServer = &IHeapAllocator_singleton;\n\n\tri.PD_Store = PD_Store;\n\tri.PD_Load = PD_Load;\n\n\tret = GetRefAPI( REF_API_VERSION, &ri );\n\n//\tCom_Printf( \"-------------------------------\\n\");\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = ret;\n\n\t// unpause so the cgame definately gets a snapshot and renders a frame\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n\n\n//===========================================================================================\n\n#define MODEL_CHANGE_DELAY 5000\nint gCLModelDelay = 0;\n\nvoid CL_SetModel_f( void ) {\n\tchar\t*arg;\n\tchar\tname[256];\n\n\targ = Cmd_Argv( 1 );\n\tif (arg[0])\n\t{\n\t\t/*\n\t\t//If you wanted to be foolproof you would put this on the server I guess. But that\n\t\t//tends to put things out of sync regarding cvar status. And I sort of doubt someone\n\t\t//is going to write a client and figure out the protocol so that they can annoy people\n\t\t//by changing models real fast.\n\t\tint curTime = Com_Milliseconds();\n\t\tif (gCLModelDelay > curTime)\n\t\t{\n\t\t\tCom_Printf(\"You can only change your model every %i seconds.\\n\", (MODEL_CHANGE_DELAY/1000));\n\t\t\treturn;\n\t\t}\n\n\t\tgCLModelDelay = curTime + MODEL_CHANGE_DELAY;\n\t\t*/\n\t\t//rwwFIXMEFIXME: This is currently broken and doesn't seem to work for connecting clients\n\t\tCvar_Set( \"model\", arg );\n\t}\n\telse\n\t{\n\t\tCvar_VariableStringBuffer( \"model\", name, sizeof(name) );\n\t\tCom_Printf(\"model is set to %s\\n\", name);\n\t}\n}\n\nvoid CL_SetForcePowers_f( void ) {\n\treturn;\n}\n\n/*\n==================\nCL_VideoFilename\n==================\n*/\nvoid CL_VideoFilename( char *buf, int bufSize ) {\n\ttime_t rawtime;\n\tchar timeStr[32] = {0}; // should really only reach ~19 chars\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\n\tCom_sprintf( buf, bufSize, \"videos/video%s.avi\", timeStr );\n}\n\n/*\n===============\nCL_Video_f\n\nvideo\nvideo [filename]\n===============\n*/\nvoid CL_Video_f( void )\n{\n\tchar  filename[ MAX_OSPATH ];\n\n\tif( !clc.demoplaying )\n\t{\n\t\tCom_Printf( \"The video command can only be used when playing back demos\\n\" );\n\t\treturn;\n\t}\n\n\tif( Cmd_Argc( ) == 2 )\n\t{\n\t\t// explicit filename\n\t\tCom_sprintf( filename, MAX_OSPATH, \"videos/%s.avi\", Cmd_Argv( 1 ) );\n\t}\n\telse\n\t{\n\t\tCL_VideoFilename( filename, MAX_OSPATH );\n\n\t\tif ( FS_FileExists( filename ) ) {\n\t\t\tCom_Printf( \"Video: Couldn't create a file\\n\");\n\t\t\treturn;\n \t\t}\n\t}\n\n\tCL_OpenAVIForWriting( filename );\n}\n\n/*\n===============\nCL_StopVideo_f\n===============\n*/\nvoid CL_StopVideo_f( void )\n{\n\tCL_CloseAVI( );\n}\n\nstatic void CL_AddFavorite_f( void ) {\n\tconst bool connected = (cls.state == CA_ACTIVE) && !clc.demoplaying;\n\tconst int argc = Cmd_Argc();\n\tif ( !connected && argc != 2 ) {\n\t\tCom_Printf( \"syntax: addFavorite <ip or hostname>\\n\" );\n\t\treturn;\n\t}\n\n\tconst char *server = (argc == 2) ? Cmd_Argv( 1 ) : NET_AdrToString( clc.serverAddress );\n\tconst int status = LAN_AddFavAddr( server );\n\tswitch ( status ) {\n\tcase -1:\n\t\tCom_Printf( \"error adding favorite server: too many favorite servers\\n\" );\n\t\tbreak;\n\tcase 0:\n\t\tCom_Printf( \"error adding favorite server: server already exists\\n\" );\n\t\tbreak;\n\tcase 1:\n\t\tCom_Printf( \"successfully added favorite server \\\"%s\\\"\\n\", server );\n\t\tbreak;\n\tdefault:\n\t\tCom_Printf( \"unknown error (%i) adding favorite server\\n\", status );\n\t\tbreak;\n\t}\n}\n\n#define G2_VERT_SPACE_CLIENT_SIZE 256\n\n/*\n===============\nCL_GenerateQKey\n\ntest to see if a valid QKEY_FILE exists.  If one does not, try to generate\nit by filling it with 2048 bytes of random data.\n===============\n*/\n\nstatic void CL_GenerateQKey(void)\n{\n\tif (cl_enableGuid->integer) {\n\t\tint len = 0;\n\t\tunsigned char buff[ QKEY_SIZE ];\n\t\tfileHandle_t f;\n\n\t\tlen = FS_SV_FOpenFileRead( QKEY_FILE, &f );\n\t\tFS_FCloseFile( f );\n\t\tif( len == QKEY_SIZE ) {\n\t\t\tCom_Printf( \"QKEY found.\\n\" );\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif( len > 0 ) {\n\t\t\t\tCom_Printf( \"QKEY file size != %d, regenerating\\n\",\n\t\t\t\t\tQKEY_SIZE );\n\t\t\t}\n\n\t\t\tCom_Printf( \"QKEY building random string\\n\" );\n\t\t\tCom_RandomBytes( buff, sizeof(buff) );\n\n\t\t\tf = FS_SV_FOpenFileWrite( QKEY_FILE );\n\t\t\tif( !f ) {\n\t\t\t\tCom_Printf( \"QKEY could not open %s for write\\n\",\n\t\t\t\t\tQKEY_FILE );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFS_Write( buff, sizeof(buff), f );\n\t\t\tFS_FCloseFile( f );\n\t\t\tCom_Printf( \"QKEY generated\\n\" );\n\t\t}\n\t}\n}\n\n/*\n====================\nCL_Init\n====================\n*/\nvoid CL_Init( void ) {\n//\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init ();\n\n\tCL_ClearState ();\n\n\tcls.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\n\tcls.realtime = 0;\n\n\tCL_InitInput ();\n\n\t//\n\t// register our variables\n\t//\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n\tcl_motd = Cvar_Get (\"cl_motd\", \"1\", CVAR_ARCHIVE, \"Display welcome message from master server on the bottom of connection screen\" );\n\tcl_motdServer[0] = Cvar_Get( \"cl_motdServer1\", UPDATE_SERVER_NAME, 0 );\n\tcl_motdServer[1] = Cvar_Get( \"cl_motdServer2\", JKHUB_UPDATE_SERVER_NAME, 0 );\n\tfor ( int index = 2; index < MAX_MASTER_SERVERS; index++ )\n\t\tcl_motdServer[index] = Cvar_Get( va( \"cl_motdServer%d\", index + 1 ), \"\", CVAR_ARCHIVE );\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP, \"Password for remote console access\" );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_avi2GBLimit = Cvar_Get (\"cl_avi2GBLimit\", \"1\", CVAR_ARCHIVE );\n\tcl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\n\n\trconAddress = Cvar_Get (\"rconAddress\", \"\", 0, \"Alternate server address to remotely access via rcon protocol\");\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", CVAR_ARCHIVE);\n\n\tcl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"63\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE, \"Always run\");\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE, \"Mouse sensitivity value\");\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE, \"Mouse acceleration value\");\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE, \"Mouse look\" );\n\n\t// 0: legacy mouse acceleration\n\t// 1: new implementation\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE, \"Mouse accelration style (0:legacy, 1:QuakeLive)\" );\n\t// offset for the power function (for style 1, ignored otherwise)\n\t// this should be set to the max rate value\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE, \"Mouse acceleration offset for style 1\" );\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n\tcl_framerate\t= Cvar_Get (\"cl_framerate\", \"0\", CVAR_TEMP);\n\tcl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE, \"Allow downloading custom paks from server\");\n\tcl_allowAltEnter = Cvar_Get (\"cl_allowAltEnter\", \"1\", CVAR_ARCHIVE, \"Enables use of ALT+ENTER keyboard combo to toggle fullscreen\" );\n\n\tcl_autolodscale = Cvar_Get( \"cl_autolodscale\", \"1\", CVAR_ARCHIVE );\n\n\tcl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n\n\tcl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitchVeh = Cvar_Get (\"m_pitchVeh\", \"0.022\", CVAR_ARCHIVE);\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef MACOS_X\n        // Input is jittery on OS X w/o this\n\tm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE, \"Max. ping for servers when searching the serverlist\" );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\t// enable the ja_guid player identifier in userinfo by default in OpenJK\n\tcl_enableGuid = Cvar_Get(\"cl_enableGuid\", \"1\", CVAR_ARCHIVE, \"Enable GUID userinfo identifier\" );\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE, \"Use a unique guid value per server\" );\n\n\t// ~ and `, as keys and characters\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60 0xb2\", CVAR_ARCHIVE, \"Which keys are used to toggle the console\");\n\tcl_consoleUseScanCode = Cvar_Get( \"cl_consoleUseScanCode\", \"1\", CVAR_ARCHIVE, \"Use native console key detection\" );\n\n\t// userinfo\n\tCvar_Get (\"name\", \"Padawan\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player name\" );\n\tCvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE, \"Data rate\" );\n\tCvar_Get (\"snaps\", \"40\", CVAR_USERINFO | CVAR_ARCHIVE, \"Client snapshots per second\" );\n\tCvar_Get (\"model\", DEFAULT_MODEL\"/default\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player model\" );\n\tCvar_Get (\"forcepowers\", \"7-1-032330000000001333\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player forcepowers\" );\n//\tCvar_Get (\"g_redTeam\", DEFAULT_REDTEAM_NAME, CVAR_SERVERINFO | CVAR_ARCHIVE);\n//\tCvar_Get (\"g_blueTeam\", DEFAULT_BLUETEAM_NAME, CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player saber1 color\" );\n\tCvar_Get (\"color2\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player saber2 color\" );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player handicap\" );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player sex\" );\n\tCvar_Get (\"password\", \"\", CVAR_USERINFO, \"Password to join server\" );\n\tCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\t//default sabers\n\tCvar_Get (\"saber1\",  DEFAULT_SABER, CVAR_USERINFO | CVAR_ARCHIVE, \"Player default right hand saber\" );\n\tCvar_Get (\"saber2\",  \"none\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player left hand saber\" );\n\n\t//skin color\n\tCvar_Get (\"char_color_red\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Red)\" );\n\tCvar_Get (\"char_color_green\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Green)\" );\n\tCvar_Get (\"char_color_blue\",  \"255\", CVAR_USERINFO | CVAR_ARCHIVE, \"Player tint (Blue)\" );\n\n\t// cgame might not be initialized before menu is used\n\tCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\n\t//\n\t// register our commands\n\t//\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f, \"Forward command to server\" );\n\tCmd_AddCommand (\"globalservers\", CL_GlobalServers_f, \"Query the masterserver for serverlist\" );\n\tCmd_AddCommand( \"addFavorite\", CL_AddFavorite_f, \"Add server to favorites\" );\n\tCmd_AddCommand (\"record\", CL_Record_f, \"Record a demo\" );\n\tCmd_AddCommand (\"demo\", CL_PlayDemo_f, \"Playback a demo\" );\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand (\"stoprecord\", CL_StopRecord_f, \"Stop recording a demo\" );\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f, \"Prints the configstrings list\" );\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f, \"Prints the userinfo variables\" );\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f, \"Restart sound\" );\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f, \"Restart the renderer - or change the resolution\" );\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f, \"Disconnect from current server\" );\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f, \"Play a cinematic video\" );\n\tCmd_AddCommand (\"connect\", CL_Connect_f, \"Connect to a server\" );\n\tCmd_AddCommand (\"reconnect\", CL_Reconnect_f, \"Reconnect to current server\" );\n\tCmd_AddCommand (\"localservers\", CL_LocalServers_f, \"Query LAN for local servers\" );\n\tCmd_AddCommand (\"rcon\", CL_Rcon_f, \"Execute commands remotely to a server\" );\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand (\"ping\", CL_Ping_f, \"Ping a server for info response\" );\n\tCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f, \"Retrieve current or specified server's status\" );\n\tCmd_AddCommand (\"showip\", CL_ShowIP_f, \"Shows local IP\" );\n\tCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f, \"Lists open pak files\" );\n\tCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f, \"Lists referenced pak files\" );\n\tCmd_AddCommand (\"model\", CL_SetModel_f, \"Set the player model\" );\n\tCmd_AddCommand (\"forcepowers\", CL_SetForcePowers_f );\n\tCmd_AddCommand (\"video\", CL_Video_f, \"Record demo to avi\" );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f, \"Stop avi recording\" );\n\n\tCL_InitRef();\n\n\tSCR_Init ();\n\n\tCbuf_Execute ();\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tG2VertSpaceClient = new CMiniHeap (G2_VERT_SPACE_CLIENT_SIZE * 1024);\n\n\tCL_GenerateQKey();\n\tCL_UpdateGUID( NULL, 0 );\n\n//\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n\n\n/*\n===============\nCL_Shutdown\n\n===============\n*/\nvoid CL_Shutdown( void ) {\n\tstatic qboolean recursive = qfalse;\n\n\t//Com_Printf( \"----- CL_Shutdown -----\\n\" );\n\n\tif ( recursive ) {\n\t\tprintf (\"recursive CL_Shutdown shutdown\\n\");\n\t\treturn;\n\t}\n\trecursive = qtrue;\n\n\tif (G2VertSpaceClient)\n\t{\n\t\tdelete G2VertSpaceClient;\n\t\tG2VertSpaceClient = 0;\n\t}\n\n\tCL_Disconnect( qtrue );\n\n\t// RJ: added the shutdown all to close down the cgame (to free up some memory, such as in the fx system)\n\tCL_ShutdownAll( qtrue );\n\n\tS_Shutdown();\n\t//CL_ShutdownUI();\n\n\tCmd_RemoveCommand (\"cmd\");\n\tCmd_RemoveCommand (\"configstrings\");\n\tCmd_RemoveCommand (\"clientinfo\");\n\tCmd_RemoveCommand (\"snd_restart\");\n\tCmd_RemoveCommand (\"vid_restart\");\n\tCmd_RemoveCommand (\"disconnect\");\n\tCmd_RemoveCommand (\"record\");\n\tCmd_RemoveCommand (\"demo\");\n\tCmd_RemoveCommand (\"cinematic\");\n\tCmd_RemoveCommand (\"stoprecord\");\n\tCmd_RemoveCommand (\"connect\");\n\tCmd_RemoveCommand (\"reconnect\");\n\tCmd_RemoveCommand (\"localservers\");\n\tCmd_RemoveCommand (\"globalservers\");\n\tCmd_RemoveCommand( \"addFavorite\" );\n\tCmd_RemoveCommand (\"rcon\");\n\tCmd_RemoveCommand (\"ping\");\n\tCmd_RemoveCommand (\"serverstatus\");\n\tCmd_RemoveCommand (\"showip\");\n\tCmd_RemoveCommand (\"fs_openedList\");\n\tCmd_RemoveCommand (\"fs_referencedList\");\n\tCmd_RemoveCommand (\"model\");\n\tCmd_RemoveCommand (\"forcepowers\");\n\tCmd_RemoveCommand (\"video\");\n\tCmd_RemoveCommand (\"stopvideo\");\n\n\tCL_ShutdownInput();\n\tCon_Shutdown();\n\n\tCvar_Set( \"cl_running\", \"0\" );\n\n\trecursive = qfalse;\n\n\tCom_Memset( &cls, 0, sizeof( cls ) );\n\tKey_SetCatcher( 0 );\n\n\t//Com_Printf( \"-----------------------\\n\" );\n\n}\n\nqboolean CL_ConnectedToRemoteServer( void ) {\n\treturn (qboolean)( com_sv_running && !com_sv_running->integer && cls.state >= CA_CONNECTED && !clc.demoplaying );\n}\n\nstatic void CL_SetServerInfo(serverInfo_t *server, const char *info, int ping) {\n\tif (server) {\n\t\tif (info) {\n\t\t\tserver->clients = atoi(Info_ValueForKey(info, \"clients\"));\n\t\t\tQ_strncpyz(server->hostName,Info_ValueForKey(info, \"hostname\"), MAX_NAME_LENGTH);\n\t\t\tQ_strncpyz(server->mapName, Info_ValueForKey(info, \"mapname\"), MAX_NAME_LENGTH);\n\t\t\tserver->maxClients = atoi(Info_ValueForKey(info, \"sv_maxclients\"));\n\t\t\tQ_strncpyz(server->game,Info_ValueForKey(info, \"game\"), MAX_NAME_LENGTH);\n\t\t\tserver->gameType = atoi(Info_ValueForKey(info, \"gametype\"));\n\t\t\tserver->netType = atoi(Info_ValueForKey(info, \"nettype\"));\n\t\t\tserver->minPing = atoi(Info_ValueForKey(info, \"minping\"));\n\t\t\tserver->maxPing = atoi(Info_ValueForKey(info, \"maxping\"));\n//\t\t\tserver->allowAnonymous = atoi(Info_ValueForKey(info, \"sv_allowAnonymous\"));\n\t\t\tserver->needPassword = (qboolean)atoi(Info_ValueForKey(info, \"needpass\" ));\n\t\t\tserver->trueJedi = atoi(Info_ValueForKey(info, \"truejedi\" ));\n\t\t\tserver->weaponDisable = atoi(Info_ValueForKey(info, \"wdisable\" ));\n\t\t\tserver->forceDisable = atoi(Info_ValueForKey(info, \"fdisable\" ));\n\t\t\tserver->humans = atoi( Info_ValueForKey( info, \"g_humanplayers\" ) );\n\t\t\tserver->bots = atoi( Info_ValueForKey( info, \"bots\" ) );\n//\t\t\tserver->pure = (qboolean)atoi(Info_ValueForKey(info, \"pure\" ));\n\t\t}\n\t\tserver->ping = ping;\n\t}\n}\n\nstatic void CL_SetServerInfoByAddress(netadr_t from, const char *info, int ping) {\n\tint i;\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.localServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.localServers[i], info, ping);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_GLOBAL_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.globalServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.globalServers[i], info, ping);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tif (NET_CompareAdr(from, cls.favoriteServers[i].adr)) {\n\t\t\tCL_SetServerInfo(&cls.favoriteServers[i], info, ping);\n\t\t}\n\t}\n}\n\n/*\n===================\nCL_ServerInfoPacket\n===================\n*/\nvoid CL_ServerInfoPacket( netadr_t from, msg_t *msg ) {\n\tint\t\ti, type;\n\tchar\tinfo[MAX_INFO_STRING];\n\tchar\t*infoString;\n\tint\t\tprot;\n\n\tinfoString = MSG_ReadString( msg );\n\n\t// if this isn't the correct protocol version, ignore it\n\tprot = atoi( Info_ValueForKey( infoString, \"protocol\" ) );\n\tif ( prot != PROTOCOL_VERSION ) {\n\t\tCom_DPrintf( \"Different protocol info packet: %s\\n\", infoString );\n\t\treturn;\n\t}\n\n\t// iterate servers waiting for ping response\n\tfor (i=0; i<MAX_PINGREQUESTS; i++)\n\t{\n\t\tif ( cl_pinglist[i].adr.port && !cl_pinglist[i].time && NET_CompareAdr( from, cl_pinglist[i].adr ) )\n\t\t{\n\t\t\t// calc ping time\n\t\t\tcl_pinglist[i].time = Sys_Milliseconds() - cl_pinglist[i].start;\n\t\t\tCom_DPrintf( \"ping time %dms from %s\\n\", cl_pinglist[i].time, NET_AdrToString( from ) );\n\n\t\t\t// save of info\n\t\t\tQ_strncpyz( cl_pinglist[i].info, infoString, sizeof( cl_pinglist[i].info ) );\n\n\t\t\t// tack on the net type\n\t\t\t// NOTE: make sure these types are in sync with the netnames strings in the UI\n\t\t\tswitch (from.type)\n\t\t\t{\n\t\t\t\tcase NA_BROADCAST:\n\t\t\t\tcase NA_IP:\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\ttype = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tInfo_SetValueForKey( cl_pinglist[i].info, \"nettype\", va(\"%d\", type) );\n\t\t\tCL_SetServerInfoByAddress(from, infoString, cl_pinglist[i].time);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// if not just sent a local broadcast or pinging local servers\n\tif (cls.pingUpdateSource != AS_LOCAL) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; i < MAX_OTHER_SERVERS ; i++ ) {\n\t\t// empty slot\n\t\tif ( cls.localServers[i].adr.port == 0 ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// avoid duplicate\n\t\tif ( NET_CompareAdr( from, cls.localServers[i].adr ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( i == MAX_OTHER_SERVERS ) {\n\t\tCom_DPrintf( \"MAX_OTHER_SERVERS hit, dropping infoResponse\\n\" );\n\t\treturn;\n\t}\n\n\t// add this to the list\n\tcls.numlocalservers = i+1;\n\tCL_InitServerInfo( &cls.localServers[i], &from );\n\n\tQ_strncpyz( info, MSG_ReadString( msg ), MAX_INFO_STRING );\n\tif (strlen(info)) {\n\t\tif (info[strlen(info)-1] != '\\n') {\n\t\t\tstrncat(info, \"\\n\", sizeof(info) -1);\n\t\t}\n\t\tCom_Printf( \"%s: %s\", NET_AdrToString( from ), info );\n\t}\n}\n\n/*\n===================\nCL_GetServerStatus\n===================\n*/\nserverStatus_t *CL_GetServerStatus( netadr_t from ) {\n\tint i, oldest, oldestTime;\n\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( NET_CompareAdr( from, cl_serverStatusList[i].address ) ) {\n\t\t\treturn &cl_serverStatusList[i];\n\t\t}\n\t}\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( cl_serverStatusList[i].retrieved ) {\n\t\t\treturn &cl_serverStatusList[i];\n\t\t}\n\t}\n\toldest = -1;\n\toldestTime = 0;\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif (oldest == -1 || cl_serverStatusList[i].startTime < oldestTime) {\n\t\t\toldest = i;\n\t\t\toldestTime = cl_serverStatusList[i].startTime;\n\t\t}\n\t}\n\tif (oldest != -1) {\n\t\treturn &cl_serverStatusList[oldest];\n\t}\n\tserverStatusCount++;\n\treturn &cl_serverStatusList[serverStatusCount & (MAX_SERVERSTATUSREQUESTS-1)];\n}\n\n/*\n===================\nCL_ServerStatus\n===================\n*/\nint CL_ServerStatus( const char *serverAddress, char *serverStatusString, int maxLen ) {\n\tint i;\n\tnetadr_t\tto;\n\tserverStatus_t *serverStatus;\n\n\t// if no server address then reset all server status requests\n\tif ( !serverAddress ) {\n\t\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\t\tcl_serverStatusList[i].address.port = 0;\n\t\t\tcl_serverStatusList[i].retrieved = qtrue;\n\t\t}\n\t\treturn qfalse;\n\t}\n\t// get the address\n\tif ( !NET_StringToAdr( serverAddress, &to ) ) {\n\t\treturn qfalse;\n\t}\n\tserverStatus = CL_GetServerStatus( to );\n\t// if no server status string then reset the server status request for this address\n\tif ( !serverStatusString ) {\n\t\tserverStatus->retrieved = qtrue;\n\t\treturn qfalse;\n\t}\n\n\t// if this server status request has the same address\n\tif ( NET_CompareAdr( to, serverStatus->address) ) {\n\t\t// if we received a response for this server status request\n\t\tif (!serverStatus->pending) {\n\t\t\tQ_strncpyz(serverStatusString, serverStatus->string, maxLen);\n\t\t\tserverStatus->retrieved = qtrue;\n\t\t\tserverStatus->startTime = 0;\n\t\t\treturn qtrue;\n\t\t}\n\t\t// resend the request regularly\n\t\telse if ( serverStatus->startTime < Com_Milliseconds() - cl_serverStatusResendTime->integer ) {\n\t\t\tserverStatus->print = qfalse;\n\t\t\tserverStatus->pending = qtrue;\n\t\t\tserverStatus->retrieved = qfalse;\n\t\t\tserverStatus->time = 0;\n\t\t\tserverStatus->startTime = Com_Milliseconds();\n\t\t\tNET_OutOfBandPrint( NS_CLIENT, to, \"getstatus\" );\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t// if retrieved\n\telse if ( serverStatus->retrieved ) {\n\t\tserverStatus->address = to;\n\t\tserverStatus->print = qfalse;\n\t\tserverStatus->pending = qtrue;\n\t\tserverStatus->retrieved = qfalse;\n\t\tserverStatus->startTime = Com_Milliseconds();\n\t\tserverStatus->time = 0;\n\t\tNET_OutOfBandPrint( NS_CLIENT, to, \"getstatus\" );\n\t\treturn qfalse;\n\t}\n\treturn qfalse;\n}\n\n/*\n===================\nCL_ServerStatusResponse\n===================\n*/\nvoid CL_ServerStatusResponse( netadr_t from, msg_t *msg ) {\n\tchar\t*s;\n\tchar\tinfo[MAX_INFO_STRING];\n\tint\t\ti, l, score, ping;\n\tint\t\tlen;\n\tserverStatus_t *serverStatus;\n\n\tserverStatus = NULL;\n\tfor (i = 0; i < MAX_SERVERSTATUSREQUESTS; i++) {\n\t\tif ( NET_CompareAdr( from, cl_serverStatusList[i].address ) ) {\n\t\t\tserverStatus = &cl_serverStatusList[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if we didn't request this server status\n\tif (!serverStatus) {\n\t\treturn;\n\t}\n\n\ts = MSG_ReadStringLine( msg );\n\n\tlen = 0;\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"%s\", s);\n\n\tif (serverStatus->print) {\n\t\tCom_Printf( \"Server (%s)\\n\",\n\t\t\tNET_AdrToString( serverStatus->address ) );\n\t\tCom_Printf(\"Server settings:\\n\");\n\t\t// print cvars\n\t\twhile (*s) {\n\t\t\tfor (i = 0; i < 2 && *s; i++) {\n\t\t\t\tif (*s == '\\\\')\n\t\t\t\t\ts++;\n\t\t\t\tl = 0;\n\t\t\t\twhile (*s) {\n\t\t\t\t\tinfo[l++] = *s;\n\t\t\t\t\tif (l >= MAX_INFO_STRING-1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts++;\n\t\t\t\t\tif (*s == '\\\\') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo[l] = '\\0';\n\t\t\t\tif (i) {\n\t\t\t\t\tCom_Printf(\"%s\\n\", info);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCom_Printf(\"%-24s\", info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlen = strlen(serverStatus->string);\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\\");\n\n\tif (serverStatus->print) {\n\t\tCom_Printf(\"\\nPlayers:\\n\");\n\t\tCom_Printf(\"num: score: ping: name:\\n\");\n\t}\n\tfor (i = 0, s = MSG_ReadStringLine( msg ); *s; s = MSG_ReadStringLine( msg ), i++) {\n\n\t\tlen = strlen(serverStatus->string);\n\t\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\%s\", s);\n\n\t\tif (serverStatus->print) {\n\t\t\tscore = ping = 0;\n\t\t\tsscanf(s, \"%d %d\", &score, &ping);\n\t\t\ts = strchr(s, ' ');\n\t\t\tif (s)\n\t\t\t\ts = strchr(s+1, ' ');\n\t\t\tif (s)\n\t\t\t\ts++;\n\t\t\telse\n\t\t\t\ts = \"unknown\";\n\t\t\tCom_Printf(\"%-2d   %-3d    %-3d   %s\\n\", i, score, ping, s );\n\t\t}\n\t}\n\tlen = strlen(serverStatus->string);\n\tCom_sprintf(&serverStatus->string[len], sizeof(serverStatus->string)-len, \"\\\\\");\n\n\tserverStatus->time = Com_Milliseconds();\n\tserverStatus->address = from;\n\tserverStatus->pending = qfalse;\n\tif (serverStatus->print) {\n\t\tserverStatus->retrieved = qtrue;\n\t}\n}\n\n/*\n==================\nCL_LocalServers_f\n==================\n*/\nvoid CL_LocalServers_f( void ) {\n\tchar\t\t*message;\n\tint\t\t\ti, j;\n\tnetadr_t\tto;\n\n\tCom_Printf( \"Scanning for servers on the local network...\\n\");\n\n\t// reset the list, waiting for response\n\tcls.numlocalservers = 0;\n\tcls.pingUpdateSource = AS_LOCAL;\n\n\tfor (i = 0; i < MAX_OTHER_SERVERS; i++) {\n\t\tqboolean b = cls.localServers[i].visible;\n\t\tCom_Memset(&cls.localServers[i], 0, sizeof(cls.localServers[i]));\n\t\tcls.localServers[i].visible = b;\n\t}\n\tCom_Memset( &to, 0, sizeof( to ) );\n\n\t// The 'xxx' in the message is a challenge that will be echoed back\n\t// by the server.  We don't care about that here, but master servers\n\t// can use that to prevent spoofed server responses from invalid ip\n\tmessage = \"\\377\\377\\377\\377getinfo xxx\";\n\n\t// send each message twice in case one is dropped\n\tfor ( i = 0 ; i < 2 ; i++ ) {\n\t\t// send a broadcast packet on each server port\n\t\t// we support multiple server ports so a single machine\n\t\t// can nicely run multiple servers\n\t\tfor ( j = 0 ; j < NUM_SERVER_PORTS ; j++ ) {\n\t\t\tto.port = BigShort( (short)(PORT_SERVER + j) );\n\n\t\t\tto.type = NA_BROADCAST;\n\t\t\tNET_SendPacket( NS_CLIENT, strlen( message ), message, to );\n\t\t}\n\t}\n}\n\n/*\n==================\nCL_GlobalServers_f\n==================\n*/\nvoid CL_GlobalServers_f( void ) {\n\tnetadr_t\tto;\n\tint\t\t\tcount, i, masterNum;\n\tchar\t\tcommand[1024], *masteraddress;\n\n\tif ((count = Cmd_Argc()) < 3 || (masterNum = atoi(Cmd_Argv(1))) < 0 || masterNum > MAX_MASTER_SERVERS - 1)\n\t{\n\t\tCom_Printf(\"usage: globalservers <master# 0-%d> <protocol> [keywords]\\n\", MAX_MASTER_SERVERS - 1);\n\t\treturn;\n\t}\n\n\tCom_sprintf( command, sizeof(command), \"sv_master%d\", masterNum + 1 );\n\tmasteraddress = Cvar_VariableString( command );\n\n\tif ( !*masteraddress )\n\t{\n\t\tCom_Printf( \"CL_GlobalServers_f: Error: No master server address given.\\n\" );\n\t\treturn;\n\t}\n\n\t// reset the list, waiting for response\n\t// -1 is used to distinguish a \"no response\"\n\n\ti = NET_StringToAdr( masteraddress, &to );\n\n\tif (!i)\n\t{\n\t\tCom_Printf( \"CL_GlobalServers_f: Error: could not resolve address of master %s\\n\", masteraddress );\n\t\treturn;\n\t}\n\tto.type = NA_IP;\n\tto.port = BigShort(PORT_MASTER);\n\n\tCom_Printf( \"Requesting servers from the master %s (%s)...\\n\", masteraddress, NET_AdrToString( to ) );\n\n\tcls.numglobalservers = -1;\n\tcls.pingUpdateSource = AS_GLOBAL;\n\n\tCom_sprintf(command, sizeof(command), \"getservers %s\", Cmd_Argv(2));\n\n\t// tack on keywords\n\tfor (i = 3; i < count; i++)\n\t{\n\t\tQ_strcat(command, sizeof(command), \" \");\n\t\tQ_strcat(command, sizeof(command), Cmd_Argv(i));\n\t}\n\n\tNET_OutOfBandPrint( NS_SERVER, to, \"%s\", command );\n}\n\n/*\n==================\nCL_GetPing\n==================\n*/\nvoid CL_GetPing( int n, char *buf, int buflen, int *pingtime )\n{\n\tconst char\t*str;\n\tint\t\ttime;\n\tint\t\tmaxPing;\n\n\tif (n < 0 || n >= MAX_PINGREQUESTS || !cl_pinglist[n].adr.port)\n\t{\n\t\t// empty or invalid slot\n\t\tbuf[0]    = '\\0';\n\t\t*pingtime = 0;\n\t\treturn;\n\t}\n\n\tstr = NET_AdrToString( cl_pinglist[n].adr );\n\tQ_strncpyz( buf, str, buflen );\n\n\ttime = cl_pinglist[n].time;\n\tif (!time)\n\t{\n\t\t// check for timeout\n\t\ttime = Sys_Milliseconds() - cl_pinglist[n].start;\n\t\tmaxPing = Cvar_VariableIntegerValue( \"cl_maxPing\" );\n\t\tif( maxPing < 100 ) {\n\t\t\tmaxPing = 100;\n\t\t}\n\t\tif (time < maxPing)\n\t\t{\n\t\t\t// not timed out yet\n\t\t\ttime = 0;\n\t\t}\n\t}\n\n\tCL_SetServerInfoByAddress(cl_pinglist[n].adr, cl_pinglist[n].info, cl_pinglist[n].time);\n\n\t*pingtime = time;\n}\n\n/*\n==================\nCL_GetPingInfo\n==================\n*/\nvoid CL_GetPingInfo( int n, char *buf, int buflen )\n{\n\tif (n < 0 || n >= MAX_PINGREQUESTS || !cl_pinglist[n].adr.port)\n\t{\n\t\t// empty or invalid slot\n\t\tif (buflen)\n\t\t\tbuf[0] = '\\0';\n\t\treturn;\n\t}\n\n\tQ_strncpyz( buf, cl_pinglist[n].info, buflen );\n}\n\n/*\n==================\nCL_ClearPing\n==================\n*/\nvoid CL_ClearPing( int n )\n{\n\tif (n < 0 || n >= MAX_PINGREQUESTS)\n\t\treturn;\n\n\tcl_pinglist[n].adr.port = 0;\n}\n\n/*\n==================\nCL_GetPingQueueCount\n==================\n*/\nint CL_GetPingQueueCount( void )\n{\n\tint\t\ti;\n\tint\t\tcount;\n\tping_t*\tpingptr;\n\n\tcount   = 0;\n\tpingptr = cl_pinglist;\n\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ ) {\n\t\tif (pingptr->adr.port) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn (count);\n}\n\n/*\n==================\nCL_GetFreePing\n==================\n*/\nping_t* CL_GetFreePing( void )\n{\n\tping_t*\tpingptr;\n\tping_t*\tbest;\n\tint\t\toldest;\n\tint\t\ti;\n\tint\t\ttime;\n\n\tpingptr = cl_pinglist;\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ )\n\t{\n\t\t// find free ping slot\n\t\tif (pingptr->adr.port)\n\t\t{\n\t\t\tif (!pingptr->time)\n\t\t\t{\n\t\t\t\tif (Sys_Milliseconds() - pingptr->start < 500)\n\t\t\t\t{\n\t\t\t\t\t// still waiting for response\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pingptr->time < 500)\n\t\t\t{\n\t\t\t\t// results have not been queried\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// clear it\n\t\tpingptr->adr.port = 0;\n\t\treturn (pingptr);\n\t}\n\n\t// use oldest entry\n\tpingptr = cl_pinglist;\n\tbest    = cl_pinglist;\n\toldest  = INT_MIN;\n\tfor (i=0; i<MAX_PINGREQUESTS; i++, pingptr++ )\n\t{\n\t\t// scan for oldest\n\t\ttime = Sys_Milliseconds() - pingptr->start;\n\t\tif (time > oldest)\n\t\t{\n\t\t\toldest = time;\n\t\t\tbest   = pingptr;\n\t\t}\n\t}\n\n\treturn (best);\n}\n\n/*\n==================\nCL_Ping_f\n==================\n*/\nvoid CL_Ping_f( void ) {\n\tnetadr_t\tto;\n\tping_t*\t\tpingptr;\n\tchar*\t\tserver;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: ping [server]\\n\");\n\t\treturn;\n\t}\n\n\tCom_Memset( &to, 0, sizeof(netadr_t) );\n\n\tserver = Cmd_Argv(1);\n\n\tif ( !NET_StringToAdr( server, &to ) ) {\n\t\treturn;\n\t}\n\n\tpingptr = CL_GetFreePing();\n\n\tmemcpy( &pingptr->adr, &to, sizeof (netadr_t) );\n\tpingptr->start = Sys_Milliseconds();\n\tpingptr->time  = 0;\n\n\tCL_SetServerInfoByAddress(pingptr->adr, NULL, 0);\n\n\tNET_OutOfBandPrint( NS_CLIENT, to, \"getinfo xxx\" );\n}\n\n/*\n==================\nCL_UpdateVisiblePings_f\n==================\n*/\nqboolean CL_UpdateVisiblePings_f(int source) {\n\tint\t\t\tslots, i;\n\tchar\t\tbuff[MAX_STRING_CHARS];\n\tint\t\t\tpingTime;\n\tint\t\t\tmax;\n\tqboolean status = qfalse;\n\n\tif (source < 0 || source > AS_FAVORITES) {\n\t\treturn qfalse;\n\t}\n\n\tcls.pingUpdateSource = source;\n\n\tslots = CL_GetPingQueueCount();\n\tif (slots < MAX_PINGREQUESTS) {\n\t\tserverInfo_t *server = NULL;\n\n\t\tswitch (source) {\n\t\t\tcase AS_LOCAL :\n\t\t\t\tserver = &cls.localServers[0];\n\t\t\t\tmax = cls.numlocalservers;\n\t\t\tbreak;\n\t\t\tcase AS_GLOBAL :\n\t\t\t\tserver = &cls.globalServers[0];\n\t\t\t\tmax = cls.numglobalservers;\n\t\t\tbreak;\n\t\t\tcase AS_FAVORITES :\n\t\t\t\tserver = &cls.favoriteServers[0];\n\t\t\t\tmax = cls.numfavoriteservers;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn qfalse;\n\t\t}\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tif (server[i].visible) {\n\t\t\t\tif (server[i].ping == -1) {\n\t\t\t\t\tint j;\n\n\t\t\t\t\tif (slots >= MAX_PINGREQUESTS) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < MAX_PINGREQUESTS; j++) {\n\t\t\t\t\t\tif (!cl_pinglist[j].adr.port) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {\n\t\t\t\t\t\t\t// already on the list\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j >= MAX_PINGREQUESTS) {\n\t\t\t\t\t\tstatus = qtrue;\n\t\t\t\t\t\tfor (j = 0; j < MAX_PINGREQUESTS; j++) {\n\t\t\t\t\t\t\tif (!cl_pinglist[j].adr.port) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(&cl_pinglist[j].adr, &server[i].adr, sizeof(netadr_t));\n\t\t\t\t\t\tcl_pinglist[j].start = Sys_Milliseconds();\n\t\t\t\t\t\tcl_pinglist[j].time = 0;\n\t\t\t\t\t\tNET_OutOfBandPrint( NS_CLIENT, cl_pinglist[j].adr, \"getinfo xxx\" );\n\t\t\t\t\t\tslots++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the server has a ping higher than cl_maxPing or\n\t\t\t\t// the ping packet got lost\n\t\t\t\telse if (server[i].ping == 0) {\n\t\t\t\t\t// if we are updating global servers\n\t\t\t\t\tif (source == AS_GLOBAL) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif ( cls.numGlobalServerAddresses > 0 ) {\n\t\t\t\t\t\t\t// overwrite this server with one from the additional global servers\n\t\t\t\t\t\t\tcls.numGlobalServerAddresses--;\n\t\t\t\t\t\t\tCL_InitServerInfo(&server[i], &cls.globalServerAddresses[cls.numGlobalServerAddresses]);\n\t\t\t\t\t\t\t// NOTE: the server[i].visible flag stays untouched\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slots) {\n\t\tstatus = qtrue;\n\t}\n\tfor (i = 0; i < MAX_PINGREQUESTS; i++) {\n\t\tif (!cl_pinglist[i].adr.port) {\n\t\t\tcontinue;\n\t\t}\n\t\tCL_GetPing( i, buff, MAX_STRING_CHARS, &pingTime );\n\t\tif (pingTime != 0) {\n\t\t\tCL_ClearPing(i);\n\t\t\tstatus = qtrue;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n/*\n==================\nCL_ServerStatus_f\n==================\n*/\nvoid CL_ServerStatus_f(void) {\n\tnetadr_t\tto, *toptr = NULL;\n\tchar\t\t*server;\n\tserverStatus_t *serverStatus;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tif ( cls.state != CA_ACTIVE || clc.demoplaying ) {\n\t\t\tCom_Printf (\"Not connected to a server.\\n\");\n\t\t\tCom_Printf( \"Usage: serverstatus [server]\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ttoptr = &clc.serverAddress;\n\t}\n\n\tif(!toptr)\n\t{\n\t\tCom_Memset( &to, 0, sizeof(netadr_t) );\n\n\t\tserver = Cmd_Argv(1);\n\n\t\ttoptr = &to;\n\t\tif ( !NET_StringToAdr( server, toptr ) )\n\t\t\treturn;\n\t}\n\n\tNET_OutOfBandPrint( NS_CLIENT, *toptr, \"getstatus\" );\n\n\tserverStatus = CL_GetServerStatus( *toptr );\n\tserverStatus->address = *toptr;\n\tserverStatus->print = qtrue;\n\tserverStatus->pending = qtrue;\n}\n\n/*\n==================\nCL_ShowIP_f\n==================\n*/\nvoid CL_ShowIP_f(void) {\n\tSys_ShowIP();\n}\n\n", "/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n/*****************************************************************************\n\n * name:\t\tfiles.cpp\n *\n * desc:\t\tfile code\n *\n *****************************************************************************/\n\n#include \"qcommon/qcommon.h\"\n\n#ifndef DEDICATED\n#ifndef FINAL_BUILD\n#include \"client/client.h\"\n#endif\n#endif\n#include <minizip/unzip.h>\n\n#if defined(_WIN32)\n#include <windows.h>\n#endif\n\n// for rmdir\n#if defined (_MSC_VER)\n\t#include <direct.h>\n#else\n\t#include <unistd.h>\n#endif\n\n/*\n=============================================================================\n\nQUAKE3 FILESYSTEM\n\nAll of Quake's data access is through a hierarchical file system, but the contents of\nthe file system can be transparently merged from several sources.\n\nA \"qpath\" is a reference to game file data.  MAX_ZPATH is 256 characters, which must include\na terminating zero. \"..\", \"\\\\\", and \":\" are explicitly illegal in qpaths to prevent any\nreferences outside the quake directory system.\n\nThe \"base path\" is the path to the directory holding all the game directories and usually\nthe executable.  It defaults to \".\", but can be overridden with a \"+set fs_basepath c:\\quake3\"\ncommand line to allow code debugging in a different directory.  Basepath cannot\nbe modified at all after startup.  Any files that are created (demos, screenshots,\netc) will be created relative to the base path, so base path should usually be writable.\n\nThe \"home path\" is the path used for all write access. On win32 systems we have \"base path\"\n== \"home path\", but on *nix systems the base installation is usually readonly, and\n\"home path\" points to ~/.q3a or similar\n\nThe user can also install custom mods and content in \"home path\", so it should be searched\nalong with \"home path\" and \"cd path\" for game content.\n\n\nThe \"base game\" is the directory under the paths where data comes from by default, and\ncan be either \"baseq3\" or \"demoq3\".\n\nThe \"current game\" may be the same as the base game, or it may be the name of another\ndirectory under the paths that should be searched for files before looking in the base game.\nThis is the basis for addons.\n\nClients automatically set the game directory after receiving a gamestate from a server,\nso only servers need to worry about +set fs_game.\n\nNo other directories outside of the base game and current game will ever be referenced by\nfilesystem functions.\n\nTo save disk space and speed loading, directory trees can be collapsed into zip files.\nThe files use a \".pk3\" extension to prevent users from unzipping them accidentally, but\notherwise the are simply normal uncompressed zip files.  A game directory can have multiple\nzip files of the form \"pak0.pk3\", \"pak1.pk3\", etc.  Zip files are searched in decending order\nfrom the highest number to the lowest, and will always take precedence over the filesystem.\nThis allows a pk3 distributed as a patch to override all existing data.\n\nBecause we will have updated executables freely available online, there is no point to\ntrying to restrict demo / oem versions of the game with code changes.  Demo / oem versions\nshould be exactly the same executables as release versions, but with different data that\nautomatically restricts where game media can come from to prevent add-ons from working.\n\nFile search order: when FS_FOpenFileRead gets called it will go through the fs_searchpaths\nstructure and stop on the first successful hit. fs_searchpaths is built with successive\ncalls to FS_AddGameDirectory\n\nAdditionaly, we search in several subdirectories:\ncurrent game is the current mode\nbase game is a variable to allow mods based on other mods\n(such as baseq3 + missionpack content combination in a mod for instance)\nBASEGAME is the hardcoded base game (\"baseq3\")\n\ne.g. the qpath \"sound/newstuff/test.wav\" would be searched for in the following places:\n\nhome path + current game's zip files\nhome path + current game's directory\nbase path + current game's zip files\nbase path + current game's directory\ncd path + current game's zip files\ncd path + current game's directory\n\nhome path + base game's zip file\nhome path + base game's directory\nbase path + base game's zip file\nbase path + base game's directory\ncd path + base game's zip file\ncd path + base game's directory\n\nhome path + BASEGAME's zip file\nhome path + BASEGAME's directory\nbase path + BASEGAME's zip file\nbase path + BASEGAME's directory\ncd path + BASEGAME's zip file\ncd path + BASEGAME's directory\n\nserver download, to be written to home path + current game's directory\n\n\nThe filesystem can be safely shutdown and reinitialized with different\nbasedir / cddir / game combinations, but all other subsystems that rely on it\n(sound, video) must also be forced to restart.\n\nBecause the same files are loaded by both the clip model (CM_) and renderer (TR_)\nsubsystems, a simple single-file caching scheme is used.  The CM_ subsystems will\nload the file with a request to cache.  Only one file will be kept cached at a time,\nso any models that are going to be referenced by both subsystems should alternate\nbetween the CM_ load function and the ref load function.\n\nTODO: A qpath that starts with a leading slash will always refer to the base game, even if another\ngame is currently active.  This allows character models, skins, and sounds to be downloaded\nto a common directory no matter which game is active.\n\nHow to prevent downloading zip files?\nPass pk3 file names in systeminfo, and download before FS_Restart()?\n\nAborting a download disconnects the client from the server.\n\nHow to mark files as downloadable?  Commercial add-ons won't be downloadable.\n\nNon-commercial downloads will want to download the entire zip file.\nthe game would have to be reset to actually read the zip in\n\nAuto-update information\n\nPath separators\n\nCasing\n\n  separate server gamedir and client gamedir, so if the user starts\n  a local game after having connected to a network game, it won't stick\n  with the network game.\n\n  allow menu options for game selection?\n\nRead / write config to floppy option.\n\nDifferent version coexistance?\n\nWhen building a pak file, make sure a q3config.cfg isn't present in it,\nor configs will never get loaded from disk!\n\n  todo:\n\n  downloading (outside fs?)\n  game directory passing and restarting\n\n=============================================================================\n\n*/\n\n#define MAX_ZPATH\t\t\t256\n#define\tMAX_SEARCH_PATHS\t4096\n#define MAX_FILEHASH_SIZE\t1024\n\ntypedef struct fileInPack_s {\n\tchar\t\t\t\t\t*name;\t\t// name of the file\n\tunsigned long\t\t\tpos;\t\t// file info position in zip\n\tunsigned long\t\t\tlen;\t\t// uncompress file size\n\tstruct\tfileInPack_s*\tnext;\t\t// next file in the hash\n} fileInPack_t;\n\ntypedef struct pack_s {\n\tchar\t\t\tpakPathname[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\t\tpakFilename[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\\assets0.pk3\n\tchar\t\t\tpakBasename[MAX_OSPATH];\t// assets0\n\tchar\t\t\tpakGamename[MAX_OSPATH];\t// base\n\tunzFile\t\t\thandle;\t\t\t\t\t\t// handle to zip file\n\tint\t\t\t\tchecksum;\t\t\t\t\t// regular checksum\n\tint\t\t\t\tpure_checksum;\t\t\t\t// checksum for pure\n\tint\t\t\t\tnumfiles;\t\t\t\t\t// number of files in pk3\n\tint\t\t\t\treferenced;\t\t\t\t\t// referenced file flags\n\tint\t\t\t\thashSize;\t\t\t\t\t// hash table size (power of 2)\n\tfileInPack_t*\t*hashTable;\t\t\t\t\t// hash table\n\tfileInPack_t*\tbuildBuffer;\t\t\t\t// buffer with the filenames etc.\n} pack_t;\n\ntypedef struct directory_s {\n\tchar\t\tpath[MAX_OSPATH];\t\t// c:\\jediacademy\\gamedata\n\tchar\t\tfullpath[MAX_OSPATH];\t// c:\\jediacademy\\gamedata\\base\n\tchar\t\tgamedir[MAX_OSPATH];\t// base\n} directory_t;\n\ntypedef struct searchpath_s {\n\tstruct searchpath_s *next;\n\n\tpack_t\t\t*pack;\t\t// only one of pack / dir will be non NULL\n\tdirectory_t\t*dir;\n} searchpath_t;\n\nstatic char\t\tfs_gamedir[MAX_OSPATH];\t// this will be a single file name with no separators\nstatic cvar_t\t\t*fs_debug;\nstatic cvar_t\t\t*fs_homepath;\n\n#ifdef MACOS_X\n// Also search the .app bundle for .pk3 files\nstatic cvar_t          *fs_apppath;\n#endif\n\nstatic cvar_t\t\t*fs_basepath;\nstatic cvar_t\t\t*fs_basegame;\nstatic cvar_t\t\t*fs_cdpath;\nstatic cvar_t\t\t*fs_copyfiles;\nstatic cvar_t\t\t*fs_gamedirvar;\nstatic cvar_t\t\t*fs_dirbeforepak; //rww - when building search path, keep directories at top and insert pk3's under them\nstatic searchpath_t\t*fs_searchpaths;\nstatic int\t\t\tfs_readCount;\t\t\t// total bytes read\nstatic int\t\t\tfs_loadCount;\t\t\t// total files read\nstatic int\t\t\tfs_packFiles = 0;\t\t// total number of files in packs\n\nstatic int\t\t\tfs_fakeChkSum;\nstatic int\t\t\tfs_checksumFeed;\n\ntypedef union qfile_gus {\n\tFILE*\t\to;\n\tunzFile\t\tz;\n} qfile_gut;\n\ntypedef struct qfile_us {\n\tqfile_gut\tfile;\n\tqboolean\tunique;\n} qfile_ut;\n\ntypedef struct fileHandleData_s {\n\tqfile_ut\thandleFiles;\n\tqboolean\thandleSync;\n\tint\t\t\tfileSize;\n\tint\t\t\tzipFilePos;\n\tint\t\t\tzipFileLen;\n\tqboolean\tzipFile;\n\tchar\t\tname[MAX_ZPATH];\n} fileHandleData_t;\n\nstatic fileHandleData_t\tfsh[MAX_FILE_HANDLES];\n\n// TTimo - https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n// wether we did a reorder on the current search path when joining the server\nstatic qboolean fs_reordered = qfalse;\n\n// never load anything from pk3 files that are not present at the server when pure\nstatic int\t\tfs_numServerPaks = 0;\nstatic int\t\tfs_serverPaks[MAX_SEARCH_PATHS];\t\t\t\t// checksums\nstatic char\t\t*fs_serverPakNames[MAX_SEARCH_PATHS];\t\t\t// pk3 names\n\n// only used for autodownload, to make sure the client has at least\n// all the pk3 files that are referenced at the server side\nstatic int\t\tfs_numServerReferencedPaks;\nstatic int\t\tfs_serverReferencedPaks[MAX_SEARCH_PATHS];\t\t\t// checksums\nstatic char\t*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];\t\t// pk3 names\n\n#if defined(_WIN32)\n// temporary files - store them in a circular buffer. We're pretty\n// much guaranteed to not need more than 8 temp files at a time.\nstatic int\t\tfs_temporaryFileWriteIdx = 0;\nstatic char\t\tfs_temporaryFileNames[8][MAX_OSPATH];\n#endif\n\n// last valid game folder used\nchar lastValidBase[MAX_OSPATH];\nchar lastValidGame[MAX_OSPATH];\n\n#ifdef FS_MISSING\nFILE*\t\tmissingFiles = NULL;\n#endif\n\n/* C99 defines __func__ */\n#if __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2 || _MSC_VER >= 1300\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"(unknown)\"\n#  endif\n#endif\n\n/*\n==============\nFS_Initialized\n==============\n*/\n\nqboolean FS_Initialized( void ) {\n\treturn (qboolean)(fs_searchpaths != NULL);\n}\n\nstatic void FS_AssertInitialised( void ) {\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n}\n\n/*\n=================\nFS_PakIsPure\n=================\n*/\nqboolean FS_PakIsPure( pack_t *pack ) {\n\tint i;\n\n\tif ( fs_numServerPaks ) {\n    // NOTE TTimo we are matching checksums without checking the pak names\n    //   this means you can have the same pk3 as the server under a different name, you will still get through sv_pure validation\n    //   (what happens when two pk3's have the same checkums? is it a likely situation?)\n    //   also, if there's a wrong checksumed pk3 and autodownload is enabled, the checksum will be appended to the downloaded pk3 name\n\t\tfor ( i = 0 ; i < fs_numServerPaks ; i++ ) {\n\t\t\t// FIXME: also use hashed file names\n\t\t\tif ( pack->checksum == fs_serverPaks[i] ) {\n\t\t\t\treturn qtrue;\t\t// on the aproved list\n\t\t\t}\n\t\t}\n\t\treturn qfalse;\t// not on the pure server pak list\n\t}\n\treturn qtrue;\n}\n\n/*\n================\nreturn a hash value for the filename\n================\n*/\nstatic long FS_HashFileName( const char *fname, int hashSize ) {\n\tint\t\ti;\n\tlong\thash;\n\tchar\tletter;\n\n\thash = 0;\n\ti = 0;\n\twhile (fname[i] != '\\0') {\n\t\tletter = tolower(fname[i]);\n\t\tif (letter =='.') break;\t\t\t\t// don't include extension\n\t\tif (letter =='\\\\') letter = '/';\t\t// damn path names\n\t\tif (letter == PATH_SEP) letter = '/';\t\t// damn path names\n\t\thash+=(long)(letter)*(i+119);\n\t\ti++;\n\t}\n\thash = (hash ^ (hash >> 10) ^ (hash >> 20));\n\thash &= (hashSize-1);\n\treturn hash;\n}\n\nstatic fileHandle_t FS_HandleForFile(void) {\n\tint\t\ti;\n\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o == NULL ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tCom_Error( ERR_DROP, \"FS_HandleForFile: none free\" );\n\treturn 0;\n}\n\nstatic FILE\t*FS_FileForHandle( fileHandle_t f ) {\n\tif ( f < 1 || f >= MAX_FILE_HANDLES ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: out of range\" );\n\t}\n\tif (fsh[f].zipFile == qtrue) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: can't get FILE on zip file\" );\n\t}\n\tif ( ! fsh[f].handleFiles.file.o ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: NULL\" );\n\t}\n\n\treturn fsh[f].handleFiles.file.o;\n}\n\nvoid\tFS_ForceFlush( fileHandle_t f ) {\n\tFILE *file;\n\n\tfile = FS_FileForHandle(f);\n\tsetvbuf( file, NULL, _IONBF, 0 );\n}\n\n/*\n================\nFS_fplength\n================\n*/\n\nlong FS_fplength(FILE *h)\n{\n\tlong\t\tpos;\n\tlong\t\tend;\n\n\tpos = ftell(h);\n\tif ( pos == EOF )\n\t\treturn EOF;\n\n\tfseek(h, 0, SEEK_END);\n\tend = ftell(h);\n\tfseek(h, pos, SEEK_SET);\n\n\treturn end;\n}\n\n/*\n================\nFS_filelength\n\nIf this is called on a non-unique FILE (from a pak file),\nit will return the size of the pak file, not the expected\nsize of the file.\n================\n*/\nint FS_filelength( fileHandle_t f ) {\n\tFILE\t*h;\n\n\th = FS_FileForHandle(f);\n\n\tif(h == NULL)\n\t\treturn EOF;\n\telse\n\t\treturn FS_fplength(h);\n}\n\n/*\n====================\nFS_ReplaceSeparators\n\nFix things up differently for win/unix/mac\n====================\n*/\nvoid FS_ReplaceSeparators( char *path ) {\n\tchar\t*s;\n\tqboolean lastCharWasSep = qfalse;\n\n\tfor ( s = path ; *s ; s++ ) {\n\t\tif ( *s == '/' || *s == '\\\\' ) {\n\t\t\tif ( !lastCharWasSep ) {\n\t\t\t\t*s = PATH_SEP;\n\t\t\t\tlastCharWasSep = qtrue;\n\t\t\t} else {\n\t\t\t\tmemmove (s, s + 1, strlen (s));\n\t\t\t}\n\t\t} else {\n\t\t\tlastCharWasSep = qfalse;\n\t\t}\n\t}\n}\n\n/*\n===================\nFS_BuildOSPath\n\nQpath may have either forward or backwards slashes\n===================\n*/\nchar *FS_BuildOSPath( const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\t// Fix for filenames that are given to FS with a leading \"/\" (/botfiles/Foo)\n\tif (qpath[0] == '\\\\' || qpath[0] == '/')\n\t\tqpath++;\n\n\tCom_sprintf( temp, sizeof(temp), \"/base/%s\", qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", fs_basepath->string, temp );\n\n\treturn ospath[toggle];\n}\n\nchar *FS_BuildOSPath( const char *base, const char *game, const char *qpath ) {\n\tchar\ttemp[MAX_OSPATH];\n\tstatic char ospath[4][MAX_OSPATH];\n\tstatic int toggle;\n\n\tint nextToggle = (toggle + 1)&3;\t// allows four returns without clash (increased from 2 during fs_copyfiles 2 enhancement)\n\ttoggle = nextToggle;\n\n\tif( !game || !game[0] ) {\n\t\tgame = fs_gamedir;\n\t}\n\n\tCom_sprintf( temp, sizeof(temp), \"/%s/%s\", game, qpath );\n\tFS_ReplaceSeparators( temp );\n\tCom_sprintf( ospath[toggle], sizeof( ospath[0] ), \"%s%s\", base, temp );\n\n\treturn ospath[toggle];\n}\n\n/*\n============\nFS_CreatePath\n\nCreates any directories needed to store the given filename\n============\n*/\nqboolean FS_CreatePath (char *OSPath) {\n\tchar\t*ofs;\n\tchar\tpath[MAX_OSPATH];\n\n\t// make absolutely sure that it can't back up the path\n\t// FIXME: is c: allowed???\n\tif ( strstr( OSPath, \"..\" ) || strstr( OSPath, \"::\" ) ) {\n\t\tCom_Printf( \"WARNING: refusing to create relative path \\\"%s\\\"\\n\", OSPath );\n\t\treturn qtrue;\n\t}\n\n\tQ_strncpyz( path, OSPath, sizeof( path ) );\n\tFS_ReplaceSeparators( path );\n\n\t// Skip creation of the root directory as it will always be there\n\tofs = strchr( path, PATH_SEP );\n\tif ( ofs ) {\n\t\tofs++;\n\t}\n\n\tfor (; ofs != NULL && *ofs ; ofs++) {\n\t\tif (*ofs == PATH_SEP) {\n\t\t\t// create the directory\n\t\t\t*ofs = 0;\n\t\t\tif (!Sys_Mkdir (path)) {\n\t\t\t\tCom_Error( ERR_FATAL, \"FS_CreatePath: failed to create path \\\"%s\\\"\",\n\t\t\t\t\tpath );\n\t\t\t}\n\t\t\t*ofs = PATH_SEP;\n\t\t}\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_CheckFilenameIsMutable\n\nERR_FATAL if trying to maniuplate a file with the platform library, or pk3 extension\n=================\n*/\nstatic void FS_CheckFilenameIsMutable( const char *filename, const char *function )\n{\n\t// Check if the filename ends with the library, or pk3 extension\n\tif( COM_CompareExtension( filename, DLL_EXT )\n\t\t|| COM_CompareExtension( filename, \".pk3\" ) )\n\t{\n\t\tCom_Error( ERR_FATAL, \"%s: Not allowed to manipulate '%s' due \"\n\t\t\t\"to %s extension\", function, filename, COM_GetExtension( filename ) );\n\t}\n}\n\n/*\n=================\nFS_CopyFile\n\nCopy a fully specified file from one place to another\n=================\n*/\nvoid FS_CopyFile( char *fromOSPath, char *toOSPath ) {\n\tFILE\t*f;\n\tint\t\tlen;\n\tbyte\t*buf;\n\n\tFS_CheckFilenameIsMutable( fromOSPath, __func__ );\n\n\tCom_Printf( \"copy %s to %s\\n\", fromOSPath, toOSPath );\n\n\tif (strstr(fromOSPath, \"journal.dat\") || strstr(fromOSPath, \"journaldata.dat\")) {\n\t\tCom_Printf( \"Ignoring journal files\\n\");\n\t\treturn;\n\t}\n\n\tf = fopen( fromOSPath, \"rb\" );\n\tif ( !f ) {\n\t\treturn;\n\t}\n\tfseek (f, 0, SEEK_END);\n\tlen = ftell (f);\n\tfseek (f, 0, SEEK_SET);\n\n\tif ( len == EOF )\n\t{\n\t\tfclose( f );\n\t\tCom_Error( ERR_FATAL, \"Bad file length in FS_CopyFile()\" );\n\t}\n\n\t// we are using direct malloc instead of Z_Malloc here, so it\n\t// probably won't work on a mac... Its only for developers anyway...\n\tbuf = (unsigned char *)malloc( len );\n\tif (fread( buf, 1, len, f ) != (unsigned)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\n\tif( FS_CreatePath( toOSPath ) ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\n\tf = fopen( toOSPath, \"wb\" );\n\tif ( !f ) {\n\t\tfree ( buf );\n\t\treturn;\n\t}\n\tif (fwrite( buf, 1, len, f ) != (unsigned)len)\n\t{\n\t\tfclose( f );\n\t\tfree ( buf );\n\t\tCom_Error( ERR_FATAL, \"Short write in FS_Copyfiles()\\n\" );\n\t}\n\tfclose( f );\n\tfree( buf );\n}\n\n/*\n===========\nFS_Remove\n\n===========\n*/\nvoid FS_Remove( const char *osPath ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tremove( osPath );\n}\n\n/*\n===========\nFS_HomeRemove\n\n===========\n*/\nvoid FS_HomeRemove( const char *homePath ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tremove( FS_BuildOSPath( fs_homepath->string,\n\t\t\tfs_gamedir, homePath ) );\n}\n\n/*\n===========\nFS_Rmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_Rmdir( const char *osPath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( osPath, __func__ );\n\n\tif ( recursive ) {\n\t\tint numfiles;\n\t\tint i;\n\t\tchar **filesToRemove = Sys_ListFiles( osPath, \"\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tchar fileOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( fileOsPath, sizeof( fileOsPath ), \"%s/%s\", osPath, filesToRemove[i] );\n\t\t\tFS_Remove( fileOsPath );\n\t\t}\n\t\tFS_FreeFileList( filesToRemove );\n\n\t\tchar **directoriesToRemove = Sys_ListFiles( osPath, \"/\", NULL, &numfiles, qfalse );\n\t\tfor ( i = 0; i < numfiles; i++ ) {\n\t\t\tif ( !Q_stricmp( directoriesToRemove[i], \".\" ) || !Q_stricmp( directoriesToRemove[i], \"..\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar directoryOsPath[MAX_OSPATH];\n\t\t\tCom_sprintf( directoryOsPath, sizeof( directoryOsPath ), \"%s/%s\", osPath, directoriesToRemove[i] );\n\t\t\tFS_Rmdir( directoryOsPath, qtrue );\n\t\t}\n\t\tFS_FreeFileList( directoriesToRemove );\n\t}\n\n\trmdir( osPath );\n}\n\n/*\n===========\nFS_HomeRmdir\n\nRemoves a directory, optionally deleting all files under it\n===========\n*/\nvoid FS_HomeRmdir( const char *homePath, qboolean recursive ) {\n\tFS_CheckFilenameIsMutable( homePath, __func__ );\n\n\tFS_Rmdir( FS_BuildOSPath( fs_homepath->string,\n\t\t\t\t\tfs_gamedir, homePath ), recursive );\n}\n\n/*\n================\nFS_FileInPathExists\n\nTests if path and file exists\n================\n*/\nqboolean FS_FileInPathExists(const char *testpath)\n{\n\tFILE *filep;\n\n\tfilep = fopen(testpath, \"rb\");\n\n\tif(filep)\n\t{\n\t\tfclose(filep);\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_FileExists\n\nTests if the file exists in the current gamedir, this DOES NOT\nsearch the paths.  This is to determine if opening a file to write\n(which always goes into the current gamedir) will cause any overwrites.\nNOTE TTimo: this goes with FS_FOpenFileWrite for opening the file afterwards\n================\n*/\nqboolean FS_FileExists( const char *file )\n{\n\treturn FS_FileInPathExists(FS_BuildOSPath(fs_homepath->string, fs_gamedir, file));\n}\n\n/*\n================\nFS_SV_FileExists\n\nTests if the file exists\n================\n*/\nqboolean FS_SV_FileExists( const char *file )\n{\n\tchar *testpath;\n\n\ttestpath = FS_BuildOSPath( fs_homepath->string, file, \"\");\n\ttestpath[strlen(testpath)-1] = '\\0';\n\n\treturn FS_FileInPathExists(testpath);\n}\n\n/*\n===========\nFS_SV_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_SV_FOpenFileWrite( const char *filename ) {\n\tchar *ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tCom_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_SV_FOpenFileRead\nsearch for a file somewhere below the home path, base path or cd path\nwe search in that order, matching FS_SV_FOpenFileRead order\n===========\n*/\nint FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp ) {\n\tchar *ospath;\n\tfileHandle_t\tf = 0;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\t// search homepath\n\tospath = FS_BuildOSPath( fs_homepath->string, filename, \"\" );\n\t// remove trailing slash\n\tospath[strlen(ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_homepath): %s\\n\", ospath );\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// NOTE TTimo on non *nix systems, fs_homepath == fs_basepath, might want to avoid\n\t\tif (Q_stricmp(fs_homepath->string,fs_basepath->string))\n\t\t{\n\t\t\t// search basepath\n\t\t\tospath = FS_BuildOSPath( fs_basepath->string, filename, \"\" );\n\t\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\t\tif ( fs_debug->integer )\n\t\t\t{\n\t\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_basepath): %s\\n\", ospath );\n\t\t\t}\n\n\t\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\t\tfsh[f].handleSync = qfalse;\n\t\t}\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\tif (!fsh[f].handleFiles.file.o)\n\t{\n\t\t// search cd path\n\t\tospath = FS_BuildOSPath( fs_cdpath->string, filename, \"\" );\n\t\tospath[strlen(ospath)-1] = '\\0';\n\n\t\tif (fs_debug->integer)\n\t\t{\n\t\t\tCom_Printf( \"FS_SV_FOpenFileRead (fs_cdpath) : %s\\n\", ospath );\n\t\t}\n\n\t\tfsh[f].handleFiles.file.o = fopen( ospath, \"rb\" );\n\t\tfsh[f].handleSync = qfalse;\n\n\t\tif ( !fsh[f].handleFiles.file.o )\n\t\t{\n\t\t\tf = 0;\n\t\t}\n\t}\n\n\t*fp = f;\n\tif (f) {\n\t\treturn FS_filelength(f);\n\t}\n\treturn 0;\n}\n\n/*\n===========\nFS_SV_Rename\n\n===========\n*/\nvoid FS_SV_Rename( const char *from, const char *to, qboolean safe ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, from, \"\" );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, to, \"\" );\n\tfrom_ospath[strlen(from_ospath)-1] = '\\0';\n\tto_ospath[strlen(to_ospath)-1] = '\\0';\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_SV_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\t}\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_Rename\n\n===========\n*/\nvoid FS_Rename( const char *from, const char *to ) {\n\tchar\t\t\t*from_ospath, *to_ospath;\n\n\tFS_AssertInitialised();\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\tif (rename( from_ospath, to_ospath )) {\n\t\t// Failed, try copying it and deleting the original\n\t\tFS_CopyFile ( from_ospath, to_ospath );\n\t\tFS_Remove ( from_ospath );\n\t}\n}\n\n/*\n===========\nFS_FCloseFile\n\nClose a file.\n\nThere are three cases handled:\n\n  * normal file: closed with fclose.\n\n  * file in pak3 archive: subfile is closed with unzCloseCurrentFile, but the\n    minizip handle to the pak3 remains open.\n\n  * file in pak3 archive, opened with \"unique\" flag: This file did not use\n    the system minizip handle to the pak3 file, but its own dedicated one.\n    The dedicated handle is closed with unzClose.\n\n===========\n*/\nvoid FS_FCloseFile( fileHandle_t f ) {\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\tunzCloseCurrentFile( fsh[f].handleFiles.file.z );\n\t\tif ( fsh[f].handleFiles.unique ) {\n\t\t\tunzClose( fsh[f].handleFiles.file.z );\n\t\t}\n\t\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n\t\treturn;\n\t}\n\n\t// we didn't find it as a pak, so close it as a unique file\n\tif (fsh[f].handleFiles.file.o) {\n\t\tfclose (fsh[f].handleFiles.file.o);\n\t}\n\tCom_Memset( &fsh[f], 0, sizeof( fsh[f] ) );\n}\n\n/*\n===========\nFS_FOpenFileWrite\n\n===========\n*/\nfileHandle_t FS_FOpenFileWrite( const char *filename, qboolean safe ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileWrite: %s\\n\", ospath );\n\t}\n\n\tif ( safe ) {\n\t\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\t}\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\t// enabling the following line causes a recursive function call loop\n\t// when running with +set logfile 1 +set developer 1\n\t//Com_DPrintf( \"writing to: %s\\n\", ospath );\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"wb\" );\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FOpenFileAppend\n\n===========\n*/\nfileHandle_t FS_FOpenFileAppend( const char *filename ) {\n\tchar\t\t\t*ospath;\n\tfileHandle_t\tf;\n\n\tFS_AssertInitialised();\n\n\tf = FS_HandleForFile();\n\tfsh[f].zipFile = qfalse;\n\n\tQ_strncpyz( fsh[f].name, filename, sizeof( fsh[f].name ) );\n\n\t// don't let sound stutter\n\tS_ClearSoundBuffer();\n\n\tospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, filename );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_FOpenFileAppend: %s\\n\", ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( ospath, __func__ );\n\n\tif( FS_CreatePath( ospath ) ) {\n\t\treturn 0;\n\t}\n\n\tfsh[f].handleFiles.file.o = fopen( ospath, \"ab\" );\n\tfsh[f].handleSync = qfalse;\n\tif (!fsh[f].handleFiles.file.o) {\n\t\tf = 0;\n\t}\n\treturn f;\n}\n\n/*\n===========\nFS_FilenameCompare\n\nIgnore case and separator char distinctions\n===========\n*/\nqboolean FS_FilenameCompare( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 != c2) {\n\t\t\treturn qtrue;\t\t// strings not equal\n\t\t}\n\t} while (c1);\n\n\treturn qfalse;\t\t// strings are equal\n}\n\n/*\n===========\nFS_IsExt\n\nReturn qtrue if ext matches file extension filename\n===========\n*/\n\nqboolean FS_IsExt(const char *filename, const char *ext, int namelen)\n{\n\tint extlen;\n\n\textlen = strlen(ext);\n\n\tif(extlen > namelen)\n\t\treturn qfalse;\n\n\tfilename += namelen - extlen;\n\n\treturn (qboolean)!Q_stricmp(filename, ext);\n}\n\n/*\n===========\nFS_IsDemoExt\n\nReturn qtrue if filename has a demo extension\n===========\n*/\n\n#define DEMO_EXTENSION \"dm_\"\nqboolean FS_IsDemoExt(const char *filename, int namelen)\n{\n\tconst char *ext_test;\n\n\text_test = strrchr(filename, '.');\n\tif(ext_test && !Q_stricmpn(ext_test + 1, DEMO_EXTENSION, ARRAY_LEN(DEMO_EXTENSION) - 1))\n\t{\n\t\tint protocol = atoi(ext_test + ARRAY_LEN(DEMO_EXTENSION));\n\n\t\tif(protocol == PROTOCOL_VERSION)\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n#ifdef _WIN32\n\nbool Sys_GetFileTime(LPCSTR psFileName, FILETIME &ft)\n{\n\tbool bSuccess = false;\n\tHANDLE hFile = INVALID_HANDLE_VALUE;\n\n\thFile = CreateFile(\tpsFileName,\t// LPCTSTR lpFileName,          // pointer to name of the file\n\t\t\t\t\t\tGENERIC_READ,\t\t\t// DWORD dwDesiredAccess,       // access (read-write) mode\n\t\t\t\t\t\tFILE_SHARE_READ,\t\t// DWORD dwShareMode,           // share mode\n\t\t\t\t\t\tNULL,\t\t\t\t\t// LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t// pointer to security attributes\n\t\t\t\t\t\tOPEN_EXISTING,\t\t\t// DWORD dwCreationDisposition,  // how to create\n\t\t\t\t\t\tFILE_FLAG_NO_BUFFERING,// DWORD dwFlagsAndAttributes,   // file attributes\n\t\t\t\t\t\tNULL\t\t\t\t\t// HANDLE hTemplateFile          // handle to file with attributes to\n\t\t\t\t\t\t);\n\n\tif (hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (GetFileTime(hFile,\t// handle to file\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpCreationTime\n\t\t\t\t\t\tNULL,\t// LPFILETIME lpLastAccessTime\n\t\t\t\t\t\t&ft\t\t// LPFILETIME lpLastWriteTime\n\t\t\t\t\t\t)\n\t\t\t)\n\t\t{\n\t\t\tbSuccess = true;\n\t\t}\n\n\t\tCloseHandle(hFile);\n\t}\n\n\treturn bSuccess;\n}\n\nbool Sys_FileOutOfDate( LPCSTR psFinalFileName /* dest */, LPCSTR psDataFileName /* src */ )\n{\n\tFILETIME ftFinalFile, ftDataFile;\n\n\tif (Sys_GetFileTime(psFinalFileName, ftFinalFile) && Sys_GetFileTime(psDataFileName, ftDataFile))\n\t{\n\t\t// timer res only accurate to within 2 seconds on FAT, so can't do exact compare...\n\t\t//\n\t\t//LONG l = CompareFileTime( &ftFinalFile, &ftDataFile );\n\t\tif (  (fabs((double)(ftFinalFile.dwLowDateTime - ftDataFile.dwLowDateTime)) <= 20000000 ) &&\n\t\t\t\t  ftFinalFile.dwHighDateTime == ftDataFile.dwHighDateTime\n\t\t\t)\n\t\t{\n\t\t\treturn false;\t// file not out of date, ie use it.\n\t\t}\n\t\treturn true;\t// flag return code to copy over a replacement version of this file\n\t}\n\n\n\t// extra error check, report as suspicious if you find a file locally but not out on the net.,.\n\t//\n\tif (com_developer->integer)\n\t{\n\t\tif (!Sys_GetFileTime(psDataFileName, ftDataFile))\n\t\t{\n\t\t\tCom_Printf( \"Sys_FileOutOfDate: reading %s but it's not on the net!\\n\", psFinalFileName);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n#endif // _WIN32\n\nbool FS_FileCacheable(const char* const filename)\n{\n\textern\tcvar_t\t*com_buildScript;\n\tif (com_buildScript && com_buildScript->integer)\n\t{\n\t\treturn true;\n\t}\n\treturn( strchr(filename, '/') != 0 );\n}\n\n/*\n===========\nFS_FOpenFileRead\n\nFinds the file in the search path.\nReturns filesize and an open FILE pointer.\nUsed for streaming data out of either a\nseparate file or a ZIP file.\n===========\n*/\nextern qboolean\t\tcom_fullyInitialized;\n\nlong FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE ) {\n\tsearchpath_t\t*search;\n\tchar\t\t\t*netpath;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tdirectory_t\t\t*dir;\n\tlong\t\t\thash;\n\t//unz_s\t\t\t*zfi;\n\t//void\t\t\t*temp;\n\tint\t\t\t\tl;\n\tbool\t\t\tisUserConfig = false;\n\n\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( file == NULL ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'file' parameter passed\\n\" );\n\t}\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\t// make sure the q3key file is only readable by the quake3.exe at initialization\n\t// any other time the key should only be accessed in memory using the provided functions\n\tif( com_fullyInitialized && strstr( filename, \"q3key\" ) ) {\n\t\t*file = 0;\n\t\treturn -1;\n\t}\n\n\tisUserConfig = !Q_stricmp( filename, \"autoexec.cfg\" ) || !Q_stricmp( filename, Q3CONFIG_CFG );\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\t*file = FS_HandleForFile();\n\tfsh[*file].handleFiles.unique = uniqueFILE;\n\n\t// this new bool is in for an optimisation, if you (eg) opened a BSP file under fs_copyfiles==2,\n\t//\tthen it triggered a copy operation to update your local HD version, then this will re-open the\n\t//\tfile handle on your local version, not the net build. This uses a bit more CPU to re-do the loop\n\t//\tlogic, but should read faster than accessing the net version a second time.\n\t//\n\tqboolean bFasterToReOpenUsingNewLocalFile = qfalse;\n\n\tdo\n\t{\n\t\tbFasterToReOpenUsingNewLocalFile = qfalse;\n\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t//\n\t\t\tif ( search->pack ) {\n\t\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t\t}\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t\t// disregard if it doesn't match one of the allowed pure pak files\n\t\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// autoexec.cfg and openjk.cfg can only be loaded outside of pk3 files.\n\t\t\t\tif ( isUserConfig ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpak = search->pack;\n\t\t\t\tpakFile = pak->hashTable[hash];\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\n\t\t\t\t\t\t// mark the pak as having been referenced and mark specifics on cgame and ui\n\t\t\t\t\t\t// shaders, txt, arena files  by themselves do not count as a reference as\n\t\t\t\t\t\t// these are loaded from all pk3s\n\t\t\t\t\t\t// from every pk3 file..\n\n\t\t\t\t\t\t// The x86.dll suffixes are needed in order for sv_pure to continue to\n\t\t\t\t\t\t// work on non-x86/windows systems...\n\n\t\t\t\t\t\tl = strlen( filename );\n\t\t\t\t\t\tif ( !(pak->referenced & FS_GENERAL_REF)) {\n\t\t\t\t\t\t\tif( !FS_IsExt(filename, \".shader\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".txt\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".str\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".cfg\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".config\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".bot\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".arena\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".menu\", l) &&\n\t\t\t\t\t\t\t    !FS_IsExt(filename, \".fcf\", l) &&\n\t\t\t\t\t\t\t    Q_stricmp(filename, \"jampgamex86.dll\") != 0 &&\n\t\t\t\t\t\t\t    //Q_stricmp(filename, \"vm/qagame.qvm\") != 0 &&\n\t\t\t\t\t\t\t    !strstr(filename, \"levelshots\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_GENERAL_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(pak->referenced & FS_CGAME_REF))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( Q_stricmp( filename, \"cgame.qvm\" ) == 0 ||\n\t\t\t\t\t\t\t\t\tQ_stricmp( filename, \"cgamex86.dll\" ) == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_CGAME_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(pak->referenced & FS_UI_REF))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( Q_stricmp( filename, \"ui.qvm\" ) == 0 ||\n\t\t\t\t\t\t\t\t\tQ_stricmp( filename, \"uix86.dll\" ) == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpak->referenced |= FS_UI_REF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( uniqueFILE ) {\n\t\t\t\t\t\t\t// open a new file on the pakfile\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = unzOpen (pak->pakFilename);\n\t\t\t\t\t\t\tif (fsh[*file].handleFiles.file.z == NULL) {\n\t\t\t\t\t\t\t\tCom_Error (ERR_FATAL, \"Couldn't open %s\", pak->pakFilename);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfsh[*file].handleFiles.file.z = pak->handle;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\t\t\tfsh[*file].zipFile = qtrue;\n\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);\n\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile(fsh[*file].handleFiles.file.z);\n\n#if 0\n\t\t\t\t\t\tzfi = (unz_s *)fsh[*file].handleFiles.file.z;\n\t\t\t\t\t\t// in case the file was new\n\t\t\t\t\t\ttemp = zfi->filestream;\n\t\t\t\t\t\t// set the file position in the zip file (also sets the current file info)\n\t\t\t\t\t\tunzSetOffset(pak->handle, pakFile->pos);\n\t\t\t\t\t\t// copy the file info into the unzip structure\n\t\t\t\t\t\tCom_Memcpy( zfi, pak->handle, sizeof(unz_s) );\n\t\t\t\t\t\t// we copy this back into the structure\n\t\t\t\t\t\tzfi->filestream = temp;\n\t\t\t\t\t\t// open the file in the zip\n\t\t\t\t\t\tunzOpenCurrentFile( fsh[*file].handleFiles.file.z );\n#endif\n\t\t\t\t\t\tfsh[*file].zipFilePos = pakFile->pos;\n\t\t\t\t\t\tfsh[*file].zipFileLen = pakFile->len;\n\n\t\t\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s')\\n\",\n\t\t\t\t\t\t\t\tfilename, pak->pakFilename );\n\t\t\t\t\t\t}\n\t#ifndef DEDICATED\n\t#ifndef FINAL_BUILD\n\t\t\t\t\t\t// Check for unprecached files when in game but not in the menus\n\t\t\t\t\t\tif((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCom_Printf(S_COLOR_YELLOW \"WARNING: File %s not precached\\n\", filename);\n\t\t\t\t\t\t}\n\t#endif\n\t#endif // DEDICATED\n\t\t\t\t\t\treturn pakFile->len;\n\t\t\t\t\t}\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while(pakFile != NULL);\n\t\t\t} else if ( search->dir ) {\n\t\t\t\t// check a file in the directory tree\n\n\t\t\t\t// if we are running restricted, the only files we\n\t\t\t\t// will allow to come from the directory are .cfg files\n\t\t\t\tl = strlen( filename );\n\t\t  // FIXME TTimo I'm not sure about the fs_numServerPaks test\n\t\t  // if you are using FS_ReadFile to find out if a file exists,\n\t\t  //   this test can make the search fail although the file is in the directory\n\t\t  // I had the problem on https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=8\n\t\t  // turned out I used FS_FileExists instead\n\t\t\t\tif ( fs_numServerPaks ) {\n\t\t\t\t\tif ( !FS_IsExt( filename, \".cfg\", l ) &&\t\t// for config files\n\t\t\t\t\t    !FS_IsExt( filename, \".fcf\", l ) &&\t\t// force configuration files\n\t\t\t\t\t    !FS_IsExt( filename, \".menu\", l ) &&\t\t// menu files\n\t\t\t\t\t    !FS_IsExt( filename, \".game\", l ) &&\t\t// menu files\n\t\t\t\t\t    !FS_IsExt( filename, \".dat\", l ) &&\t\t// for journal files\n\t\t\t\t\t    !FS_IsDemoExt( filename, l ) ) {\t\t\t// demos\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdir = search->dir;\n\n\t\t\t\tnetpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\t\tfsh[*file].handleFiles.file.o = fopen (netpath, \"rb\");\n\t\t\t\tif ( !fsh[*file].handleFiles.file.o ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !FS_IsExt( filename, \".cfg\", l ) &&\t\t// for config files\n\t\t\t\t\t!FS_IsExt( filename, \".fcf\", l ) &&\t\t// force configuration files\n\t\t\t\t\t!FS_IsExt( filename, \".menu\", l ) &&\t\t// menu files\n\t\t\t\t\t!FS_IsExt( filename, \".game\", l ) &&\t\t// menu files\n\t\t\t\t\t!FS_IsExt( filename, \".dat\", l ) &&\t\t// for journal files\n\t\t\t\t\t!FS_IsDemoExt( filename, l ) ) {\t\t\t// demos\n\t\t\t\t\tfs_fakeChkSum = Q_flrand(0.0f, 1.0f);\n\t\t\t\t}\n#ifdef _WIN32\n\t\t\t\t// if running with fs_copyfiles 2, and search path == local, then we need to fail to open\n\t\t\t\t//\tif the time/date stamp != the network version (so it'll loop round again and use the network path,\n\t\t\t\t//\twhich comes later in the search order)\n\t\t\t\t//\n\t\t\t\tif ( fs_copyfiles->integer == 2 && fs_cdpath->string[0] && !Q_stricmp( dir->path, fs_basepath->string )\n\t\t\t\t\t&& FS_FileCacheable(filename) )\n\t\t\t\t{\n\t\t\t\t\tif ( Sys_FileOutOfDate( netpath, FS_BuildOSPath( fs_cdpath->string, dir->gamedir, filename ) ))\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\tfsh[*file].handleFiles.file.o = 0;\n\t\t\t\t\t\tcontinue;\t//carry on to find the cdpath version.\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tQ_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );\n\t\t\t\tfsh[*file].zipFile = qfalse;\n\t\t\t\tif ( fs_debug->integer ) {\n\t\t\t\t\tCom_Printf( \"FS_FOpenFileRead: %s (found in '%s%c%s')\\n\", filename,\n\t\t\t\t\t\tdir->path, PATH_SEP, dir->gamedir );\n\t\t\t\t}\n\n#ifdef _WIN32\n\t\t\t\t// if we are getting it from the cdpath, optionally copy it\n\t\t\t\t//  to the basepath\n\t\t\t\tif ( fs_copyfiles->integer && !Q_stricmp( dir->path, fs_cdpath->string ) ) {\n\t\t\t\t\tchar\t*copypath;\n\n\t\t\t\t\tcopypath = FS_BuildOSPath( fs_basepath->string, dir->gamedir, filename );\n\t\t\t\t\tswitch ( fs_copyfiles->integer )\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFS_CopyFile( netpath, copypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (FS_FileCacheable(filename) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// maybe change this to Com_DPrintf?   On the other hand...\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tCom_Printf( \"fs_copyfiles(2), Copying: %s to %s\\n\", netpath, copypath );\n\n\t\t\t\t\t\t\t\tFS_CreatePath( copypath );\n\n\t\t\t\t\t\t\t\tbool bOk = true;\n\t\t\t\t\t\t\t\tif (!CopyFile( netpath, copypath, FALSE ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDWORD dwAttrs = GetFileAttributes(copypath);\n\t\t\t\t\t\t\t\t\tSetFileAttributes(copypath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);\n\t\t\t\t\t\t\t\t\tbOk = !!CopyFile( netpath, copypath, FALSE );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (bOk)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// clear this handle and setup for re-opening of the new local copy...\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tbFasterToReOpenUsingNewLocalFile = qtrue;\n\t\t\t\t\t\t\t\t\tfclose(fsh[*file].handleFiles.file.o);\n\t\t\t\t\t\t\t\t\tfsh[*file].handleFiles.file.o = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (bFasterToReOpenUsingNewLocalFile)\n\t\t\t\t{\n\t\t\t\t\tbreak;\t// and re-read the local copy, not the net version\n\t\t\t\t}\n\n\t#ifndef DEDICATED\n\t#ifndef FINAL_BUILD\n\t\t\t\t// Check for unprecached files when in game but not in the menus\n\t\t\t\tif((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))\n\t\t\t\t{\n\t\t\t\t\tCom_Printf(S_COLOR_YELLOW \"WARNING: File %s not precached\\n\", filename);\n\t\t\t\t}\n\t#endif\n\t#endif // dedicated\n\t\t\t\treturn FS_fplength(fsh[*file].handleFiles.file.o);\n\t\t\t}\n\t\t}\n\t}\n\twhile ( bFasterToReOpenUsingNewLocalFile );\n\n\tCom_DPrintf (\"Can't find %s\\n\", filename);\n#ifdef FS_MISSING\n\tif (missingFiles) {\n\t\tfprintf(missingFiles, \"%s\\n\", filename);\n\t}\n#endif\n\t*file = 0;\n\treturn -1;\n}\n\n// This is a bit of a hack but it is used for other OS'/arch to still be acceptable with pure servers.\n// Intentionally looking for x86.dll because this is all that exists in pk3s.\nqboolean FS_FindPureDLL(const char *name)\n{\n\tchar dllName[MAX_OSPATH];\n\tfileHandle_t h;\n\n\tif(!fs_searchpaths)\n\t\tCom_Error(ERR_FATAL, \"Filesystem call made without initialization\");\n\n\tif ( !Cvar_VariableValue( \"sv_pure\" ) )\n\t\treturn qtrue;\n\n\tCom_sprintf(dllName, sizeof(dllName), \"%sx86.dll\", name);\n\n\tif(FS_FOpenFileRead(dllName, &h, qtrue) > 0)\n\t{\n\t\tFS_FCloseFile( h );\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n=================\nFS_Read\n\nProperly handles partial reads\n=================\n*/\nint FS_Read( void *buffer, int len, fileHandle_t f ) {\n\tint\t\tblock, remaining;\n\tint\t\tread;\n\tbyte\t*buf;\n\tint\t\ttries;\n\n\tFS_AssertInitialised();\n\n\tif ( !f ) {\n\t\treturn 0;\n\t}\n\n\tbuf = (byte *)buffer;\n\tfs_readCount += len;\n\n\tif (fsh[f].zipFile == qfalse) {\n\t\tremaining = len;\n\t\ttries = 0;\n\t\twhile (remaining) {\n\t\t\tblock = remaining;\n\t\t\tread = fread (buf, 1, block, fsh[f].handleFiles.file.o);\n\t\t\tif (read == 0) {\n\t\t\t\t// we might have been trying to read from a CD, which\n\t\t\t\t// sometimes returns a 0 read on windows\n\t\t\t\tif (!tries) {\n\t\t\t\t\ttries = 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn len-remaining;\t//Com_Error (ERR_FATAL, \"FS_Read: 0 bytes read\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tCom_Error (ERR_FATAL, \"FS_Read: -1 bytes read\");\n\t\t\t}\n\n\t\t\tremaining -= read;\n\t\t\tbuf += read;\n\t\t}\n\t\treturn len;\n\t} else {\n\t\treturn unzReadCurrentFile(fsh[f].handleFiles.file.z, buffer, len);\n\t}\n}\n\n/*\n=================\nFS_Write\n\nProperly handles partial writes\n=================\n*/\nint FS_Write( const void *buffer, int len, fileHandle_t h ) {\n\tint\t\tblock, remaining;\n\tint\t\twritten;\n\tbyte\t*buf;\n\tint\t\ttries;\n\tFILE\t*f;\n\n\tFS_AssertInitialised();\n\n\tif ( !h ) {\n\t\treturn 0;\n\t}\n\n\tf = FS_FileForHandle(h);\n\tbuf = (byte *)buffer;\n\n\tremaining = len;\n\ttries = 0;\n\twhile (remaining) {\n\t\tblock = remaining;\n\t\twritten = fwrite (buf, 1, block, f);\n\t\tif (written == 0) {\n\t\t\tif (!tries) {\n\t\t\t\ttries = 1;\n\t\t\t} else {\n\t\t\t\tCom_Printf( \"FS_Write: 0 bytes written\\n\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (written == -1) {\n\t\t\tCom_Printf( \"FS_Write: -1 bytes written\\n\" );\n\t\t\treturn 0;\n\t\t}\n\n\t\tremaining -= written;\n\t\tbuf += written;\n\t}\n\tif ( fsh[h].handleSync ) {\n\t\tfflush( f );\n\t}\n\treturn len;\n}\n\nvoid QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tva_start (argptr,fmt);\n\tQ_vsnprintf (msg, sizeof(msg), fmt, argptr);\n\tva_end (argptr);\n\n\tFS_Write(msg, strlen(msg), h);\n}\n\n#define PK3_SEEK_BUFFER_SIZE 65536\n/*\n=================\nFS_Seek\n\n=================\n*/\nint FS_Seek( fileHandle_t f, long offset, int origin ) {\n\tint\t\t_origin;\n\n\tFS_AssertInitialised();\n\n\tif (fsh[f].zipFile == qtrue) {\n\t\t//FIXME: this is really, really crappy\n\t\t//(but better than what was here before)\n\t\tbyte\tbuffer[PK3_SEEK_BUFFER_SIZE];\n\t\tint\t\tremainder;\n\t\tint\t\tcurrentPosition = FS_FTell( f );\n\n\t\t// change negative offsets into FS_SEEK_SET\n\t\tif ( offset < 0 ) {\n\t\t\tswitch( origin ) {\n\t\t\t\tcase FS_SEEK_END:\n\t\t\t\t\tremainder = fsh[f].zipFileLen + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_CUR:\n\t\t\t\t\tremainder = currentPosition + offset;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FS_SEEK_SET:\n\t\t\t\tdefault:\n\t\t\t\t\tremainder = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( remainder < 0 ) {\n\t\t\t\tremainder = 0;\n\t\t\t}\n\n\t\t\torigin = FS_SEEK_SET;\n\t\t} else {\n\t\t\tif ( origin == FS_SEEK_END ) {\n\t\t\t\tremainder = fsh[f].zipFileLen - currentPosition + offset;\n\t\t\t} else {\n\t\t\t\tremainder = offset;\n\t\t\t}\n\t\t}\n\n\t\tswitch( origin ) {\n\t\t\tcase FS_SEEK_SET:\n\t\t\t\tif ( remainder == currentPosition ) {\n\t\t\t\t\treturn offset;\n\t\t\t\t}\n\t\t\t\tunzSetOffset(fsh[f].handleFiles.file.z, fsh[f].zipFilePos);\n\t\t\t\tunzOpenCurrentFile(fsh[f].handleFiles.file.z);\n\t\t\t\t//fallthrough\n\n\t\t\tcase FS_SEEK_END:\n\t\t\tcase FS_SEEK_CUR:\n\t\t\t\twhile( remainder > PK3_SEEK_BUFFER_SIZE ) {\n\t\t\t\t\tFS_Read( buffer, PK3_SEEK_BUFFER_SIZE, f );\n\t\t\t\t\tremainder -= PK3_SEEK_BUFFER_SIZE;\n\t\t\t\t}\n\t\t\t\tFS_Read( buffer, remainder, f );\n\t\t\t\treturn offset;\n\n\t\t\tdefault:\n\t\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\" );\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tFILE *file;\n\t\tfile = FS_FileForHandle(f);\n\t\tswitch( origin ) {\n\t\tcase FS_SEEK_CUR:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tbreak;\n\t\tcase FS_SEEK_END:\n\t\t\t_origin = SEEK_END;\n\t\t\tbreak;\n\t\tcase FS_SEEK_SET:\n\t\t\t_origin = SEEK_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_origin = SEEK_CUR;\n\t\t\tCom_Error( ERR_FATAL, \"Bad origin in FS_Seek\\n\" );\n\t\t\tbreak;\n\t\t}\n\n\t\treturn fseek( file, offset, _origin );\n\t}\n}\n\n/*\n======================================================================================\n\nCONVENIENCE FUNCTIONS FOR ENTIRE FILES\n\n======================================================================================\n*/\n\nint\tFS_FileIsInPAK(const char *filename, int *pChecksum ) {\n\tsearchpath_t\t*search;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*pakFile;\n\tlong\t\t\thash = 0;\n\n\tFS_AssertInitialised();\n\n\tif ( !filename ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FOpenFileRead: NULL 'filename' parameter passed\\n\" );\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn -1;\n\t}\n\n\t//\n\t// search through the path, one element at a time\n\t//\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t//\n\t\tif (search->pack) {\n\t\t\thash = FS_HashFileName(filename, search->pack->hashSize);\n\t\t}\n\t\t// is the element a pak file?\n\t\tif ( search->pack && search->pack->hashTable[hash] ) {\n\t\t\t// disregard if it doesn't match one of the allowed pure pak files\n\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tpakFile = pak->hashTable[hash];\n\t\t\tdo {\n\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\tif (pChecksum) {\n\t\t\t\t\t\t*pChecksum = pak->pure_checksum;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpakFile = pakFile->next;\n\t\t\t} while(pakFile != NULL);\n\t\t}\n\t}\n\treturn -1;\n}\n\n/*\n============\nFS_ReadFile\n\nFilename are relative to the quake search path\na null buffer will just return the file length without loading\n============\n*/\nlong FS_ReadFile( const char *qpath, void **buffer ) {\n\tfileHandle_t\th;\n\tbyte*\t\t\tbuf;\n\tqboolean\t\tisConfig;\n\tlong\t\t\t\tlen;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !qpath[0] ) {\n\t\tCom_Error( ERR_FATAL, \"FS_ReadFile with empty name\\n\" );\n\t}\n\n\tbuf = NULL;\t// quiet compiler warning\n\n\t// if this is a .cfg file and we are playing back a journal, read\n\t// it from the journal file\n\tif ( strstr( qpath, \".cfg\" ) ) {\n\t\tisConfig = qtrue;\n\t\tif ( com_journal && com_journal->integer == 2 ) {\n\t\t\tint\t\tr;\n\n\t\t\tCom_DPrintf( \"Loading %s from journal file.\\n\", qpath );\n\t\t\tr = FS_Read( &len, sizeof( len ), com_journalDataFile );\n\t\t\tif ( r != sizeof( len ) ) {\n\t\t\t\tif (buffer != NULL) *buffer = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// if the file didn't exist when the journal was created\n\t\t\tif (!len) {\n\t\t\t\tif (buffer == NULL) {\n\t\t\t\t\treturn 1;\t\t\t// hack for old journal files\n\t\t\t\t}\n\t\t\t\t*buffer = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (buffer == NULL) {\n\t\t\t\treturn len;\n\t\t\t}\n\n\t\t\tbuf = (unsigned char *)Hunk_AllocateTempMemory(len+1);\n\t\t\t*buffer = buf;\n\n\t\t\tr = FS_Read( buf, len, com_journalDataFile );\n\t\t\tif ( r != len ) {\n\t\t\t\tCom_Error( ERR_FATAL, \"Read from journalDataFile failed\" );\n\t\t\t}\n\n\t\t\tfs_loadCount++;\n\n\t\t\t// guarantee that it will have a trailing 0 for string operations\n\t\t\tbuf[len] = 0;\n\n\t\t\treturn len;\n\t\t}\n\t} else {\n\t\tisConfig = qfalse;\n\t}\n\n\t// look for it in the filesystem or pack files\n\tlen = FS_FOpenFileRead( qpath, &h, qfalse );\n\tif ( h == 0 ) {\n\t\tif ( buffer ) {\n\t\t\t*buffer = NULL;\n\t\t}\n\t\t// if we are journalling and it is a config file, write a zero to the journal file\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing zero for %s to journal file.\\n\", qpath );\n\t\t\tlen = 0;\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( !buffer ) {\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing len for %s to journal file.\\n\", qpath );\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\tFS_FCloseFile( h);\n\t\treturn len;\n\t}\n\n\tfs_loadCount++;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\tbuf[len]='\\0';\t// because we're not calling Z_Malloc with optional trailing 'bZeroIt' bool\n\t*buffer = buf;\n\n//\tZ_Label(buf, qpath);\n\n\tFS_Read (buf, len, h);\n\n\t// guarantee that it will have a trailing 0 for string operations\n\tbuf[len] = 0;\n\tFS_FCloseFile( h );\n\n\t// if we are journalling and it is a config file, write it to the journal file\n\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\tCom_DPrintf( \"Writing %s to journal file.\\n\", qpath );\n\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\tFS_Write( buf, len, com_journalDataFile );\n\t\tFS_Flush( com_journalDataFile );\n\t}\n\treturn len;\n}\n\n/*\n=============\nFS_FreeFile\n=============\n*/\nvoid FS_FreeFile( void *buffer ) {\n\tFS_AssertInitialised();\n\tif ( !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FreeFile( NULL )\" );\n\t}\n\n\tZ_Free( buffer );\n}\n\n/*\n============\nFS_WriteFile\n\nFilename are reletive to the quake search path\n============\n*/\nvoid FS_WriteFile( const char *qpath, const void *buffer, int size ) {\n\tfileHandle_t f;\n\n\tFS_AssertInitialised();\n\n\tif ( !qpath || !buffer ) {\n\t\tCom_Error( ERR_FATAL, \"FS_WriteFile: NULL parameter\" );\n\t}\n\n\tf = FS_FOpenFileWrite( qpath );\n\tif ( !f ) {\n\t\tCom_Printf( \"Failed to open %s\\n\", qpath );\n\t\treturn;\n\t}\n\n\tFS_Write( buffer, size, f );\n\n\tFS_FCloseFile( f );\n}\n\n/*\n==========================================================================\n\nZIP FILE LOADING\n\n==========================================================================\n*/\n\n/*\n=================\nFS_LoadZipFile\n\nCreates a new pak_t in the search chain for the contents\nof a zip file.\n=================\n*/\nstatic pack_t *FS_LoadZipFile( const char *zipfile, const char *basename )\n{\n\tfileInPack_t\t*buildBuffer;\n\tpack_t\t\t\t*pack;\n\tunzFile\t\t\tuf;\n\tint\t\t\t\terr;\n\tunz_global_info gi;\n\tchar\t\t\tfilename_inzip[MAX_ZPATH];\n\tunz_file_info\tfile_info;\n\tint\t\t\t\tlen;\n\tsize_t\t\t\ti;\n\tlong\t\t\thash;\n\tint\t\t\t\tfs_numHeaderLongs;\n\tint\t\t\t\t*fs_headerLongs;\n\tchar\t\t\t*namePtr;\n\n\tfs_numHeaderLongs = 0;\n\n\tuf = unzOpen(zipfile);\n\terr = unzGetGlobalInfo (uf,&gi);\n\n\tif (err != UNZ_OK)\n\t\treturn NULL;\n\n\tlen = 0;\n\tunzGoToFirstFile(uf);\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tlen += strlen(filename_inzip) + 1;\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tbuildBuffer = (struct fileInPack_s *)Z_Malloc( (gi.number_entry * sizeof( fileInPack_t )) + len, TAG_FILESYS, qtrue );\n\tnamePtr = ((char *) buildBuffer) + gi.number_entry * sizeof( fileInPack_t );\n\tfs_headerLongs = (int *)Z_Malloc( ( gi.number_entry + 1 ) * sizeof(int), TAG_FILESYS, qtrue );\n\tfs_headerLongs[ fs_numHeaderLongs++ ] = LittleLong( fs_checksumFeed );\n\n\t// get the hash table size from the number of files in the zip\n\t// because lots of custom pk3 files have less than 32 or 64 files\n\tfor (i = 1; i <= MAX_FILEHASH_SIZE; i <<= 1) {\n\t\tif (i > gi.number_entry) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpack = (pack_t *)Z_Malloc( sizeof( pack_t ) + i * sizeof(fileInPack_t *), TAG_FILESYS, qtrue );\n\tpack->hashSize = i;\n\tpack->hashTable = (fileInPack_t **) (((char *) pack) + sizeof( pack_t ));\n\tfor(int j = 0; j < pack->hashSize; j++) {\n\t\tpack->hashTable[j] = NULL;\n\t}\n\n\tQ_strncpyz( pack->pakFilename, zipfile, sizeof( pack->pakFilename ) );\n\tQ_strncpyz( pack->pakBasename, basename, sizeof( pack->pakBasename ) );\n\n\t// strip .pk3 if needed\n\tif ( strlen( pack->pakBasename ) > 4 && !Q_stricmp( pack->pakBasename + strlen( pack->pakBasename ) - 4, \".pk3\" ) ) {\n\t\tpack->pakBasename[strlen( pack->pakBasename ) - 4] = 0;\n\t}\n\n\tpack->handle = uf;\n\tpack->numfiles = gi.number_entry;\n\tunzGoToFirstFile(uf);\n\n\tfor (i = 0; i < gi.number_entry; i++)\n\t{\n\t\terr = unzGetCurrentFileInfo(uf, &file_info, filename_inzip, sizeof(filename_inzip), NULL, 0, NULL, 0);\n\t\tif (err != UNZ_OK) {\n\t\t\tbreak;\n\t\t}\n\t\tif (file_info.uncompressed_size > 0) {\n\t\t\tfs_headerLongs[fs_numHeaderLongs++] = LittleLong(file_info.crc);\n\t\t}\n\t\tQ_strlwr( filename_inzip );\n\t\thash = FS_HashFileName(filename_inzip, pack->hashSize);\n\t\tbuildBuffer[i].name = namePtr;\n\t\tstrcpy( buildBuffer[i].name, filename_inzip );\n\t\tnamePtr += strlen(filename_inzip) + 1;\n\t\t// store the file position in the zip\n\t\tbuildBuffer[i].pos = unzGetOffset(uf);\n\t\tbuildBuffer[i].len = file_info.uncompressed_size;\n\t\tbuildBuffer[i].next = pack->hashTable[hash];\n\t\tpack->hashTable[hash] = &buildBuffer[i];\n\t\tunzGoToNextFile(uf);\n\t}\n\n\tpack->checksum = Com_BlockChecksum( &fs_headerLongs[ 1 ], sizeof(*fs_headerLongs) * ( fs_numHeaderLongs - 1 ) );\n\tpack->pure_checksum = Com_BlockChecksum( fs_headerLongs, sizeof(*fs_headerLongs) * fs_numHeaderLongs );\n\tpack->checksum = LittleLong( pack->checksum );\n\tpack->pure_checksum = LittleLong( pack->pure_checksum );\n\n\tZ_Free(fs_headerLongs);\n\n\tpack->buildBuffer = buildBuffer;\n\treturn pack;\n}\n\n/*\n=================\nFS_FreePak\n\nFrees a pak structure and releases all associated resources\n=================\n*/\n\nvoid FS_FreePak(pack_t *thepak)\n{\n\tunzClose(thepak->handle);\n\tZ_Free(thepak->buildBuffer);\n\tZ_Free(thepak);\n}\n\n/*\n=================\nFS_GetZipChecksum\n\nCompares whether the given pak file matches a referenced checksum\n=================\n*/\nqboolean FS_CompareZipChecksum(const char *zipfile)\n{\n\tpack_t *thepak;\n\tint index, checksum;\n\n\tthepak = FS_LoadZipFile(zipfile, \"\");\n\n\tif(!thepak)\n\t\treturn qfalse;\n\n\tchecksum = thepak->checksum;\n\tFS_FreePak(thepak);\n\n\tfor(index = 0; index < fs_numServerReferencedPaks; index++)\n\t{\n\t\tif(checksum == fs_serverReferencedPaks[index])\n\t\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n\n/*\n=================================================================================\n\nDIRECTORY SCANNING FUNCTIONS\n\n=================================================================================\n*/\n\n#define\tMAX_FOUND_FILES\t0x1000\n\nstatic int FS_ReturnPath( const char *zname, char *zpath, int *depth ) {\n\tint len, at, newdep;\n\n\tnewdep = 0;\n\tzpath[0] = 0;\n\tlen = 0;\n\tat = 0;\n\n\twhile(zname[at] != 0)\n\t{\n\t\tif (zname[at]=='/' || zname[at]=='\\\\') {\n\t\t\tlen = at;\n\t\t\tnewdep++;\n\t\t}\n\t\tat++;\n\t}\n\tstrcpy(zpath, zname);\n\tzpath[len] = 0;\n\t*depth = newdep;\n\n\treturn len;\n}\n\n/*\n==================\nFS_AddFileToList\n==================\n*/\nstatic int FS_AddFileToList( char *name, char *list[MAX_FOUND_FILES], int nfiles ) {\n\tint\t\ti;\n\n\tif ( nfiles == MAX_FOUND_FILES - 1 ) {\n\t\treturn nfiles;\n\t}\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tif ( !Q_stricmp( name, list[i] ) ) {\n\t\t\treturn nfiles;\t\t// allready in list\n\t\t}\n\t}\n\tlist[nfiles] = CopyString( name );\n\tnfiles++;\n\n\treturn nfiles;\n}\n\n/*\n===============\nFS_ListFilteredFiles\n\nReturns a uniqued list of files that match the given criteria\nfrom all search paths\n===============\n*/\nchar **FS_ListFilteredFiles( const char *path, const char *extension, char *filter, int *numfiles ) {\n\tint\t\t\t\tnfiles;\n\tchar\t\t\t**listCopy;\n\tchar\t\t\t*list[MAX_FOUND_FILES];\n\tsearchpath_t\t*search;\n\tint\t\t\t\ti;\n\tint\t\t\t\tpathLength;\n\tint\t\t\t\textensionLength;\n\tint\t\t\t\tlength, pathDepth, temp;\n\tpack_t\t\t\t*pak;\n\tfileInPack_t\t*buildBuffer;\n\tchar\t\t\tzpath[MAX_ZPATH];\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n\n\tif ( !path ) {\n\t\t*numfiles = 0;\n\t\treturn NULL;\n\t}\n\tif ( !extension ) {\n\t\textension = \"\";\n\t}\n\n\tpathLength = strlen( path );\n\tif ( path[pathLength-1] == '\\\\' || path[pathLength-1] == '/' ) {\n\t\tpathLength--;\n\t}\n\textensionLength = strlen( extension );\n\tnfiles = 0;\n\tFS_ReturnPath(path, zpath, &pathDepth);\n\n\t//\n\t// search through the path, one element at a time, adding to list\n\t//\n\tfor (search = fs_searchpaths ; search ; search = search->next) {\n\t\t// is the element a pak file?\n\t\tif (search->pack) {\n\n\t\t\t//ZOID:  If we are pure, don't search for files on paks that\n\t\t\t// aren't on the pure list\n\t\t\tif ( !FS_PakIsPure(search->pack) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// look through all the pak file elements\n\t\t\tpak = search->pack;\n\t\t\tbuildBuffer = pak->buildBuffer;\n\t\t\tfor (i = 0; i < pak->numfiles; i++) {\n\t\t\t\tchar\t*name;\n\t\t\t\tint\t\tzpathLen, depth;\n\n\t\t\t\t// check for directory match\n\t\t\t\tname = buildBuffer[i].name;\n\t\t\t\t//\n\t\t\t\tif (filter) {\n\t\t\t\t\t// case insensitive\n\t\t\t\t\tif (!Com_FilterPath( filter, name, qfalse ))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// unique the match\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tzpathLen = FS_ReturnPath(name, zpath, &depth);\n\n\t\t\t\t\tif ( (depth-pathDepth)>2 || pathLength > zpathLen || Q_stricmpn( name, path, pathLength ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for extension match\n\t\t\t\t\tlength = strlen( name );\n\t\t\t\t\tif ( length < extensionLength ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Q_stricmp( name + length - extensionLength, extension ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// unique the match\n\n\t\t\t\t\ttemp = pathLength;\n\t\t\t\t\tif (pathLength) {\n\t\t\t\t\t\ttemp++;\t\t// include the '/'\n\t\t\t\t\t}\n\t\t\t\t\tnfiles = FS_AddFileToList( name + temp, list, nfiles );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (search->dir) { // scan for files in the filesystem\n\t\t\tchar\t*netpath;\n\t\t\tint\t\tnumSysFiles;\n\t\t\tchar\t**sysFiles;\n\t\t\tchar\t*name;\n\n\t\t\t// don't scan directories for files if we are pure or restricted\n\t\t\tif ( fs_numServerPaks &&\n\t\t\t\t (!extension || Q_stricmp(extension, \"fcf\")) )\n\t\t\t{\n\t\t\t\t//rww - allow scanning for fcf files outside of pak even if pure\n\t\t\t    continue;\n\t\t    }\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetpath = FS_BuildOSPath( search->dir->path, search->dir->gamedir, path );\n\t\t\t\tsysFiles = Sys_ListFiles( netpath, extension, filter, &numSysFiles, qfalse );\n\t\t\t\tfor ( i = 0 ; i < numSysFiles ; i++ ) {\n\t\t\t\t\t// unique the match\n\t\t\t\t\tname = sysFiles[i];\n\t\t\t\t\tnfiles = FS_AddFileToList( name, list, nfiles );\n\t\t\t\t}\n\t\t\t\tSys_FreeFileList( sysFiles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// return a copy of the list\n\t*numfiles = nfiles;\n\n\tif ( !nfiles ) {\n\t\treturn NULL;\n\t}\n\n\tlistCopy = (char **)Z_Malloc( ( nfiles + 1 ) * sizeof( *listCopy ), TAG_FILESYS );\n\tfor ( i = 0 ; i < nfiles ; i++ ) {\n\t\tlistCopy[i] = list[i];\n\t}\n\tlistCopy[i] = NULL;\n\n\treturn listCopy;\n}\n\n/*\n=================\nFS_ListFiles\n=================\n*/\nchar **FS_ListFiles( const char *path, const char *extension, int *numfiles ) {\n\treturn FS_ListFilteredFiles( path, extension, NULL, numfiles );\n}\n\n/*\n=================\nFS_FreeFileList\n=================\n*/\nvoid FS_FreeFileList( char **fileList ) {\n\t//rwwRMG - changed to fileList to not conflict with list type\n\tint\t\ti;\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\\n\" );\n\t}\n\n\tif ( !fileList ) {\n\t\treturn;\n\t}\n\n\tfor ( i = 0 ; fileList[i] ; i++ ) {\n\t\tZ_Free( fileList[i] );\n\t}\n\n\tZ_Free( fileList );\n}\n\n\n/*\n================\nFS_GetFileList\n================\n*/\nint\tFS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {\n\tint\t\tnFiles, i, nTotal, nLen;\n\tchar **pFiles = NULL;\n\n\t*listbuf = 0;\n\tnFiles = 0;\n\tnTotal = 0;\n\n\tif (Q_stricmp(path, \"$modlist\") == 0) {\n\t\treturn FS_GetModList(listbuf, bufsize);\n\t}\n\n\tpFiles = FS_ListFiles(path, extension, &nFiles);\n\n\tfor (i =0; i < nFiles; i++) {\n\t\tnLen = strlen(pFiles[i]) + 1;\n\t\tif (nTotal + nLen + 1 < bufsize) {\n\t\t\tstrcpy(listbuf, pFiles[i]);\n\t\t\tlistbuf += nLen;\n\t\t\tnTotal += nLen;\n\t\t}\n\t\telse {\n\t\t\tnFiles = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFS_FreeFileList(pFiles);\n\n\treturn nFiles;\n}\n\n/*\n=======================\nSys_ConcatenateFileLists\n\nmkv: Naive implementation. Concatenates three lists into a\n     new list, and frees the old lists from the heap.\nbk001129 - from cvs1.17 (mkv)\n\nFIXME TTimo those two should move to common.c next to Sys_ListFiles\n=======================\n */\nstatic unsigned int Sys_CountFileList(char **fileList)\n{\n\tint i = 0;\n\n\tif (fileList)\n\t{\n\t\twhile (*fileList)\n\t\t{\n\t\t\tfileList++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic char** Sys_ConcatenateFileLists( char **list0, char **list1, char **list2 )\n{\n\tint totalLength = 0;\n\tchar** cat = NULL, **dst, **src;\n\n\ttotalLength += Sys_CountFileList(list0);\n\ttotalLength += Sys_CountFileList(list1);\n\ttotalLength += Sys_CountFileList(list2);\n\n\t/* Create new list. */\n\tdst = cat = (char **)Z_Malloc( ( totalLength + 1 ) * sizeof( char* ), TAG_FILESYS, qtrue );\n\n\t/* Copy over lists. */\n\tif (list0) {\n\t\tfor (src = list0; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list1) {\n\t\tfor (src = list1; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\tif (list2) {\n\t\tfor (src = list2; *src; src++, dst++)\n\t\t\t*dst = *src;\n\t}\n\n\t// Terminate the list\n\t*dst = NULL;\n\n\t// Free our old lists.\n\t// NOTE: not freeing their content, it's been merged in dst and still being used\n\tif (list0) Z_Free( list0 );\n\tif (list1) Z_Free( list1 );\n\tif (list2) Z_Free( list2 );\n\n\treturn cat;\n}\n//#endif\n\n// For base game mod listing\nconst char *SE_GetString( const char *psPackageAndStringReference );\n\n/*\n================\nFS_GetModList\n\nReturns a list of mod directory names\nA mod directory is a peer to base with a pk3 in it\nThe directories are searched in base path, cd path and home path\n================\n*/\nint\tFS_GetModList( char *listbuf, int bufsize ) {\n\tint\t\tnMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;\n\tchar **pFiles = NULL;\n\tchar **pPaks = NULL;\n\tchar *name, *path;\n\tchar descPath[MAX_OSPATH];\n\tfileHandle_t descHandle;\n\n\tint dummy;\n\tchar **pFiles0 = NULL;\n\tchar **pFiles1 = NULL;\n\tchar **pFiles2 = NULL;\n\tqboolean bDrop = qfalse;\n\n\t*listbuf = 0;\n\tnMods = nPotential = nTotal = 0;\n\n\tpFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles2 = Sys_ListFiles( fs_cdpath->string, NULL, NULL, &dummy, qtrue );\n\t// we searched for mods in the three paths\n\t// it is likely that we have duplicate names now, which we will cleanup below\n\tpFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1, pFiles2 );\n\tnPotential = Sys_CountFileList(pFiles);\n\n\tfor ( i = 0 ; i < nPotential ; i++ ) {\n\t\tname = pFiles[i];\n\t\t// NOTE: cleaner would involve more changes\n\t\t// ignore duplicate mod directories\n\t\tif (i!=0) {\n\t\t\tbDrop = qfalse;\n\t\t\tfor(j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif (Q_stricmp(pFiles[j],name)==0) {\n\t\t\t\t\t// this one can be dropped\n\t\t\t\t\tbDrop = qtrue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bDrop) {\n\t\t\tcontinue;\n\t\t}\n\t\t// we drop \".\" and \"..\"\n\t\tif (Q_stricmpn(name, \".\", 1)) {\n\t\t\t// now we need to find some .pk3 files to validate the mod\n\t\t\t// NOTE TTimo: (actually I'm not sure why .. what if it's a mod under developement with no .pk3?)\n\t\t\t// we didn't keep the information when we merged the directory names, as to what OS Path it was found under\n\t\t\t//   so it could be in base path, cd path or home path\n\t\t\t//   we will try each three of them here (yes, it's a bit messy)\n\t\t\tpath = FS_BuildOSPath( fs_basepath->string, name, \"\" );\n\t\t\tnPaks = 0;\n\t\t\tpPaks = Sys_ListFiles(path, \".pk3\", NULL, &nPaks, qfalse);\n\t\t\tSys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present\n\n\t\t\t/* Try on cd path */\n\t\t\tif( nPaks <= 0 ) {\n\t\t\t\tpath = FS_BuildOSPath( fs_cdpath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\t/* try on home path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_homepath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n\t\t\tif (nPaks > 0) {\n\t\t\t\tbool isBase = !Q_stricmp( name, BASEGAME );\n\t\t\t\tnLen = isBase ? 1 : strlen(name) + 1;\n\t\t\t\t// nLen is the length of the mod path\n\t\t\t\t// we need to see if there is a description available\n\t\t\t\tdescPath[0] = '\\0';\n\t\t\t\tstrcpy(descPath, name);\n\t\t\t\tstrcat(descPath, \"/description.txt\");\n\t\t\t\tnDescLen = FS_SV_FOpenFileRead( descPath, &descHandle );\n\t\t\t\tif ( nDescLen > 0 && descHandle) {\n\t\t\t\t\tFILE *file;\n\t\t\t\t\tfile = FS_FileForHandle(descHandle);\n\t\t\t\t\tCom_Memset( descPath, 0, sizeof( descPath ) );\n\t\t\t\t\tnDescLen = fread(descPath, 1, 48, file);\n\t\t\t\t\tif (nDescLen >= 0) {\n\t\t\t\t\t\tdescPath[nDescLen] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tFS_FCloseFile(descHandle);\n\t\t\t\t} else if ( isBase ) {\n\t\t\t\t\tstrcpy(descPath, SE_GetString(\"MENUS_JEDI_ACADEMY\"));\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(descPath, name);\n\t\t\t\t}\n\t\t\t\tnDescLen = strlen(descPath) + 1;\n\n\t\t\t\tif (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {\n\t\t\t\t\tif ( isBase )\n\t\t\t\t\t\tstrcpy(listbuf, \"\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(listbuf, name);\n\t\t\t\t\tlistbuf += nLen;\n\t\t\t\t\tstrcpy(listbuf, descPath);\n\t\t\t\t\tlistbuf += nDescLen;\n\t\t\t\t\tnTotal += nLen + nDescLen;\n\t\t\t\t\tnMods++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSys_FreeFileList( pFiles );\n\n\treturn nMods;\n}\n\n//============================================================================\n\n/*\n================\nFS_Dir_f\n================\n*/\nvoid FS_Dir_f( void ) {\n\tchar\t*path;\n\tchar\t*extension;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 || Cmd_Argc() > 3 ) {\n\t\tCom_Printf( \"usage: dir <directory> [extension]\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() == 2 ) {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = \"\";\n\t} else {\n\t\tpath = Cmd_Argv( 1 );\n\t\textension = Cmd_Argv( 2 );\n\t}\n\n\tCom_Printf( \"Directory of %s %s\\n\", path, extension );\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFiles( path, extension, &ndirs );\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n===========\nFS_ConvertPath\n===========\n*/\nvoid FS_ConvertPath( char *s ) {\n\twhile (*s) {\n\t\tif ( *s == '\\\\' || *s == ':' ) {\n\t\t\t*s = '/';\n\t\t}\n\t\ts++;\n\t}\n}\n\n/*\n===========\nFS_PathCmp\n\nIgnore case and separator char distinctions\n===========\n*/\nint FS_PathCmp( const char *s1, const char *s2 ) {\n\tint\t\tc1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif (c1 >= 'a' && c1 <= 'z') {\n\t\t\tc1 -= ('a' - 'A');\n\t\t}\n\t\tif (c2 >= 'a' && c2 <= 'z') {\n\t\t\tc2 -= ('a' - 'A');\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif (c1 < c2) {\n\t\t\treturn -1;\t\t// strings not equal\n\t\t}\n\t\tif (c1 > c2) {\n\t\t\treturn 1;\n\t\t}\n\t} while (c1);\n\n\treturn 0;\t\t// strings are equal\n}\n\n/*\n================\nFS_SortFileList\n================\n*/\nvoid FS_SortFileList(char **filelist, int numfiles) {\n\tint i, j, k, numsortedfiles;\n\tchar **sortedlist;\n\n\tsortedlist = (char **)Z_Malloc( ( numfiles + 1 ) * sizeof( *sortedlist ), TAG_FILESYS, qtrue );\n\tsortedlist[0] = NULL;\n\tnumsortedfiles = 0;\n\tfor (i = 0; i < numfiles; i++) {\n\t\tfor (j = 0; j < numsortedfiles; j++) {\n\t\t\tif (FS_PathCmp(filelist[i], sortedlist[j]) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (k = numsortedfiles; k > j; k--) {\n\t\t\tsortedlist[k] = sortedlist[k-1];\n\t\t}\n\t\tsortedlist[j] = filelist[i];\n\t\tnumsortedfiles++;\n\t}\n\tCom_Memcpy(filelist, sortedlist, numfiles * sizeof( *filelist ) );\n\tZ_Free(sortedlist);\n}\n\n/*\n================\nFS_NewDir_f\n================\n*/\nvoid FS_NewDir_f( void ) {\n\tchar\t*filter;\n\tchar\t**dirnames;\n\tint\t\tndirs;\n\tint\t\ti;\n\n\tif ( Cmd_Argc() < 2 ) {\n\t\tCom_Printf( \"usage: fdir <filter>\\n\" );\n\t\tCom_Printf( \"example: fdir *ffa*.bsp\\n\");\n\t\treturn;\n\t}\n\n\tfilter = Cmd_Argv( 1 );\n\n\tCom_Printf( \"---------------\\n\" );\n\n\tdirnames = FS_ListFilteredFiles( \"\", \"\", filter, &ndirs );\n\n\tFS_SortFileList(dirnames, ndirs);\n\n\tfor ( i = 0; i < ndirs; i++ ) {\n\t\tFS_ConvertPath(dirnames[i]);\n\t\tCom_Printf( \"%s\\n\", dirnames[i] );\n\t}\n\tCom_Printf( \"%d files listed\\n\", ndirs );\n\tFS_FreeFileList( dirnames );\n}\n\n/*\n============\nFS_Path_f\n\n============\n*/\nvoid FS_Path_f( void ) {\n\tsearchpath_t\t*s;\n\tint\t\t\t\ti;\n\n\tCom_Printf (\"Current search path:\\n\");\n\tfor (s = fs_searchpaths; s; s = s->next) {\n\t\tif (s->pack) {\n\t\t\tCom_Printf (\"%s (%i files)\\n\", s->pack->pakFilename, s->pack->numfiles);\n\t\t\tif ( fs_numServerPaks ) {\n\t\t\t\tif ( !FS_PakIsPure(s->pack) ) {\n\t\t\t\t\tCom_Printf( \"    not on the pure list\\n\" );\n\t\t\t\t} else {\n\t\t\t\t\tCom_Printf( \"    on the pure list\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tCom_Printf (\"%s%c%s\\n\", s->dir->path, PATH_SEP, s->dir->gamedir );\n\t\t}\n\t}\n\n\tCom_Printf( \"\\n\" );\n\tfor ( i = 1 ; i < MAX_FILE_HANDLES ; i++ ) {\n\t\tif ( fsh[i].handleFiles.file.o ) {\n\t\t\tCom_Printf( \"handle %i: %s\\n\", i, fsh[i].name );\n\t\t}\n\t}\n}\n\n/*\n============\nFS_TouchFile_f\n\nThe only purpose of this function is to allow game script files to copy\narbitrary files furing an \"fs_copyfiles 1\" run.\n============\n*/\nvoid FS_TouchFile_f( void ) {\n\tfileHandle_t\tf;\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"Usage: touchFile <file>\\n\" );\n\t\treturn;\n\t}\n\n\tFS_FOpenFileRead( Cmd_Argv( 1 ), &f, qfalse );\n\tif ( f ) {\n\t\tFS_FCloseFile( f );\n\t}\n}\n\n/*\n============\nFS_Which_f\n============\n*/\nvoid FS_Which_f( void ) {\n\tsearchpath_t\t*search;\n\tchar\t\t*filename;\n\n\tfilename = Cmd_Argv(1);\n\n\tif ( !filename[0] ) {\n\t\tCom_Printf( \"Usage: which <file>\\n\" );\n\t\treturn;\n\t}\n\n\t// qpaths are not supposed to have a leading slash\n\tif ( filename[0] == '/' || filename[0] == '\\\\' ) {\n\t\tfilename++;\n\t}\n\n\t// make absolutely sure that it can't back up the path.\n\t// The searchpaths do guarantee that something will always\n\t// be prepended, so we don't need to worry about \"c:\" or \"//limbo\"\n\tif ( strstr( filename, \"..\" ) || strstr( filename, \"::\" ) ) {\n\t\treturn;\n\t}\n\n\t// just wants to see if file is there\n\tfor ( search=fs_searchpaths; search; search=search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tlong hash = FS_HashFileName( filename, search->pack->hashSize );\n\n\t\t\t// is the element a pak file?\n\t\t\tif ( search->pack->hashTable[hash]) {\n\t\t\t\t// look through all the pak file elements\n\t\t\t\tpack_t* pak = search->pack;\n\t\t\t\tfileInPack_t* pakFile = pak->hashTable[hash];\n\n\t\t\t\tdo {\n\t\t\t\t\t// case and separator insensitive comparisons\n\t\t\t\t\tif ( !FS_FilenameCompare( pakFile->name, filename ) ) {\n\t\t\t\t\t\t// found it!\n\t\t\t\t\t\tCom_Printf( \"File \\\"%s\\\" found in \\\"%s\\\"\\n\", filename, pak->pakFilename );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpakFile = pakFile->next;\n\t\t\t\t} while ( pakFile != NULL );\n\t\t\t}\n\t\t} else if (search->dir) {\n\t\t\tdirectory_t* dir = search->dir;\n\n\t\t\tchar* netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );\n\t\t\tFILE* filep = fopen(netpath, \"rb\");\n\n\t\t\tif ( filep ) {\n\t\t\t\tfclose( filep );\n\n\t\t\t\tchar buf[MAX_OSPATH];\n\t\t\t\tCom_sprintf( buf, sizeof( buf ), \"%s%c%s\", dir->path, PATH_SEP, dir->gamedir );\n\t\t\t\tFS_ReplaceSeparators( buf );\n\t\t\t\tCom_Printf( \"File \\\"%s\\\" found at \\\"%s\\\"\\n\", filename, buf );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tCom_Printf( \"File not found: \\\"%s\\\"\\n\", filename );\n}\n\n//===========================================================================\n\nstatic int QDECL paksort( const void *a, const void *b ) {\n\tchar\t*aa, *bb;\n\n\taa = *(char **)a;\n\tbb = *(char **)b;\n\n\treturn FS_PathCmp( aa, bb );\n}\n\n/*\n================\nFS_AddGameDirectory\n\nSets fs_gamedir, adds the directory to the head of the path,\nthen loads the zip headers\n================\n*/\n#define\tMAX_PAKFILES\t1024\nstatic void FS_AddGameDirectory( const char *path, const char *dir ) {\n\tsearchpath_t\t*sp;\n\tint\t\t\t\ti;\n\tsearchpath_t\t*search;\n\tsearchpath_t\t*thedir;\n\tpack_t\t\t\t*pak;\n\tchar\t\t\tcurpath[MAX_OSPATH + 1], *pakfile;\n\tint\t\t\t\tnumfiles;\n\tchar\t\t\t**pakfiles;\n\tchar\t\t\t*sorted[MAX_PAKFILES];\n\n\t// this fixes the case where fs_basepath is the same as fs_cdpath\n\t// which happens on full installs\n\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\tif ( sp->dir && Sys_PathCmp(sp->dir->path, path) && !Q_stricmp(sp->dir->gamedir, dir)) {\n\t\t\treturn;\t\t\t// we've already got this one\n\t\t}\n\t}\n\n\tQ_strncpyz( fs_gamedir, dir, sizeof( fs_gamedir ) );\n\n\t// find all pak files in this directory\n\tQ_strncpyz(curpath, FS_BuildOSPath(path, dir, \"\"), sizeof(curpath));\n\tcurpath[strlen(curpath) - 1] = '\\0';\t// strip the trailing slash\n\n\t//\n\t// add the directory to the search path\n\t//\n\tsearch = (struct searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\tsearch->dir = (directory_t *)Z_Malloc( sizeof( *search->dir ), TAG_FILESYS, qtrue );\n\n\tQ_strncpyz( search->dir->path, path, sizeof( search->dir->path ) );\n\tQ_strncpyz( search->dir->fullpath, curpath, sizeof( search->dir->fullpath ) );\n\tQ_strncpyz( search->dir->gamedir, dir, sizeof( search->dir->gamedir ) );\n\tsearch->next = fs_searchpaths;\n\tfs_searchpaths = search;\n\n\tthedir = search;\n\n\tpakfiles = Sys_ListFiles( curpath, \".pk3\", NULL, &numfiles, qfalse );\n\n\t// sort them so that later alphabetic matches override\n\t// earlier ones.  This makes pak1.pk3 override pak0.pk3\n\tif ( numfiles > MAX_PAKFILES ) {\n\t\tnumfiles = MAX_PAKFILES;\n\t}\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tsorted[i] = pakfiles[i];\n\t}\n\n\tqsort( sorted, numfiles, sizeof(char*), paksort );\n\n\tfor ( i = 0 ; i < numfiles ; i++ ) {\n\t\tpakfile = FS_BuildOSPath( path, dir, sorted[i] );\n\t\tif ( ( pak = FS_LoadZipFile( pakfile, sorted[i] ) ) == 0 )\n\t\t\tcontinue;\n\t\tQ_strncpyz(pak->pakPathname, curpath, sizeof(pak->pakPathname));\n\t\t// store the game name for downloading\n\t\tQ_strncpyz(pak->pakGamename, dir, sizeof(pak->pakGamename));\n\n\t\tfs_packFiles += pak->numfiles;\n\n\t\tsearch = (searchpath_s *)Z_Malloc (sizeof(searchpath_t), TAG_FILESYS, qtrue);\n\t\tsearch->pack = pak;\n\n\t\tif (fs_dirbeforepak && fs_dirbeforepak->integer && thedir)\n\t\t{\n\t\t\tsearchpath_t *oldnext = thedir->next;\n\t\t\tthedir->next = search;\n\n\t\t\twhile (oldnext)\n\t\t\t{\n\t\t\t\tsearch->next = oldnext;\n\t\t\t\tsearch = search->next;\n\t\t\t\toldnext = oldnext->next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsearch->next = fs_searchpaths;\n\t\t\tfs_searchpaths = search;\n\t\t}\n\t}\n\n\t// done\n\tSys_FreeFileList( pakfiles );\n}\n\n/*\n================\nFS_idPak\n================\n*/\nqboolean FS_idPak( char *pak, char *base ) {\n\tint i;\n\n\tfor (i = 0; i < NUM_ID_PAKS; i++) {\n\t\tif ( !FS_FilenameCompare(pak, va(\"%s/assets%d\", base, i)) ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < NUM_ID_PAKS) {\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}\n\n/*\n================\nFS_CheckDirTraversal\n\nCheck whether the string contains stuff like \"../\" to prevent directory traversal bugs\nand return qtrue if it does.\n================\n*/\n\nqboolean FS_CheckDirTraversal(const char *checkdir)\n{\n\tif(strstr(checkdir, \"../\") || strstr(checkdir, \"..\\\\\"))\n\t\treturn qtrue;\n\n\treturn qfalse;\n}\n\n/*\n================\nFS_ComparePaks\n\nif dlstring == qtrue\n\nReturns a list of pak files that we should download from the server. They all get stored\nin the current gamedir and an FS_Restart will be fired up after we download them all.\n\nThe string is the format:\n\n@remotename@localname [repeat]\n\nstatic int\t\tfs_numServerReferencedPaks;\nstatic int\t\tfs_serverReferencedPaks[MAX_SEARCH_PATHS];\nstatic char\t\t*fs_serverReferencedPakNames[MAX_SEARCH_PATHS];\n\n----------------\ndlstring == qfalse\n\nwe are not interested in a download string format, we want something human-readable\n(this is used for diagnostics while connecting to a pure server)\n================\n*/\nqboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring ) {\n\tsearchpath_t\t*sp;\n\tqboolean havepak;\n\tchar *origpos = neededpaks;\n\tint i;\n\n\tif ( !fs_numServerReferencedPaks ) {\n\t\treturn qfalse; // Server didn't send any pack information along\n\t}\n\n\t*neededpaks = 0;\n\n\tfor ( i = 0 ; i < fs_numServerReferencedPaks ; i++ ) {\n\t\t// Ok, see if we have this pak file\n\t\thavepak = qfalse;\n\n\t\t// never autodownload any of the id paks\n\t\tif ( FS_idPak(fs_serverReferencedPakNames[i], \"base\") || FS_idPak(fs_serverReferencedPakNames[i], \"missionpack\") ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Make sure the server cannot make us write to non-quake3 directories.\n\t\tif(FS_CheckDirTraversal(fs_serverReferencedPakNames[i]))\n\t\t{\n\t\t\tCom_Printf(\"WARNING: Invalid download name %s\\n\", fs_serverReferencedPakNames[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor ( sp = fs_searchpaths ; sp ; sp = sp->next ) {\n\t\t\tif ( sp->pack && sp->pack->checksum == fs_serverReferencedPaks[i] ) {\n\t\t\t\thavepak = qtrue; // This is it!\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( !havepak && fs_serverReferencedPakNames[i] && *fs_serverReferencedPakNames[i] ) {\n\t\t\t// Don't got it\n\n\t\t\tif (dlstring)\n\t\t\t{\n\t\t\t\t// We need this to make sure we won't hit the end of the buffer or the server could\n\t\t\t\t// overwrite non-pk3 files on clients by writing so much crap into neededpaks that\n\t\t\t\t// Q_strcat cuts off the .pk3 extension.\n\n\t\t\t\torigpos += strlen(origpos);\n\n\t\t\t\t// Remote name\n\t\t\t\tQ_strcat( neededpaks, len, \"@\");\n\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\n\t\t\t\t// Local name\n\t\t\t\tQ_strcat( neededpaks, len, \"@\");\n\t\t\t\t// Do we have one with the same name?\n\t\t\t\tif ( FS_SV_FileExists( va( \"%s.pk3\", fs_serverReferencedPakNames[i] ) ) ) {\n\t\t\t\t\tchar st[MAX_ZPATH];\n\t\t\t\t\t// We already have one called this, we need to download it to another name\n\t\t\t\t\t// Make something up with the checksum in it\n\t\t\t\t\tCom_sprintf( st, sizeof( st ), \"%s.%08x.pk3\", fs_serverReferencedPakNames[i], fs_serverReferencedPaks[i] );\n\t\t\t\t\tQ_strcat( neededpaks, len, st );\n\t\t\t\t} else {\n\t\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\t\t\t\t}\n\n\t\t\t\t// Find out whether it might have overflowed the buffer and don't add this file to the\n\t\t\t\t// list if that is the case.\n\t\t\t\tif(strlen(origpos) + (origpos - neededpaks) >= (unsigned)(len - 1))\n\t\t\t\t{\n\t\t\t\t\t*origpos = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tQ_strcat( neededpaks, len, fs_serverReferencedPakNames[i] );\n\t\t\t\tQ_strcat( neededpaks, len, \".pk3\" );\n\t\t\t\t// Do we have one with the same name?\n\t\t\t\tif ( FS_SV_FileExists( va( \"%s.pk3\", fs_serverReferencedPakNames[i] ) ) )\n\t\t\t\t{\n\t\t\t\t\tQ_strcat( neededpaks, len, \" (local file exists with wrong checksum)\");\n\t\t\t\t}\n\t\t\t\tQ_strcat( neededpaks, len, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif ( *neededpaks ) {\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse; // We have them all\n}\n\n/*\n================\nFS_Shutdown\n\nFrees all resources and closes all files\n================\n*/\nvoid FS_Shutdown( qboolean closemfp ) {\n\tsearchpath_t\t*p, *next;\n\tint\ti;\n\n#if defined(_WIN32)\n\t// Delete temporary files\n\tfs_temporaryFileWriteIdx = 0;\n\tfor ( size_t i = 0; i < ARRAY_LEN(fs_temporaryFileNames); i++ )\n\t{\n\t\tif (fs_temporaryFileNames[i][0] != '\\0')\n\t\t{\n\t\t\tif ( !DeleteFile(fs_temporaryFileNames[i]) )\n\t\t\t{\n\t\t\t\tDWORD error = GetLastError();\n\t\t\t\tCom_DPrintf(\"FS_Shutdown: failed to delete '%s'. \"\n\t\t\t\t\t\t\t\"Win32 error code: 0x08x\",\n\t\t\t\t\t\t\tfs_temporaryFileNames[i],\n\t\t\t\t\t\t\terror);\n\t\t\t}\n\n\t\t\tfs_temporaryFileNames[i][0] = '\\0';\n\t\t}\n\t}\n#endif\n\n\tfor(i = 0; i < MAX_FILE_HANDLES; i++) {\n\t\tif (fsh[i].fileSize) {\n\t\t\tFS_FCloseFile(i);\n\t\t}\n\t}\n\n\t// free everything\n\tfor ( p = fs_searchpaths ; p ; p = next ) {\n\t\tnext = p->next;\n\n\t\tif ( p->pack ) {\n\t\t\tFS_FreePak( p->pack );\n\t\t}\n\t\tif ( p->dir ) {\n\t\t\tZ_Free( p->dir );\n\t\t}\n\t\tZ_Free( p );\n\t}\n\n\t// any FS_ calls will now be an error until reinitialized\n\tfs_searchpaths = NULL;\n\n\tCmd_RemoveCommand( \"path\" );\n\tCmd_RemoveCommand( \"dir\" );\n\tCmd_RemoveCommand( \"fdir\" );\n\tCmd_RemoveCommand( \"touchFile\" );\n\tCmd_RemoveCommand( \"which\" );\n\n#ifdef FS_MISSING\n\tif (closemfp) {\n\t\tfclose(missingFiles);\n\t}\n#endif\n}\n\n//rww - add search paths in for received svc_setgame\n//Ensiform - this is so wrong rww\nvoid FS_UpdateGamedir(void)\n{\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, BASEGAME ) )\n\t{\n\t\tif (fs_cdpath->string[0])\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0])\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string))\n\t\t{\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n}\n\n/*\n================\nFS_ReorderPurePaks\nNOTE TTimo: the reordering that happens here is not reflected in the cvars (\\cvarlist *pak*)\n  this can lead to misleading situations, see https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n================\n*/\nstatic void FS_ReorderPurePaks()\n{\n\tsearchpath_t *s;\n\tint i;\n\tsearchpath_t **p_insert_index, // for linked list reordering\n\t\t**p_previous; // when doing the scan\n\n\t// only relevant when connected to pure server\n\tif ( !fs_numServerPaks )\n\t\treturn;\n\n\tfs_reordered = qfalse;\n\n\tp_insert_index = &fs_searchpaths; // we insert in order at the beginning of the list\n\tfor ( i = 0 ; i < fs_numServerPaks ; i++ ) {\n\t\tp_previous = p_insert_index; // track the pointer-to-current-item\n\t\tfor (s = *p_insert_index; s; s = s->next) {\n\t\t\t// the part of the list before p_insert_index has been sorted already\n\t\t\tif (s->pack && fs_serverPaks[i] == s->pack->checksum) {\n\t\t\t\tfs_reordered = qtrue;\n\t\t\t\t// move this element to the insert list\n\t\t\t\t*p_previous = s->next;\n\t\t\t\ts->next = *p_insert_index;\n\t\t\t\t*p_insert_index = s;\n\t\t\t\t// increment insert list\n\t\t\t\tp_insert_index = &s->next;\n\t\t\t\tbreak; // iterate to next server pack\n\t\t\t}\n\t\t\tp_previous = &s->next;\n\t\t}\n\t}\n}\n\n/**\n\t@brief Mount the asset archives (.pk3) and register commands.\n\n\tMounts in this order the archives from:\n\n\t1.  <fs_cdpath>/<gameName>/\n\t2.  <fs_basepath>/<gameName>/\n\t3.  <fs_apppath>/<gameName>/ (Mac Only)\n\t4.  <fs_homepath>/<gameName>/\n\t5.  <fs_cdpath>/<fs_basegame>/\n\t6.  <fs_basepath>/<fs_basegame>/\n\t7.  <fs_homepath>/<fs_basegame>/\n\t8.  <fs_cdpath>/<fs_game>/\n\t9.  <fs_basepath>/<fs_game>/\n\t10. <fs_homepath>/<fs_game>/\n\n\t@param gameName Name of the default folder (i.e. always BASEGAME = \"base\" in OpenJK)\n*/\nvoid FS_Startup( const char *gameName ) {\n\tconst char *homePath;\n\n\tCom_Printf( \"----- FS_Startup -----\\n\" );\n\n\tfs_packFiles = 0;\n\n\tfs_debug = Cvar_Get( \"fs_debug\", \"0\", 0 );\n\tfs_copyfiles = Cvar_Get( \"fs_copyfiles\", \"0\", CVAR_INIT );\n\tfs_cdpath = Cvar_Get (\"fs_cdpath\", \"\", CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location for development files\" );\n\tfs_basepath = Cvar_Get (\"fs_basepath\", Sys_DefaultInstallPath(), CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location for game files\" );\n\tfs_basegame = Cvar_Get (\"fs_basegame\", \"\", CVAR_INIT );\n\thomePath = Sys_DefaultHomePath();\n\tif (!homePath || !homePath[0]) {\n\t\thomePath = fs_basepath->string;\n\t}\n\tfs_homepath = Cvar_Get (\"fs_homepath\", homePath, CVAR_INIT|CVAR_PROTECTED, \"(Read/Write) Location for user generated files\" );\n\tfs_gamedirvar = Cvar_Get (\"fs_game\", \"\", CVAR_INIT|CVAR_SYSTEMINFO, \"Mod directory\" );\n\n\tfs_dirbeforepak = Cvar_Get(\"fs_dirbeforepak\", \"0\", CVAR_INIT|CVAR_PROTECTED, \"Prioritize directories before paks if not pure\" );\n\n\t// add search path elements in reverse priority order (lowest priority first)\n\tif (fs_cdpath->string[0]) {\n\t\tFS_AddGameDirectory( fs_cdpath->string, gameName );\n\t}\n\tif (fs_basepath->string[0]) {\n\t\tFS_AddGameDirectory( fs_basepath->string, gameName );\n\t}\n\n#ifdef MACOS_X\n\tfs_apppath = Cvar_Get (\"fs_apppath\", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED, \"(Read Only) Location of OSX .app bundle\" );\n\t// Make MacOSX also include the base path included with the .app bundle\n\tif (fs_apppath->string[0]) {\n\t\tFS_AddGameDirectory( fs_apppath->string, gameName );\n\t}\n#endif\n\n\t// fs_homepath is somewhat particular to *nix systems, only add if relevant\n\t// NOTE: same filtering below for mods and basegame\n\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\tFS_CreatePath ( fs_homepath->string );\n\t\tFS_AddGameDirectory ( fs_homepath->string, gameName );\n\t}\n\n\t// check for additional base game so mods can be based upon other mods\n\tif ( fs_basegame->string[0] && Q_stricmp( fs_basegame->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_basegame->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_basegame->string);\n\t\t}\n\t}\n\n\t// check for additional game folder for mods\n\tif ( fs_gamedirvar->string[0] && Q_stricmp( fs_gamedirvar->string, gameName ) ) {\n\t\tif (fs_cdpath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_cdpath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_basepath->string[0]) {\n\t\t\tFS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);\n\t\t}\n\t\tif (fs_homepath->string[0] && !Sys_PathCmp(fs_homepath->string, fs_basepath->string)) {\n\t\t\tFS_AddGameDirectory(fs_homepath->string, fs_gamedirvar->string);\n\t\t}\n\t}\n\n\t// add our commands\n\tCmd_AddCommand (\"path\", FS_Path_f, \"Lists search paths\" );\n\tCmd_AddCommand (\"dir\", FS_Dir_f, \"Lists a folder\" );\n\tCmd_AddCommand (\"fdir\", FS_NewDir_f, \"Lists a folder with filters\" );\n\tCmd_AddCommand (\"touchFile\", FS_TouchFile_f, \"Touches a file\" );\n\tCmd_AddCommand (\"which\", FS_Which_f, \"Determines which search path a file was loaded from\" );\n\n\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=506\n\t// reorder the pure pk3 files according to server order\n\tFS_ReorderPurePaks();\n\n\t// print the current search paths\n\tFS_Path_f();\n\n\tfs_gamedirvar->modified = qfalse; // We just loaded, it's not modified\n\n\tCom_Printf( \"----------------------\\n\" );\n\n#ifdef FS_MISSING\n\tif (missingFiles == NULL) {\n\t\tmissingFiles = fopen( \"\\\\missing.txt\", \"ab\" );\n\t}\n#endif\n\tCom_Printf( \"%d files in pk3 files\\n\", fs_packFiles );\n}\n\n/*\n=====================\nFS_LoadedPakChecksums\n\nReturns a space separated string containing the checksums of all loaded pk3 files.\nServers with sv_pure set will get this string and pass it to clients.\n=====================\n*/\nconst char *FS_LoadedPakChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->checksum ) );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_LoadedPakNames\n\nReturns a space separated string containing the names of all loaded pk3 files.\nServers with sv_pure set will get this string and pass it to clients.\n=====================\n*/\nconst char *FS_LoadedPakNames( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*info) {\n\t\t\tQ_strcat(info, sizeof( info ), \" \" );\n\t\t}\n\t\tQ_strcat( info, sizeof( info ), search->pack->pakBasename );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_LoadedPakPureChecksums\n\nReturns a space separated string containing the pure checksums of all loaded pk3 files.\nServers with sv_pure use these checksums to compare with the checksums the clients send\nback to the server.\n=====================\n*/\nconst char *FS_LoadedPakPureChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->pure_checksum ) );\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakChecksums\n\nReturns a space separated string containing the checksums of all referenced pk3 files.\nThe server will send this to the clients so they can check which files should be auto-downloaded.\n=====================\n*/\nconst char *FS_ReferencedPakChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t *search;\n\n\tinfo[0] = 0;\n\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( search->pack ) {\n\t\t\tif (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, BASEGAME, strlen(BASEGAME))) {\n\t\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->checksum ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakPureChecksums\n\nReturns a space separated string containing the pure checksums of all referenced pk3 files.\nServers with sv_pure set will get this string back from clients for pure validation\n\nThe string has a specific order, \"cgame ui @ ref1 ref2 ref3 ...\"\n=====================\n*/\nconst char *FS_ReferencedPakPureChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\tint nFlags, numPaks, checksum;\n\n\tinfo[0] = 0;\n\n\tchecksum = fs_checksumFeed;\n\tnumPaks = 0;\n\tfor (nFlags = FS_CGAME_REF; nFlags; nFlags = nFlags >> 1) {\n\t\tif (nFlags & FS_GENERAL_REF) {\n\t\t\t// add a delimter between must haves and general refs\n\t\t\t//Q_strcat(info, sizeof(info), \"@ \");\n\t\t\tinfo[strlen(info)+1] = '\\0';\n\t\t\tinfo[strlen(info)+2] = '\\0';\n\t\t\tinfo[strlen(info)] = '@';\n\t\t\tinfo[strlen(info)] = ' ';\n\t\t}\n\t\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t\t// is the element a pak file and has it been referenced based on flag?\n\t\t\tif ( search->pack && (search->pack->referenced & nFlags)) {\n\t\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->pure_checksum ) );\n\t\t\t\tif (nFlags & (FS_CGAME_REF | FS_UI_REF)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchecksum ^= search->pack->pure_checksum;\n\t\t\t\tnumPaks++;\n\t\t\t}\n\t\t}\n\t\tif (fs_fakeChkSum != 0) {\n\t\t\t// only added if a non-pure file is referenced\n\t\t\tQ_strcat( info, sizeof( info ), va(\"%i \", fs_fakeChkSum ) );\n\t\t}\n\t}\n\t// last checksum is the encoded number of referenced pk3s\n\tchecksum ^= numPaks;\n\tQ_strcat( info, sizeof( info ), va(\"%i \", checksum ) );\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ReferencedPakNames\n\nReturns a space separated string containing the names of all referenced pk3 files.\nThe server will send this to the clients so they can check which files should be auto-downloaded.\n=====================\n*/\nconst char *FS_ReferencedPakNames( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\t// we want to return ALL pk3's from the fs_game path\n\t// and referenced one's from base\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\t// is the element a pak file?\n\t\tif ( search->pack ) {\n\t\t\tif (search->pack->referenced || Q_stricmpn(search->pack->pakGamename, BASEGAME, strlen(BASEGAME))) {\n\t\t\t\tif (*info) {\n\t\t\t\t\tQ_strcat(info, sizeof( info ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( info, sizeof( info ), search->pack->pakGamename );\n\t\t\t\tQ_strcat( info, sizeof( info ), \"/\" );\n\t\t\t\tQ_strcat( info, sizeof( info ), search->pack->pakBasename );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info;\n}\n\n/*\n=====================\nFS_ClearPakReferences\n=====================\n*/\nvoid FS_ClearPakReferences( int flags ) {\n\tsearchpath_t *search;\n\n\tif ( !flags ) {\n\t\tflags = -1;\n\t}\n\tfor ( search = fs_searchpaths; search; search = search->next ) {\n\t\t// is the element a pak file and has it been referenced?\n\t\tif ( search->pack ) {\n\t\t\tsearch->pack->referenced &= ~flags;\n\t\t}\n\t}\n}\n\n\n/*\n=====================\nFS_PureServerSetLoadedPaks\n\nIf the string is empty, all data sources will be allowed.\nIf not empty, only pk3 files that match one of the space\nseparated checksums will be checked for files, with the\nexception of .cfg and .dat files.\n=====================\n*/\nvoid FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames ) {\n\tint\t\ti, c, d;\n\n\tCmd_TokenizeString( pakSums );\n\n\tc = Cmd_Argc();\n\tif ( c > MAX_SEARCH_PATHS ) {\n\t\tc = MAX_SEARCH_PATHS;\n\t}\n\n\tfs_numServerPaks = c;\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tfs_serverPaks[i] = atoi( Cmd_Argv( i ) );\n\t}\n\n\tif (fs_numServerPaks) {\n\t\tCom_DPrintf( \"Connected to a pure server.\\n\" );\n\t}\n\telse\n\t{\n\t\tif (fs_reordered)\n\t\t{\n\t\t\t// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540\n\t\t\t// force a restart to make sure the search order will be correct\n\t\t\tCom_DPrintf( \"FS search reorder is required\\n\" );\n\t\t\tFS_Restart(fs_checksumFeed);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tif (fs_serverPakNames[i]) {\n\t\t\tZ_Free(fs_serverPakNames[i]);\n\t\t}\n\t\tfs_serverPakNames[i] = NULL;\n\t}\n\tif ( pakNames && *pakNames ) {\n\t\tCmd_TokenizeString( pakNames );\n\n\t\td = Cmd_Argc();\n\t\tif ( d > MAX_SEARCH_PATHS ) {\n\t\t\td = MAX_SEARCH_PATHS;\n\t\t}\n\n\t\tfor ( i = 0 ; i < d ; i++ ) {\n\t\t\tfs_serverPakNames[i] = CopyString( Cmd_Argv( i ) );\n\t\t}\n\t}\n}\n\n/*\n=====================\nFS_PureServerSetReferencedPaks\n\nThe checksums and names of the pk3 files referenced at the server\nare sent to the client and stored here. The client will use these\nchecksums to see if any pk3 files need to be auto-downloaded.\n=====================\n*/\nvoid FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames ) {\n\tint\t\ti, c, d = 0;\n\n\tCmd_TokenizeString( pakSums );\n\n\tc = Cmd_Argc();\n\tif ( c > MAX_SEARCH_PATHS ) {\n\t\tc = MAX_SEARCH_PATHS;\n\t}\n\n\tfor ( i = 0 ; i < c ; i++ ) {\n\t\tfs_serverReferencedPaks[i] = atoi( Cmd_Argv( i ) );\n\t}\n\n\tfor (i = 0 ; i < (int)ARRAY_LEN(fs_serverReferencedPakNames); i++)\n\t{\n\t\tif(fs_serverReferencedPakNames[i])\n\t\t\tZ_Free(fs_serverReferencedPakNames[i]);\n\n\t\tfs_serverReferencedPakNames[i] = NULL;\n\t}\n\n\tif ( pakNames && *pakNames ) {\n\t\tCmd_TokenizeString( pakNames );\n\n\t\td = Cmd_Argc();\n\t\tif ( d > c ) {\n\t\t\td = c;\n\t\t}\n\n\t\tfor ( i = 0 ; i < d ; i++ ) {\n\t\t\tfs_serverReferencedPakNames[i] = CopyString( Cmd_Argv( i ) );\n\t\t}\n\t}\n\n\t// ensure that there are as many checksums as there are pak names.\n\tif(d < c)\n\t\tc = d;\n\n\tfs_numServerReferencedPaks = c;\n}\n\n/*\n================\nFS_InitFilesystem\n\nCalled only at inital startup, not when the filesystem\nis resetting due to a game change\n================\n*/\nvoid FS_InitFilesystem( void ) {\n\t// allow command line parms to override our defaults\n\t// we have to specially handle this, because normal command\n\t// line variable sets don't happen until after the filesystem\n\t// has already been initialized\n\tCom_StartupVariable( \"fs_cdpath\" );\n\tCom_StartupVariable( \"fs_basepath\" );\n\tCom_StartupVariable( \"fs_homepath\" );\n\tCom_StartupVariable( \"fs_game\" );\n\tCom_StartupVariable( \"fs_copyfiles\" );\n\tCom_StartupVariable( \"fs_dirbeforepak\" );\n#ifdef MACOS_X\n\tCom_StartupVariable( \"fs_apppath\" );\n#endif\n\n\tif(!FS_FilenameCompare(Cvar_VariableString(\"fs_game\"), BASEGAME))\n\t\tCvar_Set(\"fs_game\", \"\");\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"mpdefault.cfg\", NULL ) <= 0 ) {\n\t\tCom_Error( ERR_FATAL, \"Couldn't load mpdefault.cfg\" );\n\t\t// bk001208 - SafeMode see below, FIXME?\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n#if defined(_WIN32)\n\tCom_Memset(fs_temporaryFileNames, 0, sizeof(fs_temporaryFileNames));\n#endif\n\n  // bk001208 - SafeMode see below, FIXME?\n}\n\n/*\n================\nFS_Restart\n================\n*/\nvoid FS_Restart( int checksumFeed ) {\n\n\t// free anything we currently have loaded\n\tFS_Shutdown(qfalse);\n\n\t// set the checksum feed\n\tfs_checksumFeed = checksumFeed;\n\n\t// clear pak references\n\tFS_ClearPakReferences(0);\n\n\t// try to start up normally\n\tFS_Startup( BASEGAME );\n\n\t// if we can't find default.cfg, assume that the paths are\n\t// busted and error out now, rather than getting an unreadable\n\t// graphics screen when the font fails to load\n\tif ( FS_ReadFile( \"mpdefault.cfg\", NULL ) <= 0 ) {\n\t\t// this might happen when connecting to a pure server not using BASEGAME/pak0.pk3\n\t\t// (for instance a TA demo server)\n\t\tif (lastValidBase[0]) {\n\t\t\tFS_PureServerSetLoadedPaks(\"\", \"\");\n\t\t\tCvar_Set(\"fs_basepath\", lastValidBase);\n\t\t\tCvar_Set(\"fs_game\", lastValidGame);\n\t\t\tlastValidBase[0] = '\\0';\n\t\t\tlastValidGame[0] = '\\0';\n\t\t\tFS_Restart(checksumFeed);\n\t\t\tCom_Error( ERR_DROP, \"Invalid game folder\\n\" );\n\t\t\treturn;\n\t\t}\n\t\tCom_Error( ERR_FATAL, \"Couldn't load mpdefault.cfg\" );\n\t}\n\n\tif ( Q_stricmp(fs_gamedirvar->string, lastValidGame) ) {\n\t\t// skip the jampconfig.cfg if \"safe\" is on the command line\n\t\tif ( !Com_SafeMode() ) {\n\t\t\tCbuf_AddText (\"exec \" Q3CONFIG_CFG \"\\n\");\n\t\t}\n\t}\n\n\tQ_strncpyz(lastValidBase, fs_basepath->string, sizeof(lastValidBase));\n\tQ_strncpyz(lastValidGame, fs_gamedirvar->string, sizeof(lastValidGame));\n\n}\n\n/*\n=================\nFS_ConditionalRestart\nrestart if necessary\n=================\n*/\nqboolean FS_ConditionalRestart( int checksumFeed ) {\n\tif( fs_gamedirvar->modified || checksumFeed != fs_checksumFeed ) {\n\t\tFS_Restart( checksumFeed );\n\t\treturn qtrue;\n\t}\n#if 0\n\tif(fs_gamedirvar->modified)\n\t{\n\t\tif(FS_FilenameCompare(lastValidGame, fs_gamedirvar->string) &&\n\t\t\t\t(*lastValidGame || FS_FilenameCompare(fs_gamedirvar->string, BASEGAME)) &&\n\t\t\t\t(*fs_gamedirvar->string || FS_FilenameCompare(lastValidGame, BASEGAME)))\n\t\t{\n\t\t\tFS_Restart(checksumFeed);\n\t\t\t//Cvar_Restart(qtrue);\n\t\t\treturn qtrue;\n\t\t}\n\t\telse\n\t\t\tfs_gamedirvar->modified = qfalse;\n\t}\n\n\tif(checksumFeed != fs_checksumFeed)\n\t\tFS_Restart(checksumFeed);\n\telse if(fs_numServerPaks && !fs_reordered)\n\t\tFS_ReorderPurePaks();\n#endif\n\treturn qfalse;\n}\n\n/*\n========================================================================================\n\nHandle based file calls for virtual machines\n\n========================================================================================\n*/\n\nint\t\tFS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode ) {\n\tint\t\tr;\n\tqboolean\tsync;\n\n\tsync = qfalse;\n\n\tswitch( mode ) {\n\tcase FS_READ:\n\t\tr = FS_FOpenFileRead( qpath, f, qtrue );\n\t\tbreak;\n\tcase FS_WRITE:\n\t\t*f = FS_FOpenFileWrite( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tcase FS_APPEND_SYNC:\n\t\tsync = qtrue;\n\tcase FS_APPEND:\n\t\t*f = FS_FOpenFileAppend( qpath );\n\t\tr = 0;\n\t\tif (*f == 0) {\n\t\t\tr = -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tCom_Error( ERR_FATAL, \"FSH_FOpenFile: bad mode\" );\n\t\treturn -1;\n\t}\n\n\tif (!f) {\n\t\treturn r;\n\t}\n\n\tif ( *f ) {\n\t\tfsh[*f].fileSize = r;\n\t}\n\tfsh[*f].handleSync = sync;\n\n\treturn r;\n}\n\nint\t\tFS_FTell( fileHandle_t f ) {\n\tint pos;\n\tif (fsh[f].zipFile == qtrue) {\n\t\tpos = unztell(fsh[f].handleFiles.file.z);\n\t} else {\n\t\tpos = ftell(fsh[f].handleFiles.file.o);\n\t}\n\treturn pos;\n}\n\nvoid\tFS_Flush( fileHandle_t f ) {\n\tfflush(fsh[f].handleFiles.file.o);\n}\n\nvoid FS_FilenameCompletion( const char *dir, const char *ext, qboolean stripExt, callbackFunc_t callback, qboolean allowNonPureFilesOnDisk ) {\n\tint nfiles;\n\tchar **filenames, filename[MAX_STRING_CHARS];\n\n\tfilenames = FS_ListFilteredFiles( dir, ext, NULL, &nfiles );\n\n\tFS_SortFileList( filenames, nfiles );\n\n\t// pass all the files to callback (FindMatches)\n\tfor ( int i=0; i<nfiles; i++ ) {\n\t\tFS_ConvertPath( filenames[i] );\n\t\tQ_strncpyz( filename, filenames[i], MAX_STRING_CHARS );\n\n\t\tif ( stripExt )\n\t\t\tCOM_StripExtension( filename, filename, sizeof( filename ) );\n\n\t\tcallback( filename );\n\t}\n\tFS_FreeFileList( filenames );\n}\n\nconst char *FS_GetCurrentGameDir(bool emptybase)\n{\n\tif(fs_gamedirvar->string[0])\n\t\treturn fs_gamedirvar->string;\n\n\treturn emptybase ? \"\" : BASEGAME;\n}\n\n#ifdef MACOS_X\nbool FS_LoadMachOBundle( const char *name )\n{\n\tint     len;\n\tvoid    *data;\n\tfileHandle_t    f;\n\tchar    *fn;\n\tunzFile dll;\n\tbyte* buf;\n\tchar    dllName[MAX_QPATH];\n\tchar    *tempName;\n\tunz_file_info   zfi;\n\n\t//read zipped bundle from pk3\n\tlen = FS_ReadFile(name, &data);\n\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\t//write temporary file of zipped bundle to e.g. uixxxxxx\n\t//unique filename to avoid any clashes\n\tCom_sprintf( dllName, sizeof(dllName), \"%sXXXXXX\", name );\n\n\ttempName = mktemp( dllName );\n\n\tf = FS_FOpenFileWrite( dllName );\n\n\tif ( !f )\n\t{\n\t\tFS_FreeFile(data);\n\t\treturn false;\n\t}\n\n\tif (FS_Write( data, len, f ) < len)\n\t{\n\t\tFS_FreeFile(data);\n\t\treturn false;\n\t}\n\n\tFS_FCloseFile( f );\n\tFS_FreeFile(data);\n\n\t//unzOpen zipped bundle, find the dylib, and try to write it\n\tfn = FS_BuildOSPath( fs_homepath->string, fs_gamedir, dllName );\n\n\tdll = unzOpen( fn );\n\n\tCom_sprintf (dllName, sizeof(dllName), \"%s.bundle/Contents/MacOS/%s\", name, name);\n\n\tif (unzLocateFile(dll, dllName, 0) != UNZ_OK)\n\t{\n\t\tunzClose(dll);\n\t\tremove( fn );\n\t\treturn false;\n\t}\n\n\tunzOpenCurrentFile( dll );\n\n\tCom_sprintf( dllName, sizeof(dllName), \"%s_pk3\" DLL_EXT, name );\n\n\tf = FS_FOpenFileWrite( dllName, qfalse );\n\n\tif ( !f )\n\t{\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\tremove( fn );\n\t\treturn false;\n\t}\n\n\tunzGetCurrentFileInfo( dll, &zfi, NULL, 0, NULL, 0, NULL, 0 );\n\n\tlen = zfi.uncompressed_size;\n\n\tbuf = (byte*)Z_Malloc( len+1, TAG_FILESYS, qfalse);\n\n\tif (unzReadCurrentFile( dll, buf, len ) < len)\n\t{\n\t\tFS_FCloseFile( f );\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\treturn false;\n\t}\n\n\tif (FS_Write(buf, len, f) < len)\n\t{\n\t\tFS_FCloseFile( f );\n\t\tunzCloseCurrentFile( dll );\n\t\tunzClose( dll );\n\t\treturn false;\n\t}\n\n\tFS_FCloseFile( f );\n\tunzCloseCurrentFile( dll );\n\tunzClose( dll );\n\tZ_Free( buf );\n\n\t//remove temporary zipped bundle\n\tremove( fn );\n\n\treturn true;\n}\n#endif\n\nqboolean FS_WriteToTemporaryFile( const void *data, size_t dataLength, char **tempFilePath )\n{\n#if defined(_WIN32)\n\tDWORD error;\n\tTCHAR tempPath[MAX_PATH];\n\tDWORD tempPathResult = GetTempPath(MAX_PATH, tempPath);\n\tif ( tempPathResult )\n\t{\n\t\tTCHAR tempFileName[MAX_PATH];\n\t\tUINT tempFileNameResult = GetTempFileName(tempPath, \"OJK\", 0, tempFileName);\n\t\tif ( tempFileNameResult )\n\t\t{\n\t\t\tHANDLE file = CreateFile(\n\t\t\t\ttempFileName, GENERIC_WRITE, 0, NULL,\n\t\t\t\tCREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);\n\t\t\tif ( file != INVALID_HANDLE_VALUE )\n\t\t\t{\n\t\t\t\tDWORD bytesWritten = 0;\n\t\t\t\tif (WriteFile(file, data, dataLength, &bytesWritten, NULL))\n\t\t\t\t{\n\t\t\t\t\tint deletesRemaining = ARRAY_LEN(fs_temporaryFileNames);\n\n\t\t\t\t\tCloseHandle(file);\n\n\t\t\t\t\twhile ( deletesRemaining > 0 &&\n\t\t\t\t\t\t\tfs_temporaryFileNames[fs_temporaryFileWriteIdx][0] != '\\0' )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete old temporary file as we need to\n\t\t\t\t\t\tif ( DeleteFile(fs_temporaryFileNames[fs_temporaryFileWriteIdx]) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terror = GetLastError();\n\t\t\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed for '%s'. \"\n\t\t\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\t\t\tfs_temporaryFileNames[fs_temporaryFileWriteIdx],\n\t\t\t\t\t\t\t\t\terror);\n\n\t\t\t\t\t\t// Failed to delete, possibly because DLL was still in use. This can\n\t\t\t\t\t\t// happen when running a listen server and you continually restart\n\t\t\t\t\t\t// the map. The game DLL is reloaded, but cgame and ui DLLs are not.\n\t\t\t\t\t\tfs_temporaryFileWriteIdx =\n\t\t\t\t\t\t\t(fs_temporaryFileWriteIdx + 1) % ARRAY_LEN(fs_temporaryFileNames);\n\t\t\t\t\t\tdeletesRemaining--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If this happened, then all slots are used and we some how have 8 DLLs\n\t\t\t\t\t// loaded at once?!\n\t\t\t\t\tassert(deletesRemaining > 0);\n\n\t\t\t\t\tQ_strncpyz(fs_temporaryFileNames[fs_temporaryFileWriteIdx],\n\t\t\t\t\t\t\t\ttempFileName, sizeof(fs_temporaryFileNames[0]));\n\t\t\t\t\tfs_temporaryFileWriteIdx =\n\t\t\t\t\t\t(fs_temporaryFileWriteIdx + 1) % ARRAY_LEN(fs_temporaryFileNames);\n\n\t\t\t\t\tif ( tempFilePath )\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t fileNameLen = strlen(tempFileName);\n\t\t\t\t\t\t*tempFilePath = (char *)Z_Malloc(fileNameLen + 1, TAG_FILESYS);\n\t\t\t\t\t\tQ_strncpyz(*tempFilePath, tempFileName, fileNameLen + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn qtrue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror = GetLastError();\n\t\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to write '%s'. \"\n\t\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\t\ttempFileName, error);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\terror = GetLastError();\n\t\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to create '%s'. \"\n\t\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\",\n\t\t\t\t\t\t\ttempFileName, error);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror = GetLastError();\n\t\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to generate temporary file name. \"\n\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\", error);\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = GetLastError();\n\t\tCom_DPrintf(\"FS_WriteToTemporaryFile failed to get temporary file folder. \"\n\t\t\t\t\t\t\"Win32 error code: 0x%08x\\n\", error);\n\t}\n#endif\n\n\treturn qfalse;\n}\n", "/*\n===========================================================================\nCopyright (C) 2005 - 2015, ioquake3 contributors\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n===========================================================================\n*/\n\n#include <csignal>\n#include <cstdlib>\n#include <cstdarg>\n#include <cstdio>\n#include <sys/stat.h>\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n#include \"qcommon/qcommon.h\"\n#include \"sys_local.h\"\n#include \"sys_loadlib.h\"\n#include \"sys_public.h\"\n#include \"con_local.h\"\n\nstatic char binaryPath[ MAX_OSPATH ] = { 0 };\nstatic char installPath[ MAX_OSPATH ] = { 0 };\n\ncvar_t *com_minimized;\ncvar_t *com_unfocused;\ncvar_t *com_maxfps;\ncvar_t *com_maxfpsMinimized;\ncvar_t *com_maxfpsUnfocused;\n\n/*\n=================\nSys_SetBinaryPath\n=================\n*/\nvoid Sys_SetBinaryPath(const char *path)\n{\n\tQ_strncpyz(binaryPath, path, sizeof(binaryPath));\n}\n\n/*\n=================\nSys_BinaryPath\n=================\n*/\nchar *Sys_BinaryPath(void)\n{\n\treturn binaryPath;\n}\n\n/*\n=================\nSys_SetDefaultInstallPath\n=================\n*/\nvoid Sys_SetDefaultInstallPath(const char *path)\n{\n\tQ_strncpyz(installPath, path, sizeof(installPath));\n}\n\n/*\n=================\nSys_DefaultInstallPath\n=================\n*/\nchar *Sys_DefaultInstallPath(void)\n{\n\tif (*installPath)\n\t\treturn installPath;\n\telse\n\t\treturn Sys_Cwd();\n}\n\n/*\n=================\nSys_DefaultAppPath\n=================\n*/\nchar *Sys_DefaultAppPath(void)\n{\n\treturn Sys_BinaryPath();\n}\n\n/*\n==================\nSys_GetClipboardData\n==================\n*/\nchar *Sys_GetClipboardData( void ) {\n#ifdef DEDICATED\n\treturn NULL;\n#else\n\tif ( !SDL_HasClipboardText() )\n\t\treturn NULL;\n\n\tchar *cbText = SDL_GetClipboardText();\n\tsize_t len = strlen( cbText ) + 1;\n\n\tchar *buf = (char *)Z_Malloc( len, TAG_CLIPBOARD );\n\tQ_strncpyz( buf, cbText, len );\n\n\tSDL_free( cbText );\n\treturn buf;\n#endif\n}\n\n/*\n=================\nSys_ConsoleInput\n\nHandle new console input\n=================\n*/\nchar *Sys_ConsoleInput(void)\n{\n\treturn CON_Input( );\n}\n\nvoid Sys_Print( const char *msg ) {\n\t// TTimo - prefix for text that shows up in console but not in notify\n\t// backported from RTCW\n\tif ( !Q_strncmp( msg, \"[skipnotify]\", 12 ) ) {\n\t\tmsg += 12;\n\t}\n\tif ( msg[0] == '*' ) {\n\t\tmsg += 1;\n\t}\n\tConsoleLogAppend( msg );\n\tCON_Print( msg );\n}\n\n/*\n================\nSys_Init\n\nCalled after the common systems (cvars, files, etc)\nare initialized\n================\n*/\nvoid Sys_Init( void ) {\n\tCmd_AddCommand (\"in_restart\", IN_Restart);\n\tCvar_Get( \"arch\", OS_STRING \" \" ARCH_STRING, CVAR_ROM );\n\tCvar_Get( \"username\", Sys_GetCurrentUser(), CVAR_ROM );\n\n\tcom_unfocused = Cvar_Get( \"com_unfocused\", \"0\", CVAR_ROM );\n\tcom_minimized = Cvar_Get( \"com_minimized\", \"0\", CVAR_ROM );\n#ifdef _JK2EXE\n\tcom_maxfps = Cvar_Get (\"com_maxfps\", \"125\", CVAR_ARCHIVE );\n#else\n\tcom_maxfps = Cvar_Get( \"com_maxfps\", \"125\", CVAR_ARCHIVE, \"Maximum frames per second\" );\n#endif\n\tcom_maxfpsUnfocused = Cvar_Get( \"com_maxfpsUnfocused\", \"0\", CVAR_ARCHIVE );\n\tcom_maxfpsMinimized = Cvar_Get( \"com_maxfpsMinimized\", \"50\", CVAR_ARCHIVE );\n}\n\nstatic void NORETURN Sys_Exit( int ex ) {\n\tIN_Shutdown();\n#ifndef DEDICATED\n\tSDL_Quit();\n#endif\n\n\tNET_Shutdown();\n\n\tSys_PlatformExit();\n\n\tCom_ShutdownHunkMemory();\n\tCom_ShutdownZoneMemory();\n\n\tCON_Shutdown();\n\n    exit( ex );\n}\n\n#if !defined(DEDICATED)\nstatic void Sys_ErrorDialog( const char *error )\n{\n\ttime_t rawtime;\n\tchar timeStr[32] = {}; // should really only reach ~19 chars\n\tchar crashLogPath[MAX_OSPATH];\n\n\ttime( &rawtime );\n\tstrftime( timeStr, sizeof( timeStr ), \"%Y-%m-%d_%H-%M-%S\", localtime( &rawtime ) ); // or gmtime\n\tCom_sprintf( crashLogPath, sizeof( crashLogPath ),\n\t\t\t\t\t\"%s%ccrashlog-%s.txt\",\n\t\t\t\t\tSys_DefaultHomePath(), PATH_SEP, timeStr );\n\n\tSys_Mkdir( Sys_DefaultHomePath() );\n\n\tFILE *fp = fopen( crashLogPath, \"w\" );\n\tif ( fp )\n\t{\n\t\tConsoleLogWriteOut( fp );\n\t\tfclose( fp );\n\n\t\tconst char *errorMessage = va( \"%s\\n\\nThe crash log was written to %s\", error, crashLogPath );\n\t\tif ( SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, \"Error\", errorMessage, NULL ) < 0 )\n\t\t{\n\t\t\tfprintf( stderr, \"%s\", errorMessage );\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Getting pretty desperate now\n\t\tConsoleLogWriteOut( stderr );\n\t\tfflush( stderr );\n\n\t\tconst char *errorMessage = va( \"%s\\nCould not write the crash log file, but we printed it to stderr.\\n\"\n\t\t\t\t\t\t\t\t\t\t\"Try running the game using a command line interface.\", error );\n\t\tif ( SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, \"Error\", errorMessage, NULL ) < 0 )\n\t\t{\n\t\t\t// We really have hit rock bottom here :(\n\t\t\tfprintf( stderr, \"%s\", errorMessage );\n\t\t}\n\t}\n}\n#endif\n\nvoid NORETURN QDECL Sys_Error( const char *error, ... )\n{\n\tva_list argptr;\n\tchar    string[1024];\n\n\tva_start (argptr,error);\n\tQ_vsnprintf (string, sizeof(string), error, argptr);\n\tva_end (argptr);\n\n\tSys_Print( string );\n\n\t// Only print Sys_ErrorDialog for client binary. The dedicated\n\t// server binary is meant to be a command line program so you would\n\t// expect to see the error printed.\n#if !defined(DEDICATED)\n\tSys_ErrorDialog( string );\n#endif\n\n\tSys_Exit( 3 );\n}\n\nvoid NORETURN Sys_Quit (void) {\n    Sys_Exit(0);\n}\n\n/*\n============\nSys_FileTime\n\nreturns -1 if not present\n============\n*/\ntime_t Sys_FileTime( const char *path )\n{\n\tstruct stat buf;\n\n\tif ( stat( path, &buf ) == -1 )\n\t\treturn -1;\n\n\treturn buf.st_mtime;\n}\n\n/*\n=================\nSys_UnloadDll\n=================\n*/\nvoid Sys_UnloadDll( void *dllHandle )\n{\n\tif( !dllHandle )\n\t{\n\t\tCom_Printf(\"Sys_UnloadDll(NULL)\\n\");\n\t\treturn;\n\t}\n\n\tSys_UnloadLibrary(dllHandle);\n}\n\n/*\n=================\nSys_LoadDll\n\nFirst try to load library name from system library path,\nfrom executable path, then fs_basepath.\n=================\n*/\nvoid *Sys_LoadDll( const char *name, qboolean useSystemLib )\n{\n\tvoid *dllhandle = NULL;\n\n\t// Don't load any DLLs that end with the pk3 extension\n\tif ( COM_CompareExtension( name, \".pk3\" ) )\n\t{\n\t\tCom_Printf( S_COLOR_YELLOW \"WARNING: Rejecting DLL named \\\"%s\\\"\", name );\n\t\treturn NULL;\n\t}\n\n\tif ( useSystemLib )\n\t{\n\t\tCom_Printf( \"Trying to load \\\"%s\\\"...\\n\", name );\n\n\t\tdllhandle = Sys_LoadLibrary( name );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t}\n\n\tconst char *binarypath = Sys_BinaryPath();\n\tconst char *basepath = Cvar_VariableString( \"fs_basepath\" );\n\n\tif ( !*binarypath )\n\t\tbinarypath = \".\";\n\n\tconst char *searchPaths[] = {\n\t\tbinarypath,\n\t\tbasepath,\n\t};\n\tconst size_t numPaths = ARRAY_LEN( searchPaths );\n\n\tfor ( size_t i = 0; i < numPaths; i++ )\n\t{\n\t\tconst char *libDir = searchPaths[i];\n\t\tif ( !libDir[0] )\n\t\t\tcontinue;\n\n\t\tCom_Printf( \"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, libDir );\n\t\tchar *fn = va( \"%s%c%s\", libDir, PATH_SEP, name );\n\t\tdllhandle = Sys_LoadLibrary( fn );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, fn, Sys_LibraryError() );\n\t}\n\treturn NULL;\n}\n\n#if defined(MACOS_X) && !defined(_JK2EXE)\nvoid *Sys_LoadMachOBundle( const char *name )\n{\n\tif ( !FS_LoadMachOBundle(name) )\n\t\treturn NULL;\n\n\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n\tchar dllName[MAX_QPATH];\n\n\tCom_sprintf( dllName, sizeof(dllName), \"%s_pk3\" DLL_EXT, name );\n\n\t//load the unzipped library\n\tchar *fn = FS_BuildOSPath( homepath, gamedir, dllName );\n\n\tvoid    *libHandle = Sys_LoadLibrary( fn );\n\n\tif ( libHandle != NULL ) {\n\t\tCom_Printf( \"Loaded pk3 bundle %s.\\n\", name );\n\t}\n\n\treturn libHandle;\n}\n#endif\n\nenum SearchPathFlag\n{\n\tSEARCH_PATH_MOD\t\t= 1 << 0,\n\tSEARCH_PATH_BASE\t= 1 << 1,\n\tSEARCH_PATH_OPENJK\t= 1 << 2,\n\tSEARCH_PATH_ROOT\t= 1 << 3\n};\n\nstatic void *Sys_LoadDllFromPaths( const char *filename, const char *gamedir, const char **searchPaths,\n\t\t\t\t\t\t\t\t\tsize_t numPaths, uint32_t searchFlags, const char *callerName )\n{\n\tchar *fn;\n\tvoid *libHandle;\n\n\tif ( searchFlags & SEARCH_PATH_MOD )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, gamedir, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_BASE )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, BASEGAME, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_OPENJK )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = FS_BuildOSPath( libDir, OPENJKGAME, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\tif ( searchFlags & SEARCH_PATH_ROOT )\n\t{\n\t\tfor ( size_t i = 0; i < numPaths; i++ )\n\t\t{\n\t\t\tconst char *libDir = searchPaths[i];\n\t\t\tif ( !libDir[0] )\n\t\t\t\tcontinue;\n\n\t\t\tfn = va( \"%s%c%s\", libDir, PATH_SEP, filename );\n\t\t\tlibHandle = Sys_LoadLibrary( fn );\n\t\t\tif ( libHandle )\n\t\t\t\treturn libHandle;\n\n\t\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", callerName, fn, Sys_LibraryError() );\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void FreeUnpackDLLResult(UnpackDLLResult *result)\n{\n\tif ( result->tempDLLPath )\n\t\tZ_Free((void *)result->tempDLLPath);\n}\n\nvoid *Sys_LoadLegacyGameDll( const char *name, VMMainProc **vmMain, SystemCallProc *systemcalls )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(_DEBUG)\n\tlibHandle = Sys_LoadLibrary( name );\n\tif ( !libHandle )\n#endif\n\t{\n\t\tUnpackDLLResult unpackResult = Sys_UnpackDLL(filename);\n\t\tif ( !unpackResult.succeeded )\n\t\t{\n\t\t\tif ( Sys_DLLNeedsUnpacking() )\n\t\t\t{\n\t\t\t\tFreeUnpackDLLResult(&unpackResult);\n\t\t\t\tCom_DPrintf( \"Sys_LoadLegacyGameDll: Failed to unpack %s from PK3.\\n\", filename );\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibHandle = Sys_LoadLibrary(unpackResult.tempDLLPath);\n\t\t}\n\n\t\tFreeUnpackDLLResult(&unpackResult);\n\n\t\tif ( !libHandle )\n\t\t{\n#if defined(MACOS_X) && !defined(_JK2EXE)\n\t\t\t//First, look for the old-style mac .bundle that's inside a pk3\n\t\t\t//It's actually zipped, and the zipfile has the same name as 'name'\n\t\t\tlibHandle = Sys_LoadMachOBundle( name );\n#endif\n\n\t\t\tif (!libHandle) {\n\t\t\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\t\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\t\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\t\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n\t\t#ifdef MACOS_X\n\t\t\t\tchar *apppath = Cvar_VariableString( \"fs_apppath\" );\n\t\t#endif\n\n\t\t\t\tconst char *searchPaths[] = {\n\t\t\t\t\thomepath,\n\t\t#ifdef MACOS_X\n\t\t\t\t\tapppath,\n\t\t#endif\n\t\t\t\t\tbasepath,\n\t\t\t\t\tcdpath,\n\t\t\t\t};\n\t\t\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\t\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths, SEARCH_PATH_BASE | SEARCH_PATH_MOD, __FUNCTION__ );\n\t\t\t\tif ( !libHandle )\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\ttypedef void QDECL DllEntryProc( SystemCallProc *syscallptr );\n\n\tDllEntryProc *dllEntry = (DllEntryProc *)Sys_LoadFunction( libHandle, \"dllEntry\" );\n\t*vmMain = (VMMainProc *)Sys_LoadFunction( libHandle, \"vmMain\" );\n\n\tif ( !*vmMain || !dllEntry ) {\n\t\tCom_DPrintf ( \"Sys_LoadLegacyGameDll(%s) failed to find vmMain function:\\n...%s!\\n\", name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\tCom_DPrintf ( \"Sys_LoadLegacyGameDll(%s) found vmMain function at 0x%\" PRIxPTR \"\\n\", name, *vmMain );\n\tdllEntry( systemcalls );\n\n\treturn libHandle;\n}\n\nvoid *Sys_LoadSPGameDll( const char *name, GetGameAPIProc **GetGameAPI )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tassert( GetGameAPI );\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(MACOS_X) && !defined(_JK2EXE)\n    //First, look for the old-style mac .bundle that's inside a pk3\n    //It's actually zipped, and the zipfile has the same name as 'name'\n    libHandle = Sys_LoadMachOBundle( filename );\n#endif\n\n\tif (!libHandle) {\n\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n#ifdef MACOS_X\n        char *apppath = Cvar_VariableString( \"fs_apppath\" );\n#endif\n\n\t\tconst char *searchPaths[] = {\n\t\t\thomepath,\n#ifdef MACOS_X\n\t\t\tapppath,\n#endif\n\t\t\tbasepath,\n\t\t\tcdpath,\n\t\t};\n\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths,\n\t\t\t\t\t\t\t\t\t\t\tSEARCH_PATH_BASE | SEARCH_PATH_MOD | SEARCH_PATH_OPENJK | SEARCH_PATH_ROOT,\n\t\t\t\t\t\t\t\t\t\t\t__FUNCTION__ );\n\t\tif ( !libHandle )\n\t\t\treturn NULL;\n\t}\n\n\t*GetGameAPI = (GetGameAPIProc *)Sys_LoadFunction( libHandle, \"GetGameAPI\" );\n\tif ( !*GetGameAPI ) {\n\t\tCom_DPrintf ( \"%s(%s) failed to find GetGameAPI function:\\n...%s!\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\treturn libHandle;\n}\n\nvoid *Sys_LoadGameDll( const char *name, GetModuleAPIProc **moduleAPI )\n{\n\tvoid\t*libHandle = NULL;\n\tchar\tfilename[MAX_OSPATH];\n\n\tCom_sprintf (filename, sizeof(filename), \"%s\" ARCH_STRING DLL_EXT, name);\n\n#if defined(_DEBUG)\n\tlibHandle = Sys_LoadLibrary( filename );\n\tif ( !libHandle )\n#endif\n\t{\n\t\tUnpackDLLResult unpackResult = Sys_UnpackDLL(filename);\n\t\tif ( !unpackResult.succeeded )\n\t\t{\n\t\t\tif ( Sys_DLLNeedsUnpacking() )\n\t\t\t{\n\t\t\t\tFreeUnpackDLLResult(&unpackResult);\n\t\t\t\tCom_DPrintf( \"Sys_LoadLegacyGameDll: Failed to unpack %s from PK3.\\n\", filename );\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibHandle = Sys_LoadLibrary(unpackResult.tempDLLPath);\n\t\t}\n\n\t\tFreeUnpackDLLResult(&unpackResult);\n\n\t\tif ( !libHandle )\n\t\t{\n#if defined(MACOS_X) && !defined(_JK2EXE)\n\t\t\t//First, look for the old-style mac .bundle that's inside a pk3\n\t\t\t//It's actually zipped, and the zipfile has the same name as 'name'\n\t\t\tlibHandle = Sys_LoadMachOBundle( name );\n#endif\n\n\t\t\tif (!libHandle) {\n\t\t\t\tchar *basepath = Cvar_VariableString( \"fs_basepath\" );\n\t\t\t\tchar *homepath = Cvar_VariableString( \"fs_homepath\" );\n\t\t\t\tchar *cdpath = Cvar_VariableString( \"fs_cdpath\" );\n\t\t\t\tchar *gamedir = Cvar_VariableString( \"fs_game\" );\n#ifdef MACOS_X\n\t\t\t\tchar *apppath = Cvar_VariableString( \"fs_apppath\" );\n#endif\n\n\t\t\t\tconst char *searchPaths[] = {\n\t\t\t\t\thomepath,\n#ifdef MACOS_X\n\t\t\t\t\tapppath,\n#endif\n\t\t\t\t\tbasepath,\n\t\t\t\t\tcdpath,\n\t\t\t\t};\n\t\t\t\tsize_t numPaths = ARRAY_LEN( searchPaths );\n\n\t\t\t\tlibHandle = Sys_LoadDllFromPaths( filename, gamedir, searchPaths, numPaths, SEARCH_PATH_BASE | SEARCH_PATH_MOD, __FUNCTION__ );\n\t\t\t\tif ( !libHandle )\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t*moduleAPI = (GetModuleAPIProc *)Sys_LoadFunction( libHandle, \"GetModuleAPI\" );\n\tif ( !*moduleAPI ) {\n\t\tCom_DPrintf ( \"Sys_LoadGameDll(%s) failed to find GetModuleAPI function:\\n...%s!\\n\", name, Sys_LibraryError() );\n\t\tSys_UnloadLibrary( libHandle );\n\t\treturn NULL;\n\t}\n\n\treturn libHandle;\n}\n\n/*\n=================\nSys_SigHandler\n=================\n*/\nvoid Sys_SigHandler( int signal )\n{\n\tstatic qboolean signalcaught = qfalse;\n\n\tif( signalcaught )\n\t{\n\t\tfprintf( stderr, \"DOUBLE SIGNAL FAULT: Received signal %d, exiting...\\n\",\n\t\t\tsignal );\n\t}\n\telse\n\t{\n\t\tsignalcaught = qtrue;\n\t\t//VM_Forced_Unload_Start();\n#ifndef DEDICATED\n\t\tCL_Shutdown();\n\t\t//CL_Shutdown(va(\"Received signal %d\", signal), qtrue, qtrue);\n#endif\n\t\tSV_Shutdown(va(\"Received signal %d\", signal) );\n\t\t//VM_Forced_Unload_Done();\n\t}\n\n\tif( signal == SIGTERM || signal == SIGINT )\n\t\tSys_Exit( 1 );\n\telse\n\t\tSys_Exit( 2 );\n}\n\n#ifdef MACOS_X\n/*\n =================\n Sys_StripAppBundle\n\n Discovers if passed dir is suffixed with the directory structure of a Mac OS X\n .app bundle. If it is, the .app directory structure is stripped off the end and\n the result is returned. If not, dir is returned untouched.\n =================\n */\nchar *Sys_StripAppBundle( char *dir )\n{\n\tstatic char cwd[MAX_OSPATH];\n\n\tQ_strncpyz(cwd, dir, sizeof(cwd));\n\tif(strcmp(Sys_Basename(cwd), \"MacOS\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\tif(strcmp(Sys_Basename(cwd), \"Contents\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\tif(!strstr(Sys_Basename(cwd), \".app\"))\n\t\treturn dir;\n\tQ_strncpyz(cwd, Sys_Dirname(cwd), sizeof(cwd));\n\treturn cwd;\n}\n#endif\n\n#ifndef DEFAULT_BASEDIR\n#\tifdef MACOS_X\n#\t\tdefine DEFAULT_BASEDIR Sys_StripAppBundle(Sys_BinaryPath())\n#\telse\n#\t\tdefine DEFAULT_BASEDIR Sys_BinaryPath()\n#\tendif\n#endif\n\nint main ( int argc, char* argv[] )\n{\n\tint\t\ti;\n\tchar\tcommandLine[ MAX_STRING_CHARS ] = { 0 };\n\n\tSys_PlatformInit();\n\tCON_Init();\n\n\t// get the initial time base\n\tSys_Milliseconds();\n\n#ifdef MACOS_X\n\t// This is passed if we are launched by double-clicking\n\tif ( argc >= 2 && Q_strncmp ( argv[1], \"-psn\", 4 ) == 0 )\n\t\targc = 1;\n#endif\n\n\tSys_SetBinaryPath( Sys_Dirname( argv[ 0 ] ) );\n\tSys_SetDefaultInstallPath( DEFAULT_BASEDIR );\n\n\t// Concatenate the command line for passing to Com_Init\n\tfor( i = 1; i < argc; i++ )\n\t{\n\t\tconst bool containsSpaces = (strchr(argv[i], ' ') != NULL);\n\t\tif (containsSpaces)\n\t\t\tQ_strcat( commandLine, sizeof( commandLine ), \"\\\"\" );\n\n\t\tQ_strcat( commandLine, sizeof( commandLine ), argv[ i ] );\n\n\t\tif (containsSpaces)\n\t\t\tQ_strcat( commandLine, sizeof( commandLine ), \"\\\"\" );\n\n\t\tQ_strcat( commandLine, sizeof( commandLine ), \" \" );\n\t}\n\n\tCom_Init (commandLine);\n\n\tNET_Init();\n\n\t// main game loop\n\twhile (1)\n\t{\n\t\tif ( com_busyWait->integer )\n\t\t{\n\t\t\tbool shouldSleep = false;\n\n#if !defined(_JK2EXE)\n\t\t\tif ( com_dedicated->integer )\n\t\t\t{\n\t\t\t\tshouldSleep = true;\n\t\t\t}\n#endif\n\n\t\t\tif ( com_minimized->integer )\n\t\t\t{\n\t\t\t\tshouldSleep = true;\n\t\t\t}\n\n\t\t\tif ( shouldSleep )\n\t\t\t{\n\t\t\t\tSys_Sleep( 5 );\n\t\t\t}\n\t\t}\n\n\t\t// run the game\n\t\tCom_Frame();\n\t}\n\n\t// never gets here\n\treturn 0;\n}\n"], "filenames": ["code/client/cl_main.cpp", "code/qcommon/files.cpp", "codemp/client/cl_main.cpp", "codemp/qcommon/files.cpp", "shared/sys/sys_main.cpp"], "buggy_code_start_loc": [1087, 1260, 2367, 1269, 300], "buggy_code_end_loc": [1088, 1318, 2368, 1329, 300], "fixing_code_start_loc": [1087, 1261, 2367, 1270, 301], "fixing_code_end_loc": [1088, 1327, 2368, 1338, 308], "type": "NVD-CWE-noinfo", "message": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.", "other": {"cve": {"id": "CVE-2017-6903", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-14T22:59:01.257", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."}, {"lang": "es", "value": "En ioquake3 en versiones anteriores a 14-03-2017, la caracter\u00edstica de descarga autom\u00e1tica tiene insuficientes restricciones de contenido. Esto tambi\u00e9n afecta a Quake III Arena, OpenArena, OpenJK, iortcw y otras horquillas id Tech 3 (tambi\u00e9n conocidas como Quake 3 engine). Un archivo malicioso autodescargado puede desencadenar carga de archivos autodescargados manipulados como DLLs de c\u00f3digo nativo. Un archivo malicioso autodescargado puede contener configuraci\u00f3n predeterminada que anula la del usuario. Bytecode ejecutable en un archivo autodescargado malicioso puede configurar variables de configuraci\u00f3n a valores que resultar\u00e1n en la carga de DLLs de c\u00f3digo nativo no deseadas, resultando en sandbox de escape."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ioquake3:ioquake3:*:*:*:*:*:*:*:*", "versionEndIncluding": "2017-02-27", "matchCriteriaId": "69AED8AB-60F2-45B1-A9C7-83D6A2AB9E0A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3812", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=857699", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/JACoders/OpenJK/commit/8956a35e7b91c4a0dd1fa6db1d28c7f0efbab2d7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ioquake/ioq3/commit/b173ac05993f634a42be3d3535e1b158de0c3372", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ioquake/ioq3/commit/f61fe5f6a0419ef4a88d46a128052f2e8352e85d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/iortcw/iortcw/commit/b248763e4878ef12d5835ece6600be8334f67da1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://ioquake3.org/2017/03/13/important-security-update-please-update-ioquake3-immediately/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/JACoders/OpenJK/commit/8956a35e7b91c4a0dd1fa6db1d28c7f0efbab2d7"}}