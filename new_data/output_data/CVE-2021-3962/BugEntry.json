{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            DDDD    CCCC  M   M                              %\n%                            D   D  C      MM MM                              %\n%                            D   D  C      M M M                              %\n%                            D   D  C      M   M                              %\n%                            DDDD    CCCC  M   M                              %\n%                                                                             %\n%                                                                             %\n%                          Read DICOM Image Format                            %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"coders/coders-private.h\"\n\f\n/*\n  Dicom medical image declarations.\n*/\n\ntypedef struct _DicomInfo\n{\n  const unsigned short\n    group,\n    element;\n\n  const char\n    *vr,\n    *description;\n} DicomInfo;\n\nstatic const DicomInfo\n  dicom_info[] =\n  {\n    { 0x0000, 0x0000, \"UL\", \"Group Length\" },\n    { 0x0000, 0x0001, \"UL\", \"Command Length to End\" },\n    { 0x0000, 0x0002, \"UI\", \"Affected SOP Class UID\" },\n    { 0x0000, 0x0003, \"UI\", \"Requested SOP Class UID\" },\n    { 0x0000, 0x0010, \"LO\", \"Command Recognition Code\" },\n    { 0x0000, 0x0100, \"US\", \"Command Field\" },\n    { 0x0000, 0x0110, \"US\", \"Message ID\" },\n    { 0x0000, 0x0120, \"US\", \"Message ID Being Responded To\" },\n    { 0x0000, 0x0200, \"AE\", \"Initiator\" },\n    { 0x0000, 0x0300, \"AE\", \"Receiver\" },\n    { 0x0000, 0x0400, \"AE\", \"Find Location\" },\n    { 0x0000, 0x0600, \"AE\", \"Move Destination\" },\n    { 0x0000, 0x0700, \"US\", \"Priority\" },\n    { 0x0000, 0x0800, \"US\", \"Data Set Type\" },\n    { 0x0000, 0x0850, \"US\", \"Number of Matches\" },\n    { 0x0000, 0x0860, \"US\", \"Response Sequence Number\" },\n    { 0x0000, 0x0900, \"US\", \"Status\" },\n    { 0x0000, 0x0901, \"AT\", \"Offending Element\" },\n    { 0x0000, 0x0902, \"LO\", \"Exception Comment\" },\n    { 0x0000, 0x0903, \"US\", \"Exception ID\" },\n    { 0x0000, 0x1000, \"UI\", \"Affected SOP Instance UID\" },\n    { 0x0000, 0x1001, \"UI\", \"Requested SOP Instance UID\" },\n    { 0x0000, 0x1002, \"US\", \"Event Type ID\" },\n    { 0x0000, 0x1005, \"AT\", \"Attribute Identifier List\" },\n    { 0x0000, 0x1008, \"US\", \"Action Type ID\" },\n    { 0x0000, 0x1020, \"US\", \"Number of Remaining Suboperations\" },\n    { 0x0000, 0x1021, \"US\", \"Number of Completed Suboperations\" },\n    { 0x0000, 0x1022, \"US\", \"Number of Failed Suboperations\" },\n    { 0x0000, 0x1023, \"US\", \"Number of Warning Suboperations\" },\n    { 0x0000, 0x1030, \"AE\", \"Move Originator Application Entity Title\" },\n    { 0x0000, 0x1031, \"US\", \"Move Originator Message ID\" },\n    { 0x0000, 0x4000, \"LO\", \"Dialog Receiver\" },\n    { 0x0000, 0x4010, \"LO\", \"Terminal Type\" },\n    { 0x0000, 0x5010, \"SH\", \"Message Set ID\" },\n    { 0x0000, 0x5020, \"SH\", \"End Message Set\" },\n    { 0x0000, 0x5110, \"LO\", \"Display Format\" },\n    { 0x0000, 0x5120, \"LO\", \"Page Position ID\" },\n    { 0x0000, 0x5130, \"LO\", \"Text Format ID\" },\n    { 0x0000, 0x5140, \"LO\", \"Normal Reverse\" },\n    { 0x0000, 0x5150, \"LO\", \"Add Gray Scale\" },\n    { 0x0000, 0x5160, \"LO\", \"Borders\" },\n    { 0x0000, 0x5170, \"IS\", \"Copies\" },\n    { 0x0000, 0x5180, \"LO\", \"OldMagnificationType\" },\n    { 0x0000, 0x5190, \"LO\", \"Erase\" },\n    { 0x0000, 0x51a0, \"LO\", \"Print\" },\n    { 0x0000, 0x51b0, \"US\", \"Overlays\" },\n    { 0x0002, 0x0000, \"UL\", \"Meta Element Group Length\" },\n    { 0x0002, 0x0001, \"OB\", \"File Meta Information Version\" },\n    { 0x0002, 0x0002, \"UI\", \"Media Storage SOP Class UID\" },\n    { 0x0002, 0x0003, \"UI\", \"Media Storage SOP Instance UID\" },\n    { 0x0002, 0x0010, \"UI\", \"Transfer Syntax UID\" },\n    { 0x0002, 0x0012, \"UI\", \"Implementation Class UID\" },\n    { 0x0002, 0x0013, \"SH\", \"Implementation Version Name\" },\n    { 0x0002, 0x0016, \"AE\", \"Source Application Entity Title\" },\n    { 0x0002, 0x0100, \"UI\", \"Private Information Creator UID\" },\n    { 0x0002, 0x0102, \"OB\", \"Private Information\" },\n    { 0x0003, 0x0000, \"US\", \"?\" },\n    { 0x0003, 0x0008, \"US\", \"ISI Command Field\" },\n    { 0x0003, 0x0011, \"US\", \"Attach ID Application Code\" },\n    { 0x0003, 0x0012, \"UL\", \"Attach ID Message Count\" },\n    { 0x0003, 0x0013, \"DA\", \"Attach ID Date\" },\n    { 0x0003, 0x0014, \"TM\", \"Attach ID Time\" },\n    { 0x0003, 0x0020, \"US\", \"Message Type\" },\n    { 0x0003, 0x0030, \"DA\", \"Max Waiting Date\" },\n    { 0x0003, 0x0031, \"TM\", \"Max Waiting Time\" },\n    { 0x0004, 0x0000, \"UL\", \"File Set Group Length\" },\n    { 0x0004, 0x1130, \"CS\", \"File Set ID\" },\n    { 0x0004, 0x1141, \"CS\", \"File Set Descriptor File ID\" },\n    { 0x0004, 0x1142, \"CS\", \"File Set Descriptor File Specific Character Set\" },\n    { 0x0004, 0x1200, \"UL\", \"Root Directory Entity First Directory Record Offset\" },\n    { 0x0004, 0x1202, \"UL\", \"Root Directory Entity Last Directory Record Offset\" },\n    { 0x0004, 0x1212, \"US\", \"File Set Consistency Flag\" },\n    { 0x0004, 0x1220, \"SQ\", \"Directory Record Sequence\" },\n    { 0x0004, 0x1400, \"UL\", \"Next Directory Record Offset\" },\n    { 0x0004, 0x1410, \"US\", \"Record In Use Flag\" },\n    { 0x0004, 0x1420, \"UL\", \"Referenced Lower Level Directory Entity Offset\" },\n    { 0x0004, 0x1430, \"CS\", \"Directory Record Type\" },\n    { 0x0004, 0x1432, \"UI\", \"Private Record UID\" },\n    { 0x0004, 0x1500, \"CS\", \"Referenced File ID\" },\n    { 0x0004, 0x1504, \"UL\", \"MRDR Directory Record Offset\" },\n    { 0x0004, 0x1510, \"UI\", \"Referenced SOP Class UID In File\" },\n    { 0x0004, 0x1511, \"UI\", \"Referenced SOP Instance UID In File\" },\n    { 0x0004, 0x1512, \"UI\", \"Referenced Transfer Syntax UID In File\" },\n    { 0x0004, 0x1600, \"UL\", \"Number of References\" },\n    { 0x0005, 0x0000, \"US\", \"?\" },\n    { 0x0006, 0x0000, \"US\", \"?\" },\n    { 0x0008, 0x0000, \"UL\", \"Identifying Group Length\" },\n    { 0x0008, 0x0001, \"UL\", \"Length to End\" },\n    { 0x0008, 0x0005, \"CS\", \"Specific Character Set\" },\n    { 0x0008, 0x0008, \"CS\", \"Image Type\" },\n    { 0x0008, 0x0010, \"LO\", \"Recognition Code\" },\n    { 0x0008, 0x0012, \"DA\", \"Instance Creation Date\" },\n    { 0x0008, 0x0013, \"TM\", \"Instance Creation Time\" },\n    { 0x0008, 0x0014, \"UI\", \"Instance Creator UID\" },\n    { 0x0008, 0x0016, \"UI\", \"SOP Class UID\" },\n    { 0x0008, 0x0018, \"UI\", \"SOP Instance UID\" },\n    { 0x0008, 0x0020, \"DA\", \"Study Date\" },\n    { 0x0008, 0x0021, \"DA\", \"Series Date\" },\n    { 0x0008, 0x0022, \"DA\", \"Acquisition Date\" },\n    { 0x0008, 0x0023, \"DA\", \"Image Date\" },\n    { 0x0008, 0x0024, \"DA\", \"Overlay Date\" },\n    { 0x0008, 0x0025, \"DA\", \"Curve Date\" },\n    { 0x0008, 0x002A, \"DT\", \"Acquisition DateTime\" },\n    { 0x0008, 0x0030, \"TM\", \"Study Time\" },\n    { 0x0008, 0x0031, \"TM\", \"Series Time\" },\n    { 0x0008, 0x0032, \"TM\", \"Acquisition Time\" },\n    { 0x0008, 0x0033, \"TM\", \"Image Time\" },\n    { 0x0008, 0x0034, \"TM\", \"Overlay Time\" },\n    { 0x0008, 0x0035, \"TM\", \"Curve Time\" },\n    { 0x0008, 0x0040, \"xs\", \"Old Data Set Type\" },\n    { 0x0008, 0x0041, \"xs\", \"Old Data Set Subtype\" },\n    { 0x0008, 0x0042, \"CS\", \"Nuclear Medicine Series Type\" },\n    { 0x0008, 0x0050, \"SH\", \"Accession Number\" },\n    { 0x0008, 0x0052, \"CS\", \"Query/Retrieve Level\" },\n    { 0x0008, 0x0054, \"AE\", \"Retrieve AE Title\" },\n    { 0x0008, 0x0058, \"UI\", \"Failed SOP Instance UID List\" },\n    { 0x0008, 0x0060, \"CS\", \"Modality\" },\n    { 0x0008, 0x0062, \"SQ\", \"Modality Subtype\" },\n    { 0x0008, 0x0064, \"CS\", \"Conversion Type\" },\n    { 0x0008, 0x0068, \"CS\", \"Presentation Intent Type\" },\n    { 0x0008, 0x0070, \"LO\", \"Manufacturer\" },\n    { 0x0008, 0x0080, \"LO\", \"Institution Name\" },\n    { 0x0008, 0x0081, \"ST\", \"Institution Address\" },\n    { 0x0008, 0x0082, \"SQ\", \"Institution Code Sequence\" },\n    { 0x0008, 0x0090, \"PN\", \"Referring Physician's Name\" },\n    { 0x0008, 0x0092, \"ST\", \"Referring Physician's Address\" },\n    { 0x0008, 0x0094, \"SH\", \"Referring Physician's Telephone Numbers\" },\n    { 0x0008, 0x0100, \"SH\", \"Code Value\" },\n    { 0x0008, 0x0102, \"SH\", \"Coding Scheme Designator\" },\n    { 0x0008, 0x0103, \"SH\", \"Coding Scheme Version\" },\n    { 0x0008, 0x0104, \"LO\", \"Code Meaning\" },\n    { 0x0008, 0x0105, \"CS\", \"Mapping Resource\" },\n    { 0x0008, 0x0106, \"DT\", \"Context Group Version\" },\n    { 0x0008, 0x010b, \"CS\", \"Code Set Extension Flag\" },\n    { 0x0008, 0x010c, \"UI\", \"Private Coding Scheme Creator UID\" },\n    { 0x0008, 0x010d, \"UI\", \"Code Set Extension Creator UID\" },\n    { 0x0008, 0x010f, \"CS\", \"Context Identifier\" },\n    { 0x0008, 0x1000, \"LT\", \"Network ID\" },\n    { 0x0008, 0x1010, \"SH\", \"Station Name\" },\n    { 0x0008, 0x1030, \"LO\", \"Study Description\" },\n    { 0x0008, 0x1032, \"SQ\", \"Procedure Code Sequence\" },\n    { 0x0008, 0x103e, \"LO\", \"Series Description\" },\n    { 0x0008, 0x1040, \"LO\", \"Institutional Department Name\" },\n    { 0x0008, 0x1048, \"PN\", \"Physician of Record\" },\n    { 0x0008, 0x1050, \"PN\", \"Performing Physician's Name\" },\n    { 0x0008, 0x1060, \"PN\", \"Name of Physician(s) Reading Study\" },\n    { 0x0008, 0x1070, \"PN\", \"Operator's Name\" },\n    { 0x0008, 0x1080, \"LO\", \"Admitting Diagnosis Description\" },\n    { 0x0008, 0x1084, \"SQ\", \"Admitting Diagnosis Code Sequence\" },\n    { 0x0008, 0x1090, \"LO\", \"Manufacturer's Model Name\" },\n    { 0x0008, 0x1100, \"SQ\", \"Referenced Results Sequence\" },\n    { 0x0008, 0x1110, \"SQ\", \"Referenced Study Sequence\" },\n    { 0x0008, 0x1111, \"SQ\", \"Referenced Study Component Sequence\" },\n    { 0x0008, 0x1115, \"SQ\", \"Referenced Series Sequence\" },\n    { 0x0008, 0x1120, \"SQ\", \"Referenced Patient Sequence\" },\n    { 0x0008, 0x1125, \"SQ\", \"Referenced Visit Sequence\" },\n    { 0x0008, 0x1130, \"SQ\", \"Referenced Overlay Sequence\" },\n    { 0x0008, 0x1140, \"SQ\", \"Referenced Image Sequence\" },\n    { 0x0008, 0x1145, \"SQ\", \"Referenced Curve Sequence\" },\n    { 0x0008, 0x1148, \"SQ\", \"Referenced Previous Waveform\" },\n    { 0x0008, 0x114a, \"SQ\", \"Referenced Simultaneous Waveforms\" },\n    { 0x0008, 0x114c, \"SQ\", \"Referenced Subsequent Waveform\" },\n    { 0x0008, 0x1150, \"UI\", \"Referenced SOP Class UID\" },\n    { 0x0008, 0x1155, \"UI\", \"Referenced SOP Instance UID\" },\n    { 0x0008, 0x1160, \"IS\", \"Referenced Frame Number\" },\n    { 0x0008, 0x1195, \"UI\", \"Transaction UID\" },\n    { 0x0008, 0x1197, \"US\", \"Failure Reason\" },\n    { 0x0008, 0x1198, \"SQ\", \"Failed SOP Sequence\" },\n    { 0x0008, 0x1199, \"SQ\", \"Referenced SOP Sequence\" },\n    { 0x0008, 0x2110, \"CS\", \"Old Lossy Image Compression\" },\n    { 0x0008, 0x2111, \"ST\", \"Derivation Description\" },\n    { 0x0008, 0x2112, \"SQ\", \"Source Image Sequence\" },\n    { 0x0008, 0x2120, \"SH\", \"Stage Name\" },\n    { 0x0008, 0x2122, \"IS\", \"Stage Number\" },\n    { 0x0008, 0x2124, \"IS\", \"Number of Stages\" },\n    { 0x0008, 0x2128, \"IS\", \"View Number\" },\n    { 0x0008, 0x2129, \"IS\", \"Number of Event Timers\" },\n    { 0x0008, 0x212a, \"IS\", \"Number of Views in Stage\" },\n    { 0x0008, 0x2130, \"DS\", \"Event Elapsed Time(s)\" },\n    { 0x0008, 0x2132, \"LO\", \"Event Timer Name(s)\" },\n    { 0x0008, 0x2142, \"IS\", \"Start Trim\" },\n    { 0x0008, 0x2143, \"IS\", \"Stop Trim\" },\n    { 0x0008, 0x2144, \"IS\", \"Recommended Display Frame Rate\" },\n    { 0x0008, 0x2200, \"CS\", \"Transducer Position\" },\n    { 0x0008, 0x2204, \"CS\", \"Transducer Orientation\" },\n    { 0x0008, 0x2208, \"CS\", \"Anatomic Structure\" },\n    { 0x0008, 0x2218, \"SQ\", \"Anatomic Region Sequence\" },\n    { 0x0008, 0x2220, \"SQ\", \"Anatomic Region Modifier Sequence\" },\n    { 0x0008, 0x2228, \"SQ\", \"Primary Anatomic Structure Sequence\" },\n    { 0x0008, 0x2230, \"SQ\", \"Primary Anatomic Structure Modifier Sequence\" },\n    { 0x0008, 0x2240, \"SQ\", \"Transducer Position Sequence\" },\n    { 0x0008, 0x2242, \"SQ\", \"Transducer Position Modifier Sequence\" },\n    { 0x0008, 0x2244, \"SQ\", \"Transducer Orientation Sequence\" },\n    { 0x0008, 0x2246, \"SQ\", \"Transducer Orientation Modifier Sequence\" },\n    { 0x0008, 0x2251, \"SQ\", \"Anatomic Structure Space Or Region Code Sequence\" },\n    { 0x0008, 0x2253, \"SQ\", \"Anatomic Portal Of Entrance Code Sequence\" },\n    { 0x0008, 0x2255, \"SQ\", \"Anatomic Approach Direction Code Sequence\" },\n    { 0x0008, 0x2256, \"ST\", \"Anatomic Perspective Description\" },\n    { 0x0008, 0x2257, \"SQ\", \"Anatomic Perspective Code Sequence\" },\n    { 0x0008, 0x2258, \"ST\", \"Anatomic Location Of Examining Instrument Description\" },\n    { 0x0008, 0x2259, \"SQ\", \"Anatomic Location Of Examining Instrument Code Sequence\" },\n    { 0x0008, 0x225a, \"SQ\", \"Anatomic Structure Space Or Region Modifier Code Sequence\" },\n    { 0x0008, 0x225c, \"SQ\", \"OnAxis Background Anatomic Structure Code Sequence\" },\n    { 0x0008, 0x4000, \"LT\", \"Identifying Comments\" },\n    { 0x0009, 0x0000, \"xs\", \"?\" },\n    { 0x0009, 0x0001, \"xs\", \"?\" },\n    { 0x0009, 0x0002, \"xs\", \"?\" },\n    { 0x0009, 0x0003, \"xs\", \"?\" },\n    { 0x0009, 0x0004, \"xs\", \"?\" },\n    { 0x0009, 0x0005, \"UN\", \"?\" },\n    { 0x0009, 0x0006, \"UN\", \"?\" },\n    { 0x0009, 0x0007, \"UN\", \"?\" },\n    { 0x0009, 0x0008, \"xs\", \"?\" },\n    { 0x0009, 0x0009, \"LT\", \"?\" },\n    { 0x0009, 0x000a, \"IS\", \"?\" },\n    { 0x0009, 0x000b, \"IS\", \"?\" },\n    { 0x0009, 0x000c, \"IS\", \"?\" },\n    { 0x0009, 0x000d, \"IS\", \"?\" },\n    { 0x0009, 0x000e, \"IS\", \"?\" },\n    { 0x0009, 0x000f, \"UN\", \"?\" },\n    { 0x0009, 0x0010, \"xs\", \"?\" },\n    { 0x0009, 0x0011, \"xs\", \"?\" },\n    { 0x0009, 0x0012, \"xs\", \"?\" },\n    { 0x0009, 0x0013, \"xs\", \"?\" },\n    { 0x0009, 0x0014, \"xs\", \"?\" },\n    { 0x0009, 0x0015, \"xs\", \"?\" },\n    { 0x0009, 0x0016, \"xs\", \"?\" },\n    { 0x0009, 0x0017, \"LT\", \"?\" },\n    { 0x0009, 0x0018, \"LT\", \"Data Set Identifier\" },\n    { 0x0009, 0x001a, \"US\", \"?\" },\n    { 0x0009, 0x001e, \"UI\", \"?\" },\n    { 0x0009, 0x0020, \"xs\", \"?\" },\n    { 0x0009, 0x0021, \"xs\", \"?\" },\n    { 0x0009, 0x0022, \"SH\", \"User Orientation\" },\n    { 0x0009, 0x0023, \"SL\", \"Initiation Type\" },\n    { 0x0009, 0x0024, \"xs\", \"?\" },\n    { 0x0009, 0x0025, \"xs\", \"?\" },\n    { 0x0009, 0x0026, \"xs\", \"?\" },\n    { 0x0009, 0x0027, \"xs\", \"?\" },\n    { 0x0009, 0x0029, \"xs\", \"?\" },\n    { 0x0009, 0x002a, \"SL\", \"?\" },\n    { 0x0009, 0x002c, \"LO\", \"Series Comments\" },\n    { 0x0009, 0x002d, \"SL\", \"Track Beat Average\" },\n    { 0x0009, 0x002e, \"FD\", \"Distance Prescribed\" },\n    { 0x0009, 0x002f, \"LT\", \"?\" },\n    { 0x0009, 0x0030, \"xs\", \"?\" },\n    { 0x0009, 0x0031, \"xs\", \"?\" },\n    { 0x0009, 0x0032, \"LT\", \"?\" },\n    { 0x0009, 0x0034, \"xs\", \"?\" },\n    { 0x0009, 0x0035, \"SL\", \"Gantry Locus Type\" },\n    { 0x0009, 0x0037, \"SL\", \"Starting Heart Rate\" },\n    { 0x0009, 0x0038, \"xs\", \"?\" },\n    { 0x0009, 0x0039, \"SL\", \"RR Window Offset\" },\n    { 0x0009, 0x003a, \"SL\", \"Percent Cycle Imaged\" },\n    { 0x0009, 0x003e, \"US\", \"?\" },\n    { 0x0009, 0x003f, \"US\", \"?\" },\n    { 0x0009, 0x0040, \"xs\", \"?\" },\n    { 0x0009, 0x0041, \"xs\", \"?\" },\n    { 0x0009, 0x0042, \"xs\", \"?\" },\n    { 0x0009, 0x0043, \"xs\", \"?\" },\n    { 0x0009, 0x0050, \"LT\", \"?\" },\n    { 0x0009, 0x0051, \"xs\", \"?\" },\n    { 0x0009, 0x0060, \"LT\", \"?\" },\n    { 0x0009, 0x0061, \"LT\", \"Series Unique Identifier\" },\n    { 0x0009, 0x0070, \"LT\", \"?\" },\n    { 0x0009, 0x0080, \"LT\", \"?\" },\n    { 0x0009, 0x0091, \"LT\", \"?\" },\n    { 0x0009, 0x00e2, \"LT\", \"?\" },\n    { 0x0009, 0x00e3, \"UI\", \"Equipment UID\" },\n    { 0x0009, 0x00e6, \"SH\", \"Genesis Version Now\" },\n    { 0x0009, 0x00e7, \"UL\", \"Exam Record Checksum\" },\n    { 0x0009, 0x00e8, \"UL\", \"?\" },\n    { 0x0009, 0x00e9, \"SL\", \"Actual Series Data Time Stamp\" },\n    { 0x0009, 0x00f2, \"UN\", \"?\" },\n    { 0x0009, 0x00f3, \"UN\", \"?\" },\n    { 0x0009, 0x00f4, \"LT\", \"?\" },\n    { 0x0009, 0x00f5, \"xs\", \"?\" },\n    { 0x0009, 0x00f6, \"LT\", \"PDM Data Object Type Extension\" },\n    { 0x0009, 0x00f8, \"US\", \"?\" },\n    { 0x0009, 0x00fb, \"IS\", \"?\" },\n    { 0x0009, 0x1002, \"OB\", \"?\" },\n    { 0x0009, 0x1003, \"OB\", \"?\" },\n    { 0x0009, 0x1010, \"UN\", \"?\" },\n    { 0x0010, 0x0000, \"UL\", \"Patient Group Length\" },\n    { 0x0010, 0x0010, \"PN\", \"Patient's Name\" },\n    { 0x0010, 0x0020, \"LO\", \"Patient's ID\" },\n    { 0x0010, 0x0021, \"LO\", \"Issuer of Patient's ID\" },\n    { 0x0010, 0x0030, \"DA\", \"Patient's Birth Date\" },\n    { 0x0010, 0x0032, \"TM\", \"Patient's Birth Time\" },\n    { 0x0010, 0x0040, \"CS\", \"Patient's Sex\" },\n    { 0x0010, 0x0050, \"SQ\", \"Patient's Insurance Plan Code Sequence\" },\n    { 0x0010, 0x1000, \"LO\", \"Other Patient's ID's\" },\n    { 0x0010, 0x1001, \"PN\", \"Other Patient's Names\" },\n    { 0x0010, 0x1005, \"PN\", \"Patient's Birth Name\" },\n    { 0x0010, 0x1010, \"AS\", \"Patient's Age\" },\n    { 0x0010, 0x1020, \"DS\", \"Patient's Size\" },\n    { 0x0010, 0x1030, \"DS\", \"Patient's Weight\" },\n    { 0x0010, 0x1040, \"LO\", \"Patient's Address\" },\n    { 0x0010, 0x1050, \"LT\", \"Insurance Plan Identification\" },\n    { 0x0010, 0x1060, \"PN\", \"Patient's Mother's Birth Name\" },\n    { 0x0010, 0x1080, \"LO\", \"Military Rank\" },\n    { 0x0010, 0x1081, \"LO\", \"Branch of Service\" },\n    { 0x0010, 0x1090, \"LO\", \"Medical Record Locator\" },\n    { 0x0010, 0x2000, \"LO\", \"Medical Alerts\" },\n    { 0x0010, 0x2110, \"LO\", \"Contrast Allergies\" },\n    { 0x0010, 0x2150, \"LO\", \"Country of Residence\" },\n    { 0x0010, 0x2152, \"LO\", \"Region of Residence\" },\n    { 0x0010, 0x2154, \"SH\", \"Patients Telephone Numbers\" },\n    { 0x0010, 0x2160, \"SH\", \"Ethnic Group\" },\n    { 0x0010, 0x2180, \"SH\", \"Occupation\" },\n    { 0x0010, 0x21a0, \"CS\", \"Smoking Status\" },\n    { 0x0010, 0x21b0, \"LT\", \"Additional Patient History\" },\n    { 0x0010, 0x21c0, \"US\", \"Pregnancy Status\" },\n    { 0x0010, 0x21d0, \"DA\", \"Last Menstrual Date\" },\n    { 0x0010, 0x21f0, \"LO\", \"Patients Religious Preference\" },\n    { 0x0010, 0x4000, \"LT\", \"Patient Comments\" },\n    { 0x0011, 0x0001, \"xs\", \"?\" },\n    { 0x0011, 0x0002, \"US\", \"?\" },\n    { 0x0011, 0x0003, \"LT\", \"Patient UID\" },\n    { 0x0011, 0x0004, \"LT\", \"Patient ID\" },\n    { 0x0011, 0x000a, \"xs\", \"?\" },\n    { 0x0011, 0x000b, \"SL\", \"Effective Series Duration\" },\n    { 0x0011, 0x000c, \"SL\", \"Num Beats\" },\n    { 0x0011, 0x000d, \"LO\", \"Radio Nuclide Name\" },\n    { 0x0011, 0x0010, \"xs\", \"?\" },\n    { 0x0011, 0x0011, \"xs\", \"?\" },\n    { 0x0011, 0x0012, \"LO\", \"Dataset Name\" },\n    { 0x0011, 0x0013, \"LO\", \"Dataset Type\" },\n    { 0x0011, 0x0015, \"xs\", \"?\" },\n    { 0x0011, 0x0016, \"SL\", \"Energy Number\" },\n    { 0x0011, 0x0017, \"SL\", \"RR Interval Window Number\" },\n    { 0x0011, 0x0018, \"SL\", \"MG Bin Number\" },\n    { 0x0011, 0x0019, \"FD\", \"Radius Of Rotation\" },\n    { 0x0011, 0x001a, \"SL\", \"Detector Count Zone\" },\n    { 0x0011, 0x001b, \"SL\", \"Num Energy Windows\" },\n    { 0x0011, 0x001c, \"SL\", \"Energy Offset\" },\n    { 0x0011, 0x001d, \"SL\", \"Energy Range\" },\n    { 0x0011, 0x001f, \"SL\", \"Image Orientation\" },\n    { 0x0011, 0x0020, \"xs\", \"?\" },\n    { 0x0011, 0x0021, \"xs\", \"?\" },\n    { 0x0011, 0x0022, \"xs\", \"?\" },\n    { 0x0011, 0x0023, \"xs\", \"?\" },\n    { 0x0011, 0x0024, \"SL\", \"FOV Mask Y Cutoff Angle\" },\n    { 0x0011, 0x0025, \"xs\", \"?\" },\n    { 0x0011, 0x0026, \"SL\", \"Table Orientation\" },\n    { 0x0011, 0x0027, \"SL\", \"ROI Top Left\" },\n    { 0x0011, 0x0028, \"SL\", \"ROI Bottom Right\" },\n    { 0x0011, 0x0030, \"xs\", \"?\" },\n    { 0x0011, 0x0031, \"xs\", \"?\" },\n    { 0x0011, 0x0032, \"UN\", \"?\" },\n    { 0x0011, 0x0033, \"LO\", \"Energy Correct Name\" },\n    { 0x0011, 0x0034, \"LO\", \"Spatial Correct Name\" },\n    { 0x0011, 0x0035, \"xs\", \"?\" },\n    { 0x0011, 0x0036, \"LO\", \"Uniformity Correct Name\" },\n    { 0x0011, 0x0037, \"LO\", \"Acquisition Specific Correct Name\" },\n    { 0x0011, 0x0038, \"SL\", \"Byte Order\" },\n    { 0x0011, 0x003a, \"SL\", \"Picture Format\" },\n    { 0x0011, 0x003b, \"FD\", \"Pixel Scale\" },\n    { 0x0011, 0x003c, \"FD\", \"Pixel Offset\" },\n    { 0x0011, 0x003e, \"SL\", \"FOV Shape\" },\n    { 0x0011, 0x003f, \"SL\", \"Dataset Flags\" },\n    { 0x0011, 0x0040, \"xs\", \"?\" },\n    { 0x0011, 0x0041, \"LT\", \"Medical Alerts\" },\n    { 0x0011, 0x0042, \"LT\", \"Contrast Allergies\" },\n    { 0x0011, 0x0044, \"FD\", \"Threshold Center\" },\n    { 0x0011, 0x0045, \"FD\", \"Threshold Width\" },\n    { 0x0011, 0x0046, \"SL\", \"Interpolation Type\" },\n    { 0x0011, 0x0055, \"FD\", \"Period\" },\n    { 0x0011, 0x0056, \"FD\", \"ElapsedTime\" },\n    { 0x0011, 0x00a1, \"DA\", \"Patient Registration Date\" },\n    { 0x0011, 0x00a2, \"TM\", \"Patient Registration Time\" },\n    { 0x0011, 0x00b0, \"LT\", \"Patient Last Name\" },\n    { 0x0011, 0x00b2, \"LT\", \"Patient First Name\" },\n    { 0x0011, 0x00b4, \"LT\", \"Patient Hospital Status\" },\n    { 0x0011, 0x00bc, \"TM\", \"Current Location Time\" },\n    { 0x0011, 0x00c0, \"LT\", \"Patient Insurance Status\" },\n    { 0x0011, 0x00d0, \"LT\", \"Patient Billing Type\" },\n    { 0x0011, 0x00d2, \"LT\", \"Patient Billing Address\" },\n    { 0x0013, 0x0000, \"LT\", \"Modifying Physician\" },\n    { 0x0013, 0x0010, \"xs\", \"?\" },\n    { 0x0013, 0x0011, \"SL\", \"?\" },\n    { 0x0013, 0x0012, \"xs\", \"?\" },\n    { 0x0013, 0x0016, \"SL\", \"AutoTrack Peak\" },\n    { 0x0013, 0x0017, \"SL\", \"AutoTrack Width\" },\n    { 0x0013, 0x0018, \"FD\", \"Transmission Scan Time\" },\n    { 0x0013, 0x0019, \"FD\", \"Transmission Mask Width\" },\n    { 0x0013, 0x001a, \"FD\", \"Copper Attenuator Thickness\" },\n    { 0x0013, 0x001c, \"FD\", \"?\" },\n    { 0x0013, 0x001d, \"FD\", \"?\" },\n    { 0x0013, 0x001e, \"FD\", \"Tomo View Offset\" },\n    { 0x0013, 0x0020, \"LT\", \"Patient Name\" },\n    { 0x0013, 0x0022, \"LT\", \"Patient Id\" },\n    { 0x0013, 0x0026, \"LT\", \"Study Comments\" },\n    { 0x0013, 0x0030, \"DA\", \"Patient Birthdate\" },\n    { 0x0013, 0x0031, \"DS\", \"Patient Weight\" },\n    { 0x0013, 0x0032, \"LT\", \"Patients Maiden Name\" },\n    { 0x0013, 0x0033, \"LT\", \"Referring Physician\" },\n    { 0x0013, 0x0034, \"LT\", \"Admitting Diagnosis\" },\n    { 0x0013, 0x0035, \"LT\", \"Patient Sex\" },\n    { 0x0013, 0x0040, \"LT\", \"Procedure Description\" },\n    { 0x0013, 0x0042, \"LT\", \"Patient Rest Direction\" },\n    { 0x0013, 0x0044, \"LT\", \"Patient Position\" },\n    { 0x0013, 0x0046, \"LT\", \"View Direction\" },\n    { 0x0015, 0x0001, \"DS\", \"Stenosis Calibration Ratio\" },\n    { 0x0015, 0x0002, \"DS\", \"Stenosis Magnification\" },\n    { 0x0015, 0x0003, \"DS\", \"Cardiac Calibration Ratio\" },\n    { 0x0018, 0x0000, \"UL\", \"Acquisition Group Length\" },\n    { 0x0018, 0x0010, \"LO\", \"Contrast/Bolus Agent\" },\n    { 0x0018, 0x0012, \"SQ\", \"Contrast/Bolus Agent Sequence\" },\n    { 0x0018, 0x0014, \"SQ\", \"Contrast/Bolus Administration Route Sequence\" },\n    { 0x0018, 0x0015, \"CS\", \"Body Part Examined\" },\n    { 0x0018, 0x0020, \"CS\", \"Scanning Sequence\" },\n    { 0x0018, 0x0021, \"CS\", \"Sequence Variant\" },\n    { 0x0018, 0x0022, \"CS\", \"Scan Options\" },\n    { 0x0018, 0x0023, \"CS\", \"MR Acquisition Type\" },\n    { 0x0018, 0x0024, \"SH\", \"Sequence Name\" },\n    { 0x0018, 0x0025, \"CS\", \"Angio Flag\" },\n    { 0x0018, 0x0026, \"SQ\", \"Intervention Drug Information Sequence\" },\n    { 0x0018, 0x0027, \"TM\", \"Intervention Drug Stop Time\" },\n    { 0x0018, 0x0028, \"DS\", \"Intervention Drug Dose\" },\n    { 0x0018, 0x0029, \"SQ\", \"Intervention Drug Code Sequence\" },\n    { 0x0018, 0x002a, \"SQ\", \"Additional Drug Sequence\" },\n    { 0x0018, 0x0030, \"LO\", \"Radionuclide\" },\n    { 0x0018, 0x0031, \"LO\", \"Radiopharmaceutical\" },\n    { 0x0018, 0x0032, \"DS\", \"Energy Window Centerline\" },\n    { 0x0018, 0x0033, \"DS\", \"Energy Window Total Width\" },\n    { 0x0018, 0x0034, \"LO\", \"Intervention Drug Name\" },\n    { 0x0018, 0x0035, \"TM\", \"Intervention Drug Start Time\" },\n    { 0x0018, 0x0036, \"SQ\", \"Intervention Therapy Sequence\" },\n    { 0x0018, 0x0037, \"CS\", \"Therapy Type\" },\n    { 0x0018, 0x0038, \"CS\", \"Intervention Status\" },\n    { 0x0018, 0x0039, \"CS\", \"Therapy Description\" },\n    { 0x0018, 0x0040, \"IS\", \"Cine Rate\" },\n    { 0x0018, 0x0050, \"DS\", \"Slice Thickness\" },\n    { 0x0018, 0x0060, \"DS\", \"KVP\" },\n    { 0x0018, 0x0070, \"IS\", \"Counts Accumulated\" },\n    { 0x0018, 0x0071, \"CS\", \"Acquisition Termination Condition\" },\n    { 0x0018, 0x0072, \"DS\", \"Effective Series Duration\" },\n    { 0x0018, 0x0073, \"CS\", \"Acquisition Start Condition\" },\n    { 0x0018, 0x0074, \"IS\", \"Acquisition Start Condition Data\" },\n    { 0x0018, 0x0075, \"IS\", \"Acquisition Termination Condition Data\" },\n    { 0x0018, 0x0080, \"DS\", \"Repetition Time\" },\n    { 0x0018, 0x0081, \"DS\", \"Echo Time\" },\n    { 0x0018, 0x0082, \"DS\", \"Inversion Time\" },\n    { 0x0018, 0x0083, \"DS\", \"Number of Averages\" },\n    { 0x0018, 0x0084, \"DS\", \"Imaging Frequency\" },\n    { 0x0018, 0x0085, \"SH\", \"Imaged Nucleus\" },\n    { 0x0018, 0x0086, \"IS\", \"Echo Number(s)\" },\n    { 0x0018, 0x0087, \"DS\", \"Magnetic Field Strength\" },\n    { 0x0018, 0x0088, \"DS\", \"Spacing Between Slices\" },\n    { 0x0018, 0x0089, \"IS\", \"Number of Phase Encoding Steps\" },\n    { 0x0018, 0x0090, \"DS\", \"Data Collection Diameter\" },\n    { 0x0018, 0x0091, \"IS\", \"Echo Train Length\" },\n    { 0x0018, 0x0093, \"DS\", \"Percent Sampling\" },\n    { 0x0018, 0x0094, \"DS\", \"Percent Phase Field of View\" },\n    { 0x0018, 0x0095, \"DS\", \"Pixel Bandwidth\" },\n    { 0x0018, 0x1000, \"LO\", \"Device Serial Number\" },\n    { 0x0018, 0x1004, \"LO\", \"Plate ID\" },\n    { 0x0018, 0x1010, \"LO\", \"Secondary Capture Device ID\" },\n    { 0x0018, 0x1012, \"DA\", \"Date of Secondary Capture\" },\n    { 0x0018, 0x1014, \"TM\", \"Time of Secondary Capture\" },\n    { 0x0018, 0x1016, \"LO\", \"Secondary Capture Device Manufacturer\" },\n    { 0x0018, 0x1018, \"LO\", \"Secondary Capture Device Manufacturer Model Name\" },\n    { 0x0018, 0x1019, \"LO\", \"Secondary Capture Device Software Version(s)\" },\n    { 0x0018, 0x1020, \"LO\", \"Software Version(s)\" },\n    { 0x0018, 0x1022, \"SH\", \"Video Image Format Acquired\" },\n    { 0x0018, 0x1023, \"LO\", \"Digital Image Format Acquired\" },\n    { 0x0018, 0x1030, \"LO\", \"Protocol Name\" },\n    { 0x0018, 0x1040, \"LO\", \"Contrast/Bolus Route\" },\n    { 0x0018, 0x1041, \"DS\", \"Contrast/Bolus Volume\" },\n    { 0x0018, 0x1042, \"TM\", \"Contrast/Bolus Start Time\" },\n    { 0x0018, 0x1043, \"TM\", \"Contrast/Bolus Stop Time\" },\n    { 0x0018, 0x1044, \"DS\", \"Contrast/Bolus Total Dose\" },\n    { 0x0018, 0x1045, \"IS\", \"Syringe Counts\" },\n    { 0x0018, 0x1046, \"DS\", \"Contrast Flow Rate\" },\n    { 0x0018, 0x1047, \"DS\", \"Contrast Flow Duration\" },\n    { 0x0018, 0x1048, \"CS\", \"Contrast/Bolus Ingredient\" },\n    { 0x0018, 0x1049, \"DS\", \"Contrast/Bolus Ingredient Concentration\" },\n    { 0x0018, 0x1050, \"DS\", \"Spatial Resolution\" },\n    { 0x0018, 0x1060, \"DS\", \"Trigger Time\" },\n    { 0x0018, 0x1061, \"LO\", \"Trigger Source or Type\" },\n    { 0x0018, 0x1062, \"IS\", \"Nominal Interval\" },\n    { 0x0018, 0x1063, \"DS\", \"Frame Time\" },\n    { 0x0018, 0x1064, \"LO\", \"Framing Type\" },\n    { 0x0018, 0x1065, \"DS\", \"Frame Time Vector\" },\n    { 0x0018, 0x1066, \"DS\", \"Frame Delay\" },\n    { 0x0018, 0x1067, \"DS\", \"Image Trigger Delay\" },\n    { 0x0018, 0x1068, \"DS\", \"Group Time Offset\" },\n    { 0x0018, 0x1069, \"DS\", \"Trigger Time Offset\" },\n    { 0x0018, 0x106a, \"CS\", \"Synchronization Trigger\" },\n    { 0x0018, 0x106b, \"UI\", \"Synchronization Frame of Reference\" },\n    { 0x0018, 0x106e, \"UL\", \"Trigger Sample Position\" },\n    { 0x0018, 0x1070, \"LO\", \"Radiopharmaceutical Route\" },\n    { 0x0018, 0x1071, \"DS\", \"Radiopharmaceutical Volume\" },\n    { 0x0018, 0x1072, \"TM\", \"Radiopharmaceutical Start Time\" },\n    { 0x0018, 0x1073, \"TM\", \"Radiopharmaceutical Stop Time\" },\n    { 0x0018, 0x1074, \"DS\", \"Radionuclide Total Dose\" },\n    { 0x0018, 0x1075, \"DS\", \"Radionuclide Half Life\" },\n    { 0x0018, 0x1076, \"DS\", \"Radionuclide Positron Fraction\" },\n    { 0x0018, 0x1077, \"DS\", \"Radiopharmaceutical Specific Activity\" },\n    { 0x0018, 0x1080, \"CS\", \"Beat Rejection Flag\" },\n    { 0x0018, 0x1081, \"IS\", \"Low R-R Value\" },\n    { 0x0018, 0x1082, \"IS\", \"High R-R Value\" },\n    { 0x0018, 0x1083, \"IS\", \"Intervals Acquired\" },\n    { 0x0018, 0x1084, \"IS\", \"Intervals Rejected\" },\n    { 0x0018, 0x1085, \"LO\", \"PVC Rejection\" },\n    { 0x0018, 0x1086, \"IS\", \"Skip Beats\" },\n    { 0x0018, 0x1088, \"IS\", \"Heart Rate\" },\n    { 0x0018, 0x1090, \"IS\", \"Cardiac Number of Images\" },\n    { 0x0018, 0x1094, \"IS\", \"Trigger Window\" },\n    { 0x0018, 0x1100, \"DS\", \"Reconstruction Diameter\" },\n    { 0x0018, 0x1110, \"DS\", \"Distance Source to Detector\" },\n    { 0x0018, 0x1111, \"DS\", \"Distance Source to Patient\" },\n    { 0x0018, 0x1114, \"DS\", \"Estimated Radiographic Magnification Factor\" },\n    { 0x0018, 0x1120, \"DS\", \"Gantry/Detector Tilt\" },\n    { 0x0018, 0x1121, \"DS\", \"Gantry/Detector Slew\" },\n    { 0x0018, 0x1130, \"DS\", \"Table Height\" },\n    { 0x0018, 0x1131, \"DS\", \"Table Traverse\" },\n    { 0x0018, 0x1134, \"CS\", \"Table Motion\" },\n    { 0x0018, 0x1135, \"DS\", \"Table Vertical Increment\" },\n    { 0x0018, 0x1136, \"DS\", \"Table Lateral Increment\" },\n    { 0x0018, 0x1137, \"DS\", \"Table Longitudinal Increment\" },\n    { 0x0018, 0x1138, \"DS\", \"Table Angle\" },\n    { 0x0018, 0x113a, \"CS\", \"Table Type\" },\n    { 0x0018, 0x1140, \"CS\", \"Rotation Direction\" },\n    { 0x0018, 0x1141, \"DS\", \"Angular Position\" },\n    { 0x0018, 0x1142, \"DS\", \"Radial Position\" },\n    { 0x0018, 0x1143, \"DS\", \"Scan Arc\" },\n    { 0x0018, 0x1144, \"DS\", \"Angular Step\" },\n    { 0x0018, 0x1145, \"DS\", \"Center of Rotation Offset\" },\n    { 0x0018, 0x1146, \"DS\", \"Rotation Offset\" },\n    { 0x0018, 0x1147, \"CS\", \"Field of View Shape\" },\n    { 0x0018, 0x1149, \"IS\", \"Field of View Dimension(s)\" },\n    { 0x0018, 0x1150, \"IS\", \"Exposure Time\" },\n    { 0x0018, 0x1151, \"IS\", \"X-ray Tube Current\" },\n    { 0x0018, 0x1152, \"IS\", \"Exposure\" },\n    { 0x0018, 0x1153, \"IS\", \"Exposure in uAs\" },\n    { 0x0018, 0x1154, \"DS\", \"AveragePulseWidth\" },\n    { 0x0018, 0x1155, \"CS\", \"RadiationSetting\" },\n    { 0x0018, 0x1156, \"CS\", \"Rectification Type\" },\n    { 0x0018, 0x115a, \"CS\", \"RadiationMode\" },\n    { 0x0018, 0x115e, \"DS\", \"ImageAreaDoseProduct\" },\n    { 0x0018, 0x1160, \"SH\", \"Filter Type\" },\n    { 0x0018, 0x1161, \"LO\", \"TypeOfFilters\" },\n    { 0x0018, 0x1162, \"DS\", \"IntensifierSize\" },\n    { 0x0018, 0x1164, \"DS\", \"ImagerPixelSpacing\" },\n    { 0x0018, 0x1166, \"CS\", \"Grid\" },\n    { 0x0018, 0x1170, \"IS\", \"Generator Power\" },\n    { 0x0018, 0x1180, \"SH\", \"Collimator/Grid Name\" },\n    { 0x0018, 0x1181, \"CS\", \"Collimator Type\" },\n    { 0x0018, 0x1182, \"IS\", \"Focal Distance\" },\n    { 0x0018, 0x1183, \"DS\", \"X Focus Center\" },\n    { 0x0018, 0x1184, \"DS\", \"Y Focus Center\" },\n    { 0x0018, 0x1190, \"DS\", \"Focal Spot(s)\" },\n    { 0x0018, 0x1191, \"CS\", \"Anode Target Material\" },\n    { 0x0018, 0x11a0, \"DS\", \"Body Part Thickness\" },\n    { 0x0018, 0x11a2, \"DS\", \"Compression Force\" },\n    { 0x0018, 0x1200, \"DA\", \"Date of Last Calibration\" },\n    { 0x0018, 0x1201, \"TM\", \"Time of Last Calibration\" },\n    { 0x0018, 0x1210, \"SH\", \"Convolution Kernel\" },\n    { 0x0018, 0x1240, \"IS\", \"Upper/Lower Pixel Values\" },\n    { 0x0018, 0x1242, \"IS\", \"Actual Frame Duration\" },\n    { 0x0018, 0x1243, \"IS\", \"Count Rate\" },\n    { 0x0018, 0x1244, \"US\", \"Preferred Playback Sequencing\" },\n    { 0x0018, 0x1250, \"SH\", \"Receiving Coil\" },\n    { 0x0018, 0x1251, \"SH\", \"Transmitting Coil\" },\n    { 0x0018, 0x1260, \"SH\", \"Plate Type\" },\n    { 0x0018, 0x1261, \"LO\", \"Phosphor Type\" },\n    { 0x0018, 0x1300, \"DS\", \"Scan Velocity\" },\n    { 0x0018, 0x1301, \"CS\", \"Whole Body Technique\" },\n    { 0x0018, 0x1302, \"IS\", \"Scan Length\" },\n    { 0x0018, 0x1310, \"US\", \"Acquisition Matrix\" },\n    { 0x0018, 0x1312, \"CS\", \"Phase Encoding Direction\" },\n    { 0x0018, 0x1314, \"DS\", \"Flip Angle\" },\n    { 0x0018, 0x1315, \"CS\", \"Variable Flip Angle Flag\" },\n    { 0x0018, 0x1316, \"DS\", \"SAR\" },\n    { 0x0018, 0x1318, \"DS\", \"dB/dt\" },\n    { 0x0018, 0x1400, \"LO\", \"Acquisition Device Processing Description\" },\n    { 0x0018, 0x1401, \"LO\", \"Acquisition Device Processing Code\" },\n    { 0x0018, 0x1402, \"CS\", \"Cassette Orientation\" },\n    { 0x0018, 0x1403, \"CS\", \"Cassette Size\" },\n    { 0x0018, 0x1404, \"US\", \"Exposures on Plate\" },\n    { 0x0018, 0x1405, \"IS\", \"Relative X-ray Exposure\" },\n    { 0x0018, 0x1450, \"DS\", \"Column Angulation\" },\n    { 0x0018, 0x1460, \"DS\", \"Tomo Layer Height\" },\n    { 0x0018, 0x1470, \"DS\", \"Tomo Angle\" },\n    { 0x0018, 0x1480, \"DS\", \"Tomo Time\" },\n    { 0x0018, 0x1490, \"CS\", \"Tomo Type\" },\n    { 0x0018, 0x1491, \"CS\", \"Tomo Class\" },\n    { 0x0018, 0x1495, \"IS\", \"Number of Tomosynthesis Source Images\" },\n    { 0x0018, 0x1500, \"CS\", \"PositionerMotion\" },\n    { 0x0018, 0x1508, \"CS\", \"Positioner Type\" },\n    { 0x0018, 0x1510, \"DS\", \"PositionerPrimaryAngle\" },\n    { 0x0018, 0x1511, \"DS\", \"PositionerSecondaryAngle\" },\n    { 0x0018, 0x1520, \"DS\", \"PositionerPrimaryAngleIncrement\" },\n    { 0x0018, 0x1521, \"DS\", \"PositionerSecondaryAngleIncrement\" },\n    { 0x0018, 0x1530, \"DS\", \"DetectorPrimaryAngle\" },\n    { 0x0018, 0x1531, \"DS\", \"DetectorSecondaryAngle\" },\n    { 0x0018, 0x1600, \"CS\", \"Shutter Shape\" },\n    { 0x0018, 0x1602, \"IS\", \"Shutter Left Vertical Edge\" },\n    { 0x0018, 0x1604, \"IS\", \"Shutter Right Vertical Edge\" },\n    { 0x0018, 0x1606, \"IS\", \"Shutter Upper Horizontal Edge\" },\n    { 0x0018, 0x1608, \"IS\", \"Shutter Lower Horizonta lEdge\" },\n    { 0x0018, 0x1610, \"IS\", \"Center of Circular Shutter\" },\n    { 0x0018, 0x1612, \"IS\", \"Radius of Circular Shutter\" },\n    { 0x0018, 0x1620, \"IS\", \"Vertices of Polygonal Shutter\" },\n    { 0x0018, 0x1622, \"US\", \"Shutter Presentation Value\" },\n    { 0x0018, 0x1623, \"US\", \"Shutter Overlay Group\" },\n    { 0x0018, 0x1700, \"CS\", \"Collimator Shape\" },\n    { 0x0018, 0x1702, \"IS\", \"Collimator Left Vertical Edge\" },\n    { 0x0018, 0x1704, \"IS\", \"Collimator Right Vertical Edge\" },\n    { 0x0018, 0x1706, \"IS\", \"Collimator Upper Horizontal Edge\" },\n    { 0x0018, 0x1708, \"IS\", \"Collimator Lower Horizontal Edge\" },\n    { 0x0018, 0x1710, \"IS\", \"Center of Circular Collimator\" },\n    { 0x0018, 0x1712, \"IS\", \"Radius of Circular Collimator\" },\n    { 0x0018, 0x1720, \"IS\", \"Vertices of Polygonal Collimator\" },\n    { 0x0018, 0x1800, \"CS\", \"Acquisition Time Synchronized\" },\n    { 0x0018, 0x1801, \"SH\", \"Time Source\" },\n    { 0x0018, 0x1802, \"CS\", \"Time Distribution Protocol\" },\n    { 0x0018, 0x4000, \"LT\", \"Acquisition Comments\" },\n    { 0x0018, 0x5000, \"SH\", \"Output Power\" },\n    { 0x0018, 0x5010, \"LO\", \"Transducer Data\" },\n    { 0x0018, 0x5012, \"DS\", \"Focus Depth\" },\n    { 0x0018, 0x5020, \"LO\", \"Processing Function\" },\n    { 0x0018, 0x5021, \"LO\", \"Postprocessing Function\" },\n    { 0x0018, 0x5022, \"DS\", \"Mechanical Index\" },\n    { 0x0018, 0x5024, \"DS\", \"Thermal Index\" },\n    { 0x0018, 0x5026, \"DS\", \"Cranial Thermal Index\" },\n    { 0x0018, 0x5027, \"DS\", \"Soft Tissue Thermal Index\" },\n    { 0x0018, 0x5028, \"DS\", \"Soft Tissue-Focus Thermal Index\" },\n    { 0x0018, 0x5029, \"DS\", \"Soft Tissue-Surface Thermal Index\" },\n    { 0x0018, 0x5030, \"DS\", \"Dynamic Range\" },\n    { 0x0018, 0x5040, \"DS\", \"Total Gain\" },\n    { 0x0018, 0x5050, \"IS\", \"Depth of Scan Field\" },\n    { 0x0018, 0x5100, \"CS\", \"Patient Position\" },\n    { 0x0018, 0x5101, \"CS\", \"View Position\" },\n    { 0x0018, 0x5104, \"SQ\", \"Projection Eponymous Name Code Sequence\" },\n    { 0x0018, 0x5210, \"DS\", \"Image Transformation Matrix\" },\n    { 0x0018, 0x5212, \"DS\", \"Image Translation Vector\" },\n    { 0x0018, 0x6000, \"DS\", \"Sensitivity\" },\n    { 0x0018, 0x6011, \"IS\", \"Sequence of Ultrasound Regions\" },\n    { 0x0018, 0x6012, \"US\", \"Region Spatial Format\" },\n    { 0x0018, 0x6014, \"US\", \"Region Data Type\" },\n    { 0x0018, 0x6016, \"UL\", \"Region Flags\" },\n    { 0x0018, 0x6018, \"UL\", \"Region Location Min X0\" },\n    { 0x0018, 0x601a, \"UL\", \"Region Location Min Y0\" },\n    { 0x0018, 0x601c, \"UL\", \"Region Location Max X1\" },\n    { 0x0018, 0x601e, \"UL\", \"Region Location Max Y1\" },\n    { 0x0018, 0x6020, \"SL\", \"Reference Pixel X0\" },\n    { 0x0018, 0x6022, \"SL\", \"Reference Pixel Y0\" },\n    { 0x0018, 0x6024, \"US\", \"Physical Units X Direction\" },\n    { 0x0018, 0x6026, \"US\", \"Physical Units Y Direction\" },\n    { 0x0018, 0x6028, \"FD\", \"Reference Pixel Physical Value X\" },\n    { 0x0018, 0x602a, \"US\", \"Reference Pixel Physical Value Y\" },\n    { 0x0018, 0x602c, \"US\", \"Physical Delta X\" },\n    { 0x0018, 0x602e, \"US\", \"Physical Delta Y\" },\n    { 0x0018, 0x6030, \"UL\", \"Transducer Frequency\" },\n    { 0x0018, 0x6031, \"CS\", \"Transducer Type\" },\n    { 0x0018, 0x6032, \"UL\", \"Pulse Repetition Frequency\" },\n    { 0x0018, 0x6034, \"FD\", \"Doppler Correction Angle\" },\n    { 0x0018, 0x6036, \"FD\", \"Steering Angle\" },\n    { 0x0018, 0x6038, \"UL\", \"Doppler Sample Volume X Position\" },\n    { 0x0018, 0x603a, \"UL\", \"Doppler Sample Volume Y Position\" },\n    { 0x0018, 0x603c, \"UL\", \"TM-Line Position X0\" },\n    { 0x0018, 0x603e, \"UL\", \"TM-Line Position Y0\" },\n    { 0x0018, 0x6040, \"UL\", \"TM-Line Position X1\" },\n    { 0x0018, 0x6042, \"UL\", \"TM-Line Position Y1\" },\n    { 0x0018, 0x6044, \"US\", \"Pixel Component Organization\" },\n    { 0x0018, 0x6046, \"UL\", \"Pixel Component Mask\" },\n    { 0x0018, 0x6048, \"UL\", \"Pixel Component Range Start\" },\n    { 0x0018, 0x604a, \"UL\", \"Pixel Component Range Stop\" },\n    { 0x0018, 0x604c, \"US\", \"Pixel Component Physical Units\" },\n    { 0x0018, 0x604e, \"US\", \"Pixel Component Data Type\" },\n    { 0x0018, 0x6050, \"UL\", \"Number of Table Break Points\" },\n    { 0x0018, 0x6052, \"UL\", \"Table of X Break Points\" },\n    { 0x0018, 0x6054, \"FD\", \"Table of Y Break Points\" },\n    { 0x0018, 0x6056, \"UL\", \"Number of Table Entries\" },\n    { 0x0018, 0x6058, \"UL\", \"Table of Pixel Values\" },\n    { 0x0018, 0x605a, \"FL\", \"Table of Parameter Values\" },\n    { 0x0018, 0x7000, \"CS\", \"Detector Conditions Nominal Flag\" },\n    { 0x0018, 0x7001, \"DS\", \"Detector Temperature\" },\n    { 0x0018, 0x7004, \"CS\", \"Detector Type\" },\n    { 0x0018, 0x7005, \"CS\", \"Detector Configuration\" },\n    { 0x0018, 0x7006, \"LT\", \"Detector Description\" },\n    { 0x0018, 0x7008, \"LT\", \"Detector Mode\" },\n    { 0x0018, 0x700a, \"SH\", \"Detector ID\" },\n    { 0x0018, 0x700c, \"DA\", \"Date of Last Detector Calibration \" },\n    { 0x0018, 0x700e, \"TM\", \"Time of Last Detector Calibration\" },\n    { 0x0018, 0x7010, \"IS\", \"Exposures on Detector Since Last Calibration\" },\n    { 0x0018, 0x7011, \"IS\", \"Exposures on Detector Since Manufactured\" },\n    { 0x0018, 0x7012, \"DS\", \"Detector Time Since Last Exposure\" },\n    { 0x0018, 0x7014, \"DS\", \"Detector Active Time\" },\n    { 0x0018, 0x7016, \"DS\", \"Detector Activation Offset From Exposure\" },\n    { 0x0018, 0x701a, \"DS\", \"Detector Binning\" },\n    { 0x0018, 0x7020, \"DS\", \"Detector Element Physical Size\" },\n    { 0x0018, 0x7022, \"DS\", \"Detector Element Spacing\" },\n    { 0x0018, 0x7024, \"CS\", \"Detector Active Shape\" },\n    { 0x0018, 0x7026, \"DS\", \"Detector Active Dimensions\" },\n    { 0x0018, 0x7028, \"DS\", \"Detector Active Origin\" },\n    { 0x0018, 0x7030, \"DS\", \"Field of View Origin\" },\n    { 0x0018, 0x7032, \"DS\", \"Field of View Rotation\" },\n    { 0x0018, 0x7034, \"CS\", \"Field of View Horizontal Flip\" },\n    { 0x0018, 0x7040, \"LT\", \"Grid Absorbing Material\" },\n    { 0x0018, 0x7041, \"LT\", \"Grid Spacing Material\" },\n    { 0x0018, 0x7042, \"DS\", \"Grid Thickness\" },\n    { 0x0018, 0x7044, \"DS\", \"Grid Pitch\" },\n    { 0x0018, 0x7046, \"IS\", \"Grid Aspect Ratio\" },\n    { 0x0018, 0x7048, \"DS\", \"Grid Period\" },\n    { 0x0018, 0x704c, \"DS\", \"Grid Focal Distance\" },\n    { 0x0018, 0x7050, \"LT\", \"Filter Material\" },\n    { 0x0018, 0x7052, \"DS\", \"Filter Thickness Minimum\" },\n    { 0x0018, 0x7054, \"DS\", \"Filter Thickness Maximum\" },\n    { 0x0018, 0x7060, \"CS\", \"Exposure Control Mode\" },\n    { 0x0018, 0x7062, \"LT\", \"Exposure Control Mode Description\" },\n    { 0x0018, 0x7064, \"CS\", \"Exposure Status\" },\n    { 0x0018, 0x7065, \"DS\", \"Phototimer Setting\" },\n    { 0x0019, 0x0000, \"xs\", \"?\" },\n    { 0x0019, 0x0001, \"xs\", \"?\" },\n    { 0x0019, 0x0002, \"xs\", \"?\" },\n    { 0x0019, 0x0003, \"xs\", \"?\" },\n    { 0x0019, 0x0004, \"xs\", \"?\" },\n    { 0x0019, 0x0005, \"xs\", \"?\" },\n    { 0x0019, 0x0006, \"xs\", \"?\" },\n    { 0x0019, 0x0007, \"xs\", \"?\" },\n    { 0x0019, 0x0008, \"xs\", \"?\" },\n    { 0x0019, 0x0009, \"xs\", \"?\" },\n    { 0x0019, 0x000a, \"xs\", \"?\" },\n    { 0x0019, 0x000b, \"DS\", \"?\" },\n    { 0x0019, 0x000c, \"US\", \"?\" },\n    { 0x0019, 0x000d, \"TM\", \"Time\" },\n    { 0x0019, 0x000e, \"xs\", \"?\" },\n    { 0x0019, 0x000f, \"DS\", \"Horizontal Frame Of Reference\" },\n    { 0x0019, 0x0010, \"xs\", \"?\" },\n    { 0x0019, 0x0011, \"xs\", \"?\" },\n    { 0x0019, 0x0012, \"xs\", \"?\" },\n    { 0x0019, 0x0013, \"xs\", \"?\" },\n    { 0x0019, 0x0014, \"xs\", \"?\" },\n    { 0x0019, 0x0015, \"xs\", \"?\" },\n    { 0x0019, 0x0016, \"xs\", \"?\" },\n    { 0x0019, 0x0017, \"xs\", \"?\" },\n    { 0x0019, 0x0018, \"xs\", \"?\" },\n    { 0x0019, 0x0019, \"xs\", \"?\" },\n    { 0x0019, 0x001a, \"xs\", \"?\" },\n    { 0x0019, 0x001b, \"xs\", \"?\" },\n    { 0x0019, 0x001c, \"CS\", \"Dose\" },\n    { 0x0019, 0x001d, \"IS\", \"Side Mark\" },\n    { 0x0019, 0x001e, \"xs\", \"?\" },\n    { 0x0019, 0x001f, \"DS\", \"Exposure Duration\" },\n    { 0x0019, 0x0020, \"xs\", \"?\" },\n    { 0x0019, 0x0021, \"xs\", \"?\" },\n    { 0x0019, 0x0022, \"xs\", \"?\" },\n    { 0x0019, 0x0023, \"xs\", \"?\" },\n    { 0x0019, 0x0024, \"xs\", \"?\" },\n    { 0x0019, 0x0025, \"xs\", \"?\" },\n    { 0x0019, 0x0026, \"xs\", \"?\" },\n    { 0x0019, 0x0027, \"xs\", \"?\" },\n    { 0x0019, 0x0028, \"xs\", \"?\" },\n    { 0x0019, 0x0029, \"IS\", \"?\" },\n    { 0x0019, 0x002a, \"xs\", \"?\" },\n    { 0x0019, 0x002b, \"DS\", \"Xray Off Position\" },\n    { 0x0019, 0x002c, \"xs\", \"?\" },\n    { 0x0019, 0x002d, \"US\", \"?\" },\n    { 0x0019, 0x002e, \"xs\", \"?\" },\n    { 0x0019, 0x002f, \"DS\", \"Trigger Frequency\" },\n    { 0x0019, 0x0030, \"xs\", \"?\" },\n    { 0x0019, 0x0031, \"xs\", \"?\" },\n    { 0x0019, 0x0032, \"xs\", \"?\" },\n    { 0x0019, 0x0033, \"UN\", \"ECG 2 Offset 2\" },\n    { 0x0019, 0x0034, \"US\", \"?\" },\n    { 0x0019, 0x0036, \"US\", \"?\" },\n    { 0x0019, 0x0038, \"US\", \"?\" },\n    { 0x0019, 0x0039, \"xs\", \"?\" },\n    { 0x0019, 0x003a, \"xs\", \"?\" },\n    { 0x0019, 0x003b, \"LT\", \"?\" },\n    { 0x0019, 0x003c, \"xs\", \"?\" },\n    { 0x0019, 0x003e, \"xs\", \"?\" },\n    { 0x0019, 0x003f, \"UN\", \"?\" },\n    { 0x0019, 0x0040, \"xs\", \"?\" },\n    { 0x0019, 0x0041, \"xs\", \"?\" },\n    { 0x0019, 0x0042, \"xs\", \"?\" },\n    { 0x0019, 0x0043, \"xs\", \"?\" },\n    { 0x0019, 0x0044, \"xs\", \"?\" },\n    { 0x0019, 0x0045, \"xs\", \"?\" },\n    { 0x0019, 0x0046, \"xs\", \"?\" },\n    { 0x0019, 0x0047, \"xs\", \"?\" },\n    { 0x0019, 0x0048, \"xs\", \"?\" },\n    { 0x0019, 0x0049, \"US\", \"?\" },\n    { 0x0019, 0x004a, \"xs\", \"?\" },\n    { 0x0019, 0x004b, \"SL\", \"Data Size For Scan Data\" },\n    { 0x0019, 0x004c, \"US\", \"?\" },\n    { 0x0019, 0x004e, \"US\", \"?\" },\n    { 0x0019, 0x0050, \"xs\", \"?\" },\n    { 0x0019, 0x0051, \"xs\", \"?\" },\n    { 0x0019, 0x0052, \"xs\", \"?\" },\n    { 0x0019, 0x0053, \"LT\", \"Barcode\" },\n    { 0x0019, 0x0054, \"xs\", \"?\" },\n    { 0x0019, 0x0055, \"DS\", \"Receiver Reference Gain\" },\n    { 0x0019, 0x0056, \"xs\", \"?\" },\n    { 0x0019, 0x0057, \"SS\", \"CT Water Number\" },\n    { 0x0019, 0x0058, \"xs\", \"?\" },\n    { 0x0019, 0x005a, \"xs\", \"?\" },\n    { 0x0019, 0x005c, \"xs\", \"?\" },\n    { 0x0019, 0x005d, \"US\", \"?\" },\n    { 0x0019, 0x005e, \"xs\", \"?\" },\n    { 0x0019, 0x005f, \"SL\", \"Increment Between Channels\" },\n    { 0x0019, 0x0060, \"xs\", \"?\" },\n    { 0x0019, 0x0061, \"xs\", \"?\" },\n    { 0x0019, 0x0062, \"xs\", \"?\" },\n    { 0x0019, 0x0063, \"xs\", \"?\" },\n    { 0x0019, 0x0064, \"xs\", \"?\" },\n    { 0x0019, 0x0065, \"xs\", \"?\" },\n    { 0x0019, 0x0066, \"xs\", \"?\" },\n    { 0x0019, 0x0067, \"xs\", \"?\" },\n    { 0x0019, 0x0068, \"xs\", \"?\" },\n    { 0x0019, 0x0069, \"UL\", \"Convolution Mode\" },\n    { 0x0019, 0x006a, \"xs\", \"?\" },\n    { 0x0019, 0x006b, \"SS\", \"Field Of View In Detector Cells\" },\n    { 0x0019, 0x006c, \"US\", \"?\" },\n    { 0x0019, 0x006e, \"US\", \"?\" },\n    { 0x0019, 0x0070, \"xs\", \"?\" },\n    { 0x0019, 0x0071, \"xs\", \"?\" },\n    { 0x0019, 0x0072, \"xs\", \"?\" },\n    { 0x0019, 0x0073, \"xs\", \"?\" },\n    { 0x0019, 0x0074, \"xs\", \"?\" },\n    { 0x0019, 0x0075, \"xs\", \"?\" },\n    { 0x0019, 0x0076, \"xs\", \"?\" },\n    { 0x0019, 0x0077, \"US\", \"?\" },\n    { 0x0019, 0x0078, \"US\", \"?\" },\n    { 0x0019, 0x007a, \"US\", \"?\" },\n    { 0x0019, 0x007c, \"US\", \"?\" },\n    { 0x0019, 0x007d, \"DS\", \"Second Echo\" },\n    { 0x0019, 0x007e, \"xs\", \"?\" },\n    { 0x0019, 0x007f, \"DS\", \"Table Delta\" },\n    { 0x0019, 0x0080, \"xs\", \"?\" },\n    { 0x0019, 0x0081, \"xs\", \"?\" },\n    { 0x0019, 0x0082, \"xs\", \"?\" },\n    { 0x0019, 0x0083, \"xs\", \"?\" },\n    { 0x0019, 0x0084, \"xs\", \"?\" },\n    { 0x0019, 0x0085, \"xs\", \"?\" },\n    { 0x0019, 0x0086, \"xs\", \"?\" },\n    { 0x0019, 0x0087, \"xs\", \"?\" },\n    { 0x0019, 0x0088, \"xs\", \"?\" },\n    { 0x0019, 0x008a, \"xs\", \"?\" },\n    { 0x0019, 0x008b, \"SS\", \"Actual Receive Gain Digital\" },\n    { 0x0019, 0x008c, \"US\", \"?\" },\n    { 0x0019, 0x008d, \"DS\", \"Delay After Trigger\" },\n    { 0x0019, 0x008e, \"US\", \"?\" },\n    { 0x0019, 0x008f, \"SS\", \"Swap Phase Frequency\" },\n    { 0x0019, 0x0090, \"xs\", \"?\" },\n    { 0x0019, 0x0091, \"xs\", \"?\" },\n    { 0x0019, 0x0092, \"xs\", \"?\" },\n    { 0x0019, 0x0093, \"xs\", \"?\" },\n    { 0x0019, 0x0094, \"xs\", \"?\" },\n    { 0x0019, 0x0095, \"SS\", \"Analog Receiver Gain\" },\n    { 0x0019, 0x0096, \"xs\", \"?\" },\n    { 0x0019, 0x0097, \"xs\", \"?\" },\n    { 0x0019, 0x0098, \"xs\", \"?\" },\n    { 0x0019, 0x0099, \"US\", \"?\" },\n    { 0x0019, 0x009a, \"US\", \"?\" },\n    { 0x0019, 0x009b, \"SS\", \"Pulse Sequence Mode\" },\n    { 0x0019, 0x009c, \"xs\", \"?\" },\n    { 0x0019, 0x009d, \"DT\", \"Pulse Sequence Date\" },\n    { 0x0019, 0x009e, \"xs\", \"?\" },\n    { 0x0019, 0x009f, \"xs\", \"?\" },\n    { 0x0019, 0x00a0, \"xs\", \"?\" },\n    { 0x0019, 0x00a1, \"xs\", \"?\" },\n    { 0x0019, 0x00a2, \"xs\", \"?\" },\n    { 0x0019, 0x00a3, \"xs\", \"?\" },\n    { 0x0019, 0x00a4, \"xs\", \"?\" },\n    { 0x0019, 0x00a5, \"xs\", \"?\" },\n    { 0x0019, 0x00a6, \"xs\", \"?\" },\n    { 0x0019, 0x00a7, \"xs\", \"?\" },\n    { 0x0019, 0x00a8, \"xs\", \"?\" },\n    { 0x0019, 0x00a9, \"xs\", \"?\" },\n    { 0x0019, 0x00aa, \"xs\", \"?\" },\n    { 0x0019, 0x00ab, \"xs\", \"?\" },\n    { 0x0019, 0x00ac, \"xs\", \"?\" },\n    { 0x0019, 0x00ad, \"xs\", \"?\" },\n    { 0x0019, 0x00ae, \"xs\", \"?\" },\n    { 0x0019, 0x00af, \"xs\", \"?\" },\n    { 0x0019, 0x00b0, \"xs\", \"?\" },\n    { 0x0019, 0x00b1, \"xs\", \"?\" },\n    { 0x0019, 0x00b2, \"xs\", \"?\" },\n    { 0x0019, 0x00b3, \"xs\", \"?\" },\n    { 0x0019, 0x00b4, \"xs\", \"?\" },\n    { 0x0019, 0x00b5, \"xs\", \"?\" },\n    { 0x0019, 0x00b6, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b7, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b8, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b9, \"DS\", \"User Data\" },\n    { 0x0019, 0x00ba, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bb, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bc, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bd, \"DS\", \"User Data\" },\n    { 0x0019, 0x00be, \"DS\", \"Projection Angle\" },\n    { 0x0019, 0x00c0, \"xs\", \"?\" },\n    { 0x0019, 0x00c1, \"xs\", \"?\" },\n    { 0x0019, 0x00c2, \"xs\", \"?\" },\n    { 0x0019, 0x00c3, \"xs\", \"?\" },\n    { 0x0019, 0x00c4, \"xs\", \"?\" },\n    { 0x0019, 0x00c5, \"xs\", \"?\" },\n    { 0x0019, 0x00c6, \"SS\", \"SAT Location H\" },\n    { 0x0019, 0x00c7, \"SS\", \"SAT Location F\" },\n    { 0x0019, 0x00c8, \"SS\", \"SAT Thickness R L\" },\n    { 0x0019, 0x00c9, \"SS\", \"SAT Thickness A P\" },\n    { 0x0019, 0x00ca, \"SS\", \"SAT Thickness H F\" },\n    { 0x0019, 0x00cb, \"xs\", \"?\" },\n    { 0x0019, 0x00cc, \"xs\", \"?\" },\n    { 0x0019, 0x00cd, \"SS\", \"Thickness Disclaimer\" },\n    { 0x0019, 0x00ce, \"SS\", \"Prescan Type\" },\n    { 0x0019, 0x00cf, \"SS\", \"Prescan Status\" },\n    { 0x0019, 0x00d0, \"SH\", \"Raw Data Type\" },\n    { 0x0019, 0x00d1, \"DS\", \"Flow Sensitivity\" },\n    { 0x0019, 0x00d2, \"xs\", \"?\" },\n    { 0x0019, 0x00d3, \"xs\", \"?\" },\n    { 0x0019, 0x00d4, \"xs\", \"?\" },\n    { 0x0019, 0x00d5, \"xs\", \"?\" },\n    { 0x0019, 0x00d6, \"xs\", \"?\" },\n    { 0x0019, 0x00d7, \"xs\", \"?\" },\n    { 0x0019, 0x00d8, \"xs\", \"?\" },\n    { 0x0019, 0x00d9, \"xs\", \"?\" },\n    { 0x0019, 0x00da, \"xs\", \"?\" },\n    { 0x0019, 0x00db, \"DS\", \"Back Projector Coefficient\" },\n    { 0x0019, 0x00dc, \"SS\", \"Primary Speed Correction Used\" },\n    { 0x0019, 0x00dd, \"SS\", \"Overrange Correction Used\" },\n    { 0x0019, 0x00de, \"DS\", \"Dynamic Z Alpha Value\" },\n    { 0x0019, 0x00df, \"DS\", \"User Data\" },\n    { 0x0019, 0x00e0, \"DS\", \"User Data\" },\n    { 0x0019, 0x00e1, \"xs\", \"?\" },\n    { 0x0019, 0x00e2, \"xs\", \"?\" },\n    { 0x0019, 0x00e3, \"xs\", \"?\" },\n    { 0x0019, 0x00e4, \"LT\", \"?\" },\n    { 0x0019, 0x00e5, \"IS\", \"?\" },\n    { 0x0019, 0x00e6, \"US\", \"?\" },\n    { 0x0019, 0x00e8, \"DS\", \"?\" },\n    { 0x0019, 0x00e9, \"DS\", \"?\" },\n    { 0x0019, 0x00eb, \"DS\", \"?\" },\n    { 0x0019, 0x00ec, \"US\", \"?\" },\n    { 0x0019, 0x00f0, \"xs\", \"?\" },\n    { 0x0019, 0x00f1, \"xs\", \"?\" },\n    { 0x0019, 0x00f2, \"xs\", \"?\" },\n    { 0x0019, 0x00f3, \"xs\", \"?\" },\n    { 0x0019, 0x00f4, \"LT\", \"?\" },\n    { 0x0019, 0x00f9, \"DS\", \"Transmission Gain\" },\n    { 0x0019, 0x1015, \"UN\", \"?\" },\n    { 0x0020, 0x0000, \"UL\", \"Relationship Group Length\" },\n    { 0x0020, 0x000d, \"UI\", \"Study Instance UID\" },\n    { 0x0020, 0x000e, \"UI\", \"Series Instance UID\" },\n    { 0x0020, 0x0010, \"SH\", \"Study ID\" },\n    { 0x0020, 0x0011, \"IS\", \"Series Number\" },\n    { 0x0020, 0x0012, \"IS\", \"Acquisition Number\" },\n    { 0x0020, 0x0013, \"IS\", \"Instance (formerly Image) Number\" },\n    { 0x0020, 0x0014, \"IS\", \"Isotope Number\" },\n    { 0x0020, 0x0015, \"IS\", \"Phase Number\" },\n    { 0x0020, 0x0016, \"IS\", \"Interval Number\" },\n    { 0x0020, 0x0017, \"IS\", \"Time Slot Number\" },\n    { 0x0020, 0x0018, \"IS\", \"Angle Number\" },\n    { 0x0020, 0x0020, \"CS\", \"Patient Orientation\" },\n    { 0x0020, 0x0022, \"IS\", \"Overlay Number\" },\n    { 0x0020, 0x0024, \"IS\", \"Curve Number\" },\n    { 0x0020, 0x0026, \"IS\", \"LUT Number\" },\n    { 0x0020, 0x0030, \"DS\", \"Image Position\" },\n    { 0x0020, 0x0032, \"DS\", \"Image Position (Patient)\" },\n    { 0x0020, 0x0035, \"DS\", \"Image Orientation\" },\n    { 0x0020, 0x0037, \"DS\", \"Image Orientation (Patient)\" },\n    { 0x0020, 0x0050, \"DS\", \"Location\" },\n    { 0x0020, 0x0052, \"UI\", \"Frame of Reference UID\" },\n    { 0x0020, 0x0060, \"CS\", \"Laterality\" },\n    { 0x0020, 0x0062, \"CS\", \"Image Laterality\" },\n    { 0x0020, 0x0070, \"LT\", \"Image Geometry Type\" },\n    { 0x0020, 0x0080, \"LO\", \"Masking Image\" },\n    { 0x0020, 0x0100, \"IS\", \"Temporal Position Identifier\" },\n    { 0x0020, 0x0105, \"IS\", \"Number of Temporal Positions\" },\n    { 0x0020, 0x0110, \"DS\", \"Temporal Resolution\" },\n    { 0x0020, 0x1000, \"IS\", \"Series in Study\" },\n    { 0x0020, 0x1001, \"DS\", \"Acquisitions in Series\" },\n    { 0x0020, 0x1002, \"IS\", \"Images in Acquisition\" },\n    { 0x0020, 0x1003, \"IS\", \"Images in Series\" },\n    { 0x0020, 0x1004, \"IS\", \"Acquisitions in Study\" },\n    { 0x0020, 0x1005, \"IS\", \"Images in Study\" },\n    { 0x0020, 0x1020, \"LO\", \"Reference\" },\n    { 0x0020, 0x1040, \"LO\", \"Position Reference Indicator\" },\n    { 0x0020, 0x1041, \"DS\", \"Slice Location\" },\n    { 0x0020, 0x1070, \"IS\", \"Other Study Numbers\" },\n    { 0x0020, 0x1200, \"IS\", \"Number of Patient Related Studies\" },\n    { 0x0020, 0x1202, \"IS\", \"Number of Patient Related Series\" },\n    { 0x0020, 0x1204, \"IS\", \"Number of Patient Related Images\" },\n    { 0x0020, 0x1206, \"IS\", \"Number of Study Related Series\" },\n    { 0x0020, 0x1208, \"IS\", \"Number of Study Related Series\" },\n    { 0x0020, 0x3100, \"LO\", \"Source Image IDs\" },\n    { 0x0020, 0x3401, \"LO\", \"Modifying Device ID\" },\n    { 0x0020, 0x3402, \"LO\", \"Modified Image ID\" },\n    { 0x0020, 0x3403, \"xs\", \"Modified Image Date\" },\n    { 0x0020, 0x3404, \"LO\", \"Modifying Device Manufacturer\" },\n    { 0x0020, 0x3405, \"xs\", \"Modified Image Time\" },\n    { 0x0020, 0x3406, \"xs\", \"Modified Image Description\" },\n    { 0x0020, 0x4000, \"LT\", \"Image Comments\" },\n    { 0x0020, 0x5000, \"AT\", \"Original Image Identification\" },\n    { 0x0020, 0x5002, \"LO\", \"Original Image Identification Nomenclature\" },\n    { 0x0021, 0x0000, \"xs\", \"?\" },\n    { 0x0021, 0x0001, \"xs\", \"?\" },\n    { 0x0021, 0x0002, \"xs\", \"?\" },\n    { 0x0021, 0x0003, \"xs\", \"?\" },\n    { 0x0021, 0x0004, \"DS\", \"VOI Position\" },\n    { 0x0021, 0x0005, \"xs\", \"?\" },\n    { 0x0021, 0x0006, \"IS\", \"CSI Matrix Size Original\" },\n    { 0x0021, 0x0007, \"xs\", \"?\" },\n    { 0x0021, 0x0008, \"DS\", \"Spatial Grid Shift\" },\n    { 0x0021, 0x0009, \"DS\", \"Signal Limits Minimum\" },\n    { 0x0021, 0x0010, \"xs\", \"?\" },\n    { 0x0021, 0x0011, \"xs\", \"?\" },\n    { 0x0021, 0x0012, \"xs\", \"?\" },\n    { 0x0021, 0x0013, \"xs\", \"?\" },\n    { 0x0021, 0x0014, \"xs\", \"?\" },\n    { 0x0021, 0x0015, \"xs\", \"?\" },\n    { 0x0021, 0x0016, \"xs\", \"?\" },\n    { 0x0021, 0x0017, \"DS\", \"EPI Operation Mode Flag\" },\n    { 0x0021, 0x0018, \"xs\", \"?\" },\n    { 0x0021, 0x0019, \"xs\", \"?\" },\n    { 0x0021, 0x0020, \"xs\", \"?\" },\n    { 0x0021, 0x0021, \"xs\", \"?\" },\n    { 0x0021, 0x0022, \"xs\", \"?\" },\n    { 0x0021, 0x0024, \"xs\", \"?\" },\n    { 0x0021, 0x0025, \"US\", \"?\" },\n    { 0x0021, 0x0026, \"IS\", \"Image Pixel Offset\" },\n    { 0x0021, 0x0030, \"xs\", \"?\" },\n    { 0x0021, 0x0031, \"xs\", \"?\" },\n    { 0x0021, 0x0032, \"xs\", \"?\" },\n    { 0x0021, 0x0034, \"xs\", \"?\" },\n    { 0x0021, 0x0035, \"SS\", \"Series From Which Prescribed\" },\n    { 0x0021, 0x0036, \"xs\", \"?\" },\n    { 0x0021, 0x0037, \"SS\", \"Screen Format\" },\n    { 0x0021, 0x0039, \"DS\", \"Slab Thickness\" },\n    { 0x0021, 0x0040, \"xs\", \"?\" },\n    { 0x0021, 0x0041, \"xs\", \"?\" },\n    { 0x0021, 0x0042, \"xs\", \"?\" },\n    { 0x0021, 0x0043, \"xs\", \"?\" },\n    { 0x0021, 0x0044, \"xs\", \"?\" },\n    { 0x0021, 0x0045, \"xs\", \"?\" },\n    { 0x0021, 0x0046, \"xs\", \"?\" },\n    { 0x0021, 0x0047, \"xs\", \"?\" },\n    { 0x0021, 0x0048, \"xs\", \"?\" },\n    { 0x0021, 0x0049, \"xs\", \"?\" },\n    { 0x0021, 0x004a, \"xs\", \"?\" },\n    { 0x0021, 0x004e, \"US\", \"?\" },\n    { 0x0021, 0x004f, \"xs\", \"?\" },\n    { 0x0021, 0x0050, \"xs\", \"?\" },\n    { 0x0021, 0x0051, \"xs\", \"?\" },\n    { 0x0021, 0x0052, \"xs\", \"?\" },\n    { 0x0021, 0x0053, \"xs\", \"?\" },\n    { 0x0021, 0x0054, \"xs\", \"?\" },\n    { 0x0021, 0x0055, \"xs\", \"?\" },\n    { 0x0021, 0x0056, \"xs\", \"?\" },\n    { 0x0021, 0x0057, \"xs\", \"?\" },\n    { 0x0021, 0x0058, \"xs\", \"?\" },\n    { 0x0021, 0x0059, \"xs\", \"?\" },\n    { 0x0021, 0x005a, \"SL\", \"Integer Slop\" },\n    { 0x0021, 0x005b, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005c, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005d, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005e, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005f, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x0060, \"xs\", \"?\" },\n    { 0x0021, 0x0061, \"DS\", \"Image Normal\" },\n    { 0x0021, 0x0062, \"IS\", \"Reference Type Code\" },\n    { 0x0021, 0x0063, \"DS\", \"Image Distance\" },\n    { 0x0021, 0x0065, \"US\", \"Image Positioning History Mask\" },\n    { 0x0021, 0x006a, \"DS\", \"Image Row\" },\n    { 0x0021, 0x006b, \"DS\", \"Image Column\" },\n    { 0x0021, 0x0070, \"xs\", \"?\" },\n    { 0x0021, 0x0071, \"xs\", \"?\" },\n    { 0x0021, 0x0072, \"xs\", \"?\" },\n    { 0x0021, 0x0073, \"DS\", \"Second Repetition Time\" },\n    { 0x0021, 0x0075, \"DS\", \"Light Brightness\" },\n    { 0x0021, 0x0076, \"DS\", \"Light Contrast\" },\n    { 0x0021, 0x007a, \"IS\", \"Overlay Threshold\" },\n    { 0x0021, 0x007b, \"IS\", \"Surface Threshold\" },\n    { 0x0021, 0x007c, \"IS\", \"Grey Scale Threshold\" },\n    { 0x0021, 0x0080, \"xs\", \"?\" },\n    { 0x0021, 0x0081, \"DS\", \"Auto Window Level Alpha\" },\n    { 0x0021, 0x0082, \"xs\", \"?\" },\n    { 0x0021, 0x0083, \"DS\", \"Auto Window Level Window\" },\n    { 0x0021, 0x0084, \"DS\", \"Auto Window Level Level\" },\n    { 0x0021, 0x0090, \"xs\", \"?\" },\n    { 0x0021, 0x0091, \"xs\", \"?\" },\n    { 0x0021, 0x0092, \"xs\", \"?\" },\n    { 0x0021, 0x0093, \"xs\", \"?\" },\n    { 0x0021, 0x0094, \"DS\", \"EPI Change Value of X Component\" },\n    { 0x0021, 0x0095, \"DS\", \"EPI Change Value of Y Component\" },\n    { 0x0021, 0x0096, \"DS\", \"EPI Change Value of Z Component\" },\n    { 0x0021, 0x00a0, \"xs\", \"?\" },\n    { 0x0021, 0x00a1, \"DS\", \"?\" },\n    { 0x0021, 0x00a2, \"xs\", \"?\" },\n    { 0x0021, 0x00a3, \"LT\", \"?\" },\n    { 0x0021, 0x00a4, \"LT\", \"?\" },\n    { 0x0021, 0x00a7, \"LT\", \"?\" },\n    { 0x0021, 0x00b0, \"IS\", \"?\" },\n    { 0x0021, 0x00c0, \"IS\", \"?\" },\n    { 0x0023, 0x0000, \"xs\", \"?\" },\n    { 0x0023, 0x0001, \"SL\", \"Number Of Series In Study\" },\n    { 0x0023, 0x0002, \"SL\", \"Number Of Unarchived Series\" },\n    { 0x0023, 0x0010, \"xs\", \"?\" },\n    { 0x0023, 0x0020, \"xs\", \"?\" },\n    { 0x0023, 0x0030, \"xs\", \"?\" },\n    { 0x0023, 0x0040, \"xs\", \"?\" },\n    { 0x0023, 0x0050, \"xs\", \"?\" },\n    { 0x0023, 0x0060, \"xs\", \"?\" },\n    { 0x0023, 0x0070, \"xs\", \"?\" },\n    { 0x0023, 0x0074, \"SL\", \"Number Of Updates To Info\" },\n    { 0x0023, 0x007d, \"SS\", \"Indicates If Study Has Complete Info\" },\n    { 0x0023, 0x0080, \"xs\", \"?\" },\n    { 0x0023, 0x0090, \"xs\", \"?\" },\n    { 0x0023, 0x00ff, \"US\", \"?\" },\n    { 0x0025, 0x0000, \"UL\", \"Group Length\" },\n    { 0x0025, 0x0006, \"SS\", \"Last Pulse Sequence Used\" },\n    { 0x0025, 0x0007, \"SL\", \"Images In Series\" },\n    { 0x0025, 0x0010, \"SS\", \"Landmark Counter\" },\n    { 0x0025, 0x0011, \"SS\", \"Number Of Acquisitions\" },\n    { 0x0025, 0x0014, \"SL\", \"Indicates Number Of Updates To Info\" },\n    { 0x0025, 0x0017, \"SL\", \"Series Complete Flag\" },\n    { 0x0025, 0x0018, \"SL\", \"Number Of Images Archived\" },\n    { 0x0025, 0x0019, \"SL\", \"Last Image Number Used\" },\n    { 0x0025, 0x001a, \"SH\", \"Primary Receiver Suite And Host\" },\n    { 0x0027, 0x0000, \"US\", \"?\" },\n    { 0x0027, 0x0006, \"SL\", \"Image Archive Flag\" },\n    { 0x0027, 0x0010, \"SS\", \"Scout Type\" },\n    { 0x0027, 0x0011, \"UN\", \"?\" },\n    { 0x0027, 0x0012, \"IS\", \"?\" },\n    { 0x0027, 0x0013, \"IS\", \"?\" },\n    { 0x0027, 0x0014, \"IS\", \"?\" },\n    { 0x0027, 0x0015, \"IS\", \"?\" },\n    { 0x0027, 0x0016, \"LT\", \"?\" },\n    { 0x0027, 0x001c, \"SL\", \"Vma Mamp\" },\n    { 0x0027, 0x001d, \"SS\", \"Vma Phase\" },\n    { 0x0027, 0x001e, \"SL\", \"Vma Mod\" },\n    { 0x0027, 0x001f, \"SL\", \"Vma Clip\" },\n    { 0x0027, 0x0020, \"SS\", \"Smart Scan On Off Flag\" },\n    { 0x0027, 0x0030, \"SH\", \"Foreign Image Revision\" },\n    { 0x0027, 0x0031, \"SS\", \"Imaging Mode\" },\n    { 0x0027, 0x0032, \"SS\", \"Pulse Sequence\" },\n    { 0x0027, 0x0033, \"SL\", \"Imaging Options\" },\n    { 0x0027, 0x0035, \"SS\", \"Plane Type\" },\n    { 0x0027, 0x0036, \"SL\", \"Oblique Plane\" },\n    { 0x0027, 0x0040, \"SH\", \"RAS Letter Of Image Location\" },\n    { 0x0027, 0x0041, \"FL\", \"Image Location\" },\n    { 0x0027, 0x0042, \"FL\", \"Center R Coord Of Plane Image\" },\n    { 0x0027, 0x0043, \"FL\", \"Center A Coord Of Plane Image\" },\n    { 0x0027, 0x0044, \"FL\", \"Center S Coord Of Plane Image\" },\n    { 0x0027, 0x0045, \"FL\", \"Normal R Coord\" },\n    { 0x0027, 0x0046, \"FL\", \"Normal A Coord\" },\n    { 0x0027, 0x0047, \"FL\", \"Normal S Coord\" },\n    { 0x0027, 0x0048, \"FL\", \"R Coord Of Top Right Corner\" },\n    { 0x0027, 0x0049, \"FL\", \"A Coord Of Top Right Corner\" },\n    { 0x0027, 0x004a, \"FL\", \"S Coord Of Top Right Corner\" },\n    { 0x0027, 0x004b, \"FL\", \"R Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x004c, \"FL\", \"A Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x004d, \"FL\", \"S Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x0050, \"FL\", \"Table Start Location\" },\n    { 0x0027, 0x0051, \"FL\", \"Table End Location\" },\n    { 0x0027, 0x0052, \"SH\", \"RAS Letter For Side Of Image\" },\n    { 0x0027, 0x0053, \"SH\", \"RAS Letter For Anterior Posterior\" },\n    { 0x0027, 0x0054, \"SH\", \"RAS Letter For Scout Start Loc\" },\n    { 0x0027, 0x0055, \"SH\", \"RAS Letter For Scout End Loc\" },\n    { 0x0027, 0x0060, \"FL\", \"Image Dimension X\" },\n    { 0x0027, 0x0061, \"FL\", \"Image Dimension Y\" },\n    { 0x0027, 0x0062, \"FL\", \"Number Of Excitations\" },\n    { 0x0028, 0x0000, \"UL\", \"Image Presentation Group Length\" },\n    { 0x0028, 0x0002, \"US\", \"Samples per Pixel\" },\n    { 0x0028, 0x0004, \"CS\", \"Photometric Interpretation\" },\n    { 0x0028, 0x0005, \"US\", \"Image Dimensions\" },\n    { 0x0028, 0x0006, \"US\", \"Planar Configuration\" },\n    { 0x0028, 0x0008, \"IS\", \"Number of Frames\" },\n    { 0x0028, 0x0009, \"AT\", \"Frame Increment Pointer\" },\n    { 0x0028, 0x0010, \"US\", \"Rows\" },\n    { 0x0028, 0x0011, \"US\", \"Columns\" },\n    { 0x0028, 0x0012, \"US\", \"Planes\" },\n    { 0x0028, 0x0014, \"US\", \"Ultrasound Color Data Present\" },\n    { 0x0028, 0x0030, \"DS\", \"Pixel Spacing\" },\n    { 0x0028, 0x0031, \"DS\", \"Zoom Factor\" },\n    { 0x0028, 0x0032, \"DS\", \"Zoom Center\" },\n    { 0x0028, 0x0034, \"IS\", \"Pixel Aspect Ratio\" },\n    { 0x0028, 0x0040, \"LO\", \"Image Format\" },\n    { 0x0028, 0x0050, \"LT\", \"Manipulated Image\" },\n    { 0x0028, 0x0051, \"CS\", \"Corrected Image\" },\n    { 0x0028, 0x005f, \"LO\", \"Compression Recognition Code\" },\n    { 0x0028, 0x0060, \"LO\", \"Compression Code\" },\n    { 0x0028, 0x0061, \"SH\", \"Compression Originator\" },\n    { 0x0028, 0x0062, \"SH\", \"Compression Label\" },\n    { 0x0028, 0x0063, \"SH\", \"Compression Description\" },\n    { 0x0028, 0x0065, \"LO\", \"Compression Sequence\" },\n    { 0x0028, 0x0066, \"AT\", \"Compression Step Pointers\" },\n    { 0x0028, 0x0068, \"US\", \"Repeat Interval\" },\n    { 0x0028, 0x0069, \"US\", \"Bits Grouped\" },\n    { 0x0028, 0x0070, \"US\", \"Perimeter Table\" },\n    { 0x0028, 0x0071, \"xs\", \"Perimeter Value\" },\n    { 0x0028, 0x0080, \"US\", \"Predictor Rows\" },\n    { 0x0028, 0x0081, \"US\", \"Predictor Columns\" },\n    { 0x0028, 0x0082, \"US\", \"Predictor Constants\" },\n    { 0x0028, 0x0090, \"LO\", \"Blocked Pixels\" },\n    { 0x0028, 0x0091, \"US\", \"Block Rows\" },\n    { 0x0028, 0x0092, \"US\", \"Block Columns\" },\n    { 0x0028, 0x0093, \"US\", \"Row Overlap\" },\n    { 0x0028, 0x0094, \"US\", \"Column Overlap\" },\n    { 0x0028, 0x0100, \"US\", \"Bits Allocated\" },\n    { 0x0028, 0x0101, \"US\", \"Bits Stored\" },\n    { 0x0028, 0x0102, \"US\", \"High Bit\" },\n    { 0x0028, 0x0103, \"US\", \"Pixel Representation\" },\n    { 0x0028, 0x0104, \"xs\", \"Smallest Valid Pixel Value\" },\n    { 0x0028, 0x0105, \"xs\", \"Largest Valid Pixel Value\" },\n    { 0x0028, 0x0106, \"xs\", \"Smallest Image Pixel Value\" },\n    { 0x0028, 0x0107, \"xs\", \"Largest Image Pixel Value\" },\n    { 0x0028, 0x0108, \"xs\", \"Smallest Pixel Value in Series\" },\n    { 0x0028, 0x0109, \"xs\", \"Largest Pixel Value in Series\" },\n    { 0x0028, 0x0110, \"xs\", \"Smallest Pixel Value in Plane\" },\n    { 0x0028, 0x0111, \"xs\", \"Largest Pixel Value in Plane\" },\n    { 0x0028, 0x0120, \"xs\", \"Pixel Padding Value\" },\n    { 0x0028, 0x0200, \"xs\", \"Image Location\" },\n    { 0x0028, 0x0300, \"CS\", \"Quality Control Image\" },\n    { 0x0028, 0x0301, \"CS\", \"Burned In Annotation\" },\n    { 0x0028, 0x0400, \"xs\", \"?\" },\n    { 0x0028, 0x0401, \"xs\", \"?\" },\n    { 0x0028, 0x0402, \"xs\", \"?\" },\n    { 0x0028, 0x0403, \"xs\", \"?\" },\n    { 0x0028, 0x0404, \"AT\", \"Details of Coefficients\" },\n    { 0x0028, 0x0700, \"LO\", \"DCT Label\" },\n    { 0x0028, 0x0701, \"LO\", \"Data Block Description\" },\n    { 0x0028, 0x0702, \"AT\", \"Data Block\" },\n    { 0x0028, 0x0710, \"US\", \"Normalization Factor Format\" },\n    { 0x0028, 0x0720, \"US\", \"Zonal Map Number Format\" },\n    { 0x0028, 0x0721, \"AT\", \"Zonal Map Location\" },\n    { 0x0028, 0x0722, \"US\", \"Zonal Map Format\" },\n    { 0x0028, 0x0730, \"US\", \"Adaptive Map Format\" },\n    { 0x0028, 0x0740, \"US\", \"Code Number Format\" },\n    { 0x0028, 0x0800, \"LO\", \"Code Label\" },\n    { 0x0028, 0x0802, \"US\", \"Number of Tables\" },\n    { 0x0028, 0x0803, \"AT\", \"Code Table Location\" },\n    { 0x0028, 0x0804, \"US\", \"Bits For Code Word\" },\n    { 0x0028, 0x0808, \"AT\", \"Image Data Location\" },\n    { 0x0028, 0x1040, \"CS\", \"Pixel Intensity Relationship\" },\n    { 0x0028, 0x1041, \"SS\", \"Pixel Intensity Relationship Sign\" },\n    { 0x0028, 0x1050, \"DS\", \"Window Center\" },\n    { 0x0028, 0x1051, \"DS\", \"Window Width\" },\n    { 0x0028, 0x1052, \"DS\", \"Rescale Intercept\" },\n    { 0x0028, 0x1053, \"DS\", \"Rescale Slope\" },\n    { 0x0028, 0x1054, \"LO\", \"Rescale Type\" },\n    { 0x0028, 0x1055, \"LO\", \"Window Center & Width Explanation\" },\n    { 0x0028, 0x1080, \"LO\", \"Gray Scale\" },\n    { 0x0028, 0x1090, \"CS\", \"Recommended Viewing Mode\" },\n    { 0x0028, 0x1100, \"xs\", \"Gray Lookup Table Descriptor\" },\n    { 0x0028, 0x1101, \"xs\", \"Red Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1102, \"xs\", \"Green Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1103, \"xs\", \"Blue Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1111, \"OW\", \"Large Red Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1112, \"OW\", \"Large Green Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1113, \"OW\", \"Large Blue Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1199, \"UI\", \"Palette Color Lookup Table UID\" },\n    { 0x0028, 0x1200, \"xs\", \"Gray Lookup Table Data\" },\n    { 0x0028, 0x1201, \"OW\", \"Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1202, \"OW\", \"Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1203, \"OW\", \"Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1211, \"OW\", \"Large Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1212, \"OW\", \"Large Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1213, \"OW\", \"Large Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1214, \"UI\", \"Large Palette Color Lookup Table UID\" },\n    { 0x0028, 0x1221, \"OW\", \"Segmented Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1222, \"OW\", \"Segmented Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1223, \"OW\", \"Segmented Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1300, \"CS\", \"Implant Present\" },\n    { 0x0028, 0x2110, \"CS\", \"Lossy Image Compression\" },\n    { 0x0028, 0x2112, \"DS\", \"Lossy Image Compression Ratio\" },\n    { 0x0028, 0x3000, \"SQ\", \"Modality LUT Sequence\" },\n    { 0x0028, 0x3002, \"US\", \"LUT Descriptor\" },\n    { 0x0028, 0x3003, \"LO\", \"LUT Explanation\" },\n    { 0x0028, 0x3004, \"LO\", \"Modality LUT Type\" },\n    { 0x0028, 0x3006, \"US\", \"LUT Data\" },\n    { 0x0028, 0x3010, \"xs\", \"VOI LUT Sequence\" },\n    { 0x0028, 0x4000, \"LT\", \"Image Presentation Comments\" },\n    { 0x0028, 0x5000, \"SQ\", \"Biplane Acquisition Sequence\" },\n    { 0x0028, 0x6010, \"US\", \"Representative Frame Number\" },\n    { 0x0028, 0x6020, \"US\", \"Frame Numbers of Interest\" },\n    { 0x0028, 0x6022, \"LO\", \"Frame of Interest Description\" },\n    { 0x0028, 0x6030, \"US\", \"Mask Pointer\" },\n    { 0x0028, 0x6040, \"US\", \"R Wave Pointer\" },\n    { 0x0028, 0x6100, \"SQ\", \"Mask Subtraction Sequence\" },\n    { 0x0028, 0x6101, \"CS\", \"Mask Operation\" },\n    { 0x0028, 0x6102, \"US\", \"Applicable Frame Range\" },\n    { 0x0028, 0x6110, \"US\", \"Mask Frame Numbers\" },\n    { 0x0028, 0x6112, \"US\", \"Contrast Frame Averaging\" },\n    { 0x0028, 0x6114, \"FL\", \"Mask Sub-Pixel Shift\" },\n    { 0x0028, 0x6120, \"SS\", \"TID Offset\" },\n    { 0x0028, 0x6190, \"ST\", \"Mask Operation Explanation\" },\n    { 0x0029, 0x0000, \"xs\", \"?\" },\n    { 0x0029, 0x0001, \"xs\", \"?\" },\n    { 0x0029, 0x0002, \"xs\", \"?\" },\n    { 0x0029, 0x0003, \"xs\", \"?\" },\n    { 0x0029, 0x0004, \"xs\", \"?\" },\n    { 0x0029, 0x0005, \"xs\", \"?\" },\n    { 0x0029, 0x0006, \"xs\", \"?\" },\n    { 0x0029, 0x0007, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0008, \"SH\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0009, \"SH\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x000a, \"SS\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x000c, \"xs\", \"?\" },\n    { 0x0029, 0x000e, \"CS\", \"Zoom Enable Status\" },\n    { 0x0029, 0x000f, \"CS\", \"Zoom Select Status\" },\n    { 0x0029, 0x0010, \"xs\", \"?\" },\n    { 0x0029, 0x0011, \"xs\", \"?\" },\n    { 0x0029, 0x0013, \"LT\", \"?\" },\n    { 0x0029, 0x0015, \"xs\", \"?\" },\n    { 0x0029, 0x0016, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0017, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0018, \"SL\", \"Upper Range Of Pixels\" },\n    { 0x0029, 0x001a, \"SL\", \"Length Of Total Info In Bytes\" },\n    { 0x0029, 0x001e, \"xs\", \"?\" },\n    { 0x0029, 0x001f, \"xs\", \"?\" },\n    { 0x0029, 0x0020, \"xs\", \"?\" },\n    { 0x0029, 0x0022, \"IS\", \"Pixel Quality Value\" },\n    { 0x0029, 0x0025, \"LT\", \"Processed Pixel Data Quality\" },\n    { 0x0029, 0x0026, \"SS\", \"Version Of Info Structure\" },\n    { 0x0029, 0x0030, \"xs\", \"?\" },\n    { 0x0029, 0x0031, \"xs\", \"?\" },\n    { 0x0029, 0x0032, \"xs\", \"?\" },\n    { 0x0029, 0x0033, \"xs\", \"?\" },\n    { 0x0029, 0x0034, \"xs\", \"?\" },\n    { 0x0029, 0x0035, \"SL\", \"Advantage Comp Underflow\" },\n    { 0x0029, 0x0038, \"US\", \"?\" },\n    { 0x0029, 0x0040, \"xs\", \"?\" },\n    { 0x0029, 0x0041, \"DS\", \"Magnifying Glass Rectangle\" },\n    { 0x0029, 0x0043, \"DS\", \"Magnifying Glass Factor\" },\n    { 0x0029, 0x0044, \"US\", \"Magnifying Glass Function\" },\n    { 0x0029, 0x004e, \"CS\", \"Magnifying Glass Enable Status\" },\n    { 0x0029, 0x004f, \"CS\", \"Magnifying Glass Select Status\" },\n    { 0x0029, 0x0050, \"xs\", \"?\" },\n    { 0x0029, 0x0051, \"LT\", \"Exposure Code\" },\n    { 0x0029, 0x0052, \"LT\", \"Sort Code\" },\n    { 0x0029, 0x0053, \"LT\", \"?\" },\n    { 0x0029, 0x0060, \"xs\", \"?\" },\n    { 0x0029, 0x0061, \"xs\", \"?\" },\n    { 0x0029, 0x0067, \"LT\", \"?\" },\n    { 0x0029, 0x0070, \"xs\", \"?\" },\n    { 0x0029, 0x0071, \"xs\", \"?\" },\n    { 0x0029, 0x0072, \"xs\", \"?\" },\n    { 0x0029, 0x0077, \"CS\", \"Window Select Status\" },\n    { 0x0029, 0x0078, \"LT\", \"ECG Display Printing ID\" },\n    { 0x0029, 0x0079, \"CS\", \"ECG Display Printing\" },\n    { 0x0029, 0x007e, \"CS\", \"ECG Display Printing Enable Status\" },\n    { 0x0029, 0x007f, \"CS\", \"ECG Display Printing Select Status\" },\n    { 0x0029, 0x0080, \"xs\", \"?\" },\n    { 0x0029, 0x0081, \"xs\", \"?\" },\n    { 0x0029, 0x0082, \"IS\", \"View Zoom\" },\n    { 0x0029, 0x0083, \"IS\", \"View Transform\" },\n    { 0x0029, 0x008e, \"CS\", \"Physiological Display Enable Status\" },\n    { 0x0029, 0x008f, \"CS\", \"Physiological Display Select Status\" },\n    { 0x0029, 0x0090, \"IS\", \"?\" },\n    { 0x0029, 0x0099, \"LT\", \"Shutter Type\" },\n    { 0x0029, 0x00a0, \"US\", \"Rows of Rectangular Shutter\" },\n    { 0x0029, 0x00a1, \"US\", \"Columns of Rectangular Shutter\" },\n    { 0x0029, 0x00a2, \"US\", \"Origin of Rectangular Shutter\" },\n    { 0x0029, 0x00b0, \"US\", \"Radius of Circular Shutter\" },\n    { 0x0029, 0x00b2, \"US\", \"Origin of Circular Shutter\" },\n    { 0x0029, 0x00c0, \"LT\", \"Functional Shutter ID\" },\n    { 0x0029, 0x00c1, \"xs\", \"?\" },\n    { 0x0029, 0x00c3, \"IS\", \"Scan Resolution\" },\n    { 0x0029, 0x00c4, \"IS\", \"Field of View\" },\n    { 0x0029, 0x00c5, \"LT\", \"Field Of Shutter Rectangle\" },\n    { 0x0029, 0x00ce, \"CS\", \"Shutter Enable Status\" },\n    { 0x0029, 0x00cf, \"CS\", \"Shutter Select Status\" },\n    { 0x0029, 0x00d0, \"IS\", \"?\" },\n    { 0x0029, 0x00d1, \"IS\", \"?\" },\n    { 0x0029, 0x00d5, \"LT\", \"Slice Thickness\" },\n    { 0x0031, 0x0010, \"LT\", \"Request UID\" },\n    { 0x0031, 0x0012, \"LT\", \"Examination Reason\" },\n    { 0x0031, 0x0030, \"DA\", \"Requested Date\" },\n    { 0x0031, 0x0032, \"TM\", \"Worklist Request Start Time\" },\n    { 0x0031, 0x0033, \"TM\", \"Worklist Request End Time\" },\n    { 0x0031, 0x0045, \"LT\", \"Requesting Physician\" },\n    { 0x0031, 0x004a, \"TM\", \"Requested Time\" },\n    { 0x0031, 0x0050, \"LT\", \"Requested Physician\" },\n    { 0x0031, 0x0080, \"LT\", \"Requested Location\" },\n    { 0x0032, 0x0000, \"UL\", \"Study Group Length\" },\n    { 0x0032, 0x000a, \"CS\", \"Study Status ID\" },\n    { 0x0032, 0x000c, \"CS\", \"Study Priority ID\" },\n    { 0x0032, 0x0012, \"LO\", \"Study ID Issuer\" },\n    { 0x0032, 0x0032, \"DA\", \"Study Verified Date\" },\n    { 0x0032, 0x0033, \"TM\", \"Study Verified Time\" },\n    { 0x0032, 0x0034, \"DA\", \"Study Read Date\" },\n    { 0x0032, 0x0035, \"TM\", \"Study Read Time\" },\n    { 0x0032, 0x1000, \"DA\", \"Scheduled Study Start Date\" },\n    { 0x0032, 0x1001, \"TM\", \"Scheduled Study Start Time\" },\n    { 0x0032, 0x1010, \"DA\", \"Scheduled Study Stop Date\" },\n    { 0x0032, 0x1011, \"TM\", \"Scheduled Study Stop Time\" },\n    { 0x0032, 0x1020, \"LO\", \"Scheduled Study Location\" },\n    { 0x0032, 0x1021, \"AE\", \"Scheduled Study Location AE Title(s)\" },\n    { 0x0032, 0x1030, \"LO\", \"Reason for Study\" },\n    { 0x0032, 0x1032, \"PN\", \"Requesting Physician\" },\n    { 0x0032, 0x1033, \"LO\", \"Requesting Service\" },\n    { 0x0032, 0x1040, \"DA\", \"Study Arrival Date\" },\n    { 0x0032, 0x1041, \"TM\", \"Study Arrival Time\" },\n    { 0x0032, 0x1050, \"DA\", \"Study Completion Date\" },\n    { 0x0032, 0x1051, \"TM\", \"Study Completion Time\" },\n    { 0x0032, 0x1055, \"CS\", \"Study Component Status ID\" },\n    { 0x0032, 0x1060, \"LO\", \"Requested Procedure Description\" },\n    { 0x0032, 0x1064, \"SQ\", \"Requested Procedure Code Sequence\" },\n    { 0x0032, 0x1070, \"LO\", \"Requested Contrast Agent\" },\n    { 0x0032, 0x4000, \"LT\", \"Study Comments\" },\n    { 0x0033, 0x0001, \"UN\", \"?\" },\n    { 0x0033, 0x0002, \"UN\", \"?\" },\n    { 0x0033, 0x0005, \"UN\", \"?\" },\n    { 0x0033, 0x0006, \"UN\", \"?\" },\n    { 0x0033, 0x0010, \"LT\", \"Patient Study UID\" },\n    { 0x0037, 0x0010, \"LO\", \"ReferringDepartment\" },\n    { 0x0037, 0x0020, \"US\", \"ScreenNumber\" },\n    { 0x0037, 0x0040, \"SH\", \"LeftOrientation\" },\n    { 0x0037, 0x0042, \"SH\", \"RightOrientation\" },\n    { 0x0037, 0x0050, \"CS\", \"Inversion\" },\n    { 0x0037, 0x0060, \"US\", \"DSA\" },\n    { 0x0038, 0x0000, \"UL\", \"Visit Group Length\" },\n    { 0x0038, 0x0004, \"SQ\", \"Referenced Patient Alias Sequence\" },\n    { 0x0038, 0x0008, \"CS\", \"Visit Status ID\" },\n    { 0x0038, 0x0010, \"LO\", \"Admission ID\" },\n    { 0x0038, 0x0011, \"LO\", \"Issuer of Admission ID\" },\n    { 0x0038, 0x0016, \"LO\", \"Route of Admissions\" },\n    { 0x0038, 0x001a, \"DA\", \"Scheduled Admission Date\" },\n    { 0x0038, 0x001b, \"TM\", \"Scheduled Admission Time\" },\n    { 0x0038, 0x001c, \"DA\", \"Scheduled Discharge Date\" },\n    { 0x0038, 0x001d, \"TM\", \"Scheduled Discharge Time\" },\n    { 0x0038, 0x001e, \"LO\", \"Scheduled Patient Institution Residence\" },\n    { 0x0038, 0x0020, \"DA\", \"Admitting Date\" },\n    { 0x0038, 0x0021, \"TM\", \"Admitting Time\" },\n    { 0x0038, 0x0030, \"DA\", \"Discharge Date\" },\n    { 0x0038, 0x0032, \"TM\", \"Discharge Time\" },\n    { 0x0038, 0x0040, \"LO\", \"Discharge Diagnosis Description\" },\n    { 0x0038, 0x0044, \"SQ\", \"Discharge Diagnosis Code Sequence\" },\n    { 0x0038, 0x0050, \"LO\", \"Special Needs\" },\n    { 0x0038, 0x0300, \"LO\", \"Current Patient Location\" },\n    { 0x0038, 0x0400, \"LO\", \"Patient's Institution Residence\" },\n    { 0x0038, 0x0500, \"LO\", \"Patient State\" },\n    { 0x0038, 0x4000, \"LT\", \"Visit Comments\" },\n    { 0x0039, 0x0080, \"IS\", \"Private Entity Number\" },\n    { 0x0039, 0x0085, \"DA\", \"Private Entity Date\" },\n    { 0x0039, 0x0090, \"TM\", \"Private Entity Time\" },\n    { 0x0039, 0x0095, \"LO\", \"Private Entity Launch Command\" },\n    { 0x0039, 0x00aa, \"CS\", \"Private Entity Type\" },\n    { 0x003a, 0x0002, \"SQ\", \"Waveform Sequence\" },\n    { 0x003a, 0x0005, \"US\", \"Waveform Number of Channels\" },\n    { 0x003a, 0x0010, \"UL\", \"Waveform Number of Samples\" },\n    { 0x003a, 0x001a, \"DS\", \"Sampling Frequency\" },\n    { 0x003a, 0x0020, \"SH\", \"Group Label\" },\n    { 0x003a, 0x0103, \"CS\", \"Waveform Sample Value Representation\" },\n    { 0x003a, 0x0122, \"OB\", \"Waveform Padding Value\" },\n    { 0x003a, 0x0200, \"SQ\", \"Channel Definition\" },\n    { 0x003a, 0x0202, \"IS\", \"Waveform Channel Number\" },\n    { 0x003a, 0x0203, \"SH\", \"Channel Label\" },\n    { 0x003a, 0x0205, \"CS\", \"Channel Status\" },\n    { 0x003a, 0x0208, \"SQ\", \"Channel Source\" },\n    { 0x003a, 0x0209, \"SQ\", \"Channel Source Modifiers\" },\n    { 0x003a, 0x020a, \"SQ\", \"Differential Channel Source\" },\n    { 0x003a, 0x020b, \"SQ\", \"Differential Channel Source Modifiers\" },\n    { 0x003a, 0x0210, \"DS\", \"Channel Sensitivity\" },\n    { 0x003a, 0x0211, \"SQ\", \"Channel Sensitivity Units\" },\n    { 0x003a, 0x0212, \"DS\", \"Channel Sensitivity Correction Factor\" },\n    { 0x003a, 0x0213, \"DS\", \"Channel Baseline\" },\n    { 0x003a, 0x0214, \"DS\", \"Channel Time Skew\" },\n    { 0x003a, 0x0215, \"DS\", \"Channel Sample Skew\" },\n    { 0x003a, 0x0216, \"OB\", \"Channel Minimum Value\" },\n    { 0x003a, 0x0217, \"OB\", \"Channel Maximum Value\" },\n    { 0x003a, 0x0218, \"DS\", \"Channel Offset\" },\n    { 0x003a, 0x021a, \"US\", \"Bits Per Sample\" },\n    { 0x003a, 0x0220, \"DS\", \"Filter Low Frequency\" },\n    { 0x003a, 0x0221, \"DS\", \"Filter High Frequency\" },\n    { 0x003a, 0x0222, \"DS\", \"Notch Filter Frequency\" },\n    { 0x003a, 0x0223, \"DS\", \"Notch Filter Bandwidth\" },\n    { 0x003a, 0x1000, \"OB\", \"Waveform Data\" },\n    { 0x0040, 0x0001, \"AE\", \"Scheduled Station AE Title\" },\n    { 0x0040, 0x0002, \"DA\", \"Scheduled Procedure Step Start Date\" },\n    { 0x0040, 0x0003, \"TM\", \"Scheduled Procedure Step Start Time\" },\n    { 0x0040, 0x0004, \"DA\", \"Scheduled Procedure Step End Date\" },\n    { 0x0040, 0x0005, \"TM\", \"Scheduled Procedure Step End Time\" },\n    { 0x0040, 0x0006, \"PN\", \"Scheduled Performing Physician Name\" },\n    { 0x0040, 0x0007, \"LO\", \"Scheduled Procedure Step Description\" },\n    { 0x0040, 0x0008, \"SQ\", \"Scheduled Action Item Code Sequence\" },\n    { 0x0040, 0x0009, \"SH\", \"Scheduled Procedure Step ID\" },\n    { 0x0040, 0x0010, \"SH\", \"Scheduled Station Name\" },\n    { 0x0040, 0x0011, \"SH\", \"Scheduled Procedure Step Location\" },\n    { 0x0040, 0x0012, \"LO\", \"Pre-Medication\" },\n    { 0x0040, 0x0020, \"CS\", \"Scheduled Procedure Step Status\" },\n    { 0x0040, 0x0100, \"SQ\", \"Scheduled Procedure Step Sequence\" },\n    { 0x0040, 0x0302, \"US\", \"Entrance Dose\" },\n    { 0x0040, 0x0303, \"US\", \"Exposed Area\" },\n    { 0x0040, 0x0306, \"DS\", \"Distance Source to Entrance\" },\n    { 0x0040, 0x0307, \"DS\", \"Distance Source to Support\" },\n    { 0x0040, 0x0310, \"ST\", \"Comments On Radiation Dose\" },\n    { 0x0040, 0x0312, \"DS\", \"X-Ray Output\" },\n    { 0x0040, 0x0314, \"DS\", \"Half Value Layer\" },\n    { 0x0040, 0x0316, \"DS\", \"Organ Dose\" },\n    { 0x0040, 0x0318, \"CS\", \"Organ Exposed\" },\n    { 0x0040, 0x0400, \"LT\", \"Comments On Scheduled Procedure Step\" },\n    { 0x0040, 0x050a, \"LO\", \"Specimen Accession Number\" },\n    { 0x0040, 0x0550, \"SQ\", \"Specimen Sequence\" },\n    { 0x0040, 0x0551, \"LO\", \"Specimen Identifier\" },\n    { 0x0040, 0x0552, \"SQ\", \"Specimen Description Sequence\" },\n    { 0x0040, 0x0553, \"ST\", \"Specimen Description\" },\n    { 0x0040, 0x0555, \"SQ\", \"Acquisition Context Sequence\" },\n    { 0x0040, 0x0556, \"ST\", \"Acquisition Context Description\" },\n    { 0x0040, 0x059a, \"SQ\", \"Specimen Type Code Sequence\" },\n    { 0x0040, 0x06fa, \"LO\", \"Slide Identifier\" },\n    { 0x0040, 0x071a, \"SQ\", \"Image Center Point Coordinates Sequence\" },\n    { 0x0040, 0x072a, \"DS\", \"X Offset In Slide Coordinate System\" },\n    { 0x0040, 0x073a, \"DS\", \"Y Offset In Slide Coordinate System\" },\n    { 0x0040, 0x074a, \"DS\", \"Z Offset In Slide Coordinate System\" },\n    { 0x0040, 0x08d8, \"SQ\", \"Pixel Spacing Sequence\" },\n    { 0x0040, 0x08da, \"SQ\", \"Coordinate System Axis Code Sequence\" },\n    { 0x0040, 0x08ea, \"SQ\", \"Measurement Units Code Sequence\" },\n    { 0x0040, 0x09f8, \"SQ\", \"Vital Stain Code Sequence\" },\n    { 0x0040, 0x1001, \"SH\", \"Requested Procedure ID\" },\n    { 0x0040, 0x1002, \"LO\", \"Reason For Requested Procedure\" },\n    { 0x0040, 0x1003, \"SH\", \"Requested Procedure Priority\" },\n    { 0x0040, 0x1004, \"LO\", \"Patient Transport Arrangements\" },\n    { 0x0040, 0x1005, \"LO\", \"Requested Procedure Location\" },\n    { 0x0040, 0x1006, \"SH\", \"Placer Order Number of Procedure\" },\n    { 0x0040, 0x1007, \"SH\", \"Filler Order Number of Procedure\" },\n    { 0x0040, 0x1008, \"LO\", \"Confidentiality Code\" },\n    { 0x0040, 0x1009, \"SH\", \"Reporting Priority\" },\n    { 0x0040, 0x1010, \"PN\", \"Names of Intended Recipients of Results\" },\n    { 0x0040, 0x1400, \"LT\", \"Requested Procedure Comments\" },\n    { 0x0040, 0x2001, \"LO\", \"Reason For Imaging Service Request\" },\n    { 0x0040, 0x2004, \"DA\", \"Issue Date of Imaging Service Request\" },\n    { 0x0040, 0x2005, \"TM\", \"Issue Time of Imaging Service Request\" },\n    { 0x0040, 0x2006, \"SH\", \"Placer Order Number of Imaging Service Request\" },\n    { 0x0040, 0x2007, \"SH\", \"Filler Order Number of Imaging Service Request\" },\n    { 0x0040, 0x2008, \"PN\", \"Order Entered By\" },\n    { 0x0040, 0x2009, \"SH\", \"Order Enterer Location\" },\n    { 0x0040, 0x2010, \"SH\", \"Order Callback Phone Number\" },\n    { 0x0040, 0x2400, \"LT\", \"Imaging Service Request Comments\" },\n    { 0x0040, 0x3001, \"LO\", \"Confidentiality Constraint On Patient Data\" },\n    { 0x0040, 0xa007, \"CS\", \"Findings Flag\" },\n    { 0x0040, 0xa020, \"SQ\", \"Findings Sequence\" },\n    { 0x0040, 0xa021, \"UI\", \"Findings Group UID\" },\n    { 0x0040, 0xa022, \"UI\", \"Referenced Findings Group UID\" },\n    { 0x0040, 0xa023, \"DA\", \"Findings Group Recording Date\" },\n    { 0x0040, 0xa024, \"TM\", \"Findings Group Recording Time\" },\n    { 0x0040, 0xa026, \"SQ\", \"Findings Source Category Code Sequence\" },\n    { 0x0040, 0xa027, \"LO\", \"Documenting Organization\" },\n    { 0x0040, 0xa028, \"SQ\", \"Documenting Organization Identifier Code Sequence\" },\n    { 0x0040, 0xa032, \"LO\", \"History Reliability Qualifier Description\" },\n    { 0x0040, 0xa043, \"SQ\", \"Concept Name Code Sequence\" },\n    { 0x0040, 0xa047, \"LO\", \"Measurement Precision Description\" },\n    { 0x0040, 0xa057, \"CS\", \"Urgency or Priority Alerts\" },\n    { 0x0040, 0xa060, \"LO\", \"Sequencing Indicator\" },\n    { 0x0040, 0xa066, \"SQ\", \"Document Identifier Code Sequence\" },\n    { 0x0040, 0xa067, \"PN\", \"Document Author\" },\n    { 0x0040, 0xa068, \"SQ\", \"Document Author Identifier Code Sequence\" },\n    { 0x0040, 0xa070, \"SQ\", \"Identifier Code Sequence\" },\n    { 0x0040, 0xa073, \"LO\", \"Object String Identifier\" },\n    { 0x0040, 0xa074, \"OB\", \"Object Binary Identifier\" },\n    { 0x0040, 0xa075, \"PN\", \"Documenting Observer\" },\n    { 0x0040, 0xa076, \"SQ\", \"Documenting Observer Identifier Code Sequence\" },\n    { 0x0040, 0xa078, \"SQ\", \"Observation Subject Identifier Code Sequence\" },\n    { 0x0040, 0xa080, \"SQ\", \"Person Identifier Code Sequence\" },\n    { 0x0040, 0xa085, \"SQ\", \"Procedure Identifier Code Sequence\" },\n    { 0x0040, 0xa088, \"LO\", \"Object Directory String Identifier\" },\n    { 0x0040, 0xa089, \"OB\", \"Object Directory Binary Identifier\" },\n    { 0x0040, 0xa090, \"CS\", \"History Reliability Qualifier\" },\n    { 0x0040, 0xa0a0, \"CS\", \"Referenced Type of Data\" },\n    { 0x0040, 0xa0b0, \"US\", \"Referenced Waveform Channels\" },\n    { 0x0040, 0xa110, \"DA\", \"Date of Document or Verbal Transaction\" },\n    { 0x0040, 0xa112, \"TM\", \"Time of Document Creation or Verbal Transaction\" },\n    { 0x0040, 0xa121, \"DA\", \"Date\" },\n    { 0x0040, 0xa122, \"TM\", \"Time\" },\n    { 0x0040, 0xa123, \"PN\", \"Person Name\" },\n    { 0x0040, 0xa124, \"SQ\", \"Referenced Person Sequence\" },\n    { 0x0040, 0xa125, \"CS\", \"Report Status ID\" },\n    { 0x0040, 0xa130, \"CS\", \"Temporal Range Type\" },\n    { 0x0040, 0xa132, \"UL\", \"Referenced Sample Offsets\" },\n    { 0x0040, 0xa136, \"US\", \"Referenced Frame Numbers\" },\n    { 0x0040, 0xa138, \"DS\", \"Referenced Time Offsets\" },\n    { 0x0040, 0xa13a, \"DT\", \"Referenced Datetime\" },\n    { 0x0040, 0xa160, \"UT\", \"Text Value\" },\n    { 0x0040, 0xa167, \"SQ\", \"Observation Category Code Sequence\" },\n    { 0x0040, 0xa168, \"SQ\", \"Concept Code Sequence\" },\n    { 0x0040, 0xa16a, \"ST\", \"Bibliographic Citation\" },\n    { 0x0040, 0xa170, \"CS\", \"Observation Class\" },\n    { 0x0040, 0xa171, \"UI\", \"Observation UID\" },\n    { 0x0040, 0xa172, \"UI\", \"Referenced Observation UID\" },\n    { 0x0040, 0xa173, \"CS\", \"Referenced Observation Class\" },\n    { 0x0040, 0xa174, \"CS\", \"Referenced Object Observation Class\" },\n    { 0x0040, 0xa180, \"US\", \"Annotation Group Number\" },\n    { 0x0040, 0xa192, \"DA\", \"Observation Date\" },\n    { 0x0040, 0xa193, \"TM\", \"Observation Time\" },\n    { 0x0040, 0xa194, \"CS\", \"Measurement Automation\" },\n    { 0x0040, 0xa195, \"SQ\", \"Concept Name Code Sequence Modifier\" },\n    { 0x0040, 0xa224, \"ST\", \"Identification Description\" },\n    { 0x0040, 0xa290, \"CS\", \"Coordinates Set Geometric Type\" },\n    { 0x0040, 0xa296, \"SQ\", \"Algorithm Code Sequence\" },\n    { 0x0040, 0xa297, \"ST\", \"Algorithm Description\" },\n    { 0x0040, 0xa29a, \"SL\", \"Pixel Coordinates Set\" },\n    { 0x0040, 0xa300, \"SQ\", \"Measured Value Sequence\" },\n    { 0x0040, 0xa307, \"PN\", \"Current Observer\" },\n    { 0x0040, 0xa30a, \"DS\", \"Numeric Value\" },\n    { 0x0040, 0xa313, \"SQ\", \"Referenced Accession Sequence\" },\n    { 0x0040, 0xa33a, \"ST\", \"Report Status Comment\" },\n    { 0x0040, 0xa340, \"SQ\", \"Procedure Context Sequence\" },\n    { 0x0040, 0xa352, \"PN\", \"Verbal Source\" },\n    { 0x0040, 0xa353, \"ST\", \"Address\" },\n    { 0x0040, 0xa354, \"LO\", \"Telephone Number\" },\n    { 0x0040, 0xa358, \"SQ\", \"Verbal Source Identifier Code Sequence\" },\n    { 0x0040, 0xa380, \"SQ\", \"Report Detail Sequence\" },\n    { 0x0040, 0xa402, \"UI\", \"Observation Subject UID\" },\n    { 0x0040, 0xa403, \"CS\", \"Observation Subject Class\" },\n    { 0x0040, 0xa404, \"SQ\", \"Observation Subject Type Code Sequence\" },\n    { 0x0040, 0xa600, \"CS\", \"Observation Subject Context Flag\" },\n    { 0x0040, 0xa601, \"CS\", \"Observer Context Flag\" },\n    { 0x0040, 0xa603, \"CS\", \"Procedure Context Flag\" },\n    { 0x0040, 0xa730, \"SQ\", \"Observations Sequence\" },\n    { 0x0040, 0xa731, \"SQ\", \"Relationship Sequence\" },\n    { 0x0040, 0xa732, \"SQ\", \"Relationship Type Code Sequence\" },\n    { 0x0040, 0xa744, \"SQ\", \"Language Code Sequence\" },\n    { 0x0040, 0xa992, \"ST\", \"Uniform Resource Locator\" },\n    { 0x0040, 0xb020, \"SQ\", \"Annotation Sequence\" },\n    { 0x0040, 0xdb73, \"SQ\", \"Relationship Type Code Sequence Modifier\" },\n    { 0x0041, 0x0000, \"LT\", \"Papyrus Comments\" },\n    { 0x0041, 0x0010, \"xs\", \"?\" },\n    { 0x0041, 0x0011, \"xs\", \"?\" },\n    { 0x0041, 0x0012, \"UL\", \"Pixel Offset\" },\n    { 0x0041, 0x0013, \"SQ\", \"Image Identifier Sequence\" },\n    { 0x0041, 0x0014, \"SQ\", \"External File Reference Sequence\" },\n    { 0x0041, 0x0015, \"US\", \"Number of Images\" },\n    { 0x0041, 0x0020, \"xs\", \"?\" },\n    { 0x0041, 0x0021, \"UI\", \"Referenced SOP Class UID\" },\n    { 0x0041, 0x0022, \"UI\", \"Referenced SOP Instance UID\" },\n    { 0x0041, 0x0030, \"xs\", \"?\" },\n    { 0x0041, 0x0031, \"xs\", \"?\" },\n    { 0x0041, 0x0032, \"xs\", \"?\" },\n    { 0x0041, 0x0034, \"DA\", \"Modified Date\" },\n    { 0x0041, 0x0036, \"TM\", \"Modified Time\" },\n    { 0x0041, 0x0040, \"LT\", \"Owner Name\" },\n    { 0x0041, 0x0041, \"UI\", \"Referenced Image SOP Class UID\" },\n    { 0x0041, 0x0042, \"UI\", \"Referenced Image SOP Instance UID\" },\n    { 0x0041, 0x0050, \"xs\", \"?\" },\n    { 0x0041, 0x0060, \"UL\", \"Number of Images\" },\n    { 0x0041, 0x0062, \"UL\", \"Number of Other\" },\n    { 0x0041, 0x00a0, \"LT\", \"External Folder Element DSID\" },\n    { 0x0041, 0x00a1, \"US\", \"External Folder Element Data Set Type\" },\n    { 0x0041, 0x00a2, \"LT\", \"External Folder Element File Location\" },\n    { 0x0041, 0x00a3, \"UL\", \"External Folder Element Length\" },\n    { 0x0041, 0x00b0, \"LT\", \"Internal Folder Element DSID\" },\n    { 0x0041, 0x00b1, \"US\", \"Internal Folder Element Data Set Type\" },\n    { 0x0041, 0x00b2, \"UL\", \"Internal Offset To Data Set\" },\n    { 0x0041, 0x00b3, \"UL\", \"Internal Offset To Image\" },\n    { 0x0043, 0x0001, \"SS\", \"Bitmap Of Prescan Options\" },\n    { 0x0043, 0x0002, \"SS\", \"Gradient Offset In X\" },\n    { 0x0043, 0x0003, \"SS\", \"Gradient Offset In Y\" },\n    { 0x0043, 0x0004, \"SS\", \"Gradient Offset In Z\" },\n    { 0x0043, 0x0005, \"SS\", \"Image Is Original Or Unoriginal\" },\n    { 0x0043, 0x0006, \"SS\", \"Number Of EPI Shots\" },\n    { 0x0043, 0x0007, \"SS\", \"Views Per Segment\" },\n    { 0x0043, 0x0008, \"SS\", \"Respiratory Rate In BPM\" },\n    { 0x0043, 0x0009, \"SS\", \"Respiratory Trigger Point\" },\n    { 0x0043, 0x000a, \"SS\", \"Type Of Receiver Used\" },\n    { 0x0043, 0x000b, \"DS\", \"Peak Rate Of Change Of Gradient Field\" },\n    { 0x0043, 0x000c, \"DS\", \"Limits In Units Of Percent\" },\n    { 0x0043, 0x000d, \"DS\", \"PSD Estimated Limit\" },\n    { 0x0043, 0x000e, \"DS\", \"PSD Estimated Limit In Tesla Per Second\" },\n    { 0x0043, 0x000f, \"DS\", \"SAR Avg Head\" },\n    { 0x0043, 0x0010, \"US\", \"Window Value\" },\n    { 0x0043, 0x0011, \"US\", \"Total Input Views\" },\n    { 0x0043, 0x0012, \"SS\", \"Xray Chain\" },\n    { 0x0043, 0x0013, \"SS\", \"Recon Kernel Parameters\" },\n    { 0x0043, 0x0014, \"SS\", \"Calibration Parameters\" },\n    { 0x0043, 0x0015, \"SS\", \"Total Output Views\" },\n    { 0x0043, 0x0016, \"SS\", \"Number Of Overranges\" },\n    { 0x0043, 0x0017, \"DS\", \"IBH Image Scale Factors\" },\n    { 0x0043, 0x0018, \"DS\", \"BBH Coefficients\" },\n    { 0x0043, 0x0019, \"SS\", \"Number Of BBH Chains To Blend\" },\n    { 0x0043, 0x001a, \"SL\", \"Starting Channel Number\" },\n    { 0x0043, 0x001b, \"SS\", \"PPScan Parameters\" },\n    { 0x0043, 0x001c, \"SS\", \"GE Image Integrity\" },\n    { 0x0043, 0x001d, \"SS\", \"Level Value\" },\n    { 0x0043, 0x001e, \"xs\", \"?\" },\n    { 0x0043, 0x001f, \"SL\", \"Max Overranges In A View\" },\n    { 0x0043, 0x0020, \"DS\", \"Avg Overranges All Views\" },\n    { 0x0043, 0x0021, \"SS\", \"Corrected Afterglow Terms\" },\n    { 0x0043, 0x0025, \"SS\", \"Reference Channels\" },\n    { 0x0043, 0x0026, \"US\", \"No Views Ref Channels Blocked\" },\n    { 0x0043, 0x0027, \"xs\", \"?\" },\n    { 0x0043, 0x0028, \"OB\", \"Unique Image Identifier\" },\n    { 0x0043, 0x0029, \"OB\", \"Histogram Tables\" },\n    { 0x0043, 0x002a, \"OB\", \"User Defined Data\" },\n    { 0x0043, 0x002b, \"SS\", \"Private Scan Options\" },\n    { 0x0043, 0x002c, \"SS\", \"Effective Echo Spacing\" },\n    { 0x0043, 0x002d, \"SH\", \"String Slop Field 1\" },\n    { 0x0043, 0x002e, \"SH\", \"String Slop Field 2\" },\n    { 0x0043, 0x002f, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0030, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0031, \"DS\", \"RA Coord Of Target Recon Centre\" },\n    { 0x0043, 0x0032, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0033, \"FL\", \"Neg Scan Spacing\" },\n    { 0x0043, 0x0034, \"IS\", \"Offset Frequency\" },\n    { 0x0043, 0x0035, \"UL\", \"User Usage Tag\" },\n    { 0x0043, 0x0036, \"UL\", \"User Fill Map MSW\" },\n    { 0x0043, 0x0037, \"UL\", \"User Fill Map LSW\" },\n    { 0x0043, 0x0038, \"FL\", \"User 25 To User 48\" },\n    { 0x0043, 0x0039, \"IS\", \"Slop Integer 6 To Slop Integer 9\" },\n    { 0x0043, 0x0040, \"FL\", \"Trigger On Position\" },\n    { 0x0043, 0x0041, \"FL\", \"Degree Of Rotation\" },\n    { 0x0043, 0x0042, \"SL\", \"DAS Trigger Source\" },\n    { 0x0043, 0x0043, \"SL\", \"DAS Fpa Gain\" },\n    { 0x0043, 0x0044, \"SL\", \"DAS Output Source\" },\n    { 0x0043, 0x0045, \"SL\", \"DAS Ad Input\" },\n    { 0x0043, 0x0046, \"SL\", \"DAS Cal Mode\" },\n    { 0x0043, 0x0047, \"SL\", \"DAS Cal Frequency\" },\n    { 0x0043, 0x0048, \"SL\", \"DAS Reg Xm\" },\n    { 0x0043, 0x0049, \"SL\", \"DAS Auto Zero\" },\n    { 0x0043, 0x004a, \"SS\", \"Starting Channel Of View\" },\n    { 0x0043, 0x004b, \"SL\", \"DAS Xm Pattern\" },\n    { 0x0043, 0x004c, \"SS\", \"TGGC Trigger Mode\" },\n    { 0x0043, 0x004d, \"FL\", \"Start Scan To Xray On Delay\" },\n    { 0x0043, 0x004e, \"FL\", \"Duration Of Xray On\" },\n    { 0x0044, 0x0000, \"UI\", \"?\" },\n    { 0x0045, 0x0004, \"CS\", \"AES\" },\n    { 0x0045, 0x0006, \"DS\", \"Angulation\" },\n    { 0x0045, 0x0009, \"DS\", \"Real Magnification Factor\" },\n    { 0x0045, 0x000b, \"CS\", \"Senograph Type\" },\n    { 0x0045, 0x000c, \"DS\", \"Integration Time\" },\n    { 0x0045, 0x000d, \"DS\", \"ROI Origin X and Y\" },\n    { 0x0045, 0x0011, \"DS\", \"Receptor Size cm X and Y\" },\n    { 0x0045, 0x0012, \"IS\", \"Receptor Size Pixels X and Y\" },\n    { 0x0045, 0x0013, \"ST\", \"Screen\" },\n    { 0x0045, 0x0014, \"DS\", \"Pixel Pitch Microns\" },\n    { 0x0045, 0x0015, \"IS\", \"Pixel Depth Bits\" },\n    { 0x0045, 0x0016, \"IS\", \"Binning Factor X and Y\" },\n    { 0x0045, 0x001b, \"CS\", \"Clinical View\" },\n    { 0x0045, 0x001d, \"DS\", \"Mean Of Raw Gray Levels\" },\n    { 0x0045, 0x001e, \"DS\", \"Mean Of Offset Gray Levels\" },\n    { 0x0045, 0x001f, \"DS\", \"Mean Of Corrected Gray Levels\" },\n    { 0x0045, 0x0020, \"DS\", \"Mean Of Region Gray Levels\" },\n    { 0x0045, 0x0021, \"DS\", \"Mean Of Log Region Gray Levels\" },\n    { 0x0045, 0x0022, \"DS\", \"Standard Deviation Of Raw Gray Levels\" },\n    { 0x0045, 0x0023, \"DS\", \"Standard Deviation Of Corrected Gray Levels\" },\n    { 0x0045, 0x0024, \"DS\", \"Standard Deviation Of Region Gray Levels\" },\n    { 0x0045, 0x0025, \"DS\", \"Standard Deviation Of Log Region Gray Levels\" },\n    { 0x0045, 0x0026, \"OB\", \"MAO Buffer\" },\n    { 0x0045, 0x0027, \"IS\", \"Set Number\" },\n    { 0x0045, 0x0028, \"CS\", \"WindowingType (LINEAR or GAMMA)\" },\n    { 0x0045, 0x0029, \"DS\", \"WindowingParameters\" },\n    { 0x0045, 0x002a, \"IS\", \"Crosshair Cursor X Coordinates\" },\n    { 0x0045, 0x002b, \"IS\", \"Crosshair Cursor Y Coordinates\" },\n    { 0x0045, 0x0039, \"US\", \"Vignette Rows\" },\n    { 0x0045, 0x003a, \"US\", \"Vignette Columns\" },\n    { 0x0045, 0x003b, \"US\", \"Vignette Bits Allocated\" },\n    { 0x0045, 0x003c, \"US\", \"Vignette Bits Stored\" },\n    { 0x0045, 0x003d, \"US\", \"Vignette High Bit\" },\n    { 0x0045, 0x003e, \"US\", \"Vignette Pixel Representation\" },\n    { 0x0045, 0x003f, \"OB\", \"Vignette Pixel Data\" },\n    { 0x0047, 0x0001, \"SQ\", \"Reconstruction Parameters Sequence\" },\n    { 0x0047, 0x0050, \"UL\", \"Volume Voxel Count\" },\n    { 0x0047, 0x0051, \"UL\", \"Volume Segment Count\" },\n    { 0x0047, 0x0053, \"US\", \"Volume Slice Size\" },\n    { 0x0047, 0x0054, \"US\", \"Volume Slice Count\" },\n    { 0x0047, 0x0055, \"SL\", \"Volume Threshold Value\" },\n    { 0x0047, 0x0057, \"DS\", \"Volume Voxel Ratio\" },\n    { 0x0047, 0x0058, \"DS\", \"Volume Voxel Size\" },\n    { 0x0047, 0x0059, \"US\", \"Volume Z Position Size\" },\n    { 0x0047, 0x0060, \"DS\", \"Volume Base Line\" },\n    { 0x0047, 0x0061, \"DS\", \"Volume Center Point\" },\n    { 0x0047, 0x0063, \"SL\", \"Volume Skew Base\" },\n    { 0x0047, 0x0064, \"DS\", \"Volume Registration Transform Rotation Matrix\" },\n    { 0x0047, 0x0065, \"DS\", \"Volume Registration Transform Translation Vector\" },\n    { 0x0047, 0x0070, \"DS\", \"KVP List\" },\n    { 0x0047, 0x0071, \"IS\", \"XRay Tube Current List\" },\n    { 0x0047, 0x0072, \"IS\", \"Exposure List\" },\n    { 0x0047, 0x0080, \"LO\", \"Acquisition DLX Identifier\" },\n    { 0x0047, 0x0085, \"SQ\", \"Acquisition DLX 2D Series Sequence\" },\n    { 0x0047, 0x0089, \"DS\", \"Contrast Agent Volume List\" },\n    { 0x0047, 0x008a, \"US\", \"Number Of Injections\" },\n    { 0x0047, 0x008b, \"US\", \"Frame Count\" },\n    { 0x0047, 0x0096, \"IS\", \"Used Frames\" },\n    { 0x0047, 0x0091, \"LO\", \"XA 3D Reconstruction Algorithm Name\" },\n    { 0x0047, 0x0092, \"CS\", \"XA 3D Reconstruction Algorithm Version\" },\n    { 0x0047, 0x0093, \"DA\", \"DLX Calibration Date\" },\n    { 0x0047, 0x0094, \"TM\", \"DLX Calibration Time\" },\n    { 0x0047, 0x0095, \"CS\", \"DLX Calibration Status\" },\n    { 0x0047, 0x0098, \"US\", \"Transform Count\" },\n    { 0x0047, 0x0099, \"SQ\", \"Transform Sequence\" },\n    { 0x0047, 0x009a, \"DS\", \"Transform Rotation Matrix\" },\n    { 0x0047, 0x009b, \"DS\", \"Transform Translation Vector\" },\n    { 0x0047, 0x009c, \"LO\", \"Transform Label\" },\n    { 0x0047, 0x00b1, \"US\", \"Wireframe Count\" },\n    { 0x0047, 0x00b2, \"US\", \"Location System\" },\n    { 0x0047, 0x00b0, \"SQ\", \"Wireframe List\" },\n    { 0x0047, 0x00b5, \"LO\", \"Wireframe Name\" },\n    { 0x0047, 0x00b6, \"LO\", \"Wireframe Group Name\" },\n    { 0x0047, 0x00b7, \"LO\", \"Wireframe Color\" },\n    { 0x0047, 0x00b8, \"SL\", \"Wireframe Attributes\" },\n    { 0x0047, 0x00b9, \"SL\", \"Wireframe Point Count\" },\n    { 0x0047, 0x00ba, \"SL\", \"Wireframe Timestamp\" },\n    { 0x0047, 0x00bb, \"SQ\", \"Wireframe Point List\" },\n    { 0x0047, 0x00bc, \"DS\", \"Wireframe Points Coordinates\" },\n    { 0x0047, 0x00c0, \"DS\", \"Volume Upper Left High Corner RAS\" },\n    { 0x0047, 0x00c1, \"DS\", \"Volume Slice To RAS Rotation Matrix\" },\n    { 0x0047, 0x00c2, \"DS\", \"Volume Upper Left High Corner TLOC\" },\n    { 0x0047, 0x00d1, \"OB\", \"Volume Segment List\" },\n    { 0x0047, 0x00d2, \"OB\", \"Volume Gradient List\" },\n    { 0x0047, 0x00d3, \"OB\", \"Volume Density List\" },\n    { 0x0047, 0x00d4, \"OB\", \"Volume Z Position List\" },\n    { 0x0047, 0x00d5, \"OB\", \"Volume Original Index List\" },\n    { 0x0050, 0x0000, \"UL\", \"Calibration Group Length\" },\n    { 0x0050, 0x0004, \"CS\", \"Calibration Object\" },\n    { 0x0050, 0x0010, \"SQ\", \"DeviceSequence\" },\n    { 0x0050, 0x0014, \"DS\", \"DeviceLength\" },\n    { 0x0050, 0x0016, \"DS\", \"DeviceDiameter\" },\n    { 0x0050, 0x0017, \"CS\", \"DeviceDiameterUnits\" },\n    { 0x0050, 0x0018, \"DS\", \"DeviceVolume\" },\n    { 0x0050, 0x0019, \"DS\", \"InterMarkerDistance\" },\n    { 0x0050, 0x0020, \"LO\", \"DeviceDescription\" },\n    { 0x0050, 0x0030, \"SQ\", \"CodedInterventionDeviceSequence\" },\n    { 0x0051, 0x0010, \"xs\", \"Image Text\" },\n    { 0x0054, 0x0000, \"UL\", \"Nuclear Acquisition Group Length\" },\n    { 0x0054, 0x0010, \"US\", \"Energy Window Vector\" },\n    { 0x0054, 0x0011, \"US\", \"Number of Energy Windows\" },\n    { 0x0054, 0x0012, \"SQ\", \"Energy Window Information Sequence\" },\n    { 0x0054, 0x0013, \"SQ\", \"Energy Window Range Sequence\" },\n    { 0x0054, 0x0014, \"DS\", \"Energy Window Lower Limit\" },\n    { 0x0054, 0x0015, \"DS\", \"Energy Window Upper Limit\" },\n    { 0x0054, 0x0016, \"SQ\", \"Radiopharmaceutical Information Sequence\" },\n    { 0x0054, 0x0017, \"IS\", \"Residual Syringe Counts\" },\n    { 0x0054, 0x0018, \"SH\", \"Energy Window Name\" },\n    { 0x0054, 0x0020, \"US\", \"Detector Vector\" },\n    { 0x0054, 0x0021, \"US\", \"Number of Detectors\" },\n    { 0x0054, 0x0022, \"SQ\", \"Detector Information Sequence\" },\n    { 0x0054, 0x0030, \"US\", \"Phase Vector\" },\n    { 0x0054, 0x0031, \"US\", \"Number of Phases\" },\n    { 0x0054, 0x0032, \"SQ\", \"Phase Information Sequence\" },\n    { 0x0054, 0x0033, \"US\", \"Number of Frames In Phase\" },\n    { 0x0054, 0x0036, \"IS\", \"Phase Delay\" },\n    { 0x0054, 0x0038, \"IS\", \"Pause Between Frames\" },\n    { 0x0054, 0x0050, \"US\", \"Rotation Vector\" },\n    { 0x0054, 0x0051, \"US\", \"Number of Rotations\" },\n    { 0x0054, 0x0052, \"SQ\", \"Rotation Information Sequence\" },\n    { 0x0054, 0x0053, \"US\", \"Number of Frames In Rotation\" },\n    { 0x0054, 0x0060, \"US\", \"R-R Interval Vector\" },\n    { 0x0054, 0x0061, \"US\", \"Number of R-R Intervals\" },\n    { 0x0054, 0x0062, \"SQ\", \"Gated Information Sequence\" },\n    { 0x0054, 0x0063, \"SQ\", \"Data Information Sequence\" },\n    { 0x0054, 0x0070, \"US\", \"Time Slot Vector\" },\n    { 0x0054, 0x0071, \"US\", \"Number of Time Slots\" },\n    { 0x0054, 0x0072, \"SQ\", \"Time Slot Information Sequence\" },\n    { 0x0054, 0x0073, \"DS\", \"Time Slot Time\" },\n    { 0x0054, 0x0080, \"US\", \"Slice Vector\" },\n    { 0x0054, 0x0081, \"US\", \"Number of Slices\" },\n    { 0x0054, 0x0090, \"US\", \"Angular View Vector\" },\n    { 0x0054, 0x0100, \"US\", \"Time Slice Vector\" },\n    { 0x0054, 0x0101, \"US\", \"Number Of Time Slices\" },\n    { 0x0054, 0x0200, \"DS\", \"Start Angle\" },\n    { 0x0054, 0x0202, \"CS\", \"Type of Detector Motion\" },\n    { 0x0054, 0x0210, \"IS\", \"Trigger Vector\" },\n    { 0x0054, 0x0211, \"US\", \"Number of Triggers in Phase\" },\n    { 0x0054, 0x0220, \"SQ\", \"View Code Sequence\" },\n    { 0x0054, 0x0222, \"SQ\", \"View Modifier Code Sequence\" },\n    { 0x0054, 0x0300, \"SQ\", \"Radionuclide Code Sequence\" },\n    { 0x0054, 0x0302, \"SQ\", \"Radiopharmaceutical Route Code Sequence\" },\n    { 0x0054, 0x0304, \"SQ\", \"Radiopharmaceutical Code Sequence\" },\n    { 0x0054, 0x0306, \"SQ\", \"Calibration Data Sequence\" },\n    { 0x0054, 0x0308, \"US\", \"Energy Window Number\" },\n    { 0x0054, 0x0400, \"SH\", \"Image ID\" },\n    { 0x0054, 0x0410, \"SQ\", \"Patient Orientation Code Sequence\" },\n    { 0x0054, 0x0412, \"SQ\", \"Patient Orientation Modifier Code Sequence\" },\n    { 0x0054, 0x0414, \"SQ\", \"Patient Gantry Relationship Code Sequence\" },\n    { 0x0054, 0x1000, \"CS\", \"Positron Emission Tomography Series Type\" },\n    { 0x0054, 0x1001, \"CS\", \"Positron Emission Tomography Units\" },\n    { 0x0054, 0x1002, \"CS\", \"Counts Source\" },\n    { 0x0054, 0x1004, \"CS\", \"Reprojection Method\" },\n    { 0x0054, 0x1100, \"CS\", \"Randoms Correction Method\" },\n    { 0x0054, 0x1101, \"LO\", \"Attenuation Correction Method\" },\n    { 0x0054, 0x1102, \"CS\", \"Decay Correction\" },\n    { 0x0054, 0x1103, \"LO\", \"Reconstruction Method\" },\n    { 0x0054, 0x1104, \"LO\", \"Detector Lines of Response Used\" },\n    { 0x0054, 0x1105, \"LO\", \"Scatter Correction Method\" },\n    { 0x0054, 0x1200, \"DS\", \"Axial Acceptance\" },\n    { 0x0054, 0x1201, \"IS\", \"Axial Mash\" },\n    { 0x0054, 0x1202, \"IS\", \"Transverse Mash\" },\n    { 0x0054, 0x1203, \"DS\", \"Detector Element Size\" },\n    { 0x0054, 0x1210, \"DS\", \"Coincidence Window Width\" },\n    { 0x0054, 0x1220, \"CS\", \"Secondary Counts Type\" },\n    { 0x0054, 0x1300, \"DS\", \"Frame Reference Time\" },\n    { 0x0054, 0x1310, \"IS\", \"Primary Prompts Counts Accumulated\" },\n    { 0x0054, 0x1311, \"IS\", \"Secondary Counts Accumulated\" },\n    { 0x0054, 0x1320, \"DS\", \"Slice Sensitivity Factor\" },\n    { 0x0054, 0x1321, \"DS\", \"Decay Factor\" },\n    { 0x0054, 0x1322, \"DS\", \"Dose Calibration Factor\" },\n    { 0x0054, 0x1323, \"DS\", \"Scatter Fraction Factor\" },\n    { 0x0054, 0x1324, \"DS\", \"Dead Time Factor\" },\n    { 0x0054, 0x1330, \"US\", \"Image Index\" },\n    { 0x0054, 0x1400, \"CS\", \"Counts Included\" },\n    { 0x0054, 0x1401, \"CS\", \"Dead Time Correction Flag\" },\n    { 0x0055, 0x0046, \"LT\", \"Current Ward\" },\n    { 0x0058, 0x0000, \"SQ\", \"?\" },\n    { 0x0060, 0x3000, \"SQ\", \"Histogram Sequence\" },\n    { 0x0060, 0x3002, \"US\", \"Histogram Number of Bins\" },\n    { 0x0060, 0x3004, \"xs\", \"Histogram First Bin Value\" },\n    { 0x0060, 0x3006, \"xs\", \"Histogram Last Bin Value\" },\n    { 0x0060, 0x3008, \"US\", \"Histogram Bin Width\" },\n    { 0x0060, 0x3010, \"LO\", \"Histogram Explanation\" },\n    { 0x0060, 0x3020, \"UL\", \"Histogram Data\" },\n    { 0x0070, 0x0001, \"SQ\", \"Graphic Annotation Sequence\" },\n    { 0x0070, 0x0002, \"CS\", \"Graphic Layer\" },\n    { 0x0070, 0x0003, \"CS\", \"Bounding Box Annotation Units\" },\n    { 0x0070, 0x0004, \"CS\", \"Anchor Point Annotation Units\" },\n    { 0x0070, 0x0005, \"CS\", \"Graphic Annotation Units\" },\n    { 0x0070, 0x0006, \"ST\", \"Unformatted Text Value\" },\n    { 0x0070, 0x0008, \"SQ\", \"Text Object Sequence\" },\n    { 0x0070, 0x0009, \"SQ\", \"Graphic Object Sequence\" },\n    { 0x0070, 0x0010, \"FL\", \"Bounding Box TLHC\" },\n    { 0x0070, 0x0011, \"FL\", \"Bounding Box BRHC\" },\n    { 0x0070, 0x0014, \"FL\", \"Anchor Point\" },\n    { 0x0070, 0x0015, \"CS\", \"Anchor Point Visibility\" },\n    { 0x0070, 0x0020, \"US\", \"Graphic Dimensions\" },\n    { 0x0070, 0x0021, \"US\", \"Number Of Graphic Points\" },\n    { 0x0070, 0x0022, \"FL\", \"Graphic Data\" },\n    { 0x0070, 0x0023, \"CS\", \"Graphic Type\" },\n    { 0x0070, 0x0024, \"CS\", \"Graphic Filled\" },\n    { 0x0070, 0x0040, \"IS\", \"Image Rotation\" },\n    { 0x0070, 0x0041, \"CS\", \"Image Horizontal Flip\" },\n    { 0x0070, 0x0050, \"US\", \"Displayed Area TLHC\" },\n    { 0x0070, 0x0051, \"US\", \"Displayed Area BRHC\" },\n    { 0x0070, 0x0060, \"SQ\", \"Graphic Layer Sequence\" },\n    { 0x0070, 0x0062, \"IS\", \"Graphic Layer Order\" },\n    { 0x0070, 0x0066, \"US\", \"Graphic Layer Recommended Display Value\" },\n    { 0x0070, 0x0068, \"LO\", \"Graphic Layer Description\" },\n    { 0x0070, 0x0080, \"CS\", \"Presentation Label\" },\n    { 0x0070, 0x0081, \"LO\", \"Presentation Description\" },\n    { 0x0070, 0x0082, \"DA\", \"Presentation Creation Date\" },\n    { 0x0070, 0x0083, \"TM\", \"Presentation Creation Time\" },\n    { 0x0070, 0x0084, \"PN\", \"Presentation Creator's Name\" },\n    { 0x0070, 0x031a, \"UI\", \"Fiducial UID\" },\n    { 0x0087, 0x0010, \"CS\", \"Media Type\" },\n    { 0x0087, 0x0020, \"CS\", \"Media Location\" },\n    { 0x0087, 0x0050, \"IS\", \"Estimated Retrieve Time\" },\n    { 0x0088, 0x0000, \"UL\", \"Storage Group Length\" },\n    { 0x0088, 0x0130, \"SH\", \"Storage Media FileSet ID\" },\n    { 0x0088, 0x0140, \"UI\", \"Storage Media FileSet UID\" },\n    { 0x0088, 0x0200, \"SQ\", \"Icon Image Sequence\" },\n    { 0x0088, 0x0904, \"LO\", \"Topic Title\" },\n    { 0x0088, 0x0906, \"ST\", \"Topic Subject\" },\n    { 0x0088, 0x0910, \"LO\", \"Topic Author\" },\n    { 0x0088, 0x0912, \"LO\", \"Topic Key Words\" },\n    { 0x0095, 0x0001, \"LT\", \"Examination Folder ID\" },\n    { 0x0095, 0x0004, \"UL\", \"Folder Reported Status\" },\n    { 0x0095, 0x0005, \"LT\", \"Folder Reporting Radiologist\" },\n    { 0x0095, 0x0007, \"LT\", \"SIENET ISA PLA\" },\n    { 0x0099, 0x0002, \"UL\", \"Data Object Attributes\" },\n    { 0x00e1, 0x0001, \"US\", \"Data Dictionary Version\" },\n    { 0x00e1, 0x0014, \"LT\", \"?\" },\n    { 0x00e1, 0x0022, \"DS\", \"?\" },\n    { 0x00e1, 0x0023, \"DS\", \"?\" },\n    { 0x00e1, 0x0024, \"LT\", \"?\" },\n    { 0x00e1, 0x0025, \"LT\", \"?\" },\n    { 0x00e1, 0x0040, \"SH\", \"Offset From CT MR Images\" },\n    { 0x0193, 0x0002, \"DS\", \"RIS Key\" },\n    { 0x0307, 0x0001, \"UN\", \"RIS Worklist IMGEF\" },\n    { 0x0309, 0x0001, \"UN\", \"RIS Report IMGEF\" },\n    { 0x0601, 0x0000, \"SH\", \"Implementation Version\" },\n    { 0x0601, 0x0020, \"DS\", \"Relative Table Position\" },\n    { 0x0601, 0x0021, \"DS\", \"Relative Table Height\" },\n    { 0x0601, 0x0030, \"SH\", \"Surview Direction\" },\n    { 0x0601, 0x0031, \"DS\", \"Surview Length\" },\n    { 0x0601, 0x0050, \"SH\", \"Image View Type\" },\n    { 0x0601, 0x0070, \"DS\", \"Batch Number\" },\n    { 0x0601, 0x0071, \"DS\", \"Batch Size\" },\n    { 0x0601, 0x0072, \"DS\", \"Batch Slice Number\" },\n    { 0x1000, 0x0000, \"xs\", \"?\" },\n    { 0x1000, 0x0001, \"US\", \"Run Length Triplet\" },\n    { 0x1000, 0x0002, \"US\", \"Huffman Table Size\" },\n    { 0x1000, 0x0003, \"US\", \"Huffman Table Triplet\" },\n    { 0x1000, 0x0004, \"US\", \"Shift Table Size\" },\n    { 0x1000, 0x0005, \"US\", \"Shift Table Triplet\" },\n    { 0x1010, 0x0000, \"xs\", \"?\" },\n    { 0x1369, 0x0000, \"US\", \"?\" },\n    { 0x2000, 0x0000, \"UL\", \"Film Session Group Length\" },\n    { 0x2000, 0x0010, \"IS\", \"Number of Copies\" },\n    { 0x2000, 0x0020, \"CS\", \"Print Priority\" },\n    { 0x2000, 0x0030, \"CS\", \"Medium Type\" },\n    { 0x2000, 0x0040, \"CS\", \"Film Destination\" },\n    { 0x2000, 0x0050, \"LO\", \"Film Session Label\" },\n    { 0x2000, 0x0060, \"IS\", \"Memory Allocation\" },\n    { 0x2000, 0x0500, \"SQ\", \"Referenced Film Box Sequence\" },\n    { 0x2010, 0x0000, \"UL\", \"Film Box Group Length\" },\n    { 0x2010, 0x0010, \"ST\", \"Image Display Format\" },\n    { 0x2010, 0x0030, \"CS\", \"Annotation Display Format ID\" },\n    { 0x2010, 0x0040, \"CS\", \"Film Orientation\" },\n    { 0x2010, 0x0050, \"CS\", \"Film Size ID\" },\n    { 0x2010, 0x0060, \"CS\", \"Magnification Type\" },\n    { 0x2010, 0x0080, \"CS\", \"Smoothing Type\" },\n    { 0x2010, 0x0100, \"CS\", \"Border Density\" },\n    { 0x2010, 0x0110, \"CS\", \"Empty Image Density\" },\n    { 0x2010, 0x0120, \"US\", \"Min Density\" },\n    { 0x2010, 0x0130, \"US\", \"Max Density\" },\n    { 0x2010, 0x0140, \"CS\", \"Trim\" },\n    { 0x2010, 0x0150, \"ST\", \"Configuration Information\" },\n    { 0x2010, 0x0500, \"SQ\", \"Referenced Film Session Sequence\" },\n    { 0x2010, 0x0510, \"SQ\", \"Referenced Image Box Sequence\" },\n    { 0x2010, 0x0520, \"SQ\", \"Referenced Basic Annotation Box Sequence\" },\n    { 0x2020, 0x0000, \"UL\", \"Image Box Group Length\" },\n    { 0x2020, 0x0010, \"US\", \"Image Box Position\" },\n    { 0x2020, 0x0020, \"CS\", \"Polarity\" },\n    { 0x2020, 0x0030, \"DS\", \"Requested Image Size\" },\n    { 0x2020, 0x0110, \"SQ\", \"Preformatted Grayscale Image Sequence\" },\n    { 0x2020, 0x0111, \"SQ\", \"Preformatted Color Image Sequence\" },\n    { 0x2020, 0x0130, \"SQ\", \"Referenced Image Overlay Box Sequence\" },\n    { 0x2020, 0x0140, \"SQ\", \"Referenced VOI LUT Box Sequence\" },\n    { 0x2030, 0x0000, \"UL\", \"Annotation Group Length\" },\n    { 0x2030, 0x0010, \"US\", \"Annotation Position\" },\n    { 0x2030, 0x0020, \"LO\", \"Text String\" },\n    { 0x2040, 0x0000, \"UL\", \"Overlay Box Group Length\" },\n    { 0x2040, 0x0010, \"SQ\", \"Referenced Overlay Plane Sequence\" },\n    { 0x2040, 0x0011, \"US\", \"Referenced Overlay Plane Groups\" },\n    { 0x2040, 0x0060, \"CS\", \"Overlay Magnification Type\" },\n    { 0x2040, 0x0070, \"CS\", \"Overlay Smoothing Type\" },\n    { 0x2040, 0x0080, \"CS\", \"Overlay Foreground Density\" },\n    { 0x2040, 0x0090, \"CS\", \"Overlay Mode\" },\n    { 0x2040, 0x0100, \"CS\", \"Threshold Density\" },\n    { 0x2040, 0x0500, \"SQ\", \"Referenced Overlay Image Box Sequence\" },\n    { 0x2050, 0x0010, \"SQ\", \"Presentation LUT Sequence\" },\n    { 0x2050, 0x0020, \"CS\", \"Presentation LUT Shape\" },\n    { 0x2100, 0x0000, \"UL\", \"Print Job Group Length\" },\n    { 0x2100, 0x0020, \"CS\", \"Execution Status\" },\n    { 0x2100, 0x0030, \"CS\", \"Execution Status Info\" },\n    { 0x2100, 0x0040, \"DA\", \"Creation Date\" },\n    { 0x2100, 0x0050, \"TM\", \"Creation Time\" },\n    { 0x2100, 0x0070, \"AE\", \"Originator\" },\n    { 0x2100, 0x0500, \"SQ\", \"Referenced Print Job Sequence\" },\n    { 0x2110, 0x0000, \"UL\", \"Printer Group Length\" },\n    { 0x2110, 0x0010, \"CS\", \"Printer Status\" },\n    { 0x2110, 0x0020, \"CS\", \"Printer Status Info\" },\n    { 0x2110, 0x0030, \"LO\", \"Printer Name\" },\n    { 0x2110, 0x0099, \"SH\", \"Print Queue ID\" },\n    { 0x3002, 0x0002, \"SH\", \"RT Image Label\" },\n    { 0x3002, 0x0003, \"LO\", \"RT Image Name\" },\n    { 0x3002, 0x0004, \"ST\", \"RT Image Description\" },\n    { 0x3002, 0x000a, \"CS\", \"Reported Values Origin\" },\n    { 0x3002, 0x000c, \"CS\", \"RT Image Plane\" },\n    { 0x3002, 0x000e, \"DS\", \"X-Ray Image Receptor Angle\" },\n    { 0x3002, 0x0010, \"DS\", \"RTImageOrientation\" },\n    { 0x3002, 0x0011, \"DS\", \"Image Plane Pixel Spacing\" },\n    { 0x3002, 0x0012, \"DS\", \"RT Image Position\" },\n    { 0x3002, 0x0020, \"SH\", \"Radiation Machine Name\" },\n    { 0x3002, 0x0022, \"DS\", \"Radiation Machine SAD\" },\n    { 0x3002, 0x0024, \"DS\", \"Radiation Machine SSD\" },\n    { 0x3002, 0x0026, \"DS\", \"RT Image SID\" },\n    { 0x3002, 0x0028, \"DS\", \"Source to Reference Object Distance\" },\n    { 0x3002, 0x0029, \"IS\", \"Fraction Number\" },\n    { 0x3002, 0x0030, \"SQ\", \"Exposure Sequence\" },\n    { 0x3002, 0x0032, \"DS\", \"Meterset Exposure\" },\n    { 0x3004, 0x0001, \"CS\", \"DVH Type\" },\n    { 0x3004, 0x0002, \"CS\", \"Dose Units\" },\n    { 0x3004, 0x0004, \"CS\", \"Dose Type\" },\n    { 0x3004, 0x0006, \"LO\", \"Dose Comment\" },\n    { 0x3004, 0x0008, \"DS\", \"Normalization Point\" },\n    { 0x3004, 0x000a, \"CS\", \"Dose Summation Type\" },\n    { 0x3004, 0x000c, \"DS\", \"GridFrame Offset Vector\" },\n    { 0x3004, 0x000e, \"DS\", \"Dose Grid Scaling\" },\n    { 0x3004, 0x0010, \"SQ\", \"RT Dose ROI Sequence\" },\n    { 0x3004, 0x0012, \"DS\", \"Dose Value\" },\n    { 0x3004, 0x0040, \"DS\", \"DVH Normalization Point\" },\n    { 0x3004, 0x0042, \"DS\", \"DVH Normalization Dose Value\" },\n    { 0x3004, 0x0050, \"SQ\", \"DVH Sequence\" },\n    { 0x3004, 0x0052, \"DS\", \"DVH Dose Scaling\" },\n    { 0x3004, 0x0054, \"CS\", \"DVH Volume Units\" },\n    { 0x3004, 0x0056, \"IS\", \"DVH Number of Bins\" },\n    { 0x3004, 0x0058, \"DS\", \"DVH Data\" },\n    { 0x3004, 0x0060, \"SQ\", \"DVH Referenced ROI Sequence\" },\n    { 0x3004, 0x0062, \"CS\", \"DVH ROI Contribution Type\" },\n    { 0x3004, 0x0070, \"DS\", \"DVH Minimum Dose\" },\n    { 0x3004, 0x0072, \"DS\", \"DVH Maximum Dose\" },\n    { 0x3004, 0x0074, \"DS\", \"DVH Mean Dose\" },\n    { 0x3006, 0x0002, \"SH\", \"Structure Set Label\" },\n    { 0x3006, 0x0004, \"LO\", \"Structure Set Name\" },\n    { 0x3006, 0x0006, \"ST\", \"Structure Set Description\" },\n    { 0x3006, 0x0008, \"DA\", \"Structure Set Date\" },\n    { 0x3006, 0x0009, \"TM\", \"Structure Set Time\" },\n    { 0x3006, 0x0010, \"SQ\", \"Referenced Frame of Reference Sequence\" },\n    { 0x3006, 0x0012, \"SQ\", \"RT Referenced Study Sequence\" },\n    { 0x3006, 0x0014, \"SQ\", \"RT Referenced Series Sequence\" },\n    { 0x3006, 0x0016, \"SQ\", \"Contour Image Sequence\" },\n    { 0x3006, 0x0020, \"SQ\", \"Structure Set ROI Sequence\" },\n    { 0x3006, 0x0022, \"IS\", \"ROI Number\" },\n    { 0x3006, 0x0024, \"UI\", \"Referenced Frame of Reference UID\" },\n    { 0x3006, 0x0026, \"LO\", \"ROI Name\" },\n    { 0x3006, 0x0028, \"ST\", \"ROI Description\" },\n    { 0x3006, 0x002a, \"IS\", \"ROI Display Color\" },\n    { 0x3006, 0x002c, \"DS\", \"ROI Volume\" },\n    { 0x3006, 0x0030, \"SQ\", \"RT Related ROI Sequence\" },\n    { 0x3006, 0x0033, \"CS\", \"RT ROI Relationship\" },\n    { 0x3006, 0x0036, \"CS\", \"ROI Generation Algorithm\" },\n    { 0x3006, 0x0038, \"LO\", \"ROI Generation Description\" },\n    { 0x3006, 0x0039, \"SQ\", \"ROI Contour Sequence\" },\n    { 0x3006, 0x0040, \"SQ\", \"Contour Sequence\" },\n    { 0x3006, 0x0042, \"CS\", \"Contour Geometric Type\" },\n    { 0x3006, 0x0044, \"DS\", \"Contour SlabT hickness\" },\n    { 0x3006, 0x0045, \"DS\", \"Contour Offset Vector\" },\n    { 0x3006, 0x0046, \"IS\", \"Number of Contour Points\" },\n    { 0x3006, 0x0050, \"DS\", \"Contour Data\" },\n    { 0x3006, 0x0080, \"SQ\", \"RT ROI Observations Sequence\" },\n    { 0x3006, 0x0082, \"IS\", \"Observation Number\" },\n    { 0x3006, 0x0084, \"IS\", \"Referenced ROI Number\" },\n    { 0x3006, 0x0085, \"SH\", \"ROI Observation Label\" },\n    { 0x3006, 0x0086, \"SQ\", \"RT ROI Identification Code Sequence\" },\n    { 0x3006, 0x0088, \"ST\", \"ROI Observation Description\" },\n    { 0x3006, 0x00a0, \"SQ\", \"Related RT ROI Observations Sequence\" },\n    { 0x3006, 0x00a4, \"CS\", \"RT ROI Interpreted Type\" },\n    { 0x3006, 0x00a6, \"PN\", \"ROI Interpreter\" },\n    { 0x3006, 0x00b0, \"SQ\", \"ROI Physical Properties Sequence\" },\n    { 0x3006, 0x00b2, \"CS\", \"ROI Physical Property\" },\n    { 0x3006, 0x00b4, \"DS\", \"ROI Physical Property Value\" },\n    { 0x3006, 0x00c0, \"SQ\", \"Frame of Reference Relationship Sequence\" },\n    { 0x3006, 0x00c2, \"UI\", \"Related Frame of Reference UID\" },\n    { 0x3006, 0x00c4, \"CS\", \"Frame of Reference Transformation Type\" },\n    { 0x3006, 0x00c6, \"DS\", \"Frame of Reference Transformation Matrix\" },\n    { 0x3006, 0x00c8, \"LO\", \"Frame of Reference Transformation Comment\" },\n    { 0x300a, 0x0002, \"SH\", \"RT Plan Label\" },\n    { 0x300a, 0x0003, \"LO\", \"RT Plan Name\" },\n    { 0x300a, 0x0004, \"ST\", \"RT Plan Description\" },\n    { 0x300a, 0x0006, \"DA\", \"RT Plan Date\" },\n    { 0x300a, 0x0007, \"TM\", \"RT Plan Time\" },\n    { 0x300a, 0x0009, \"LO\", \"Treatment Protocols\" },\n    { 0x300a, 0x000a, \"CS\", \"Treatment Intent\" },\n    { 0x300a, 0x000b, \"LO\", \"Treatment Sites\" },\n    { 0x300a, 0x000c, \"CS\", \"RT Plan Geometry\" },\n    { 0x300a, 0x000e, \"ST\", \"Prescription Description\" },\n    { 0x300a, 0x0010, \"SQ\", \"Dose ReferenceSequence\" },\n    { 0x300a, 0x0012, \"IS\", \"Dose ReferenceNumber\" },\n    { 0x300a, 0x0014, \"CS\", \"Dose Reference Structure Type\" },\n    { 0x300a, 0x0016, \"LO\", \"Dose ReferenceDescription\" },\n    { 0x300a, 0x0018, \"DS\", \"Dose Reference Point Coordinates\" },\n    { 0x300a, 0x001a, \"DS\", \"Nominal Prior Dose\" },\n    { 0x300a, 0x0020, \"CS\", \"Dose Reference Type\" },\n    { 0x300a, 0x0021, \"DS\", \"Constraint Weight\" },\n    { 0x300a, 0x0022, \"DS\", \"Delivery Warning Dose\" },\n    { 0x300a, 0x0023, \"DS\", \"Delivery Maximum Dose\" },\n    { 0x300a, 0x0025, \"DS\", \"Target Minimum Dose\" },\n    { 0x300a, 0x0026, \"DS\", \"Target Prescription Dose\" },\n    { 0x300a, 0x0027, \"DS\", \"Target Maximum Dose\" },\n    { 0x300a, 0x0028, \"DS\", \"Target Underdose Volume Fraction\" },\n    { 0x300a, 0x002a, \"DS\", \"Organ at Risk Full-volume Dose\" },\n    { 0x300a, 0x002b, \"DS\", \"Organ at Risk Limit Dose\" },\n    { 0x300a, 0x002c, \"DS\", \"Organ at Risk Maximum Dose\" },\n    { 0x300a, 0x002d, \"DS\", \"Organ at Risk Overdose Volume Fraction\" },\n    { 0x300a, 0x0040, \"SQ\", \"Tolerance Table Sequence\" },\n    { 0x300a, 0x0042, \"IS\", \"Tolerance Table Number\" },\n    { 0x300a, 0x0043, \"SH\", \"Tolerance Table Label\" },\n    { 0x300a, 0x0044, \"DS\", \"Gantry Angle Tolerance\" },\n    { 0x300a, 0x0046, \"DS\", \"Beam Limiting Device Angle Tolerance\" },\n    { 0x300a, 0x0048, \"SQ\", \"Beam Limiting Device Tolerance Sequence\" },\n    { 0x300a, 0x004a, \"DS\", \"Beam Limiting Device Position Tolerance\" },\n    { 0x300a, 0x004c, \"DS\", \"Patient Support Angle Tolerance\" },\n    { 0x300a, 0x004e, \"DS\", \"Table Top Eccentric Angle Tolerance\" },\n    { 0x300a, 0x0051, \"DS\", \"Table Top Vertical Position Tolerance\" },\n    { 0x300a, 0x0052, \"DS\", \"Table Top Longitudinal Position Tolerance\" },\n    { 0x300a, 0x0053, \"DS\", \"Table Top Lateral Position Tolerance\" },\n    { 0x300a, 0x0055, \"CS\", \"RT Plan Relationship\" },\n    { 0x300a, 0x0070, \"SQ\", \"Fraction Group Sequence\" },\n    { 0x300a, 0x0071, \"IS\", \"Fraction Group Number\" },\n    { 0x300a, 0x0078, \"IS\", \"Number of Fractions Planned\" },\n    { 0x300a, 0x0079, \"IS\", \"Number of Fractions Per Day\" },\n    { 0x300a, 0x007a, \"IS\", \"Repeat Fraction Cycle Length\" },\n    { 0x300a, 0x007b, \"LT\", \"Fraction Pattern\" },\n    { 0x300a, 0x0080, \"IS\", \"Number of Beams\" },\n    { 0x300a, 0x0082, \"DS\", \"Beam Dose Specification Point\" },\n    { 0x300a, 0x0084, \"DS\", \"Beam Dose\" },\n    { 0x300a, 0x0086, \"DS\", \"Beam Meterset\" },\n    { 0x300a, 0x00a0, \"IS\", \"Number of Brachy Application Setups\" },\n    { 0x300a, 0x00a2, \"DS\", \"Brachy Application Setup Dose Specification Point\" },\n    { 0x300a, 0x00a4, \"DS\", \"Brachy Application Setup Dose\" },\n    { 0x300a, 0x00b0, \"SQ\", \"Beam Sequence\" },\n    { 0x300a, 0x00b2, \"SH\", \"Treatment Machine Name \" },\n    { 0x300a, 0x00b3, \"CS\", \"Primary Dosimeter Unit\" },\n    { 0x300a, 0x00b4, \"DS\", \"Source-Axis Distance\" },\n    { 0x300a, 0x00b6, \"SQ\", \"Beam Limiting Device Sequence\" },\n    { 0x300a, 0x00b8, \"CS\", \"RT Beam Limiting Device Type\" },\n    { 0x300a, 0x00ba, \"DS\", \"Source to Beam Limiting Device Distance\" },\n    { 0x300a, 0x00bc, \"IS\", \"Number of Leaf/Jaw Pairs\" },\n    { 0x300a, 0x00be, \"DS\", \"Leaf Position Boundaries\" },\n    { 0x300a, 0x00c0, \"IS\", \"Beam Number\" },\n    { 0x300a, 0x00c2, \"LO\", \"Beam Name\" },\n    { 0x300a, 0x00c3, \"ST\", \"Beam Description\" },\n    { 0x300a, 0x00c4, \"CS\", \"Beam Type\" },\n    { 0x300a, 0x00c6, \"CS\", \"Radiation Type\" },\n    { 0x300a, 0x00c8, \"IS\", \"Reference Image Number\" },\n    { 0x300a, 0x00ca, \"SQ\", \"Planned Verification Image Sequence\" },\n    { 0x300a, 0x00cc, \"LO\", \"Imaging Device Specific Acquisition Parameters\" },\n    { 0x300a, 0x00ce, \"CS\", \"Treatment Delivery Type\" },\n    { 0x300a, 0x00d0, \"IS\", \"Number of Wedges\" },\n    { 0x300a, 0x00d1, \"SQ\", \"Wedge Sequence\" },\n    { 0x300a, 0x00d2, \"IS\", \"Wedge Number\" },\n    { 0x300a, 0x00d3, \"CS\", \"Wedge Type\" },\n    { 0x300a, 0x00d4, \"SH\", \"Wedge ID\" },\n    { 0x300a, 0x00d5, \"IS\", \"Wedge Angle\" },\n    { 0x300a, 0x00d6, \"DS\", \"Wedge Factor\" },\n    { 0x300a, 0x00d8, \"DS\", \"Wedge Orientation\" },\n    { 0x300a, 0x00da, \"DS\", \"Source to Wedge Tray Distance\" },\n    { 0x300a, 0x00e0, \"IS\", \"Number of Compensators\" },\n    { 0x300a, 0x00e1, \"SH\", \"Material ID\" },\n    { 0x300a, 0x00e2, \"DS\", \"Total Compensator Tray Factor\" },\n    { 0x300a, 0x00e3, \"SQ\", \"Compensator Sequence\" },\n    { 0x300a, 0x00e4, \"IS\", \"Compensator Number\" },\n    { 0x300a, 0x00e5, \"SH\", \"Compensator ID\" },\n    { 0x300a, 0x00e6, \"DS\", \"Source to Compensator Tray Distance\" },\n    { 0x300a, 0x00e7, \"IS\", \"Compensator Rows\" },\n    { 0x300a, 0x00e8, \"IS\", \"Compensator Columns\" },\n    { 0x300a, 0x00e9, \"DS\", \"Compensator Pixel Spacing\" },\n    { 0x300a, 0x00ea, \"DS\", \"Compensator Position\" },\n    { 0x300a, 0x00eb, \"DS\", \"Compensator Transmission Data\" },\n    { 0x300a, 0x00ec, \"DS\", \"Compensator Thickness Data\" },\n    { 0x300a, 0x00ed, \"IS\", \"Number of Boli\" },\n    { 0x300a, 0x00f0, \"IS\", \"Number of Blocks\" },\n    { 0x300a, 0x00f2, \"DS\", \"Total Block Tray Factor\" },\n    { 0x300a, 0x00f4, \"SQ\", \"Block Sequence\" },\n    { 0x300a, 0x00f5, \"SH\", \"Block Tray ID\" },\n    { 0x300a, 0x00f6, \"DS\", \"Source to Block Tray Distance\" },\n    { 0x300a, 0x00f8, \"CS\", \"Block Type\" },\n    { 0x300a, 0x00fa, \"CS\", \"Block Divergence\" },\n    { 0x300a, 0x00fc, \"IS\", \"Block Number\" },\n    { 0x300a, 0x00fe, \"LO\", \"Block Name\" },\n    { 0x300a, 0x0100, \"DS\", \"Block Thickness\" },\n    { 0x300a, 0x0102, \"DS\", \"Block Transmission\" },\n    { 0x300a, 0x0104, \"IS\", \"Block Number of Points\" },\n    { 0x300a, 0x0106, \"DS\", \"Block Data\" },\n    { 0x300a, 0x0107, \"SQ\", \"Applicator Sequence\" },\n    { 0x300a, 0x0108, \"SH\", \"Applicator ID\" },\n    { 0x300a, 0x0109, \"CS\", \"Applicator Type\" },\n    { 0x300a, 0x010a, \"LO\", \"Applicator Description\" },\n    { 0x300a, 0x010c, \"DS\", \"Cumulative Dose Reference Coefficient\" },\n    { 0x300a, 0x010e, \"DS\", \"Final Cumulative Meterset Weight\" },\n    { 0x300a, 0x0110, \"IS\", \"Number of Control Points\" },\n    { 0x300a, 0x0111, \"SQ\", \"Control Point Sequence\" },\n    { 0x300a, 0x0112, \"IS\", \"Control Point Index\" },\n    { 0x300a, 0x0114, \"DS\", \"Nominal Beam Energy\" },\n    { 0x300a, 0x0115, \"DS\", \"Dose Rate Set\" },\n    { 0x300a, 0x0116, \"SQ\", \"Wedge Position Sequence\" },\n    { 0x300a, 0x0118, \"CS\", \"Wedge Position\" },\n    { 0x300a, 0x011a, \"SQ\", \"Beam Limiting Device Position Sequence\" },\n    { 0x300a, 0x011c, \"DS\", \"Leaf Jaw Positions\" },\n    { 0x300a, 0x011e, \"DS\", \"Gantry Angle\" },\n    { 0x300a, 0x011f, \"CS\", \"Gantry Rotation Direction\" },\n    { 0x300a, 0x0120, \"DS\", \"Beam Limiting Device Angle\" },\n    { 0x300a, 0x0121, \"CS\", \"Beam Limiting Device Rotation Direction\" },\n    { 0x300a, 0x0122, \"DS\", \"Patient Support Angle\" },\n    { 0x300a, 0x0123, \"CS\", \"Patient Support Rotation Direction\" },\n    { 0x300a, 0x0124, \"DS\", \"Table Top Eccentric Axis Distance\" },\n    { 0x300a, 0x0125, \"DS\", \"Table Top Eccentric Angle\" },\n    { 0x300a, 0x0126, \"CS\", \"Table Top Eccentric Rotation Direction\" },\n    { 0x300a, 0x0128, \"DS\", \"Table Top Vertical Position\" },\n    { 0x300a, 0x0129, \"DS\", \"Table Top Longitudinal Position\" },\n    { 0x300a, 0x012a, \"DS\", \"Table Top Lateral Position\" },\n    { 0x300a, 0x012c, \"DS\", \"Isocenter Position\" },\n    { 0x300a, 0x012e, \"DS\", \"Surface Entry Point\" },\n    { 0x300a, 0x0130, \"DS\", \"Source to Surface Distance\" },\n    { 0x300a, 0x0134, \"DS\", \"Cumulative Meterset Weight\" },\n    { 0x300a, 0x0180, \"SQ\", \"Patient Setup Sequence\" },\n    { 0x300a, 0x0182, \"IS\", \"Patient Setup Number\" },\n    { 0x300a, 0x0184, \"LO\", \"Patient Additional Position\" },\n    { 0x300a, 0x0190, \"SQ\", \"Fixation Device Sequence\" },\n    { 0x300a, 0x0192, \"CS\", \"Fixation Device Type\" },\n    { 0x300a, 0x0194, \"SH\", \"Fixation Device Label\" },\n    { 0x300a, 0x0196, \"ST\", \"Fixation Device Description\" },\n    { 0x300a, 0x0198, \"SH\", \"Fixation Device Position\" },\n    { 0x300a, 0x01a0, \"SQ\", \"Shielding Device Sequence\" },\n    { 0x300a, 0x01a2, \"CS\", \"Shielding Device Type\" },\n    { 0x300a, 0x01a4, \"SH\", \"Shielding Device Label\" },\n    { 0x300a, 0x01a6, \"ST\", \"Shielding Device Description\" },\n    { 0x300a, 0x01a8, \"SH\", \"Shielding Device Position\" },\n    { 0x300a, 0x01b0, \"CS\", \"Setup Technique\" },\n    { 0x300a, 0x01b2, \"ST\", \"Setup TechniqueDescription\" },\n    { 0x300a, 0x01b4, \"SQ\", \"Setup Device Sequence\" },\n    { 0x300a, 0x01b6, \"CS\", \"Setup Device Type\" },\n    { 0x300a, 0x01b8, \"SH\", \"Setup Device Label\" },\n    { 0x300a, 0x01ba, \"ST\", \"Setup Device Description\" },\n    { 0x300a, 0x01bc, \"DS\", \"Setup Device Parameter\" },\n    { 0x300a, 0x01d0, \"ST\", \"Setup ReferenceDescription\" },\n    { 0x300a, 0x01d2, \"DS\", \"Table Top Vertical Setup Displacement\" },\n    { 0x300a, 0x01d4, \"DS\", \"Table Top Longitudinal Setup Displacement\" },\n    { 0x300a, 0x01d6, \"DS\", \"Table Top Lateral Setup Displacement\" },\n    { 0x300a, 0x0200, \"CS\", \"Brachy Treatment Technique\" },\n    { 0x300a, 0x0202, \"CS\", \"Brachy Treatment Type\" },\n    { 0x300a, 0x0206, \"SQ\", \"Treatment Machine Sequence\" },\n    { 0x300a, 0x0210, \"SQ\", \"Source Sequence\" },\n    { 0x300a, 0x0212, \"IS\", \"Source Number\" },\n    { 0x300a, 0x0214, \"CS\", \"Source Type\" },\n    { 0x300a, 0x0216, \"LO\", \"Source Manufacturer\" },\n    { 0x300a, 0x0218, \"DS\", \"Active Source Diameter\" },\n    { 0x300a, 0x021a, \"DS\", \"Active Source Length\" },\n    { 0x300a, 0x0222, \"DS\", \"Source Encapsulation Nominal Thickness\" },\n    { 0x300a, 0x0224, \"DS\", \"Source Encapsulation Nominal Transmission\" },\n    { 0x300a, 0x0226, \"LO\", \"Source IsotopeName\" },\n    { 0x300a, 0x0228, \"DS\", \"Source Isotope Half Life\" },\n    { 0x300a, 0x022a, \"DS\", \"Reference Air Kerma Rate\" },\n    { 0x300a, 0x022c, \"DA\", \"Air Kerma Rate Reference Date\" },\n    { 0x300a, 0x022e, \"TM\", \"Air Kerma Rate Reference Time\" },\n    { 0x300a, 0x0230, \"SQ\", \"Application Setup Sequence\" },\n    { 0x300a, 0x0232, \"CS\", \"Application Setup Type\" },\n    { 0x300a, 0x0234, \"IS\", \"Application Setup Number\" },\n    { 0x300a, 0x0236, \"LO\", \"Application Setup Name\" },\n    { 0x300a, 0x0238, \"LO\", \"Application Setup Manufacturer\" },\n    { 0x300a, 0x0240, \"IS\", \"Template Number\" },\n    { 0x300a, 0x0242, \"SH\", \"Template Type\" },\n    { 0x300a, 0x0244, \"LO\", \"Template Name\" },\n    { 0x300a, 0x0250, \"DS\", \"Total Reference Air Kerma\" },\n    { 0x300a, 0x0260, \"SQ\", \"Brachy Accessory Device Sequence\" },\n    { 0x300a, 0x0262, \"IS\", \"Brachy Accessory Device Number\" },\n    { 0x300a, 0x0263, \"SH\", \"Brachy Accessory Device ID\" },\n    { 0x300a, 0x0264, \"CS\", \"Brachy Accessory Device Type\" },\n    { 0x300a, 0x0266, \"LO\", \"Brachy Accessory Device Name\" },\n    { 0x300a, 0x026a, \"DS\", \"Brachy Accessory Device Nominal Thickness\" },\n    { 0x300a, 0x026c, \"DS\", \"Brachy Accessory Device Nominal Transmission\" },\n    { 0x300a, 0x0280, \"SQ\", \"Channel Sequence\" },\n    { 0x300a, 0x0282, \"IS\", \"Channel Number\" },\n    { 0x300a, 0x0284, \"DS\", \"Channel Length\" },\n    { 0x300a, 0x0286, \"DS\", \"Channel Total Time\" },\n    { 0x300a, 0x0288, \"CS\", \"Source Movement Type\" },\n    { 0x300a, 0x028a, \"IS\", \"Number of Pulses\" },\n    { 0x300a, 0x028c, \"DS\", \"Pulse Repetition Interval\" },\n    { 0x300a, 0x0290, \"IS\", \"Source Applicator Number\" },\n    { 0x300a, 0x0291, \"SH\", \"Source Applicator ID\" },\n    { 0x300a, 0x0292, \"CS\", \"Source Applicator Type\" },\n    { 0x300a, 0x0294, \"LO\", \"Source Applicator Name\" },\n    { 0x300a, 0x0296, \"DS\", \"Source Applicator Length\" },\n    { 0x300a, 0x0298, \"LO\", \"Source Applicator Manufacturer\" },\n    { 0x300a, 0x029c, \"DS\", \"Source Applicator Wall Nominal Thickness\" },\n    { 0x300a, 0x029e, \"DS\", \"Source Applicator Wall Nominal Transmission\" },\n    { 0x300a, 0x02a0, \"DS\", \"Source Applicator Step Size\" },\n    { 0x300a, 0x02a2, \"IS\", \"Transfer Tube Number\" },\n    { 0x300a, 0x02a4, \"DS\", \"Transfer Tube Length\" },\n    { 0x300a, 0x02b0, \"SQ\", \"Channel Shield Sequence\" },\n    { 0x300a, 0x02b2, \"IS\", \"Channel Shield Number\" },\n    { 0x300a, 0x02b3, \"SH\", \"Channel Shield ID\" },\n    { 0x300a, 0x02b4, \"LO\", \"Channel Shield Name\" },\n    { 0x300a, 0x02b8, \"DS\", \"Channel Shield Nominal Thickness\" },\n    { 0x300a, 0x02ba, \"DS\", \"Channel Shield Nominal Transmission\" },\n    { 0x300a, 0x02c8, \"DS\", \"Final Cumulative Time Weight\" },\n    { 0x300a, 0x02d0, \"SQ\", \"Brachy Control Point Sequence\" },\n    { 0x300a, 0x02d2, \"DS\", \"Control Point Relative Position\" },\n    { 0x300a, 0x02d4, \"DS\", \"Control Point 3D Position\" },\n    { 0x300a, 0x02d6, \"DS\", \"Cumulative Time Weight\" },\n    { 0x300c, 0x0002, \"SQ\", \"Referenced RT Plan Sequence\" },\n    { 0x300c, 0x0004, \"SQ\", \"Referenced Beam Sequence\" },\n    { 0x300c, 0x0006, \"IS\", \"Referenced Beam Number\" },\n    { 0x300c, 0x0007, \"IS\", \"Referenced Reference Image Number\" },\n    { 0x300c, 0x0008, \"DS\", \"Start Cumulative Meterset Weight\" },\n    { 0x300c, 0x0009, \"DS\", \"End Cumulative Meterset Weight\" },\n    { 0x300c, 0x000a, \"SQ\", \"Referenced Brachy Application Setup Sequence\" },\n    { 0x300c, 0x000c, \"IS\", \"Referenced Brachy Application Setup Number\" },\n    { 0x300c, 0x000e, \"IS\", \"Referenced Source Number\" },\n    { 0x300c, 0x0020, \"SQ\", \"Referenced Fraction Group Sequence\" },\n    { 0x300c, 0x0022, \"IS\", \"Referenced Fraction Group Number\" },\n    { 0x300c, 0x0040, \"SQ\", \"Referenced Verification Image Sequence\" },\n    { 0x300c, 0x0042, \"SQ\", \"Referenced Reference Image Sequence\" },\n    { 0x300c, 0x0050, \"SQ\", \"Referenced Dose Reference Sequence\" },\n    { 0x300c, 0x0051, \"IS\", \"Referenced Dose Reference Number\" },\n    { 0x300c, 0x0055, \"SQ\", \"Brachy Referenced Dose Reference Sequence\" },\n    { 0x300c, 0x0060, \"SQ\", \"Referenced Structure Set Sequence\" },\n    { 0x300c, 0x006a, \"IS\", \"Referenced Patient Setup Number\" },\n    { 0x300c, 0x0080, \"SQ\", \"Referenced Dose Sequence\" },\n    { 0x300c, 0x00a0, \"IS\", \"Referenced Tolerance Table Number\" },\n    { 0x300c, 0x00b0, \"SQ\", \"Referenced Bolus Sequence\" },\n    { 0x300c, 0x00c0, \"IS\", \"Referenced Wedge Number\" },\n    { 0x300c, 0x00d0, \"IS\", \"Referenced Compensato rNumber\" },\n    { 0x300c, 0x00e0, \"IS\", \"Referenced Block Number\" },\n    { 0x300c, 0x00f0, \"IS\", \"Referenced Control Point\" },\n    { 0x300e, 0x0002, \"CS\", \"Approval Status\" },\n    { 0x300e, 0x0004, \"DA\", \"Review Date\" },\n    { 0x300e, 0x0005, \"TM\", \"Review Time\" },\n    { 0x300e, 0x0008, \"PN\", \"Reviewer Name\" },\n    { 0x4000, 0x0000, \"UL\", \"Text Group Length\" },\n    { 0x4000, 0x0010, \"LT\", \"Text Arbitrary\" },\n    { 0x4000, 0x4000, \"LT\", \"Text Comments\" },\n    { 0x4008, 0x0000, \"UL\", \"Results Group Length\" },\n    { 0x4008, 0x0040, \"SH\", \"Results ID\" },\n    { 0x4008, 0x0042, \"LO\", \"Results ID Issuer\" },\n    { 0x4008, 0x0050, \"SQ\", \"Referenced Interpretation Sequence\" },\n    { 0x4008, 0x00ff, \"CS\", \"Report Production Status\" },\n    { 0x4008, 0x0100, \"DA\", \"Interpretation Recorded Date\" },\n    { 0x4008, 0x0101, \"TM\", \"Interpretation Recorded Time\" },\n    { 0x4008, 0x0102, \"PN\", \"Interpretation Recorder\" },\n    { 0x4008, 0x0103, \"LO\", \"Reference to Recorded Sound\" },\n    { 0x4008, 0x0108, \"DA\", \"Interpretation Transcription Date\" },\n    { 0x4008, 0x0109, \"TM\", \"Interpretation Transcription Time\" },\n    { 0x4008, 0x010a, \"PN\", \"Interpretation Transcriber\" },\n    { 0x4008, 0x010b, \"ST\", \"Interpretation Text\" },\n    { 0x4008, 0x010c, \"PN\", \"Interpretation Author\" },\n    { 0x4008, 0x0111, \"SQ\", \"Interpretation Approver Sequence\" },\n    { 0x4008, 0x0112, \"DA\", \"Interpretation Approval Date\" },\n    { 0x4008, 0x0113, \"TM\", \"Interpretation Approval Time\" },\n    { 0x4008, 0x0114, \"PN\", \"Physician Approving Interpretation\" },\n    { 0x4008, 0x0115, \"LT\", \"Interpretation Diagnosis Description\" },\n    { 0x4008, 0x0117, \"SQ\", \"InterpretationDiagnosis Code Sequence\" },\n    { 0x4008, 0x0118, \"SQ\", \"Results Distribution List Sequence\" },\n    { 0x4008, 0x0119, \"PN\", \"Distribution Name\" },\n    { 0x4008, 0x011a, \"LO\", \"Distribution Address\" },\n    { 0x4008, 0x0200, \"SH\", \"Interpretation ID\" },\n    { 0x4008, 0x0202, \"LO\", \"Interpretation ID Issuer\" },\n    { 0x4008, 0x0210, \"CS\", \"Interpretation Type ID\" },\n    { 0x4008, 0x0212, \"CS\", \"Interpretation Status ID\" },\n    { 0x4008, 0x0300, \"ST\", \"Impressions\" },\n    { 0x4008, 0x4000, \"ST\", \"Results Comments\" },\n    { 0x4009, 0x0001, \"LT\", \"Report ID\" },\n    { 0x4009, 0x0020, \"LT\", \"Report Status\" },\n    { 0x4009, 0x0030, \"DA\", \"Report Creation Date\" },\n    { 0x4009, 0x0070, \"LT\", \"Report Approving Physician\" },\n    { 0x4009, 0x00e0, \"LT\", \"Report Text\" },\n    { 0x4009, 0x00e1, \"LT\", \"Report Author\" },\n    { 0x4009, 0x00e3, \"LT\", \"Reporting Radiologist\" },\n    { 0x5000, 0x0000, \"UL\", \"Curve Group Length\" },\n    { 0x5000, 0x0005, \"US\", \"Curve Dimensions\" },\n    { 0x5000, 0x0010, \"US\", \"Number of Points\" },\n    { 0x5000, 0x0020, \"CS\", \"Type of Data\" },\n    { 0x5000, 0x0022, \"LO\", \"Curve Description\" },\n    { 0x5000, 0x0030, \"SH\", \"Axis Units\" },\n    { 0x5000, 0x0040, \"SH\", \"Axis Labels\" },\n    { 0x5000, 0x0103, \"US\", \"Data Value Representation\" },\n    { 0x5000, 0x0104, \"US\", \"Minimum Coordinate Value\" },\n    { 0x5000, 0x0105, \"US\", \"Maximum Coordinate Value\" },\n    { 0x5000, 0x0106, \"SH\", \"Curve Range\" },\n    { 0x5000, 0x0110, \"US\", \"Curve Data Descriptor\" },\n    { 0x5000, 0x0112, \"US\", \"Coordinate Start Value\" },\n    { 0x5000, 0x0114, \"US\", \"Coordinate Step Value\" },\n    { 0x5000, 0x1001, \"CS\", \"Curve Activation Layer\" },\n    { 0x5000, 0x2000, \"US\", \"Audio Type\" },\n    { 0x5000, 0x2002, \"US\", \"Audio Sample Format\" },\n    { 0x5000, 0x2004, \"US\", \"Number of Channels\" },\n    { 0x5000, 0x2006, \"UL\", \"Number of Samples\" },\n    { 0x5000, 0x2008, \"UL\", \"Sample Rate\" },\n    { 0x5000, 0x200a, \"UL\", \"Total Time\" },\n    { 0x5000, 0x200c, \"xs\", \"Audio Sample Data\" },\n    { 0x5000, 0x200e, \"LT\", \"Audio Comments\" },\n    { 0x5000, 0x2500, \"LO\", \"Curve Label\" },\n    { 0x5000, 0x2600, \"SQ\", \"CurveReferenced Overlay Sequence\" },\n    { 0x5000, 0x2610, \"US\", \"CurveReferenced Overlay Group\" },\n    { 0x5000, 0x3000, \"OW\", \"Curve Data\" },\n    { 0x6000, 0x0000, \"UL\", \"Overlay Group Length\" },\n    { 0x6000, 0x0001, \"US\", \"Gray Palette Color Lookup Table Descriptor\" },\n    { 0x6000, 0x0002, \"US\", \"Gray Palette Color Lookup Table Data\" },\n    { 0x6000, 0x0010, \"US\", \"Overlay Rows\" },\n    { 0x6000, 0x0011, \"US\", \"Overlay Columns\" },\n    { 0x6000, 0x0012, \"US\", \"Overlay Planes\" },\n    { 0x6000, 0x0015, \"IS\", \"Number of Frames in Overlay\" },\n    { 0x6000, 0x0022, \"LO\", \"Overlay Description\" },\n    { 0x6000, 0x0040, \"CS\", \"Overlay Type\" },\n    { 0x6000, 0x0045, \"CS\", \"Overlay Subtype\" },\n    { 0x6000, 0x0050, \"SS\", \"Overlay Origin\" },\n    { 0x6000, 0x0051, \"US\", \"Image Frame Origin\" },\n    { 0x6000, 0x0052, \"US\", \"Plane Origin\" },\n    { 0x6000, 0x0060, \"LO\", \"Overlay Compression Code\" },\n    { 0x6000, 0x0061, \"SH\", \"Overlay Compression Originator\" },\n    { 0x6000, 0x0062, \"SH\", \"Overlay Compression Label\" },\n    { 0x6000, 0x0063, \"SH\", \"Overlay Compression Description\" },\n    { 0x6000, 0x0066, \"AT\", \"Overlay Compression Step Pointers\" },\n    { 0x6000, 0x0068, \"US\", \"Overlay Repeat Interval\" },\n    { 0x6000, 0x0069, \"US\", \"Overlay Bits Grouped\" },\n    { 0x6000, 0x0100, \"US\", \"Overlay Bits Allocated\" },\n    { 0x6000, 0x0102, \"US\", \"Overlay Bit Position\" },\n    { 0x6000, 0x0110, \"LO\", \"Overlay Format\" },\n    { 0x6000, 0x0200, \"xs\", \"Overlay Location\" },\n    { 0x6000, 0x0800, \"LO\", \"Overlay Code Label\" },\n    { 0x6000, 0x0802, \"US\", \"Overlay Number of Tables\" },\n    { 0x6000, 0x0803, \"AT\", \"Overlay Code Table Location\" },\n    { 0x6000, 0x0804, \"US\", \"Overlay Bits For Code Word\" },\n    { 0x6000, 0x1001, \"CS\", \"Overlay Activation Layer\" },\n    { 0x6000, 0x1100, \"US\", \"Overlay Descriptor - Gray\" },\n    { 0x6000, 0x1101, \"US\", \"Overlay Descriptor - Red\" },\n    { 0x6000, 0x1102, \"US\", \"Overlay Descriptor - Green\" },\n    { 0x6000, 0x1103, \"US\", \"Overlay Descriptor - Blue\" },\n    { 0x6000, 0x1200, \"US\", \"Overlays - Gray\" },\n    { 0x6000, 0x1201, \"US\", \"Overlays - Red\" },\n    { 0x6000, 0x1202, \"US\", \"Overlays - Green\" },\n    { 0x6000, 0x1203, \"US\", \"Overlays - Blue\" },\n    { 0x6000, 0x1301, \"IS\", \"ROI Area\" },\n    { 0x6000, 0x1302, \"DS\", \"ROI Mean\" },\n    { 0x6000, 0x1303, \"DS\", \"ROI Standard Deviation\" },\n    { 0x6000, 0x1500, \"LO\", \"Overlay Label\" },\n    { 0x6000, 0x3000, \"OW\", \"Overlay Data\" },\n    { 0x6000, 0x4000, \"LT\", \"Overlay Comments\" },\n    { 0x6001, 0x0000, \"UN\", \"?\" },\n    { 0x6001, 0x0010, \"LO\", \"?\" },\n    { 0x6001, 0x1010, \"xs\", \"?\" },\n    { 0x6001, 0x1030, \"xs\", \"?\" },\n    { 0x6021, 0x0000, \"xs\", \"?\" },\n    { 0x6021, 0x0010, \"xs\", \"?\" },\n    { 0x7001, 0x0010, \"LT\", \"Dummy\" },\n    { 0x7003, 0x0010, \"LT\", \"Info\" },\n    { 0x7005, 0x0010, \"LT\", \"Dummy\" },\n    { 0x7000, 0x0004, \"ST\", \"TextAnnotation\" },\n    { 0x7000, 0x0005, \"IS\", \"Box\" },\n    { 0x7000, 0x0007, \"IS\", \"ArrowEnd\" },\n    { 0x7001, 0x0001, \"SL\", \"Private Group Length To End\" },\n    { 0x7001, 0x0002, \"OB\", \"Unknown\" },\n    { 0x7001, 0x0011, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0021, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0022, \"SQ\", \"Private Creator\" },\n    { 0x7001, 0x0041, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0042, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0051, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0052, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0075, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0076, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0077, \"OB\", \"Private Creator\" },\n    { 0x7001, 0x0101, \"SL\", \"Unknown\" },\n    { 0x7001, 0x0121, \"SL\", \"Unknown\" },\n    { 0x7001, 0x0122, \"SQ\", \"Unknown\" },\n    { 0x7fe0, 0x0000, \"UL\", \"Pixel Data Group Length\" },\n    { 0x7fe0, 0x0010, \"xs\", \"Pixel Data\" },\n    { 0x7fe0, 0x0020, \"OW\", \"Coefficients SDVN\" },\n    { 0x7fe0, 0x0030, \"OW\", \"Coefficients SDHN\" },\n    { 0x7fe0, 0x0040, \"OW\", \"Coefficients SDDN\" },\n    { 0x7fe1, 0x0010, \"xs\", \"Pixel Data\" },\n    { 0x7f00, 0x0000, \"UL\", \"Variable Pixel Data Group Length\" },\n    { 0x7f00, 0x0010, \"xs\", \"Variable Pixel Data\" },\n    { 0x7f00, 0x0011, \"US\", \"Variable Next Data Group\" },\n    { 0x7f00, 0x0020, \"OW\", \"Variable Coefficients SDVN\" },\n    { 0x7f00, 0x0030, \"OW\", \"Variable Coefficients SDHN\" },\n    { 0x7f00, 0x0040, \"OW\", \"Variable Coefficients SDDN\" },\n    { 0x7fe1, 0x0000, \"OB\", \"Binary Data\" },\n    { 0x7fe3, 0x0000, \"LT\", \"Image Graphics Format Code\" },\n    { 0x7fe3, 0x0010, \"OB\", \"Image Graphics\" },\n    { 0x7fe3, 0x0020, \"OB\", \"Image Graphics Dummy\" },\n    { 0x7ff1, 0x0001, \"US\", \"?\" },\n    { 0x7ff1, 0x0002, \"US\", \"?\" },\n    { 0x7ff1, 0x0003, \"xs\", \"?\" },\n    { 0x7ff1, 0x0004, \"IS\", \"?\" },\n    { 0x7ff1, 0x0005, \"US\", \"?\" },\n    { 0x7ff1, 0x0007, \"US\", \"?\" },\n    { 0x7ff1, 0x0008, \"US\", \"?\" },\n    { 0x7ff1, 0x0009, \"US\", \"?\" },\n    { 0x7ff1, 0x000a, \"LT\", \"?\" },\n    { 0x7ff1, 0x000b, \"US\", \"?\" },\n    { 0x7ff1, 0x000c, \"US\", \"?\" },\n    { 0x7ff1, 0x000d, \"US\", \"?\" },\n    { 0x7ff1, 0x0010, \"US\", \"?\" },\n    { 0xfffc, 0xfffc, \"OB\", \"Data Set Trailing Padding\" },\n    { 0xfffe, 0xe000, \"!!\", \"Item\" },\n    { 0xfffe, 0xe00d, \"!!\", \"Item Delimitation Item\" },\n    { 0xfffe, 0xe0dd, \"!!\", \"Sequence Delimitation Item\" },\n    { 0xffff, 0xffff, \"xs\", (char *) NULL }\n  };\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D C M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDCM() returns MagickTrue if the image format type, identified by the\n%  magick string, is DCM.\n%\n%  The format of the IsDCM method is:\n%\n%      MagickBooleanType IsDCM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDCM(const unsigned char *magick,const size_t length)\n{\n  if (length < 132)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) (magick+128),\"DICM\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d D C M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadDCMImage() reads a Digital Imaging and Communications in Medicine\n%  (DICOM) file and returns it.  It allocates the memory necessary for the\n%  new Image structure and returns a pointer to the new image.\n%\n%  The format of the ReadDCMImage method is:\n%\n%      Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\ntypedef struct _DCMInfo\n{\n  MagickBooleanType\n    polarity;\n\n  Quantum\n    *scale;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    depth,\n    mask,\n    max_value,\n    samples_per_pixel,\n    scale_size,\n    signed_data,\n    significant_bits,\n    width,\n    height;\n\n  MagickBooleanType\n    rescale;\n\n  double\n    rescale_intercept,\n    rescale_slope,\n    window_center,\n    window_width;\n} DCMInfo;\n\ntypedef struct _DCMStreamInfo\n{\n  size_t\n    remaining,\n    segment_count;\n\n  ssize_t\n    segments[15];\n\n  size_t\n    offset_count;\n\n  ssize_t\n    *offsets;\n\n  ssize_t\n    count;\n\n  int\n    byte;\n} DCMStreamInfo;\n\ntypedef struct _DCMMap\n{\n  int\n    *blue,\n    *green,\n    *gray,\n    *red;\n} DCMMap;\n\nstatic int ReadDCMByte(DCMStreamInfo *stream_info,Image *image)\n{\n  if (image->compression != RLECompression)\n    return(ReadBlobByte(image));\n  if (stream_info->count == 0)\n    {\n      int\n        byte;\n\n      ssize_t\n        count;\n\n      if (stream_info->remaining <= 2)\n        stream_info->remaining=0;\n      else\n        stream_info->remaining-=2;\n      count=(ssize_t) ReadBlobByte(image);\n      byte=ReadBlobByte(image);\n      if (count == 128)\n        return(0);\n      else\n        if (count < 128)\n          {\n            /*\n              Literal bytes.\n            */\n            stream_info->count=count;\n            stream_info->byte=(-1);\n            return(byte);\n          }\n        else\n          {\n            /*\n              Repeated bytes.\n            */\n            stream_info->count=256-count;\n            stream_info->byte=byte;\n            return(byte);\n          }\n    }\n  stream_info->count--;\n  if (stream_info->byte >= 0)\n    return(stream_info->byte);\n  if (stream_info->remaining > 0)\n    stream_info->remaining--;\n  return(ReadBlobByte(image));\n}\n\nstatic unsigned short ReadDCMShort(DCMStreamInfo *stream_info,Image *image)\n{\n  int\n    shift,\n    byte;\n\n  unsigned short\n    value;\n\n  if (image->compression != RLECompression)\n    return(ReadBlobLSBShort(image));\n  shift=image->depth < 16 ? 4 : 8;\n  value=(unsigned short) ReadDCMByte(stream_info,image);\n  byte=ReadDCMByte(stream_info,image);\n  if (byte < 0)\n    return(0);\n  value|=(unsigned short) (byte << shift);\n  return(value);\n}\n\nstatic signed short ReadDCMSignedShort(DCMStreamInfo *stream_info,Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadDCMShort(stream_info,image);\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,\n  DCMStreamInfo *stream_info,MagickBooleanType first_segment,\n  ExceptionInfo *exception)\n{\n  int\n    byte,\n    index;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    pixel;\n\n  ssize_t\n    i,\n    x;\n\n  Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Convert DCM Medical image to pixel packets.\n  */\n  byte=0;\n  i=0;\n  status=MagickTrue;\n  (void) memset(&pixel,0,sizeof(pixel));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (info->samples_per_pixel == 1)\n        {\n          int\n            pixel_value;\n\n          if (info->bytes_per_pixel == 1)\n            pixel_value=info->polarity != MagickFalse ?\n              ((int) info->max_value-ReadDCMByte(stream_info,image)) :\n              ReadDCMByte(stream_info,image);\n          else\n            if ((info->bits_allocated != 12) || (info->significant_bits != 12))\n              {\n                if (info->signed_data != 0)\n                  pixel_value=ReadDCMSignedShort(stream_info,image);\n                else\n                  pixel_value=(int) ReadDCMShort(stream_info,image);\n                if (info->polarity != MagickFalse)\n                  pixel_value=(int)info->max_value-pixel_value;\n              }\n            else\n              {\n                if ((i & 0x01) != 0)\n                  {\n                    pixel_value=byte;\n                    byte=ReadDCMByte(stream_info,image);\n                    if (byte >= 0)\n                      pixel_value|=(byte << 8);\n                  }\n                else\n                  {\n                    pixel_value=ReadDCMSignedShort(stream_info,image);\n                    byte=(int) (pixel_value & 0x0f);\n                    pixel_value>>=4;\n                  }\n                i++;\n              }\n          if (info->signed_data == 1)\n            pixel_value-=32767;\n          index=pixel_value;\n          if (info->rescale != MagickFalse)\n            {\n              double\n                scaled_value;\n\n              scaled_value=pixel_value*info->rescale_slope+\n                info->rescale_intercept;\n              index=(int) scaled_value;\n              if (info->window_width != 0)\n                {\n                  double\n                    window_max,\n                    window_min;\n\n                  window_min=ceil(info->window_center-\n                    (info->window_width-1.0)/2.0-0.5);\n                  window_max=floor(info->window_center+\n                    (info->window_width-1.0)/2.0+0.5);\n                  if (scaled_value <= window_min)\n                    index=0;\n                  else\n                    if (scaled_value > window_max)\n                      index=(int) info->max_value;\n                    else\n                      index=(int) (info->max_value*(((scaled_value-\n                        info->window_center-0.5)/(info->window_width-1))+0.5));\n                }\n            }\n          index&=info->mask;\n          index=(int) ConstrainColormapIndex(image,(ssize_t) index,exception);\n          if (first_segment != MagickFalse)\n            SetPixelIndex(image,(Quantum) index,q);\n          else\n            SetPixelIndex(image,(Quantum) (((size_t) index) |\n              (((size_t) GetPixelIndex(image,q)) << 8)),q);\n          pixel.red=(unsigned int) image->colormap[index].red;\n          pixel.green=(unsigned int) image->colormap[index].green;\n          pixel.blue=(unsigned int) image->colormap[index].blue;\n        }\n      else\n        {\n          if (info->bytes_per_pixel == 1)\n            {\n              pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n            }\n          else\n            {\n              pixel.red=ReadDCMShort(stream_info,image);\n              pixel.green=ReadDCMShort(stream_info,image);\n              pixel.blue=ReadDCMShort(stream_info,image);\n            }\n          pixel.red&=info->mask;\n          pixel.green&=info->mask;\n          pixel.blue&=info->mask;\n          if (info->scale != (Quantum *) NULL)\n            {\n              if ((MagickSizeType) pixel.red <= GetQuantumRange(info->depth))\n                pixel.red=(unsigned int) info->scale[pixel.red];\n              if ((MagickSizeType) pixel.green <= GetQuantumRange(info->depth))\n                pixel.green=(unsigned int) info->scale[pixel.green];\n              if ((MagickSizeType) pixel.blue <= GetQuantumRange(info->depth))\n                pixel.blue=(unsigned int) info->scale[pixel.blue];\n            }\n        }\n      if (first_segment != MagickFalse)\n        {\n          SetPixelRed(image,(Quantum) pixel.red,q);\n          SetPixelGreen(image,(Quantum) pixel.green,q);\n          SetPixelBlue(image,(Quantum) pixel.blue,q);\n        }\n      else\n        {\n          SetPixelRed(image,(Quantum) (((size_t) pixel.red) |\n            (((size_t) GetPixelRed(image,q)) << 8)),q);\n          SetPixelGreen(image,(Quantum) (((size_t) pixel.green) |\n            (((size_t) GetPixelGreen(image,q)) << 8)),q);\n          SetPixelBlue(image,(Quantum) (((size_t) pixel.blue) |\n            (((size_t) GetPixelBlue(image,q)) << 8)),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  return(status);\n}\n\nstatic void *RelinquishDCMInfo(void *memory)\n{\n  DCMInfo\n    *info;\n\n  info=(DCMInfo *) memory;\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  return(RelinquishMagickMemory(info));\n}\n\nstatic inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}\n\nstatic Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info,\n    *info_copy;\n\n  DCMMap\n    map;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    datum;\n\n  LinkedListInfo\n    *stack;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    blob_size,\n    offset;\n\n  unsigned char\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    colors,\n    length,\n    number_scenes,\n    quantum,\n    status;\n\n  ssize_t\n    count,\n    scene,\n    sequence_depth;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  (void) memset(&map,0,sizeof(map));\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  sequence_depth=0;\n  stack=NewLinkedList(256);\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry=MagickFalse;\n  blob_size=(MagickOffsetType) GetBlobSize(image);\n  while (TellBlob(image) < blob_size)\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((int) ((unsigned char) *explicit_vr)) != 0) &&\n          (isupper((int) ((unsigned char) *(explicit_vr+1))) != 0) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strcmp(explicit_vr,\"OB\") == 0) ||\n              (strcmp(explicit_vr,\"OW\") == 0) ||\n              (strcmp(explicit_vr,\"OF\") == 0) ||\n              (strcmp(explicit_vr,\"SQ\") == 0) ||\n              (strcmp(explicit_vr,\"UN\") == 0) ||\n              (strcmp(explicit_vr,\"UT\") == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      if ((group == 0xFFFE) && (element == 0xE0DD))\n        {\n          /*\n            If we're exiting a sequence, restore the previous image parameters,\n            effectively undoing any parameter changes that happened inside the\n            sequence.\n          */\n          sequence_depth--;\n          info_copy=(DCMInfo *) RemoveLastElementFromLinkedList(stack);\n          if (info_copy == (DCMInfo *)NULL)\n            {\n              /*\n                The sequence's entry and exit points don't line up (tried to\n                exit one more sequence than we entered).\n              */\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          if (info.scale != (Quantum *) NULL)\n            info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n          (void) memcpy(&info,info_copy,sizeof(info));\n          info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n        }\n      if (strcmp(explicit_vr,\"SQ\") == 0)\n        {\n          /*\n            If we're entering a sequence, push the current image parameters\n            onto the stack, so we can restore them at the end of the sequence.\n          */\n          info_copy=(DCMInfo *) AcquireMagickMemory(sizeof(info));\n          if (info_copy == (DCMInfo *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          (void) memcpy(info_copy,&info,sizeof(info));\n          info_copy->scale=(Quantum *) AcquireQuantumMemory(\n            info_copy->scale_size,sizeof(*info_copy->scale));\n          if (info_copy->scale == (Quantum *) NULL)\n            {\n              info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            }\n          (void) memcpy(info_copy->scale,info.scale,info_copy->scale_size*\n            sizeof(*info_copy->scale));\n          AppendValueToLinkedList(stack,info_copy);\n          sequence_depth++;\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\n            \"0x%04lX %4ld S%ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,(long) sequence_depth,\n            implicit_vr,explicit_vr,(unsigned long) group,\n            (unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\")\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\")\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\")\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\")\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              info.height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              info.width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.gray != (int *) NULL)\n                map.gray=(int *) RelinquishMagickMemory(map.gray);\n              map.gray=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.gray));\n              if (map.gray == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.gray,0,MagickMax(colors,65536)*\n                sizeof(*map.gray));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  map.gray[i]=(int) data[i];\n                else\n                  map.gray[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.red != (int *) NULL)\n                map.red=(int *) RelinquishMagickMemory(map.red);\n              map.red=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.red));\n              if (map.red == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.red,0,MagickMax(colors,65536)*\n                sizeof(*map.red));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.red[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.green != (int *) NULL)\n                map.green=(int *) RelinquishMagickMemory(map.green);\n              map.green=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.green));\n              if (map.green == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.green,0,MagickMax(colors,65536)*\n                sizeof(*map.green));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.green[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.blue != (int *) NULL)\n                map.blue=(int *) RelinquishMagickMemory(map.blue);\n              map.blue=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.blue));\n              if (map.blue == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.blue,0,MagickMax(colors,65536)*\n                sizeof(*map.blue));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.blue[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != 0)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          group=0xfffc;\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((info.width == 0) || (info.height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    image->columns=info.width;\n    image->rows=info.height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (length > (size_t) GetBlobSize(image))\n            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n          if (EOFBlob(image) != MagickFalse)\n            {\n              status=MagickFalse;\n              break;\n            }\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              status=MagickFalse;\n              break;\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n        image=DestroyImageList(image);\n        if ((status == MagickFalse) && (exception->severity < ErrorException))\n          ThrowDCMException(CorruptImageError,\"CorruptImageError\")\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale_size=MagickMax(length,MaxMap)+1;\n        info.scale=(Quantum *) AcquireQuantumMemory(info.scale_size,\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n        (void) memset(info.scale,0,(MagickMax(length,MaxMap)+1)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              offset=(MagickOffsetType) ReadBlobLSBSignedLong(image);\n              if (offset > (MagickOffsetType) GetBlobSize(image))\n                ThrowDCMException(CorruptImageError,\n                  \"InsufficientImageDataInFile\")\n              stream_info->offsets[i]=(ssize_t) offset;\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=info.width;\n      image->rows=info.height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          if (map.red != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.red[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (map.green != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.green[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (map.blue != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.blue[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (map.gray != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.gray[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          Quantum\n            *q;\n\n          ssize_t\n            x,\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (IdentifyImageCoderGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r D C M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterDCMImage() adds attributes for the DCM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterDCMImage method is:\n%\n%      size_t RegisterDCMImage(void)\n%\n*/\nModuleExport size_t RegisterDCMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  static const char\n    *DCMNote=\n    {\n      \"DICOM is used by the medical community for images like X-rays.  The\\n\"\n      \"specification, \\\"Digital Imaging and Communications in Medicine\\n\"\n      \"(DICOM)\\\", is available at http://medical.nema.org/.  In particular,\\n\"\n      \"see part 5 which describes the image encoding (RLE, JPEG, JPEG-LS),\\n\"\n      \"and supplement 61 which adds JPEG-2000 encoding.\"\n    };\n\n  entry=AcquireMagickInfo(\"DCM\",\"DCM\",\n    \"Digital Imaging and Communications in Medicine image\");\n  entry->decoder=(DecodeImageHandler *) ReadDCMImage;\n  entry->magick=(IsImageFormatHandler *) IsDCM;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->note=ConstantString(DCMNote);\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r D C M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterDCMImage() removes format registrations made by the\n%  DCM module from the list of supported formats.\n%\n%  The format of the UnregisterDCMImage method is:\n%\n%      UnregisterDCMImage(void)\n%\n*/\nModuleExport void UnregisterDCMImage(void)\n{\n  (void) UnregisterMagickInfo(\"DCM\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            DDDD    CCCC  M   M                              %\n%                            D   D  C      MM MM                              %\n%                            D   D  C      M M M                              %\n%                            D   D  C      M   M                              %\n%                            DDDD    CCCC  M   M                              %\n%                                                                             %\n%                                                                             %\n%                          Read DICOM Image Format                            %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"coders/coders-private.h\"\n\f\n/*\n  Dicom medical image declarations.\n*/\n\ntypedef struct _DicomInfo\n{\n  const unsigned short\n    group,\n    element;\n\n  const char\n    *vr,\n    *description;\n} DicomInfo;\n\nstatic const DicomInfo\n  dicom_info[] =\n  {\n    { 0x0000, 0x0000, \"UL\", \"Group Length\" },\n    { 0x0000, 0x0001, \"UL\", \"Command Length to End\" },\n    { 0x0000, 0x0002, \"UI\", \"Affected SOP Class UID\" },\n    { 0x0000, 0x0003, \"UI\", \"Requested SOP Class UID\" },\n    { 0x0000, 0x0010, \"LO\", \"Command Recognition Code\" },\n    { 0x0000, 0x0100, \"US\", \"Command Field\" },\n    { 0x0000, 0x0110, \"US\", \"Message ID\" },\n    { 0x0000, 0x0120, \"US\", \"Message ID Being Responded To\" },\n    { 0x0000, 0x0200, \"AE\", \"Initiator\" },\n    { 0x0000, 0x0300, \"AE\", \"Receiver\" },\n    { 0x0000, 0x0400, \"AE\", \"Find Location\" },\n    { 0x0000, 0x0600, \"AE\", \"Move Destination\" },\n    { 0x0000, 0x0700, \"US\", \"Priority\" },\n    { 0x0000, 0x0800, \"US\", \"Data Set Type\" },\n    { 0x0000, 0x0850, \"US\", \"Number of Matches\" },\n    { 0x0000, 0x0860, \"US\", \"Response Sequence Number\" },\n    { 0x0000, 0x0900, \"US\", \"Status\" },\n    { 0x0000, 0x0901, \"AT\", \"Offending Element\" },\n    { 0x0000, 0x0902, \"LO\", \"Exception Comment\" },\n    { 0x0000, 0x0903, \"US\", \"Exception ID\" },\n    { 0x0000, 0x1000, \"UI\", \"Affected SOP Instance UID\" },\n    { 0x0000, 0x1001, \"UI\", \"Requested SOP Instance UID\" },\n    { 0x0000, 0x1002, \"US\", \"Event Type ID\" },\n    { 0x0000, 0x1005, \"AT\", \"Attribute Identifier List\" },\n    { 0x0000, 0x1008, \"US\", \"Action Type ID\" },\n    { 0x0000, 0x1020, \"US\", \"Number of Remaining Suboperations\" },\n    { 0x0000, 0x1021, \"US\", \"Number of Completed Suboperations\" },\n    { 0x0000, 0x1022, \"US\", \"Number of Failed Suboperations\" },\n    { 0x0000, 0x1023, \"US\", \"Number of Warning Suboperations\" },\n    { 0x0000, 0x1030, \"AE\", \"Move Originator Application Entity Title\" },\n    { 0x0000, 0x1031, \"US\", \"Move Originator Message ID\" },\n    { 0x0000, 0x4000, \"LO\", \"Dialog Receiver\" },\n    { 0x0000, 0x4010, \"LO\", \"Terminal Type\" },\n    { 0x0000, 0x5010, \"SH\", \"Message Set ID\" },\n    { 0x0000, 0x5020, \"SH\", \"End Message Set\" },\n    { 0x0000, 0x5110, \"LO\", \"Display Format\" },\n    { 0x0000, 0x5120, \"LO\", \"Page Position ID\" },\n    { 0x0000, 0x5130, \"LO\", \"Text Format ID\" },\n    { 0x0000, 0x5140, \"LO\", \"Normal Reverse\" },\n    { 0x0000, 0x5150, \"LO\", \"Add Gray Scale\" },\n    { 0x0000, 0x5160, \"LO\", \"Borders\" },\n    { 0x0000, 0x5170, \"IS\", \"Copies\" },\n    { 0x0000, 0x5180, \"LO\", \"OldMagnificationType\" },\n    { 0x0000, 0x5190, \"LO\", \"Erase\" },\n    { 0x0000, 0x51a0, \"LO\", \"Print\" },\n    { 0x0000, 0x51b0, \"US\", \"Overlays\" },\n    { 0x0002, 0x0000, \"UL\", \"Meta Element Group Length\" },\n    { 0x0002, 0x0001, \"OB\", \"File Meta Information Version\" },\n    { 0x0002, 0x0002, \"UI\", \"Media Storage SOP Class UID\" },\n    { 0x0002, 0x0003, \"UI\", \"Media Storage SOP Instance UID\" },\n    { 0x0002, 0x0010, \"UI\", \"Transfer Syntax UID\" },\n    { 0x0002, 0x0012, \"UI\", \"Implementation Class UID\" },\n    { 0x0002, 0x0013, \"SH\", \"Implementation Version Name\" },\n    { 0x0002, 0x0016, \"AE\", \"Source Application Entity Title\" },\n    { 0x0002, 0x0100, \"UI\", \"Private Information Creator UID\" },\n    { 0x0002, 0x0102, \"OB\", \"Private Information\" },\n    { 0x0003, 0x0000, \"US\", \"?\" },\n    { 0x0003, 0x0008, \"US\", \"ISI Command Field\" },\n    { 0x0003, 0x0011, \"US\", \"Attach ID Application Code\" },\n    { 0x0003, 0x0012, \"UL\", \"Attach ID Message Count\" },\n    { 0x0003, 0x0013, \"DA\", \"Attach ID Date\" },\n    { 0x0003, 0x0014, \"TM\", \"Attach ID Time\" },\n    { 0x0003, 0x0020, \"US\", \"Message Type\" },\n    { 0x0003, 0x0030, \"DA\", \"Max Waiting Date\" },\n    { 0x0003, 0x0031, \"TM\", \"Max Waiting Time\" },\n    { 0x0004, 0x0000, \"UL\", \"File Set Group Length\" },\n    { 0x0004, 0x1130, \"CS\", \"File Set ID\" },\n    { 0x0004, 0x1141, \"CS\", \"File Set Descriptor File ID\" },\n    { 0x0004, 0x1142, \"CS\", \"File Set Descriptor File Specific Character Set\" },\n    { 0x0004, 0x1200, \"UL\", \"Root Directory Entity First Directory Record Offset\" },\n    { 0x0004, 0x1202, \"UL\", \"Root Directory Entity Last Directory Record Offset\" },\n    { 0x0004, 0x1212, \"US\", \"File Set Consistency Flag\" },\n    { 0x0004, 0x1220, \"SQ\", \"Directory Record Sequence\" },\n    { 0x0004, 0x1400, \"UL\", \"Next Directory Record Offset\" },\n    { 0x0004, 0x1410, \"US\", \"Record In Use Flag\" },\n    { 0x0004, 0x1420, \"UL\", \"Referenced Lower Level Directory Entity Offset\" },\n    { 0x0004, 0x1430, \"CS\", \"Directory Record Type\" },\n    { 0x0004, 0x1432, \"UI\", \"Private Record UID\" },\n    { 0x0004, 0x1500, \"CS\", \"Referenced File ID\" },\n    { 0x0004, 0x1504, \"UL\", \"MRDR Directory Record Offset\" },\n    { 0x0004, 0x1510, \"UI\", \"Referenced SOP Class UID In File\" },\n    { 0x0004, 0x1511, \"UI\", \"Referenced SOP Instance UID In File\" },\n    { 0x0004, 0x1512, \"UI\", \"Referenced Transfer Syntax UID In File\" },\n    { 0x0004, 0x1600, \"UL\", \"Number of References\" },\n    { 0x0005, 0x0000, \"US\", \"?\" },\n    { 0x0006, 0x0000, \"US\", \"?\" },\n    { 0x0008, 0x0000, \"UL\", \"Identifying Group Length\" },\n    { 0x0008, 0x0001, \"UL\", \"Length to End\" },\n    { 0x0008, 0x0005, \"CS\", \"Specific Character Set\" },\n    { 0x0008, 0x0008, \"CS\", \"Image Type\" },\n    { 0x0008, 0x0010, \"LO\", \"Recognition Code\" },\n    { 0x0008, 0x0012, \"DA\", \"Instance Creation Date\" },\n    { 0x0008, 0x0013, \"TM\", \"Instance Creation Time\" },\n    { 0x0008, 0x0014, \"UI\", \"Instance Creator UID\" },\n    { 0x0008, 0x0016, \"UI\", \"SOP Class UID\" },\n    { 0x0008, 0x0018, \"UI\", \"SOP Instance UID\" },\n    { 0x0008, 0x0020, \"DA\", \"Study Date\" },\n    { 0x0008, 0x0021, \"DA\", \"Series Date\" },\n    { 0x0008, 0x0022, \"DA\", \"Acquisition Date\" },\n    { 0x0008, 0x0023, \"DA\", \"Image Date\" },\n    { 0x0008, 0x0024, \"DA\", \"Overlay Date\" },\n    { 0x0008, 0x0025, \"DA\", \"Curve Date\" },\n    { 0x0008, 0x002A, \"DT\", \"Acquisition DateTime\" },\n    { 0x0008, 0x0030, \"TM\", \"Study Time\" },\n    { 0x0008, 0x0031, \"TM\", \"Series Time\" },\n    { 0x0008, 0x0032, \"TM\", \"Acquisition Time\" },\n    { 0x0008, 0x0033, \"TM\", \"Image Time\" },\n    { 0x0008, 0x0034, \"TM\", \"Overlay Time\" },\n    { 0x0008, 0x0035, \"TM\", \"Curve Time\" },\n    { 0x0008, 0x0040, \"xs\", \"Old Data Set Type\" },\n    { 0x0008, 0x0041, \"xs\", \"Old Data Set Subtype\" },\n    { 0x0008, 0x0042, \"CS\", \"Nuclear Medicine Series Type\" },\n    { 0x0008, 0x0050, \"SH\", \"Accession Number\" },\n    { 0x0008, 0x0052, \"CS\", \"Query/Retrieve Level\" },\n    { 0x0008, 0x0054, \"AE\", \"Retrieve AE Title\" },\n    { 0x0008, 0x0058, \"UI\", \"Failed SOP Instance UID List\" },\n    { 0x0008, 0x0060, \"CS\", \"Modality\" },\n    { 0x0008, 0x0062, \"SQ\", \"Modality Subtype\" },\n    { 0x0008, 0x0064, \"CS\", \"Conversion Type\" },\n    { 0x0008, 0x0068, \"CS\", \"Presentation Intent Type\" },\n    { 0x0008, 0x0070, \"LO\", \"Manufacturer\" },\n    { 0x0008, 0x0080, \"LO\", \"Institution Name\" },\n    { 0x0008, 0x0081, \"ST\", \"Institution Address\" },\n    { 0x0008, 0x0082, \"SQ\", \"Institution Code Sequence\" },\n    { 0x0008, 0x0090, \"PN\", \"Referring Physician's Name\" },\n    { 0x0008, 0x0092, \"ST\", \"Referring Physician's Address\" },\n    { 0x0008, 0x0094, \"SH\", \"Referring Physician's Telephone Numbers\" },\n    { 0x0008, 0x0100, \"SH\", \"Code Value\" },\n    { 0x0008, 0x0102, \"SH\", \"Coding Scheme Designator\" },\n    { 0x0008, 0x0103, \"SH\", \"Coding Scheme Version\" },\n    { 0x0008, 0x0104, \"LO\", \"Code Meaning\" },\n    { 0x0008, 0x0105, \"CS\", \"Mapping Resource\" },\n    { 0x0008, 0x0106, \"DT\", \"Context Group Version\" },\n    { 0x0008, 0x010b, \"CS\", \"Code Set Extension Flag\" },\n    { 0x0008, 0x010c, \"UI\", \"Private Coding Scheme Creator UID\" },\n    { 0x0008, 0x010d, \"UI\", \"Code Set Extension Creator UID\" },\n    { 0x0008, 0x010f, \"CS\", \"Context Identifier\" },\n    { 0x0008, 0x1000, \"LT\", \"Network ID\" },\n    { 0x0008, 0x1010, \"SH\", \"Station Name\" },\n    { 0x0008, 0x1030, \"LO\", \"Study Description\" },\n    { 0x0008, 0x1032, \"SQ\", \"Procedure Code Sequence\" },\n    { 0x0008, 0x103e, \"LO\", \"Series Description\" },\n    { 0x0008, 0x1040, \"LO\", \"Institutional Department Name\" },\n    { 0x0008, 0x1048, \"PN\", \"Physician of Record\" },\n    { 0x0008, 0x1050, \"PN\", \"Performing Physician's Name\" },\n    { 0x0008, 0x1060, \"PN\", \"Name of Physician(s) Reading Study\" },\n    { 0x0008, 0x1070, \"PN\", \"Operator's Name\" },\n    { 0x0008, 0x1080, \"LO\", \"Admitting Diagnosis Description\" },\n    { 0x0008, 0x1084, \"SQ\", \"Admitting Diagnosis Code Sequence\" },\n    { 0x0008, 0x1090, \"LO\", \"Manufacturer's Model Name\" },\n    { 0x0008, 0x1100, \"SQ\", \"Referenced Results Sequence\" },\n    { 0x0008, 0x1110, \"SQ\", \"Referenced Study Sequence\" },\n    { 0x0008, 0x1111, \"SQ\", \"Referenced Study Component Sequence\" },\n    { 0x0008, 0x1115, \"SQ\", \"Referenced Series Sequence\" },\n    { 0x0008, 0x1120, \"SQ\", \"Referenced Patient Sequence\" },\n    { 0x0008, 0x1125, \"SQ\", \"Referenced Visit Sequence\" },\n    { 0x0008, 0x1130, \"SQ\", \"Referenced Overlay Sequence\" },\n    { 0x0008, 0x1140, \"SQ\", \"Referenced Image Sequence\" },\n    { 0x0008, 0x1145, \"SQ\", \"Referenced Curve Sequence\" },\n    { 0x0008, 0x1148, \"SQ\", \"Referenced Previous Waveform\" },\n    { 0x0008, 0x114a, \"SQ\", \"Referenced Simultaneous Waveforms\" },\n    { 0x0008, 0x114c, \"SQ\", \"Referenced Subsequent Waveform\" },\n    { 0x0008, 0x1150, \"UI\", \"Referenced SOP Class UID\" },\n    { 0x0008, 0x1155, \"UI\", \"Referenced SOP Instance UID\" },\n    { 0x0008, 0x1160, \"IS\", \"Referenced Frame Number\" },\n    { 0x0008, 0x1195, \"UI\", \"Transaction UID\" },\n    { 0x0008, 0x1197, \"US\", \"Failure Reason\" },\n    { 0x0008, 0x1198, \"SQ\", \"Failed SOP Sequence\" },\n    { 0x0008, 0x1199, \"SQ\", \"Referenced SOP Sequence\" },\n    { 0x0008, 0x2110, \"CS\", \"Old Lossy Image Compression\" },\n    { 0x0008, 0x2111, \"ST\", \"Derivation Description\" },\n    { 0x0008, 0x2112, \"SQ\", \"Source Image Sequence\" },\n    { 0x0008, 0x2120, \"SH\", \"Stage Name\" },\n    { 0x0008, 0x2122, \"IS\", \"Stage Number\" },\n    { 0x0008, 0x2124, \"IS\", \"Number of Stages\" },\n    { 0x0008, 0x2128, \"IS\", \"View Number\" },\n    { 0x0008, 0x2129, \"IS\", \"Number of Event Timers\" },\n    { 0x0008, 0x212a, \"IS\", \"Number of Views in Stage\" },\n    { 0x0008, 0x2130, \"DS\", \"Event Elapsed Time(s)\" },\n    { 0x0008, 0x2132, \"LO\", \"Event Timer Name(s)\" },\n    { 0x0008, 0x2142, \"IS\", \"Start Trim\" },\n    { 0x0008, 0x2143, \"IS\", \"Stop Trim\" },\n    { 0x0008, 0x2144, \"IS\", \"Recommended Display Frame Rate\" },\n    { 0x0008, 0x2200, \"CS\", \"Transducer Position\" },\n    { 0x0008, 0x2204, \"CS\", \"Transducer Orientation\" },\n    { 0x0008, 0x2208, \"CS\", \"Anatomic Structure\" },\n    { 0x0008, 0x2218, \"SQ\", \"Anatomic Region Sequence\" },\n    { 0x0008, 0x2220, \"SQ\", \"Anatomic Region Modifier Sequence\" },\n    { 0x0008, 0x2228, \"SQ\", \"Primary Anatomic Structure Sequence\" },\n    { 0x0008, 0x2230, \"SQ\", \"Primary Anatomic Structure Modifier Sequence\" },\n    { 0x0008, 0x2240, \"SQ\", \"Transducer Position Sequence\" },\n    { 0x0008, 0x2242, \"SQ\", \"Transducer Position Modifier Sequence\" },\n    { 0x0008, 0x2244, \"SQ\", \"Transducer Orientation Sequence\" },\n    { 0x0008, 0x2246, \"SQ\", \"Transducer Orientation Modifier Sequence\" },\n    { 0x0008, 0x2251, \"SQ\", \"Anatomic Structure Space Or Region Code Sequence\" },\n    { 0x0008, 0x2253, \"SQ\", \"Anatomic Portal Of Entrance Code Sequence\" },\n    { 0x0008, 0x2255, \"SQ\", \"Anatomic Approach Direction Code Sequence\" },\n    { 0x0008, 0x2256, \"ST\", \"Anatomic Perspective Description\" },\n    { 0x0008, 0x2257, \"SQ\", \"Anatomic Perspective Code Sequence\" },\n    { 0x0008, 0x2258, \"ST\", \"Anatomic Location Of Examining Instrument Description\" },\n    { 0x0008, 0x2259, \"SQ\", \"Anatomic Location Of Examining Instrument Code Sequence\" },\n    { 0x0008, 0x225a, \"SQ\", \"Anatomic Structure Space Or Region Modifier Code Sequence\" },\n    { 0x0008, 0x225c, \"SQ\", \"OnAxis Background Anatomic Structure Code Sequence\" },\n    { 0x0008, 0x4000, \"LT\", \"Identifying Comments\" },\n    { 0x0009, 0x0000, \"xs\", \"?\" },\n    { 0x0009, 0x0001, \"xs\", \"?\" },\n    { 0x0009, 0x0002, \"xs\", \"?\" },\n    { 0x0009, 0x0003, \"xs\", \"?\" },\n    { 0x0009, 0x0004, \"xs\", \"?\" },\n    { 0x0009, 0x0005, \"UN\", \"?\" },\n    { 0x0009, 0x0006, \"UN\", \"?\" },\n    { 0x0009, 0x0007, \"UN\", \"?\" },\n    { 0x0009, 0x0008, \"xs\", \"?\" },\n    { 0x0009, 0x0009, \"LT\", \"?\" },\n    { 0x0009, 0x000a, \"IS\", \"?\" },\n    { 0x0009, 0x000b, \"IS\", \"?\" },\n    { 0x0009, 0x000c, \"IS\", \"?\" },\n    { 0x0009, 0x000d, \"IS\", \"?\" },\n    { 0x0009, 0x000e, \"IS\", \"?\" },\n    { 0x0009, 0x000f, \"UN\", \"?\" },\n    { 0x0009, 0x0010, \"xs\", \"?\" },\n    { 0x0009, 0x0011, \"xs\", \"?\" },\n    { 0x0009, 0x0012, \"xs\", \"?\" },\n    { 0x0009, 0x0013, \"xs\", \"?\" },\n    { 0x0009, 0x0014, \"xs\", \"?\" },\n    { 0x0009, 0x0015, \"xs\", \"?\" },\n    { 0x0009, 0x0016, \"xs\", \"?\" },\n    { 0x0009, 0x0017, \"LT\", \"?\" },\n    { 0x0009, 0x0018, \"LT\", \"Data Set Identifier\" },\n    { 0x0009, 0x001a, \"US\", \"?\" },\n    { 0x0009, 0x001e, \"UI\", \"?\" },\n    { 0x0009, 0x0020, \"xs\", \"?\" },\n    { 0x0009, 0x0021, \"xs\", \"?\" },\n    { 0x0009, 0x0022, \"SH\", \"User Orientation\" },\n    { 0x0009, 0x0023, \"SL\", \"Initiation Type\" },\n    { 0x0009, 0x0024, \"xs\", \"?\" },\n    { 0x0009, 0x0025, \"xs\", \"?\" },\n    { 0x0009, 0x0026, \"xs\", \"?\" },\n    { 0x0009, 0x0027, \"xs\", \"?\" },\n    { 0x0009, 0x0029, \"xs\", \"?\" },\n    { 0x0009, 0x002a, \"SL\", \"?\" },\n    { 0x0009, 0x002c, \"LO\", \"Series Comments\" },\n    { 0x0009, 0x002d, \"SL\", \"Track Beat Average\" },\n    { 0x0009, 0x002e, \"FD\", \"Distance Prescribed\" },\n    { 0x0009, 0x002f, \"LT\", \"?\" },\n    { 0x0009, 0x0030, \"xs\", \"?\" },\n    { 0x0009, 0x0031, \"xs\", \"?\" },\n    { 0x0009, 0x0032, \"LT\", \"?\" },\n    { 0x0009, 0x0034, \"xs\", \"?\" },\n    { 0x0009, 0x0035, \"SL\", \"Gantry Locus Type\" },\n    { 0x0009, 0x0037, \"SL\", \"Starting Heart Rate\" },\n    { 0x0009, 0x0038, \"xs\", \"?\" },\n    { 0x0009, 0x0039, \"SL\", \"RR Window Offset\" },\n    { 0x0009, 0x003a, \"SL\", \"Percent Cycle Imaged\" },\n    { 0x0009, 0x003e, \"US\", \"?\" },\n    { 0x0009, 0x003f, \"US\", \"?\" },\n    { 0x0009, 0x0040, \"xs\", \"?\" },\n    { 0x0009, 0x0041, \"xs\", \"?\" },\n    { 0x0009, 0x0042, \"xs\", \"?\" },\n    { 0x0009, 0x0043, \"xs\", \"?\" },\n    { 0x0009, 0x0050, \"LT\", \"?\" },\n    { 0x0009, 0x0051, \"xs\", \"?\" },\n    { 0x0009, 0x0060, \"LT\", \"?\" },\n    { 0x0009, 0x0061, \"LT\", \"Series Unique Identifier\" },\n    { 0x0009, 0x0070, \"LT\", \"?\" },\n    { 0x0009, 0x0080, \"LT\", \"?\" },\n    { 0x0009, 0x0091, \"LT\", \"?\" },\n    { 0x0009, 0x00e2, \"LT\", \"?\" },\n    { 0x0009, 0x00e3, \"UI\", \"Equipment UID\" },\n    { 0x0009, 0x00e6, \"SH\", \"Genesis Version Now\" },\n    { 0x0009, 0x00e7, \"UL\", \"Exam Record Checksum\" },\n    { 0x0009, 0x00e8, \"UL\", \"?\" },\n    { 0x0009, 0x00e9, \"SL\", \"Actual Series Data Time Stamp\" },\n    { 0x0009, 0x00f2, \"UN\", \"?\" },\n    { 0x0009, 0x00f3, \"UN\", \"?\" },\n    { 0x0009, 0x00f4, \"LT\", \"?\" },\n    { 0x0009, 0x00f5, \"xs\", \"?\" },\n    { 0x0009, 0x00f6, \"LT\", \"PDM Data Object Type Extension\" },\n    { 0x0009, 0x00f8, \"US\", \"?\" },\n    { 0x0009, 0x00fb, \"IS\", \"?\" },\n    { 0x0009, 0x1002, \"OB\", \"?\" },\n    { 0x0009, 0x1003, \"OB\", \"?\" },\n    { 0x0009, 0x1010, \"UN\", \"?\" },\n    { 0x0010, 0x0000, \"UL\", \"Patient Group Length\" },\n    { 0x0010, 0x0010, \"PN\", \"Patient's Name\" },\n    { 0x0010, 0x0020, \"LO\", \"Patient's ID\" },\n    { 0x0010, 0x0021, \"LO\", \"Issuer of Patient's ID\" },\n    { 0x0010, 0x0030, \"DA\", \"Patient's Birth Date\" },\n    { 0x0010, 0x0032, \"TM\", \"Patient's Birth Time\" },\n    { 0x0010, 0x0040, \"CS\", \"Patient's Sex\" },\n    { 0x0010, 0x0050, \"SQ\", \"Patient's Insurance Plan Code Sequence\" },\n    { 0x0010, 0x1000, \"LO\", \"Other Patient's ID's\" },\n    { 0x0010, 0x1001, \"PN\", \"Other Patient's Names\" },\n    { 0x0010, 0x1005, \"PN\", \"Patient's Birth Name\" },\n    { 0x0010, 0x1010, \"AS\", \"Patient's Age\" },\n    { 0x0010, 0x1020, \"DS\", \"Patient's Size\" },\n    { 0x0010, 0x1030, \"DS\", \"Patient's Weight\" },\n    { 0x0010, 0x1040, \"LO\", \"Patient's Address\" },\n    { 0x0010, 0x1050, \"LT\", \"Insurance Plan Identification\" },\n    { 0x0010, 0x1060, \"PN\", \"Patient's Mother's Birth Name\" },\n    { 0x0010, 0x1080, \"LO\", \"Military Rank\" },\n    { 0x0010, 0x1081, \"LO\", \"Branch of Service\" },\n    { 0x0010, 0x1090, \"LO\", \"Medical Record Locator\" },\n    { 0x0010, 0x2000, \"LO\", \"Medical Alerts\" },\n    { 0x0010, 0x2110, \"LO\", \"Contrast Allergies\" },\n    { 0x0010, 0x2150, \"LO\", \"Country of Residence\" },\n    { 0x0010, 0x2152, \"LO\", \"Region of Residence\" },\n    { 0x0010, 0x2154, \"SH\", \"Patients Telephone Numbers\" },\n    { 0x0010, 0x2160, \"SH\", \"Ethnic Group\" },\n    { 0x0010, 0x2180, \"SH\", \"Occupation\" },\n    { 0x0010, 0x21a0, \"CS\", \"Smoking Status\" },\n    { 0x0010, 0x21b0, \"LT\", \"Additional Patient History\" },\n    { 0x0010, 0x21c0, \"US\", \"Pregnancy Status\" },\n    { 0x0010, 0x21d0, \"DA\", \"Last Menstrual Date\" },\n    { 0x0010, 0x21f0, \"LO\", \"Patients Religious Preference\" },\n    { 0x0010, 0x4000, \"LT\", \"Patient Comments\" },\n    { 0x0011, 0x0001, \"xs\", \"?\" },\n    { 0x0011, 0x0002, \"US\", \"?\" },\n    { 0x0011, 0x0003, \"LT\", \"Patient UID\" },\n    { 0x0011, 0x0004, \"LT\", \"Patient ID\" },\n    { 0x0011, 0x000a, \"xs\", \"?\" },\n    { 0x0011, 0x000b, \"SL\", \"Effective Series Duration\" },\n    { 0x0011, 0x000c, \"SL\", \"Num Beats\" },\n    { 0x0011, 0x000d, \"LO\", \"Radio Nuclide Name\" },\n    { 0x0011, 0x0010, \"xs\", \"?\" },\n    { 0x0011, 0x0011, \"xs\", \"?\" },\n    { 0x0011, 0x0012, \"LO\", \"Dataset Name\" },\n    { 0x0011, 0x0013, \"LO\", \"Dataset Type\" },\n    { 0x0011, 0x0015, \"xs\", \"?\" },\n    { 0x0011, 0x0016, \"SL\", \"Energy Number\" },\n    { 0x0011, 0x0017, \"SL\", \"RR Interval Window Number\" },\n    { 0x0011, 0x0018, \"SL\", \"MG Bin Number\" },\n    { 0x0011, 0x0019, \"FD\", \"Radius Of Rotation\" },\n    { 0x0011, 0x001a, \"SL\", \"Detector Count Zone\" },\n    { 0x0011, 0x001b, \"SL\", \"Num Energy Windows\" },\n    { 0x0011, 0x001c, \"SL\", \"Energy Offset\" },\n    { 0x0011, 0x001d, \"SL\", \"Energy Range\" },\n    { 0x0011, 0x001f, \"SL\", \"Image Orientation\" },\n    { 0x0011, 0x0020, \"xs\", \"?\" },\n    { 0x0011, 0x0021, \"xs\", \"?\" },\n    { 0x0011, 0x0022, \"xs\", \"?\" },\n    { 0x0011, 0x0023, \"xs\", \"?\" },\n    { 0x0011, 0x0024, \"SL\", \"FOV Mask Y Cutoff Angle\" },\n    { 0x0011, 0x0025, \"xs\", \"?\" },\n    { 0x0011, 0x0026, \"SL\", \"Table Orientation\" },\n    { 0x0011, 0x0027, \"SL\", \"ROI Top Left\" },\n    { 0x0011, 0x0028, \"SL\", \"ROI Bottom Right\" },\n    { 0x0011, 0x0030, \"xs\", \"?\" },\n    { 0x0011, 0x0031, \"xs\", \"?\" },\n    { 0x0011, 0x0032, \"UN\", \"?\" },\n    { 0x0011, 0x0033, \"LO\", \"Energy Correct Name\" },\n    { 0x0011, 0x0034, \"LO\", \"Spatial Correct Name\" },\n    { 0x0011, 0x0035, \"xs\", \"?\" },\n    { 0x0011, 0x0036, \"LO\", \"Uniformity Correct Name\" },\n    { 0x0011, 0x0037, \"LO\", \"Acquisition Specific Correct Name\" },\n    { 0x0011, 0x0038, \"SL\", \"Byte Order\" },\n    { 0x0011, 0x003a, \"SL\", \"Picture Format\" },\n    { 0x0011, 0x003b, \"FD\", \"Pixel Scale\" },\n    { 0x0011, 0x003c, \"FD\", \"Pixel Offset\" },\n    { 0x0011, 0x003e, \"SL\", \"FOV Shape\" },\n    { 0x0011, 0x003f, \"SL\", \"Dataset Flags\" },\n    { 0x0011, 0x0040, \"xs\", \"?\" },\n    { 0x0011, 0x0041, \"LT\", \"Medical Alerts\" },\n    { 0x0011, 0x0042, \"LT\", \"Contrast Allergies\" },\n    { 0x0011, 0x0044, \"FD\", \"Threshold Center\" },\n    { 0x0011, 0x0045, \"FD\", \"Threshold Width\" },\n    { 0x0011, 0x0046, \"SL\", \"Interpolation Type\" },\n    { 0x0011, 0x0055, \"FD\", \"Period\" },\n    { 0x0011, 0x0056, \"FD\", \"ElapsedTime\" },\n    { 0x0011, 0x00a1, \"DA\", \"Patient Registration Date\" },\n    { 0x0011, 0x00a2, \"TM\", \"Patient Registration Time\" },\n    { 0x0011, 0x00b0, \"LT\", \"Patient Last Name\" },\n    { 0x0011, 0x00b2, \"LT\", \"Patient First Name\" },\n    { 0x0011, 0x00b4, \"LT\", \"Patient Hospital Status\" },\n    { 0x0011, 0x00bc, \"TM\", \"Current Location Time\" },\n    { 0x0011, 0x00c0, \"LT\", \"Patient Insurance Status\" },\n    { 0x0011, 0x00d0, \"LT\", \"Patient Billing Type\" },\n    { 0x0011, 0x00d2, \"LT\", \"Patient Billing Address\" },\n    { 0x0013, 0x0000, \"LT\", \"Modifying Physician\" },\n    { 0x0013, 0x0010, \"xs\", \"?\" },\n    { 0x0013, 0x0011, \"SL\", \"?\" },\n    { 0x0013, 0x0012, \"xs\", \"?\" },\n    { 0x0013, 0x0016, \"SL\", \"AutoTrack Peak\" },\n    { 0x0013, 0x0017, \"SL\", \"AutoTrack Width\" },\n    { 0x0013, 0x0018, \"FD\", \"Transmission Scan Time\" },\n    { 0x0013, 0x0019, \"FD\", \"Transmission Mask Width\" },\n    { 0x0013, 0x001a, \"FD\", \"Copper Attenuator Thickness\" },\n    { 0x0013, 0x001c, \"FD\", \"?\" },\n    { 0x0013, 0x001d, \"FD\", \"?\" },\n    { 0x0013, 0x001e, \"FD\", \"Tomo View Offset\" },\n    { 0x0013, 0x0020, \"LT\", \"Patient Name\" },\n    { 0x0013, 0x0022, \"LT\", \"Patient Id\" },\n    { 0x0013, 0x0026, \"LT\", \"Study Comments\" },\n    { 0x0013, 0x0030, \"DA\", \"Patient Birthdate\" },\n    { 0x0013, 0x0031, \"DS\", \"Patient Weight\" },\n    { 0x0013, 0x0032, \"LT\", \"Patients Maiden Name\" },\n    { 0x0013, 0x0033, \"LT\", \"Referring Physician\" },\n    { 0x0013, 0x0034, \"LT\", \"Admitting Diagnosis\" },\n    { 0x0013, 0x0035, \"LT\", \"Patient Sex\" },\n    { 0x0013, 0x0040, \"LT\", \"Procedure Description\" },\n    { 0x0013, 0x0042, \"LT\", \"Patient Rest Direction\" },\n    { 0x0013, 0x0044, \"LT\", \"Patient Position\" },\n    { 0x0013, 0x0046, \"LT\", \"View Direction\" },\n    { 0x0015, 0x0001, \"DS\", \"Stenosis Calibration Ratio\" },\n    { 0x0015, 0x0002, \"DS\", \"Stenosis Magnification\" },\n    { 0x0015, 0x0003, \"DS\", \"Cardiac Calibration Ratio\" },\n    { 0x0018, 0x0000, \"UL\", \"Acquisition Group Length\" },\n    { 0x0018, 0x0010, \"LO\", \"Contrast/Bolus Agent\" },\n    { 0x0018, 0x0012, \"SQ\", \"Contrast/Bolus Agent Sequence\" },\n    { 0x0018, 0x0014, \"SQ\", \"Contrast/Bolus Administration Route Sequence\" },\n    { 0x0018, 0x0015, \"CS\", \"Body Part Examined\" },\n    { 0x0018, 0x0020, \"CS\", \"Scanning Sequence\" },\n    { 0x0018, 0x0021, \"CS\", \"Sequence Variant\" },\n    { 0x0018, 0x0022, \"CS\", \"Scan Options\" },\n    { 0x0018, 0x0023, \"CS\", \"MR Acquisition Type\" },\n    { 0x0018, 0x0024, \"SH\", \"Sequence Name\" },\n    { 0x0018, 0x0025, \"CS\", \"Angio Flag\" },\n    { 0x0018, 0x0026, \"SQ\", \"Intervention Drug Information Sequence\" },\n    { 0x0018, 0x0027, \"TM\", \"Intervention Drug Stop Time\" },\n    { 0x0018, 0x0028, \"DS\", \"Intervention Drug Dose\" },\n    { 0x0018, 0x0029, \"SQ\", \"Intervention Drug Code Sequence\" },\n    { 0x0018, 0x002a, \"SQ\", \"Additional Drug Sequence\" },\n    { 0x0018, 0x0030, \"LO\", \"Radionuclide\" },\n    { 0x0018, 0x0031, \"LO\", \"Radiopharmaceutical\" },\n    { 0x0018, 0x0032, \"DS\", \"Energy Window Centerline\" },\n    { 0x0018, 0x0033, \"DS\", \"Energy Window Total Width\" },\n    { 0x0018, 0x0034, \"LO\", \"Intervention Drug Name\" },\n    { 0x0018, 0x0035, \"TM\", \"Intervention Drug Start Time\" },\n    { 0x0018, 0x0036, \"SQ\", \"Intervention Therapy Sequence\" },\n    { 0x0018, 0x0037, \"CS\", \"Therapy Type\" },\n    { 0x0018, 0x0038, \"CS\", \"Intervention Status\" },\n    { 0x0018, 0x0039, \"CS\", \"Therapy Description\" },\n    { 0x0018, 0x0040, \"IS\", \"Cine Rate\" },\n    { 0x0018, 0x0050, \"DS\", \"Slice Thickness\" },\n    { 0x0018, 0x0060, \"DS\", \"KVP\" },\n    { 0x0018, 0x0070, \"IS\", \"Counts Accumulated\" },\n    { 0x0018, 0x0071, \"CS\", \"Acquisition Termination Condition\" },\n    { 0x0018, 0x0072, \"DS\", \"Effective Series Duration\" },\n    { 0x0018, 0x0073, \"CS\", \"Acquisition Start Condition\" },\n    { 0x0018, 0x0074, \"IS\", \"Acquisition Start Condition Data\" },\n    { 0x0018, 0x0075, \"IS\", \"Acquisition Termination Condition Data\" },\n    { 0x0018, 0x0080, \"DS\", \"Repetition Time\" },\n    { 0x0018, 0x0081, \"DS\", \"Echo Time\" },\n    { 0x0018, 0x0082, \"DS\", \"Inversion Time\" },\n    { 0x0018, 0x0083, \"DS\", \"Number of Averages\" },\n    { 0x0018, 0x0084, \"DS\", \"Imaging Frequency\" },\n    { 0x0018, 0x0085, \"SH\", \"Imaged Nucleus\" },\n    { 0x0018, 0x0086, \"IS\", \"Echo Number(s)\" },\n    { 0x0018, 0x0087, \"DS\", \"Magnetic Field Strength\" },\n    { 0x0018, 0x0088, \"DS\", \"Spacing Between Slices\" },\n    { 0x0018, 0x0089, \"IS\", \"Number of Phase Encoding Steps\" },\n    { 0x0018, 0x0090, \"DS\", \"Data Collection Diameter\" },\n    { 0x0018, 0x0091, \"IS\", \"Echo Train Length\" },\n    { 0x0018, 0x0093, \"DS\", \"Percent Sampling\" },\n    { 0x0018, 0x0094, \"DS\", \"Percent Phase Field of View\" },\n    { 0x0018, 0x0095, \"DS\", \"Pixel Bandwidth\" },\n    { 0x0018, 0x1000, \"LO\", \"Device Serial Number\" },\n    { 0x0018, 0x1004, \"LO\", \"Plate ID\" },\n    { 0x0018, 0x1010, \"LO\", \"Secondary Capture Device ID\" },\n    { 0x0018, 0x1012, \"DA\", \"Date of Secondary Capture\" },\n    { 0x0018, 0x1014, \"TM\", \"Time of Secondary Capture\" },\n    { 0x0018, 0x1016, \"LO\", \"Secondary Capture Device Manufacturer\" },\n    { 0x0018, 0x1018, \"LO\", \"Secondary Capture Device Manufacturer Model Name\" },\n    { 0x0018, 0x1019, \"LO\", \"Secondary Capture Device Software Version(s)\" },\n    { 0x0018, 0x1020, \"LO\", \"Software Version(s)\" },\n    { 0x0018, 0x1022, \"SH\", \"Video Image Format Acquired\" },\n    { 0x0018, 0x1023, \"LO\", \"Digital Image Format Acquired\" },\n    { 0x0018, 0x1030, \"LO\", \"Protocol Name\" },\n    { 0x0018, 0x1040, \"LO\", \"Contrast/Bolus Route\" },\n    { 0x0018, 0x1041, \"DS\", \"Contrast/Bolus Volume\" },\n    { 0x0018, 0x1042, \"TM\", \"Contrast/Bolus Start Time\" },\n    { 0x0018, 0x1043, \"TM\", \"Contrast/Bolus Stop Time\" },\n    { 0x0018, 0x1044, \"DS\", \"Contrast/Bolus Total Dose\" },\n    { 0x0018, 0x1045, \"IS\", \"Syringe Counts\" },\n    { 0x0018, 0x1046, \"DS\", \"Contrast Flow Rate\" },\n    { 0x0018, 0x1047, \"DS\", \"Contrast Flow Duration\" },\n    { 0x0018, 0x1048, \"CS\", \"Contrast/Bolus Ingredient\" },\n    { 0x0018, 0x1049, \"DS\", \"Contrast/Bolus Ingredient Concentration\" },\n    { 0x0018, 0x1050, \"DS\", \"Spatial Resolution\" },\n    { 0x0018, 0x1060, \"DS\", \"Trigger Time\" },\n    { 0x0018, 0x1061, \"LO\", \"Trigger Source or Type\" },\n    { 0x0018, 0x1062, \"IS\", \"Nominal Interval\" },\n    { 0x0018, 0x1063, \"DS\", \"Frame Time\" },\n    { 0x0018, 0x1064, \"LO\", \"Framing Type\" },\n    { 0x0018, 0x1065, \"DS\", \"Frame Time Vector\" },\n    { 0x0018, 0x1066, \"DS\", \"Frame Delay\" },\n    { 0x0018, 0x1067, \"DS\", \"Image Trigger Delay\" },\n    { 0x0018, 0x1068, \"DS\", \"Group Time Offset\" },\n    { 0x0018, 0x1069, \"DS\", \"Trigger Time Offset\" },\n    { 0x0018, 0x106a, \"CS\", \"Synchronization Trigger\" },\n    { 0x0018, 0x106b, \"UI\", \"Synchronization Frame of Reference\" },\n    { 0x0018, 0x106e, \"UL\", \"Trigger Sample Position\" },\n    { 0x0018, 0x1070, \"LO\", \"Radiopharmaceutical Route\" },\n    { 0x0018, 0x1071, \"DS\", \"Radiopharmaceutical Volume\" },\n    { 0x0018, 0x1072, \"TM\", \"Radiopharmaceutical Start Time\" },\n    { 0x0018, 0x1073, \"TM\", \"Radiopharmaceutical Stop Time\" },\n    { 0x0018, 0x1074, \"DS\", \"Radionuclide Total Dose\" },\n    { 0x0018, 0x1075, \"DS\", \"Radionuclide Half Life\" },\n    { 0x0018, 0x1076, \"DS\", \"Radionuclide Positron Fraction\" },\n    { 0x0018, 0x1077, \"DS\", \"Radiopharmaceutical Specific Activity\" },\n    { 0x0018, 0x1080, \"CS\", \"Beat Rejection Flag\" },\n    { 0x0018, 0x1081, \"IS\", \"Low R-R Value\" },\n    { 0x0018, 0x1082, \"IS\", \"High R-R Value\" },\n    { 0x0018, 0x1083, \"IS\", \"Intervals Acquired\" },\n    { 0x0018, 0x1084, \"IS\", \"Intervals Rejected\" },\n    { 0x0018, 0x1085, \"LO\", \"PVC Rejection\" },\n    { 0x0018, 0x1086, \"IS\", \"Skip Beats\" },\n    { 0x0018, 0x1088, \"IS\", \"Heart Rate\" },\n    { 0x0018, 0x1090, \"IS\", \"Cardiac Number of Images\" },\n    { 0x0018, 0x1094, \"IS\", \"Trigger Window\" },\n    { 0x0018, 0x1100, \"DS\", \"Reconstruction Diameter\" },\n    { 0x0018, 0x1110, \"DS\", \"Distance Source to Detector\" },\n    { 0x0018, 0x1111, \"DS\", \"Distance Source to Patient\" },\n    { 0x0018, 0x1114, \"DS\", \"Estimated Radiographic Magnification Factor\" },\n    { 0x0018, 0x1120, \"DS\", \"Gantry/Detector Tilt\" },\n    { 0x0018, 0x1121, \"DS\", \"Gantry/Detector Slew\" },\n    { 0x0018, 0x1130, \"DS\", \"Table Height\" },\n    { 0x0018, 0x1131, \"DS\", \"Table Traverse\" },\n    { 0x0018, 0x1134, \"CS\", \"Table Motion\" },\n    { 0x0018, 0x1135, \"DS\", \"Table Vertical Increment\" },\n    { 0x0018, 0x1136, \"DS\", \"Table Lateral Increment\" },\n    { 0x0018, 0x1137, \"DS\", \"Table Longitudinal Increment\" },\n    { 0x0018, 0x1138, \"DS\", \"Table Angle\" },\n    { 0x0018, 0x113a, \"CS\", \"Table Type\" },\n    { 0x0018, 0x1140, \"CS\", \"Rotation Direction\" },\n    { 0x0018, 0x1141, \"DS\", \"Angular Position\" },\n    { 0x0018, 0x1142, \"DS\", \"Radial Position\" },\n    { 0x0018, 0x1143, \"DS\", \"Scan Arc\" },\n    { 0x0018, 0x1144, \"DS\", \"Angular Step\" },\n    { 0x0018, 0x1145, \"DS\", \"Center of Rotation Offset\" },\n    { 0x0018, 0x1146, \"DS\", \"Rotation Offset\" },\n    { 0x0018, 0x1147, \"CS\", \"Field of View Shape\" },\n    { 0x0018, 0x1149, \"IS\", \"Field of View Dimension(s)\" },\n    { 0x0018, 0x1150, \"IS\", \"Exposure Time\" },\n    { 0x0018, 0x1151, \"IS\", \"X-ray Tube Current\" },\n    { 0x0018, 0x1152, \"IS\", \"Exposure\" },\n    { 0x0018, 0x1153, \"IS\", \"Exposure in uAs\" },\n    { 0x0018, 0x1154, \"DS\", \"AveragePulseWidth\" },\n    { 0x0018, 0x1155, \"CS\", \"RadiationSetting\" },\n    { 0x0018, 0x1156, \"CS\", \"Rectification Type\" },\n    { 0x0018, 0x115a, \"CS\", \"RadiationMode\" },\n    { 0x0018, 0x115e, \"DS\", \"ImageAreaDoseProduct\" },\n    { 0x0018, 0x1160, \"SH\", \"Filter Type\" },\n    { 0x0018, 0x1161, \"LO\", \"TypeOfFilters\" },\n    { 0x0018, 0x1162, \"DS\", \"IntensifierSize\" },\n    { 0x0018, 0x1164, \"DS\", \"ImagerPixelSpacing\" },\n    { 0x0018, 0x1166, \"CS\", \"Grid\" },\n    { 0x0018, 0x1170, \"IS\", \"Generator Power\" },\n    { 0x0018, 0x1180, \"SH\", \"Collimator/Grid Name\" },\n    { 0x0018, 0x1181, \"CS\", \"Collimator Type\" },\n    { 0x0018, 0x1182, \"IS\", \"Focal Distance\" },\n    { 0x0018, 0x1183, \"DS\", \"X Focus Center\" },\n    { 0x0018, 0x1184, \"DS\", \"Y Focus Center\" },\n    { 0x0018, 0x1190, \"DS\", \"Focal Spot(s)\" },\n    { 0x0018, 0x1191, \"CS\", \"Anode Target Material\" },\n    { 0x0018, 0x11a0, \"DS\", \"Body Part Thickness\" },\n    { 0x0018, 0x11a2, \"DS\", \"Compression Force\" },\n    { 0x0018, 0x1200, \"DA\", \"Date of Last Calibration\" },\n    { 0x0018, 0x1201, \"TM\", \"Time of Last Calibration\" },\n    { 0x0018, 0x1210, \"SH\", \"Convolution Kernel\" },\n    { 0x0018, 0x1240, \"IS\", \"Upper/Lower Pixel Values\" },\n    { 0x0018, 0x1242, \"IS\", \"Actual Frame Duration\" },\n    { 0x0018, 0x1243, \"IS\", \"Count Rate\" },\n    { 0x0018, 0x1244, \"US\", \"Preferred Playback Sequencing\" },\n    { 0x0018, 0x1250, \"SH\", \"Receiving Coil\" },\n    { 0x0018, 0x1251, \"SH\", \"Transmitting Coil\" },\n    { 0x0018, 0x1260, \"SH\", \"Plate Type\" },\n    { 0x0018, 0x1261, \"LO\", \"Phosphor Type\" },\n    { 0x0018, 0x1300, \"DS\", \"Scan Velocity\" },\n    { 0x0018, 0x1301, \"CS\", \"Whole Body Technique\" },\n    { 0x0018, 0x1302, \"IS\", \"Scan Length\" },\n    { 0x0018, 0x1310, \"US\", \"Acquisition Matrix\" },\n    { 0x0018, 0x1312, \"CS\", \"Phase Encoding Direction\" },\n    { 0x0018, 0x1314, \"DS\", \"Flip Angle\" },\n    { 0x0018, 0x1315, \"CS\", \"Variable Flip Angle Flag\" },\n    { 0x0018, 0x1316, \"DS\", \"SAR\" },\n    { 0x0018, 0x1318, \"DS\", \"dB/dt\" },\n    { 0x0018, 0x1400, \"LO\", \"Acquisition Device Processing Description\" },\n    { 0x0018, 0x1401, \"LO\", \"Acquisition Device Processing Code\" },\n    { 0x0018, 0x1402, \"CS\", \"Cassette Orientation\" },\n    { 0x0018, 0x1403, \"CS\", \"Cassette Size\" },\n    { 0x0018, 0x1404, \"US\", \"Exposures on Plate\" },\n    { 0x0018, 0x1405, \"IS\", \"Relative X-ray Exposure\" },\n    { 0x0018, 0x1450, \"DS\", \"Column Angulation\" },\n    { 0x0018, 0x1460, \"DS\", \"Tomo Layer Height\" },\n    { 0x0018, 0x1470, \"DS\", \"Tomo Angle\" },\n    { 0x0018, 0x1480, \"DS\", \"Tomo Time\" },\n    { 0x0018, 0x1490, \"CS\", \"Tomo Type\" },\n    { 0x0018, 0x1491, \"CS\", \"Tomo Class\" },\n    { 0x0018, 0x1495, \"IS\", \"Number of Tomosynthesis Source Images\" },\n    { 0x0018, 0x1500, \"CS\", \"PositionerMotion\" },\n    { 0x0018, 0x1508, \"CS\", \"Positioner Type\" },\n    { 0x0018, 0x1510, \"DS\", \"PositionerPrimaryAngle\" },\n    { 0x0018, 0x1511, \"DS\", \"PositionerSecondaryAngle\" },\n    { 0x0018, 0x1520, \"DS\", \"PositionerPrimaryAngleIncrement\" },\n    { 0x0018, 0x1521, \"DS\", \"PositionerSecondaryAngleIncrement\" },\n    { 0x0018, 0x1530, \"DS\", \"DetectorPrimaryAngle\" },\n    { 0x0018, 0x1531, \"DS\", \"DetectorSecondaryAngle\" },\n    { 0x0018, 0x1600, \"CS\", \"Shutter Shape\" },\n    { 0x0018, 0x1602, \"IS\", \"Shutter Left Vertical Edge\" },\n    { 0x0018, 0x1604, \"IS\", \"Shutter Right Vertical Edge\" },\n    { 0x0018, 0x1606, \"IS\", \"Shutter Upper Horizontal Edge\" },\n    { 0x0018, 0x1608, \"IS\", \"Shutter Lower Horizonta lEdge\" },\n    { 0x0018, 0x1610, \"IS\", \"Center of Circular Shutter\" },\n    { 0x0018, 0x1612, \"IS\", \"Radius of Circular Shutter\" },\n    { 0x0018, 0x1620, \"IS\", \"Vertices of Polygonal Shutter\" },\n    { 0x0018, 0x1622, \"US\", \"Shutter Presentation Value\" },\n    { 0x0018, 0x1623, \"US\", \"Shutter Overlay Group\" },\n    { 0x0018, 0x1700, \"CS\", \"Collimator Shape\" },\n    { 0x0018, 0x1702, \"IS\", \"Collimator Left Vertical Edge\" },\n    { 0x0018, 0x1704, \"IS\", \"Collimator Right Vertical Edge\" },\n    { 0x0018, 0x1706, \"IS\", \"Collimator Upper Horizontal Edge\" },\n    { 0x0018, 0x1708, \"IS\", \"Collimator Lower Horizontal Edge\" },\n    { 0x0018, 0x1710, \"IS\", \"Center of Circular Collimator\" },\n    { 0x0018, 0x1712, \"IS\", \"Radius of Circular Collimator\" },\n    { 0x0018, 0x1720, \"IS\", \"Vertices of Polygonal Collimator\" },\n    { 0x0018, 0x1800, \"CS\", \"Acquisition Time Synchronized\" },\n    { 0x0018, 0x1801, \"SH\", \"Time Source\" },\n    { 0x0018, 0x1802, \"CS\", \"Time Distribution Protocol\" },\n    { 0x0018, 0x4000, \"LT\", \"Acquisition Comments\" },\n    { 0x0018, 0x5000, \"SH\", \"Output Power\" },\n    { 0x0018, 0x5010, \"LO\", \"Transducer Data\" },\n    { 0x0018, 0x5012, \"DS\", \"Focus Depth\" },\n    { 0x0018, 0x5020, \"LO\", \"Processing Function\" },\n    { 0x0018, 0x5021, \"LO\", \"Postprocessing Function\" },\n    { 0x0018, 0x5022, \"DS\", \"Mechanical Index\" },\n    { 0x0018, 0x5024, \"DS\", \"Thermal Index\" },\n    { 0x0018, 0x5026, \"DS\", \"Cranial Thermal Index\" },\n    { 0x0018, 0x5027, \"DS\", \"Soft Tissue Thermal Index\" },\n    { 0x0018, 0x5028, \"DS\", \"Soft Tissue-Focus Thermal Index\" },\n    { 0x0018, 0x5029, \"DS\", \"Soft Tissue-Surface Thermal Index\" },\n    { 0x0018, 0x5030, \"DS\", \"Dynamic Range\" },\n    { 0x0018, 0x5040, \"DS\", \"Total Gain\" },\n    { 0x0018, 0x5050, \"IS\", \"Depth of Scan Field\" },\n    { 0x0018, 0x5100, \"CS\", \"Patient Position\" },\n    { 0x0018, 0x5101, \"CS\", \"View Position\" },\n    { 0x0018, 0x5104, \"SQ\", \"Projection Eponymous Name Code Sequence\" },\n    { 0x0018, 0x5210, \"DS\", \"Image Transformation Matrix\" },\n    { 0x0018, 0x5212, \"DS\", \"Image Translation Vector\" },\n    { 0x0018, 0x6000, \"DS\", \"Sensitivity\" },\n    { 0x0018, 0x6011, \"IS\", \"Sequence of Ultrasound Regions\" },\n    { 0x0018, 0x6012, \"US\", \"Region Spatial Format\" },\n    { 0x0018, 0x6014, \"US\", \"Region Data Type\" },\n    { 0x0018, 0x6016, \"UL\", \"Region Flags\" },\n    { 0x0018, 0x6018, \"UL\", \"Region Location Min X0\" },\n    { 0x0018, 0x601a, \"UL\", \"Region Location Min Y0\" },\n    { 0x0018, 0x601c, \"UL\", \"Region Location Max X1\" },\n    { 0x0018, 0x601e, \"UL\", \"Region Location Max Y1\" },\n    { 0x0018, 0x6020, \"SL\", \"Reference Pixel X0\" },\n    { 0x0018, 0x6022, \"SL\", \"Reference Pixel Y0\" },\n    { 0x0018, 0x6024, \"US\", \"Physical Units X Direction\" },\n    { 0x0018, 0x6026, \"US\", \"Physical Units Y Direction\" },\n    { 0x0018, 0x6028, \"FD\", \"Reference Pixel Physical Value X\" },\n    { 0x0018, 0x602a, \"US\", \"Reference Pixel Physical Value Y\" },\n    { 0x0018, 0x602c, \"US\", \"Physical Delta X\" },\n    { 0x0018, 0x602e, \"US\", \"Physical Delta Y\" },\n    { 0x0018, 0x6030, \"UL\", \"Transducer Frequency\" },\n    { 0x0018, 0x6031, \"CS\", \"Transducer Type\" },\n    { 0x0018, 0x6032, \"UL\", \"Pulse Repetition Frequency\" },\n    { 0x0018, 0x6034, \"FD\", \"Doppler Correction Angle\" },\n    { 0x0018, 0x6036, \"FD\", \"Steering Angle\" },\n    { 0x0018, 0x6038, \"UL\", \"Doppler Sample Volume X Position\" },\n    { 0x0018, 0x603a, \"UL\", \"Doppler Sample Volume Y Position\" },\n    { 0x0018, 0x603c, \"UL\", \"TM-Line Position X0\" },\n    { 0x0018, 0x603e, \"UL\", \"TM-Line Position Y0\" },\n    { 0x0018, 0x6040, \"UL\", \"TM-Line Position X1\" },\n    { 0x0018, 0x6042, \"UL\", \"TM-Line Position Y1\" },\n    { 0x0018, 0x6044, \"US\", \"Pixel Component Organization\" },\n    { 0x0018, 0x6046, \"UL\", \"Pixel Component Mask\" },\n    { 0x0018, 0x6048, \"UL\", \"Pixel Component Range Start\" },\n    { 0x0018, 0x604a, \"UL\", \"Pixel Component Range Stop\" },\n    { 0x0018, 0x604c, \"US\", \"Pixel Component Physical Units\" },\n    { 0x0018, 0x604e, \"US\", \"Pixel Component Data Type\" },\n    { 0x0018, 0x6050, \"UL\", \"Number of Table Break Points\" },\n    { 0x0018, 0x6052, \"UL\", \"Table of X Break Points\" },\n    { 0x0018, 0x6054, \"FD\", \"Table of Y Break Points\" },\n    { 0x0018, 0x6056, \"UL\", \"Number of Table Entries\" },\n    { 0x0018, 0x6058, \"UL\", \"Table of Pixel Values\" },\n    { 0x0018, 0x605a, \"FL\", \"Table of Parameter Values\" },\n    { 0x0018, 0x7000, \"CS\", \"Detector Conditions Nominal Flag\" },\n    { 0x0018, 0x7001, \"DS\", \"Detector Temperature\" },\n    { 0x0018, 0x7004, \"CS\", \"Detector Type\" },\n    { 0x0018, 0x7005, \"CS\", \"Detector Configuration\" },\n    { 0x0018, 0x7006, \"LT\", \"Detector Description\" },\n    { 0x0018, 0x7008, \"LT\", \"Detector Mode\" },\n    { 0x0018, 0x700a, \"SH\", \"Detector ID\" },\n    { 0x0018, 0x700c, \"DA\", \"Date of Last Detector Calibration \" },\n    { 0x0018, 0x700e, \"TM\", \"Time of Last Detector Calibration\" },\n    { 0x0018, 0x7010, \"IS\", \"Exposures on Detector Since Last Calibration\" },\n    { 0x0018, 0x7011, \"IS\", \"Exposures on Detector Since Manufactured\" },\n    { 0x0018, 0x7012, \"DS\", \"Detector Time Since Last Exposure\" },\n    { 0x0018, 0x7014, \"DS\", \"Detector Active Time\" },\n    { 0x0018, 0x7016, \"DS\", \"Detector Activation Offset From Exposure\" },\n    { 0x0018, 0x701a, \"DS\", \"Detector Binning\" },\n    { 0x0018, 0x7020, \"DS\", \"Detector Element Physical Size\" },\n    { 0x0018, 0x7022, \"DS\", \"Detector Element Spacing\" },\n    { 0x0018, 0x7024, \"CS\", \"Detector Active Shape\" },\n    { 0x0018, 0x7026, \"DS\", \"Detector Active Dimensions\" },\n    { 0x0018, 0x7028, \"DS\", \"Detector Active Origin\" },\n    { 0x0018, 0x7030, \"DS\", \"Field of View Origin\" },\n    { 0x0018, 0x7032, \"DS\", \"Field of View Rotation\" },\n    { 0x0018, 0x7034, \"CS\", \"Field of View Horizontal Flip\" },\n    { 0x0018, 0x7040, \"LT\", \"Grid Absorbing Material\" },\n    { 0x0018, 0x7041, \"LT\", \"Grid Spacing Material\" },\n    { 0x0018, 0x7042, \"DS\", \"Grid Thickness\" },\n    { 0x0018, 0x7044, \"DS\", \"Grid Pitch\" },\n    { 0x0018, 0x7046, \"IS\", \"Grid Aspect Ratio\" },\n    { 0x0018, 0x7048, \"DS\", \"Grid Period\" },\n    { 0x0018, 0x704c, \"DS\", \"Grid Focal Distance\" },\n    { 0x0018, 0x7050, \"LT\", \"Filter Material\" },\n    { 0x0018, 0x7052, \"DS\", \"Filter Thickness Minimum\" },\n    { 0x0018, 0x7054, \"DS\", \"Filter Thickness Maximum\" },\n    { 0x0018, 0x7060, \"CS\", \"Exposure Control Mode\" },\n    { 0x0018, 0x7062, \"LT\", \"Exposure Control Mode Description\" },\n    { 0x0018, 0x7064, \"CS\", \"Exposure Status\" },\n    { 0x0018, 0x7065, \"DS\", \"Phototimer Setting\" },\n    { 0x0019, 0x0000, \"xs\", \"?\" },\n    { 0x0019, 0x0001, \"xs\", \"?\" },\n    { 0x0019, 0x0002, \"xs\", \"?\" },\n    { 0x0019, 0x0003, \"xs\", \"?\" },\n    { 0x0019, 0x0004, \"xs\", \"?\" },\n    { 0x0019, 0x0005, \"xs\", \"?\" },\n    { 0x0019, 0x0006, \"xs\", \"?\" },\n    { 0x0019, 0x0007, \"xs\", \"?\" },\n    { 0x0019, 0x0008, \"xs\", \"?\" },\n    { 0x0019, 0x0009, \"xs\", \"?\" },\n    { 0x0019, 0x000a, \"xs\", \"?\" },\n    { 0x0019, 0x000b, \"DS\", \"?\" },\n    { 0x0019, 0x000c, \"US\", \"?\" },\n    { 0x0019, 0x000d, \"TM\", \"Time\" },\n    { 0x0019, 0x000e, \"xs\", \"?\" },\n    { 0x0019, 0x000f, \"DS\", \"Horizontal Frame Of Reference\" },\n    { 0x0019, 0x0010, \"xs\", \"?\" },\n    { 0x0019, 0x0011, \"xs\", \"?\" },\n    { 0x0019, 0x0012, \"xs\", \"?\" },\n    { 0x0019, 0x0013, \"xs\", \"?\" },\n    { 0x0019, 0x0014, \"xs\", \"?\" },\n    { 0x0019, 0x0015, \"xs\", \"?\" },\n    { 0x0019, 0x0016, \"xs\", \"?\" },\n    { 0x0019, 0x0017, \"xs\", \"?\" },\n    { 0x0019, 0x0018, \"xs\", \"?\" },\n    { 0x0019, 0x0019, \"xs\", \"?\" },\n    { 0x0019, 0x001a, \"xs\", \"?\" },\n    { 0x0019, 0x001b, \"xs\", \"?\" },\n    { 0x0019, 0x001c, \"CS\", \"Dose\" },\n    { 0x0019, 0x001d, \"IS\", \"Side Mark\" },\n    { 0x0019, 0x001e, \"xs\", \"?\" },\n    { 0x0019, 0x001f, \"DS\", \"Exposure Duration\" },\n    { 0x0019, 0x0020, \"xs\", \"?\" },\n    { 0x0019, 0x0021, \"xs\", \"?\" },\n    { 0x0019, 0x0022, \"xs\", \"?\" },\n    { 0x0019, 0x0023, \"xs\", \"?\" },\n    { 0x0019, 0x0024, \"xs\", \"?\" },\n    { 0x0019, 0x0025, \"xs\", \"?\" },\n    { 0x0019, 0x0026, \"xs\", \"?\" },\n    { 0x0019, 0x0027, \"xs\", \"?\" },\n    { 0x0019, 0x0028, \"xs\", \"?\" },\n    { 0x0019, 0x0029, \"IS\", \"?\" },\n    { 0x0019, 0x002a, \"xs\", \"?\" },\n    { 0x0019, 0x002b, \"DS\", \"Xray Off Position\" },\n    { 0x0019, 0x002c, \"xs\", \"?\" },\n    { 0x0019, 0x002d, \"US\", \"?\" },\n    { 0x0019, 0x002e, \"xs\", \"?\" },\n    { 0x0019, 0x002f, \"DS\", \"Trigger Frequency\" },\n    { 0x0019, 0x0030, \"xs\", \"?\" },\n    { 0x0019, 0x0031, \"xs\", \"?\" },\n    { 0x0019, 0x0032, \"xs\", \"?\" },\n    { 0x0019, 0x0033, \"UN\", \"ECG 2 Offset 2\" },\n    { 0x0019, 0x0034, \"US\", \"?\" },\n    { 0x0019, 0x0036, \"US\", \"?\" },\n    { 0x0019, 0x0038, \"US\", \"?\" },\n    { 0x0019, 0x0039, \"xs\", \"?\" },\n    { 0x0019, 0x003a, \"xs\", \"?\" },\n    { 0x0019, 0x003b, \"LT\", \"?\" },\n    { 0x0019, 0x003c, \"xs\", \"?\" },\n    { 0x0019, 0x003e, \"xs\", \"?\" },\n    { 0x0019, 0x003f, \"UN\", \"?\" },\n    { 0x0019, 0x0040, \"xs\", \"?\" },\n    { 0x0019, 0x0041, \"xs\", \"?\" },\n    { 0x0019, 0x0042, \"xs\", \"?\" },\n    { 0x0019, 0x0043, \"xs\", \"?\" },\n    { 0x0019, 0x0044, \"xs\", \"?\" },\n    { 0x0019, 0x0045, \"xs\", \"?\" },\n    { 0x0019, 0x0046, \"xs\", \"?\" },\n    { 0x0019, 0x0047, \"xs\", \"?\" },\n    { 0x0019, 0x0048, \"xs\", \"?\" },\n    { 0x0019, 0x0049, \"US\", \"?\" },\n    { 0x0019, 0x004a, \"xs\", \"?\" },\n    { 0x0019, 0x004b, \"SL\", \"Data Size For Scan Data\" },\n    { 0x0019, 0x004c, \"US\", \"?\" },\n    { 0x0019, 0x004e, \"US\", \"?\" },\n    { 0x0019, 0x0050, \"xs\", \"?\" },\n    { 0x0019, 0x0051, \"xs\", \"?\" },\n    { 0x0019, 0x0052, \"xs\", \"?\" },\n    { 0x0019, 0x0053, \"LT\", \"Barcode\" },\n    { 0x0019, 0x0054, \"xs\", \"?\" },\n    { 0x0019, 0x0055, \"DS\", \"Receiver Reference Gain\" },\n    { 0x0019, 0x0056, \"xs\", \"?\" },\n    { 0x0019, 0x0057, \"SS\", \"CT Water Number\" },\n    { 0x0019, 0x0058, \"xs\", \"?\" },\n    { 0x0019, 0x005a, \"xs\", \"?\" },\n    { 0x0019, 0x005c, \"xs\", \"?\" },\n    { 0x0019, 0x005d, \"US\", \"?\" },\n    { 0x0019, 0x005e, \"xs\", \"?\" },\n    { 0x0019, 0x005f, \"SL\", \"Increment Between Channels\" },\n    { 0x0019, 0x0060, \"xs\", \"?\" },\n    { 0x0019, 0x0061, \"xs\", \"?\" },\n    { 0x0019, 0x0062, \"xs\", \"?\" },\n    { 0x0019, 0x0063, \"xs\", \"?\" },\n    { 0x0019, 0x0064, \"xs\", \"?\" },\n    { 0x0019, 0x0065, \"xs\", \"?\" },\n    { 0x0019, 0x0066, \"xs\", \"?\" },\n    { 0x0019, 0x0067, \"xs\", \"?\" },\n    { 0x0019, 0x0068, \"xs\", \"?\" },\n    { 0x0019, 0x0069, \"UL\", \"Convolution Mode\" },\n    { 0x0019, 0x006a, \"xs\", \"?\" },\n    { 0x0019, 0x006b, \"SS\", \"Field Of View In Detector Cells\" },\n    { 0x0019, 0x006c, \"US\", \"?\" },\n    { 0x0019, 0x006e, \"US\", \"?\" },\n    { 0x0019, 0x0070, \"xs\", \"?\" },\n    { 0x0019, 0x0071, \"xs\", \"?\" },\n    { 0x0019, 0x0072, \"xs\", \"?\" },\n    { 0x0019, 0x0073, \"xs\", \"?\" },\n    { 0x0019, 0x0074, \"xs\", \"?\" },\n    { 0x0019, 0x0075, \"xs\", \"?\" },\n    { 0x0019, 0x0076, \"xs\", \"?\" },\n    { 0x0019, 0x0077, \"US\", \"?\" },\n    { 0x0019, 0x0078, \"US\", \"?\" },\n    { 0x0019, 0x007a, \"US\", \"?\" },\n    { 0x0019, 0x007c, \"US\", \"?\" },\n    { 0x0019, 0x007d, \"DS\", \"Second Echo\" },\n    { 0x0019, 0x007e, \"xs\", \"?\" },\n    { 0x0019, 0x007f, \"DS\", \"Table Delta\" },\n    { 0x0019, 0x0080, \"xs\", \"?\" },\n    { 0x0019, 0x0081, \"xs\", \"?\" },\n    { 0x0019, 0x0082, \"xs\", \"?\" },\n    { 0x0019, 0x0083, \"xs\", \"?\" },\n    { 0x0019, 0x0084, \"xs\", \"?\" },\n    { 0x0019, 0x0085, \"xs\", \"?\" },\n    { 0x0019, 0x0086, \"xs\", \"?\" },\n    { 0x0019, 0x0087, \"xs\", \"?\" },\n    { 0x0019, 0x0088, \"xs\", \"?\" },\n    { 0x0019, 0x008a, \"xs\", \"?\" },\n    { 0x0019, 0x008b, \"SS\", \"Actual Receive Gain Digital\" },\n    { 0x0019, 0x008c, \"US\", \"?\" },\n    { 0x0019, 0x008d, \"DS\", \"Delay After Trigger\" },\n    { 0x0019, 0x008e, \"US\", \"?\" },\n    { 0x0019, 0x008f, \"SS\", \"Swap Phase Frequency\" },\n    { 0x0019, 0x0090, \"xs\", \"?\" },\n    { 0x0019, 0x0091, \"xs\", \"?\" },\n    { 0x0019, 0x0092, \"xs\", \"?\" },\n    { 0x0019, 0x0093, \"xs\", \"?\" },\n    { 0x0019, 0x0094, \"xs\", \"?\" },\n    { 0x0019, 0x0095, \"SS\", \"Analog Receiver Gain\" },\n    { 0x0019, 0x0096, \"xs\", \"?\" },\n    { 0x0019, 0x0097, \"xs\", \"?\" },\n    { 0x0019, 0x0098, \"xs\", \"?\" },\n    { 0x0019, 0x0099, \"US\", \"?\" },\n    { 0x0019, 0x009a, \"US\", \"?\" },\n    { 0x0019, 0x009b, \"SS\", \"Pulse Sequence Mode\" },\n    { 0x0019, 0x009c, \"xs\", \"?\" },\n    { 0x0019, 0x009d, \"DT\", \"Pulse Sequence Date\" },\n    { 0x0019, 0x009e, \"xs\", \"?\" },\n    { 0x0019, 0x009f, \"xs\", \"?\" },\n    { 0x0019, 0x00a0, \"xs\", \"?\" },\n    { 0x0019, 0x00a1, \"xs\", \"?\" },\n    { 0x0019, 0x00a2, \"xs\", \"?\" },\n    { 0x0019, 0x00a3, \"xs\", \"?\" },\n    { 0x0019, 0x00a4, \"xs\", \"?\" },\n    { 0x0019, 0x00a5, \"xs\", \"?\" },\n    { 0x0019, 0x00a6, \"xs\", \"?\" },\n    { 0x0019, 0x00a7, \"xs\", \"?\" },\n    { 0x0019, 0x00a8, \"xs\", \"?\" },\n    { 0x0019, 0x00a9, \"xs\", \"?\" },\n    { 0x0019, 0x00aa, \"xs\", \"?\" },\n    { 0x0019, 0x00ab, \"xs\", \"?\" },\n    { 0x0019, 0x00ac, \"xs\", \"?\" },\n    { 0x0019, 0x00ad, \"xs\", \"?\" },\n    { 0x0019, 0x00ae, \"xs\", \"?\" },\n    { 0x0019, 0x00af, \"xs\", \"?\" },\n    { 0x0019, 0x00b0, \"xs\", \"?\" },\n    { 0x0019, 0x00b1, \"xs\", \"?\" },\n    { 0x0019, 0x00b2, \"xs\", \"?\" },\n    { 0x0019, 0x00b3, \"xs\", \"?\" },\n    { 0x0019, 0x00b4, \"xs\", \"?\" },\n    { 0x0019, 0x00b5, \"xs\", \"?\" },\n    { 0x0019, 0x00b6, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b7, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b8, \"DS\", \"User Data\" },\n    { 0x0019, 0x00b9, \"DS\", \"User Data\" },\n    { 0x0019, 0x00ba, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bb, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bc, \"DS\", \"User Data\" },\n    { 0x0019, 0x00bd, \"DS\", \"User Data\" },\n    { 0x0019, 0x00be, \"DS\", \"Projection Angle\" },\n    { 0x0019, 0x00c0, \"xs\", \"?\" },\n    { 0x0019, 0x00c1, \"xs\", \"?\" },\n    { 0x0019, 0x00c2, \"xs\", \"?\" },\n    { 0x0019, 0x00c3, \"xs\", \"?\" },\n    { 0x0019, 0x00c4, \"xs\", \"?\" },\n    { 0x0019, 0x00c5, \"xs\", \"?\" },\n    { 0x0019, 0x00c6, \"SS\", \"SAT Location H\" },\n    { 0x0019, 0x00c7, \"SS\", \"SAT Location F\" },\n    { 0x0019, 0x00c8, \"SS\", \"SAT Thickness R L\" },\n    { 0x0019, 0x00c9, \"SS\", \"SAT Thickness A P\" },\n    { 0x0019, 0x00ca, \"SS\", \"SAT Thickness H F\" },\n    { 0x0019, 0x00cb, \"xs\", \"?\" },\n    { 0x0019, 0x00cc, \"xs\", \"?\" },\n    { 0x0019, 0x00cd, \"SS\", \"Thickness Disclaimer\" },\n    { 0x0019, 0x00ce, \"SS\", \"Prescan Type\" },\n    { 0x0019, 0x00cf, \"SS\", \"Prescan Status\" },\n    { 0x0019, 0x00d0, \"SH\", \"Raw Data Type\" },\n    { 0x0019, 0x00d1, \"DS\", \"Flow Sensitivity\" },\n    { 0x0019, 0x00d2, \"xs\", \"?\" },\n    { 0x0019, 0x00d3, \"xs\", \"?\" },\n    { 0x0019, 0x00d4, \"xs\", \"?\" },\n    { 0x0019, 0x00d5, \"xs\", \"?\" },\n    { 0x0019, 0x00d6, \"xs\", \"?\" },\n    { 0x0019, 0x00d7, \"xs\", \"?\" },\n    { 0x0019, 0x00d8, \"xs\", \"?\" },\n    { 0x0019, 0x00d9, \"xs\", \"?\" },\n    { 0x0019, 0x00da, \"xs\", \"?\" },\n    { 0x0019, 0x00db, \"DS\", \"Back Projector Coefficient\" },\n    { 0x0019, 0x00dc, \"SS\", \"Primary Speed Correction Used\" },\n    { 0x0019, 0x00dd, \"SS\", \"Overrange Correction Used\" },\n    { 0x0019, 0x00de, \"DS\", \"Dynamic Z Alpha Value\" },\n    { 0x0019, 0x00df, \"DS\", \"User Data\" },\n    { 0x0019, 0x00e0, \"DS\", \"User Data\" },\n    { 0x0019, 0x00e1, \"xs\", \"?\" },\n    { 0x0019, 0x00e2, \"xs\", \"?\" },\n    { 0x0019, 0x00e3, \"xs\", \"?\" },\n    { 0x0019, 0x00e4, \"LT\", \"?\" },\n    { 0x0019, 0x00e5, \"IS\", \"?\" },\n    { 0x0019, 0x00e6, \"US\", \"?\" },\n    { 0x0019, 0x00e8, \"DS\", \"?\" },\n    { 0x0019, 0x00e9, \"DS\", \"?\" },\n    { 0x0019, 0x00eb, \"DS\", \"?\" },\n    { 0x0019, 0x00ec, \"US\", \"?\" },\n    { 0x0019, 0x00f0, \"xs\", \"?\" },\n    { 0x0019, 0x00f1, \"xs\", \"?\" },\n    { 0x0019, 0x00f2, \"xs\", \"?\" },\n    { 0x0019, 0x00f3, \"xs\", \"?\" },\n    { 0x0019, 0x00f4, \"LT\", \"?\" },\n    { 0x0019, 0x00f9, \"DS\", \"Transmission Gain\" },\n    { 0x0019, 0x1015, \"UN\", \"?\" },\n    { 0x0020, 0x0000, \"UL\", \"Relationship Group Length\" },\n    { 0x0020, 0x000d, \"UI\", \"Study Instance UID\" },\n    { 0x0020, 0x000e, \"UI\", \"Series Instance UID\" },\n    { 0x0020, 0x0010, \"SH\", \"Study ID\" },\n    { 0x0020, 0x0011, \"IS\", \"Series Number\" },\n    { 0x0020, 0x0012, \"IS\", \"Acquisition Number\" },\n    { 0x0020, 0x0013, \"IS\", \"Instance (formerly Image) Number\" },\n    { 0x0020, 0x0014, \"IS\", \"Isotope Number\" },\n    { 0x0020, 0x0015, \"IS\", \"Phase Number\" },\n    { 0x0020, 0x0016, \"IS\", \"Interval Number\" },\n    { 0x0020, 0x0017, \"IS\", \"Time Slot Number\" },\n    { 0x0020, 0x0018, \"IS\", \"Angle Number\" },\n    { 0x0020, 0x0020, \"CS\", \"Patient Orientation\" },\n    { 0x0020, 0x0022, \"IS\", \"Overlay Number\" },\n    { 0x0020, 0x0024, \"IS\", \"Curve Number\" },\n    { 0x0020, 0x0026, \"IS\", \"LUT Number\" },\n    { 0x0020, 0x0030, \"DS\", \"Image Position\" },\n    { 0x0020, 0x0032, \"DS\", \"Image Position (Patient)\" },\n    { 0x0020, 0x0035, \"DS\", \"Image Orientation\" },\n    { 0x0020, 0x0037, \"DS\", \"Image Orientation (Patient)\" },\n    { 0x0020, 0x0050, \"DS\", \"Location\" },\n    { 0x0020, 0x0052, \"UI\", \"Frame of Reference UID\" },\n    { 0x0020, 0x0060, \"CS\", \"Laterality\" },\n    { 0x0020, 0x0062, \"CS\", \"Image Laterality\" },\n    { 0x0020, 0x0070, \"LT\", \"Image Geometry Type\" },\n    { 0x0020, 0x0080, \"LO\", \"Masking Image\" },\n    { 0x0020, 0x0100, \"IS\", \"Temporal Position Identifier\" },\n    { 0x0020, 0x0105, \"IS\", \"Number of Temporal Positions\" },\n    { 0x0020, 0x0110, \"DS\", \"Temporal Resolution\" },\n    { 0x0020, 0x1000, \"IS\", \"Series in Study\" },\n    { 0x0020, 0x1001, \"DS\", \"Acquisitions in Series\" },\n    { 0x0020, 0x1002, \"IS\", \"Images in Acquisition\" },\n    { 0x0020, 0x1003, \"IS\", \"Images in Series\" },\n    { 0x0020, 0x1004, \"IS\", \"Acquisitions in Study\" },\n    { 0x0020, 0x1005, \"IS\", \"Images in Study\" },\n    { 0x0020, 0x1020, \"LO\", \"Reference\" },\n    { 0x0020, 0x1040, \"LO\", \"Position Reference Indicator\" },\n    { 0x0020, 0x1041, \"DS\", \"Slice Location\" },\n    { 0x0020, 0x1070, \"IS\", \"Other Study Numbers\" },\n    { 0x0020, 0x1200, \"IS\", \"Number of Patient Related Studies\" },\n    { 0x0020, 0x1202, \"IS\", \"Number of Patient Related Series\" },\n    { 0x0020, 0x1204, \"IS\", \"Number of Patient Related Images\" },\n    { 0x0020, 0x1206, \"IS\", \"Number of Study Related Series\" },\n    { 0x0020, 0x1208, \"IS\", \"Number of Study Related Series\" },\n    { 0x0020, 0x3100, \"LO\", \"Source Image IDs\" },\n    { 0x0020, 0x3401, \"LO\", \"Modifying Device ID\" },\n    { 0x0020, 0x3402, \"LO\", \"Modified Image ID\" },\n    { 0x0020, 0x3403, \"xs\", \"Modified Image Date\" },\n    { 0x0020, 0x3404, \"LO\", \"Modifying Device Manufacturer\" },\n    { 0x0020, 0x3405, \"xs\", \"Modified Image Time\" },\n    { 0x0020, 0x3406, \"xs\", \"Modified Image Description\" },\n    { 0x0020, 0x4000, \"LT\", \"Image Comments\" },\n    { 0x0020, 0x5000, \"AT\", \"Original Image Identification\" },\n    { 0x0020, 0x5002, \"LO\", \"Original Image Identification Nomenclature\" },\n    { 0x0021, 0x0000, \"xs\", \"?\" },\n    { 0x0021, 0x0001, \"xs\", \"?\" },\n    { 0x0021, 0x0002, \"xs\", \"?\" },\n    { 0x0021, 0x0003, \"xs\", \"?\" },\n    { 0x0021, 0x0004, \"DS\", \"VOI Position\" },\n    { 0x0021, 0x0005, \"xs\", \"?\" },\n    { 0x0021, 0x0006, \"IS\", \"CSI Matrix Size Original\" },\n    { 0x0021, 0x0007, \"xs\", \"?\" },\n    { 0x0021, 0x0008, \"DS\", \"Spatial Grid Shift\" },\n    { 0x0021, 0x0009, \"DS\", \"Signal Limits Minimum\" },\n    { 0x0021, 0x0010, \"xs\", \"?\" },\n    { 0x0021, 0x0011, \"xs\", \"?\" },\n    { 0x0021, 0x0012, \"xs\", \"?\" },\n    { 0x0021, 0x0013, \"xs\", \"?\" },\n    { 0x0021, 0x0014, \"xs\", \"?\" },\n    { 0x0021, 0x0015, \"xs\", \"?\" },\n    { 0x0021, 0x0016, \"xs\", \"?\" },\n    { 0x0021, 0x0017, \"DS\", \"EPI Operation Mode Flag\" },\n    { 0x0021, 0x0018, \"xs\", \"?\" },\n    { 0x0021, 0x0019, \"xs\", \"?\" },\n    { 0x0021, 0x0020, \"xs\", \"?\" },\n    { 0x0021, 0x0021, \"xs\", \"?\" },\n    { 0x0021, 0x0022, \"xs\", \"?\" },\n    { 0x0021, 0x0024, \"xs\", \"?\" },\n    { 0x0021, 0x0025, \"US\", \"?\" },\n    { 0x0021, 0x0026, \"IS\", \"Image Pixel Offset\" },\n    { 0x0021, 0x0030, \"xs\", \"?\" },\n    { 0x0021, 0x0031, \"xs\", \"?\" },\n    { 0x0021, 0x0032, \"xs\", \"?\" },\n    { 0x0021, 0x0034, \"xs\", \"?\" },\n    { 0x0021, 0x0035, \"SS\", \"Series From Which Prescribed\" },\n    { 0x0021, 0x0036, \"xs\", \"?\" },\n    { 0x0021, 0x0037, \"SS\", \"Screen Format\" },\n    { 0x0021, 0x0039, \"DS\", \"Slab Thickness\" },\n    { 0x0021, 0x0040, \"xs\", \"?\" },\n    { 0x0021, 0x0041, \"xs\", \"?\" },\n    { 0x0021, 0x0042, \"xs\", \"?\" },\n    { 0x0021, 0x0043, \"xs\", \"?\" },\n    { 0x0021, 0x0044, \"xs\", \"?\" },\n    { 0x0021, 0x0045, \"xs\", \"?\" },\n    { 0x0021, 0x0046, \"xs\", \"?\" },\n    { 0x0021, 0x0047, \"xs\", \"?\" },\n    { 0x0021, 0x0048, \"xs\", \"?\" },\n    { 0x0021, 0x0049, \"xs\", \"?\" },\n    { 0x0021, 0x004a, \"xs\", \"?\" },\n    { 0x0021, 0x004e, \"US\", \"?\" },\n    { 0x0021, 0x004f, \"xs\", \"?\" },\n    { 0x0021, 0x0050, \"xs\", \"?\" },\n    { 0x0021, 0x0051, \"xs\", \"?\" },\n    { 0x0021, 0x0052, \"xs\", \"?\" },\n    { 0x0021, 0x0053, \"xs\", \"?\" },\n    { 0x0021, 0x0054, \"xs\", \"?\" },\n    { 0x0021, 0x0055, \"xs\", \"?\" },\n    { 0x0021, 0x0056, \"xs\", \"?\" },\n    { 0x0021, 0x0057, \"xs\", \"?\" },\n    { 0x0021, 0x0058, \"xs\", \"?\" },\n    { 0x0021, 0x0059, \"xs\", \"?\" },\n    { 0x0021, 0x005a, \"SL\", \"Integer Slop\" },\n    { 0x0021, 0x005b, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005c, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005d, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005e, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x005f, \"DS\", \"Float Slop\" },\n    { 0x0021, 0x0060, \"xs\", \"?\" },\n    { 0x0021, 0x0061, \"DS\", \"Image Normal\" },\n    { 0x0021, 0x0062, \"IS\", \"Reference Type Code\" },\n    { 0x0021, 0x0063, \"DS\", \"Image Distance\" },\n    { 0x0021, 0x0065, \"US\", \"Image Positioning History Mask\" },\n    { 0x0021, 0x006a, \"DS\", \"Image Row\" },\n    { 0x0021, 0x006b, \"DS\", \"Image Column\" },\n    { 0x0021, 0x0070, \"xs\", \"?\" },\n    { 0x0021, 0x0071, \"xs\", \"?\" },\n    { 0x0021, 0x0072, \"xs\", \"?\" },\n    { 0x0021, 0x0073, \"DS\", \"Second Repetition Time\" },\n    { 0x0021, 0x0075, \"DS\", \"Light Brightness\" },\n    { 0x0021, 0x0076, \"DS\", \"Light Contrast\" },\n    { 0x0021, 0x007a, \"IS\", \"Overlay Threshold\" },\n    { 0x0021, 0x007b, \"IS\", \"Surface Threshold\" },\n    { 0x0021, 0x007c, \"IS\", \"Grey Scale Threshold\" },\n    { 0x0021, 0x0080, \"xs\", \"?\" },\n    { 0x0021, 0x0081, \"DS\", \"Auto Window Level Alpha\" },\n    { 0x0021, 0x0082, \"xs\", \"?\" },\n    { 0x0021, 0x0083, \"DS\", \"Auto Window Level Window\" },\n    { 0x0021, 0x0084, \"DS\", \"Auto Window Level Level\" },\n    { 0x0021, 0x0090, \"xs\", \"?\" },\n    { 0x0021, 0x0091, \"xs\", \"?\" },\n    { 0x0021, 0x0092, \"xs\", \"?\" },\n    { 0x0021, 0x0093, \"xs\", \"?\" },\n    { 0x0021, 0x0094, \"DS\", \"EPI Change Value of X Component\" },\n    { 0x0021, 0x0095, \"DS\", \"EPI Change Value of Y Component\" },\n    { 0x0021, 0x0096, \"DS\", \"EPI Change Value of Z Component\" },\n    { 0x0021, 0x00a0, \"xs\", \"?\" },\n    { 0x0021, 0x00a1, \"DS\", \"?\" },\n    { 0x0021, 0x00a2, \"xs\", \"?\" },\n    { 0x0021, 0x00a3, \"LT\", \"?\" },\n    { 0x0021, 0x00a4, \"LT\", \"?\" },\n    { 0x0021, 0x00a7, \"LT\", \"?\" },\n    { 0x0021, 0x00b0, \"IS\", \"?\" },\n    { 0x0021, 0x00c0, \"IS\", \"?\" },\n    { 0x0023, 0x0000, \"xs\", \"?\" },\n    { 0x0023, 0x0001, \"SL\", \"Number Of Series In Study\" },\n    { 0x0023, 0x0002, \"SL\", \"Number Of Unarchived Series\" },\n    { 0x0023, 0x0010, \"xs\", \"?\" },\n    { 0x0023, 0x0020, \"xs\", \"?\" },\n    { 0x0023, 0x0030, \"xs\", \"?\" },\n    { 0x0023, 0x0040, \"xs\", \"?\" },\n    { 0x0023, 0x0050, \"xs\", \"?\" },\n    { 0x0023, 0x0060, \"xs\", \"?\" },\n    { 0x0023, 0x0070, \"xs\", \"?\" },\n    { 0x0023, 0x0074, \"SL\", \"Number Of Updates To Info\" },\n    { 0x0023, 0x007d, \"SS\", \"Indicates If Study Has Complete Info\" },\n    { 0x0023, 0x0080, \"xs\", \"?\" },\n    { 0x0023, 0x0090, \"xs\", \"?\" },\n    { 0x0023, 0x00ff, \"US\", \"?\" },\n    { 0x0025, 0x0000, \"UL\", \"Group Length\" },\n    { 0x0025, 0x0006, \"SS\", \"Last Pulse Sequence Used\" },\n    { 0x0025, 0x0007, \"SL\", \"Images In Series\" },\n    { 0x0025, 0x0010, \"SS\", \"Landmark Counter\" },\n    { 0x0025, 0x0011, \"SS\", \"Number Of Acquisitions\" },\n    { 0x0025, 0x0014, \"SL\", \"Indicates Number Of Updates To Info\" },\n    { 0x0025, 0x0017, \"SL\", \"Series Complete Flag\" },\n    { 0x0025, 0x0018, \"SL\", \"Number Of Images Archived\" },\n    { 0x0025, 0x0019, \"SL\", \"Last Image Number Used\" },\n    { 0x0025, 0x001a, \"SH\", \"Primary Receiver Suite And Host\" },\n    { 0x0027, 0x0000, \"US\", \"?\" },\n    { 0x0027, 0x0006, \"SL\", \"Image Archive Flag\" },\n    { 0x0027, 0x0010, \"SS\", \"Scout Type\" },\n    { 0x0027, 0x0011, \"UN\", \"?\" },\n    { 0x0027, 0x0012, \"IS\", \"?\" },\n    { 0x0027, 0x0013, \"IS\", \"?\" },\n    { 0x0027, 0x0014, \"IS\", \"?\" },\n    { 0x0027, 0x0015, \"IS\", \"?\" },\n    { 0x0027, 0x0016, \"LT\", \"?\" },\n    { 0x0027, 0x001c, \"SL\", \"Vma Mamp\" },\n    { 0x0027, 0x001d, \"SS\", \"Vma Phase\" },\n    { 0x0027, 0x001e, \"SL\", \"Vma Mod\" },\n    { 0x0027, 0x001f, \"SL\", \"Vma Clip\" },\n    { 0x0027, 0x0020, \"SS\", \"Smart Scan On Off Flag\" },\n    { 0x0027, 0x0030, \"SH\", \"Foreign Image Revision\" },\n    { 0x0027, 0x0031, \"SS\", \"Imaging Mode\" },\n    { 0x0027, 0x0032, \"SS\", \"Pulse Sequence\" },\n    { 0x0027, 0x0033, \"SL\", \"Imaging Options\" },\n    { 0x0027, 0x0035, \"SS\", \"Plane Type\" },\n    { 0x0027, 0x0036, \"SL\", \"Oblique Plane\" },\n    { 0x0027, 0x0040, \"SH\", \"RAS Letter Of Image Location\" },\n    { 0x0027, 0x0041, \"FL\", \"Image Location\" },\n    { 0x0027, 0x0042, \"FL\", \"Center R Coord Of Plane Image\" },\n    { 0x0027, 0x0043, \"FL\", \"Center A Coord Of Plane Image\" },\n    { 0x0027, 0x0044, \"FL\", \"Center S Coord Of Plane Image\" },\n    { 0x0027, 0x0045, \"FL\", \"Normal R Coord\" },\n    { 0x0027, 0x0046, \"FL\", \"Normal A Coord\" },\n    { 0x0027, 0x0047, \"FL\", \"Normal S Coord\" },\n    { 0x0027, 0x0048, \"FL\", \"R Coord Of Top Right Corner\" },\n    { 0x0027, 0x0049, \"FL\", \"A Coord Of Top Right Corner\" },\n    { 0x0027, 0x004a, \"FL\", \"S Coord Of Top Right Corner\" },\n    { 0x0027, 0x004b, \"FL\", \"R Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x004c, \"FL\", \"A Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x004d, \"FL\", \"S Coord Of Bottom Right Corner\" },\n    { 0x0027, 0x0050, \"FL\", \"Table Start Location\" },\n    { 0x0027, 0x0051, \"FL\", \"Table End Location\" },\n    { 0x0027, 0x0052, \"SH\", \"RAS Letter For Side Of Image\" },\n    { 0x0027, 0x0053, \"SH\", \"RAS Letter For Anterior Posterior\" },\n    { 0x0027, 0x0054, \"SH\", \"RAS Letter For Scout Start Loc\" },\n    { 0x0027, 0x0055, \"SH\", \"RAS Letter For Scout End Loc\" },\n    { 0x0027, 0x0060, \"FL\", \"Image Dimension X\" },\n    { 0x0027, 0x0061, \"FL\", \"Image Dimension Y\" },\n    { 0x0027, 0x0062, \"FL\", \"Number Of Excitations\" },\n    { 0x0028, 0x0000, \"UL\", \"Image Presentation Group Length\" },\n    { 0x0028, 0x0002, \"US\", \"Samples per Pixel\" },\n    { 0x0028, 0x0004, \"CS\", \"Photometric Interpretation\" },\n    { 0x0028, 0x0005, \"US\", \"Image Dimensions\" },\n    { 0x0028, 0x0006, \"US\", \"Planar Configuration\" },\n    { 0x0028, 0x0008, \"IS\", \"Number of Frames\" },\n    { 0x0028, 0x0009, \"AT\", \"Frame Increment Pointer\" },\n    { 0x0028, 0x0010, \"US\", \"Rows\" },\n    { 0x0028, 0x0011, \"US\", \"Columns\" },\n    { 0x0028, 0x0012, \"US\", \"Planes\" },\n    { 0x0028, 0x0014, \"US\", \"Ultrasound Color Data Present\" },\n    { 0x0028, 0x0030, \"DS\", \"Pixel Spacing\" },\n    { 0x0028, 0x0031, \"DS\", \"Zoom Factor\" },\n    { 0x0028, 0x0032, \"DS\", \"Zoom Center\" },\n    { 0x0028, 0x0034, \"IS\", \"Pixel Aspect Ratio\" },\n    { 0x0028, 0x0040, \"LO\", \"Image Format\" },\n    { 0x0028, 0x0050, \"LT\", \"Manipulated Image\" },\n    { 0x0028, 0x0051, \"CS\", \"Corrected Image\" },\n    { 0x0028, 0x005f, \"LO\", \"Compression Recognition Code\" },\n    { 0x0028, 0x0060, \"LO\", \"Compression Code\" },\n    { 0x0028, 0x0061, \"SH\", \"Compression Originator\" },\n    { 0x0028, 0x0062, \"SH\", \"Compression Label\" },\n    { 0x0028, 0x0063, \"SH\", \"Compression Description\" },\n    { 0x0028, 0x0065, \"LO\", \"Compression Sequence\" },\n    { 0x0028, 0x0066, \"AT\", \"Compression Step Pointers\" },\n    { 0x0028, 0x0068, \"US\", \"Repeat Interval\" },\n    { 0x0028, 0x0069, \"US\", \"Bits Grouped\" },\n    { 0x0028, 0x0070, \"US\", \"Perimeter Table\" },\n    { 0x0028, 0x0071, \"xs\", \"Perimeter Value\" },\n    { 0x0028, 0x0080, \"US\", \"Predictor Rows\" },\n    { 0x0028, 0x0081, \"US\", \"Predictor Columns\" },\n    { 0x0028, 0x0082, \"US\", \"Predictor Constants\" },\n    { 0x0028, 0x0090, \"LO\", \"Blocked Pixels\" },\n    { 0x0028, 0x0091, \"US\", \"Block Rows\" },\n    { 0x0028, 0x0092, \"US\", \"Block Columns\" },\n    { 0x0028, 0x0093, \"US\", \"Row Overlap\" },\n    { 0x0028, 0x0094, \"US\", \"Column Overlap\" },\n    { 0x0028, 0x0100, \"US\", \"Bits Allocated\" },\n    { 0x0028, 0x0101, \"US\", \"Bits Stored\" },\n    { 0x0028, 0x0102, \"US\", \"High Bit\" },\n    { 0x0028, 0x0103, \"US\", \"Pixel Representation\" },\n    { 0x0028, 0x0104, \"xs\", \"Smallest Valid Pixel Value\" },\n    { 0x0028, 0x0105, \"xs\", \"Largest Valid Pixel Value\" },\n    { 0x0028, 0x0106, \"xs\", \"Smallest Image Pixel Value\" },\n    { 0x0028, 0x0107, \"xs\", \"Largest Image Pixel Value\" },\n    { 0x0028, 0x0108, \"xs\", \"Smallest Pixel Value in Series\" },\n    { 0x0028, 0x0109, \"xs\", \"Largest Pixel Value in Series\" },\n    { 0x0028, 0x0110, \"xs\", \"Smallest Pixel Value in Plane\" },\n    { 0x0028, 0x0111, \"xs\", \"Largest Pixel Value in Plane\" },\n    { 0x0028, 0x0120, \"xs\", \"Pixel Padding Value\" },\n    { 0x0028, 0x0200, \"xs\", \"Image Location\" },\n    { 0x0028, 0x0300, \"CS\", \"Quality Control Image\" },\n    { 0x0028, 0x0301, \"CS\", \"Burned In Annotation\" },\n    { 0x0028, 0x0400, \"xs\", \"?\" },\n    { 0x0028, 0x0401, \"xs\", \"?\" },\n    { 0x0028, 0x0402, \"xs\", \"?\" },\n    { 0x0028, 0x0403, \"xs\", \"?\" },\n    { 0x0028, 0x0404, \"AT\", \"Details of Coefficients\" },\n    { 0x0028, 0x0700, \"LO\", \"DCT Label\" },\n    { 0x0028, 0x0701, \"LO\", \"Data Block Description\" },\n    { 0x0028, 0x0702, \"AT\", \"Data Block\" },\n    { 0x0028, 0x0710, \"US\", \"Normalization Factor Format\" },\n    { 0x0028, 0x0720, \"US\", \"Zonal Map Number Format\" },\n    { 0x0028, 0x0721, \"AT\", \"Zonal Map Location\" },\n    { 0x0028, 0x0722, \"US\", \"Zonal Map Format\" },\n    { 0x0028, 0x0730, \"US\", \"Adaptive Map Format\" },\n    { 0x0028, 0x0740, \"US\", \"Code Number Format\" },\n    { 0x0028, 0x0800, \"LO\", \"Code Label\" },\n    { 0x0028, 0x0802, \"US\", \"Number of Tables\" },\n    { 0x0028, 0x0803, \"AT\", \"Code Table Location\" },\n    { 0x0028, 0x0804, \"US\", \"Bits For Code Word\" },\n    { 0x0028, 0x0808, \"AT\", \"Image Data Location\" },\n    { 0x0028, 0x1040, \"CS\", \"Pixel Intensity Relationship\" },\n    { 0x0028, 0x1041, \"SS\", \"Pixel Intensity Relationship Sign\" },\n    { 0x0028, 0x1050, \"DS\", \"Window Center\" },\n    { 0x0028, 0x1051, \"DS\", \"Window Width\" },\n    { 0x0028, 0x1052, \"DS\", \"Rescale Intercept\" },\n    { 0x0028, 0x1053, \"DS\", \"Rescale Slope\" },\n    { 0x0028, 0x1054, \"LO\", \"Rescale Type\" },\n    { 0x0028, 0x1055, \"LO\", \"Window Center & Width Explanation\" },\n    { 0x0028, 0x1080, \"LO\", \"Gray Scale\" },\n    { 0x0028, 0x1090, \"CS\", \"Recommended Viewing Mode\" },\n    { 0x0028, 0x1100, \"xs\", \"Gray Lookup Table Descriptor\" },\n    { 0x0028, 0x1101, \"xs\", \"Red Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1102, \"xs\", \"Green Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1103, \"xs\", \"Blue Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1111, \"OW\", \"Large Red Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1112, \"OW\", \"Large Green Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1113, \"OW\", \"Large Blue Palette Color Lookup Table Descriptor\" },\n    { 0x0028, 0x1199, \"UI\", \"Palette Color Lookup Table UID\" },\n    { 0x0028, 0x1200, \"xs\", \"Gray Lookup Table Data\" },\n    { 0x0028, 0x1201, \"OW\", \"Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1202, \"OW\", \"Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1203, \"OW\", \"Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1211, \"OW\", \"Large Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1212, \"OW\", \"Large Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1213, \"OW\", \"Large Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1214, \"UI\", \"Large Palette Color Lookup Table UID\" },\n    { 0x0028, 0x1221, \"OW\", \"Segmented Red Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1222, \"OW\", \"Segmented Green Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1223, \"OW\", \"Segmented Blue Palette Color Lookup Table Data\" },\n    { 0x0028, 0x1300, \"CS\", \"Implant Present\" },\n    { 0x0028, 0x2110, \"CS\", \"Lossy Image Compression\" },\n    { 0x0028, 0x2112, \"DS\", \"Lossy Image Compression Ratio\" },\n    { 0x0028, 0x3000, \"SQ\", \"Modality LUT Sequence\" },\n    { 0x0028, 0x3002, \"US\", \"LUT Descriptor\" },\n    { 0x0028, 0x3003, \"LO\", \"LUT Explanation\" },\n    { 0x0028, 0x3004, \"LO\", \"Modality LUT Type\" },\n    { 0x0028, 0x3006, \"US\", \"LUT Data\" },\n    { 0x0028, 0x3010, \"xs\", \"VOI LUT Sequence\" },\n    { 0x0028, 0x4000, \"LT\", \"Image Presentation Comments\" },\n    { 0x0028, 0x5000, \"SQ\", \"Biplane Acquisition Sequence\" },\n    { 0x0028, 0x6010, \"US\", \"Representative Frame Number\" },\n    { 0x0028, 0x6020, \"US\", \"Frame Numbers of Interest\" },\n    { 0x0028, 0x6022, \"LO\", \"Frame of Interest Description\" },\n    { 0x0028, 0x6030, \"US\", \"Mask Pointer\" },\n    { 0x0028, 0x6040, \"US\", \"R Wave Pointer\" },\n    { 0x0028, 0x6100, \"SQ\", \"Mask Subtraction Sequence\" },\n    { 0x0028, 0x6101, \"CS\", \"Mask Operation\" },\n    { 0x0028, 0x6102, \"US\", \"Applicable Frame Range\" },\n    { 0x0028, 0x6110, \"US\", \"Mask Frame Numbers\" },\n    { 0x0028, 0x6112, \"US\", \"Contrast Frame Averaging\" },\n    { 0x0028, 0x6114, \"FL\", \"Mask Sub-Pixel Shift\" },\n    { 0x0028, 0x6120, \"SS\", \"TID Offset\" },\n    { 0x0028, 0x6190, \"ST\", \"Mask Operation Explanation\" },\n    { 0x0029, 0x0000, \"xs\", \"?\" },\n    { 0x0029, 0x0001, \"xs\", \"?\" },\n    { 0x0029, 0x0002, \"xs\", \"?\" },\n    { 0x0029, 0x0003, \"xs\", \"?\" },\n    { 0x0029, 0x0004, \"xs\", \"?\" },\n    { 0x0029, 0x0005, \"xs\", \"?\" },\n    { 0x0029, 0x0006, \"xs\", \"?\" },\n    { 0x0029, 0x0007, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0008, \"SH\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0009, \"SH\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x000a, \"SS\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x000c, \"xs\", \"?\" },\n    { 0x0029, 0x000e, \"CS\", \"Zoom Enable Status\" },\n    { 0x0029, 0x000f, \"CS\", \"Zoom Select Status\" },\n    { 0x0029, 0x0010, \"xs\", \"?\" },\n    { 0x0029, 0x0011, \"xs\", \"?\" },\n    { 0x0029, 0x0013, \"LT\", \"?\" },\n    { 0x0029, 0x0015, \"xs\", \"?\" },\n    { 0x0029, 0x0016, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0017, \"SL\", \"Lower Range Of Pixels\" },\n    { 0x0029, 0x0018, \"SL\", \"Upper Range Of Pixels\" },\n    { 0x0029, 0x001a, \"SL\", \"Length Of Total Info In Bytes\" },\n    { 0x0029, 0x001e, \"xs\", \"?\" },\n    { 0x0029, 0x001f, \"xs\", \"?\" },\n    { 0x0029, 0x0020, \"xs\", \"?\" },\n    { 0x0029, 0x0022, \"IS\", \"Pixel Quality Value\" },\n    { 0x0029, 0x0025, \"LT\", \"Processed Pixel Data Quality\" },\n    { 0x0029, 0x0026, \"SS\", \"Version Of Info Structure\" },\n    { 0x0029, 0x0030, \"xs\", \"?\" },\n    { 0x0029, 0x0031, \"xs\", \"?\" },\n    { 0x0029, 0x0032, \"xs\", \"?\" },\n    { 0x0029, 0x0033, \"xs\", \"?\" },\n    { 0x0029, 0x0034, \"xs\", \"?\" },\n    { 0x0029, 0x0035, \"SL\", \"Advantage Comp Underflow\" },\n    { 0x0029, 0x0038, \"US\", \"?\" },\n    { 0x0029, 0x0040, \"xs\", \"?\" },\n    { 0x0029, 0x0041, \"DS\", \"Magnifying Glass Rectangle\" },\n    { 0x0029, 0x0043, \"DS\", \"Magnifying Glass Factor\" },\n    { 0x0029, 0x0044, \"US\", \"Magnifying Glass Function\" },\n    { 0x0029, 0x004e, \"CS\", \"Magnifying Glass Enable Status\" },\n    { 0x0029, 0x004f, \"CS\", \"Magnifying Glass Select Status\" },\n    { 0x0029, 0x0050, \"xs\", \"?\" },\n    { 0x0029, 0x0051, \"LT\", \"Exposure Code\" },\n    { 0x0029, 0x0052, \"LT\", \"Sort Code\" },\n    { 0x0029, 0x0053, \"LT\", \"?\" },\n    { 0x0029, 0x0060, \"xs\", \"?\" },\n    { 0x0029, 0x0061, \"xs\", \"?\" },\n    { 0x0029, 0x0067, \"LT\", \"?\" },\n    { 0x0029, 0x0070, \"xs\", \"?\" },\n    { 0x0029, 0x0071, \"xs\", \"?\" },\n    { 0x0029, 0x0072, \"xs\", \"?\" },\n    { 0x0029, 0x0077, \"CS\", \"Window Select Status\" },\n    { 0x0029, 0x0078, \"LT\", \"ECG Display Printing ID\" },\n    { 0x0029, 0x0079, \"CS\", \"ECG Display Printing\" },\n    { 0x0029, 0x007e, \"CS\", \"ECG Display Printing Enable Status\" },\n    { 0x0029, 0x007f, \"CS\", \"ECG Display Printing Select Status\" },\n    { 0x0029, 0x0080, \"xs\", \"?\" },\n    { 0x0029, 0x0081, \"xs\", \"?\" },\n    { 0x0029, 0x0082, \"IS\", \"View Zoom\" },\n    { 0x0029, 0x0083, \"IS\", \"View Transform\" },\n    { 0x0029, 0x008e, \"CS\", \"Physiological Display Enable Status\" },\n    { 0x0029, 0x008f, \"CS\", \"Physiological Display Select Status\" },\n    { 0x0029, 0x0090, \"IS\", \"?\" },\n    { 0x0029, 0x0099, \"LT\", \"Shutter Type\" },\n    { 0x0029, 0x00a0, \"US\", \"Rows of Rectangular Shutter\" },\n    { 0x0029, 0x00a1, \"US\", \"Columns of Rectangular Shutter\" },\n    { 0x0029, 0x00a2, \"US\", \"Origin of Rectangular Shutter\" },\n    { 0x0029, 0x00b0, \"US\", \"Radius of Circular Shutter\" },\n    { 0x0029, 0x00b2, \"US\", \"Origin of Circular Shutter\" },\n    { 0x0029, 0x00c0, \"LT\", \"Functional Shutter ID\" },\n    { 0x0029, 0x00c1, \"xs\", \"?\" },\n    { 0x0029, 0x00c3, \"IS\", \"Scan Resolution\" },\n    { 0x0029, 0x00c4, \"IS\", \"Field of View\" },\n    { 0x0029, 0x00c5, \"LT\", \"Field Of Shutter Rectangle\" },\n    { 0x0029, 0x00ce, \"CS\", \"Shutter Enable Status\" },\n    { 0x0029, 0x00cf, \"CS\", \"Shutter Select Status\" },\n    { 0x0029, 0x00d0, \"IS\", \"?\" },\n    { 0x0029, 0x00d1, \"IS\", \"?\" },\n    { 0x0029, 0x00d5, \"LT\", \"Slice Thickness\" },\n    { 0x0031, 0x0010, \"LT\", \"Request UID\" },\n    { 0x0031, 0x0012, \"LT\", \"Examination Reason\" },\n    { 0x0031, 0x0030, \"DA\", \"Requested Date\" },\n    { 0x0031, 0x0032, \"TM\", \"Worklist Request Start Time\" },\n    { 0x0031, 0x0033, \"TM\", \"Worklist Request End Time\" },\n    { 0x0031, 0x0045, \"LT\", \"Requesting Physician\" },\n    { 0x0031, 0x004a, \"TM\", \"Requested Time\" },\n    { 0x0031, 0x0050, \"LT\", \"Requested Physician\" },\n    { 0x0031, 0x0080, \"LT\", \"Requested Location\" },\n    { 0x0032, 0x0000, \"UL\", \"Study Group Length\" },\n    { 0x0032, 0x000a, \"CS\", \"Study Status ID\" },\n    { 0x0032, 0x000c, \"CS\", \"Study Priority ID\" },\n    { 0x0032, 0x0012, \"LO\", \"Study ID Issuer\" },\n    { 0x0032, 0x0032, \"DA\", \"Study Verified Date\" },\n    { 0x0032, 0x0033, \"TM\", \"Study Verified Time\" },\n    { 0x0032, 0x0034, \"DA\", \"Study Read Date\" },\n    { 0x0032, 0x0035, \"TM\", \"Study Read Time\" },\n    { 0x0032, 0x1000, \"DA\", \"Scheduled Study Start Date\" },\n    { 0x0032, 0x1001, \"TM\", \"Scheduled Study Start Time\" },\n    { 0x0032, 0x1010, \"DA\", \"Scheduled Study Stop Date\" },\n    { 0x0032, 0x1011, \"TM\", \"Scheduled Study Stop Time\" },\n    { 0x0032, 0x1020, \"LO\", \"Scheduled Study Location\" },\n    { 0x0032, 0x1021, \"AE\", \"Scheduled Study Location AE Title(s)\" },\n    { 0x0032, 0x1030, \"LO\", \"Reason for Study\" },\n    { 0x0032, 0x1032, \"PN\", \"Requesting Physician\" },\n    { 0x0032, 0x1033, \"LO\", \"Requesting Service\" },\n    { 0x0032, 0x1040, \"DA\", \"Study Arrival Date\" },\n    { 0x0032, 0x1041, \"TM\", \"Study Arrival Time\" },\n    { 0x0032, 0x1050, \"DA\", \"Study Completion Date\" },\n    { 0x0032, 0x1051, \"TM\", \"Study Completion Time\" },\n    { 0x0032, 0x1055, \"CS\", \"Study Component Status ID\" },\n    { 0x0032, 0x1060, \"LO\", \"Requested Procedure Description\" },\n    { 0x0032, 0x1064, \"SQ\", \"Requested Procedure Code Sequence\" },\n    { 0x0032, 0x1070, \"LO\", \"Requested Contrast Agent\" },\n    { 0x0032, 0x4000, \"LT\", \"Study Comments\" },\n    { 0x0033, 0x0001, \"UN\", \"?\" },\n    { 0x0033, 0x0002, \"UN\", \"?\" },\n    { 0x0033, 0x0005, \"UN\", \"?\" },\n    { 0x0033, 0x0006, \"UN\", \"?\" },\n    { 0x0033, 0x0010, \"LT\", \"Patient Study UID\" },\n    { 0x0037, 0x0010, \"LO\", \"ReferringDepartment\" },\n    { 0x0037, 0x0020, \"US\", \"ScreenNumber\" },\n    { 0x0037, 0x0040, \"SH\", \"LeftOrientation\" },\n    { 0x0037, 0x0042, \"SH\", \"RightOrientation\" },\n    { 0x0037, 0x0050, \"CS\", \"Inversion\" },\n    { 0x0037, 0x0060, \"US\", \"DSA\" },\n    { 0x0038, 0x0000, \"UL\", \"Visit Group Length\" },\n    { 0x0038, 0x0004, \"SQ\", \"Referenced Patient Alias Sequence\" },\n    { 0x0038, 0x0008, \"CS\", \"Visit Status ID\" },\n    { 0x0038, 0x0010, \"LO\", \"Admission ID\" },\n    { 0x0038, 0x0011, \"LO\", \"Issuer of Admission ID\" },\n    { 0x0038, 0x0016, \"LO\", \"Route of Admissions\" },\n    { 0x0038, 0x001a, \"DA\", \"Scheduled Admission Date\" },\n    { 0x0038, 0x001b, \"TM\", \"Scheduled Admission Time\" },\n    { 0x0038, 0x001c, \"DA\", \"Scheduled Discharge Date\" },\n    { 0x0038, 0x001d, \"TM\", \"Scheduled Discharge Time\" },\n    { 0x0038, 0x001e, \"LO\", \"Scheduled Patient Institution Residence\" },\n    { 0x0038, 0x0020, \"DA\", \"Admitting Date\" },\n    { 0x0038, 0x0021, \"TM\", \"Admitting Time\" },\n    { 0x0038, 0x0030, \"DA\", \"Discharge Date\" },\n    { 0x0038, 0x0032, \"TM\", \"Discharge Time\" },\n    { 0x0038, 0x0040, \"LO\", \"Discharge Diagnosis Description\" },\n    { 0x0038, 0x0044, \"SQ\", \"Discharge Diagnosis Code Sequence\" },\n    { 0x0038, 0x0050, \"LO\", \"Special Needs\" },\n    { 0x0038, 0x0300, \"LO\", \"Current Patient Location\" },\n    { 0x0038, 0x0400, \"LO\", \"Patient's Institution Residence\" },\n    { 0x0038, 0x0500, \"LO\", \"Patient State\" },\n    { 0x0038, 0x4000, \"LT\", \"Visit Comments\" },\n    { 0x0039, 0x0080, \"IS\", \"Private Entity Number\" },\n    { 0x0039, 0x0085, \"DA\", \"Private Entity Date\" },\n    { 0x0039, 0x0090, \"TM\", \"Private Entity Time\" },\n    { 0x0039, 0x0095, \"LO\", \"Private Entity Launch Command\" },\n    { 0x0039, 0x00aa, \"CS\", \"Private Entity Type\" },\n    { 0x003a, 0x0002, \"SQ\", \"Waveform Sequence\" },\n    { 0x003a, 0x0005, \"US\", \"Waveform Number of Channels\" },\n    { 0x003a, 0x0010, \"UL\", \"Waveform Number of Samples\" },\n    { 0x003a, 0x001a, \"DS\", \"Sampling Frequency\" },\n    { 0x003a, 0x0020, \"SH\", \"Group Label\" },\n    { 0x003a, 0x0103, \"CS\", \"Waveform Sample Value Representation\" },\n    { 0x003a, 0x0122, \"OB\", \"Waveform Padding Value\" },\n    { 0x003a, 0x0200, \"SQ\", \"Channel Definition\" },\n    { 0x003a, 0x0202, \"IS\", \"Waveform Channel Number\" },\n    { 0x003a, 0x0203, \"SH\", \"Channel Label\" },\n    { 0x003a, 0x0205, \"CS\", \"Channel Status\" },\n    { 0x003a, 0x0208, \"SQ\", \"Channel Source\" },\n    { 0x003a, 0x0209, \"SQ\", \"Channel Source Modifiers\" },\n    { 0x003a, 0x020a, \"SQ\", \"Differential Channel Source\" },\n    { 0x003a, 0x020b, \"SQ\", \"Differential Channel Source Modifiers\" },\n    { 0x003a, 0x0210, \"DS\", \"Channel Sensitivity\" },\n    { 0x003a, 0x0211, \"SQ\", \"Channel Sensitivity Units\" },\n    { 0x003a, 0x0212, \"DS\", \"Channel Sensitivity Correction Factor\" },\n    { 0x003a, 0x0213, \"DS\", \"Channel Baseline\" },\n    { 0x003a, 0x0214, \"DS\", \"Channel Time Skew\" },\n    { 0x003a, 0x0215, \"DS\", \"Channel Sample Skew\" },\n    { 0x003a, 0x0216, \"OB\", \"Channel Minimum Value\" },\n    { 0x003a, 0x0217, \"OB\", \"Channel Maximum Value\" },\n    { 0x003a, 0x0218, \"DS\", \"Channel Offset\" },\n    { 0x003a, 0x021a, \"US\", \"Bits Per Sample\" },\n    { 0x003a, 0x0220, \"DS\", \"Filter Low Frequency\" },\n    { 0x003a, 0x0221, \"DS\", \"Filter High Frequency\" },\n    { 0x003a, 0x0222, \"DS\", \"Notch Filter Frequency\" },\n    { 0x003a, 0x0223, \"DS\", \"Notch Filter Bandwidth\" },\n    { 0x003a, 0x1000, \"OB\", \"Waveform Data\" },\n    { 0x0040, 0x0001, \"AE\", \"Scheduled Station AE Title\" },\n    { 0x0040, 0x0002, \"DA\", \"Scheduled Procedure Step Start Date\" },\n    { 0x0040, 0x0003, \"TM\", \"Scheduled Procedure Step Start Time\" },\n    { 0x0040, 0x0004, \"DA\", \"Scheduled Procedure Step End Date\" },\n    { 0x0040, 0x0005, \"TM\", \"Scheduled Procedure Step End Time\" },\n    { 0x0040, 0x0006, \"PN\", \"Scheduled Performing Physician Name\" },\n    { 0x0040, 0x0007, \"LO\", \"Scheduled Procedure Step Description\" },\n    { 0x0040, 0x0008, \"SQ\", \"Scheduled Action Item Code Sequence\" },\n    { 0x0040, 0x0009, \"SH\", \"Scheduled Procedure Step ID\" },\n    { 0x0040, 0x0010, \"SH\", \"Scheduled Station Name\" },\n    { 0x0040, 0x0011, \"SH\", \"Scheduled Procedure Step Location\" },\n    { 0x0040, 0x0012, \"LO\", \"Pre-Medication\" },\n    { 0x0040, 0x0020, \"CS\", \"Scheduled Procedure Step Status\" },\n    { 0x0040, 0x0100, \"SQ\", \"Scheduled Procedure Step Sequence\" },\n    { 0x0040, 0x0302, \"US\", \"Entrance Dose\" },\n    { 0x0040, 0x0303, \"US\", \"Exposed Area\" },\n    { 0x0040, 0x0306, \"DS\", \"Distance Source to Entrance\" },\n    { 0x0040, 0x0307, \"DS\", \"Distance Source to Support\" },\n    { 0x0040, 0x0310, \"ST\", \"Comments On Radiation Dose\" },\n    { 0x0040, 0x0312, \"DS\", \"X-Ray Output\" },\n    { 0x0040, 0x0314, \"DS\", \"Half Value Layer\" },\n    { 0x0040, 0x0316, \"DS\", \"Organ Dose\" },\n    { 0x0040, 0x0318, \"CS\", \"Organ Exposed\" },\n    { 0x0040, 0x0400, \"LT\", \"Comments On Scheduled Procedure Step\" },\n    { 0x0040, 0x050a, \"LO\", \"Specimen Accession Number\" },\n    { 0x0040, 0x0550, \"SQ\", \"Specimen Sequence\" },\n    { 0x0040, 0x0551, \"LO\", \"Specimen Identifier\" },\n    { 0x0040, 0x0552, \"SQ\", \"Specimen Description Sequence\" },\n    { 0x0040, 0x0553, \"ST\", \"Specimen Description\" },\n    { 0x0040, 0x0555, \"SQ\", \"Acquisition Context Sequence\" },\n    { 0x0040, 0x0556, \"ST\", \"Acquisition Context Description\" },\n    { 0x0040, 0x059a, \"SQ\", \"Specimen Type Code Sequence\" },\n    { 0x0040, 0x06fa, \"LO\", \"Slide Identifier\" },\n    { 0x0040, 0x071a, \"SQ\", \"Image Center Point Coordinates Sequence\" },\n    { 0x0040, 0x072a, \"DS\", \"X Offset In Slide Coordinate System\" },\n    { 0x0040, 0x073a, \"DS\", \"Y Offset In Slide Coordinate System\" },\n    { 0x0040, 0x074a, \"DS\", \"Z Offset In Slide Coordinate System\" },\n    { 0x0040, 0x08d8, \"SQ\", \"Pixel Spacing Sequence\" },\n    { 0x0040, 0x08da, \"SQ\", \"Coordinate System Axis Code Sequence\" },\n    { 0x0040, 0x08ea, \"SQ\", \"Measurement Units Code Sequence\" },\n    { 0x0040, 0x09f8, \"SQ\", \"Vital Stain Code Sequence\" },\n    { 0x0040, 0x1001, \"SH\", \"Requested Procedure ID\" },\n    { 0x0040, 0x1002, \"LO\", \"Reason For Requested Procedure\" },\n    { 0x0040, 0x1003, \"SH\", \"Requested Procedure Priority\" },\n    { 0x0040, 0x1004, \"LO\", \"Patient Transport Arrangements\" },\n    { 0x0040, 0x1005, \"LO\", \"Requested Procedure Location\" },\n    { 0x0040, 0x1006, \"SH\", \"Placer Order Number of Procedure\" },\n    { 0x0040, 0x1007, \"SH\", \"Filler Order Number of Procedure\" },\n    { 0x0040, 0x1008, \"LO\", \"Confidentiality Code\" },\n    { 0x0040, 0x1009, \"SH\", \"Reporting Priority\" },\n    { 0x0040, 0x1010, \"PN\", \"Names of Intended Recipients of Results\" },\n    { 0x0040, 0x1400, \"LT\", \"Requested Procedure Comments\" },\n    { 0x0040, 0x2001, \"LO\", \"Reason For Imaging Service Request\" },\n    { 0x0040, 0x2004, \"DA\", \"Issue Date of Imaging Service Request\" },\n    { 0x0040, 0x2005, \"TM\", \"Issue Time of Imaging Service Request\" },\n    { 0x0040, 0x2006, \"SH\", \"Placer Order Number of Imaging Service Request\" },\n    { 0x0040, 0x2007, \"SH\", \"Filler Order Number of Imaging Service Request\" },\n    { 0x0040, 0x2008, \"PN\", \"Order Entered By\" },\n    { 0x0040, 0x2009, \"SH\", \"Order Enterer Location\" },\n    { 0x0040, 0x2010, \"SH\", \"Order Callback Phone Number\" },\n    { 0x0040, 0x2400, \"LT\", \"Imaging Service Request Comments\" },\n    { 0x0040, 0x3001, \"LO\", \"Confidentiality Constraint On Patient Data\" },\n    { 0x0040, 0xa007, \"CS\", \"Findings Flag\" },\n    { 0x0040, 0xa020, \"SQ\", \"Findings Sequence\" },\n    { 0x0040, 0xa021, \"UI\", \"Findings Group UID\" },\n    { 0x0040, 0xa022, \"UI\", \"Referenced Findings Group UID\" },\n    { 0x0040, 0xa023, \"DA\", \"Findings Group Recording Date\" },\n    { 0x0040, 0xa024, \"TM\", \"Findings Group Recording Time\" },\n    { 0x0040, 0xa026, \"SQ\", \"Findings Source Category Code Sequence\" },\n    { 0x0040, 0xa027, \"LO\", \"Documenting Organization\" },\n    { 0x0040, 0xa028, \"SQ\", \"Documenting Organization Identifier Code Sequence\" },\n    { 0x0040, 0xa032, \"LO\", \"History Reliability Qualifier Description\" },\n    { 0x0040, 0xa043, \"SQ\", \"Concept Name Code Sequence\" },\n    { 0x0040, 0xa047, \"LO\", \"Measurement Precision Description\" },\n    { 0x0040, 0xa057, \"CS\", \"Urgency or Priority Alerts\" },\n    { 0x0040, 0xa060, \"LO\", \"Sequencing Indicator\" },\n    { 0x0040, 0xa066, \"SQ\", \"Document Identifier Code Sequence\" },\n    { 0x0040, 0xa067, \"PN\", \"Document Author\" },\n    { 0x0040, 0xa068, \"SQ\", \"Document Author Identifier Code Sequence\" },\n    { 0x0040, 0xa070, \"SQ\", \"Identifier Code Sequence\" },\n    { 0x0040, 0xa073, \"LO\", \"Object String Identifier\" },\n    { 0x0040, 0xa074, \"OB\", \"Object Binary Identifier\" },\n    { 0x0040, 0xa075, \"PN\", \"Documenting Observer\" },\n    { 0x0040, 0xa076, \"SQ\", \"Documenting Observer Identifier Code Sequence\" },\n    { 0x0040, 0xa078, \"SQ\", \"Observation Subject Identifier Code Sequence\" },\n    { 0x0040, 0xa080, \"SQ\", \"Person Identifier Code Sequence\" },\n    { 0x0040, 0xa085, \"SQ\", \"Procedure Identifier Code Sequence\" },\n    { 0x0040, 0xa088, \"LO\", \"Object Directory String Identifier\" },\n    { 0x0040, 0xa089, \"OB\", \"Object Directory Binary Identifier\" },\n    { 0x0040, 0xa090, \"CS\", \"History Reliability Qualifier\" },\n    { 0x0040, 0xa0a0, \"CS\", \"Referenced Type of Data\" },\n    { 0x0040, 0xa0b0, \"US\", \"Referenced Waveform Channels\" },\n    { 0x0040, 0xa110, \"DA\", \"Date of Document or Verbal Transaction\" },\n    { 0x0040, 0xa112, \"TM\", \"Time of Document Creation or Verbal Transaction\" },\n    { 0x0040, 0xa121, \"DA\", \"Date\" },\n    { 0x0040, 0xa122, \"TM\", \"Time\" },\n    { 0x0040, 0xa123, \"PN\", \"Person Name\" },\n    { 0x0040, 0xa124, \"SQ\", \"Referenced Person Sequence\" },\n    { 0x0040, 0xa125, \"CS\", \"Report Status ID\" },\n    { 0x0040, 0xa130, \"CS\", \"Temporal Range Type\" },\n    { 0x0040, 0xa132, \"UL\", \"Referenced Sample Offsets\" },\n    { 0x0040, 0xa136, \"US\", \"Referenced Frame Numbers\" },\n    { 0x0040, 0xa138, \"DS\", \"Referenced Time Offsets\" },\n    { 0x0040, 0xa13a, \"DT\", \"Referenced Datetime\" },\n    { 0x0040, 0xa160, \"UT\", \"Text Value\" },\n    { 0x0040, 0xa167, \"SQ\", \"Observation Category Code Sequence\" },\n    { 0x0040, 0xa168, \"SQ\", \"Concept Code Sequence\" },\n    { 0x0040, 0xa16a, \"ST\", \"Bibliographic Citation\" },\n    { 0x0040, 0xa170, \"CS\", \"Observation Class\" },\n    { 0x0040, 0xa171, \"UI\", \"Observation UID\" },\n    { 0x0040, 0xa172, \"UI\", \"Referenced Observation UID\" },\n    { 0x0040, 0xa173, \"CS\", \"Referenced Observation Class\" },\n    { 0x0040, 0xa174, \"CS\", \"Referenced Object Observation Class\" },\n    { 0x0040, 0xa180, \"US\", \"Annotation Group Number\" },\n    { 0x0040, 0xa192, \"DA\", \"Observation Date\" },\n    { 0x0040, 0xa193, \"TM\", \"Observation Time\" },\n    { 0x0040, 0xa194, \"CS\", \"Measurement Automation\" },\n    { 0x0040, 0xa195, \"SQ\", \"Concept Name Code Sequence Modifier\" },\n    { 0x0040, 0xa224, \"ST\", \"Identification Description\" },\n    { 0x0040, 0xa290, \"CS\", \"Coordinates Set Geometric Type\" },\n    { 0x0040, 0xa296, \"SQ\", \"Algorithm Code Sequence\" },\n    { 0x0040, 0xa297, \"ST\", \"Algorithm Description\" },\n    { 0x0040, 0xa29a, \"SL\", \"Pixel Coordinates Set\" },\n    { 0x0040, 0xa300, \"SQ\", \"Measured Value Sequence\" },\n    { 0x0040, 0xa307, \"PN\", \"Current Observer\" },\n    { 0x0040, 0xa30a, \"DS\", \"Numeric Value\" },\n    { 0x0040, 0xa313, \"SQ\", \"Referenced Accession Sequence\" },\n    { 0x0040, 0xa33a, \"ST\", \"Report Status Comment\" },\n    { 0x0040, 0xa340, \"SQ\", \"Procedure Context Sequence\" },\n    { 0x0040, 0xa352, \"PN\", \"Verbal Source\" },\n    { 0x0040, 0xa353, \"ST\", \"Address\" },\n    { 0x0040, 0xa354, \"LO\", \"Telephone Number\" },\n    { 0x0040, 0xa358, \"SQ\", \"Verbal Source Identifier Code Sequence\" },\n    { 0x0040, 0xa380, \"SQ\", \"Report Detail Sequence\" },\n    { 0x0040, 0xa402, \"UI\", \"Observation Subject UID\" },\n    { 0x0040, 0xa403, \"CS\", \"Observation Subject Class\" },\n    { 0x0040, 0xa404, \"SQ\", \"Observation Subject Type Code Sequence\" },\n    { 0x0040, 0xa600, \"CS\", \"Observation Subject Context Flag\" },\n    { 0x0040, 0xa601, \"CS\", \"Observer Context Flag\" },\n    { 0x0040, 0xa603, \"CS\", \"Procedure Context Flag\" },\n    { 0x0040, 0xa730, \"SQ\", \"Observations Sequence\" },\n    { 0x0040, 0xa731, \"SQ\", \"Relationship Sequence\" },\n    { 0x0040, 0xa732, \"SQ\", \"Relationship Type Code Sequence\" },\n    { 0x0040, 0xa744, \"SQ\", \"Language Code Sequence\" },\n    { 0x0040, 0xa992, \"ST\", \"Uniform Resource Locator\" },\n    { 0x0040, 0xb020, \"SQ\", \"Annotation Sequence\" },\n    { 0x0040, 0xdb73, \"SQ\", \"Relationship Type Code Sequence Modifier\" },\n    { 0x0041, 0x0000, \"LT\", \"Papyrus Comments\" },\n    { 0x0041, 0x0010, \"xs\", \"?\" },\n    { 0x0041, 0x0011, \"xs\", \"?\" },\n    { 0x0041, 0x0012, \"UL\", \"Pixel Offset\" },\n    { 0x0041, 0x0013, \"SQ\", \"Image Identifier Sequence\" },\n    { 0x0041, 0x0014, \"SQ\", \"External File Reference Sequence\" },\n    { 0x0041, 0x0015, \"US\", \"Number of Images\" },\n    { 0x0041, 0x0020, \"xs\", \"?\" },\n    { 0x0041, 0x0021, \"UI\", \"Referenced SOP Class UID\" },\n    { 0x0041, 0x0022, \"UI\", \"Referenced SOP Instance UID\" },\n    { 0x0041, 0x0030, \"xs\", \"?\" },\n    { 0x0041, 0x0031, \"xs\", \"?\" },\n    { 0x0041, 0x0032, \"xs\", \"?\" },\n    { 0x0041, 0x0034, \"DA\", \"Modified Date\" },\n    { 0x0041, 0x0036, \"TM\", \"Modified Time\" },\n    { 0x0041, 0x0040, \"LT\", \"Owner Name\" },\n    { 0x0041, 0x0041, \"UI\", \"Referenced Image SOP Class UID\" },\n    { 0x0041, 0x0042, \"UI\", \"Referenced Image SOP Instance UID\" },\n    { 0x0041, 0x0050, \"xs\", \"?\" },\n    { 0x0041, 0x0060, \"UL\", \"Number of Images\" },\n    { 0x0041, 0x0062, \"UL\", \"Number of Other\" },\n    { 0x0041, 0x00a0, \"LT\", \"External Folder Element DSID\" },\n    { 0x0041, 0x00a1, \"US\", \"External Folder Element Data Set Type\" },\n    { 0x0041, 0x00a2, \"LT\", \"External Folder Element File Location\" },\n    { 0x0041, 0x00a3, \"UL\", \"External Folder Element Length\" },\n    { 0x0041, 0x00b0, \"LT\", \"Internal Folder Element DSID\" },\n    { 0x0041, 0x00b1, \"US\", \"Internal Folder Element Data Set Type\" },\n    { 0x0041, 0x00b2, \"UL\", \"Internal Offset To Data Set\" },\n    { 0x0041, 0x00b3, \"UL\", \"Internal Offset To Image\" },\n    { 0x0043, 0x0001, \"SS\", \"Bitmap Of Prescan Options\" },\n    { 0x0043, 0x0002, \"SS\", \"Gradient Offset In X\" },\n    { 0x0043, 0x0003, \"SS\", \"Gradient Offset In Y\" },\n    { 0x0043, 0x0004, \"SS\", \"Gradient Offset In Z\" },\n    { 0x0043, 0x0005, \"SS\", \"Image Is Original Or Unoriginal\" },\n    { 0x0043, 0x0006, \"SS\", \"Number Of EPI Shots\" },\n    { 0x0043, 0x0007, \"SS\", \"Views Per Segment\" },\n    { 0x0043, 0x0008, \"SS\", \"Respiratory Rate In BPM\" },\n    { 0x0043, 0x0009, \"SS\", \"Respiratory Trigger Point\" },\n    { 0x0043, 0x000a, \"SS\", \"Type Of Receiver Used\" },\n    { 0x0043, 0x000b, \"DS\", \"Peak Rate Of Change Of Gradient Field\" },\n    { 0x0043, 0x000c, \"DS\", \"Limits In Units Of Percent\" },\n    { 0x0043, 0x000d, \"DS\", \"PSD Estimated Limit\" },\n    { 0x0043, 0x000e, \"DS\", \"PSD Estimated Limit In Tesla Per Second\" },\n    { 0x0043, 0x000f, \"DS\", \"SAR Avg Head\" },\n    { 0x0043, 0x0010, \"US\", \"Window Value\" },\n    { 0x0043, 0x0011, \"US\", \"Total Input Views\" },\n    { 0x0043, 0x0012, \"SS\", \"Xray Chain\" },\n    { 0x0043, 0x0013, \"SS\", \"Recon Kernel Parameters\" },\n    { 0x0043, 0x0014, \"SS\", \"Calibration Parameters\" },\n    { 0x0043, 0x0015, \"SS\", \"Total Output Views\" },\n    { 0x0043, 0x0016, \"SS\", \"Number Of Overranges\" },\n    { 0x0043, 0x0017, \"DS\", \"IBH Image Scale Factors\" },\n    { 0x0043, 0x0018, \"DS\", \"BBH Coefficients\" },\n    { 0x0043, 0x0019, \"SS\", \"Number Of BBH Chains To Blend\" },\n    { 0x0043, 0x001a, \"SL\", \"Starting Channel Number\" },\n    { 0x0043, 0x001b, \"SS\", \"PPScan Parameters\" },\n    { 0x0043, 0x001c, \"SS\", \"GE Image Integrity\" },\n    { 0x0043, 0x001d, \"SS\", \"Level Value\" },\n    { 0x0043, 0x001e, \"xs\", \"?\" },\n    { 0x0043, 0x001f, \"SL\", \"Max Overranges In A View\" },\n    { 0x0043, 0x0020, \"DS\", \"Avg Overranges All Views\" },\n    { 0x0043, 0x0021, \"SS\", \"Corrected Afterglow Terms\" },\n    { 0x0043, 0x0025, \"SS\", \"Reference Channels\" },\n    { 0x0043, 0x0026, \"US\", \"No Views Ref Channels Blocked\" },\n    { 0x0043, 0x0027, \"xs\", \"?\" },\n    { 0x0043, 0x0028, \"OB\", \"Unique Image Identifier\" },\n    { 0x0043, 0x0029, \"OB\", \"Histogram Tables\" },\n    { 0x0043, 0x002a, \"OB\", \"User Defined Data\" },\n    { 0x0043, 0x002b, \"SS\", \"Private Scan Options\" },\n    { 0x0043, 0x002c, \"SS\", \"Effective Echo Spacing\" },\n    { 0x0043, 0x002d, \"SH\", \"String Slop Field 1\" },\n    { 0x0043, 0x002e, \"SH\", \"String Slop Field 2\" },\n    { 0x0043, 0x002f, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0030, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0031, \"DS\", \"RA Coord Of Target Recon Centre\" },\n    { 0x0043, 0x0032, \"SS\", \"Raw Data Type\" },\n    { 0x0043, 0x0033, \"FL\", \"Neg Scan Spacing\" },\n    { 0x0043, 0x0034, \"IS\", \"Offset Frequency\" },\n    { 0x0043, 0x0035, \"UL\", \"User Usage Tag\" },\n    { 0x0043, 0x0036, \"UL\", \"User Fill Map MSW\" },\n    { 0x0043, 0x0037, \"UL\", \"User Fill Map LSW\" },\n    { 0x0043, 0x0038, \"FL\", \"User 25 To User 48\" },\n    { 0x0043, 0x0039, \"IS\", \"Slop Integer 6 To Slop Integer 9\" },\n    { 0x0043, 0x0040, \"FL\", \"Trigger On Position\" },\n    { 0x0043, 0x0041, \"FL\", \"Degree Of Rotation\" },\n    { 0x0043, 0x0042, \"SL\", \"DAS Trigger Source\" },\n    { 0x0043, 0x0043, \"SL\", \"DAS Fpa Gain\" },\n    { 0x0043, 0x0044, \"SL\", \"DAS Output Source\" },\n    { 0x0043, 0x0045, \"SL\", \"DAS Ad Input\" },\n    { 0x0043, 0x0046, \"SL\", \"DAS Cal Mode\" },\n    { 0x0043, 0x0047, \"SL\", \"DAS Cal Frequency\" },\n    { 0x0043, 0x0048, \"SL\", \"DAS Reg Xm\" },\n    { 0x0043, 0x0049, \"SL\", \"DAS Auto Zero\" },\n    { 0x0043, 0x004a, \"SS\", \"Starting Channel Of View\" },\n    { 0x0043, 0x004b, \"SL\", \"DAS Xm Pattern\" },\n    { 0x0043, 0x004c, \"SS\", \"TGGC Trigger Mode\" },\n    { 0x0043, 0x004d, \"FL\", \"Start Scan To Xray On Delay\" },\n    { 0x0043, 0x004e, \"FL\", \"Duration Of Xray On\" },\n    { 0x0044, 0x0000, \"UI\", \"?\" },\n    { 0x0045, 0x0004, \"CS\", \"AES\" },\n    { 0x0045, 0x0006, \"DS\", \"Angulation\" },\n    { 0x0045, 0x0009, \"DS\", \"Real Magnification Factor\" },\n    { 0x0045, 0x000b, \"CS\", \"Senograph Type\" },\n    { 0x0045, 0x000c, \"DS\", \"Integration Time\" },\n    { 0x0045, 0x000d, \"DS\", \"ROI Origin X and Y\" },\n    { 0x0045, 0x0011, \"DS\", \"Receptor Size cm X and Y\" },\n    { 0x0045, 0x0012, \"IS\", \"Receptor Size Pixels X and Y\" },\n    { 0x0045, 0x0013, \"ST\", \"Screen\" },\n    { 0x0045, 0x0014, \"DS\", \"Pixel Pitch Microns\" },\n    { 0x0045, 0x0015, \"IS\", \"Pixel Depth Bits\" },\n    { 0x0045, 0x0016, \"IS\", \"Binning Factor X and Y\" },\n    { 0x0045, 0x001b, \"CS\", \"Clinical View\" },\n    { 0x0045, 0x001d, \"DS\", \"Mean Of Raw Gray Levels\" },\n    { 0x0045, 0x001e, \"DS\", \"Mean Of Offset Gray Levels\" },\n    { 0x0045, 0x001f, \"DS\", \"Mean Of Corrected Gray Levels\" },\n    { 0x0045, 0x0020, \"DS\", \"Mean Of Region Gray Levels\" },\n    { 0x0045, 0x0021, \"DS\", \"Mean Of Log Region Gray Levels\" },\n    { 0x0045, 0x0022, \"DS\", \"Standard Deviation Of Raw Gray Levels\" },\n    { 0x0045, 0x0023, \"DS\", \"Standard Deviation Of Corrected Gray Levels\" },\n    { 0x0045, 0x0024, \"DS\", \"Standard Deviation Of Region Gray Levels\" },\n    { 0x0045, 0x0025, \"DS\", \"Standard Deviation Of Log Region Gray Levels\" },\n    { 0x0045, 0x0026, \"OB\", \"MAO Buffer\" },\n    { 0x0045, 0x0027, \"IS\", \"Set Number\" },\n    { 0x0045, 0x0028, \"CS\", \"WindowingType (LINEAR or GAMMA)\" },\n    { 0x0045, 0x0029, \"DS\", \"WindowingParameters\" },\n    { 0x0045, 0x002a, \"IS\", \"Crosshair Cursor X Coordinates\" },\n    { 0x0045, 0x002b, \"IS\", \"Crosshair Cursor Y Coordinates\" },\n    { 0x0045, 0x0039, \"US\", \"Vignette Rows\" },\n    { 0x0045, 0x003a, \"US\", \"Vignette Columns\" },\n    { 0x0045, 0x003b, \"US\", \"Vignette Bits Allocated\" },\n    { 0x0045, 0x003c, \"US\", \"Vignette Bits Stored\" },\n    { 0x0045, 0x003d, \"US\", \"Vignette High Bit\" },\n    { 0x0045, 0x003e, \"US\", \"Vignette Pixel Representation\" },\n    { 0x0045, 0x003f, \"OB\", \"Vignette Pixel Data\" },\n    { 0x0047, 0x0001, \"SQ\", \"Reconstruction Parameters Sequence\" },\n    { 0x0047, 0x0050, \"UL\", \"Volume Voxel Count\" },\n    { 0x0047, 0x0051, \"UL\", \"Volume Segment Count\" },\n    { 0x0047, 0x0053, \"US\", \"Volume Slice Size\" },\n    { 0x0047, 0x0054, \"US\", \"Volume Slice Count\" },\n    { 0x0047, 0x0055, \"SL\", \"Volume Threshold Value\" },\n    { 0x0047, 0x0057, \"DS\", \"Volume Voxel Ratio\" },\n    { 0x0047, 0x0058, \"DS\", \"Volume Voxel Size\" },\n    { 0x0047, 0x0059, \"US\", \"Volume Z Position Size\" },\n    { 0x0047, 0x0060, \"DS\", \"Volume Base Line\" },\n    { 0x0047, 0x0061, \"DS\", \"Volume Center Point\" },\n    { 0x0047, 0x0063, \"SL\", \"Volume Skew Base\" },\n    { 0x0047, 0x0064, \"DS\", \"Volume Registration Transform Rotation Matrix\" },\n    { 0x0047, 0x0065, \"DS\", \"Volume Registration Transform Translation Vector\" },\n    { 0x0047, 0x0070, \"DS\", \"KVP List\" },\n    { 0x0047, 0x0071, \"IS\", \"XRay Tube Current List\" },\n    { 0x0047, 0x0072, \"IS\", \"Exposure List\" },\n    { 0x0047, 0x0080, \"LO\", \"Acquisition DLX Identifier\" },\n    { 0x0047, 0x0085, \"SQ\", \"Acquisition DLX 2D Series Sequence\" },\n    { 0x0047, 0x0089, \"DS\", \"Contrast Agent Volume List\" },\n    { 0x0047, 0x008a, \"US\", \"Number Of Injections\" },\n    { 0x0047, 0x008b, \"US\", \"Frame Count\" },\n    { 0x0047, 0x0096, \"IS\", \"Used Frames\" },\n    { 0x0047, 0x0091, \"LO\", \"XA 3D Reconstruction Algorithm Name\" },\n    { 0x0047, 0x0092, \"CS\", \"XA 3D Reconstruction Algorithm Version\" },\n    { 0x0047, 0x0093, \"DA\", \"DLX Calibration Date\" },\n    { 0x0047, 0x0094, \"TM\", \"DLX Calibration Time\" },\n    { 0x0047, 0x0095, \"CS\", \"DLX Calibration Status\" },\n    { 0x0047, 0x0098, \"US\", \"Transform Count\" },\n    { 0x0047, 0x0099, \"SQ\", \"Transform Sequence\" },\n    { 0x0047, 0x009a, \"DS\", \"Transform Rotation Matrix\" },\n    { 0x0047, 0x009b, \"DS\", \"Transform Translation Vector\" },\n    { 0x0047, 0x009c, \"LO\", \"Transform Label\" },\n    { 0x0047, 0x00b1, \"US\", \"Wireframe Count\" },\n    { 0x0047, 0x00b2, \"US\", \"Location System\" },\n    { 0x0047, 0x00b0, \"SQ\", \"Wireframe List\" },\n    { 0x0047, 0x00b5, \"LO\", \"Wireframe Name\" },\n    { 0x0047, 0x00b6, \"LO\", \"Wireframe Group Name\" },\n    { 0x0047, 0x00b7, \"LO\", \"Wireframe Color\" },\n    { 0x0047, 0x00b8, \"SL\", \"Wireframe Attributes\" },\n    { 0x0047, 0x00b9, \"SL\", \"Wireframe Point Count\" },\n    { 0x0047, 0x00ba, \"SL\", \"Wireframe Timestamp\" },\n    { 0x0047, 0x00bb, \"SQ\", \"Wireframe Point List\" },\n    { 0x0047, 0x00bc, \"DS\", \"Wireframe Points Coordinates\" },\n    { 0x0047, 0x00c0, \"DS\", \"Volume Upper Left High Corner RAS\" },\n    { 0x0047, 0x00c1, \"DS\", \"Volume Slice To RAS Rotation Matrix\" },\n    { 0x0047, 0x00c2, \"DS\", \"Volume Upper Left High Corner TLOC\" },\n    { 0x0047, 0x00d1, \"OB\", \"Volume Segment List\" },\n    { 0x0047, 0x00d2, \"OB\", \"Volume Gradient List\" },\n    { 0x0047, 0x00d3, \"OB\", \"Volume Density List\" },\n    { 0x0047, 0x00d4, \"OB\", \"Volume Z Position List\" },\n    { 0x0047, 0x00d5, \"OB\", \"Volume Original Index List\" },\n    { 0x0050, 0x0000, \"UL\", \"Calibration Group Length\" },\n    { 0x0050, 0x0004, \"CS\", \"Calibration Object\" },\n    { 0x0050, 0x0010, \"SQ\", \"DeviceSequence\" },\n    { 0x0050, 0x0014, \"DS\", \"DeviceLength\" },\n    { 0x0050, 0x0016, \"DS\", \"DeviceDiameter\" },\n    { 0x0050, 0x0017, \"CS\", \"DeviceDiameterUnits\" },\n    { 0x0050, 0x0018, \"DS\", \"DeviceVolume\" },\n    { 0x0050, 0x0019, \"DS\", \"InterMarkerDistance\" },\n    { 0x0050, 0x0020, \"LO\", \"DeviceDescription\" },\n    { 0x0050, 0x0030, \"SQ\", \"CodedInterventionDeviceSequence\" },\n    { 0x0051, 0x0010, \"xs\", \"Image Text\" },\n    { 0x0054, 0x0000, \"UL\", \"Nuclear Acquisition Group Length\" },\n    { 0x0054, 0x0010, \"US\", \"Energy Window Vector\" },\n    { 0x0054, 0x0011, \"US\", \"Number of Energy Windows\" },\n    { 0x0054, 0x0012, \"SQ\", \"Energy Window Information Sequence\" },\n    { 0x0054, 0x0013, \"SQ\", \"Energy Window Range Sequence\" },\n    { 0x0054, 0x0014, \"DS\", \"Energy Window Lower Limit\" },\n    { 0x0054, 0x0015, \"DS\", \"Energy Window Upper Limit\" },\n    { 0x0054, 0x0016, \"SQ\", \"Radiopharmaceutical Information Sequence\" },\n    { 0x0054, 0x0017, \"IS\", \"Residual Syringe Counts\" },\n    { 0x0054, 0x0018, \"SH\", \"Energy Window Name\" },\n    { 0x0054, 0x0020, \"US\", \"Detector Vector\" },\n    { 0x0054, 0x0021, \"US\", \"Number of Detectors\" },\n    { 0x0054, 0x0022, \"SQ\", \"Detector Information Sequence\" },\n    { 0x0054, 0x0030, \"US\", \"Phase Vector\" },\n    { 0x0054, 0x0031, \"US\", \"Number of Phases\" },\n    { 0x0054, 0x0032, \"SQ\", \"Phase Information Sequence\" },\n    { 0x0054, 0x0033, \"US\", \"Number of Frames In Phase\" },\n    { 0x0054, 0x0036, \"IS\", \"Phase Delay\" },\n    { 0x0054, 0x0038, \"IS\", \"Pause Between Frames\" },\n    { 0x0054, 0x0050, \"US\", \"Rotation Vector\" },\n    { 0x0054, 0x0051, \"US\", \"Number of Rotations\" },\n    { 0x0054, 0x0052, \"SQ\", \"Rotation Information Sequence\" },\n    { 0x0054, 0x0053, \"US\", \"Number of Frames In Rotation\" },\n    { 0x0054, 0x0060, \"US\", \"R-R Interval Vector\" },\n    { 0x0054, 0x0061, \"US\", \"Number of R-R Intervals\" },\n    { 0x0054, 0x0062, \"SQ\", \"Gated Information Sequence\" },\n    { 0x0054, 0x0063, \"SQ\", \"Data Information Sequence\" },\n    { 0x0054, 0x0070, \"US\", \"Time Slot Vector\" },\n    { 0x0054, 0x0071, \"US\", \"Number of Time Slots\" },\n    { 0x0054, 0x0072, \"SQ\", \"Time Slot Information Sequence\" },\n    { 0x0054, 0x0073, \"DS\", \"Time Slot Time\" },\n    { 0x0054, 0x0080, \"US\", \"Slice Vector\" },\n    { 0x0054, 0x0081, \"US\", \"Number of Slices\" },\n    { 0x0054, 0x0090, \"US\", \"Angular View Vector\" },\n    { 0x0054, 0x0100, \"US\", \"Time Slice Vector\" },\n    { 0x0054, 0x0101, \"US\", \"Number Of Time Slices\" },\n    { 0x0054, 0x0200, \"DS\", \"Start Angle\" },\n    { 0x0054, 0x0202, \"CS\", \"Type of Detector Motion\" },\n    { 0x0054, 0x0210, \"IS\", \"Trigger Vector\" },\n    { 0x0054, 0x0211, \"US\", \"Number of Triggers in Phase\" },\n    { 0x0054, 0x0220, \"SQ\", \"View Code Sequence\" },\n    { 0x0054, 0x0222, \"SQ\", \"View Modifier Code Sequence\" },\n    { 0x0054, 0x0300, \"SQ\", \"Radionuclide Code Sequence\" },\n    { 0x0054, 0x0302, \"SQ\", \"Radiopharmaceutical Route Code Sequence\" },\n    { 0x0054, 0x0304, \"SQ\", \"Radiopharmaceutical Code Sequence\" },\n    { 0x0054, 0x0306, \"SQ\", \"Calibration Data Sequence\" },\n    { 0x0054, 0x0308, \"US\", \"Energy Window Number\" },\n    { 0x0054, 0x0400, \"SH\", \"Image ID\" },\n    { 0x0054, 0x0410, \"SQ\", \"Patient Orientation Code Sequence\" },\n    { 0x0054, 0x0412, \"SQ\", \"Patient Orientation Modifier Code Sequence\" },\n    { 0x0054, 0x0414, \"SQ\", \"Patient Gantry Relationship Code Sequence\" },\n    { 0x0054, 0x1000, \"CS\", \"Positron Emission Tomography Series Type\" },\n    { 0x0054, 0x1001, \"CS\", \"Positron Emission Tomography Units\" },\n    { 0x0054, 0x1002, \"CS\", \"Counts Source\" },\n    { 0x0054, 0x1004, \"CS\", \"Reprojection Method\" },\n    { 0x0054, 0x1100, \"CS\", \"Randoms Correction Method\" },\n    { 0x0054, 0x1101, \"LO\", \"Attenuation Correction Method\" },\n    { 0x0054, 0x1102, \"CS\", \"Decay Correction\" },\n    { 0x0054, 0x1103, \"LO\", \"Reconstruction Method\" },\n    { 0x0054, 0x1104, \"LO\", \"Detector Lines of Response Used\" },\n    { 0x0054, 0x1105, \"LO\", \"Scatter Correction Method\" },\n    { 0x0054, 0x1200, \"DS\", \"Axial Acceptance\" },\n    { 0x0054, 0x1201, \"IS\", \"Axial Mash\" },\n    { 0x0054, 0x1202, \"IS\", \"Transverse Mash\" },\n    { 0x0054, 0x1203, \"DS\", \"Detector Element Size\" },\n    { 0x0054, 0x1210, \"DS\", \"Coincidence Window Width\" },\n    { 0x0054, 0x1220, \"CS\", \"Secondary Counts Type\" },\n    { 0x0054, 0x1300, \"DS\", \"Frame Reference Time\" },\n    { 0x0054, 0x1310, \"IS\", \"Primary Prompts Counts Accumulated\" },\n    { 0x0054, 0x1311, \"IS\", \"Secondary Counts Accumulated\" },\n    { 0x0054, 0x1320, \"DS\", \"Slice Sensitivity Factor\" },\n    { 0x0054, 0x1321, \"DS\", \"Decay Factor\" },\n    { 0x0054, 0x1322, \"DS\", \"Dose Calibration Factor\" },\n    { 0x0054, 0x1323, \"DS\", \"Scatter Fraction Factor\" },\n    { 0x0054, 0x1324, \"DS\", \"Dead Time Factor\" },\n    { 0x0054, 0x1330, \"US\", \"Image Index\" },\n    { 0x0054, 0x1400, \"CS\", \"Counts Included\" },\n    { 0x0054, 0x1401, \"CS\", \"Dead Time Correction Flag\" },\n    { 0x0055, 0x0046, \"LT\", \"Current Ward\" },\n    { 0x0058, 0x0000, \"SQ\", \"?\" },\n    { 0x0060, 0x3000, \"SQ\", \"Histogram Sequence\" },\n    { 0x0060, 0x3002, \"US\", \"Histogram Number of Bins\" },\n    { 0x0060, 0x3004, \"xs\", \"Histogram First Bin Value\" },\n    { 0x0060, 0x3006, \"xs\", \"Histogram Last Bin Value\" },\n    { 0x0060, 0x3008, \"US\", \"Histogram Bin Width\" },\n    { 0x0060, 0x3010, \"LO\", \"Histogram Explanation\" },\n    { 0x0060, 0x3020, \"UL\", \"Histogram Data\" },\n    { 0x0070, 0x0001, \"SQ\", \"Graphic Annotation Sequence\" },\n    { 0x0070, 0x0002, \"CS\", \"Graphic Layer\" },\n    { 0x0070, 0x0003, \"CS\", \"Bounding Box Annotation Units\" },\n    { 0x0070, 0x0004, \"CS\", \"Anchor Point Annotation Units\" },\n    { 0x0070, 0x0005, \"CS\", \"Graphic Annotation Units\" },\n    { 0x0070, 0x0006, \"ST\", \"Unformatted Text Value\" },\n    { 0x0070, 0x0008, \"SQ\", \"Text Object Sequence\" },\n    { 0x0070, 0x0009, \"SQ\", \"Graphic Object Sequence\" },\n    { 0x0070, 0x0010, \"FL\", \"Bounding Box TLHC\" },\n    { 0x0070, 0x0011, \"FL\", \"Bounding Box BRHC\" },\n    { 0x0070, 0x0014, \"FL\", \"Anchor Point\" },\n    { 0x0070, 0x0015, \"CS\", \"Anchor Point Visibility\" },\n    { 0x0070, 0x0020, \"US\", \"Graphic Dimensions\" },\n    { 0x0070, 0x0021, \"US\", \"Number Of Graphic Points\" },\n    { 0x0070, 0x0022, \"FL\", \"Graphic Data\" },\n    { 0x0070, 0x0023, \"CS\", \"Graphic Type\" },\n    { 0x0070, 0x0024, \"CS\", \"Graphic Filled\" },\n    { 0x0070, 0x0040, \"IS\", \"Image Rotation\" },\n    { 0x0070, 0x0041, \"CS\", \"Image Horizontal Flip\" },\n    { 0x0070, 0x0050, \"US\", \"Displayed Area TLHC\" },\n    { 0x0070, 0x0051, \"US\", \"Displayed Area BRHC\" },\n    { 0x0070, 0x0060, \"SQ\", \"Graphic Layer Sequence\" },\n    { 0x0070, 0x0062, \"IS\", \"Graphic Layer Order\" },\n    { 0x0070, 0x0066, \"US\", \"Graphic Layer Recommended Display Value\" },\n    { 0x0070, 0x0068, \"LO\", \"Graphic Layer Description\" },\n    { 0x0070, 0x0080, \"CS\", \"Presentation Label\" },\n    { 0x0070, 0x0081, \"LO\", \"Presentation Description\" },\n    { 0x0070, 0x0082, \"DA\", \"Presentation Creation Date\" },\n    { 0x0070, 0x0083, \"TM\", \"Presentation Creation Time\" },\n    { 0x0070, 0x0084, \"PN\", \"Presentation Creator's Name\" },\n    { 0x0070, 0x031a, \"UI\", \"Fiducial UID\" },\n    { 0x0087, 0x0010, \"CS\", \"Media Type\" },\n    { 0x0087, 0x0020, \"CS\", \"Media Location\" },\n    { 0x0087, 0x0050, \"IS\", \"Estimated Retrieve Time\" },\n    { 0x0088, 0x0000, \"UL\", \"Storage Group Length\" },\n    { 0x0088, 0x0130, \"SH\", \"Storage Media FileSet ID\" },\n    { 0x0088, 0x0140, \"UI\", \"Storage Media FileSet UID\" },\n    { 0x0088, 0x0200, \"SQ\", \"Icon Image Sequence\" },\n    { 0x0088, 0x0904, \"LO\", \"Topic Title\" },\n    { 0x0088, 0x0906, \"ST\", \"Topic Subject\" },\n    { 0x0088, 0x0910, \"LO\", \"Topic Author\" },\n    { 0x0088, 0x0912, \"LO\", \"Topic Key Words\" },\n    { 0x0095, 0x0001, \"LT\", \"Examination Folder ID\" },\n    { 0x0095, 0x0004, \"UL\", \"Folder Reported Status\" },\n    { 0x0095, 0x0005, \"LT\", \"Folder Reporting Radiologist\" },\n    { 0x0095, 0x0007, \"LT\", \"SIENET ISA PLA\" },\n    { 0x0099, 0x0002, \"UL\", \"Data Object Attributes\" },\n    { 0x00e1, 0x0001, \"US\", \"Data Dictionary Version\" },\n    { 0x00e1, 0x0014, \"LT\", \"?\" },\n    { 0x00e1, 0x0022, \"DS\", \"?\" },\n    { 0x00e1, 0x0023, \"DS\", \"?\" },\n    { 0x00e1, 0x0024, \"LT\", \"?\" },\n    { 0x00e1, 0x0025, \"LT\", \"?\" },\n    { 0x00e1, 0x0040, \"SH\", \"Offset From CT MR Images\" },\n    { 0x0193, 0x0002, \"DS\", \"RIS Key\" },\n    { 0x0307, 0x0001, \"UN\", \"RIS Worklist IMGEF\" },\n    { 0x0309, 0x0001, \"UN\", \"RIS Report IMGEF\" },\n    { 0x0601, 0x0000, \"SH\", \"Implementation Version\" },\n    { 0x0601, 0x0020, \"DS\", \"Relative Table Position\" },\n    { 0x0601, 0x0021, \"DS\", \"Relative Table Height\" },\n    { 0x0601, 0x0030, \"SH\", \"Surview Direction\" },\n    { 0x0601, 0x0031, \"DS\", \"Surview Length\" },\n    { 0x0601, 0x0050, \"SH\", \"Image View Type\" },\n    { 0x0601, 0x0070, \"DS\", \"Batch Number\" },\n    { 0x0601, 0x0071, \"DS\", \"Batch Size\" },\n    { 0x0601, 0x0072, \"DS\", \"Batch Slice Number\" },\n    { 0x1000, 0x0000, \"xs\", \"?\" },\n    { 0x1000, 0x0001, \"US\", \"Run Length Triplet\" },\n    { 0x1000, 0x0002, \"US\", \"Huffman Table Size\" },\n    { 0x1000, 0x0003, \"US\", \"Huffman Table Triplet\" },\n    { 0x1000, 0x0004, \"US\", \"Shift Table Size\" },\n    { 0x1000, 0x0005, \"US\", \"Shift Table Triplet\" },\n    { 0x1010, 0x0000, \"xs\", \"?\" },\n    { 0x1369, 0x0000, \"US\", \"?\" },\n    { 0x2000, 0x0000, \"UL\", \"Film Session Group Length\" },\n    { 0x2000, 0x0010, \"IS\", \"Number of Copies\" },\n    { 0x2000, 0x0020, \"CS\", \"Print Priority\" },\n    { 0x2000, 0x0030, \"CS\", \"Medium Type\" },\n    { 0x2000, 0x0040, \"CS\", \"Film Destination\" },\n    { 0x2000, 0x0050, \"LO\", \"Film Session Label\" },\n    { 0x2000, 0x0060, \"IS\", \"Memory Allocation\" },\n    { 0x2000, 0x0500, \"SQ\", \"Referenced Film Box Sequence\" },\n    { 0x2010, 0x0000, \"UL\", \"Film Box Group Length\" },\n    { 0x2010, 0x0010, \"ST\", \"Image Display Format\" },\n    { 0x2010, 0x0030, \"CS\", \"Annotation Display Format ID\" },\n    { 0x2010, 0x0040, \"CS\", \"Film Orientation\" },\n    { 0x2010, 0x0050, \"CS\", \"Film Size ID\" },\n    { 0x2010, 0x0060, \"CS\", \"Magnification Type\" },\n    { 0x2010, 0x0080, \"CS\", \"Smoothing Type\" },\n    { 0x2010, 0x0100, \"CS\", \"Border Density\" },\n    { 0x2010, 0x0110, \"CS\", \"Empty Image Density\" },\n    { 0x2010, 0x0120, \"US\", \"Min Density\" },\n    { 0x2010, 0x0130, \"US\", \"Max Density\" },\n    { 0x2010, 0x0140, \"CS\", \"Trim\" },\n    { 0x2010, 0x0150, \"ST\", \"Configuration Information\" },\n    { 0x2010, 0x0500, \"SQ\", \"Referenced Film Session Sequence\" },\n    { 0x2010, 0x0510, \"SQ\", \"Referenced Image Box Sequence\" },\n    { 0x2010, 0x0520, \"SQ\", \"Referenced Basic Annotation Box Sequence\" },\n    { 0x2020, 0x0000, \"UL\", \"Image Box Group Length\" },\n    { 0x2020, 0x0010, \"US\", \"Image Box Position\" },\n    { 0x2020, 0x0020, \"CS\", \"Polarity\" },\n    { 0x2020, 0x0030, \"DS\", \"Requested Image Size\" },\n    { 0x2020, 0x0110, \"SQ\", \"Preformatted Grayscale Image Sequence\" },\n    { 0x2020, 0x0111, \"SQ\", \"Preformatted Color Image Sequence\" },\n    { 0x2020, 0x0130, \"SQ\", \"Referenced Image Overlay Box Sequence\" },\n    { 0x2020, 0x0140, \"SQ\", \"Referenced VOI LUT Box Sequence\" },\n    { 0x2030, 0x0000, \"UL\", \"Annotation Group Length\" },\n    { 0x2030, 0x0010, \"US\", \"Annotation Position\" },\n    { 0x2030, 0x0020, \"LO\", \"Text String\" },\n    { 0x2040, 0x0000, \"UL\", \"Overlay Box Group Length\" },\n    { 0x2040, 0x0010, \"SQ\", \"Referenced Overlay Plane Sequence\" },\n    { 0x2040, 0x0011, \"US\", \"Referenced Overlay Plane Groups\" },\n    { 0x2040, 0x0060, \"CS\", \"Overlay Magnification Type\" },\n    { 0x2040, 0x0070, \"CS\", \"Overlay Smoothing Type\" },\n    { 0x2040, 0x0080, \"CS\", \"Overlay Foreground Density\" },\n    { 0x2040, 0x0090, \"CS\", \"Overlay Mode\" },\n    { 0x2040, 0x0100, \"CS\", \"Threshold Density\" },\n    { 0x2040, 0x0500, \"SQ\", \"Referenced Overlay Image Box Sequence\" },\n    { 0x2050, 0x0010, \"SQ\", \"Presentation LUT Sequence\" },\n    { 0x2050, 0x0020, \"CS\", \"Presentation LUT Shape\" },\n    { 0x2100, 0x0000, \"UL\", \"Print Job Group Length\" },\n    { 0x2100, 0x0020, \"CS\", \"Execution Status\" },\n    { 0x2100, 0x0030, \"CS\", \"Execution Status Info\" },\n    { 0x2100, 0x0040, \"DA\", \"Creation Date\" },\n    { 0x2100, 0x0050, \"TM\", \"Creation Time\" },\n    { 0x2100, 0x0070, \"AE\", \"Originator\" },\n    { 0x2100, 0x0500, \"SQ\", \"Referenced Print Job Sequence\" },\n    { 0x2110, 0x0000, \"UL\", \"Printer Group Length\" },\n    { 0x2110, 0x0010, \"CS\", \"Printer Status\" },\n    { 0x2110, 0x0020, \"CS\", \"Printer Status Info\" },\n    { 0x2110, 0x0030, \"LO\", \"Printer Name\" },\n    { 0x2110, 0x0099, \"SH\", \"Print Queue ID\" },\n    { 0x3002, 0x0002, \"SH\", \"RT Image Label\" },\n    { 0x3002, 0x0003, \"LO\", \"RT Image Name\" },\n    { 0x3002, 0x0004, \"ST\", \"RT Image Description\" },\n    { 0x3002, 0x000a, \"CS\", \"Reported Values Origin\" },\n    { 0x3002, 0x000c, \"CS\", \"RT Image Plane\" },\n    { 0x3002, 0x000e, \"DS\", \"X-Ray Image Receptor Angle\" },\n    { 0x3002, 0x0010, \"DS\", \"RTImageOrientation\" },\n    { 0x3002, 0x0011, \"DS\", \"Image Plane Pixel Spacing\" },\n    { 0x3002, 0x0012, \"DS\", \"RT Image Position\" },\n    { 0x3002, 0x0020, \"SH\", \"Radiation Machine Name\" },\n    { 0x3002, 0x0022, \"DS\", \"Radiation Machine SAD\" },\n    { 0x3002, 0x0024, \"DS\", \"Radiation Machine SSD\" },\n    { 0x3002, 0x0026, \"DS\", \"RT Image SID\" },\n    { 0x3002, 0x0028, \"DS\", \"Source to Reference Object Distance\" },\n    { 0x3002, 0x0029, \"IS\", \"Fraction Number\" },\n    { 0x3002, 0x0030, \"SQ\", \"Exposure Sequence\" },\n    { 0x3002, 0x0032, \"DS\", \"Meterset Exposure\" },\n    { 0x3004, 0x0001, \"CS\", \"DVH Type\" },\n    { 0x3004, 0x0002, \"CS\", \"Dose Units\" },\n    { 0x3004, 0x0004, \"CS\", \"Dose Type\" },\n    { 0x3004, 0x0006, \"LO\", \"Dose Comment\" },\n    { 0x3004, 0x0008, \"DS\", \"Normalization Point\" },\n    { 0x3004, 0x000a, \"CS\", \"Dose Summation Type\" },\n    { 0x3004, 0x000c, \"DS\", \"GridFrame Offset Vector\" },\n    { 0x3004, 0x000e, \"DS\", \"Dose Grid Scaling\" },\n    { 0x3004, 0x0010, \"SQ\", \"RT Dose ROI Sequence\" },\n    { 0x3004, 0x0012, \"DS\", \"Dose Value\" },\n    { 0x3004, 0x0040, \"DS\", \"DVH Normalization Point\" },\n    { 0x3004, 0x0042, \"DS\", \"DVH Normalization Dose Value\" },\n    { 0x3004, 0x0050, \"SQ\", \"DVH Sequence\" },\n    { 0x3004, 0x0052, \"DS\", \"DVH Dose Scaling\" },\n    { 0x3004, 0x0054, \"CS\", \"DVH Volume Units\" },\n    { 0x3004, 0x0056, \"IS\", \"DVH Number of Bins\" },\n    { 0x3004, 0x0058, \"DS\", \"DVH Data\" },\n    { 0x3004, 0x0060, \"SQ\", \"DVH Referenced ROI Sequence\" },\n    { 0x3004, 0x0062, \"CS\", \"DVH ROI Contribution Type\" },\n    { 0x3004, 0x0070, \"DS\", \"DVH Minimum Dose\" },\n    { 0x3004, 0x0072, \"DS\", \"DVH Maximum Dose\" },\n    { 0x3004, 0x0074, \"DS\", \"DVH Mean Dose\" },\n    { 0x3006, 0x0002, \"SH\", \"Structure Set Label\" },\n    { 0x3006, 0x0004, \"LO\", \"Structure Set Name\" },\n    { 0x3006, 0x0006, \"ST\", \"Structure Set Description\" },\n    { 0x3006, 0x0008, \"DA\", \"Structure Set Date\" },\n    { 0x3006, 0x0009, \"TM\", \"Structure Set Time\" },\n    { 0x3006, 0x0010, \"SQ\", \"Referenced Frame of Reference Sequence\" },\n    { 0x3006, 0x0012, \"SQ\", \"RT Referenced Study Sequence\" },\n    { 0x3006, 0x0014, \"SQ\", \"RT Referenced Series Sequence\" },\n    { 0x3006, 0x0016, \"SQ\", \"Contour Image Sequence\" },\n    { 0x3006, 0x0020, \"SQ\", \"Structure Set ROI Sequence\" },\n    { 0x3006, 0x0022, \"IS\", \"ROI Number\" },\n    { 0x3006, 0x0024, \"UI\", \"Referenced Frame of Reference UID\" },\n    { 0x3006, 0x0026, \"LO\", \"ROI Name\" },\n    { 0x3006, 0x0028, \"ST\", \"ROI Description\" },\n    { 0x3006, 0x002a, \"IS\", \"ROI Display Color\" },\n    { 0x3006, 0x002c, \"DS\", \"ROI Volume\" },\n    { 0x3006, 0x0030, \"SQ\", \"RT Related ROI Sequence\" },\n    { 0x3006, 0x0033, \"CS\", \"RT ROI Relationship\" },\n    { 0x3006, 0x0036, \"CS\", \"ROI Generation Algorithm\" },\n    { 0x3006, 0x0038, \"LO\", \"ROI Generation Description\" },\n    { 0x3006, 0x0039, \"SQ\", \"ROI Contour Sequence\" },\n    { 0x3006, 0x0040, \"SQ\", \"Contour Sequence\" },\n    { 0x3006, 0x0042, \"CS\", \"Contour Geometric Type\" },\n    { 0x3006, 0x0044, \"DS\", \"Contour SlabT hickness\" },\n    { 0x3006, 0x0045, \"DS\", \"Contour Offset Vector\" },\n    { 0x3006, 0x0046, \"IS\", \"Number of Contour Points\" },\n    { 0x3006, 0x0050, \"DS\", \"Contour Data\" },\n    { 0x3006, 0x0080, \"SQ\", \"RT ROI Observations Sequence\" },\n    { 0x3006, 0x0082, \"IS\", \"Observation Number\" },\n    { 0x3006, 0x0084, \"IS\", \"Referenced ROI Number\" },\n    { 0x3006, 0x0085, \"SH\", \"ROI Observation Label\" },\n    { 0x3006, 0x0086, \"SQ\", \"RT ROI Identification Code Sequence\" },\n    { 0x3006, 0x0088, \"ST\", \"ROI Observation Description\" },\n    { 0x3006, 0x00a0, \"SQ\", \"Related RT ROI Observations Sequence\" },\n    { 0x3006, 0x00a4, \"CS\", \"RT ROI Interpreted Type\" },\n    { 0x3006, 0x00a6, \"PN\", \"ROI Interpreter\" },\n    { 0x3006, 0x00b0, \"SQ\", \"ROI Physical Properties Sequence\" },\n    { 0x3006, 0x00b2, \"CS\", \"ROI Physical Property\" },\n    { 0x3006, 0x00b4, \"DS\", \"ROI Physical Property Value\" },\n    { 0x3006, 0x00c0, \"SQ\", \"Frame of Reference Relationship Sequence\" },\n    { 0x3006, 0x00c2, \"UI\", \"Related Frame of Reference UID\" },\n    { 0x3006, 0x00c4, \"CS\", \"Frame of Reference Transformation Type\" },\n    { 0x3006, 0x00c6, \"DS\", \"Frame of Reference Transformation Matrix\" },\n    { 0x3006, 0x00c8, \"LO\", \"Frame of Reference Transformation Comment\" },\n    { 0x300a, 0x0002, \"SH\", \"RT Plan Label\" },\n    { 0x300a, 0x0003, \"LO\", \"RT Plan Name\" },\n    { 0x300a, 0x0004, \"ST\", \"RT Plan Description\" },\n    { 0x300a, 0x0006, \"DA\", \"RT Plan Date\" },\n    { 0x300a, 0x0007, \"TM\", \"RT Plan Time\" },\n    { 0x300a, 0x0009, \"LO\", \"Treatment Protocols\" },\n    { 0x300a, 0x000a, \"CS\", \"Treatment Intent\" },\n    { 0x300a, 0x000b, \"LO\", \"Treatment Sites\" },\n    { 0x300a, 0x000c, \"CS\", \"RT Plan Geometry\" },\n    { 0x300a, 0x000e, \"ST\", \"Prescription Description\" },\n    { 0x300a, 0x0010, \"SQ\", \"Dose ReferenceSequence\" },\n    { 0x300a, 0x0012, \"IS\", \"Dose ReferenceNumber\" },\n    { 0x300a, 0x0014, \"CS\", \"Dose Reference Structure Type\" },\n    { 0x300a, 0x0016, \"LO\", \"Dose ReferenceDescription\" },\n    { 0x300a, 0x0018, \"DS\", \"Dose Reference Point Coordinates\" },\n    { 0x300a, 0x001a, \"DS\", \"Nominal Prior Dose\" },\n    { 0x300a, 0x0020, \"CS\", \"Dose Reference Type\" },\n    { 0x300a, 0x0021, \"DS\", \"Constraint Weight\" },\n    { 0x300a, 0x0022, \"DS\", \"Delivery Warning Dose\" },\n    { 0x300a, 0x0023, \"DS\", \"Delivery Maximum Dose\" },\n    { 0x300a, 0x0025, \"DS\", \"Target Minimum Dose\" },\n    { 0x300a, 0x0026, \"DS\", \"Target Prescription Dose\" },\n    { 0x300a, 0x0027, \"DS\", \"Target Maximum Dose\" },\n    { 0x300a, 0x0028, \"DS\", \"Target Underdose Volume Fraction\" },\n    { 0x300a, 0x002a, \"DS\", \"Organ at Risk Full-volume Dose\" },\n    { 0x300a, 0x002b, \"DS\", \"Organ at Risk Limit Dose\" },\n    { 0x300a, 0x002c, \"DS\", \"Organ at Risk Maximum Dose\" },\n    { 0x300a, 0x002d, \"DS\", \"Organ at Risk Overdose Volume Fraction\" },\n    { 0x300a, 0x0040, \"SQ\", \"Tolerance Table Sequence\" },\n    { 0x300a, 0x0042, \"IS\", \"Tolerance Table Number\" },\n    { 0x300a, 0x0043, \"SH\", \"Tolerance Table Label\" },\n    { 0x300a, 0x0044, \"DS\", \"Gantry Angle Tolerance\" },\n    { 0x300a, 0x0046, \"DS\", \"Beam Limiting Device Angle Tolerance\" },\n    { 0x300a, 0x0048, \"SQ\", \"Beam Limiting Device Tolerance Sequence\" },\n    { 0x300a, 0x004a, \"DS\", \"Beam Limiting Device Position Tolerance\" },\n    { 0x300a, 0x004c, \"DS\", \"Patient Support Angle Tolerance\" },\n    { 0x300a, 0x004e, \"DS\", \"Table Top Eccentric Angle Tolerance\" },\n    { 0x300a, 0x0051, \"DS\", \"Table Top Vertical Position Tolerance\" },\n    { 0x300a, 0x0052, \"DS\", \"Table Top Longitudinal Position Tolerance\" },\n    { 0x300a, 0x0053, \"DS\", \"Table Top Lateral Position Tolerance\" },\n    { 0x300a, 0x0055, \"CS\", \"RT Plan Relationship\" },\n    { 0x300a, 0x0070, \"SQ\", \"Fraction Group Sequence\" },\n    { 0x300a, 0x0071, \"IS\", \"Fraction Group Number\" },\n    { 0x300a, 0x0078, \"IS\", \"Number of Fractions Planned\" },\n    { 0x300a, 0x0079, \"IS\", \"Number of Fractions Per Day\" },\n    { 0x300a, 0x007a, \"IS\", \"Repeat Fraction Cycle Length\" },\n    { 0x300a, 0x007b, \"LT\", \"Fraction Pattern\" },\n    { 0x300a, 0x0080, \"IS\", \"Number of Beams\" },\n    { 0x300a, 0x0082, \"DS\", \"Beam Dose Specification Point\" },\n    { 0x300a, 0x0084, \"DS\", \"Beam Dose\" },\n    { 0x300a, 0x0086, \"DS\", \"Beam Meterset\" },\n    { 0x300a, 0x00a0, \"IS\", \"Number of Brachy Application Setups\" },\n    { 0x300a, 0x00a2, \"DS\", \"Brachy Application Setup Dose Specification Point\" },\n    { 0x300a, 0x00a4, \"DS\", \"Brachy Application Setup Dose\" },\n    { 0x300a, 0x00b0, \"SQ\", \"Beam Sequence\" },\n    { 0x300a, 0x00b2, \"SH\", \"Treatment Machine Name \" },\n    { 0x300a, 0x00b3, \"CS\", \"Primary Dosimeter Unit\" },\n    { 0x300a, 0x00b4, \"DS\", \"Source-Axis Distance\" },\n    { 0x300a, 0x00b6, \"SQ\", \"Beam Limiting Device Sequence\" },\n    { 0x300a, 0x00b8, \"CS\", \"RT Beam Limiting Device Type\" },\n    { 0x300a, 0x00ba, \"DS\", \"Source to Beam Limiting Device Distance\" },\n    { 0x300a, 0x00bc, \"IS\", \"Number of Leaf/Jaw Pairs\" },\n    { 0x300a, 0x00be, \"DS\", \"Leaf Position Boundaries\" },\n    { 0x300a, 0x00c0, \"IS\", \"Beam Number\" },\n    { 0x300a, 0x00c2, \"LO\", \"Beam Name\" },\n    { 0x300a, 0x00c3, \"ST\", \"Beam Description\" },\n    { 0x300a, 0x00c4, \"CS\", \"Beam Type\" },\n    { 0x300a, 0x00c6, \"CS\", \"Radiation Type\" },\n    { 0x300a, 0x00c8, \"IS\", \"Reference Image Number\" },\n    { 0x300a, 0x00ca, \"SQ\", \"Planned Verification Image Sequence\" },\n    { 0x300a, 0x00cc, \"LO\", \"Imaging Device Specific Acquisition Parameters\" },\n    { 0x300a, 0x00ce, \"CS\", \"Treatment Delivery Type\" },\n    { 0x300a, 0x00d0, \"IS\", \"Number of Wedges\" },\n    { 0x300a, 0x00d1, \"SQ\", \"Wedge Sequence\" },\n    { 0x300a, 0x00d2, \"IS\", \"Wedge Number\" },\n    { 0x300a, 0x00d3, \"CS\", \"Wedge Type\" },\n    { 0x300a, 0x00d4, \"SH\", \"Wedge ID\" },\n    { 0x300a, 0x00d5, \"IS\", \"Wedge Angle\" },\n    { 0x300a, 0x00d6, \"DS\", \"Wedge Factor\" },\n    { 0x300a, 0x00d8, \"DS\", \"Wedge Orientation\" },\n    { 0x300a, 0x00da, \"DS\", \"Source to Wedge Tray Distance\" },\n    { 0x300a, 0x00e0, \"IS\", \"Number of Compensators\" },\n    { 0x300a, 0x00e1, \"SH\", \"Material ID\" },\n    { 0x300a, 0x00e2, \"DS\", \"Total Compensator Tray Factor\" },\n    { 0x300a, 0x00e3, \"SQ\", \"Compensator Sequence\" },\n    { 0x300a, 0x00e4, \"IS\", \"Compensator Number\" },\n    { 0x300a, 0x00e5, \"SH\", \"Compensator ID\" },\n    { 0x300a, 0x00e6, \"DS\", \"Source to Compensator Tray Distance\" },\n    { 0x300a, 0x00e7, \"IS\", \"Compensator Rows\" },\n    { 0x300a, 0x00e8, \"IS\", \"Compensator Columns\" },\n    { 0x300a, 0x00e9, \"DS\", \"Compensator Pixel Spacing\" },\n    { 0x300a, 0x00ea, \"DS\", \"Compensator Position\" },\n    { 0x300a, 0x00eb, \"DS\", \"Compensator Transmission Data\" },\n    { 0x300a, 0x00ec, \"DS\", \"Compensator Thickness Data\" },\n    { 0x300a, 0x00ed, \"IS\", \"Number of Boli\" },\n    { 0x300a, 0x00f0, \"IS\", \"Number of Blocks\" },\n    { 0x300a, 0x00f2, \"DS\", \"Total Block Tray Factor\" },\n    { 0x300a, 0x00f4, \"SQ\", \"Block Sequence\" },\n    { 0x300a, 0x00f5, \"SH\", \"Block Tray ID\" },\n    { 0x300a, 0x00f6, \"DS\", \"Source to Block Tray Distance\" },\n    { 0x300a, 0x00f8, \"CS\", \"Block Type\" },\n    { 0x300a, 0x00fa, \"CS\", \"Block Divergence\" },\n    { 0x300a, 0x00fc, \"IS\", \"Block Number\" },\n    { 0x300a, 0x00fe, \"LO\", \"Block Name\" },\n    { 0x300a, 0x0100, \"DS\", \"Block Thickness\" },\n    { 0x300a, 0x0102, \"DS\", \"Block Transmission\" },\n    { 0x300a, 0x0104, \"IS\", \"Block Number of Points\" },\n    { 0x300a, 0x0106, \"DS\", \"Block Data\" },\n    { 0x300a, 0x0107, \"SQ\", \"Applicator Sequence\" },\n    { 0x300a, 0x0108, \"SH\", \"Applicator ID\" },\n    { 0x300a, 0x0109, \"CS\", \"Applicator Type\" },\n    { 0x300a, 0x010a, \"LO\", \"Applicator Description\" },\n    { 0x300a, 0x010c, \"DS\", \"Cumulative Dose Reference Coefficient\" },\n    { 0x300a, 0x010e, \"DS\", \"Final Cumulative Meterset Weight\" },\n    { 0x300a, 0x0110, \"IS\", \"Number of Control Points\" },\n    { 0x300a, 0x0111, \"SQ\", \"Control Point Sequence\" },\n    { 0x300a, 0x0112, \"IS\", \"Control Point Index\" },\n    { 0x300a, 0x0114, \"DS\", \"Nominal Beam Energy\" },\n    { 0x300a, 0x0115, \"DS\", \"Dose Rate Set\" },\n    { 0x300a, 0x0116, \"SQ\", \"Wedge Position Sequence\" },\n    { 0x300a, 0x0118, \"CS\", \"Wedge Position\" },\n    { 0x300a, 0x011a, \"SQ\", \"Beam Limiting Device Position Sequence\" },\n    { 0x300a, 0x011c, \"DS\", \"Leaf Jaw Positions\" },\n    { 0x300a, 0x011e, \"DS\", \"Gantry Angle\" },\n    { 0x300a, 0x011f, \"CS\", \"Gantry Rotation Direction\" },\n    { 0x300a, 0x0120, \"DS\", \"Beam Limiting Device Angle\" },\n    { 0x300a, 0x0121, \"CS\", \"Beam Limiting Device Rotation Direction\" },\n    { 0x300a, 0x0122, \"DS\", \"Patient Support Angle\" },\n    { 0x300a, 0x0123, \"CS\", \"Patient Support Rotation Direction\" },\n    { 0x300a, 0x0124, \"DS\", \"Table Top Eccentric Axis Distance\" },\n    { 0x300a, 0x0125, \"DS\", \"Table Top Eccentric Angle\" },\n    { 0x300a, 0x0126, \"CS\", \"Table Top Eccentric Rotation Direction\" },\n    { 0x300a, 0x0128, \"DS\", \"Table Top Vertical Position\" },\n    { 0x300a, 0x0129, \"DS\", \"Table Top Longitudinal Position\" },\n    { 0x300a, 0x012a, \"DS\", \"Table Top Lateral Position\" },\n    { 0x300a, 0x012c, \"DS\", \"Isocenter Position\" },\n    { 0x300a, 0x012e, \"DS\", \"Surface Entry Point\" },\n    { 0x300a, 0x0130, \"DS\", \"Source to Surface Distance\" },\n    { 0x300a, 0x0134, \"DS\", \"Cumulative Meterset Weight\" },\n    { 0x300a, 0x0180, \"SQ\", \"Patient Setup Sequence\" },\n    { 0x300a, 0x0182, \"IS\", \"Patient Setup Number\" },\n    { 0x300a, 0x0184, \"LO\", \"Patient Additional Position\" },\n    { 0x300a, 0x0190, \"SQ\", \"Fixation Device Sequence\" },\n    { 0x300a, 0x0192, \"CS\", \"Fixation Device Type\" },\n    { 0x300a, 0x0194, \"SH\", \"Fixation Device Label\" },\n    { 0x300a, 0x0196, \"ST\", \"Fixation Device Description\" },\n    { 0x300a, 0x0198, \"SH\", \"Fixation Device Position\" },\n    { 0x300a, 0x01a0, \"SQ\", \"Shielding Device Sequence\" },\n    { 0x300a, 0x01a2, \"CS\", \"Shielding Device Type\" },\n    { 0x300a, 0x01a4, \"SH\", \"Shielding Device Label\" },\n    { 0x300a, 0x01a6, \"ST\", \"Shielding Device Description\" },\n    { 0x300a, 0x01a8, \"SH\", \"Shielding Device Position\" },\n    { 0x300a, 0x01b0, \"CS\", \"Setup Technique\" },\n    { 0x300a, 0x01b2, \"ST\", \"Setup TechniqueDescription\" },\n    { 0x300a, 0x01b4, \"SQ\", \"Setup Device Sequence\" },\n    { 0x300a, 0x01b6, \"CS\", \"Setup Device Type\" },\n    { 0x300a, 0x01b8, \"SH\", \"Setup Device Label\" },\n    { 0x300a, 0x01ba, \"ST\", \"Setup Device Description\" },\n    { 0x300a, 0x01bc, \"DS\", \"Setup Device Parameter\" },\n    { 0x300a, 0x01d0, \"ST\", \"Setup ReferenceDescription\" },\n    { 0x300a, 0x01d2, \"DS\", \"Table Top Vertical Setup Displacement\" },\n    { 0x300a, 0x01d4, \"DS\", \"Table Top Longitudinal Setup Displacement\" },\n    { 0x300a, 0x01d6, \"DS\", \"Table Top Lateral Setup Displacement\" },\n    { 0x300a, 0x0200, \"CS\", \"Brachy Treatment Technique\" },\n    { 0x300a, 0x0202, \"CS\", \"Brachy Treatment Type\" },\n    { 0x300a, 0x0206, \"SQ\", \"Treatment Machine Sequence\" },\n    { 0x300a, 0x0210, \"SQ\", \"Source Sequence\" },\n    { 0x300a, 0x0212, \"IS\", \"Source Number\" },\n    { 0x300a, 0x0214, \"CS\", \"Source Type\" },\n    { 0x300a, 0x0216, \"LO\", \"Source Manufacturer\" },\n    { 0x300a, 0x0218, \"DS\", \"Active Source Diameter\" },\n    { 0x300a, 0x021a, \"DS\", \"Active Source Length\" },\n    { 0x300a, 0x0222, \"DS\", \"Source Encapsulation Nominal Thickness\" },\n    { 0x300a, 0x0224, \"DS\", \"Source Encapsulation Nominal Transmission\" },\n    { 0x300a, 0x0226, \"LO\", \"Source IsotopeName\" },\n    { 0x300a, 0x0228, \"DS\", \"Source Isotope Half Life\" },\n    { 0x300a, 0x022a, \"DS\", \"Reference Air Kerma Rate\" },\n    { 0x300a, 0x022c, \"DA\", \"Air Kerma Rate Reference Date\" },\n    { 0x300a, 0x022e, \"TM\", \"Air Kerma Rate Reference Time\" },\n    { 0x300a, 0x0230, \"SQ\", \"Application Setup Sequence\" },\n    { 0x300a, 0x0232, \"CS\", \"Application Setup Type\" },\n    { 0x300a, 0x0234, \"IS\", \"Application Setup Number\" },\n    { 0x300a, 0x0236, \"LO\", \"Application Setup Name\" },\n    { 0x300a, 0x0238, \"LO\", \"Application Setup Manufacturer\" },\n    { 0x300a, 0x0240, \"IS\", \"Template Number\" },\n    { 0x300a, 0x0242, \"SH\", \"Template Type\" },\n    { 0x300a, 0x0244, \"LO\", \"Template Name\" },\n    { 0x300a, 0x0250, \"DS\", \"Total Reference Air Kerma\" },\n    { 0x300a, 0x0260, \"SQ\", \"Brachy Accessory Device Sequence\" },\n    { 0x300a, 0x0262, \"IS\", \"Brachy Accessory Device Number\" },\n    { 0x300a, 0x0263, \"SH\", \"Brachy Accessory Device ID\" },\n    { 0x300a, 0x0264, \"CS\", \"Brachy Accessory Device Type\" },\n    { 0x300a, 0x0266, \"LO\", \"Brachy Accessory Device Name\" },\n    { 0x300a, 0x026a, \"DS\", \"Brachy Accessory Device Nominal Thickness\" },\n    { 0x300a, 0x026c, \"DS\", \"Brachy Accessory Device Nominal Transmission\" },\n    { 0x300a, 0x0280, \"SQ\", \"Channel Sequence\" },\n    { 0x300a, 0x0282, \"IS\", \"Channel Number\" },\n    { 0x300a, 0x0284, \"DS\", \"Channel Length\" },\n    { 0x300a, 0x0286, \"DS\", \"Channel Total Time\" },\n    { 0x300a, 0x0288, \"CS\", \"Source Movement Type\" },\n    { 0x300a, 0x028a, \"IS\", \"Number of Pulses\" },\n    { 0x300a, 0x028c, \"DS\", \"Pulse Repetition Interval\" },\n    { 0x300a, 0x0290, \"IS\", \"Source Applicator Number\" },\n    { 0x300a, 0x0291, \"SH\", \"Source Applicator ID\" },\n    { 0x300a, 0x0292, \"CS\", \"Source Applicator Type\" },\n    { 0x300a, 0x0294, \"LO\", \"Source Applicator Name\" },\n    { 0x300a, 0x0296, \"DS\", \"Source Applicator Length\" },\n    { 0x300a, 0x0298, \"LO\", \"Source Applicator Manufacturer\" },\n    { 0x300a, 0x029c, \"DS\", \"Source Applicator Wall Nominal Thickness\" },\n    { 0x300a, 0x029e, \"DS\", \"Source Applicator Wall Nominal Transmission\" },\n    { 0x300a, 0x02a0, \"DS\", \"Source Applicator Step Size\" },\n    { 0x300a, 0x02a2, \"IS\", \"Transfer Tube Number\" },\n    { 0x300a, 0x02a4, \"DS\", \"Transfer Tube Length\" },\n    { 0x300a, 0x02b0, \"SQ\", \"Channel Shield Sequence\" },\n    { 0x300a, 0x02b2, \"IS\", \"Channel Shield Number\" },\n    { 0x300a, 0x02b3, \"SH\", \"Channel Shield ID\" },\n    { 0x300a, 0x02b4, \"LO\", \"Channel Shield Name\" },\n    { 0x300a, 0x02b8, \"DS\", \"Channel Shield Nominal Thickness\" },\n    { 0x300a, 0x02ba, \"DS\", \"Channel Shield Nominal Transmission\" },\n    { 0x300a, 0x02c8, \"DS\", \"Final Cumulative Time Weight\" },\n    { 0x300a, 0x02d0, \"SQ\", \"Brachy Control Point Sequence\" },\n    { 0x300a, 0x02d2, \"DS\", \"Control Point Relative Position\" },\n    { 0x300a, 0x02d4, \"DS\", \"Control Point 3D Position\" },\n    { 0x300a, 0x02d6, \"DS\", \"Cumulative Time Weight\" },\n    { 0x300c, 0x0002, \"SQ\", \"Referenced RT Plan Sequence\" },\n    { 0x300c, 0x0004, \"SQ\", \"Referenced Beam Sequence\" },\n    { 0x300c, 0x0006, \"IS\", \"Referenced Beam Number\" },\n    { 0x300c, 0x0007, \"IS\", \"Referenced Reference Image Number\" },\n    { 0x300c, 0x0008, \"DS\", \"Start Cumulative Meterset Weight\" },\n    { 0x300c, 0x0009, \"DS\", \"End Cumulative Meterset Weight\" },\n    { 0x300c, 0x000a, \"SQ\", \"Referenced Brachy Application Setup Sequence\" },\n    { 0x300c, 0x000c, \"IS\", \"Referenced Brachy Application Setup Number\" },\n    { 0x300c, 0x000e, \"IS\", \"Referenced Source Number\" },\n    { 0x300c, 0x0020, \"SQ\", \"Referenced Fraction Group Sequence\" },\n    { 0x300c, 0x0022, \"IS\", \"Referenced Fraction Group Number\" },\n    { 0x300c, 0x0040, \"SQ\", \"Referenced Verification Image Sequence\" },\n    { 0x300c, 0x0042, \"SQ\", \"Referenced Reference Image Sequence\" },\n    { 0x300c, 0x0050, \"SQ\", \"Referenced Dose Reference Sequence\" },\n    { 0x300c, 0x0051, \"IS\", \"Referenced Dose Reference Number\" },\n    { 0x300c, 0x0055, \"SQ\", \"Brachy Referenced Dose Reference Sequence\" },\n    { 0x300c, 0x0060, \"SQ\", \"Referenced Structure Set Sequence\" },\n    { 0x300c, 0x006a, \"IS\", \"Referenced Patient Setup Number\" },\n    { 0x300c, 0x0080, \"SQ\", \"Referenced Dose Sequence\" },\n    { 0x300c, 0x00a0, \"IS\", \"Referenced Tolerance Table Number\" },\n    { 0x300c, 0x00b0, \"SQ\", \"Referenced Bolus Sequence\" },\n    { 0x300c, 0x00c0, \"IS\", \"Referenced Wedge Number\" },\n    { 0x300c, 0x00d0, \"IS\", \"Referenced Compensato rNumber\" },\n    { 0x300c, 0x00e0, \"IS\", \"Referenced Block Number\" },\n    { 0x300c, 0x00f0, \"IS\", \"Referenced Control Point\" },\n    { 0x300e, 0x0002, \"CS\", \"Approval Status\" },\n    { 0x300e, 0x0004, \"DA\", \"Review Date\" },\n    { 0x300e, 0x0005, \"TM\", \"Review Time\" },\n    { 0x300e, 0x0008, \"PN\", \"Reviewer Name\" },\n    { 0x4000, 0x0000, \"UL\", \"Text Group Length\" },\n    { 0x4000, 0x0010, \"LT\", \"Text Arbitrary\" },\n    { 0x4000, 0x4000, \"LT\", \"Text Comments\" },\n    { 0x4008, 0x0000, \"UL\", \"Results Group Length\" },\n    { 0x4008, 0x0040, \"SH\", \"Results ID\" },\n    { 0x4008, 0x0042, \"LO\", \"Results ID Issuer\" },\n    { 0x4008, 0x0050, \"SQ\", \"Referenced Interpretation Sequence\" },\n    { 0x4008, 0x00ff, \"CS\", \"Report Production Status\" },\n    { 0x4008, 0x0100, \"DA\", \"Interpretation Recorded Date\" },\n    { 0x4008, 0x0101, \"TM\", \"Interpretation Recorded Time\" },\n    { 0x4008, 0x0102, \"PN\", \"Interpretation Recorder\" },\n    { 0x4008, 0x0103, \"LO\", \"Reference to Recorded Sound\" },\n    { 0x4008, 0x0108, \"DA\", \"Interpretation Transcription Date\" },\n    { 0x4008, 0x0109, \"TM\", \"Interpretation Transcription Time\" },\n    { 0x4008, 0x010a, \"PN\", \"Interpretation Transcriber\" },\n    { 0x4008, 0x010b, \"ST\", \"Interpretation Text\" },\n    { 0x4008, 0x010c, \"PN\", \"Interpretation Author\" },\n    { 0x4008, 0x0111, \"SQ\", \"Interpretation Approver Sequence\" },\n    { 0x4008, 0x0112, \"DA\", \"Interpretation Approval Date\" },\n    { 0x4008, 0x0113, \"TM\", \"Interpretation Approval Time\" },\n    { 0x4008, 0x0114, \"PN\", \"Physician Approving Interpretation\" },\n    { 0x4008, 0x0115, \"LT\", \"Interpretation Diagnosis Description\" },\n    { 0x4008, 0x0117, \"SQ\", \"InterpretationDiagnosis Code Sequence\" },\n    { 0x4008, 0x0118, \"SQ\", \"Results Distribution List Sequence\" },\n    { 0x4008, 0x0119, \"PN\", \"Distribution Name\" },\n    { 0x4008, 0x011a, \"LO\", \"Distribution Address\" },\n    { 0x4008, 0x0200, \"SH\", \"Interpretation ID\" },\n    { 0x4008, 0x0202, \"LO\", \"Interpretation ID Issuer\" },\n    { 0x4008, 0x0210, \"CS\", \"Interpretation Type ID\" },\n    { 0x4008, 0x0212, \"CS\", \"Interpretation Status ID\" },\n    { 0x4008, 0x0300, \"ST\", \"Impressions\" },\n    { 0x4008, 0x4000, \"ST\", \"Results Comments\" },\n    { 0x4009, 0x0001, \"LT\", \"Report ID\" },\n    { 0x4009, 0x0020, \"LT\", \"Report Status\" },\n    { 0x4009, 0x0030, \"DA\", \"Report Creation Date\" },\n    { 0x4009, 0x0070, \"LT\", \"Report Approving Physician\" },\n    { 0x4009, 0x00e0, \"LT\", \"Report Text\" },\n    { 0x4009, 0x00e1, \"LT\", \"Report Author\" },\n    { 0x4009, 0x00e3, \"LT\", \"Reporting Radiologist\" },\n    { 0x5000, 0x0000, \"UL\", \"Curve Group Length\" },\n    { 0x5000, 0x0005, \"US\", \"Curve Dimensions\" },\n    { 0x5000, 0x0010, \"US\", \"Number of Points\" },\n    { 0x5000, 0x0020, \"CS\", \"Type of Data\" },\n    { 0x5000, 0x0022, \"LO\", \"Curve Description\" },\n    { 0x5000, 0x0030, \"SH\", \"Axis Units\" },\n    { 0x5000, 0x0040, \"SH\", \"Axis Labels\" },\n    { 0x5000, 0x0103, \"US\", \"Data Value Representation\" },\n    { 0x5000, 0x0104, \"US\", \"Minimum Coordinate Value\" },\n    { 0x5000, 0x0105, \"US\", \"Maximum Coordinate Value\" },\n    { 0x5000, 0x0106, \"SH\", \"Curve Range\" },\n    { 0x5000, 0x0110, \"US\", \"Curve Data Descriptor\" },\n    { 0x5000, 0x0112, \"US\", \"Coordinate Start Value\" },\n    { 0x5000, 0x0114, \"US\", \"Coordinate Step Value\" },\n    { 0x5000, 0x1001, \"CS\", \"Curve Activation Layer\" },\n    { 0x5000, 0x2000, \"US\", \"Audio Type\" },\n    { 0x5000, 0x2002, \"US\", \"Audio Sample Format\" },\n    { 0x5000, 0x2004, \"US\", \"Number of Channels\" },\n    { 0x5000, 0x2006, \"UL\", \"Number of Samples\" },\n    { 0x5000, 0x2008, \"UL\", \"Sample Rate\" },\n    { 0x5000, 0x200a, \"UL\", \"Total Time\" },\n    { 0x5000, 0x200c, \"xs\", \"Audio Sample Data\" },\n    { 0x5000, 0x200e, \"LT\", \"Audio Comments\" },\n    { 0x5000, 0x2500, \"LO\", \"Curve Label\" },\n    { 0x5000, 0x2600, \"SQ\", \"CurveReferenced Overlay Sequence\" },\n    { 0x5000, 0x2610, \"US\", \"CurveReferenced Overlay Group\" },\n    { 0x5000, 0x3000, \"OW\", \"Curve Data\" },\n    { 0x6000, 0x0000, \"UL\", \"Overlay Group Length\" },\n    { 0x6000, 0x0001, \"US\", \"Gray Palette Color Lookup Table Descriptor\" },\n    { 0x6000, 0x0002, \"US\", \"Gray Palette Color Lookup Table Data\" },\n    { 0x6000, 0x0010, \"US\", \"Overlay Rows\" },\n    { 0x6000, 0x0011, \"US\", \"Overlay Columns\" },\n    { 0x6000, 0x0012, \"US\", \"Overlay Planes\" },\n    { 0x6000, 0x0015, \"IS\", \"Number of Frames in Overlay\" },\n    { 0x6000, 0x0022, \"LO\", \"Overlay Description\" },\n    { 0x6000, 0x0040, \"CS\", \"Overlay Type\" },\n    { 0x6000, 0x0045, \"CS\", \"Overlay Subtype\" },\n    { 0x6000, 0x0050, \"SS\", \"Overlay Origin\" },\n    { 0x6000, 0x0051, \"US\", \"Image Frame Origin\" },\n    { 0x6000, 0x0052, \"US\", \"Plane Origin\" },\n    { 0x6000, 0x0060, \"LO\", \"Overlay Compression Code\" },\n    { 0x6000, 0x0061, \"SH\", \"Overlay Compression Originator\" },\n    { 0x6000, 0x0062, \"SH\", \"Overlay Compression Label\" },\n    { 0x6000, 0x0063, \"SH\", \"Overlay Compression Description\" },\n    { 0x6000, 0x0066, \"AT\", \"Overlay Compression Step Pointers\" },\n    { 0x6000, 0x0068, \"US\", \"Overlay Repeat Interval\" },\n    { 0x6000, 0x0069, \"US\", \"Overlay Bits Grouped\" },\n    { 0x6000, 0x0100, \"US\", \"Overlay Bits Allocated\" },\n    { 0x6000, 0x0102, \"US\", \"Overlay Bit Position\" },\n    { 0x6000, 0x0110, \"LO\", \"Overlay Format\" },\n    { 0x6000, 0x0200, \"xs\", \"Overlay Location\" },\n    { 0x6000, 0x0800, \"LO\", \"Overlay Code Label\" },\n    { 0x6000, 0x0802, \"US\", \"Overlay Number of Tables\" },\n    { 0x6000, 0x0803, \"AT\", \"Overlay Code Table Location\" },\n    { 0x6000, 0x0804, \"US\", \"Overlay Bits For Code Word\" },\n    { 0x6000, 0x1001, \"CS\", \"Overlay Activation Layer\" },\n    { 0x6000, 0x1100, \"US\", \"Overlay Descriptor - Gray\" },\n    { 0x6000, 0x1101, \"US\", \"Overlay Descriptor - Red\" },\n    { 0x6000, 0x1102, \"US\", \"Overlay Descriptor - Green\" },\n    { 0x6000, 0x1103, \"US\", \"Overlay Descriptor - Blue\" },\n    { 0x6000, 0x1200, \"US\", \"Overlays - Gray\" },\n    { 0x6000, 0x1201, \"US\", \"Overlays - Red\" },\n    { 0x6000, 0x1202, \"US\", \"Overlays - Green\" },\n    { 0x6000, 0x1203, \"US\", \"Overlays - Blue\" },\n    { 0x6000, 0x1301, \"IS\", \"ROI Area\" },\n    { 0x6000, 0x1302, \"DS\", \"ROI Mean\" },\n    { 0x6000, 0x1303, \"DS\", \"ROI Standard Deviation\" },\n    { 0x6000, 0x1500, \"LO\", \"Overlay Label\" },\n    { 0x6000, 0x3000, \"OW\", \"Overlay Data\" },\n    { 0x6000, 0x4000, \"LT\", \"Overlay Comments\" },\n    { 0x6001, 0x0000, \"UN\", \"?\" },\n    { 0x6001, 0x0010, \"LO\", \"?\" },\n    { 0x6001, 0x1010, \"xs\", \"?\" },\n    { 0x6001, 0x1030, \"xs\", \"?\" },\n    { 0x6021, 0x0000, \"xs\", \"?\" },\n    { 0x6021, 0x0010, \"xs\", \"?\" },\n    { 0x7001, 0x0010, \"LT\", \"Dummy\" },\n    { 0x7003, 0x0010, \"LT\", \"Info\" },\n    { 0x7005, 0x0010, \"LT\", \"Dummy\" },\n    { 0x7000, 0x0004, \"ST\", \"TextAnnotation\" },\n    { 0x7000, 0x0005, \"IS\", \"Box\" },\n    { 0x7000, 0x0007, \"IS\", \"ArrowEnd\" },\n    { 0x7001, 0x0001, \"SL\", \"Private Group Length To End\" },\n    { 0x7001, 0x0002, \"OB\", \"Unknown\" },\n    { 0x7001, 0x0011, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0021, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0022, \"SQ\", \"Private Creator\" },\n    { 0x7001, 0x0041, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0042, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0051, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0052, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0075, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0076, \"SL\", \"Private Creator\" },\n    { 0x7001, 0x0077, \"OB\", \"Private Creator\" },\n    { 0x7001, 0x0101, \"SL\", \"Unknown\" },\n    { 0x7001, 0x0121, \"SL\", \"Unknown\" },\n    { 0x7001, 0x0122, \"SQ\", \"Unknown\" },\n    { 0x7fe0, 0x0000, \"UL\", \"Pixel Data Group Length\" },\n    { 0x7fe0, 0x0010, \"xs\", \"Pixel Data\" },\n    { 0x7fe0, 0x0020, \"OW\", \"Coefficients SDVN\" },\n    { 0x7fe0, 0x0030, \"OW\", \"Coefficients SDHN\" },\n    { 0x7fe0, 0x0040, \"OW\", \"Coefficients SDDN\" },\n    { 0x7fe1, 0x0010, \"xs\", \"Pixel Data\" },\n    { 0x7f00, 0x0000, \"UL\", \"Variable Pixel Data Group Length\" },\n    { 0x7f00, 0x0010, \"xs\", \"Variable Pixel Data\" },\n    { 0x7f00, 0x0011, \"US\", \"Variable Next Data Group\" },\n    { 0x7f00, 0x0020, \"OW\", \"Variable Coefficients SDVN\" },\n    { 0x7f00, 0x0030, \"OW\", \"Variable Coefficients SDHN\" },\n    { 0x7f00, 0x0040, \"OW\", \"Variable Coefficients SDDN\" },\n    { 0x7fe1, 0x0000, \"OB\", \"Binary Data\" },\n    { 0x7fe3, 0x0000, \"LT\", \"Image Graphics Format Code\" },\n    { 0x7fe3, 0x0010, \"OB\", \"Image Graphics\" },\n    { 0x7fe3, 0x0020, \"OB\", \"Image Graphics Dummy\" },\n    { 0x7ff1, 0x0001, \"US\", \"?\" },\n    { 0x7ff1, 0x0002, \"US\", \"?\" },\n    { 0x7ff1, 0x0003, \"xs\", \"?\" },\n    { 0x7ff1, 0x0004, \"IS\", \"?\" },\n    { 0x7ff1, 0x0005, \"US\", \"?\" },\n    { 0x7ff1, 0x0007, \"US\", \"?\" },\n    { 0x7ff1, 0x0008, \"US\", \"?\" },\n    { 0x7ff1, 0x0009, \"US\", \"?\" },\n    { 0x7ff1, 0x000a, \"LT\", \"?\" },\n    { 0x7ff1, 0x000b, \"US\", \"?\" },\n    { 0x7ff1, 0x000c, \"US\", \"?\" },\n    { 0x7ff1, 0x000d, \"US\", \"?\" },\n    { 0x7ff1, 0x0010, \"US\", \"?\" },\n    { 0xfffc, 0xfffc, \"OB\", \"Data Set Trailing Padding\" },\n    { 0xfffe, 0xe000, \"!!\", \"Item\" },\n    { 0xfffe, 0xe00d, \"!!\", \"Item Delimitation Item\" },\n    { 0xfffe, 0xe0dd, \"!!\", \"Sequence Delimitation Item\" },\n    { 0xffff, 0xffff, \"xs\", (char *) NULL }\n  };\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D C M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDCM() returns MagickTrue if the image format type, identified by the\n%  magick string, is DCM.\n%\n%  The format of the IsDCM method is:\n%\n%      MagickBooleanType IsDCM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDCM(const unsigned char *magick,const size_t length)\n{\n  if (length < 132)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) (magick+128),\"DICM\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d D C M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadDCMImage() reads a Digital Imaging and Communications in Medicine\n%  (DICOM) file and returns it.  It allocates the memory necessary for the\n%  new Image structure and returns a pointer to the new image.\n%\n%  The format of the ReadDCMImage method is:\n%\n%      Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\ntypedef struct _DCMInfo\n{\n  MagickBooleanType\n    polarity;\n\n  Quantum\n    *scale;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    depth,\n    mask,\n    max_value,\n    samples_per_pixel,\n    scale_size,\n    signed_data,\n    significant_bits,\n    width,\n    height;\n\n  MagickBooleanType\n    rescale;\n\n  double\n    rescale_intercept,\n    rescale_slope,\n    window_center,\n    window_width;\n} DCMInfo;\n\ntypedef struct _DCMStreamInfo\n{\n  size_t\n    remaining,\n    segment_count;\n\n  ssize_t\n    segments[15];\n\n  size_t\n    offset_count;\n\n  ssize_t\n    *offsets;\n\n  ssize_t\n    count;\n\n  int\n    byte;\n} DCMStreamInfo;\n\ntypedef struct _DCMMap\n{\n  int\n    *blue,\n    *green,\n    *gray,\n    *red;\n} DCMMap;\n\nstatic int ReadDCMByte(DCMStreamInfo *stream_info,Image *image)\n{\n  if (image->compression != RLECompression)\n    return(ReadBlobByte(image));\n  if (stream_info->count == 0)\n    {\n      int\n        byte;\n\n      ssize_t\n        count;\n\n      if (stream_info->remaining <= 2)\n        stream_info->remaining=0;\n      else\n        stream_info->remaining-=2;\n      count=(ssize_t) ReadBlobByte(image);\n      byte=ReadBlobByte(image);\n      if (count == 128)\n        return(0);\n      else\n        if (count < 128)\n          {\n            /*\n              Literal bytes.\n            */\n            stream_info->count=count;\n            stream_info->byte=(-1);\n            return(byte);\n          }\n        else\n          {\n            /*\n              Repeated bytes.\n            */\n            stream_info->count=256-count;\n            stream_info->byte=byte;\n            return(byte);\n          }\n    }\n  stream_info->count--;\n  if (stream_info->byte >= 0)\n    return(stream_info->byte);\n  if (stream_info->remaining > 0)\n    stream_info->remaining--;\n  return(ReadBlobByte(image));\n}\n\nstatic unsigned short ReadDCMShort(DCMStreamInfo *stream_info,Image *image)\n{\n  int\n    shift,\n    byte;\n\n  unsigned short\n    value;\n\n  if (image->compression != RLECompression)\n    return(ReadBlobLSBShort(image));\n  shift=image->depth < 16 ? 4 : 8;\n  value=(unsigned short) ReadDCMByte(stream_info,image);\n  byte=ReadDCMByte(stream_info,image);\n  if (byte < 0)\n    return(0);\n  value|=(unsigned short) (byte << shift);\n  return(value);\n}\n\nstatic signed short ReadDCMSignedShort(DCMStreamInfo *stream_info,Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadDCMShort(stream_info,image);\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,\n  DCMStreamInfo *stream_info,MagickBooleanType first_segment,\n  ExceptionInfo *exception)\n{\n  int\n    byte,\n    index;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    pixel;\n\n  ssize_t\n    i,\n    x;\n\n  Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Convert DCM Medical image to pixel packets.\n  */\n  byte=0;\n  i=0;\n  status=MagickTrue;\n  (void) memset(&pixel,0,sizeof(pixel));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (info->samples_per_pixel == 1)\n        {\n          int\n            pixel_value;\n\n          if (info->bytes_per_pixel == 1)\n            pixel_value=info->polarity != MagickFalse ?\n              ((int) info->max_value-ReadDCMByte(stream_info,image)) :\n              ReadDCMByte(stream_info,image);\n          else\n            if ((info->bits_allocated != 12) || (info->significant_bits != 12))\n              {\n                if (info->signed_data != 0)\n                  pixel_value=ReadDCMSignedShort(stream_info,image);\n                else\n                  pixel_value=(int) ReadDCMShort(stream_info,image);\n                if (info->polarity != MagickFalse)\n                  pixel_value=(int)info->max_value-pixel_value;\n              }\n            else\n              {\n                if ((i & 0x01) != 0)\n                  {\n                    pixel_value=byte;\n                    byte=ReadDCMByte(stream_info,image);\n                    if (byte >= 0)\n                      pixel_value|=(byte << 8);\n                  }\n                else\n                  {\n                    pixel_value=ReadDCMSignedShort(stream_info,image);\n                    byte=(int) (pixel_value & 0x0f);\n                    pixel_value>>=4;\n                  }\n                i++;\n              }\n          if (info->signed_data == 1)\n            pixel_value-=32767;\n          index=pixel_value;\n          if (info->rescale != MagickFalse)\n            {\n              double\n                scaled_value;\n\n              scaled_value=pixel_value*info->rescale_slope+\n                info->rescale_intercept;\n              index=(int) scaled_value;\n              if (info->window_width != 0)\n                {\n                  double\n                    window_max,\n                    window_min;\n\n                  window_min=ceil(info->window_center-\n                    (info->window_width-1.0)/2.0-0.5);\n                  window_max=floor(info->window_center+\n                    (info->window_width-1.0)/2.0+0.5);\n                  if (scaled_value <= window_min)\n                    index=0;\n                  else\n                    if (scaled_value > window_max)\n                      index=(int) info->max_value;\n                    else\n                      index=(int) (info->max_value*(((scaled_value-\n                        info->window_center-0.5)/(info->window_width-1))+0.5));\n                }\n            }\n          index&=info->mask;\n          index=(int) ConstrainColormapIndex(image,(ssize_t) index,exception);\n          if (first_segment != MagickFalse)\n            SetPixelIndex(image,(Quantum) index,q);\n          else\n            SetPixelIndex(image,(Quantum) (((size_t) index) |\n              (((size_t) GetPixelIndex(image,q)) << 8)),q);\n          pixel.red=(unsigned int) image->colormap[index].red;\n          pixel.green=(unsigned int) image->colormap[index].green;\n          pixel.blue=(unsigned int) image->colormap[index].blue;\n        }\n      else\n        {\n          if (info->bytes_per_pixel == 1)\n            {\n              pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n            }\n          else\n            {\n              pixel.red=ReadDCMShort(stream_info,image);\n              pixel.green=ReadDCMShort(stream_info,image);\n              pixel.blue=ReadDCMShort(stream_info,image);\n            }\n          pixel.red&=info->mask;\n          pixel.green&=info->mask;\n          pixel.blue&=info->mask;\n          if (info->scale != (Quantum *) NULL)\n            {\n              if ((MagickSizeType) pixel.red <= GetQuantumRange(info->depth))\n                pixel.red=(unsigned int) info->scale[pixel.red];\n              if ((MagickSizeType) pixel.green <= GetQuantumRange(info->depth))\n                pixel.green=(unsigned int) info->scale[pixel.green];\n              if ((MagickSizeType) pixel.blue <= GetQuantumRange(info->depth))\n                pixel.blue=(unsigned int) info->scale[pixel.blue];\n            }\n        }\n      if (first_segment != MagickFalse)\n        {\n          SetPixelRed(image,(Quantum) pixel.red,q);\n          SetPixelGreen(image,(Quantum) pixel.green,q);\n          SetPixelBlue(image,(Quantum) pixel.blue,q);\n        }\n      else\n        {\n          SetPixelRed(image,(Quantum) (((size_t) pixel.red) |\n            (((size_t) GetPixelRed(image,q)) << 8)),q);\n          SetPixelGreen(image,(Quantum) (((size_t) pixel.green) |\n            (((size_t) GetPixelGreen(image,q)) << 8)),q);\n          SetPixelBlue(image,(Quantum) (((size_t) pixel.blue) |\n            (((size_t) GetPixelBlue(image,q)) << 8)),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  return(status);\n}\n\nstatic void *RelinquishDCMInfo(void *memory)\n{\n  DCMInfo\n    *info;\n\n  info=(DCMInfo *) memory;\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  return(RelinquishMagickMemory(info));\n}\n\nstatic inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}\n\nstatic Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMInfo\n    info,\n    *info_copy;\n\n  DCMMap\n    map;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    datum;\n\n  LinkedListInfo\n    *stack;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    use_explicit;\n\n  MagickOffsetType\n    blob_size,\n    offset;\n\n  unsigned char\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    colors,\n    length,\n    number_scenes,\n    quantum,\n    status;\n\n  ssize_t\n    count,\n    scene,\n    sequence_depth;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  (void) memset(&info,0,sizeof(info));\n  (void) memset(&map,0,sizeof(map));\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  sequence_depth=0;\n  stack=NewLinkedList(256);\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n  (void) memset(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.rescale_slope=1.0;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  number_scenes=1;\n  use_explicit=MagickFalse;\n  explicit_retry=MagickFalse;\n  blob_size=(MagickOffsetType) GetBlobSize(image);\n  while (TellBlob(image) < blob_size)\n  {\n    for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )\n    {\n      /*\n        Read a group.\n      */\n      image->offset=(ssize_t) TellBlob(image);\n      group=ReadBlobLSBShort(image);\n      element=ReadBlobLSBShort(image);\n      if ((group == 0xfffc) && (element == 0xfffc))\n        break;\n      if ((group != 0x0002) && (image->endian == MSBEndian))\n        {\n          group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n          element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n        }\n      quantum=0;\n      /*\n        Find corresponding VR for this group and element.\n      */\n      for (i=0; dicom_info[i].group < 0xffff; i++)\n        if ((group == dicom_info[i].group) &&\n            (element == dicom_info[i].element))\n          break;\n      (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n      count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n      if (count != 2)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n      /*\n        Check for \"explicitness\", but meta-file headers always explicit.\n      */\n      if ((explicit_file == MagickFalse) && (group != 0x0002))\n        explicit_file=(isupper((int) ((unsigned char) *explicit_vr)) != 0) &&\n          (isupper((int) ((unsigned char) *(explicit_vr+1))) != 0) ?\n          MagickTrue : MagickFalse;\n      use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n        (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n      if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n        (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n      if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n        {\n          offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n          if (offset < 0)\n            ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n          quantum=4;\n        }\n      else\n        {\n          /*\n            Assume explicit type.\n          */\n          quantum=2;\n          if ((strcmp(explicit_vr,\"OB\") == 0) ||\n              (strcmp(explicit_vr,\"OW\") == 0) ||\n              (strcmp(explicit_vr,\"OF\") == 0) ||\n              (strcmp(explicit_vr,\"SQ\") == 0) ||\n              (strcmp(explicit_vr,\"UN\") == 0) ||\n              (strcmp(explicit_vr,\"UT\") == 0))\n            {\n              (void) ReadBlobLSBShort(image);\n              quantum=4;\n            }\n        }\n      if ((group == 0xFFFE) && (element == 0xE0DD))\n        {\n          /*\n            If we're exiting a sequence, restore the previous image parameters,\n            effectively undoing any parameter changes that happened inside the\n            sequence.\n          */\n          sequence_depth--;\n          info_copy=(DCMInfo *) RemoveLastElementFromLinkedList(stack);\n          if (info_copy == (DCMInfo *)NULL)\n            {\n              /*\n                The sequence's entry and exit points don't line up (tried to\n                exit one more sequence than we entered).\n              */\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          if (info.scale != (Quantum *) NULL)\n            info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n          (void) memcpy(&info,info_copy,sizeof(info));\n          info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n        }\n      if (strcmp(explicit_vr,\"SQ\") == 0)\n        {\n          /*\n            If we're entering a sequence, push the current image parameters\n            onto the stack, so we can restore them at the end of the sequence.\n          */\n          info_copy=(DCMInfo *) AcquireMagickMemory(sizeof(info));\n          if (info_copy == (DCMInfo *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          (void) memcpy(info_copy,&info,sizeof(info));\n          info_copy->scale=(Quantum *) AcquireQuantumMemory(\n            info_copy->scale_size,sizeof(*info_copy->scale));\n          if (info_copy->scale == (Quantum *) NULL)\n            {\n              info_copy=(DCMInfo *) RelinquishMagickMemory(info_copy);\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            }\n          (void) memcpy(info_copy->scale,info.scale,info_copy->scale_size*\n            sizeof(*info_copy->scale));\n          AppendValueToLinkedList(stack,info_copy);\n          sequence_depth++;\n        }\n      datum=0;\n      if (quantum == 4)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedLong(image);\n          else\n            datum=ReadBlobSignedLong(image);\n        }\n      else\n        if (quantum == 2)\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n      quantum=0;\n      length=1;\n      if (datum != 0)\n        {\n          if ((strncmp(implicit_vr,\"OW\",2) == 0) ||\n              (strncmp(implicit_vr,\"SS\",2) == 0) ||\n              (strncmp(implicit_vr,\"US\",2) == 0))\n            quantum=2;\n          else\n            if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                (strncmp(implicit_vr,\"UL\",2) == 0))\n              quantum=4;\n            else\n              if (strncmp(implicit_vr,\"FD\",2) == 0)\n                quantum=8;\n              else\n                quantum=1;\n          if (datum != ~0)\n            length=(size_t) datum/quantum;\n          else\n            {\n              /*\n                Sequence and item of undefined length.\n              */\n              quantum=0;\n              length=0;\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          /*\n            Display Dicom info.\n          */\n          if (use_explicit == MagickFalse)\n            explicit_vr[0]='\\0';\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          (void) FormatLocaleFile(stdout,\n            \"0x%04lX %4ld S%ld %s-%s (0x%04lx,0x%04lx)\",\n            (unsigned long) image->offset,(long) length,(long) sequence_depth,\n            implicit_vr,explicit_vr,(unsigned long) group,\n            (unsigned long) element);\n          if (dicom_info[i].description != (char *) NULL)\n            (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n          (void) FormatLocaleFile(stdout,\": \");\n        }\n      if ((group == 0x7FE0) && (element == 0x0010))\n        {\n          if (image_info->verbose != MagickFalse)\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          break;\n        }\n      /*\n        Allocate space and read an array.\n      */\n      data=(unsigned char *) NULL;\n      if ((length == 1) && (quantum == 1))\n        datum=ReadBlobByte(image);\n      else\n        if ((length == 1) && (quantum == 2))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedShort(image);\n            else\n              datum=ReadBlobSignedShort(image);\n          }\n        else\n          if ((length == 1) && (quantum == 4))\n            {\n              if (group == 0x0002)\n                datum=ReadBlobLSBSignedLong(image);\n              else\n                datum=ReadBlobSignedLong(image);\n            }\n          else\n            if ((quantum != 0) && (length != 0))\n              {\n                if (length > (size_t) GetBlobSize(image))\n                  ThrowDCMException(CorruptImageError,\n                    \"InsufficientImageDataInFile\")\n                if (~length >= 1)\n                  data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                    sizeof(*data));\n                if (data == (unsigned char *) NULL)\n                  ThrowDCMException(ResourceLimitError,\n                    \"MemoryAllocationFailed\")\n                count=ReadBlob(image,(size_t) quantum*length,data);\n                if (count != (ssize_t) (quantum*length))\n                  {\n                    if (image_info->verbose != MagickFalse)\n                      (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                        \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                        length,(int) group);\n                     ThrowDCMException(CorruptImageError,\n                       \"InsufficientImageDataInFile\")\n                  }\n                data[length*quantum]='\\0';\n              }\n      if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)\n        {\n          if (data != (unsigned char *) NULL)\n            data=(unsigned char *) RelinquishMagickMemory(data);\n          continue;\n        }\n      switch (group)\n      {\n        case 0x0002:\n        {\n          switch (element)\n          {\n            case 0x0010:\n            {\n              char\n                transfer_syntax[MagickPathExtent];\n\n              /*\n                Transfer Syntax.\n              */\n              if ((datum == 0) && (explicit_retry == MagickFalse))\n                {\n                  explicit_retry=MagickTrue;\n                  (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                  group=0;\n                  element=0;\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\n                      \"Corrupted image - trying explicit format\\n\");\n                  break;\n                }\n              *transfer_syntax='\\0';\n              if (data != (unsigned char *) NULL)\n                (void) CopyMagickString(transfer_syntax,(char *) data,\n                  MagickPathExtent);\n              if (image_info->verbose != MagickFalse)\n                (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                  (const char *) transfer_syntax);\n              if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n                {\n                  int\n                    subtype,\n                    type;\n\n                  type=1;\n                  subtype=0;\n                  if (strlen(transfer_syntax) > 17)\n                    {\n                      count=(ssize_t) sscanf(transfer_syntax+17,\".%d.%d\",&type,\n                        &subtype);\n                      if (count < 1)\n                        ThrowDCMException(CorruptImageError,\n                          \"ImproperImageHeader\")\n                    }\n                  switch (type)\n                  {\n                    case 1:\n                    {\n                      image->endian=LSBEndian;\n                      break;\n                    }\n                    case 2:\n                    {\n                      image->endian=MSBEndian;\n                      break;\n                    }\n                    case 4:\n                    {\n                      if ((subtype >= 80) && (subtype <= 81))\n                        image->compression=JPEGCompression;\n                      else\n                        if ((subtype >= 90) && (subtype <= 93))\n                          image->compression=JPEG2000Compression;\n                        else\n                          image->compression=JPEGCompression;\n                      break;\n                    }\n                    case 5:\n                    {\n                      image->compression=RLECompression;\n                      break;\n                    }\n                  }\n                }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x0028:\n        {\n          switch (element)\n          {\n            case 0x0002:\n            {\n              /*\n                Samples per pixel.\n              */\n              info.samples_per_pixel=(size_t) datum;\n              if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              break;\n            }\n            case 0x0004:\n            {\n              /*\n                Photometric interpretation.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n                photometric[i]=(char) data[i];\n              photometric[i]='\\0';\n              info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n                MagickTrue : MagickFalse;\n              break;\n            }\n            case 0x0006:\n            {\n              /*\n                Planar configuration.\n              */\n              if (datum == 1)\n                image->interlace=PlaneInterlace;\n              break;\n            }\n            case 0x0008:\n            {\n              /*\n                Number of frames.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              number_scenes=StringToUnsignedLong((char *) data);\n              break;\n            }\n            case 0x0010:\n            {\n              /*\n                Image rows.\n              */\n              info.height=(size_t) datum;\n              break;\n            }\n            case 0x0011:\n            {\n              /*\n                Image columns.\n              */\n              info.width=(size_t) datum;\n              break;\n            }\n            case 0x0100:\n            {\n              /*\n                Bits allocated.\n              */\n              info.bits_allocated=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (datum > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.bits_allocated;\n              if ((info.depth == 0) || (info.depth > 32))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.bits_allocated)-1;\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0101:\n            {\n              /*\n                Bits stored.\n              */\n              info.significant_bits=(size_t) datum;\n              info.bytes_per_pixel=1;\n              if (info.significant_bits > 8)\n                info.bytes_per_pixel=2;\n              info.depth=info.significant_bits;\n              if ((info.depth == 0) || (info.depth > 16))\n                ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n              info.max_value=(1UL << info.significant_bits)-1;\n              info.mask=(size_t) GetQuantumRange(info.significant_bits);\n              image->depth=info.depth;\n              break;\n            }\n            case 0x0102:\n            {\n              /*\n                High bit.\n              */\n              break;\n            }\n            case 0x0103:\n            {\n              /*\n                Pixel representation.\n              */\n              info.signed_data=(size_t) datum;\n              break;\n            }\n            case 0x1050:\n            {\n              /*\n                Visible pixel range: center.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_center=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1051:\n            {\n              /*\n                Visible pixel range: width.\n              */\n              if (data != (unsigned char *) NULL)\n                info.window_width=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1052:\n            {\n              /*\n                Rescale intercept\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_intercept=StringToDouble((char *) data,\n                  (char **) NULL);\n              break;\n            }\n            case 0x1053:\n            {\n              /*\n                Rescale slope\n              */\n              if (data != (unsigned char *) NULL)\n                info.rescale_slope=StringToDouble((char *) data,(char **) NULL);\n              break;\n            }\n            case 0x1200:\n            case 0x3006:\n            {\n              /*\n                Populate graymap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.gray != (int *) NULL)\n                map.gray=(int *) RelinquishMagickMemory(map.gray);\n              map.gray=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.gray));\n              if (map.gray == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.gray,0,MagickMax(colors,65536)*\n                sizeof(*map.gray));\n              for (i=0; i < (ssize_t) colors; i++)\n                if (info.bytes_per_pixel == 1)\n                  map.gray[i]=(int) data[i];\n                else\n                  map.gray[i]=(int) ((short *) data)[i];\n              break;\n            }\n            case 0x1201:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate redmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.red != (int *) NULL)\n                map.red=(int *) RelinquishMagickMemory(map.red);\n              map.red=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.red));\n              if (map.red == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.red,0,MagickMax(colors,65536)*\n                sizeof(*map.red));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.red[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1202:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate greenmap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.green != (int *) NULL)\n                map.green=(int *) RelinquishMagickMemory(map.green);\n              map.green=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.green));\n              if (map.green == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.green,0,MagickMax(colors,65536)*\n                sizeof(*map.green));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.green[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            case 0x1203:\n            {\n              unsigned short\n                index;\n\n              /*\n                Populate bluemap.\n              */\n              if (data == (unsigned char *) NULL)\n                break;\n              colors=(size_t) (length/info.bytes_per_pixel);\n              datum=(int) colors;\n              if (map.blue != (int *) NULL)\n                map.blue=(int *) RelinquishMagickMemory(map.blue);\n              map.blue=(int *) AcquireQuantumMemory(MagickMax(colors,65536),\n                sizeof(*map.blue));\n              if (map.blue == (int *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n              (void) memset(map.blue,0,MagickMax(colors,65536)*\n                sizeof(*map.blue));\n              p=data;\n              for (i=0; i < (ssize_t) colors; i++)\n              {\n                if (image->endian == MSBEndian)\n                  index=(unsigned short) ((*p << 8) | *(p+1));\n                else\n                  index=(unsigned short) (*p | (*(p+1) << 8));\n                map.blue[i]=(int) index;\n                p+=2;\n              }\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        case 0x2050:\n        {\n          switch (element)\n          {\n            case 0x0020:\n            {\n              if ((data != (unsigned char *) NULL) &&\n                  (strncmp((char *) data,\"INVERSE\",7) == 0))\n                info.polarity=MagickTrue;\n              break;\n            }\n            default:\n              break;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n      if (data != (unsigned char *) NULL)\n        {\n          char\n            *attribute;\n\n          for (i=0; dicom_info[i].description != (char *) NULL; i++)\n            if ((group == dicom_info[i].group) &&\n                (element == dicom_info[i].element))\n              break;\n          if (dicom_info[i].description != (char *) NULL)\n            {\n              attribute=AcquireString(\"dcm:\");\n              (void) ConcatenateString(&attribute,dicom_info[i].description);\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i == (ssize_t) length) || (length > 4))\n                {\n                  (void) SubstituteString(&attribute,\" \",\"\");\n                  (void) SetImageProperty(image,attribute,(char *) data,\n                    exception);\n                }\n              attribute=DestroyString(attribute);\n            }\n        }\n      if (image_info->verbose != MagickFalse)\n        {\n          if (data == (unsigned char *) NULL)\n            (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n          else\n            {\n              /*\n                Display group data.\n              */\n              for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n                if (isprint((int) data[i]) == 0)\n                  break;\n              if ((i != (ssize_t) length) && (length <= 4))\n                {\n                  ssize_t\n                    j;\n\n                  datum=0;\n                  for (j=(ssize_t) length-1; j >= 0; j--)\n                    datum=(256*datum+data[j]);\n                  (void) FormatLocaleFile(stdout,\"%d\",datum);\n                }\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                  if (isprint((int) data[i]) != 0)\n                    (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                  else\n                    (void) FormatLocaleFile(stdout,\"%c\",'.');\n              (void) FormatLocaleFile(stdout,\"\\n\");\n            }\n        }\n      if (data != (unsigned char *) NULL)\n        data=(unsigned char *) RelinquishMagickMemory(data);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          group=0xfffc;\n          break;\n        }\n    }\n    if ((group == 0xfffc) && (element == 0xfffc))\n      {\n        Image\n          *last;\n\n        last=RemoveLastImageFromList(&image);\n        if (last != (Image *) NULL)\n          last=DestroyImage(last);\n        break;\n      }\n    if ((info.width == 0) || (info.height == 0))\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n    image->columns=info.width;\n    image->rows=info.height;\n    if (info.signed_data == 0xffff)\n      info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n    if ((image->compression == JPEGCompression) ||\n        (image->compression == JPEG2000Compression))\n      {\n        Image\n          *images;\n\n        ImageInfo\n          *read_info;\n\n        int\n          c;\n\n        /*\n          Read offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image));\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n                stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n            offset=TellBlob(image);\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n        /*\n          Handle non-native image formats.\n        */\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        images=NewImageList();\n        for (scene=0; scene < (ssize_t) number_scenes; scene++)\n        {\n          char\n            filename[MagickPathExtent];\n\n          const char\n            *property;\n\n          FILE\n            *file;\n\n          Image\n            *jpeg_image;\n\n          int\n            unique_file;\n\n          unsigned int\n            tag;\n\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          length=(size_t) ReadBlobLSBLong(image);\n          if (length > (size_t) GetBlobSize(image))\n            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n          if (EOFBlob(image) != MagickFalse)\n            {\n              status=MagickFalse;\n              break;\n            }\n          if (tag == 0xFFFEE0DD)\n            break; /* sequence delimiter tag */\n          if (tag != 0xFFFEE000)\n            {\n              status=MagickFalse;\n              break;\n            }\n          file=(FILE *) NULL;\n          unique_file=AcquireUniqueFileResource(filename);\n          if (unique_file != -1)\n            file=fdopen(unique_file,\"wb\");\n          if (file == (FILE *) NULL)\n            {\n              (void) RelinquishUniqueFileResource(filename);\n              ThrowFileException(exception,FileOpenError,\n                \"UnableToCreateTemporaryFile\",filename);\n              break;\n            }\n          for (c=EOF; length != 0; length--)\n          {\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            if (fputc(c,file) != c)\n              break;\n          }\n          (void) fclose(file);\n          if (c == EOF)\n            break;\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"jpeg:%s\",filename);\n          if (image->compression == JPEG2000Compression)\n            (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n              \"j2k:%s\",filename);\n          jpeg_image=ReadImage(read_info,exception);\n          if (jpeg_image != (Image *) NULL)\n            {\n              ResetImagePropertyIterator(image);\n              property=GetNextImageProperty(image);\n              while (property != (const char *) NULL)\n              {\n                (void) SetImageProperty(jpeg_image,property,\n                  GetImageProperty(image,property,exception),exception);\n                property=GetNextImageProperty(image);\n              }\n              AppendImageToList(&images,jpeg_image);\n            }\n          (void) RelinquishUniqueFileResource(filename);\n        }\n        read_info=DestroyImageInfo(read_info);\n        image=DestroyImageList(image);\n        if ((status == MagickFalse) && (exception->severity < ErrorException))\n          ThrowDCMException(CorruptImageError,\"CorruptImageError\")\n        else\n          RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n        return(GetFirstImageInList(images));\n      }\n    if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n      {\n        QuantumAny\n          range;\n\n        /*\n          Compute pixel scaling table.\n        */\n        length=(size_t) (GetQuantumRange(info.depth)+1);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        if (info.scale != (Quantum *) NULL)\n          info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n        info.scale_size=MagickMax(length,MaxMap)+1;\n        info.scale=(Quantum *) AcquireQuantumMemory(info.scale_size,\n          sizeof(*info.scale));\n        if (info.scale == (Quantum *) NULL)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n        (void) memset(info.scale,0,(MagickMax(length,MaxMap)+1)*\n          sizeof(*info.scale));\n        range=GetQuantumRange(info.depth);\n        for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n          info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE offset table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n        }\n        tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n          ReadBlobLSBShort(image);\n        (void) tag;\n        length=(size_t) ReadBlobLSBLong(image);\n        if (length > (size_t) GetBlobSize(image))\n          ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\")\n        stream_info->offset_count=length >> 2;\n        if (stream_info->offset_count != 0)\n          {\n            if (stream_info->offsets != (ssize_t *) NULL)\n              stream_info->offsets=(ssize_t *)\n                RelinquishMagickMemory(stream_info->offsets);\n            stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n              stream_info->offset_count,sizeof(*stream_info->offsets));\n            if (stream_info->offsets == (ssize_t *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            {\n              offset=(MagickOffsetType) ReadBlobLSBSignedLong(image);\n              if (offset > (MagickOffsetType) GetBlobSize(image))\n                ThrowDCMException(CorruptImageError,\n                  \"InsufficientImageDataInFile\")\n              stream_info->offsets[i]=(ssize_t) offset;\n              if (EOFBlob(image) != MagickFalse)\n                break;\n            }\n            offset=TellBlob(image)+8;\n            for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n              stream_info->offsets[i]+=offset;\n          }\n      }\n    for (scene=0; scene < (ssize_t) number_scenes; scene++)\n    {\n      image->columns=info.width;\n      image->rows=info.height;\n      image->depth=info.depth;\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        break;\n      image->colorspace=RGBColorspace;\n      (void) SetImageBackgroundColor(image,exception);\n      if ((image->colormap == (PixelInfo *) NULL) &&\n          (info.samples_per_pixel == 1))\n        {\n          int\n            index;\n\n          size_t\n            one;\n\n          one=1;\n          if (colors == 0)\n            colors=one << info.depth;\n          if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\")\n          if (map.red != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.red[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n            }\n          if (map.green != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.green[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].green=(MagickRealType) index;\n            }\n          if (map.blue != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.blue[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n          if (map.gray != (int *) NULL)\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              index=map.gray[i];\n              if ((info.scale != (Quantum *) NULL) && (index >= 0) &&\n                  (index <= (int) info.max_value))\n                index=(int) info.scale[index];\n              image->colormap[i].red=(MagickRealType) index;\n              image->colormap[i].green=(MagickRealType) index;\n              image->colormap[i].blue=(MagickRealType) index;\n            }\n        }\n      if (image->compression == RLECompression)\n        {\n          unsigned int\n            tag;\n\n          /*\n            Read RLE segment table.\n          */\n          for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          {\n            int\n              c;\n\n            c=ReadBlobByte(image);\n            if (c == EOF)\n              break;\n          }\n          tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n            ReadBlobLSBShort(image);\n          stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n          if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n              (EOFBlob(image) != MagickFalse))\n            {\n              if (stream_info->offsets != (ssize_t *) NULL)\n                stream_info->offsets=(ssize_t *)\n                  RelinquishMagickMemory(stream_info->offsets);\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\")\n            }\n          stream_info->count=0;\n          stream_info->segment_count=ReadBlobLSBLong(image);\n          for (i=0; i < 15; i++)\n            stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          stream_info->remaining-=64;\n          if (stream_info->segment_count > 1)\n            {\n              info.bytes_per_pixel=1;\n              info.depth=8;\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);\n            }\n        }\n      if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n        {\n          Quantum\n            *q;\n\n          ssize_t\n            x,\n            y;\n\n          /*\n            Convert Planar RGB DCM Medical image to pixel packets.\n          */\n          for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                switch ((int) i)\n                {\n                  case 0:\n                  {\n                    SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 1:\n                  {\n                    SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 2:\n                  {\n                    SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  case 3:\n                  {\n                    SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                      ReadDCMByte(stream_info,image)),q);\n                    break;\n                  }\n                  default:\n                    break;\n                }\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        }\n      else\n        {\n          const char\n            *option;\n\n          /*\n            Convert DCM Medical image to pixel packets.\n          */\n          option=GetImageOption(image_info,\"dcm:display-range\");\n          if (option != (const char *) NULL)\n            {\n              if (LocaleCompare(option,\"reset\") == 0)\n                info.window_width=0;\n            }\n          option=GetImageOption(image_info,\"dcm:window\");\n          if (option != (char *) NULL)\n            {\n              GeometryInfo\n                geometry_info;\n\n              MagickStatusType\n                flags;\n\n              flags=ParseGeometry(option,&geometry_info);\n              if (flags & RhoValue)\n                info.window_center=geometry_info.rho;\n              if (flags & SigmaValue)\n                info.window_width=geometry_info.sigma;\n              info.rescale=MagickTrue;\n            }\n          option=GetImageOption(image_info,\"dcm:rescale\");\n          if (option != (char *) NULL)\n            info.rescale=IsStringTrue(option);\n          if ((info.window_center != 0) && (info.window_width == 0))\n            info.window_width=info.window_center;\n          status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n          if ((status != MagickFalse) && (stream_info->segment_count > 1))\n            {\n              if (stream_info->offset_count > 0)\n                (void) SeekBlob(image,(MagickOffsetType)\n                  stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);\n              (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,\n                exception);\n            }\n        }\n      if (IdentifyImageCoderGray(image,exception) != MagickFalse)\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n      /*\n        Proceed to next image.\n      */\n      if (image_info->number_scenes != 0)\n        if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n          break;\n      if (scene < (ssize_t) (number_scenes-1))\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              status=MagickFalse;\n              break;\n            }\n          image=SyncNextImageInList(image);\n          status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n            GetBlobSize(image));\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n     }\n  }\n  /*\n    Free resources.\n  */\n  RelinquishDCMMemory(&info,&map,stream_info,stack,data);\n  if (image == (Image *) NULL)\n    return(image);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r D C M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterDCMImage() adds attributes for the DCM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterDCMImage method is:\n%\n%      size_t RegisterDCMImage(void)\n%\n*/\nModuleExport size_t RegisterDCMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  static const char\n    *DCMNote=\n    {\n      \"DICOM is used by the medical community for images like X-rays.  The\\n\"\n      \"specification, \\\"Digital Imaging and Communications in Medicine\\n\"\n      \"(DICOM)\\\", is available at http://medical.nema.org/.  In particular,\\n\"\n      \"see part 5 which describes the image encoding (RLE, JPEG, JPEG-LS),\\n\"\n      \"and supplement 61 which adds JPEG-2000 encoding.\"\n    };\n\n  entry=AcquireMagickInfo(\"DCM\",\"DCM\",\n    \"Digital Imaging and Communications in Medicine image\");\n  entry->decoder=(DecodeImageHandler *) ReadDCMImage;\n  entry->magick=(IsImageFormatHandler *) IsDCM;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->note=ConstantString(DCMNote);\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r D C M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterDCMImage() removes format registrations made by the\n%  DCM module from the list of supported formats.\n%\n%  The format of the UnregisterDCMImage method is:\n%\n%      UnregisterDCMImage(void)\n%\n*/\nModuleExport void UnregisterDCMImage(void)\n{\n  (void) UnregisterMagickInfo(\"DCM\");\n}\n"], "filenames": ["coders/dcm.c"], "buggy_code_start_loc": [4003], "buggy_code_end_loc": [4006], "fixing_code_start_loc": [4002], "fixing_code_end_loc": [4008], "type": "CWE-416", "message": "A flaw was found in ImageMagick where it did not properly sanitize certain input before using it to invoke convert processes. This flaw allows an attacker to create a specially crafted image that leads to a use-after-free vulnerability when processed by ImageMagick. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.", "other": {"cve": {"id": "CVE-2021-3962", "sourceIdentifier": "secalert@redhat.com", "published": "2021-11-19T17:15:08.733", "lastModified": "2021-11-28T23:31:15.713", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in ImageMagick where it did not properly sanitize certain input before using it to invoke convert processes. This flaw allows an attacker to create a specially crafted image that leads to a use-after-free vulnerability when processed by ImageMagick. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en ImageMagick que no sanea correctamente ciertas entradas antes de utilizarlas para invocar procesos de conversi\u00f3n. Este defecto permite a un atacante crear una imagen especialmente dise\u00f1ada que conduce a una vulnerabilidad de uso despu\u00e9s de la liberaci\u00f3n cuando es procesada por ImageMagick. La mayor amenaza de esta vulnerabilidad es para la confidencialidad, la integridad, as\u00ed como la disponibilidad del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.1.0-14:*:*:*:*:*:*:*", "matchCriteriaId": "1F791E1D-6A0A-47F0-8219-51EE22C2F467"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2023196", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/82775af03bbb10a0a1d0e15c0156c75673b4525e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/4446", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/82775af03bbb10a0a1d0e15c0156c75673b4525e"}}