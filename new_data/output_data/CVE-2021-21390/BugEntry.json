{"buggy_code": ["/*\n * MinIO Cloud Storage, (C) 2016 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package cmd This file implements helper functions to validate Streaming AWS\n// Signature Version '4' authorization header.\npackage cmd\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"hash\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\thumanize \"github.com/dustin/go-humanize\"\n\txhttp \"github.com/minio/minio/cmd/http\"\n\t\"github.com/minio/minio/pkg/auth\"\n)\n\n// Streaming AWS Signature Version '4' constants.\nconst (\n\temptySHA256              = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\tstreamingContentSHA256   = \"STREAMING-AWS4-HMAC-SHA256-PAYLOAD\"\n\tsignV4ChunkedAlgorithm   = \"AWS4-HMAC-SHA256-PAYLOAD\"\n\tstreamingContentEncoding = \"aws-chunked\"\n)\n\n// getChunkSignature - get chunk signature.\nfunc getChunkSignature(cred auth.Credentials, seedSignature string, region string, date time.Time, hashedChunk string) string {\n\t// Calculate string to sign.\n\tstringToSign := signV4ChunkedAlgorithm + \"\\n\" +\n\t\tdate.Format(iso8601Format) + \"\\n\" +\n\t\tgetScope(date, region) + \"\\n\" +\n\t\tseedSignature + \"\\n\" +\n\t\temptySHA256 + \"\\n\" +\n\t\thashedChunk\n\n\t// Get hmac signing key.\n\tsigningKey := getSigningKey(cred.SecretKey, date, region, serviceS3)\n\n\t// Calculate signature.\n\tnewSignature := getSignature(signingKey, stringToSign)\n\n\treturn newSignature\n}\n\n// calculateSeedSignature - Calculate seed signature in accordance with\n//     - http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-streaming.html\n// returns signature, error otherwise if the signature mismatches or any other\n// error while parsing and validating.\nfunc calculateSeedSignature(r *http.Request) (cred auth.Credentials, signature string, region string, date time.Time, errCode APIErrorCode) {\n\t// Copy request.\n\treq := *r\n\n\t// Save authorization header.\n\tv4Auth := req.Header.Get(xhttp.Authorization)\n\n\t// Parse signature version '4' header.\n\tsignV4Values, errCode := parseSignV4(v4Auth, globalServerRegion, serviceS3)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\t// Payload streaming.\n\tpayload := streamingContentSHA256\n\n\t// Payload for STREAMING signature should be 'STREAMING-AWS4-HMAC-SHA256-PAYLOAD'\n\tif payload != req.Header.Get(xhttp.AmzContentSha256) {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrContentSHA256Mismatch\n\t}\n\n\t// Extract all the signed headers along with its values.\n\textractedSignedHeaders, errCode := extractSignedHeaders(signV4Values.SignedHeaders, r)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\tcred, _, errCode = checkKeyValid(signV4Values.Credential.accessKey)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\t// Verify if region is valid.\n\tregion = signV4Values.Credential.scope.region\n\n\t// Extract date, if not present throw error.\n\tvar dateStr string\n\tif dateStr = req.Header.Get(\"x-amz-date\"); dateStr == \"\" {\n\t\tif dateStr = r.Header.Get(\"Date\"); dateStr == \"\" {\n\t\t\treturn cred, \"\", \"\", time.Time{}, ErrMissingDateHeader\n\t\t}\n\t}\n\n\t// Parse date header.\n\tvar err error\n\tdate, err = time.Parse(iso8601Format, dateStr)\n\tif err != nil {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrMalformedDate\n\t}\n\n\t// Query string.\n\tqueryStr := req.URL.Query().Encode()\n\n\t// Get canonical request.\n\tcanonicalRequest := getCanonicalRequest(extractedSignedHeaders, payload, queryStr, req.URL.Path, req.Method)\n\n\t// Get string to sign from canonical request.\n\tstringToSign := getStringToSign(canonicalRequest, date, signV4Values.Credential.getScope())\n\n\t// Get hmac signing key.\n\tsigningKey := getSigningKey(cred.SecretKey, signV4Values.Credential.scope.date, region, serviceS3)\n\n\t// Calculate signature.\n\tnewSignature := getSignature(signingKey, stringToSign)\n\n\t// Verify if signature match.\n\tif !compareSignatureV4(newSignature, signV4Values.Signature) {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrSignatureDoesNotMatch\n\t}\n\n\t// Return caculated signature.\n\treturn cred, newSignature, region, date, ErrNone\n}\n\nconst maxLineLength = 4 * humanize.KiByte // assumed <= bufio.defaultBufSize 4KiB\n\n// lineTooLong is generated as chunk header is bigger than 4KiB.\nvar errLineTooLong = errors.New(\"header line too long\")\n\n// Malformed encoding is generated when chunk header is wrongly formed.\nvar errMalformedEncoding = errors.New(\"malformed chunked encoding\")\n\n// newSignV4ChunkedReader returns a new s3ChunkedReader that translates the data read from r\n// out of HTTP \"chunked\" format before returning it.\n// The s3ChunkedReader returns io.EOF when the final 0-length chunk is read.\n//\n// NewChunkedReader is not needed by normal applications. The http package\n// automatically decodes chunking when reading response bodies.\nfunc newSignV4ChunkedReader(req *http.Request) (io.ReadCloser, APIErrorCode) {\n\tcred, seedSignature, region, seedDate, errCode := calculateSeedSignature(req)\n\tif errCode != ErrNone {\n\t\treturn nil, errCode\n\t}\n\n\treturn &s3ChunkedReader{\n\t\treader:            bufio.NewReader(req.Body),\n\t\tcred:              cred,\n\t\tseedSignature:     seedSignature,\n\t\tseedDate:          seedDate,\n\t\tregion:            region,\n\t\tchunkSHA256Writer: sha256.New(),\n\t\tstate:             readChunkHeader,\n\t}, ErrNone\n}\n\n// Represents the overall state that is required for decoding a\n// AWS Signature V4 chunked reader.\ntype s3ChunkedReader struct {\n\treader            *bufio.Reader\n\tcred              auth.Credentials\n\tseedSignature     string\n\tseedDate          time.Time\n\tregion            string\n\tstate             chunkState\n\tlastChunk         bool\n\tchunkSignature    string\n\tchunkSHA256Writer hash.Hash // Calculates sha256 of chunk data.\n\tn                 uint64    // Unread bytes in chunk\n\terr               error\n}\n\n// Read chunk reads the chunk token signature portion.\nfunc (cr *s3ChunkedReader) readS3ChunkHeader() {\n\t// Read the first chunk line until CRLF.\n\tvar hexChunkSize, hexChunkSignature []byte\n\thexChunkSize, hexChunkSignature, cr.err = readChunkLine(cr.reader)\n\tif cr.err != nil {\n\t\treturn\n\t}\n\t// <hex>;token=value - converts the hex into its uint64 form.\n\tcr.n, cr.err = parseHexUint(hexChunkSize)\n\tif cr.err != nil {\n\t\treturn\n\t}\n\tif cr.n == 0 {\n\t\tcr.err = io.EOF\n\t}\n\t// Save the incoming chunk signature.\n\tcr.chunkSignature = string(hexChunkSignature)\n}\n\ntype chunkState int\n\nconst (\n\treadChunkHeader chunkState = iota\n\treadChunkTrailer\n\treadChunk\n\tverifyChunk\n\teofChunk\n)\n\nfunc (cs chunkState) String() string {\n\tstateString := \"\"\n\tswitch cs {\n\tcase readChunkHeader:\n\t\tstateString = \"readChunkHeader\"\n\tcase readChunkTrailer:\n\t\tstateString = \"readChunkTrailer\"\n\tcase readChunk:\n\t\tstateString = \"readChunk\"\n\tcase verifyChunk:\n\t\tstateString = \"verifyChunk\"\n\tcase eofChunk:\n\t\tstateString = \"eofChunk\"\n\n\t}\n\treturn stateString\n}\n\nfunc (cr *s3ChunkedReader) Close() (err error) {\n\treturn nil\n}\n\n// Read - implements `io.Reader`, which transparently decodes\n// the incoming AWS Signature V4 streaming signature.\nfunc (cr *s3ChunkedReader) Read(buf []byte) (n int, err error) {\n\tfor {\n\t\tswitch cr.state {\n\t\tcase readChunkHeader:\n\t\t\tcr.readS3ChunkHeader()\n\t\t\t// If we're at the end of a chunk.\n\t\t\tif cr.n == 0 && cr.err == io.EOF {\n\t\t\t\tcr.state = readChunkTrailer\n\t\t\t\tcr.lastChunk = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif cr.err != nil {\n\t\t\t\treturn 0, cr.err\n\t\t\t}\n\t\t\tcr.state = readChunk\n\t\tcase readChunkTrailer:\n\t\t\tcr.err = readCRLF(cr.reader)\n\t\t\tif cr.err != nil {\n\t\t\t\treturn 0, errMalformedEncoding\n\t\t\t}\n\t\t\tcr.state = verifyChunk\n\t\tcase readChunk:\n\t\t\t// There is no more space left in the request buffer.\n\t\t\tif len(buf) == 0 {\n\t\t\t\treturn n, nil\n\t\t\t}\n\t\t\trbuf := buf\n\t\t\t// The request buffer is larger than the current chunk size.\n\t\t\t// Read only the current chunk from the underlying reader.\n\t\t\tif uint64(len(rbuf)) > cr.n {\n\t\t\t\trbuf = rbuf[:cr.n]\n\t\t\t}\n\t\t\tvar n0 int\n\t\t\tn0, cr.err = cr.reader.Read(rbuf)\n\t\t\tif cr.err != nil {\n\t\t\t\t// We have lesser than chunk size advertised in chunkHeader, this is 'unexpected'.\n\t\t\t\tif cr.err == io.EOF {\n\t\t\t\t\tcr.err = io.ErrUnexpectedEOF\n\t\t\t\t}\n\t\t\t\treturn 0, cr.err\n\t\t\t}\n\n\t\t\t// Calculate sha256.\n\t\t\tcr.chunkSHA256Writer.Write(rbuf[:n0])\n\t\t\t// Update the bytes read into request buffer so far.\n\t\t\tn += n0\n\t\t\tbuf = buf[n0:]\n\t\t\t// Update bytes to be read of the current chunk before verifying chunk's signature.\n\t\t\tcr.n -= uint64(n0)\n\n\t\t\t// If we're at the end of a chunk.\n\t\t\tif cr.n == 0 {\n\t\t\t\tcr.state = readChunkTrailer\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase verifyChunk:\n\t\t\t// Calculate the hashed chunk.\n\t\t\thashedChunk := hex.EncodeToString(cr.chunkSHA256Writer.Sum(nil))\n\t\t\t// Calculate the chunk signature.\n\t\t\tnewSignature := getChunkSignature(cr.cred, cr.seedSignature, cr.region, cr.seedDate, hashedChunk)\n\t\t\tif !compareSignatureV4(cr.chunkSignature, newSignature) {\n\t\t\t\t// Chunk signature doesn't match we return signature does not match.\n\t\t\t\tcr.err = errSignatureMismatch\n\t\t\t\treturn 0, cr.err\n\t\t\t}\n\t\t\t// Newly calculated signature becomes the seed for the next chunk\n\t\t\t// this follows the chaining.\n\t\t\tcr.seedSignature = newSignature\n\t\t\tcr.chunkSHA256Writer.Reset()\n\t\t\tif cr.lastChunk {\n\t\t\t\tcr.state = eofChunk\n\t\t\t} else {\n\t\t\t\tcr.state = readChunkHeader\n\t\t\t}\n\t\tcase eofChunk:\n\t\t\treturn n, io.EOF\n\t\t}\n\t}\n}\n\n// readCRLF - check if reader only has '\\r\\n' CRLF character.\n// returns malformed encoding if it doesn't.\nfunc readCRLF(reader io.Reader) error {\n\tbuf := make([]byte, 2)\n\t_, err := io.ReadFull(reader, buf[:2])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif buf[0] != '\\r' || buf[1] != '\\n' {\n\t\treturn errMalformedEncoding\n\t}\n\treturn nil\n}\n\n// Read a line of bytes (up to \\n) from b.\n// Give up if the line exceeds maxLineLength.\n// The returned bytes are owned by the bufio.Reader\n// so they are only valid until the next bufio read.\nfunc readChunkLine(b *bufio.Reader) ([]byte, []byte, error) {\n\tbuf, err := b.ReadSlice('\\n')\n\tif err != nil {\n\t\t// We always know when EOF is coming.\n\t\t// If the caller asked for a line, there should be a line.\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t} else if err == bufio.ErrBufferFull {\n\t\t\terr = errLineTooLong\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif len(buf) >= maxLineLength {\n\t\treturn nil, nil, errLineTooLong\n\t}\n\t// Parse s3 specific chunk extension and fetch the values.\n\thexChunkSize, hexChunkSignature := parseS3ChunkExtension(buf)\n\treturn hexChunkSize, hexChunkSignature, nil\n}\n\n// trimTrailingWhitespace - trim trailing white space.\nfunc trimTrailingWhitespace(b []byte) []byte {\n\tfor len(b) > 0 && isASCIISpace(b[len(b)-1]) {\n\t\tb = b[:len(b)-1]\n\t}\n\treturn b\n}\n\n// isASCIISpace - is ascii space?\nfunc isASCIISpace(b byte) bool {\n\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n}\n\n// Constant s3 chunk encoding signature.\nconst s3ChunkSignatureStr = \";chunk-signature=\"\n\n// parses3ChunkExtension removes any s3 specific chunk-extension from buf.\n// For example,\n//     \"10000;chunk-signature=...\" => \"10000\", \"chunk-signature=...\"\nfunc parseS3ChunkExtension(buf []byte) ([]byte, []byte) {\n\tbuf = trimTrailingWhitespace(buf)\n\tsemi := bytes.Index(buf, []byte(s3ChunkSignatureStr))\n\t// Chunk signature not found, return the whole buffer.\n\tif semi == -1 {\n\t\treturn buf, nil\n\t}\n\treturn buf[:semi], parseChunkSignature(buf[semi:])\n}\n\n// parseChunkSignature - parse chunk signature.\nfunc parseChunkSignature(chunk []byte) []byte {\n\tchunkSplits := bytes.SplitN(chunk, []byte(s3ChunkSignatureStr), 2)\n\treturn chunkSplits[1]\n}\n\n// parse hex to uint64.\nfunc parseHexUint(v []byte) (n uint64, err error) {\n\tfor i, b := range v {\n\t\tswitch {\n\t\tcase '0' <= b && b <= '9':\n\t\t\tb = b - '0'\n\t\tcase 'a' <= b && b <= 'f':\n\t\t\tb = b - 'a' + 10\n\t\tcase 'A' <= b && b <= 'F':\n\t\t\tb = b - 'A' + 10\n\t\tdefault:\n\t\t\treturn 0, errors.New(\"invalid byte in chunk length\")\n\t\t}\n\t\tif i == 16 {\n\t\t\treturn 0, errors.New(\"http chunk length too large\")\n\t\t}\n\t\tn <<= 4\n\t\tn |= uint64(b)\n\t}\n\treturn\n}\n"], "fixing_code": ["/*\n * MinIO Cloud Storage, (C) 2016 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package cmd This file implements helper functions to validate Streaming AWS\n// Signature Version '4' authorization header.\npackage cmd\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"hash\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\thumanize \"github.com/dustin/go-humanize\"\n\txhttp \"github.com/minio/minio/cmd/http\"\n\t\"github.com/minio/minio/pkg/auth\"\n)\n\n// Streaming AWS Signature Version '4' constants.\nconst (\n\temptySHA256              = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\tstreamingContentSHA256   = \"STREAMING-AWS4-HMAC-SHA256-PAYLOAD\"\n\tsignV4ChunkedAlgorithm   = \"AWS4-HMAC-SHA256-PAYLOAD\"\n\tstreamingContentEncoding = \"aws-chunked\"\n)\n\n// getChunkSignature - get chunk signature.\nfunc getChunkSignature(cred auth.Credentials, seedSignature string, region string, date time.Time, hashedChunk string) string {\n\t// Calculate string to sign.\n\tstringToSign := signV4ChunkedAlgorithm + \"\\n\" +\n\t\tdate.Format(iso8601Format) + \"\\n\" +\n\t\tgetScope(date, region) + \"\\n\" +\n\t\tseedSignature + \"\\n\" +\n\t\temptySHA256 + \"\\n\" +\n\t\thashedChunk\n\n\t// Get hmac signing key.\n\tsigningKey := getSigningKey(cred.SecretKey, date, region, serviceS3)\n\n\t// Calculate signature.\n\tnewSignature := getSignature(signingKey, stringToSign)\n\n\treturn newSignature\n}\n\n// calculateSeedSignature - Calculate seed signature in accordance with\n//     - http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-streaming.html\n// returns signature, error otherwise if the signature mismatches or any other\n// error while parsing and validating.\nfunc calculateSeedSignature(r *http.Request) (cred auth.Credentials, signature string, region string, date time.Time, errCode APIErrorCode) {\n\t// Copy request.\n\treq := *r\n\n\t// Save authorization header.\n\tv4Auth := req.Header.Get(xhttp.Authorization)\n\n\t// Parse signature version '4' header.\n\tsignV4Values, errCode := parseSignV4(v4Auth, globalServerRegion, serviceS3)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\t// Payload streaming.\n\tpayload := streamingContentSHA256\n\n\t// Payload for STREAMING signature should be 'STREAMING-AWS4-HMAC-SHA256-PAYLOAD'\n\tif payload != req.Header.Get(xhttp.AmzContentSha256) {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrContentSHA256Mismatch\n\t}\n\n\t// Extract all the signed headers along with its values.\n\textractedSignedHeaders, errCode := extractSignedHeaders(signV4Values.SignedHeaders, r)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\tcred, _, errCode = checkKeyValid(signV4Values.Credential.accessKey)\n\tif errCode != ErrNone {\n\t\treturn cred, \"\", \"\", time.Time{}, errCode\n\t}\n\n\t// Verify if region is valid.\n\tregion = signV4Values.Credential.scope.region\n\n\t// Extract date, if not present throw error.\n\tvar dateStr string\n\tif dateStr = req.Header.Get(\"x-amz-date\"); dateStr == \"\" {\n\t\tif dateStr = r.Header.Get(\"Date\"); dateStr == \"\" {\n\t\t\treturn cred, \"\", \"\", time.Time{}, ErrMissingDateHeader\n\t\t}\n\t}\n\n\t// Parse date header.\n\tvar err error\n\tdate, err = time.Parse(iso8601Format, dateStr)\n\tif err != nil {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrMalformedDate\n\t}\n\n\t// Query string.\n\tqueryStr := req.URL.Query().Encode()\n\n\t// Get canonical request.\n\tcanonicalRequest := getCanonicalRequest(extractedSignedHeaders, payload, queryStr, req.URL.Path, req.Method)\n\n\t// Get string to sign from canonical request.\n\tstringToSign := getStringToSign(canonicalRequest, date, signV4Values.Credential.getScope())\n\n\t// Get hmac signing key.\n\tsigningKey := getSigningKey(cred.SecretKey, signV4Values.Credential.scope.date, region, serviceS3)\n\n\t// Calculate signature.\n\tnewSignature := getSignature(signingKey, stringToSign)\n\n\t// Verify if signature match.\n\tif !compareSignatureV4(newSignature, signV4Values.Signature) {\n\t\treturn cred, \"\", \"\", time.Time{}, ErrSignatureDoesNotMatch\n\t}\n\n\t// Return caculated signature.\n\treturn cred, newSignature, region, date, ErrNone\n}\n\nconst maxLineLength = 4 * humanize.KiByte // assumed <= bufio.defaultBufSize 4KiB\n\n// lineTooLong is generated as chunk header is bigger than 4KiB.\nvar errLineTooLong = errors.New(\"header line too long\")\n\n// Malformed encoding is generated when chunk header is wrongly formed.\nvar errMalformedEncoding = errors.New(\"malformed chunked encoding\")\n\n// newSignV4ChunkedReader returns a new s3ChunkedReader that translates the data read from r\n// out of HTTP \"chunked\" format before returning it.\n// The s3ChunkedReader returns io.EOF when the final 0-length chunk is read.\n//\n// NewChunkedReader is not needed by normal applications. The http package\n// automatically decodes chunking when reading response bodies.\nfunc newSignV4ChunkedReader(req *http.Request) (io.ReadCloser, APIErrorCode) {\n\tcred, seedSignature, region, seedDate, errCode := calculateSeedSignature(req)\n\tif errCode != ErrNone {\n\t\treturn nil, errCode\n\t}\n\n\treturn &s3ChunkedReader{\n\t\treader:            bufio.NewReader(req.Body),\n\t\tcred:              cred,\n\t\tseedSignature:     seedSignature,\n\t\tseedDate:          seedDate,\n\t\tregion:            region,\n\t\tchunkSHA256Writer: sha256.New(),\n\t\tbuffer:            make([]byte, 64*1024),\n\t}, ErrNone\n}\n\n// Represents the overall state that is required for decoding a\n// AWS Signature V4 chunked reader.\ntype s3ChunkedReader struct {\n\treader        *bufio.Reader\n\tcred          auth.Credentials\n\tseedSignature string\n\tseedDate      time.Time\n\tregion        string\n\n\tchunkSHA256Writer hash.Hash // Calculates sha256 of chunk data.\n\tbuffer            []byte\n\toffset            int\n\terr               error\n}\n\nfunc (cr *s3ChunkedReader) Close() (err error) {\n\treturn nil\n}\n\n// Read - implements `io.Reader`, which transparently decodes\n// the incoming AWS Signature V4 streaming signature.\nfunc (cr *s3ChunkedReader) Read(buf []byte) (n int, err error) {\n\t// First, if there is any unread data, copy it to the client\n\t// provided buffer.\n\tif cr.offset > 0 {\n\t\tn = copy(buf, cr.buffer[cr.offset:])\n\t\tif n == len(buf) {\n\t\t\tcr.offset += n\n\t\t\treturn n, nil\n\t\t}\n\t\tcr.offset = 0\n\t\tbuf = buf[n:]\n\t}\n\n\t// Now, we read one chunk from the underlying reader.\n\t// A chunk has the following format:\n\t//   <chunk-size-as-hex> + \";chunk-signature=\" + <signature-as-hex> + \"\\r\\n\" + <payload> + \"\\r\\n\"\n\t//\n\t// Frist, we read the chunk size but fail if it is larger\n\t// than 1 MB. We must not accept arbitrary large chunks.\n\t// One 1 MB is a reasonable max limit.\n\t//\n\t// Then we read the signature and payload data. We compute the SHA256 checksum\n\t// of the payload and verify that it matches the expected signature value.\n\t//\n\t// The last chunk is *always* 0-sized. So, we must only return io.EOF if we have encountered\n\t// a chunk with a chunk size = 0. However, this chunk still has a signature and we must\n\t// verify it.\n\tconst MaxSize = 1 << 20 // 1 MB\n\tvar size int\n\tfor {\n\t\tb, err := cr.reader.ReadByte()\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t\tif err != nil {\n\t\t\tcr.err = err\n\t\t\treturn n, cr.err\n\t\t}\n\t\tif b == ';' { // separating character\n\t\t\tbreak\n\t\t}\n\n\t\t// Manually deserialize the size since AWS specified\n\t\t// the chunk size to be of variable width. In particular,\n\t\t// a size of 16 is encoded as `10` while a size of 64 KB\n\t\t// is `10000`.\n\t\tswitch {\n\t\tcase b >= '0' && b <= '9':\n\t\t\tsize = size<<4 | int(b-'0')\n\t\tcase b >= 'a' && b <= 'f':\n\t\t\tsize = size<<4 | int(b-('a'-10))\n\t\tcase b >= 'A' && b <= 'F':\n\t\t\tsize = size<<4 | int(b-('A'-10))\n\t\tdefault:\n\t\t\tcr.err = errMalformedEncoding\n\t\t\treturn n, cr.err\n\t\t}\n\t\tif size > MaxSize {\n\t\t\tcr.err = errMalformedEncoding\n\t\t\treturn n, cr.err\n\t\t}\n\t}\n\n\t// Now, we read the signature of the following payload and expect:\n\t//   chunk-signature=\" + <signature-as-hex> + \"\\r\\n\"\n\t//\n\t// The signature is 64 bytes long (hex-encoded SHA256 hash) and\n\t// starts with a 16 byte header: len(\"chunk-signature=\") + 64 == 80.\n\tvar signature [80]byte\n\t_, err = io.ReadFull(cr.reader, signature[:])\n\tif err == io.EOF {\n\t\terr = io.ErrUnexpectedEOF\n\t}\n\tif err != nil {\n\t\tcr.err = err\n\t\treturn n, cr.err\n\t}\n\tif !bytes.HasPrefix(signature[:], []byte(\"chunk-signature=\")) {\n\t\tcr.err = errMalformedEncoding\n\t\treturn n, cr.err\n\t}\n\tb, err := cr.reader.ReadByte()\n\tif err == io.EOF {\n\t\terr = io.ErrUnexpectedEOF\n\t}\n\tif err != nil {\n\t\tcr.err = err\n\t\treturn n, cr.err\n\t}\n\tif b != '\\r' {\n\t\tcr.err = errMalformedEncoding\n\t\treturn n, cr.err\n\t}\n\tb, err = cr.reader.ReadByte()\n\tif err == io.EOF {\n\t\terr = io.ErrUnexpectedEOF\n\t}\n\tif err != nil {\n\t\tcr.err = err\n\t\treturn n, cr.err\n\t}\n\tif b != '\\n' {\n\t\tcr.err = errMalformedEncoding\n\t\treturn n, cr.err\n\t}\n\n\tif cap(cr.buffer) < size {\n\t\tcr.buffer = make([]byte, size)\n\t} else {\n\t\tcr.buffer = cr.buffer[:size]\n\t}\n\n\t// Now, we read the payload and compute its SHA-256 hash.\n\t_, err = io.ReadFull(cr.reader, cr.buffer)\n\tif err == io.EOF && size != 0 {\n\t\terr = io.ErrUnexpectedEOF\n\t}\n\tif err != nil && err != io.EOF {\n\t\tcr.err = err\n\t\treturn n, cr.err\n\t}\n\tb, err = cr.reader.ReadByte()\n\tif b != '\\r' {\n\t\tcr.err = errMalformedEncoding\n\t\treturn n, cr.err\n\t}\n\tb, err = cr.reader.ReadByte()\n\tif err == io.EOF {\n\t\terr = io.ErrUnexpectedEOF\n\t}\n\tif err != nil {\n\t\tcr.err = err\n\t\treturn n, cr.err\n\t}\n\tif b != '\\n' {\n\t\tcr.err = errMalformedEncoding\n\t\treturn n, cr.err\n\t}\n\n\t// Once we have read the entire chunk successfully, we verify\n\t// that the received signature matches our computed signature.\n\tcr.chunkSHA256Writer.Write(cr.buffer)\n\tnewSignature := getChunkSignature(cr.cred, cr.seedSignature, cr.region, cr.seedDate, hex.EncodeToString(cr.chunkSHA256Writer.Sum(nil)))\n\tif !compareSignatureV4(string(signature[16:]), newSignature) {\n\t\tcr.err = errSignatureMismatch\n\t\treturn n, cr.err\n\t}\n\tcr.seedSignature = newSignature\n\tcr.chunkSHA256Writer.Reset()\n\n\t// If the chunk size is zero we return io.EOF. As specified by AWS,\n\t// only the last chunk is zero-sized.\n\tif size == 0 {\n\t\tcr.err = io.EOF\n\t\treturn n, cr.err\n\t}\n\n\tcr.offset = copy(buf, cr.buffer)\n\tn += cr.offset\n\treturn n, err\n}\n\n// readCRLF - check if reader only has '\\r\\n' CRLF character.\n// returns malformed encoding if it doesn't.\nfunc readCRLF(reader io.Reader) error {\n\tbuf := make([]byte, 2)\n\t_, err := io.ReadFull(reader, buf[:2])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif buf[0] != '\\r' || buf[1] != '\\n' {\n\t\treturn errMalformedEncoding\n\t}\n\treturn nil\n}\n\n// Read a line of bytes (up to \\n) from b.\n// Give up if the line exceeds maxLineLength.\n// The returned bytes are owned by the bufio.Reader\n// so they are only valid until the next bufio read.\nfunc readChunkLine(b *bufio.Reader) ([]byte, []byte, error) {\n\tbuf, err := b.ReadSlice('\\n')\n\tif err != nil {\n\t\t// We always know when EOF is coming.\n\t\t// If the caller asked for a line, there should be a line.\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t} else if err == bufio.ErrBufferFull {\n\t\t\terr = errLineTooLong\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif len(buf) >= maxLineLength {\n\t\treturn nil, nil, errLineTooLong\n\t}\n\t// Parse s3 specific chunk extension and fetch the values.\n\thexChunkSize, hexChunkSignature := parseS3ChunkExtension(buf)\n\treturn hexChunkSize, hexChunkSignature, nil\n}\n\n// trimTrailingWhitespace - trim trailing white space.\nfunc trimTrailingWhitespace(b []byte) []byte {\n\tfor len(b) > 0 && isASCIISpace(b[len(b)-1]) {\n\t\tb = b[:len(b)-1]\n\t}\n\treturn b\n}\n\n// isASCIISpace - is ascii space?\nfunc isASCIISpace(b byte) bool {\n\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n}\n\n// Constant s3 chunk encoding signature.\nconst s3ChunkSignatureStr = \";chunk-signature=\"\n\n// parses3ChunkExtension removes any s3 specific chunk-extension from buf.\n// For example,\n//     \"10000;chunk-signature=...\" => \"10000\", \"chunk-signature=...\"\nfunc parseS3ChunkExtension(buf []byte) ([]byte, []byte) {\n\tbuf = trimTrailingWhitespace(buf)\n\tsemi := bytes.Index(buf, []byte(s3ChunkSignatureStr))\n\t// Chunk signature not found, return the whole buffer.\n\tif semi == -1 {\n\t\treturn buf, nil\n\t}\n\treturn buf[:semi], parseChunkSignature(buf[semi:])\n}\n\n// parseChunkSignature - parse chunk signature.\nfunc parseChunkSignature(chunk []byte) []byte {\n\tchunkSplits := bytes.SplitN(chunk, []byte(s3ChunkSignatureStr), 2)\n\treturn chunkSplits[1]\n}\n\n// parse hex to uint64.\nfunc parseHexUint(v []byte) (n uint64, err error) {\n\tfor i, b := range v {\n\t\tswitch {\n\t\tcase '0' <= b && b <= '9':\n\t\t\tb = b - '0'\n\t\tcase 'a' <= b && b <= 'f':\n\t\t\tb = b - 'a' + 10\n\t\tcase 'A' <= b && b <= 'F':\n\t\t\tb = b - 'A' + 10\n\t\tdefault:\n\t\t\treturn 0, errors.New(\"invalid byte in chunk length\")\n\t\t}\n\t\tif i == 16 {\n\t\t\treturn 0, errors.New(\"http chunk length too large\")\n\t\t}\n\t\tn <<= 4\n\t\tn |= uint64(b)\n\t}\n\treturn\n}\n"], "filenames": ["cmd/streaming-signature-v4.go"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [321], "fixing_code_start_loc": [169], "fixing_code_end_loc": [354], "type": "CWE-924", "message": "MinIO is an open-source high performance object storage service and it is API compatible with Amazon S3 cloud storage service. In MinIO before version RELEASE.2021-03-17T02-33-02Z, there is a vulnerability which enables MITM modification of request bodies that are meant to have integrity guaranteed by chunk signatures. In a PUT request using aws-chunked encoding, MinIO ordinarily verifies signatures at the end of a chunk. This check can be skipped if the client sends a false chunk size that is much greater than the actual data sent: the server accepts and completes the request without ever reaching the end of the chunk + thereby without ever checking the chunk signature. This is fixed in version RELEASE.2021-03-17T02-33-02Z. As a workaround one can avoid using \"aws-chunked\" encoding-based chunk signature upload requests instead use TLS. MinIO SDKs automatically disable chunked encoding signature when the server endpoint is configured with TLS.", "other": {"cve": {"id": "CVE-2021-21390", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-19T16:15:12.920", "lastModified": "2021-03-25T20:29:34.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO is an open-source high performance object storage service and it is API compatible with Amazon S3 cloud storage service. In MinIO before version RELEASE.2021-03-17T02-33-02Z, there is a vulnerability which enables MITM modification of request bodies that are meant to have integrity guaranteed by chunk signatures. In a PUT request using aws-chunked encoding, MinIO ordinarily verifies signatures at the end of a chunk. This check can be skipped if the client sends a false chunk size that is much greater than the actual data sent: the server accepts and completes the request without ever reaching the end of the chunk + thereby without ever checking the chunk signature. This is fixed in version RELEASE.2021-03-17T02-33-02Z. As a workaround one can avoid using \"aws-chunked\" encoding-based chunk signature upload requests instead use TLS. MinIO SDKs automatically disable chunked encoding signature when the server endpoint is configured with TLS."}, {"lang": "es", "value": "MinIO es un servicio de almacenamiento de objetos de alto rendimiento de c\u00f3digo abierto y su API es compatible con el servicio de almacenamiento en la nube Amazon S3. En MinIO versiones anteriores a RELEASE.2021-03-17T02-33-02Z, se presenta una vulnerabilidad que permite la modificaci\u00f3n por parte de un MITM de los cuerpos de las peticiones que se supone que presentan la integridad garantizada por las firmas de los fragmentos. En una petici\u00f3n PUT que usa la codificaci\u00f3n aws-chunked, MinIO normalmente comprueba las firmas al final de un fragmento. Esta comprobaci\u00f3n puede saltarse si el cliente env\u00eda un tama\u00f1o de fragmento falso que es mucho mayor que los datos reales enviados: el servidor acepta y completa la petici\u00f3n sin llegar nunca al final del fragmento + por tanto sin comprobar nunca la firma del fragmento. Esto se ha corregido en la versi\u00f3n RELEASE.2021-03-17T02-33-02Z. Como soluci\u00f3n, se puede evitar el uso de peticiones de carga de firmas de fragmentos basadas en la codificaci\u00f3n \"aws-chunked\" y, en su lugar, usar TLS. Los SDKs de MinIO deshabilitan autom\u00e1ticamente la firma de codificaci\u00f3n en trozos cuando el endpoint del servidor est\u00e1 configurado con TLS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-924"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-924"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-03-17t02-33-02z", "matchCriteriaId": "420A5DDF-D7F9-45C8-82EB-BD18D81939CA"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/e197800f9055489415b53cf137e31e194aaf7ba0", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/11801", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-xr7r-7gpj-5pgp", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/e197800f9055489415b53cf137e31e194aaf7ba0"}}