{"buggy_code": ["# ksh 2020.1.0 (this is a work in progress)\n\n## Deprecations\n\n## Notable non-backward compatible changes\n\n- The `login` and `newgrp` special builtins have been removed. Use\n  `exec login` and `exec newgrp` instead (#1348).\n\n## Notable fixes and improvements\n\n- Fix `history` command behavior when the *~/.sh_history* file has\n  specific content (issue #1432).\n- A ${.sh.install_prefix}/config.ksh file will be sourced if it exists. It is\n  the first config file loaded by every ksh instance. It is loaded regardless\n  of whether the shell is interactive, login, or neither.\n- A .sh.install_prefix var has been introduced to reflect the `meson -prefix=`\n  value. This will be used to establish the location of supporting files such\n  as man pages and autoloaded functions.\n\n## Other significant changes\n\n# ksh 2020.0.0\n\nThis documents changes since the AST code, which includes the `ksh` program,\nwas moved to Github. That is, the ksh93u+ source. The next stable version will\nbe treated as a major release for several reasons. Not least of which is\nchanging the build tool chain from the legacy Nmake system to Meson and\nreplacing the AST Vmalloc subsystem with the platform Malloc subsystem. Legacy\nchanges can be found in the various `RELEASE` files.\n\nStarting in June 2017 maintenance of the Korn shell (`ksh`) resumed with\nthe merging of some fixes from Red Hat by Siteshwar Vashisht after he was\ngranted commit privilege. In October 2017 Kurtis Rader noticed that `ksh`\nhad been open sourced and started contributing changes. This document\nwas subsequently created to document the work being done.\n\n## Deprecations\n\n- Some libc/libm math functions not suitable for use by a ksh script (e.g.,\n  `j0()`) will likely be removed in the near future (issue #1346 and #88).\n\n## Notable non-backward compatible changes\n\n- The nonportable, unusable, `fpclassify` math function has been removed\n  (issue #1346).\n- The broken math functions `nextforward` and `nexttoward` have been removed\n  (issue #1346).\n- Support for binary plugins written for ksh93u+ or earlier releases has been\n  dropped (issue #983).\n- Support for coshell has been removed (issue #619).\n- The `universe` command has been removed (issue #793).\n- The `getconf` command has been removed (issue #1118).\n- Support for building on systems using EBCDIC has been removed (issue #742).\n- Support for the `LC_OPTIONS` env var has been removed (issue #579).\n- `case \"[0-9]\" in [0-9]) echo match;; esac` has stopped matching. When a case\n  statement doesn't match a pattern, it no longer tries to use the pattern as\n  a literal string (issue #476).\n- echo builtin now interprets escape sequences and parses command line options\n  on all platforms. (issue #370)\n- Support for the UWIN environment has been removed (issue #284).\n- The experimental `SHOPT_FIXEDARRAY` feature has been removed. It is known to\n  have been enabled in some Fedora and RHEL builds. But because it was\n  experimental and undocumented this should not break any existing users of\n  `ksh` built with this feature enabled. (issue #234)\n- <> operator now redirects standard input by default (issue #75).\n- Support for the build time SHOPT_ACCTFILE symbol and code has been removed\n  (issue #210).\n- Versioning scheme has been changed to use semantic version numbers (issue #335).\n- Undocumented and broken `alarm` builtin has been removed (issue #646).\n\n## Notable fixes and improvements\n\n- `declare` has been added as an alias for `typeset` (issue #220).\n- `local` has been added as a constrained alias for `typeset` when used inside\n  a function (issue #220).\n- Mention of the `getconf` builtin has been removed from the main ksh man\n  page. That command has never been enabled by default and is now deprecated\n  in favor of the platform command of the same name (issue #1118).\n- The `test` command no longer silently fails all uses of the `=~` operator.\n  Instead an error is printed suggesting the use of `[[...]]` (issue #1152).\n- Doing `[ -t1 ]` inside a command substitution behaves correctly\n  (issue #1079).\n- The project now passes its unit tests when built with malloc debugging\n  enabled (i.e., `meson test --setup=malloc`) or with ASAN enabled.\n- Changes to the project are now validated by running unit tests on the Travis\n  continuous integration system.\n- The ksh source now builds on BSD based systems such as macOS and FreeBSD.\n- The ksh source now builds on Cygwin; albeit with many unit test failures.\n- The legacy Nmake build system has been replaced by Meson. This improves the\n  build time by roughly an order of magnitude (issue #42).\n- The `times` command is now a builtin that conforms to POSIX rather than an\n  alias for the `time` command (issue #16).\n- The `time` command now has millisecond resolution if the platform provides\n  `getrusage()` and its time values have millisecond or better resolution.\n\n## Other significant changes\n\n- Using a bare tilde (e.g., `cd ~`) now works correctly if `$HOME` is not set\n  (issue #1391).\n- You can no longer run an external command with stdin, stdout, or stderr\n  closed. If you attempt to do so (e.g., `a_cmd <&-`) it will be opened on\n  /dev/null in the child process (issue #1117).\n- Vi raw mode is now the default and cannot be disabled. Note that this was\n  true at least as far back as ksh93u+. The difference is that now it's no\n  longer even theoretically possible to even build with that feature disabled.\n  (issue #864).\n- The AST locale subsystem has been replaced by the platform's implementation\n  (issue #579).\n- The AST Vmalloc subsystem has been removed. The project now uses the system\n  malloc. (issue #396)\n- Operations that depend on the simulated 3DFS behavior found in release\n  ksh93v are no longer supported. That behavior does not work in ksh93u (the\n  most recent stable release found in all distros) unless the 3D file system\n  is actually present. This includes operations such as this:\n  `exec {fd}</dev; cd ~{fd}` (issue #510).\n- The math `scalb` function has been removed since it was marked obsolete by\n  POSIX in 2001 and is no longer found in some libc implementations.\n- Code hidden behind the SHOPT_ACCT and SHOPT_ACCTFILE build time symbols\n  has been removed. The features are not enabled by default and I am not aware\n  of any distro which enables them. Furthermore, they are huge security holes\n  and should never be enabled.\n- The suid_exec program has been removed (issue #366).\n- The code has been restyled according to new guidelines (issue #125).\n- Many features which used to be optionally included at build time are now\n  unconditionally included (e.g., the code protected by `SHOPT_MULTIBYTE`,\n  `SHOPT_COMPLETE`, `SHOPT_BRACEPAT`, `SHOPT_RAWONLY`, `SHOPT_STATS,\n  `SHOPT_OPTIMIZE`, `SHOPT_SUID_EXEC`, `SHOPT_FILESCAN`, `SHOPT_POLL,\n  `SHOPT_AUDIT`, and `SHOPT_SYSRC`).\n- Unit tests can now be run under Valgrind and ASAN to help detect more bugs.\n- Any code not needed to build and run `ksh` has been removed from the master\n  branch.\n- Fixes backported from OpenSuse (issue #377).\n- Fixes backported from Red Hat Fedora and Enterprise Linux (RHEL) distros\n  (issue #172).\n- Fixes backported from Solaris (issue #122).\n\n## Other significant changes taken from ksh93v-:\n\nLast stable release was `ksh93u+`. ksh x.y.z is based on `ksh93v-` which was last beta\nrelease that came out from AT&T Bell Labs. It had number of notable changes that are\nlisted below. Entries are directly taken from `src/cmd/ksh93/RELEASE` file (with minor\nspelling fixes):\n\n- 14-12-02  The requirement that unquoted { and } must match inside string with\n\t  ${name op string} has been removed (at least for now).\n- 14-09-24 +When listing jobs, the shell now shows the directory that the job\n\t  was started from when it was not started from the current working\n\t  directory.\n- 14-07-11 +Added -t flag and -P flag to whence and type for bash compatibility.\n- 14-07-11 +Added -p flag to alias to output aliases for re-input.\n- 14-06-30 +The variable COMP_WORDBREAKS for programmable completion.\n- 14-06-25 +The -D and -E options have been added to the complete builtin.\n- 14-06-19 +The -l flag to trap and the -p flag to umask were added as in bash.\n- 14-06-16 +Added parameter expansion operator ${$parameter} for variables and\n\t  positional parameters.\n- 14-06-06  Added -a option to read which is equivalent to -A.\n- 14-06-05 +Added -n option to builtin to disable builtins.\n- 14-05-25 +Replaced the -p option for read with -p prompt.  For backward\n\t  compatibility, if a coprocess is running and prompt begins with -\n\t  or is a valid variable name, -p causes the read from a pipe.\n- 14-05-25 +Modified the -u option for read and print so that it accepts the\n\t  option argument p to indicate the coprocess file descriptor.\n- 14-01-10  [[...]] now supports hexadecimal constants with arithmetic operators.\n- 13-12-05  If cd is invoked with no arguments and HOME is unset, it attempts to\n\t  find the home directory and use that.  Otherwise an error occurs.\n- 13-11-14 +Added -f fd option to pwd to display the directory corresponding to\n\t  file descriptor fd.\n- 13-10-08  The shell arithmetic now recognized suffices f,F, l, and L for\n\t  floating point constants.\n- 13-10-07  The shell now prints an error message on standard error when a\n\t  job specified with %job does not exist.\n- 13-09-13 +The signal .sh.value variable is now a compound variable with the name\n\t  value.q for sending a signal with -q and value.Q for sending a value\n\t  with -Q.\n- 13-09-10 +A -Q option was added to kill to pass integers as large as pointers.\n\t  The -q option now only accepts integers as large as typeset -i.\n- 13-09-09  Qualified print format \"%([no]unicode)q\" added to prefer \\u[...]\n\t  over \\w[...] and override LC_OPTIONS=unicode.\n- 13-09-04 +\\w[hex] locale-specific code point literals have been added.\n- 13-09-04 +The float(f) math function was added.\n- 13-09-04  kill -q can now pass numbers as large as typeset -li and\n\t  .sh.sig.value is typeset -i rather than a compound variable.\n- 13-09-04  kill -q yields the processor and returns 2 when siqueue fails with\n\t  EAGAIN and yield.\n- 13-08-26 +Added 12 math constants such as E, PI, and SQRT2.\n- 13-08-19 +The variable .sh.pwdfd which expands to the file descriptor number\n\t  corresponding to $PWD has been added.\n- 13-08-11 +namespace was modified so that namespace names can be a compound\n\t  variable rather than just an identifier and namespace are no\n\t  longer nested.\n- 13-08-07  typeset -p (and print -v) now display the short attribute for\n\t  typeset -sF and typeset -sE.\n- 13-08-06 +You can now use the redirection <& {n} which is the same as <& $n.\n- 13-07-24  The _ variable is now set as a reference to the type inside\n\t  discipline functions for non-type variables in the type.\n- 13-07-22  The .sh.sig variable has been modified to treat .sh.value as a\n\t  compound variable containing int and ptr.\n- 13-07-18  Assignments of the type name=(...) to array variables now preserve\n\t  the array type and the variable type if any.\n- 13-07-18  If a PATH ends in ., and you are in the current directory and this\n\t  directory is in FPATH, ksh now treats this as a function directory.\n- 13-07-17  ${!.sh.sig@]} now expands to all the .sh.sig. variables.\n- 13-07-08  When using kill -q to send a signal, a CONT signal is not sent to\n\t  wake the process if it is sleeping after sending the signal.\n- 13-06-21  A -f nn option has been added to cd to change to a directory\n\t  relative to a file descriptor of an open directory.  cd -f nn\n\t  is equivalent to cd ~{nn}.\n- 13-06-06  In accordance with the standard set -u now causes failures for\n\t  unset positional parameters.\n- 13-05-29  ksh93 now intercepts the `LC_TIME` variable.\n- 13-05-29  namespace commands are no longer allowed inside function definitions\n\t  and now generate a syntax error.\n- 13-05-10  With print -v for with nested compound variables, the output contains\n\t  typeset -C for sub-variables that are compound assignments.\n- 13-05-08  Added a ksh -n options that suggests that x=$((expr)) be replaced by\n\t  ((x=expr))>\n- 13-05-01 +Increased to maximum number of enumeration elements from 32K to\n\t  2G.\n- 13-04-25 +The -K option has been added to set to sort indexed arrays of\n\t  compound elements based on a list of keys.\n- 13-04-18  Added serialization to processing of CHLD traps.\n- 13-04-15  ksh now waits for background jobs started in functions contained\n\t  in command substitution.\n- 13-04-08 +ksh now sets .sh.sig.pid and .sh.sig.status for CHLD traps.  The\n\t  .sh.sig.status can be one of exited, killed, dumped, stopped or\n\t  continued.\n- 13-04-08 +The CHLD trap is now triggered with STOP and CONT signals.\n- 13-04-03 +Functions that are used in brace group command substitution ${ ... }\n\t  can assign the result to .sh.value instead of writing to standard\n\t  out with the same result, but faster.\n- 13-03-27 +The variable .sh.sig containing siginfo information is no set during\n\t  a SIGCHLD trap.\n- 13-03-12  Empty fields and empty arrays as type elements are not displayed\n\t  when expanding a type instance.\n- 13-03-11  The trap command now blocks signals that have traps until the\n\t  trap command completes.\n- 13-03-11  Signals that have traps that occur while processing a trap are\n\t  deferred until the trap command completes.\n- 13-02-08 +The -p option was added to enum to display the values that are\n\t  valid for the enum.\n- 13-02-07 +A preset alias named bool which is an alias for an enum\n\t  named `_Bool` which has values true and false has been added.\n- 13-02-24  Increased the maximum level of recursion for evaluating variables\n\t  inside arithmetic expressions from 9 to 1024.\n- 13-01-17 +User define math functions introduced on 10-03-24 now allow passing\n\t  arrays as arguments.\n- 13-01-10 +ksh now treats ESC-O-letter the same as ESC-[-letter in vi and emacs\n\t  edit modes.\n- 12-10-09 +read -d '' now reads up to a NUL byte.\n- 12-10-04  libcmd builtins are statically linked into ksh93 and by default are\n\t  bound to the path /opt/ast/bin whether this path exists or not.\n\t  Changing the .sh.op_astbin variable changes the binding.\n- 12-10-01 +Added the variable `SH_OPTIONS` which consists of name=value pairs.\n\t  For defined options it assigned value to the variable .sh.op_name.\n- 12-10-02 +Add the variable .sh.op_astbin to define the directory where several\n\t  shell builtins will be bound.\n- 12-09-10 +Added ~{fd} expansion where fd is the number of an open file or\n\t  a variable whose value is the number of an open file.\n- 12-08-30  For an associative array A, $((A[sub])) no longer cause subscript sub\n\t  to be created.\n- 12-08-20  typeset -H foo no longer un-sets foo when foo has been exported to\n\t  the shell.\n- 12-07-12 +Added -q option was added to kill to send queued signals on systems\n\t  that support sigqueue().\n- 12-07-12 +Added -p option to builtin to output builtins in a format that can\n\t  be used to re-input.\n- 12-07-02 +The -a option was added to trap to cause the current setting to be\n\t  appended to the new trap setting rather than replacing it.\n", "/***********************************************************************\n *                                                                      *\n *               This software is part of the ast package               *\n *          Copyright (c) 1982-2013 AT&T Intellectual Property          *\n *                      and is licensed under the                       *\n *                 Eclipse Public License, Version 1.0                  *\n *                    by AT&T Intellectual Property                     *\n *                                                                      *\n *                A copy of the License is available at                 *\n *          http://www.eclipse.org/org/documents/epl-v10.html           *\n *         (with md5 checksum b35adb5213ca9657e911e9befb180842)         *\n *                                                                      *\n *              Information and Software Systems Research               *\n *                            AT&T Research                             *\n *                           Florham Park NJ                            *\n *                                                                      *\n *                    David Korn <dgkorn@gmail.com>                     *\n *                                                                      *\n ***********************************************************************/\n//\n// Shell arithmetic - uses streval library\n//   David Korn\n//   AT&T Labs\n//\n#include \"config_ast.h\"  // IWYU pragma: keep\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"ast.h\"\n#include \"builtins.h\"\n#include \"cdt.h\"\n#include \"defs.h\"\n#include \"error.h\"\n#include \"lexstates.h\"\n#include \"name.h\"\n#include \"sfio.h\"\n#include \"shcmd.h\"\n#include \"stk.h\"\n#include \"streval.h\"\n#include \"variables.h\"\n\n#ifndef LLONG_MAX\n#define LLONG_MAX LONG_MAX\n#endif\n\ntypedef Sfdouble_t (*Math_f)(Sfdouble_t, ...);\n\nextern const Namdisc_t ENUM_disc;\nstatic bool Varsubscript;\nstatic Sfdouble_t NaN, Inf, Fun;\nstatic Namval_t Infnod = {.nvname = \"Inf\"};\nstatic Namval_t NaNnod = {.nvname = \"NaN\"};\nstatic Namval_t FunNode = {.nvname = \"?\"};\n\nstruct Mathconst {\n    char name[9];\n    Sfdouble_t value;\n};\n\n#ifndef M_1_PIl\n#define M_1_PIl 0.3183098861837906715377675267450287L\n#endif\n#ifndef M_2_PIl\n#define M_2_PIl 0.6366197723675813430755350534900574L\n#endif\n#ifndef M_2_SQRTPIl\n#define M_2_SQRTPIl 1.1283791670955125738961589031215452L\n#endif\n#ifndef M_El\n#define M_El 2.7182818284590452353602874713526625L\n#endif\n#ifndef M_LOG2El\n#define M_LOG2El 1.4426950408889634073599246810018921L\n#endif\n#ifndef M_LOG10El\n#define M_LOG10El 0.4342944819032518276511289189166051L\n#endif\n#ifndef M_LN2l\n#define M_LN2l 0.6931471805599453094172321214581766L\n#endif\n#ifndef M_LN10l\n#define M_LN10l 2.3025850929940456840179914546843642L\n#endif\n#ifndef M_PIl\n#define M_PIl 3.1415926535897932384626433832795029L\n#endif\n#ifndef M_PI_2l\n#define M_PI_2l 1.5707963267948966192313216916397514L\n#endif\n#ifndef M_PI_4l\n#define M_PI_4l 0.7853981633974483096156608458198757L\n#endif\n#ifndef M_SQRT2l\n#define M_SQRT2l 1.4142135623730950488016887242096981L\n#endif\n#ifndef M_SQRT1_2l\n#define M_SQRT1_2l 0.7071067811865475244008443621048490L\n#endif\n\n// The first three entries cann't be moved or it will break the code.\nstatic const struct Mathconst Mtable[] = {\n    {\"1_PI\", M_1_PIl}, {\"2_PI\", M_2_PIl},   {\"2_SQRTPI\", M_2_SQRTPIl},\n    {\"E\", M_El},       {\"LOG2E\", M_LOG2El}, {\"LOG10E\", M_LOG10El},\n    {\"LN2\", M_LN2l},   {\"PI\", M_PIl},       {\"PI_2\", M_PI_2l},\n    {\"PI_4\", M_PI_4l}, {\"SQRT2\", M_SQRT2l}, {\"SQRT1_2\", M_SQRT1_2l},\n    {\"\", 0.0}};\n\nstatic_fn Namval_t *scope(Namval_t *np, struct lval *lvalue, int assign) {\n    int flag = lvalue->flag;\n    char *sub = 0, *cp = (char *)np;\n    Namval_t *mp;\n    Shell_t *shp = lvalue->shp;\n    int c = 0, nosub = lvalue->nosub;\n    Dt_t *sdict = (shp->st.real_fun ? shp->st.real_fun->sdict : 0);\n    Dt_t *nsdict = (shp->namespace ? nv_dict(shp->namespace) : 0);\n    Dt_t *root = shp->var_tree;\n\n    nvflag_t nvflags = assign ? NV_ASSIGN : 0;\n    lvalue->nosub = 0;\n    if (nosub < 0 && lvalue->ovalue) return (Namval_t *)lvalue->ovalue;\n    lvalue->ovalue = NULL;\n    if (cp >= lvalue->expr && cp < lvalue->expr + lvalue->elen) {\n        int offset;\n        // Do binding to node now.\n        int d = cp[flag];\n        cp[flag] = 0;\n        np = nv_open(cp, root, nvflags | NV_VARNAME | NV_NOADD | NV_NOFAIL);\n        if ((!np || nv_isnull(np)) && sh_macfun(shp, cp, offset = stktell(shp->stk))) {\n            Fun = sh_arith(shp, sub = stkptr(shp->stk, offset));\n            STORE_VT(FunNode.nvalue, sfdoublep, &Fun);\n            FunNode.nvshell = shp;\n            nv_onattr(&FunNode, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n            cp[flag] = d;\n            return &FunNode;\n        }\n        if (!np && assign) {\n            np = nv_open(cp, root, nvflags | NV_VARNAME);\n        }\n        cp[flag] = d;\n        if (!np) return 0;\n        root = shp->last_root;\n        if (cp[flag + 1] == '[') {\n            flag++;\n        } else {\n            flag = 0;\n        }\n    }\n\n    if ((lvalue->emode & ARITH_COMP) && dtvnext(root)) {\n        mp = nv_search_namval(np, sdict ? sdict : root, NV_NOSCOPE);\n        if (!mp && nsdict) mp = nv_search_namval(np, nsdict, 0);\n        if (mp) np = mp;\n    }\n\n    while (nv_isref(np)) {\n        sub = nv_refsub(np);\n        np = nv_refnode(np);\n        if (sub) nv_putsub(np, sub, 0, assign ? ARRAY_ADD : 0);\n    }\n\n    if (!nosub && flag) {\n        int hasdot = 0;\n        cp = (char *)&lvalue->expr[flag];\n        if (sub) goto skip;\n        sub = cp;\n        while (1) {\n            Namarr_t *ap;\n            Namval_t *nq;\n            cp = nv_endsubscript(np, cp, 0, shp);\n            if (c || *cp == '.') {\n                c = '.';\n                while (*cp == '.') {\n                    hasdot = 1;\n                    cp++;\n                    while (c = mb1char(&cp), isaname(c)) {\n                        ;  // empty body\n                    }\n                }\n                if (c == '[') continue;\n            }\n            flag = *cp;\n            *cp = 0;\n            if (c || hasdot) {\n                sfprintf(shp->strbuf, \"%s%s%c\", nv_name(np), sub, 0);\n                sub = sfstruse(shp->strbuf);\n            }\n            if (strchr(sub, '$')) sub = sh_mactrim(shp, sub, 0);\n            *cp = flag;\n            if (c || hasdot) {\n                np = nv_open(sub, shp->var_tree, NV_VARNAME | nvflags);\n                return np;\n            }\n            cp = nv_endsubscript(np, sub, (assign ? NV_ADD : 0) | NV_SUBQUOTE, np->nvshell);\n            if (*cp != '[') break;\n        skip:\n            nq = nv_opensub(np);\n            if (nq) {\n                np = nq;\n            } else {\n                ap = nv_arrayptr(np);\n                if (ap && !ap->table) {\n                    ap->table = dtopen(&_Nvdisc, Dtoset);\n                    dtuserdata(ap->table, shp, 1);\n                }\n                if (ap && ap->table && (nq = nv_search(nv_getsub(np), ap->table, NV_ADD))) {\n                    nq->nvenv = np;\n                }\n                if (nq && nv_isnull(nq)) np = nv_arraychild(np, nq, 0);\n            }\n            sub = cp;\n        }\n    } else if (nosub > 0) {\n        nv_putsub(np, NULL, nosub - 1, 0);\n    }\n    return np;\n}\n\nMath_f sh_mathstdfun(const char *fname, size_t fsize, short *nargs) {\n    const struct mathtab *tp;\n    char c = fname[0];\n    for (tp = shtab_math; *tp->fname; tp++) {\n        if (*tp->fname > c) break;\n        if (tp->fname[1] == c && tp->fname[fsize + 1] == 0 &&\n            strncmp(&tp->fname[1], fname, fsize) == 0) {\n            if (nargs) *nargs = *tp->fname;\n            return tp->fnptr;\n        }\n    }\n    return NULL;\n}\n\nint sh_mathstd(const char *name) { return sh_mathstdfun(name, strlen(name), NULL) != 0; }\n\nstatic_fn Sfdouble_t number(const char *s, char **p, int b, struct lval *lvalue) {\n    Sfdouble_t r;\n    char *t;\n    int oerrno;\n    int c;\n    char base;\n    struct lval v;\n\n    oerrno = errno;\n    errno = 0;\n    base = b;\n\n    if (!lvalue) {\n        lvalue = &v;\n    } else if (lvalue->shp->bltindata.bnode == SYSLET && !sh_isoption(lvalue->shp, SH_LETOCTAL)) {\n        while (*s == '0' && isdigit(s[1])) s++;\n    }\n    lvalue->eflag = 0;\n    lvalue->isfloat = 0;\n    r = strton64(s, &t, &base, -1);\n    if (*t == '8' || *t == '9') {\n        base = 10;\n        errno = 0;\n        r = strton64(s, &t, &base, -1);\n    }\n    if (base <= 1) base = 10;\n    if (*t == '_') {\n        if ((r == 1 || r == 2) && strcmp(t, \"_PI\") == 0) {\n            t += 3;\n            r = Mtable[(int)r - 1].value;\n        } else if (r == 2 && strcmp(t, \"_SQRTPI\") == 0) {\n            t += 7;\n            r = Mtable[2].value;\n        }\n    }\n    c = r == LLONG_MAX && errno ? 'e' : *t;\n    if (c == getdecimal() || c == 'e' || c == 'E' || (base == 16 && (c == 'p' || c == 'P'))) {\n        r = strtold(s, &t);\n        lvalue->isfloat = TYPE_LD;\n    }\n    if (t > s) {\n        if (*t == 'f' || *t == 'F') {\n            t++;\n            lvalue->isfloat = TYPE_F;\n            r = (float)r;\n        } else if (*t == 'l' || *t == 'L') {\n            t++;\n            lvalue->isfloat = TYPE_LD;\n        } else if (*t == 'd' || *t == 'D') {\n            t++;\n            lvalue->isfloat = TYPE_LD;\n            r = (double)r;\n        }\n    }\n    errno = oerrno;\n    *p = t;\n    return r;\n}\n\nstatic_fn Sfdouble_t arith(const char **ptr, struct lval *lvalue, int type, Sfdouble_t n) {\n    Shell_t *shp = lvalue->shp;\n    Sfdouble_t r = 0;\n    char *str = (char *)*ptr;\n    char *cp;\n\n    switch (type) {\n        case ASSIGN: {\n            Namval_t *np = (Namval_t *)(lvalue->value);\n            np = scope(np, lvalue, 1);\n            nv_putval(np, (char *)&n, NV_LDOUBLE);\n            if (lvalue->eflag) lvalue->ptr = nv_hasdisc(np, &ENUM_disc);\n            lvalue->eflag = 0;\n            r = nv_getnum(np);\n            lvalue->value = (char *)np;\n            break;\n        }\n        case LOOKUP: {\n            int c = *str;\n            char *xp = str;\n            lvalue->value = NULL;\n            if (c == '.') str++;\n            c = mb1char(&str);\n            if (isaletter(c)) {\n                Namval_t *np = NULL;\n                int dot = 0;\n                while (1) {\n                    xp = str;\n                    while (c = mb1char(&str), isaname(c)) xp = str;\n                    str = xp;\n                    while (c == '[' && dot == NV_NOADD) {\n                        str = nv_endsubscript(NULL, str, 0, shp);\n                        c = *str;\n                    }\n                    if (c != '.') break;\n                    dot = NV_NOADD;\n                    c = *++str;\n                    if (c != '[') continue;\n                    str = nv_endsubscript(NULL, cp = str, NV_SUBQUOTE, shp) - 1;\n                    if (sh_checkid(cp + 1, NULL)) str -= 2;\n                }\n                if (c == '(') {\n                    int off = stktell(shp->stk);\n                    int fsize = str - (char *)(*ptr);\n                    const struct mathtab *tp;\n                    Namval_t *nq;\n                    lvalue->fun = NULL;\n                    sfprintf(shp->stk, \".sh.math.%.*s%c\", fsize, *ptr, 0);\n                    stkseek(shp->stk, off);\n                    nq = nv_search(stkptr(shp->stk, off), shp->fun_tree, 0);\n                    if (nq) {\n                        struct Ufunction *rp = FETCH_VT(nq->nvalue, rp);\n                        lvalue->nargs = -rp->argc;\n                        lvalue->fun = (Math_f)nq;\n                        break;\n                    }\n                    if (fsize <= (sizeof(tp->fname) - 2)) {\n                        lvalue->fun = (Math_f)sh_mathstdfun(*ptr, fsize, &lvalue->nargs);\n                    }\n                    if (lvalue->fun) break;\n                    if (lvalue->emode & ARITH_COMP) {\n                        lvalue->value = (char *)e_function;\n                    } else {\n                        lvalue->value = (char *)ERROR_dictionary(e_function);\n                    }\n                    return r;\n                }\n                if ((lvalue->emode & ARITH_COMP) && dot) {\n                    lvalue->value = (char *)*ptr;\n                    lvalue->flag = str - lvalue->value;\n                    break;\n                }\n                *str = 0;\n                if (sh_isoption(shp, SH_NOEXEC)) {\n                    np = VAR_underscore;\n                } else {\n                    int offset = stktell(shp->stk);\n                    char *saveptr = stkfreeze(shp->stk, 0);\n                    Dt_t *root = (lvalue->emode & ARITH_COMP) ? shp->var_base : shp->var_tree;\n                    *str = c;\n                    cp = str;\n                    while (c == '[' || c == '.') {\n                        if (c == '[') {\n                            str = nv_endsubscript(np, str, 0, shp);\n                            c = *str;\n                            if (c != '[' && c != '.') {\n                                str = cp;\n                                c = '[';\n                                break;\n                            }\n                        } else {\n                            dot = NV_NOADD | NV_NOFAIL;\n                            str++;\n                            xp = str;\n                            while (c = mb1char(&str), isaname(c)) xp = str;\n                            str = xp;\n                        }\n                    }\n                    *str = 0;\n                    cp = (char *)*ptr;\n                    Varsubscript = false;\n                    if ((cp[0] == 'i' || cp[0] == 'I') && (cp[1] == 'n' || cp[1] == 'N') &&\n                        (cp[2] == 'f' || cp[2] == 'F') && cp[3] == 0) {\n                        Inf = strtold(\"Inf\", NULL);\n                        STORE_VT(Infnod.nvalue, sfdoublep, &Inf);\n                        np = &Infnod;\n                        np->nvshell = shp;\n                        nv_onattr(np, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n                    } else if ((cp[0] == 'n' || cp[0] == 'N') && (cp[1] == 'a' || cp[1] == 'A') &&\n                               (cp[2] == 'n' || cp[2] == 'N') && cp[3] == 0) {\n                        NaN = strtold(\"NaN\", NULL);\n                        STORE_VT(NaNnod.nvalue, sfdoublep, &NaN);\n                        np = &NaNnod;\n                        np->nvshell = shp;\n                        nv_onattr(np, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n                    } else {\n                        const struct Mathconst *mp = NULL;\n                        np = NULL;\n                        if (strchr(\"ELPS12\", **ptr)) {\n                            for (mp = Mtable; *mp->name; mp++) {\n                                if (strcmp(mp->name, *ptr) == 0) break;\n                            }\n                        }\n                        if (mp && *mp->name) {\n                            r = mp->value;\n                            lvalue->isfloat = TYPE_LD;\n                            goto skip2;\n                        }\n                        if (shp->namref_root && !(lvalue->emode & ARITH_COMP)) {\n                            np = nv_open(*ptr, shp->namref_root,\n                                         NV_NOREF | NV_VARNAME | NV_NOSCOPE | NV_NOADD | dot);\n                        }\n                        if (!np) {\n                            np = nv_open(*ptr, root, NV_NOREF | NV_VARNAME | dot);\n                        }\n                        if (!np || Varsubscript) {\n                            np = NULL;\n                            lvalue->value = (char *)*ptr;\n                            lvalue->flag = str - lvalue->value;\n                        }\n                    }\n                skip2:\n                    if (saveptr != stkptr(shp->stk, 0)) {\n                        stkset(shp->stk, saveptr, offset);\n                    } else {\n                        stkseek(shp->stk, offset);\n                    }\n                }\n                *str = c;\n                if (lvalue->isfloat == TYPE_LD) break;\n                if (!np) break;  // this used to also test `&& lvalue->value` but that's redundant\n                lvalue->value = (char *)np;\n                // Bind subscript later.\n                if (nv_isattr(np, NV_DOUBLE) == NV_DOUBLE) lvalue->isfloat = 1;\n                lvalue->flag = 0;\n                if (c == '[') {\n                    lvalue->flag = (str - lvalue->expr);\n                    do {\n                        while (c == '.') {\n                            str++;\n                            while (xp = str, c = mb1char(&str), isaname(c)) {\n                                ;  // empty body\n                            }\n                            c = *(str = xp);\n                        }\n                        if (c == '[') str = nv_endsubscript(np, str, 0, np->nvshell);\n                        c = *str;\n                    } while (c == '[' || c == '.');\n                    break;\n                }\n            } else {\n                r = number(xp, &str, 0, lvalue);\n            }\n            break;\n        }\n        case VALUE: {\n            Namval_t *np = (Namval_t *)(lvalue->value);\n            Namarr_t *ap;\n            if (sh_isoption(shp, SH_NOEXEC)) return 0;\n            np = scope(np, lvalue, 0);\n            if (!np) {\n                if (sh_isoption(shp, SH_NOUNSET)) {\n                    *ptr = lvalue->value;\n                    goto skip;\n                }\n                return 0;\n            }\n            lvalue->ovalue = (char *)np;\n            if (lvalue->eflag) {\n                lvalue->ptr = nv_hasdisc(np, &ENUM_disc);\n            } else if ((Namfun_t *)lvalue->ptr && !nv_hasdisc(np, &ENUM_disc) &&\n                       !nv_isattr(np, NV_INTEGER)) {\n                // TODO: The calloc() below should be considered a bandaid and may not be correct.\n                // See https://github.com/att/ast/issues/980. This dynamic allocation may leak some\n                // memory but that is preferable to referencing a stack var after this function\n                // returns. I think I have addressed this by removing the NV_NOFREE flag but I'm\n                // leaving this comment due to my low confidence.\n                Namval_t *mp = ((Namfun_t *)lvalue->ptr)->type;\n                Namval_t *node = calloc(1, sizeof(Namval_t));\n                nv_clone(mp, node, 0);\n                nv_offattr(node, NV_NOFREE);\n                nv_offattr(node, NV_RDONLY);\n                nv_putval(node, np->nvname, 0);\n\n                if (nv_isattr(node, NV_NOFREE)) return nv_getnum(node);\n            }\n            lvalue->eflag = 0;\n            if (((lvalue->emode & 2) || lvalue->level > 1 ||\n                 (lvalue->nextop != A_STORE && sh_isoption(shp, SH_NOUNSET))) &&\n                nv_isnull(np) && !nv_isattr(np, NV_INTEGER)) {\n                *ptr = nv_name(np);\n            skip:\n                lvalue->value = (char *)ERROR_dictionary(e_notset);\n                lvalue->emode |= 010;\n                return 0;\n            }\n            if (lvalue->userfn) {\n                ap = nv_arrayptr(np);\n                if (ap && (ap->flags & ARRAY_UNDEF)) {\n                    r = (Sfdouble_t)(uintptr_t)np;\n                    lvalue->isfloat = 5;\n                    return r;\n                }\n            }\n            r = nv_getnum(np);\n            if (nv_isattr(np, NV_INTEGER | NV_BINARY) == (NV_INTEGER | NV_BINARY)) {\n                lvalue->isfloat = (r != (Sflong_t)r) ? TYPE_LD : 0;\n            } else if (nv_isattr(np, (NV_DOUBLE | NV_SHORT)) == (NV_DOUBLE | NV_SHORT)) {\n                lvalue->isfloat = TYPE_F;\n                r = (float)r;\n            } else if (nv_isattr(np, (NV_DOUBLE | NV_LONG)) == (NV_DOUBLE | NV_LONG)) {\n                lvalue->isfloat = TYPE_LD;\n            } else if (nv_isattr(np, NV_DOUBLE) == NV_DOUBLE) {\n                lvalue->isfloat = TYPE_D;\n                r = (double)r;\n            }\n            if ((lvalue->emode & ARITH_ASSIGNOP) && nv_isarray(np)) {\n                lvalue->nosub = nv_aindex(np) + 1;\n            }\n            return r;\n        }\n        case MESSAGE: {\n            sfsync(NULL);\n            if (lvalue->emode & ARITH_COMP) return -1;\n\n            errormsg(SH_DICT, ERROR_exit((lvalue->emode & 3) != 0), lvalue->value, *ptr);\n        }\n    }\n    *ptr = str;\n    return r;\n}\n\nSfdouble_t sh_arith(Shell_t *shp, const char *str) { return sh_strnum(shp, str, NULL, 1); }\n\nvoid *sh_arithcomp(Shell_t *shp, char *str) {\n    const char *ptr = str;\n    Arith_t *ep;\n\n    ep = arith_compile(shp, str, (char **)&ptr, arith, ARITH_COMP | 1);\n    if (*ptr) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *ptr, str);\n    return ep;\n}\n\n// Convert number defined by string to a Sfdouble_t.\n// Ptr is set to the last character processed.\n// If mode>0, an error will be fatal with value <mode>.\nSfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}\n", "########################################################################\n#                                                                      #\n#               This software is part of the ast package               #\n#          Copyright (c) 1982-2014 AT&T Intellectual Property          #\n#                      and is licensed under the                       #\n#                 Eclipse Public License, Version 1.0                  #\n#                    by AT&T Intellectual Property                     #\n#                                                                      #\n#                A copy of the License is available at                 #\n#          http://www.eclipse.org/org/documents/epl-v10.html           #\n#         (with md5 checksum b35adb5213ca9657e911e9befb180842)         #\n#                                                                      #\n#              Information and Software Systems Research               #\n#                            AT&T Research                             #\n#                           Florham Park NJ                            #\n#                                                                      #\n#                    David Korn <dgkorn@gmail.com>                     #\n#                                                                      #\n########################################################################\n\n# Some platforms have an extremely large default value for the number of open files. For example,\n# FreeBSD 11.1 has a default of 44685. This test fails with such a large value. Every other platform\n# has a limit an order of magnitude smaller. So limit the allowable values to something more\n# reasonable.\n#\n# TBD is why such a large default limit causes the test to fail.\nulimit -n 512\n\nz=()\nz.foo=( [one]=hello [two]=(x=3 y=4) [three]=hi)\nz.bar[0]=hello\nz.bar[2]=world\nz.bar[1]=(x=4 y=5)\nval='(\n\ttypeset -a bar=(\n\t\t[0]=hello\n\t\t[2]=world\n\t\t[1]=(\n\t\t\tx=4\n\t\t\ty=5\n\t\t)\n\t)\n\ttypeset -A foo=(\n\t\t[one]=hello\n\t\t[three]=hi\n\t\t[two]=(\n\t\t\tx=3\n\t\t\ty=4\n\t\t)\n\t)\n)'\n\n[[ $z == \"$val\" ]] || log_error 'compound variable with mixed arrays not working'\nz.bar[1]=yesyes\n[[ ${z.bar[1]} == yesyes ]] || log_error 'reassign of index array compound variable fails'\nz.bar[1]=(x=12 y=5)\n[[ ${z.bar[1]} == $'(\\n\\tx=12\\n\\ty=5\\n)' ]] || log_error 'reassign array simple to compound variable fails'\neval val=\"$z\"\n(\n    z.foo[three]=good\n    [[ ${z.foo[three]} == good ]] || log_error 'associative array assignment in subshell not working'\n)\n[[ $z == \"$val\" ]] || log_error 'compound variable changes after associative array assignment'\neval val=\"$z\"\n(\n    z.foo[two]=ok\n    [[ ${z.foo[two]} == ok ]] || log_error 'associative array assignment to compound variable in subshell not working'\n    z.bar[1]=yes\n    [[ ${z.bar[1]} == yes ]] || log_error 'index array assignment to compound variable in subshell not working'\n)\n[[ $z == \"$val\" ]] || log_error 'compound variable changes after associative array assignment'\n\nx=(\n    foo=( qqq=abc rrr=def)\n    bar=( zzz=no rst=fed)\n)\neval val=\"$x\"\n(\n    unset x.foo\n    [[ ${x.foo.qqq} ]] && log_error 'x.foo.qqq should be unset'\n    x.foo=good\n    [[ ${x.foo} == good ]] || log_error 'x.foo should be good'\n)\n[[ $x == \"$val\" ]] || log_error 'compound variable changes after unset leaves'\nunset l\n(\n    l=( a=1 b=\"BE\" )\n)\n[[ ${l+foo} != foo ]] || log_error 'l should be unset'\n\nTEST_notfound=notfound\nwhile whence $TEST_notfound >/dev/null 2>&1\ndo\n    TEST_notfound=notfound-$RANDOM\ndone\n\n\ninteger BS=1024 nb=64 ss=60 bs no\nfor bs in $BS 1\ndo\n    $SHELL -c '\n        {\n            sleep '$ss'\n            kill -KILL $$\n        } &\n        set -- $(printf %.'$(($BS*$nb))'c x | dd bs='$bs')\n        print ${#1}\n        kill $!\n    ' > $TEST_DIR/sub 2>/dev/null\n    no=$(<$TEST_DIR/sub)\n    (( no == (BS * nb) )) || log_error \"shell hangs on command substitution output size >= $BS*$nb with write size $bs -- expected $((BS*nb)), got ${no:-0}\"\ndone\n\n# This time with redirection on the trailing command\nfor bs in $BS 1\ndo\n    $SHELL -c '\n        {\n            sleep 2\n            sleep '$ss'\n            kill -KILL $$\n        } &\n        set -- $(printf %.'$(($BS*$nb))'c x | dd bs='$bs' 2>/dev/null)\n        print ${#1}\n        kill $!\n    ' > $TEST_DIR/sub 2>/dev/null\n    no=$(<$TEST_DIR/sub)\n    (( no == (BS * nb) )) || log_error \"shell hangs on command substitution output size >= $BS*$nb with write size $bs and trailing redirection -- expected $((BS*nb)), got ${no:-0}\"\ndone\n\n# exercise command substitutuion trailing newline logic w.r.t. pipe vs. tmp file io\n\nset -- \\\n    'post-line print'                                \\\n    '$TEST_unset; ($TEST_fork; print 1); print'                    \\\n    1                                        \\\n    'pre-line print'                                \\\n    '$TEST_unset; ($TEST_fork; print); print 1'                    \\\n    $'\\n1'                                        \\\n    'multiple pre-line print'                            \\\n    '$TEST_unset; ($TEST_fork; print); print; ($TEST_fork; print 1); print'        \\\n    $'\\n\\n1'                                    \\\n    'multiple post-line print'                            \\\n    '$TEST_unset; ($TEST_fork; print 1); print; ($TEST_fork; print); print'        \\\n    1                                        \\\n    'intermediate print'                                \\\n    '$TEST_unset; ($TEST_fork; print 1); print; ($TEST_fork; print 2); print'    \\\n    $'1\\n\\n2'                                    \\\n    'simple variable'                                \\\n    '$TEST_unset; ($TEST_fork; l=2; print \"$l\"); print $l'                \\\n    2                                        \\\n    'compound variable'                                \\\n    '$TEST_unset; ($TEST_fork; l=(a=2 b=\"BE\"); print \"$l\"); print $l'        \\\n    $'(\\n\\ta=2\\n\\tb=BE\\n)'                                \\\n\nexport TEST_fork TEST_unset\n\nwhile (( $# >= 3 ))\ndo\n    txt=$1\n    cmd=$2\n    exp=$3\n    shift 3\n    for TEST_unset in '' 'unset var'\n    do\n        for TEST_fork in '' 'ulimit -c 0'\n        do\n            for TEST_shell in \"eval\" \"$SHELL -c\"\n            do\n                if ! got=$($TEST_shell \"$cmd\")\n                then\n                    log_error \"${TEST_shell/*-c/\\$SHELL -c} ${TEST_unset:+unset }${TEST_fork:+fork }$txt print failed\"\n                elif [[ \"$got\" != \"$exp\" ]]\n                then\n                    EXP=$(printf %q \"$exp\")\n                    GOT=$(printf %q \"$got\")\n                    log_error \"${TEST_shell/*-c/\\$SHELL -c} ${TEST_unset:+unset }${TEST_fork:+fork }$txt command substitution failed -- expected $EXP, got $GOT\"\n                fi\n            done\n        done\n    done\ndone\n\nr=$( ($SHELL -c '\n    {\n        sleep 32\n        kill -KILL $$\n    } &\n    for v in $(set | sed \"s/=.*//\")\n    do\n        command unset $v\n    done\n    typeset -Z5 I\n    for ((I = 0; I < 1024; I++))\n    do\n        eval A$I=1234567890\n    done\n    a=$(set 2>&1)\n    print ok\n    kill -KILL $!\n') 2>/dev/null)\n[[ $r == ok ]] || log_error \"large subshell command substitution hangs\"\n\nfor TEST_command in '' $TEST_notfound\ndo\n    for TEST_exec in '' 'exec'\n    do\n        for TEST_fork in '' 'ulimit -c 0;'\n        do\n        for TEST_redirect in '' '>/dev/null'\n            do\n                for TEST_substitute in '' ': $'\n                do\n\n                     TEST_test=\"$TEST_substitute($TEST_fork $TEST_exec $TEST_command $TEST_redirect 2>/dev/null)\"\n                    [[ $TEST_test == '('*([[:space:]])')' ]] && continue\n                    r=$($SHELL -c '\n                        {\n                            sleep 2\n                            kill -KILL $$\n                        } &\n                        '\"$TEST_test\"'\n                        kill $!\n                        print ok\n                        ')\n                    [[ $r == ok ]] || log_error \"shell hangs on $TEST_test\"\n                done\n            done\n        done\n    done\ndone\n\n$SHELL -c '( autoload xxxxx);print -n' ||  log_error 'autoloaded functions in subshells can cause failure'\nactual=$($SHELL  <<- ++EOF++\n\t(trap 'print bar' EXIT;print -n foo)\n\t++EOF++\n)\nexpect=foobar\n[[ $actual == $expect ]] ||\n    log_error 'trap on exit when last commands is subshell is not triggered' \"$expect\" \"$actual\"\n\nactual=$(\n    $SHELL  2>&1  <<- \\EOF\n\t\tfunction foo\n\t\t{\n\t\t\tx=$( $bin_date > /dev/null 2>&1 ;:)\n\t\t}\n\t\t# consume almost all fds to push the test to the fd limit #\n\t\tinteger max=$(ulimit --nofile)\n\t\t(( max -= 10 ))\n\t\tfor ((i=20; i < max; i++))\n\t\tdo\n\t\t\texec {i}>&1\n                done\n\t\tfor ((i=0; i < 20; i++))\n                do\n\t\t\ty=$(foo)\n\t\tdone\n\tEOF\n) || {\n    expect=''\n    log_error \"nested command substitution with redirections failed\" \"$expect\" \"$actual\"\n}\n\nexp=0\n$SHELL -c $'\n    function foobar\n    {\n        print \"hello world\"\n    }\n    [[ $(getopts \\'[+?X\\ffoobar\\fX]\\' v --man 2>&1) == *\"Xhello worldX\"* ]]\n    exit '$exp$'\n'\ngot=$?\n[[ $got == $exp ]] || log_error \"getopts --man runtime callout with nonzero exit terminates shell -- expected '$exp', got '$got'\"\nexp=ok\ngot=$($SHELL -c $'\n    function foobar\n    {\n        print \"hello world\"\n    }\n    [[ $(getopts \\'[+?X\\ffoobar\\fX]\\' v --man 2>&1) == *\"Xhello worldX\"* ]]\n    print '$exp$'\n')\n[[ $got == $exp ]] || log_error \"getopts --man runtime callout with nonzero exit terminates shell -- expected '$exp', got '$got'\"\n\n# command substitution variations #\nset -- \\\n    '$('            ')'        \\\n    '${ '            '; }'        \\\n    '$(ulimit -c 0; '    ')'        \\\n    '$( ('            ') )'        \\\n    '${ ('            '); }'        \\\n    '`'            '`'        \\\n    '`('            ')`'        \\\n    '`ulimit -c 0; '    '`'        \\\n    # end of table #\nexp=ok\ntestcase[1]='\n    if %sexpr \"NOMATCH\" : \".*Z\" >/dev/null%s\n    then\n        print error\n    else\n        print ok\n    fi\n\n    exit %s\n'\ntestcase[2]='\n    function bar\n    {\n        pipeout=%1$sprintf Ok | tr O o%2$s\n        print $pipeout\n        return 0\n    }\n    foo=%1$sbar%2$s || foo=\"exit status $?\"\n    print $foo\n    exit %3$s\n'\n\nwhile (( $# >= 2 ))\ndo\n    for ((TEST=1; TEST<=${#testcase[@]}; TEST++))\n    do\n        body=${testcase[TEST]}\n        for code in 0 2\n        do\n            got=${ printf \"$body\" \"$1\" \"$2\" \"$code\" | $SHELL 2>&1 }\n            status=$?\n            if (( status != code ))\n            then\n                log_error \"test $TEST '$1...$2 exit $code' failed -- exit status $status, expected $code\"\n            elif [[ $got != $exp ]]\n            then\n                log_error \"test $TEST '$1...$2 exit $code' failed -- got '$got', expected '$exp'\"\n            fi\n        done\n    done\n    shift 2\ndone\n\n# the next tests loop on all combinations of\n#    { SUB CAT INS TST APP } X { file-sizes }\n# where the file size starts at 1Ki and doubles up to and including 1Mi\n#\n# the tests and timeouts are done in async subshells to prevent\n# the test harness from hanging\n\nSUB=(\n    ( BEG='$( '    END=' )'    )\n    ( BEG='${ '    END='; }'    )\n)\nCAT=(  cat  $bin_cat  )\nINS=(  \"\"  \"builtin cat; \"  \"builtin -d cat $bin_cat; \"  \": > /dev/null; \"  )\nAPP=(  \"\"  \"; :\"  )\nTST=(\n    ( CMD='print foo | $cat'            EXP=3        )\n    ( CMD='$cat < $TEST_DIR/lin'                        )\n    ( CMD='cat $TEST_DIR/lin | $cat'                    )\n    ( CMD='read v < $TEST_DIR/buf; print $v'        LIM=4*1024    )\n    ( CMD='cat $TEST_DIR/buf | read v; print $v'        LIM=4*1024    )\n)\n\n# Prime the two data files to 512 bytes each\n# $TEST_DIR/lin has newlines every 16 bytes and $TEST_DIR/buf has no newlines\n# the outer loop doubles the file size at top\n\nbuf=$'1234567890abcdef'\nlin=$'\\n1234567890abcde'\nfor ((i=0; i<5; i++))\ndo\n    buf=$buf$buf\n    lin=$lin$lin\ndone\n\nprint -n \"$buf\" > $TEST_DIR/buf\nprint -n \"$lin\" > $TEST_DIR/lin\n\nunset SKIP\nfor ((n=1024; n<=1024*1024; n*=2))\ndo\n    cat $TEST_DIR/buf $TEST_DIR/buf > $TEST_DIR/tmp\n    mv $TEST_DIR/tmp $TEST_DIR/buf\n    cat $TEST_DIR/lin $TEST_DIR/lin > $TEST_DIR/tmp\n    mv $TEST_DIR/tmp $TEST_DIR/lin\n    for ((S=0; S<${#SUB[@]}; S++))\n    do\n        for ((C=0; C<${#CAT[@]}; C++))\n        do\n            cat=${CAT[C]}\n            for ((I=0; I<${#INS[@]}; I++))\n            do\n            for ((A=0; A<${#APP[@]}; A++))\n                do\n                for ((T=0; T<${#TST[@]}; T++))\n                    do\n                    #undent...#\n                    if [[ ! ${SKIP[S][C][I][A][T]} ]]\n                    then\n                        eval \"{ x=${SUB[S].BEG}${INS[I]}${TST[T].CMD}${APP[A]}${SUB[S].END}; print \\${#x}; } >\\$TEST_DIR/out &\"\n                        m=$!\n                        { sleep 4; kill -9 $m; } &\n                        k=$!\n                        wait $m\n                        h=$?\n                        kill -9 $k\n                        # Suppress messages like this from the test log:\n                        # /tmp/ksh.subshell.7fgw2W8/subshell.sh[475]: wait: 8737: Killed\n                        wait $k 2> /dev/null\n                        got=$(<$TEST_DIR/out)\n                        if [[ ! $got ]] && (( h ))\n                        then\n                            got=HUNG\n                        fi\n\n                        if [[ ${TST[T].EXP} ]]\n                        then\n                            exp=${TST[T].EXP}\n                        else\n                            exp=$n\n                        fi\n\n                        if [[ $got != $exp ]]\n                        then\n                            # on failure skip similar tests on larger files sizes #\n                            SKIP[S][C][I][A][T]=1\n                            siz=$(printf $'%#i' $exp)\n                            cmd=${TST[T].CMD//\\$cat/$cat}\n                            cmd=${cmd//\\$TEST_DIR\\/buf/$siz.buf}\n                            cmd=${cmd//\\$TEST_DIR\\/lin/$siz.lin}\n                            log_error \"'x=${SUB[S].BEG}${INS[I]}${cmd}${APP[A]}${SUB[S].END} && print \\${#x}' failed -- expected '$exp', got '$got'\"\n                        elif [[ ${TST[T].EXP} ]] || (( TST[T].LIM >= n ))\n                        then\n                            SKIP[S][C][I][A][T]=1\n                        fi\n\n                    fi\n                    #...indent#\n                    done\n                done\n            done\n        done\n    done\ndone\n\n# specifics -- there's more?\n\n{\n    cmd='{ exec 5>/dev/null; print \"$(eval ls -d . 2>&1 1>&5)\"; } >$TEST_DIR/out &'\n    eval $cmd\n    m=$!\n    { sleep 4; kill -9 $m; } &\n    k=$!\n    wait $m\n    h=$?\n    kill -9 $k\n    wait $k\n    got=$(<$TEST_DIR/out)\n} 2>/dev/null\nexp=''\nif [[ ! $got ]] && (( h ))\nthen\n    got=HUNG\nfi\n\nif [[ $got != $exp ]]\nthen\n    log_error \"eval '$cmd' failed -- expected '$exp', got '$got'\"\nfi\n\nfloat t1=$SECONDS\n  $SHELL -c \"( $bin_sleep 5 </dev/null >/dev/null 2>&1 & ); exit 0\" | cat\n  (( (SECONDS-t1) > 4 )) && log_error '/bin/sleep& in subshell hanging'\n  ((t1=SECONDS))\n\n$SHELL -c '( sleep 5 </dev/null >/dev/null 2>&1 & );exit 0' | cat\n(( (SECONDS-t1) > 4 )) && log_error 'sleep& in subshell hanging'\n\nexp=HOME=$HOME\n( HOME=/bin/sh )\ngot=$(env | grep ^HOME=)\n[[ $got == \"$exp\" ]] ||  log_error \"( HOME=/bin/sh ) cleanup failed -- expected '$exp', got '$got'\"\n\ncmd='echo $((case x in x)echo ok;esac);:)'\nexp=ok\ngot=$($SHELL -c \"$cmd\" 2>&1)\n[[ $got == \"$exp\" ]] ||  log_error \"'$cmd' failed -- expected '$exp', got '$got'\"\n\ncmd='eval \"for i in 1 2; do eval /bin/echo x; done\"'\nexp=$'x\\nx'\ngot=$($SHELL -c \"$cmd\")\nif [[ $got != \"$exp\" ]]\nthen\n    EXP=$(printf %q \"$exp\")\n    GOT=$(printf %q \"$got\")\n    log_error \"'$cmd' failed -- expected $EXP, got $GOT\"\nfi\n\n(\n$SHELL -c 'sleep 20 & pid=$!; { x=$( ( seq 60000 ) );kill -9 $pid;}&;wait $pid'\n) 2> /dev/null\n(( $? )) ||  log_error 'nested command substitution with large output hangs'\n\n(.sh.foo=foobar)\n[[ ${.sh.foo} == foobar ]] && log_error '.sh subvariables in subshells remain set'\n[[ $($SHELL -c 'print 1 | : \"$(/bin/cat <(/bin/cat))\"') ]] && log_error 'process substitution not working correctly in subshells'\n\n# config hang bug\ninteger i\nfor ((i=1; i < 1000; i++))\ndo\n    typeset foo$i=$i\ndone\n{\n    : $( (ac_space=' '; set | grep ac_space) 2>&1)\n} < /dev/null | cat > /dev/null &\nsleep  1.5\nif kill -KILL $! 2> /dev/null\nthen\n    log_error 'process timed out with hung comsub'\nfi\n\nwait $! 2> /dev/null\n(( $? > 128 )) && log_error 'incorrect exit status with comsub'\n\n$SHELL 2> /dev/null -c '[[ ${ print foo },${ print bar } == foo,bar ]]' || log_error  '${ print foo },${ print bar } not working'\n$SHELL 2> /dev/null -c '[[ ${ print foo; },${ print bar } == foo,bar ]]' || log_error  '${ print foo; },${ print bar } not working'\n\nsrc=$'true 2>&1\\n: $(true | true)\\n: $(true | true)\\n: $(true | true)\\n'$bin_true\nexp=ok\ngot=$( $SHELL -c \"(eval '$src'); echo $exp\" )\n[[ $got == \"$exp\" ]] || log_error 'subshell eval of pipeline clobbers stdout'\n\nx=$( { time $SHELL -c date >| /dev/null;} 2>&1)\n[[ $x == *real*user*sys* ]] || log_error 'time { ...;} 2>&1 in $(...) fails'\n\nx=$($SHELL -c '( function fx { export X=123;  } ; fx; ); echo $X')\n[[ $x == 123 ]] && log_error 'global variables set from with functions inside a\nsubshell can leave side effects in parent shell'\n\nerr() { return $1; }\n( err 12 ) & pid=$!\n: $($bin_date)\nwait $pid\nactual=$?\nexpect=12\n[[ $actual -eq $expect ]] ||\n    log_error 'exit status from subshells not being preserved' \"$expect\" \"$actual\"\n\nactual=\"$(sed 's/^/Hello /' <(print \"Fred\" | sort))\"\nexpect=\"Hello Fred\"\n[[ $actual == $expect ]] ||\n    log_error  \"process subst of pipeline in cmd subst not working\" \"$expect\" \"$actual\"\n\n{\n$SHELL <<- \\EOF\n\tfunction foo\n\t{\n\t\tinteger i\n\t\tprint -u2 foobar\n\t\tfor    ((i=0; i < 8000; i++))\n\t\tdo\n\t\t\tprint abcdefghijk\n\t\tdone\n\t\tprint -u2 done\n\t}\n\tout=$(eval \"foo | cat\" 2>&1)\n\t(( ${#out} == 96011 )) || log_error \"\\${#out} is ${#out} should be 96011\"\nEOF\n} & pid=$!\n$SHELL -c \"{ sleep 4 && kill $pid ;}\" 2> /dev/null\n(( $? == 0 )) &&  log_error 'process has hung'\n\n{\nx=$( $SHELL  <<- \\EOF\n\tfunction func1 { typeset IFS; : $(func2); print END ;}\n\tfunction func2 { IFS=\"BAR\"; }\n\tfunc1\n\tfunc1\nEOF\n)\n} 2> /dev/null\n[[ $x == $'END\\nEND' ]] || log_error 'bug in save/restore of IFS in subshell'\n\ntmpf=$TEST_DIR/foo\nfunction fun1\n{\n    $bin_true\n    cd - >/dev/null 2>&1\n    print -u2 -- \"$($bin_date) SUCCESS\"\n}\n\nprint -n $(fun1 2> $tmpf)\n[[  $(< $tmpf) == *SUCCESS ]] || log_error 'standard error output lost with command substitution'\n\n\ncat > foo <<-\\EOF\n\t$SHELL -c 'function g { IFS= ;};function f { typeset IFS;(g);: $V;};f;f'\n\tEOF\n$SHELL 2> /dev/null foo || log_error 'IFS in subshell causes core dump'\n\nunset i\nif   [[ -d /dev/fd ]]\nthen\n        integer i\n        for ((i=11; i < 29; i++))\n        do\n            if ! [[ -r /dev/fd/$i  || -w /dev/fd/$i ]]\n            then\n                a=$($SHELL -c \"[[ -r /dev/fd/$i || -w /dev/fd/$i ]]\")\n                (( $? )) || log_error \"file descriptor $i not close on exec\"\n            fi\n        done\nfi\n\ntrap USR1 USR1\ntrap ERR ERR\n[[ $(trap -p USR1) == USR1 ]] || log_error 'trap -p USR1 in subshell not working'\n[[ $(trap -p ERR) == ERR ]] || log_error 'trap -p ERR in subshell not working'\n[[ $(trap -p) == *USR* ]] || log_error 'trap -p in subshell does not contain USR'\n[[ $(trap -p) == *ERR* ]] || log_error 'trap -p in subshell does not contain ERR'\ntrap - USR1 ERR\n\n( PATH=/bin:/usr/bin\ndot=$(cat <<-EOF\n\t$(ls -d .)\n\tEOF\n) ) & sleep 1\n\nif kill -0 $! 2> /dev/null\nthen\n    log_error  'command substitution containg here-doc with command substitution fails'\nfi\n\n[[ $( { trap \"echo foobar\" EXIT; ( $bin_printf \"\"); } & wait) == foobar ]] || \\\n    log_error  'exit trap not being invoked'\n\n$SHELL 2> /dev/null -c '( PATH=/bin; set -o restricted) ; exit 0'  || \\\n    log_error 'restoring PATH when a subshell enables restricted exits not working'\n\n$SHELL <<- \\EOF\n\tprint > /dev/null  $( ( head -c 1 /dev/zero | (wc -c) 3>&1 ) 3>&1) &\n\tpid=$!\n\tsleep 2\n\tkill -9 $! 2> /dev/null && log_error '/dev/zero in command substitution hangs'\n\twait $!\nEOF\n\nfor f in /dev/stdout /dev/fd/1\ndo\n    if [[ -e $f ]]\n    then\n        $SHELL -c \"x=\\$(command -p tee $f </dev/null 2>/dev/null)\" || log_error \"$f in command substitution fails\"\n    fi\ndone\n\n$SHELL > /dev/null -c 'echo $(for x in whatever; do case y in *) true;; esac; done)' || log_error 'syntax error with case in command substitution'\n\n$SHELL 2> /dev/null <<- \\EOF || log_error 'cannot run 100000 subshells'\n\t( for ((i=0; i < 100000; i++))\n\tdo\n\t\t(b=$(printf %08d ${i}))\n\tdone )\nEOF\n\nprint 'print OK'  | out=$(${SHELL})\n[[ $out == OK ]] || log_error '$() command substitution not waiting for process completion'\n\nprint 'print OK' | out=$( ${SHELL} 2>&1 )\nout2=\"${out}$?\"\n[[ \"$out2\" == 'OK0' ]]  ||  log_error -u2 \"expected OK0 got $out2\"\n\nfun()\n{\n    foo=` $bin_echo foo`\n    print -n stdout=$foo\n    print -u2 stderr=$foo\n}\n[[ `fun 2>&1` == 'stdout=foostderr=foo' ]] || log_error 'nested command substitution with 2>&1 not working'\n\nmkdir $TEST_DIR/bin$$\nprint 'print foo' > $TEST_DIR/bin$$/foo\nchmod +x  $TEST_DIR/bin$$/foo\n: $(type foo 2> type.foo.out)\nactual=$(< type.foo.out)\nactual=${actual#*: }  # remove the script name and line number prefix\nexpect='whence: foo: not found'\n[[ $actual == $expect ]] || log_error \"command foo should not have been found\" \"$expect\" \"$actual\"\n: ${ PATH=$TEST_DIR/bin$$:$PATH;}\nactual=$(whence foo 2> /dev/null)\nexpect=\"$TEST_DIR/bin$$/foo\"\n[[ $actual == $expect ]] ||\n    log_error '${...PATH=...} does not preserve PATH bindings' \"$expect\" \"$actual\"\n\n> $TEST_DIR/log\nfunction A\n{\n    trap 'print TRAP A >> $TEST_DIR/log' EXIT\n    print >&2\n}\nfunction B\n{\n    trap 'print TRAP B >> $TEST_DIR/log' EXIT\n    A\n}\nx=${ ( B ) ; }\n[[ $(<$TEST_DIR/log) ==  *'TRAP A'*'TRAP B'* ]] || log_error 'trap A and trap B not both executed'\n\nfunction foo\n{\n    .sh.value=bam\n}\nval=${ foo;}\n[[ $val ]] && log_error \"function foo generates $val but should generate the empty string in command substitution\"\n\nx=$(\n    for i in a b c\n    do\n    read A\n        print -n \"$A\"\n        STDERR=$(</dev/null)\n    done <<< $'y\\ny\\ny\\n'\n)\n[[ $x == yyy ]] || log_error '$(</dev/null) in a subshell causes failure'\n\n\n$SHELL -c 'while((SECONDS<3)); do test -z `/bin/false | /bin/false | /bin/doesnotexist`;done;:' 2> /dev/null || log_error 'non-existant last command in pipeline causes `` to fail'\n\nx=$({ sleep .1;false;} | true)\n[[ $? != 0 ]] && log_error 'without pipefail, non-zero exit in pipeline causes command substitution to fail'\n\nfoo() {\n  print -r foo | read\n  return 1\n}\no1=$(foo \"foo\") && log_error 'function which fails inside commad substitution should return non-zero exit status for assignments'\n\n# test for larg `` command substitutions\ntmpscr=$TEST_DIR/xxx.sh\nprint 'x=` print -n '\"'\" > $tmpscr\ninteger i\nfor ((i=0; i < 4000; i++))\ndo\n    print xxxxxxxxxxyyyyyyyyyyzzzzzzzzzzaaaaaaaaaabbbbbbbbbbcccccccccc\ndone >>  $tmpscr\nprint  \"'\"'`' >> $tmpscr\n(( size= $(wc -c < $tmpscr) -18 ))\n$SHELL  \"$tmpscr\" &\ncop=$!\n{ sleep 2; kill $cop; } 2>/dev/null &\nspy=$!\nif   wait $cop 2>/dev/null\nthen\n    kill $spy 2>/dev/null\nelse    log_error -u2 \"\\`...\\` hangs for large with output size $size\"\nfi\n\nif [[ -e /dev/zero ]]\nthen\n    (( size = 117*1024 ))\n    $SHELL -c 'x=`(dd if=/dev/zero bs=1k count=117 2>/dev/null)`' &\n    cop=$!\n    { sleep 2; kill $cop; } 2>/dev/null &\n    spy=$!\n    if wait $cop 2>/dev/null\n    then\n        kill $spy 2>/dev/null\n    else\n        log_error -u2 \"\\`(...)\\` hangs for large with output size $size\"\n    fi\nfi\n\n# ========================================\n# Test that variables exported in subshells don't affect the outer shell.\n# Regression test for issue #7.\nfunction proxy {\n    export MYVAR=\"blah\"\n    child\n    unset MYVAR\n}\n\nfunction child {\n    echo \"MYVAR=$MYVAR\"\n}\n\nfunction test {\n        child\n        proxy\n        child\n}\n\nactual=\"$(test)\"\nexpected=\"\\\nMYVAR=\nMYVAR=blah\nMYVAR=\"\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"exported vars in subshells not confined to the subshell: $actual\"\nfi\n\n\n# ========================================\n# Test that closing file descriptors don't affect capturing the output of a\n# subshell. Regression test for issue #198.\nexpected='return value'\n\nfunction get_value {\n    case=$1\n    (( case >= 1 )) && exec 3< foo\n    (( case >= 2 )) && exec 4< foo\n    (( case >= 3 )) && exec 6< foo\n\n    # To trigger the bug we have to spawn an external command. Why is a\n    # mystery but not really relevant.\n    $bin_true\n\n    (( case >= 1 )) && exec 3<&-\n    (( case >= 2 )) && exec 4<&-\n    (( case >= 3 )) && exec 6<&-\n\n    print $expected\n}\n\nactual=$(get_value 0)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 0\"\nfi\n\nactual=$(get_value 1)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 1\"\nfi\n\nactual=$(get_value 2)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 2\"\nfi\n\nactual=$(get_value 3)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 3\"\nfi\n\nbuiltin -d echo\n# Check if redirections work if backticks are nested inside $()\nfoo=$(print `echo bar`)\n[[ $foo == \"bar\" ]] || log_error 'Redirections do not work if backticks are nested inside $()'\n\n# Buffer boundary tests\nfor exp in 65535 65536\ndo    got=$($SHELL -c 'x=$(printf \"%.*c\" '$exp' x); print ${#x}' 2>&1)\n    [[ $got == $exp ]] || log_error \"large command substitution failed\" \"$exp\" \"$got\"\ndone\n"], "fixing_code": ["# ksh 2020.1.0 (this is a work in progress)\n\n## Deprecations\n\n## Notable non-backward compatible changes\n\n- You can no longer use arbitrary expressions in imported numeric env vars;\n  only integer literals are allowed.\n- The `login` and `newgrp` special builtins have been removed. Use\n  `exec login` and `exec newgrp` instead (#1348).\n\n## Notable fixes and improvements\n\n- Fix `history` command behavior when the *~/.sh_history* file has\n  specific content (issue #1432).\n- A ${.sh.install_prefix}/config.ksh file will be sourced if it exists. It is\n  the first config file loaded by every ksh instance. It is loaded regardless\n  of whether the shell is interactive, login, or neither.\n- A .sh.install_prefix var has been introduced to reflect the `meson -prefix=`\n  value. This will be used to establish the location of supporting files such\n  as man pages and autoloaded functions.\n\n## Other significant changes\n\n# ksh 2020.0.0\n\nThis documents changes since the AST code, which includes the `ksh` program,\nwas moved to Github. That is, the ksh93u+ source. The next stable version will\nbe treated as a major release for several reasons. Not least of which is\nchanging the build tool chain from the legacy Nmake system to Meson and\nreplacing the AST Vmalloc subsystem with the platform Malloc subsystem. Legacy\nchanges can be found in the various `RELEASE` files.\n\nStarting in June 2017 maintenance of the Korn shell (`ksh`) resumed with\nthe merging of some fixes from Red Hat by Siteshwar Vashisht after he was\ngranted commit privilege. In October 2017 Kurtis Rader noticed that `ksh`\nhad been open sourced and started contributing changes. This document\nwas subsequently created to document the work being done.\n\n## Deprecations\n\n- Some libc/libm math functions not suitable for use by a ksh script (e.g.,\n  `j0()`) will likely be removed in the near future (issue #1346 and #88).\n\n## Notable non-backward compatible changes\n\n- The nonportable, unusable, `fpclassify` math function has been removed\n  (issue #1346).\n- The broken math functions `nextforward` and `nexttoward` have been removed\n  (issue #1346).\n- Support for binary plugins written for ksh93u+ or earlier releases has been\n  dropped (issue #983).\n- Support for coshell has been removed (issue #619).\n- The `universe` command has been removed (issue #793).\n- The `getconf` command has been removed (issue #1118).\n- Support for building on systems using EBCDIC has been removed (issue #742).\n- Support for the `LC_OPTIONS` env var has been removed (issue #579).\n- `case \"[0-9]\" in [0-9]) echo match;; esac` has stopped matching. When a case\n  statement doesn't match a pattern, it no longer tries to use the pattern as\n  a literal string (issue #476).\n- echo builtin now interprets escape sequences and parses command line options\n  on all platforms. (issue #370)\n- Support for the UWIN environment has been removed (issue #284).\n- The experimental `SHOPT_FIXEDARRAY` feature has been removed. It is known to\n  have been enabled in some Fedora and RHEL builds. But because it was\n  experimental and undocumented this should not break any existing users of\n  `ksh` built with this feature enabled. (issue #234)\n- <> operator now redirects standard input by default (issue #75).\n- Support for the build time SHOPT_ACCTFILE symbol and code has been removed\n  (issue #210).\n- Versioning scheme has been changed to use semantic version numbers (issue #335).\n- Undocumented and broken `alarm` builtin has been removed (issue #646).\n\n## Notable fixes and improvements\n\n- `declare` has been added as an alias for `typeset` (issue #220).\n- `local` has been added as a constrained alias for `typeset` when used inside\n  a function (issue #220).\n- Mention of the `getconf` builtin has been removed from the main ksh man\n  page. That command has never been enabled by default and is now deprecated\n  in favor of the platform command of the same name (issue #1118).\n- The `test` command no longer silently fails all uses of the `=~` operator.\n  Instead an error is printed suggesting the use of `[[...]]` (issue #1152).\n- Doing `[ -t1 ]` inside a command substitution behaves correctly\n  (issue #1079).\n- The project now passes its unit tests when built with malloc debugging\n  enabled (i.e., `meson test --setup=malloc`) or with ASAN enabled.\n- Changes to the project are now validated by running unit tests on the Travis\n  continuous integration system.\n- The ksh source now builds on BSD based systems such as macOS and FreeBSD.\n- The ksh source now builds on Cygwin; albeit with many unit test failures.\n- The legacy Nmake build system has been replaced by Meson. This improves the\n  build time by roughly an order of magnitude (issue #42).\n- The `times` command is now a builtin that conforms to POSIX rather than an\n  alias for the `time` command (issue #16).\n- The `time` command now has millisecond resolution if the platform provides\n  `getrusage()` and its time values have millisecond or better resolution.\n\n## Other significant changes\n\n- Using a bare tilde (e.g., `cd ~`) now works correctly if `$HOME` is not set\n  (issue #1391).\n- You can no longer run an external command with stdin, stdout, or stderr\n  closed. If you attempt to do so (e.g., `a_cmd <&-`) it will be opened on\n  /dev/null in the child process (issue #1117).\n- Vi raw mode is now the default and cannot be disabled. Note that this was\n  true at least as far back as ksh93u+. The difference is that now it's no\n  longer even theoretically possible to even build with that feature disabled.\n  (issue #864).\n- The AST locale subsystem has been replaced by the platform's implementation\n  (issue #579).\n- The AST Vmalloc subsystem has been removed. The project now uses the system\n  malloc. (issue #396)\n- Operations that depend on the simulated 3DFS behavior found in release\n  ksh93v are no longer supported. That behavior does not work in ksh93u (the\n  most recent stable release found in all distros) unless the 3D file system\n  is actually present. This includes operations such as this:\n  `exec {fd}</dev; cd ~{fd}` (issue #510).\n- The math `scalb` function has been removed since it was marked obsolete by\n  POSIX in 2001 and is no longer found in some libc implementations.\n- Code hidden behind the SHOPT_ACCT and SHOPT_ACCTFILE build time symbols\n  has been removed. The features are not enabled by default and I am not aware\n  of any distro which enables them. Furthermore, they are huge security holes\n  and should never be enabled.\n- The suid_exec program has been removed (issue #366).\n- The code has been restyled according to new guidelines (issue #125).\n- Many features which used to be optionally included at build time are now\n  unconditionally included (e.g., the code protected by `SHOPT_MULTIBYTE`,\n  `SHOPT_COMPLETE`, `SHOPT_BRACEPAT`, `SHOPT_RAWONLY`, `SHOPT_STATS,\n  `SHOPT_OPTIMIZE`, `SHOPT_SUID_EXEC`, `SHOPT_FILESCAN`, `SHOPT_POLL,\n  `SHOPT_AUDIT`, and `SHOPT_SYSRC`).\n- Unit tests can now be run under Valgrind and ASAN to help detect more bugs.\n- Any code not needed to build and run `ksh` has been removed from the master\n  branch.\n- Fixes backported from OpenSuse (issue #377).\n- Fixes backported from Red Hat Fedora and Enterprise Linux (RHEL) distros\n  (issue #172).\n- Fixes backported from Solaris (issue #122).\n\n## Other significant changes taken from ksh93v-:\n\nLast stable release was `ksh93u+`. ksh x.y.z is based on `ksh93v-` which was last beta\nrelease that came out from AT&T Bell Labs. It had number of notable changes that are\nlisted below. Entries are directly taken from `src/cmd/ksh93/RELEASE` file (with minor\nspelling fixes):\n\n- 14-12-02  The requirement that unquoted { and } must match inside string with\n\t  ${name op string} has been removed (at least for now).\n- 14-09-24 +When listing jobs, the shell now shows the directory that the job\n\t  was started from when it was not started from the current working\n\t  directory.\n- 14-07-11 +Added -t flag and -P flag to whence and type for bash compatibility.\n- 14-07-11 +Added -p flag to alias to output aliases for re-input.\n- 14-06-30 +The variable COMP_WORDBREAKS for programmable completion.\n- 14-06-25 +The -D and -E options have been added to the complete builtin.\n- 14-06-19 +The -l flag to trap and the -p flag to umask were added as in bash.\n- 14-06-16 +Added parameter expansion operator ${$parameter} for variables and\n\t  positional parameters.\n- 14-06-06  Added -a option to read which is equivalent to -A.\n- 14-06-05 +Added -n option to builtin to disable builtins.\n- 14-05-25 +Replaced the -p option for read with -p prompt.  For backward\n\t  compatibility, if a coprocess is running and prompt begins with -\n\t  or is a valid variable name, -p causes the read from a pipe.\n- 14-05-25 +Modified the -u option for read and print so that it accepts the\n\t  option argument p to indicate the coprocess file descriptor.\n- 14-01-10  [[...]] now supports hexadecimal constants with arithmetic operators.\n- 13-12-05  If cd is invoked with no arguments and HOME is unset, it attempts to\n\t  find the home directory and use that.  Otherwise an error occurs.\n- 13-11-14 +Added -f fd option to pwd to display the directory corresponding to\n\t  file descriptor fd.\n- 13-10-08  The shell arithmetic now recognized suffices f,F, l, and L for\n\t  floating point constants.\n- 13-10-07  The shell now prints an error message on standard error when a\n\t  job specified with %job does not exist.\n- 13-09-13 +The signal .sh.value variable is now a compound variable with the name\n\t  value.q for sending a signal with -q and value.Q for sending a value\n\t  with -Q.\n- 13-09-10 +A -Q option was added to kill to pass integers as large as pointers.\n\t  The -q option now only accepts integers as large as typeset -i.\n- 13-09-09  Qualified print format \"%([no]unicode)q\" added to prefer \\u[...]\n\t  over \\w[...] and override LC_OPTIONS=unicode.\n- 13-09-04 +\\w[hex] locale-specific code point literals have been added.\n- 13-09-04 +The float(f) math function was added.\n- 13-09-04  kill -q can now pass numbers as large as typeset -li and\n\t  .sh.sig.value is typeset -i rather than a compound variable.\n- 13-09-04  kill -q yields the processor and returns 2 when siqueue fails with\n\t  EAGAIN and yield.\n- 13-08-26 +Added 12 math constants such as E, PI, and SQRT2.\n- 13-08-19 +The variable .sh.pwdfd which expands to the file descriptor number\n\t  corresponding to $PWD has been added.\n- 13-08-11 +namespace was modified so that namespace names can be a compound\n\t  variable rather than just an identifier and namespace are no\n\t  longer nested.\n- 13-08-07  typeset -p (and print -v) now display the short attribute for\n\t  typeset -sF and typeset -sE.\n- 13-08-06 +You can now use the redirection <& {n} which is the same as <& $n.\n- 13-07-24  The _ variable is now set as a reference to the type inside\n\t  discipline functions for non-type variables in the type.\n- 13-07-22  The .sh.sig variable has been modified to treat .sh.value as a\n\t  compound variable containing int and ptr.\n- 13-07-18  Assignments of the type name=(...) to array variables now preserve\n\t  the array type and the variable type if any.\n- 13-07-18  If a PATH ends in ., and you are in the current directory and this\n\t  directory is in FPATH, ksh now treats this as a function directory.\n- 13-07-17  ${!.sh.sig@]} now expands to all the .sh.sig. variables.\n- 13-07-08  When using kill -q to send a signal, a CONT signal is not sent to\n\t  wake the process if it is sleeping after sending the signal.\n- 13-06-21  A -f nn option has been added to cd to change to a directory\n\t  relative to a file descriptor of an open directory.  cd -f nn\n\t  is equivalent to cd ~{nn}.\n- 13-06-06  In accordance with the standard set -u now causes failures for\n\t  unset positional parameters.\n- 13-05-29  ksh93 now intercepts the `LC_TIME` variable.\n- 13-05-29  namespace commands are no longer allowed inside function definitions\n\t  and now generate a syntax error.\n- 13-05-10  With print -v for with nested compound variables, the output contains\n\t  typeset -C for sub-variables that are compound assignments.\n- 13-05-08  Added a ksh -n options that suggests that x=$((expr)) be replaced by\n\t  ((x=expr))>\n- 13-05-01 +Increased to maximum number of enumeration elements from 32K to\n\t  2G.\n- 13-04-25 +The -K option has been added to set to sort indexed arrays of\n\t  compound elements based on a list of keys.\n- 13-04-18  Added serialization to processing of CHLD traps.\n- 13-04-15  ksh now waits for background jobs started in functions contained\n\t  in command substitution.\n- 13-04-08 +ksh now sets .sh.sig.pid and .sh.sig.status for CHLD traps.  The\n\t  .sh.sig.status can be one of exited, killed, dumped, stopped or\n\t  continued.\n- 13-04-08 +The CHLD trap is now triggered with STOP and CONT signals.\n- 13-04-03 +Functions that are used in brace group command substitution ${ ... }\n\t  can assign the result to .sh.value instead of writing to standard\n\t  out with the same result, but faster.\n- 13-03-27 +The variable .sh.sig containing siginfo information is no set during\n\t  a SIGCHLD trap.\n- 13-03-12  Empty fields and empty arrays as type elements are not displayed\n\t  when expanding a type instance.\n- 13-03-11  The trap command now blocks signals that have traps until the\n\t  trap command completes.\n- 13-03-11  Signals that have traps that occur while processing a trap are\n\t  deferred until the trap command completes.\n- 13-02-08 +The -p option was added to enum to display the values that are\n\t  valid for the enum.\n- 13-02-07 +A preset alias named bool which is an alias for an enum\n\t  named `_Bool` which has values true and false has been added.\n- 13-02-24  Increased the maximum level of recursion for evaluating variables\n\t  inside arithmetic expressions from 9 to 1024.\n- 13-01-17 +User define math functions introduced on 10-03-24 now allow passing\n\t  arrays as arguments.\n- 13-01-10 +ksh now treats ESC-O-letter the same as ESC-[-letter in vi and emacs\n\t  edit modes.\n- 12-10-09 +read -d '' now reads up to a NUL byte.\n- 12-10-04  libcmd builtins are statically linked into ksh93 and by default are\n\t  bound to the path /opt/ast/bin whether this path exists or not.\n\t  Changing the .sh.op_astbin variable changes the binding.\n- 12-10-01 +Added the variable `SH_OPTIONS` which consists of name=value pairs.\n\t  For defined options it assigned value to the variable .sh.op_name.\n- 12-10-02 +Add the variable .sh.op_astbin to define the directory where several\n\t  shell builtins will be bound.\n- 12-09-10 +Added ~{fd} expansion where fd is the number of an open file or\n\t  a variable whose value is the number of an open file.\n- 12-08-30  For an associative array A, $((A[sub])) no longer cause subscript sub\n\t  to be created.\n- 12-08-20  typeset -H foo no longer un-sets foo when foo has been exported to\n\t  the shell.\n- 12-07-12 +Added -q option was added to kill to send queued signals on systems\n\t  that support sigqueue().\n- 12-07-12 +Added -p option to builtin to output builtins in a format that can\n\t  be used to re-input.\n- 12-07-02 +The -a option was added to trap to cause the current setting to be\n\t  appended to the new trap setting rather than replacing it.\n", "/***********************************************************************\n *                                                                      *\n *               This software is part of the ast package               *\n *          Copyright (c) 1982-2013 AT&T Intellectual Property          *\n *                      and is licensed under the                       *\n *                 Eclipse Public License, Version 1.0                  *\n *                    by AT&T Intellectual Property                     *\n *                                                                      *\n *                A copy of the License is available at                 *\n *          http://www.eclipse.org/org/documents/epl-v10.html           *\n *         (with md5 checksum b35adb5213ca9657e911e9befb180842)         *\n *                                                                      *\n *              Information and Software Systems Research               *\n *                            AT&T Research                             *\n *                           Florham Park NJ                            *\n *                                                                      *\n *                    David Korn <dgkorn@gmail.com>                     *\n *                                                                      *\n ***********************************************************************/\n//\n// Shell arithmetic - uses streval library\n//   David Korn\n//   AT&T Labs\n//\n#include \"config_ast.h\"  // IWYU pragma: keep\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"ast.h\"\n#include \"builtins.h\"\n#include \"cdt.h\"\n#include \"defs.h\"\n#include \"error.h\"\n#include \"lexstates.h\"\n#include \"name.h\"\n#include \"sfio.h\"\n#include \"shcmd.h\"\n#include \"stk.h\"\n#include \"streval.h\"\n#include \"variables.h\"\n\n#ifndef LLONG_MAX\n#define LLONG_MAX LONG_MAX\n#endif\n\ntypedef Sfdouble_t (*Math_f)(Sfdouble_t, ...);\n\nextern const Namdisc_t ENUM_disc;\nstatic bool Varsubscript;\nstatic Sfdouble_t NaN, Inf, Fun;\nstatic Namval_t Infnod = {.nvname = \"Inf\"};\nstatic Namval_t NaNnod = {.nvname = \"NaN\"};\nstatic Namval_t FunNode = {.nvname = \"?\"};\n\nstruct Mathconst {\n    char name[9];\n    Sfdouble_t value;\n};\n\n#ifndef M_1_PIl\n#define M_1_PIl 0.3183098861837906715377675267450287L\n#endif\n#ifndef M_2_PIl\n#define M_2_PIl 0.6366197723675813430755350534900574L\n#endif\n#ifndef M_2_SQRTPIl\n#define M_2_SQRTPIl 1.1283791670955125738961589031215452L\n#endif\n#ifndef M_El\n#define M_El 2.7182818284590452353602874713526625L\n#endif\n#ifndef M_LOG2El\n#define M_LOG2El 1.4426950408889634073599246810018921L\n#endif\n#ifndef M_LOG10El\n#define M_LOG10El 0.4342944819032518276511289189166051L\n#endif\n#ifndef M_LN2l\n#define M_LN2l 0.6931471805599453094172321214581766L\n#endif\n#ifndef M_LN10l\n#define M_LN10l 2.3025850929940456840179914546843642L\n#endif\n#ifndef M_PIl\n#define M_PIl 3.1415926535897932384626433832795029L\n#endif\n#ifndef M_PI_2l\n#define M_PI_2l 1.5707963267948966192313216916397514L\n#endif\n#ifndef M_PI_4l\n#define M_PI_4l 0.7853981633974483096156608458198757L\n#endif\n#ifndef M_SQRT2l\n#define M_SQRT2l 1.4142135623730950488016887242096981L\n#endif\n#ifndef M_SQRT1_2l\n#define M_SQRT1_2l 0.7071067811865475244008443621048490L\n#endif\n\n// The first three entries cann't be moved or it will break the code.\nstatic const struct Mathconst Mtable[] = {\n    {\"1_PI\", M_1_PIl}, {\"2_PI\", M_2_PIl},   {\"2_SQRTPI\", M_2_SQRTPIl},\n    {\"E\", M_El},       {\"LOG2E\", M_LOG2El}, {\"LOG10E\", M_LOG10El},\n    {\"LN2\", M_LN2l},   {\"PI\", M_PIl},       {\"PI_2\", M_PI_2l},\n    {\"PI_4\", M_PI_4l}, {\"SQRT2\", M_SQRT2l}, {\"SQRT1_2\", M_SQRT1_2l},\n    {\"\", 0.0}};\n\nstatic_fn Namval_t *scope(Namval_t *np, struct lval *lvalue, int assign) {\n    int flag = lvalue->flag;\n    char *sub = 0, *cp = (char *)np;\n    Namval_t *mp;\n    Shell_t *shp = lvalue->shp;\n    int c = 0, nosub = lvalue->nosub;\n    Dt_t *sdict = (shp->st.real_fun ? shp->st.real_fun->sdict : 0);\n    Dt_t *nsdict = (shp->namespace ? nv_dict(shp->namespace) : 0);\n    Dt_t *root = shp->var_tree;\n\n    nvflag_t nvflags = assign ? NV_ASSIGN : 0;\n    lvalue->nosub = 0;\n    if (nosub < 0 && lvalue->ovalue) return (Namval_t *)lvalue->ovalue;\n    lvalue->ovalue = NULL;\n    if (cp >= lvalue->expr && cp < lvalue->expr + lvalue->elen) {\n        int offset;\n        // Do binding to node now.\n        int d = cp[flag];\n        cp[flag] = 0;\n        np = nv_open(cp, root, nvflags | NV_VARNAME | NV_NOADD | NV_NOFAIL);\n        if ((!np || nv_isnull(np)) && sh_macfun(shp, cp, offset = stktell(shp->stk))) {\n            Fun = sh_arith(shp, sub = stkptr(shp->stk, offset));\n            STORE_VT(FunNode.nvalue, sfdoublep, &Fun);\n            FunNode.nvshell = shp;\n            nv_onattr(&FunNode, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n            cp[flag] = d;\n            return &FunNode;\n        }\n        if (!np && assign) {\n            np = nv_open(cp, root, nvflags | NV_VARNAME);\n        }\n        cp[flag] = d;\n        if (!np) return 0;\n        root = shp->last_root;\n        if (cp[flag + 1] == '[') {\n            flag++;\n        } else {\n            flag = 0;\n        }\n    }\n\n    if ((lvalue->emode & ARITH_COMP) && dtvnext(root)) {\n        mp = nv_search_namval(np, sdict ? sdict : root, NV_NOSCOPE);\n        if (!mp && nsdict) mp = nv_search_namval(np, nsdict, 0);\n        if (mp) np = mp;\n    }\n\n    while (nv_isref(np)) {\n        sub = nv_refsub(np);\n        np = nv_refnode(np);\n        if (sub) nv_putsub(np, sub, 0, assign ? ARRAY_ADD : 0);\n    }\n\n    if (!nosub && flag) {\n        int hasdot = 0;\n        cp = (char *)&lvalue->expr[flag];\n        if (sub) goto skip;\n        sub = cp;\n        while (1) {\n            Namarr_t *ap;\n            Namval_t *nq;\n            cp = nv_endsubscript(np, cp, 0, shp);\n            if (c || *cp == '.') {\n                c = '.';\n                while (*cp == '.') {\n                    hasdot = 1;\n                    cp++;\n                    while (c = mb1char(&cp), isaname(c)) {\n                        ;  // empty body\n                    }\n                }\n                if (c == '[') continue;\n            }\n            flag = *cp;\n            *cp = 0;\n            if (c || hasdot) {\n                sfprintf(shp->strbuf, \"%s%s%c\", nv_name(np), sub, 0);\n                sub = sfstruse(shp->strbuf);\n            }\n            if (strchr(sub, '$')) sub = sh_mactrim(shp, sub, 0);\n            *cp = flag;\n            if (c || hasdot) {\n                np = nv_open(sub, shp->var_tree, NV_VARNAME | nvflags);\n                return np;\n            }\n            cp = nv_endsubscript(np, sub, (assign ? NV_ADD : 0) | NV_SUBQUOTE, np->nvshell);\n            if (*cp != '[') break;\n        skip:\n            nq = nv_opensub(np);\n            if (nq) {\n                np = nq;\n            } else {\n                ap = nv_arrayptr(np);\n                if (ap && !ap->table) {\n                    ap->table = dtopen(&_Nvdisc, Dtoset);\n                    dtuserdata(ap->table, shp, 1);\n                }\n                if (ap && ap->table && (nq = nv_search(nv_getsub(np), ap->table, NV_ADD))) {\n                    nq->nvenv = np;\n                }\n                if (nq && nv_isnull(nq)) np = nv_arraychild(np, nq, 0);\n            }\n            sub = cp;\n        }\n    } else if (nosub > 0) {\n        nv_putsub(np, NULL, nosub - 1, 0);\n    }\n    return np;\n}\n\nMath_f sh_mathstdfun(const char *fname, size_t fsize, short *nargs) {\n    const struct mathtab *tp;\n    char c = fname[0];\n    for (tp = shtab_math; *tp->fname; tp++) {\n        if (*tp->fname > c) break;\n        if (tp->fname[1] == c && tp->fname[fsize + 1] == 0 &&\n            strncmp(&tp->fname[1], fname, fsize) == 0) {\n            if (nargs) *nargs = *tp->fname;\n            return tp->fnptr;\n        }\n    }\n    return NULL;\n}\n\nint sh_mathstd(const char *name) { return sh_mathstdfun(name, strlen(name), NULL) != 0; }\n\nstatic_fn Sfdouble_t number(const char *s, char **p, int b, struct lval *lvalue) {\n    Sfdouble_t r;\n    char *t;\n    int oerrno;\n    int c;\n    char base;\n    struct lval v;\n\n    oerrno = errno;\n    errno = 0;\n    base = b;\n\n    if (!lvalue) {\n        lvalue = &v;\n    } else if (lvalue->shp->bltindata.bnode == SYSLET && !sh_isoption(lvalue->shp, SH_LETOCTAL)) {\n        while (*s == '0' && isdigit(s[1])) s++;\n    }\n    lvalue->eflag = 0;\n    lvalue->isfloat = 0;\n    r = strton64(s, &t, &base, -1);\n    if (*t == '8' || *t == '9') {\n        base = 10;\n        errno = 0;\n        r = strton64(s, &t, &base, -1);\n    }\n    if (base <= 1) base = 10;\n    if (*t == '_') {\n        if ((r == 1 || r == 2) && strcmp(t, \"_PI\") == 0) {\n            t += 3;\n            r = Mtable[(int)r - 1].value;\n        } else if (r == 2 && strcmp(t, \"_SQRTPI\") == 0) {\n            t += 7;\n            r = Mtable[2].value;\n        }\n    }\n    c = r == LLONG_MAX && errno ? 'e' : *t;\n    if (c == getdecimal() || c == 'e' || c == 'E' || (base == 16 && (c == 'p' || c == 'P'))) {\n        r = strtold(s, &t);\n        lvalue->isfloat = TYPE_LD;\n    }\n    if (t > s) {\n        if (*t == 'f' || *t == 'F') {\n            t++;\n            lvalue->isfloat = TYPE_F;\n            r = (float)r;\n        } else if (*t == 'l' || *t == 'L') {\n            t++;\n            lvalue->isfloat = TYPE_LD;\n        } else if (*t == 'd' || *t == 'D') {\n            t++;\n            lvalue->isfloat = TYPE_LD;\n            r = (double)r;\n        }\n    }\n    errno = oerrno;\n    *p = t;\n    return r;\n}\n\nstatic_fn Sfdouble_t arith(const char **ptr, struct lval *lvalue, int type, Sfdouble_t n) {\n    Shell_t *shp = lvalue->shp;\n    Sfdouble_t r = 0;\n    char *str = (char *)*ptr;\n    char *cp;\n\n    switch (type) {\n        case ASSIGN: {\n            Namval_t *np = (Namval_t *)(lvalue->value);\n            np = scope(np, lvalue, 1);\n            nv_putval(np, (char *)&n, NV_LDOUBLE);\n            if (lvalue->eflag) lvalue->ptr = nv_hasdisc(np, &ENUM_disc);\n            lvalue->eflag = 0;\n            r = nv_getnum(np);\n            lvalue->value = (char *)np;\n            break;\n        }\n        case LOOKUP: {\n            int c = *str;\n            char *xp = str;\n            lvalue->value = NULL;\n            if (c == '.') str++;\n            c = mb1char(&str);\n            if (isaletter(c)) {\n                Namval_t *np = NULL;\n                int dot = 0;\n                while (1) {\n                    xp = str;\n                    while (c = mb1char(&str), isaname(c)) xp = str;\n                    str = xp;\n                    while (c == '[' && dot == NV_NOADD) {\n                        str = nv_endsubscript(NULL, str, 0, shp);\n                        c = *str;\n                    }\n                    if (c != '.') break;\n                    dot = NV_NOADD;\n                    c = *++str;\n                    if (c != '[') continue;\n                    str = nv_endsubscript(NULL, cp = str, NV_SUBQUOTE, shp) - 1;\n                    if (sh_checkid(cp + 1, NULL)) str -= 2;\n                }\n                if (c == '(') {\n                    int off = stktell(shp->stk);\n                    int fsize = str - (char *)(*ptr);\n                    const struct mathtab *tp;\n                    Namval_t *nq;\n                    lvalue->fun = NULL;\n                    sfprintf(shp->stk, \".sh.math.%.*s%c\", fsize, *ptr, 0);\n                    stkseek(shp->stk, off);\n                    nq = nv_search(stkptr(shp->stk, off), shp->fun_tree, 0);\n                    if (nq) {\n                        struct Ufunction *rp = FETCH_VT(nq->nvalue, rp);\n                        lvalue->nargs = -rp->argc;\n                        lvalue->fun = (Math_f)nq;\n                        break;\n                    }\n                    if (fsize <= (sizeof(tp->fname) - 2)) {\n                        lvalue->fun = (Math_f)sh_mathstdfun(*ptr, fsize, &lvalue->nargs);\n                    }\n                    if (lvalue->fun) break;\n                    if (lvalue->emode & ARITH_COMP) {\n                        lvalue->value = (char *)e_function;\n                    } else {\n                        lvalue->value = (char *)ERROR_dictionary(e_function);\n                    }\n                    return r;\n                }\n                if ((lvalue->emode & ARITH_COMP) && dot) {\n                    lvalue->value = (char *)*ptr;\n                    lvalue->flag = str - lvalue->value;\n                    break;\n                }\n                *str = 0;\n                if (sh_isoption(shp, SH_NOEXEC)) {\n                    np = VAR_underscore;\n                } else {\n                    int offset = stktell(shp->stk);\n                    char *saveptr = stkfreeze(shp->stk, 0);\n                    Dt_t *root = (lvalue->emode & ARITH_COMP) ? shp->var_base : shp->var_tree;\n                    *str = c;\n                    cp = str;\n                    while (c == '[' || c == '.') {\n                        if (c == '[') {\n                            str = nv_endsubscript(np, str, 0, shp);\n                            c = *str;\n                            if (c != '[' && c != '.') {\n                                str = cp;\n                                c = '[';\n                                break;\n                            }\n                        } else {\n                            dot = NV_NOADD | NV_NOFAIL;\n                            str++;\n                            xp = str;\n                            while (c = mb1char(&str), isaname(c)) xp = str;\n                            str = xp;\n                        }\n                    }\n                    *str = 0;\n                    cp = (char *)*ptr;\n                    Varsubscript = false;\n                    if ((cp[0] == 'i' || cp[0] == 'I') && (cp[1] == 'n' || cp[1] == 'N') &&\n                        (cp[2] == 'f' || cp[2] == 'F') && cp[3] == 0) {\n                        Inf = strtold(\"Inf\", NULL);\n                        STORE_VT(Infnod.nvalue, sfdoublep, &Inf);\n                        np = &Infnod;\n                        np->nvshell = shp;\n                        nv_onattr(np, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n                    } else if ((cp[0] == 'n' || cp[0] == 'N') && (cp[1] == 'a' || cp[1] == 'A') &&\n                               (cp[2] == 'n' || cp[2] == 'N') && cp[3] == 0) {\n                        NaN = strtold(\"NaN\", NULL);\n                        STORE_VT(NaNnod.nvalue, sfdoublep, &NaN);\n                        np = &NaNnod;\n                        np->nvshell = shp;\n                        nv_onattr(np, NV_NOFREE | NV_LDOUBLE | NV_RDONLY);\n                    } else {\n                        const struct Mathconst *mp = NULL;\n                        np = NULL;\n                        if (strchr(\"ELPS12\", **ptr)) {\n                            for (mp = Mtable; *mp->name; mp++) {\n                                if (strcmp(mp->name, *ptr) == 0) break;\n                            }\n                        }\n                        if (mp && *mp->name) {\n                            r = mp->value;\n                            lvalue->isfloat = TYPE_LD;\n                            goto skip2;\n                        }\n                        if (shp->namref_root && !(lvalue->emode & ARITH_COMP)) {\n                            np = nv_open(*ptr, shp->namref_root,\n                                         NV_NOREF | NV_VARNAME | NV_NOSCOPE | NV_NOADD | dot);\n                        }\n                        if (!np) {\n                            np = nv_open(*ptr, root, NV_NOREF | NV_VARNAME | dot);\n                        }\n                        if (!np || Varsubscript) {\n                            np = NULL;\n                            lvalue->value = (char *)*ptr;\n                            lvalue->flag = str - lvalue->value;\n                        }\n                    }\n                skip2:\n                    if (saveptr != stkptr(shp->stk, 0)) {\n                        stkset(shp->stk, saveptr, offset);\n                    } else {\n                        stkseek(shp->stk, offset);\n                    }\n                }\n                *str = c;\n                if (lvalue->isfloat == TYPE_LD) break;\n                if (!np) break;  // this used to also test `&& lvalue->value` but that's redundant\n                lvalue->value = (char *)np;\n                // Bind subscript later.\n                if (nv_isattr(np, NV_DOUBLE) == NV_DOUBLE) lvalue->isfloat = 1;\n                lvalue->flag = 0;\n                if (c == '[') {\n                    lvalue->flag = (str - lvalue->expr);\n                    do {\n                        while (c == '.') {\n                            str++;\n                            while (xp = str, c = mb1char(&str), isaname(c)) {\n                                ;  // empty body\n                            }\n                            c = *(str = xp);\n                        }\n                        if (c == '[') str = nv_endsubscript(np, str, 0, np->nvshell);\n                        c = *str;\n                    } while (c == '[' || c == '.');\n                    break;\n                }\n            } else {\n                r = number(xp, &str, 0, lvalue);\n            }\n            break;\n        }\n        case VALUE: {\n            Namval_t *np = (Namval_t *)(lvalue->value);\n            Namarr_t *ap;\n            if (sh_isoption(shp, SH_NOEXEC)) return 0;\n            np = scope(np, lvalue, 0);\n            if (!np) {\n                if (sh_isoption(shp, SH_NOUNSET)) {\n                    *ptr = lvalue->value;\n                    goto skip;\n                }\n                return 0;\n            }\n            lvalue->ovalue = (char *)np;\n            if (lvalue->eflag) {\n                lvalue->ptr = nv_hasdisc(np, &ENUM_disc);\n            } else if ((Namfun_t *)lvalue->ptr && !nv_hasdisc(np, &ENUM_disc) &&\n                       !nv_isattr(np, NV_INTEGER)) {\n                // TODO: The calloc() below should be considered a bandaid and may not be correct.\n                // See https://github.com/att/ast/issues/980. This dynamic allocation may leak some\n                // memory but that is preferable to referencing a stack var after this function\n                // returns. I think I have addressed this by removing the NV_NOFREE flag but I'm\n                // leaving this comment due to my low confidence.\n                Namval_t *mp = ((Namfun_t *)lvalue->ptr)->type;\n                Namval_t *node = calloc(1, sizeof(Namval_t));\n                nv_clone(mp, node, 0);\n                nv_offattr(node, NV_NOFREE);\n                nv_offattr(node, NV_RDONLY);\n                nv_putval(node, np->nvname, 0);\n\n                if (nv_isattr(node, NV_NOFREE)) return nv_getnum(node);\n            }\n            lvalue->eflag = 0;\n            if (((lvalue->emode & 2) || lvalue->level > 1 ||\n                 (lvalue->nextop != A_STORE && sh_isoption(shp, SH_NOUNSET))) &&\n                nv_isnull(np) && !nv_isattr(np, NV_INTEGER)) {\n                *ptr = nv_name(np);\n            skip:\n                lvalue->value = (char *)ERROR_dictionary(e_notset);\n                lvalue->emode |= 010;\n                return 0;\n            }\n            if (lvalue->userfn) {\n                ap = nv_arrayptr(np);\n                if (ap && (ap->flags & ARRAY_UNDEF)) {\n                    r = (Sfdouble_t)(uintptr_t)np;\n                    lvalue->isfloat = 5;\n                    return r;\n                }\n            }\n            r = nv_getnum(np);\n            if (nv_isattr(np, NV_INTEGER | NV_BINARY) == (NV_INTEGER | NV_BINARY)) {\n                lvalue->isfloat = (r != (Sflong_t)r) ? TYPE_LD : 0;\n            } else if (nv_isattr(np, (NV_DOUBLE | NV_SHORT)) == (NV_DOUBLE | NV_SHORT)) {\n                lvalue->isfloat = TYPE_F;\n                r = (float)r;\n            } else if (nv_isattr(np, (NV_DOUBLE | NV_LONG)) == (NV_DOUBLE | NV_LONG)) {\n                lvalue->isfloat = TYPE_LD;\n            } else if (nv_isattr(np, NV_DOUBLE) == NV_DOUBLE) {\n                lvalue->isfloat = TYPE_D;\n                r = (double)r;\n            }\n            if ((lvalue->emode & ARITH_ASSIGNOP) && nv_isarray(np)) {\n                lvalue->nosub = nv_aindex(np) + 1;\n            }\n            return r;\n        }\n        case MESSAGE: {\n            sfsync(NULL);\n            if (lvalue->emode & ARITH_COMP) return -1;\n\n            errormsg(SH_DICT, ERROR_exit((lvalue->emode & 3) != 0), lvalue->value, *ptr);\n        }\n    }\n    *ptr = str;\n    return r;\n}\n\nSfdouble_t sh_arith(Shell_t *shp, const char *str) { return sh_strnum(shp, str, NULL, 1); }\n\nvoid *sh_arithcomp(Shell_t *shp, char *str) {\n    const char *ptr = str;\n    Arith_t *ep;\n\n    ep = arith_compile(shp, str, (char **)&ptr, arith, ARITH_COMP | 1);\n    if (*ptr) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *ptr, str);\n    return ep;\n}\n\n// Convert number defined by string to a Sfdouble_t.\n// Ptr is set to the last character processed.\n// If mode>0, an error will be fatal with value <mode>.\nSfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        d = 0.0;\n        last = (char *)str;\n    } else {\n        d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {\n            // This call is to handle \"base#value\" literals if we're importing untrusted env vars.\n            d = number(str, &last, 0, NULL);\n        }\n        if (*last) {\n            if (sh_isstate(shp, SH_INIT)) {\n                // Initializing means importing untrusted env vars. Since the string does not appear\n                // to be a recognized numeric literal give up. We can't safely call strval() since\n                // that allows arbitrary expressions which would create a security vulnerability.\n                d = 0.0;\n            } else {\n                if (*last != '.' || last[1] != '.') {\n                    d = strval(shp, str, &last, arith, mode);\n                    Varsubscript = true;\n                }\n                if (!ptr && *last && mode > 0) {\n                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n                }\n            }\n        } else if (d == 0.0 && *str == '-') {\n            d = -0.0;\n        }\n    }\n    if (ptr) *ptr = last;\n    return d;\n}\n", "########################################################################\n#                                                                      #\n#               This software is part of the ast package               #\n#          Copyright (c) 1982-2014 AT&T Intellectual Property          #\n#                      and is licensed under the                       #\n#                 Eclipse Public License, Version 1.0                  #\n#                    by AT&T Intellectual Property                     #\n#                                                                      #\n#                A copy of the License is available at                 #\n#          http://www.eclipse.org/org/documents/epl-v10.html           #\n#         (with md5 checksum b35adb5213ca9657e911e9befb180842)         #\n#                                                                      #\n#              Information and Software Systems Research               #\n#                            AT&T Research                             #\n#                           Florham Park NJ                            #\n#                                                                      #\n#                    David Korn <dgkorn@gmail.com>                     #\n#                                                                      #\n########################################################################\n\n# Some platforms have an extremely large default value for the number of open files. For example,\n# FreeBSD 11.1 has a default of 44685. This test fails with such a large value. Every other platform\n# has a limit an order of magnitude smaller. So limit the allowable values to something more\n# reasonable.\n#\n# TBD is why such a large default limit causes the test to fail.\nulimit -n 512\n\nz=()\nz.foo=( [one]=hello [two]=(x=3 y=4) [three]=hi)\nz.bar[0]=hello\nz.bar[2]=world\nz.bar[1]=(x=4 y=5)\nval='(\n\ttypeset -a bar=(\n\t\t[0]=hello\n\t\t[2]=world\n\t\t[1]=(\n\t\t\tx=4\n\t\t\ty=5\n\t\t)\n\t)\n\ttypeset -A foo=(\n\t\t[one]=hello\n\t\t[three]=hi\n\t\t[two]=(\n\t\t\tx=3\n\t\t\ty=4\n\t\t)\n\t)\n)'\n\n[[ $z == \"$val\" ]] || log_error 'compound variable with mixed arrays not working'\nz.bar[1]=yesyes\n[[ ${z.bar[1]} == yesyes ]] || log_error 'reassign of index array compound variable fails'\nz.bar[1]=(x=12 y=5)\n[[ ${z.bar[1]} == $'(\\n\\tx=12\\n\\ty=5\\n)' ]] || log_error 'reassign array simple to compound variable fails'\neval val=\"$z\"\n(\n    z.foo[three]=good\n    [[ ${z.foo[three]} == good ]] || log_error 'associative array assignment in subshell not working'\n)\n[[ $z == \"$val\" ]] || log_error 'compound variable changes after associative array assignment'\neval val=\"$z\"\n(\n    z.foo[two]=ok\n    [[ ${z.foo[two]} == ok ]] || log_error 'associative array assignment to compound variable in subshell not working'\n    z.bar[1]=yes\n    [[ ${z.bar[1]} == yes ]] || log_error 'index array assignment to compound variable in subshell not working'\n)\n[[ $z == \"$val\" ]] || log_error 'compound variable changes after associative array assignment'\n\nx=(\n    foo=( qqq=abc rrr=def)\n    bar=( zzz=no rst=fed)\n)\neval val=\"$x\"\n(\n    unset x.foo\n    [[ ${x.foo.qqq} ]] && log_error 'x.foo.qqq should be unset'\n    x.foo=good\n    [[ ${x.foo} == good ]] || log_error 'x.foo should be good'\n)\n[[ $x == \"$val\" ]] || log_error 'compound variable changes after unset leaves'\nunset l\n(\n    l=( a=1 b=\"BE\" )\n)\n[[ ${l+foo} != foo ]] || log_error 'l should be unset'\n\nTEST_notfound=notfound\nwhile whence $TEST_notfound >/dev/null 2>&1\ndo\n    TEST_notfound=notfound-$RANDOM\ndone\n\n\ninteger BS=1024 nb=64 ss=60 bs no\nfor bs in $BS 1\ndo\n    $SHELL -c '\n        {\n            sleep '$ss'\n            kill -KILL $$\n        } &\n        set -- $(printf %.'$(($BS*$nb))'c x | dd bs='$bs')\n        print ${#1}\n        kill $!\n    ' > $TEST_DIR/sub 2>/dev/null\n    no=$(<$TEST_DIR/sub)\n    (( no == (BS * nb) )) || log_error \"shell hangs on command substitution output size >= $BS*$nb with write size $bs -- expected $((BS*nb)), got ${no:-0}\"\ndone\n\n# This time with redirection on the trailing command\nfor bs in $BS 1\ndo\n    $SHELL -c '\n        {\n            sleep 2\n            sleep '$ss'\n            kill -KILL $$\n        } &\n        set -- $(printf %.'$(($BS*$nb))'c x | dd bs='$bs' 2>/dev/null)\n        print ${#1}\n        kill $!\n    ' > $TEST_DIR/sub 2>/dev/null\n    no=$(<$TEST_DIR/sub)\n    (( no == (BS * nb) )) || log_error \"shell hangs on command substitution output size >= $BS*$nb with write size $bs and trailing redirection -- expected $((BS*nb)), got ${no:-0}\"\ndone\n\n# exercise command substitutuion trailing newline logic w.r.t. pipe vs. tmp file io\n\nset -- \\\n    'post-line print'                                \\\n    '$TEST_unset; ($TEST_fork; print 1); print'                    \\\n    1                                        \\\n    'pre-line print'                                \\\n    '$TEST_unset; ($TEST_fork; print); print 1'                    \\\n    $'\\n1'                                        \\\n    'multiple pre-line print'                            \\\n    '$TEST_unset; ($TEST_fork; print); print; ($TEST_fork; print 1); print'        \\\n    $'\\n\\n1'                                    \\\n    'multiple post-line print'                            \\\n    '$TEST_unset; ($TEST_fork; print 1); print; ($TEST_fork; print); print'        \\\n    1                                        \\\n    'intermediate print'                                \\\n    '$TEST_unset; ($TEST_fork; print 1); print; ($TEST_fork; print 2); print'    \\\n    $'1\\n\\n2'                                    \\\n    'simple variable'                                \\\n    '$TEST_unset; ($TEST_fork; l=2; print \"$l\"); print $l'                \\\n    2                                        \\\n    'compound variable'                                \\\n    '$TEST_unset; ($TEST_fork; l=(a=2 b=\"BE\"); print \"$l\"); print $l'        \\\n    $'(\\n\\ta=2\\n\\tb=BE\\n)'                                \\\n\nexport TEST_fork TEST_unset\n\nwhile (( $# >= 3 ))\ndo\n    txt=$1\n    cmd=$2\n    exp=$3\n    shift 3\n    for TEST_unset in '' 'unset var'\n    do\n        for TEST_fork in '' 'ulimit -c 0'\n        do\n            for TEST_shell in \"eval\" \"$SHELL -c\"\n            do\n                if ! got=$($TEST_shell \"$cmd\")\n                then\n                    log_error \"${TEST_shell/*-c/\\$SHELL -c} ${TEST_unset:+unset }${TEST_fork:+fork }$txt print failed\"\n                elif [[ \"$got\" != \"$exp\" ]]\n                then\n                    EXP=$(printf %q \"$exp\")\n                    GOT=$(printf %q \"$got\")\n                    log_error \"${TEST_shell/*-c/\\$SHELL -c} ${TEST_unset:+unset }${TEST_fork:+fork }$txt command substitution failed -- expected $EXP, got $GOT\"\n                fi\n            done\n        done\n    done\ndone\n\nr=$( ($SHELL -c '\n    {\n        sleep 32\n        kill -KILL $$\n    } &\n    for v in $(set | sed \"s/=.*//\")\n    do\n        command unset $v\n    done\n    typeset -Z5 I\n    for ((I = 0; I < 1024; I++))\n    do\n        eval A$I=1234567890\n    done\n    a=$(set 2>&1)\n    print ok\n    kill -KILL $!\n') 2>/dev/null)\n[[ $r == ok ]] || log_error \"large subshell command substitution hangs\"\n\nfor TEST_command in '' $TEST_notfound\ndo\n    for TEST_exec in '' 'exec'\n    do\n        for TEST_fork in '' 'ulimit -c 0;'\n        do\n        for TEST_redirect in '' '>/dev/null'\n            do\n                for TEST_substitute in '' ': $'\n                do\n\n                     TEST_test=\"$TEST_substitute($TEST_fork $TEST_exec $TEST_command $TEST_redirect 2>/dev/null)\"\n                    [[ $TEST_test == '('*([[:space:]])')' ]] && continue\n                    r=$($SHELL -c '\n                        {\n                            sleep 2\n                            kill -KILL $$\n                        } &\n                        '\"$TEST_test\"'\n                        kill $!\n                        print ok\n                        ')\n                    [[ $r == ok ]] || log_error \"shell hangs on $TEST_test\"\n                done\n            done\n        done\n    done\ndone\n\n$SHELL -c '( autoload xxxxx);print -n' ||  log_error 'autoloaded functions in subshells can cause failure'\nactual=$($SHELL  <<- ++EOF++\n\t(trap 'print bar' EXIT;print -n foo)\n\t++EOF++\n)\nexpect=foobar\n[[ $actual == $expect ]] ||\n    log_error 'trap on exit when last commands is subshell is not triggered' \"$expect\" \"$actual\"\n\nactual=$(\n    $SHELL  2>&1  <<- \\EOF\n\t\tfunction foo\n\t\t{\n\t\t\tx=$( $bin_date > /dev/null 2>&1 ;:)\n\t\t}\n\t\t# consume almost all fds to push the test to the fd limit #\n\t\tinteger max=$(ulimit --nofile)\n\t\t(( max -= 10 ))\n\t\tfor ((i=20; i < max; i++))\n\t\tdo\n\t\t\texec {i}>&1\n                done\n\t\tfor ((i=0; i < 20; i++))\n                do\n\t\t\ty=$(foo)\n\t\tdone\n\tEOF\n) || {\n    expect=''\n    log_error \"nested command substitution with redirections failed\" \"$expect\" \"$actual\"\n}\n\nexp=0\n$SHELL -c $'\n    function foobar\n    {\n        print \"hello world\"\n    }\n    [[ $(getopts \\'[+?X\\ffoobar\\fX]\\' v --man 2>&1) == *\"Xhello worldX\"* ]]\n    exit '$exp$'\n'\ngot=$?\n[[ $got == $exp ]] || log_error \"getopts --man runtime callout with nonzero exit terminates shell -- expected '$exp', got '$got'\"\nexp=ok\ngot=$($SHELL -c $'\n    function foobar\n    {\n        print \"hello world\"\n    }\n    [[ $(getopts \\'[+?X\\ffoobar\\fX]\\' v --man 2>&1) == *\"Xhello worldX\"* ]]\n    print '$exp$'\n')\n[[ $got == $exp ]] || log_error \"getopts --man runtime callout with nonzero exit terminates shell -- expected '$exp', got '$got'\"\n\n# command substitution variations #\nset -- \\\n    '$('            ')'        \\\n    '${ '            '; }'        \\\n    '$(ulimit -c 0; '    ')'        \\\n    '$( ('            ') )'        \\\n    '${ ('            '); }'        \\\n    '`'            '`'        \\\n    '`('            ')`'        \\\n    '`ulimit -c 0; '    '`'        \\\n    # end of table #\nexp=ok\ntestcase[1]='\n    if %sexpr \"NOMATCH\" : \".*Z\" >/dev/null%s\n    then\n        print error\n    else\n        print ok\n    fi\n\n    exit %s\n'\ntestcase[2]='\n    function bar\n    {\n        pipeout=%1$sprintf Ok | tr O o%2$s\n        print $pipeout\n        return 0\n    }\n    foo=%1$sbar%2$s || foo=\"exit status $?\"\n    print $foo\n    exit %3$s\n'\n\nwhile (( $# >= 2 ))\ndo\n    for ((TEST=1; TEST<=${#testcase[@]}; TEST++))\n    do\n        body=${testcase[TEST]}\n        for code in 0 2\n        do\n            got=${ printf \"$body\" \"$1\" \"$2\" \"$code\" | $SHELL 2>&1 }\n            status=$?\n            if (( status != code ))\n            then\n                log_error \"test $TEST '$1...$2 exit $code' failed -- exit status $status, expected $code\"\n            elif [[ $got != $exp ]]\n            then\n                log_error \"test $TEST '$1...$2 exit $code' failed -- got '$got', expected '$exp'\"\n            fi\n        done\n    done\n    shift 2\ndone\n\n# the next tests loop on all combinations of\n#    { SUB CAT INS TST APP } X { file-sizes }\n# where the file size starts at 1Ki and doubles up to and including 1Mi\n#\n# the tests and timeouts are done in async subshells to prevent\n# the test harness from hanging\n\nSUB=(\n    ( BEG='$( '    END=' )'    )\n    ( BEG='${ '    END='; }'    )\n)\nCAT=(  cat  $bin_cat  )\nINS=(  \"\"  \"builtin cat; \"  \"builtin -d cat $bin_cat; \"  \": > /dev/null; \"  )\nAPP=(  \"\"  \"; :\"  )\nTST=(\n    ( CMD='print foo | $cat'            EXP=3        )\n    ( CMD='$cat < $TEST_DIR/lin'                        )\n    ( CMD='cat $TEST_DIR/lin | $cat'                    )\n    ( CMD='read v < $TEST_DIR/buf; print $v'        LIM=4*1024    )\n    ( CMD='cat $TEST_DIR/buf | read v; print $v'        LIM=4*1024    )\n)\n\n# Prime the two data files to 512 bytes each\n# $TEST_DIR/lin has newlines every 16 bytes and $TEST_DIR/buf has no newlines\n# the outer loop doubles the file size at top\n\nbuf=$'1234567890abcdef'\nlin=$'\\n1234567890abcde'\nfor ((i=0; i<5; i++))\ndo\n    buf=$buf$buf\n    lin=$lin$lin\ndone\n\nprint -n \"$buf\" > $TEST_DIR/buf\nprint -n \"$lin\" > $TEST_DIR/lin\n\nunset SKIP\nfor ((n=1024; n<=1024*1024; n*=2))\ndo\n    cat $TEST_DIR/buf $TEST_DIR/buf > $TEST_DIR/tmp\n    mv $TEST_DIR/tmp $TEST_DIR/buf\n    cat $TEST_DIR/lin $TEST_DIR/lin > $TEST_DIR/tmp\n    mv $TEST_DIR/tmp $TEST_DIR/lin\n    for ((S=0; S<${#SUB[@]}; S++))\n    do\n        for ((C=0; C<${#CAT[@]}; C++))\n        do\n            cat=${CAT[C]}\n            for ((I=0; I<${#INS[@]}; I++))\n            do\n            for ((A=0; A<${#APP[@]}; A++))\n                do\n                for ((T=0; T<${#TST[@]}; T++))\n                    do\n                    #undent...#\n                    if [[ ! ${SKIP[S][C][I][A][T]} ]]\n                    then\n                        eval \"{ x=${SUB[S].BEG}${INS[I]}${TST[T].CMD}${APP[A]}${SUB[S].END}; print \\${#x}; } >\\$TEST_DIR/out &\"\n                        m=$!\n                        { sleep 4; kill -9 $m; } &\n                        k=$!\n                        wait $m\n                        h=$?\n                        kill -9 $k\n                        # Suppress messages like this from the test log:\n                        # /tmp/ksh.subshell.7fgw2W8/subshell.sh[475]: wait: 8737: Killed\n                        wait $k 2> /dev/null\n                        got=$(<$TEST_DIR/out)\n                        if [[ ! $got ]] && (( h ))\n                        then\n                            got=HUNG\n                        fi\n\n                        if [[ ${TST[T].EXP} ]]\n                        then\n                            exp=${TST[T].EXP}\n                        else\n                            exp=$n\n                        fi\n\n                        if [[ $got != $exp ]]\n                        then\n                            # on failure skip similar tests on larger files sizes #\n                            SKIP[S][C][I][A][T]=1\n                            siz=$(printf $'%#i' $exp)\n                            cmd=${TST[T].CMD//\\$cat/$cat}\n                            cmd=${cmd//\\$TEST_DIR\\/buf/$siz.buf}\n                            cmd=${cmd//\\$TEST_DIR\\/lin/$siz.lin}\n                            log_error \"'x=${SUB[S].BEG}${INS[I]}${cmd}${APP[A]}${SUB[S].END} && print \\${#x}' failed -- expected '$exp', got '$got'\"\n                        elif [[ ${TST[T].EXP} ]] || (( TST[T].LIM >= n ))\n                        then\n                            SKIP[S][C][I][A][T]=1\n                        fi\n\n                    fi\n                    #...indent#\n                    done\n                done\n            done\n        done\n    done\ndone\n\n# specifics -- there's more?\n\n{\n    cmd='{ exec 5>/dev/null; print \"$(eval ls -d . 2>&1 1>&5)\"; } >$TEST_DIR/out &'\n    eval $cmd\n    m=$!\n    { sleep 4; kill -9 $m; } &\n    k=$!\n    wait $m\n    h=$?\n    kill -9 $k\n    wait $k\n    got=$(<$TEST_DIR/out)\n} 2>/dev/null\nexp=''\nif [[ ! $got ]] && (( h ))\nthen\n    got=HUNG\nfi\n\nif [[ $got != $exp ]]\nthen\n    log_error \"eval '$cmd' failed -- expected '$exp', got '$got'\"\nfi\n\nfloat t1=$SECONDS\n  $SHELL -c \"( $bin_sleep 5 </dev/null >/dev/null 2>&1 & ); exit 0\" | cat\n  (( (SECONDS-t1) > 4 )) && log_error '/bin/sleep& in subshell hanging'\n  ((t1=SECONDS))\n\n$SHELL -c '( sleep 5 </dev/null >/dev/null 2>&1 & );exit 0' | cat\n(( (SECONDS-t1) > 4 )) && log_error 'sleep& in subshell hanging'\n\nexp=HOME=$HOME\n( HOME=/bin/sh )\ngot=$(env | grep ^HOME=)\n[[ $got == \"$exp\" ]] ||  log_error \"( HOME=/bin/sh ) cleanup failed -- expected '$exp', got '$got'\"\n\ncmd='echo $((case x in x)echo ok;esac);:)'\nexp=ok\ngot=$($SHELL -c \"$cmd\" 2>&1)\n[[ $got == \"$exp\" ]] ||  log_error \"'$cmd' failed -- expected '$exp', got '$got'\"\n\ncmd='eval \"for i in 1 2; do eval /bin/echo x; done\"'\nexp=$'x\\nx'\ngot=$($SHELL -c \"$cmd\")\nif [[ $got != \"$exp\" ]]\nthen\n    EXP=$(printf %q \"$exp\")\n    GOT=$(printf %q \"$got\")\n    log_error \"'$cmd' failed -- expected $EXP, got $GOT\"\nfi\n\n(\n$SHELL -c 'sleep 20 & pid=$!; { x=$( ( seq 60000 ) );kill -9 $pid;}&;wait $pid'\n) 2> /dev/null\n(( $? )) ||  log_error 'nested command substitution with large output hangs'\n\n(.sh.foo=foobar)\n[[ ${.sh.foo} == foobar ]] && log_error '.sh subvariables in subshells remain set'\n[[ $($SHELL -c 'print 1 | : \"$(/bin/cat <(/bin/cat))\"') ]] && log_error 'process substitution not working correctly in subshells'\n\n# config hang bug\ninteger i\nfor ((i=1; i < 1000; i++))\ndo\n    typeset foo$i=$i\ndone\n{\n    : $( (ac_space=' '; set | grep ac_space) 2>&1)\n} < /dev/null | cat > /dev/null &\nsleep  1.5\nif kill -KILL $! 2> /dev/null\nthen\n    log_error 'process timed out with hung comsub'\nfi\n\nwait $! 2> /dev/null\n(( $? > 128 )) && log_error 'incorrect exit status with comsub'\n\n$SHELL 2> /dev/null -c '[[ ${ print foo },${ print bar } == foo,bar ]]' || log_error  '${ print foo },${ print bar } not working'\n$SHELL 2> /dev/null -c '[[ ${ print foo; },${ print bar } == foo,bar ]]' || log_error  '${ print foo; },${ print bar } not working'\n\nsrc=$'true 2>&1\\n: $(true | true)\\n: $(true | true)\\n: $(true | true)\\n'$bin_true\nexp=ok\ngot=$( $SHELL -c \"(eval '$src'); echo $exp\" )\n[[ $got == \"$exp\" ]] || log_error 'subshell eval of pipeline clobbers stdout'\n\nx=$( { time $SHELL -c date >| /dev/null;} 2>&1)\n[[ $x == *real*user*sys* ]] || log_error 'time { ...;} 2>&1 in $(...) fails'\n\nx=$($SHELL -c '( function fx { export X=123;  } ; fx; ); echo $X')\n[[ $x == 123 ]] && log_error 'global variables set from with functions inside a\nsubshell can leave side effects in parent shell'\n\nerr() { return $1; }\n( err 12 ) & pid=$!\n: $($bin_date)\nwait $pid\nactual=$?\nexpect=12\n[[ $actual -eq $expect ]] ||\n    log_error 'exit status from subshells not being preserved' \"$expect\" \"$actual\"\n\nactual=\"$(sed 's/^/Hello /' <(print \"Fred\" | sort))\"\nexpect=\"Hello Fred\"\n[[ $actual == $expect ]] ||\n    log_error  \"process subst of pipeline in cmd subst not working\" \"$expect\" \"$actual\"\n\n{\n$SHELL <<- \\EOF\n\tfunction foo\n\t{\n\t\tinteger i\n\t\tprint -u2 foobar\n\t\tfor    ((i=0; i < 8000; i++))\n\t\tdo\n\t\t\tprint abcdefghijk\n\t\tdone\n\t\tprint -u2 done\n\t}\n\tout=$(eval \"foo | cat\" 2>&1)\n\t(( ${#out} == 96011 )) || log_error \"\\${#out} is ${#out} should be 96011\"\nEOF\n} & pid=$!\n$SHELL -c \"{ sleep 4 && kill $pid ;}\" 2> /dev/null\n(( $? == 0 )) &&  log_error 'process has hung'\n\n{\nx=$( $SHELL  <<- \\EOF\n\tfunction func1 { typeset IFS; : $(func2); print END ;}\n\tfunction func2 { IFS=\"BAR\"; }\n\tfunc1\n\tfunc1\nEOF\n)\n} 2> /dev/null\n[[ $x == $'END\\nEND' ]] || log_error 'bug in save/restore of IFS in subshell'\n\ntmpf=$TEST_DIR/foo\nfunction fun1\n{\n    $bin_true\n    cd - >/dev/null 2>&1\n    print -u2 -- \"$($bin_date) SUCCESS\"\n}\n\nprint -n $(fun1 2> $tmpf)\n[[  $(< $tmpf) == *SUCCESS ]] || log_error 'standard error output lost with command substitution'\n\n\ncat > foo <<-\\EOF\n\t$SHELL -c 'function g { IFS= ;};function f { typeset IFS;(g);: $V;};f;f'\n\tEOF\n$SHELL 2> /dev/null foo || log_error 'IFS in subshell causes core dump'\n\nunset i\nif   [[ -d /dev/fd ]]\nthen\n        integer i\n        for ((i=11; i < 29; i++))\n        do\n            if ! [[ -r /dev/fd/$i  || -w /dev/fd/$i ]]\n            then\n                a=$($SHELL -c \"[[ -r /dev/fd/$i || -w /dev/fd/$i ]]\")\n                (( $? )) || log_error \"file descriptor $i not close on exec\"\n            fi\n        done\nfi\n\ntrap USR1 USR1\ntrap ERR ERR\n[[ $(trap -p USR1) == USR1 ]] || log_error 'trap -p USR1 in subshell not working'\n[[ $(trap -p ERR) == ERR ]] || log_error 'trap -p ERR in subshell not working'\n[[ $(trap -p) == *USR* ]] || log_error 'trap -p in subshell does not contain USR'\n[[ $(trap -p) == *ERR* ]] || log_error 'trap -p in subshell does not contain ERR'\ntrap - USR1 ERR\n\n( PATH=/bin:/usr/bin\ndot=$(cat <<-EOF\n\t$(ls -d .)\n\tEOF\n) ) & sleep 1\n\nif kill -0 $! 2> /dev/null\nthen\n    log_error  'command substitution containg here-doc with command substitution fails'\nfi\n\n[[ $( { trap \"echo foobar\" EXIT; ( $bin_printf \"\"); } & wait) == foobar ]] || \\\n    log_error  'exit trap not being invoked'\n\n$SHELL 2> /dev/null -c '( PATH=/bin; set -o restricted) ; exit 0'  || \\\n    log_error 'restoring PATH when a subshell enables restricted exits not working'\n\n$SHELL <<- \\EOF\n\tprint > /dev/null  $( ( head -c 1 /dev/zero | (wc -c) 3>&1 ) 3>&1) &\n\tpid=$!\n\tsleep 2\n\tkill -9 $! 2> /dev/null && log_error '/dev/zero in command substitution hangs'\n\twait $!\nEOF\n\nfor f in /dev/stdout /dev/fd/1\ndo\n    if [[ -e $f ]]\n    then\n        $SHELL -c \"x=\\$(command -p tee $f </dev/null 2>/dev/null)\" || log_error \"$f in command substitution fails\"\n    fi\ndone\n\n$SHELL > /dev/null -c 'echo $(for x in whatever; do case y in *) true;; esac; done)' || log_error 'syntax error with case in command substitution'\n\n$SHELL 2> /dev/null <<- \\EOF || log_error 'cannot run 100000 subshells'\n\t( for ((i=0; i < 100000; i++))\n\tdo\n\t\t(b=$(printf %08d ${i}))\n\tdone )\nEOF\n\nprint 'print OK'  | out=$(${SHELL})\n[[ $out == OK ]] || log_error '$() command substitution not waiting for process completion'\n\nprint 'print OK' | out=$( ${SHELL} 2>&1 )\nout2=\"${out}$?\"\n[[ \"$out2\" == 'OK0' ]]  ||  log_error -u2 \"expected OK0 got $out2\"\n\nfun()\n{\n    foo=` $bin_echo foo`\n    print -n stdout=$foo\n    print -u2 stderr=$foo\n}\n[[ `fun 2>&1` == 'stdout=foostderr=foo' ]] || log_error 'nested command substitution with 2>&1 not working'\n\nmkdir $TEST_DIR/bin$$\nprint 'print foo' > $TEST_DIR/bin$$/foo\nchmod +x  $TEST_DIR/bin$$/foo\n: $(type foo 2> type.foo.out)\nactual=$(< type.foo.out)\nactual=${actual#*: }  # remove the script name and line number prefix\nexpect='whence: foo: not found'\n[[ $actual == $expect ]] || log_error \"command foo should not have been found\" \"$expect\" \"$actual\"\n: ${ PATH=$TEST_DIR/bin$$:$PATH;}\nactual=$(whence foo 2> /dev/null)\nexpect=\"$TEST_DIR/bin$$/foo\"\n[[ $actual == $expect ]] ||\n    log_error '${...PATH=...} does not preserve PATH bindings' \"$expect\" \"$actual\"\n\n> $TEST_DIR/log\nfunction A\n{\n    trap 'print TRAP A >> $TEST_DIR/log' EXIT\n    print >&2\n}\nfunction B\n{\n    trap 'print TRAP B >> $TEST_DIR/log' EXIT\n    A\n}\nx=${ ( B ) ; }\n[[ $(<$TEST_DIR/log) ==  *'TRAP A'*'TRAP B'* ]] || log_error 'trap A and trap B not both executed'\n\nfunction foo\n{\n    .sh.value=bam\n}\nval=${ foo;}\n[[ $val ]] && log_error \"function foo generates $val but should generate the empty string in command substitution\"\n\nx=$(\n    for i in a b c\n    do\n    read A\n        print -n \"$A\"\n        STDERR=$(</dev/null)\n    done <<< $'y\\ny\\ny\\n'\n)\n[[ $x == yyy ]] || log_error '$(</dev/null) in a subshell causes failure'\n\n\n$SHELL -c 'while((SECONDS<3)); do test -z `/bin/false | /bin/false | /bin/doesnotexist`;done;:' 2> /dev/null || log_error 'non-existant last command in pipeline causes `` to fail'\n\nx=$({ sleep .1;false;} | true)\n[[ $? != 0 ]] && log_error 'without pipefail, non-zero exit in pipeline causes command substitution to fail'\n\nfoo() {\n  print -r foo | read\n  return 1\n}\no1=$(foo \"foo\") && log_error 'function which fails inside commad substitution should return non-zero exit status for assignments'\n\n# test for larg `` command substitutions\ntmpscr=$TEST_DIR/xxx.sh\nprint 'x=` print -n '\"'\" > $tmpscr\ninteger i\nfor ((i=0; i < 4000; i++))\ndo\n    print xxxxxxxxxxyyyyyyyyyyzzzzzzzzzzaaaaaaaaaabbbbbbbbbbcccccccccc\ndone >>  $tmpscr\nprint  \"'\"'`' >> $tmpscr\n(( size= $(wc -c < $tmpscr) -18 ))\n$SHELL  \"$tmpscr\" &\ncop=$!\n{ sleep 2; kill $cop; } 2>/dev/null &\nspy=$!\nif   wait $cop 2>/dev/null\nthen\n    kill $spy 2>/dev/null\nelse    log_error -u2 \"\\`...\\` hangs for large with output size $size\"\nfi\n\nif [[ -e /dev/zero ]]\nthen\n    (( size = 117*1024 ))\n    $SHELL -c 'x=`(dd if=/dev/zero bs=1k count=117 2>/dev/null)`' &\n    cop=$!\n    { sleep 2; kill $cop; } 2>/dev/null &\n    spy=$!\n    if wait $cop 2>/dev/null\n    then\n        kill $spy 2>/dev/null\n    else\n        log_error -u2 \"\\`(...)\\` hangs for large with output size $size\"\n    fi\nfi\n\n# ========================================\n# Test that variables exported in subshells don't affect the outer shell.\n# Regression test for issue #7.\nfunction proxy {\n    export MYVAR=\"blah\"\n    child\n    unset MYVAR\n}\n\nfunction child {\n    echo \"MYVAR=$MYVAR\"\n}\n\nfunction test {\n        child\n        proxy\n        child\n}\n\nactual=\"$(test)\"\nexpected=\"\\\nMYVAR=\nMYVAR=blah\nMYVAR=\"\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"exported vars in subshells not confined to the subshell: $actual\"\nfi\n\n\n# ========================================\n# Test that closing file descriptors don't affect capturing the output of a\n# subshell. Regression test for issue #198.\nexpected='return value'\n\nfunction get_value {\n    case=$1\n    (( case >= 1 )) && exec 3< foo\n    (( case >= 2 )) && exec 4< foo\n    (( case >= 3 )) && exec 6< foo\n\n    # To trigger the bug we have to spawn an external command. Why is a\n    # mystery but not really relevant.\n    $bin_true\n\n    (( case >= 1 )) && exec 3<&-\n    (( case >= 2 )) && exec 4<&-\n    (( case >= 3 )) && exec 6<&-\n\n    print $expected\n}\n\nactual=$(get_value 0)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 0\"\nfi\n\nactual=$(get_value 1)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 1\"\nfi\n\nactual=$(get_value 2)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 2\"\nfi\n\nactual=$(get_value 3)\nif [[ $actual != $expected ]]\nthen\n    log_error -u2 \"failed to capture subshell output when closing fd: case 3\"\nfi\n\nbuiltin -d echo\n# Check if redirections work if backticks are nested inside $()\nfoo=$(print `echo bar`)\n[[ $foo == \"bar\" ]] || log_error 'Redirections do not work if backticks are nested inside $()'\n\n# Buffer boundary tests\nfor exp in 65535 65536\ndo    got=$($SHELL -c 'x=$(printf \"%.*c\" '$exp' x); print ${#x}' 2>&1)\n    [[ $got == $exp ]] || log_error \"large command substitution failed\" \"$exp\" \"$got\"\ndone\n\n# ==========\n# Verify that importing untrusted env vars does not allow evaluating arbitrary expressions but does\n# recognize all integer literals recognized by ksh.\nexpect=8\nactual=$(env SHLVL='7' $SHELL -c 'echo $SHLVL')\n[[ $actual == $expect ]] || log_error \"decimal int literal not recognized\" \"$expect\" \"$actual\"\n\nexpect=14\nactual=$(env SHLVL='013' $SHELL -c 'echo $SHLVL')\n[[ $actual == $expect ]] || log_error \"leading zeros int literal not recognized\" \"$expect\" \"$actual\"\n\nexpect=4\nactual=$(env SHLVL='2#11' $SHELL -c 'echo $SHLVL')\n[[ $actual == $expect ]] || log_error \"base#value int literal not recognized\" \"$expect\" \"$actual\"\n\nexpect=12\nactual=$(env SHLVL='16#B' $SHELL -c 'echo $SHLVL')\n[[ $actual == $expect ]] || log_error \"base#value int literal not recognized\" \"$expect\" \"$actual\"\n\nexpect=1\nactual=$(env SHLVL=\"2#11+x[\\$($bin_echo DANGER WILL ROBINSON >&2)0]\" $SHELL -c 'echo $SHLVL')\n[[ $actual == $expect ]] || log_error \"expression allowed on env var import\" \"$expect\" \"$actual\"\n"], "filenames": ["CHANGELOG.md", "src/cmd/ksh93/sh/arith.c", "src/cmd/ksh93/tests/subshell.sh"], "buggy_code_start_loc": [6, 570, 858], "buggy_code_end_loc": [6, 583, 858], "fixing_code_start_loc": [7, 570, 859], "fixing_code_end_loc": [9, 596, 882], "type": "CWE-77", "message": "In ksh version 20120801, a flaw was found in the way it evaluates certain environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Services and applications that allow remote unauthenticated attackers to provide one of those environment variables could allow them to exploit this issue remotely.", "other": {"cve": {"id": "CVE-2019-14868", "sourceIdentifier": "secalert@redhat.com", "published": "2020-04-02T17:15:13.990", "lastModified": "2023-02-12T23:36:17.613", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In ksh version 20120801, a flaw was found in the way it evaluates certain environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Services and applications that allow remote unauthenticated attackers to provide one of those environment variables could allow them to exploit this issue remotely."}, {"lang": "es", "value": "En ksh versi\u00f3n 20120801, se detect\u00f3 un fallo en la manera que eval\u00faa determinadas variables de entorno. Un atacante podr\u00eda usar este fallo para anular u omitir unas restricciones del entorno para ejecutar comandos de shell. Los servicios y las aplicaciones permiten a atacantes remotos no autenticados proporcionar una de esas variables de entorno que podr\u00edan permitirles explotar este problema remotamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ksh_project:ksh:20120801:*:*:*:*:*:*:*", "matchCriteriaId": "C453FD9C-7375-4E2E-84AD-ABC3CC786153"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.15.5", "matchCriteriaId": "99973242-A249-4C34-B042-5F833AE73708"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2020/May/53", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-14868", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/att/ast/commit/c7de8b641266bac7c77942239ac659edfee9ecd2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00015.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT211170", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/att/ast/commit/c7de8b641266bac7c77942239ac659edfee9ecd2"}}