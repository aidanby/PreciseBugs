{"buggy_code": ["/*-\n * Copyright (c) 2003-2007 Tim Kientzle\n * Copyright (c) 2008 Joerg Sonnenberger\n * Copyright (c) 2011-2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_read_support_format_mtree.c 201165 2009-12-29 05:52:13Z kientzle $\");\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#include <stddef.h>\n/* #include <stdint.h> */ /* See archive_platform.h */\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_string.h\"\n#include \"archive_pack_dev.h\"\n\n#ifndef O_BINARY\n#define\tO_BINARY 0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC\t0\n#endif\n\n#define\tMTREE_HAS_DEVICE\t0x0001\n#define\tMTREE_HAS_FFLAGS\t0x0002\n#define\tMTREE_HAS_GID\t\t0x0004\n#define\tMTREE_HAS_GNAME\t\t0x0008\n#define\tMTREE_HAS_MTIME\t\t0x0010\n#define\tMTREE_HAS_NLINK\t\t0x0020\n#define\tMTREE_HAS_PERM\t\t0x0040\n#define\tMTREE_HAS_SIZE\t\t0x0080\n#define\tMTREE_HAS_TYPE\t\t0x0100\n#define\tMTREE_HAS_UID\t\t0x0200\n#define\tMTREE_HAS_UNAME\t\t0x0400\n\n#define\tMTREE_HAS_OPTIONAL\t0x0800\n#define\tMTREE_HAS_NOCHANGE\t0x1000 /* FreeBSD specific */\n\nstruct mtree_option {\n\tstruct mtree_option *next;\n\tchar *value;\n};\n\nstruct mtree_entry {\n\tstruct mtree_entry *next;\n\tstruct mtree_option *options;\n\tchar *name;\n\tchar full;\n\tchar used;\n};\n\nstruct mtree {\n\tstruct archive_string\t line;\n\tsize_t\t\t\t buffsize;\n\tchar\t\t\t*buff;\n\tint64_t\t\t\t offset;\n\tint\t\t\t fd;\n\tint\t\t\t archive_format;\n\tconst char\t\t*archive_format_name;\n\tstruct mtree_entry\t*entries;\n\tstruct mtree_entry\t*this_entry;\n\tstruct archive_string\t current_dir;\n\tstruct archive_string\t contents_name;\n\n\tstruct archive_entry_linkresolver *resolver;\n\n\tint64_t\t\t\t cur_size;\n\tchar checkfs;\n};\n\nstatic int\tbid_keycmp(const char *, const char *, ssize_t);\nstatic int\tcleanup(struct archive_read *);\nstatic int\tdetect_form(struct archive_read *, int *);\nstatic int\tmtree_bid(struct archive_read *, int);\nstatic int\tparse_file(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic void\tparse_escapes(char *, struct mtree_entry *);\nstatic int\tparse_line(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic int\tparse_keyword(struct archive_read *, struct mtree *,\n\t\t    struct archive_entry *, struct mtree_option *, int *);\nstatic int\tread_data(struct archive_read *a,\n\t\t    const void **buff, size_t *size, int64_t *offset);\nstatic ssize_t\treadline(struct archive_read *, struct mtree *, char **, ssize_t);\nstatic int\tskip(struct archive_read *a);\nstatic int\tread_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int64_t\tmtree_atol10(char **);\nstatic int64_t\tmtree_atol8(char **);\nstatic int64_t\tmtree_atol(char **);\n\n/*\n * There's no standard for TIME_T_MAX/TIME_T_MIN.  So we compute them\n * here.  TODO: Move this to configure time, but be careful\n * about cross-compile environments.\n */\nstatic int64_t\nget_time_t_max(void)\n{\n#if defined(TIME_T_MAX)\n\treturn TIME_T_MAX;\n#else\n\t/* ISO C allows time_t to be a floating-point type,\n\t   but POSIX requires an integer type.  The following\n\t   should work on any system that follows the POSIX\n\t   conventions. */\n\tif (((time_t)0) < ((time_t)-1)) {\n\t\t/* Time_t is unsigned */\n\t\treturn (~(time_t)0);\n\t} else {\n\t\t/* Time_t is signed. */\n\t\t/* Assume it's the same as int64_t or int32_t */\n\t\tif (sizeof(time_t) == sizeof(int64_t)) {\n\t\t\treturn (time_t)INT64_MAX;\n\t\t} else {\n\t\t\treturn (time_t)INT32_MAX;\n\t\t}\n\t}\n#endif\n}\n\nstatic int64_t\nget_time_t_min(void)\n{\n#if defined(TIME_T_MIN)\n\treturn TIME_T_MIN;\n#else\n\tif (((time_t)0) < ((time_t)-1)) {\n\t\t/* Time_t is unsigned */\n\t\treturn (time_t)0;\n\t} else {\n\t\t/* Time_t is signed. */\n\t\tif (sizeof(time_t) == sizeof(int64_t)) {\n\t\t\treturn (time_t)INT64_MIN;\n\t\t} else {\n\t\t\treturn (time_t)INT32_MIN;\n\t\t}\n\t}\n#endif\n}\n\nstatic int\narchive_read_format_mtree_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (strcmp(key, \"checkfs\")  == 0) {\n\t\t/* Allows to read information missing from the mtree from the file system */\n\t\tif (val == NULL || val[0] == 0) {\n\t\t\tmtree->checkfs = 0;\n\t\t} else {\n\t\t\tmtree->checkfs = 1;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nstatic void\nfree_options(struct mtree_option *head)\n{\n\tstruct mtree_option *next;\n\n\tfor (; head != NULL; head = next) {\n\t\tnext = head->next;\n\t\tfree(head->value);\n\t\tfree(head);\n\t}\n}\n\nint\narchive_read_support_format_mtree(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct mtree *mtree;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_mtree\");\n\n\tmtree = (struct mtree *)malloc(sizeof(*mtree));\n\tif (mtree == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate mtree data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemset(mtree, 0, sizeof(*mtree));\n\tmtree->fd = -1;\n\n\tr = __archive_read_register_format(a, mtree, \"mtree\",\n           mtree_bid, archive_read_format_mtree_options, read_header, read_data, skip, NULL, cleanup, NULL, NULL);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(mtree);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ncleanup(struct archive_read *a)\n{\n\tstruct mtree *mtree;\n\tstruct mtree_entry *p, *q;\n\n\tmtree = (struct mtree *)(a->format->data);\n\n\tp = mtree->entries;\n\twhile (p != NULL) {\n\t\tq = p->next;\n\t\tfree(p->name);\n\t\tfree_options(p->options);\n\t\tfree(p);\n\t\tp = q;\n\t}\n\tarchive_string_free(&mtree->line);\n\tarchive_string_free(&mtree->current_dir);\n\tarchive_string_free(&mtree->contents_name);\n\tarchive_entry_linkresolver_free(mtree->resolver);\n\n\tfree(mtree->buff);\n\tfree(mtree);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nget_line_size(const char *b, ssize_t avail, ssize_t *nlsize)\n{\n\tssize_t len;\n\n\tlen = 0;\n\twhile (len < avail) {\n\t\tswitch (*b) {\n\t\tcase '\\0':/* Non-ascii character or control character. */\n\t\t\tif (nlsize != NULL)\n\t\t\t\t*nlsize = 0;\n\t\t\treturn (-1);\n\t\tcase '\\r':\n\t\t\tif (avail-len > 1 && b[1] == '\\n') {\n\t\t\t\tif (nlsize != NULL)\n\t\t\t\t\t*nlsize = 2;\n\t\t\t\treturn (len+2);\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase '\\n':\n\t\t\tif (nlsize != NULL)\n\t\t\t\t*nlsize = 1;\n\t\t\treturn (len+1);\n\t\tdefault:\n\t\t\tb++;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nlsize != NULL)\n\t\t*nlsize = 0;\n\treturn (avail);\n}\n\nstatic ssize_t\nnext_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\t/*\n\t * Read bytes more while it does not reach the end of line.\n\t */\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\t/* Increase reading bytes if it is not enough to at least\n\t\t * new two lines. */\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t/* Reading bytes reaches the end of file. */\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;/* Skip some bytes we already determinated. */\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}\n\n/*\n * Compare characters with a mtree keyword.\n * Returns the length of a mtree keyword if matched.\n * Returns 0 if not matched.\n */\nstatic int\nbid_keycmp(const char *p, const char *key, ssize_t len)\n{\n\tint match_len = 0;\n\n\twhile (len > 0 && *p && *key) {\n\t\tif (*p == *key) {\n\t\t\t--len;\n\t\t\t++p;\n\t\t\t++key;\n\t\t\t++match_len;\n\t\t\tcontinue;\n\t\t}\n\t\treturn (0);/* Not match */\n\t}\n\tif (*key != '\\0')\n\t\treturn (0);/* Not match */\n\n\t/* A following character should be specified characters */\n\tif (p[0] == '=' || p[0] == ' ' || p[0] == '\\t' ||\n\t    p[0] == '\\n' || p[0] == '\\r' ||\n\t   (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r')))\n\t\treturn (match_len);\n\treturn (0);/* Not match */\n}\n\n/*\n * Test whether the characters 'p' has is mtree keyword.\n * Returns the length of a detected keyword.\n * Returns 0 if any keywords were not found.\n */\nstatic int\nbid_keyword(const char *p,  ssize_t len)\n{\n\tstatic const char *keys_c[] = {\n\t\t\"content\", \"contents\", \"cksum\", NULL\n\t};\n\tstatic const char *keys_df[] = {\n\t\t\"device\", \"flags\", NULL\n\t};\n\tstatic const char *keys_g[] = {\n\t\t\"gid\", \"gname\", NULL\n\t};\n\tstatic const char *keys_il[] = {\n\t\t\"ignore\", \"inode\", \"link\", NULL\n\t};\n\tstatic const char *keys_m[] = {\n\t\t\"md5\", \"md5digest\", \"mode\", NULL\n\t};\n\tstatic const char *keys_no[] = {\n\t\t\"nlink\", \"nochange\", \"optional\", NULL\n\t};\n\tstatic const char *keys_r[] = {\n\t\t\"resdevice\", \"rmd160\", \"rmd160digest\", NULL\n\t};\n\tstatic const char *keys_s[] = {\n\t\t\"sha1\", \"sha1digest\",\n\t\t\"sha256\", \"sha256digest\",\n\t\t\"sha384\", \"sha384digest\",\n\t\t\"sha512\", \"sha512digest\",\n\t\t\"size\", NULL\n\t};\n\tstatic const char *keys_t[] = {\n\t\t\"tags\", \"time\", \"type\", NULL\n\t};\n\tstatic const char *keys_u[] = {\n\t\t\"uid\", \"uname\",\tNULL\n\t};\n\tconst char **keys;\n\tint i;\n\n\tswitch (*p) {\n\tcase 'c': keys = keys_c; break;\n\tcase 'd': case 'f': keys = keys_df; break;\n\tcase 'g': keys = keys_g; break;\n\tcase 'i': case 'l': keys = keys_il; break;\n\tcase 'm': keys = keys_m; break;\n\tcase 'n': case 'o': keys = keys_no; break;\n\tcase 'r': keys = keys_r; break;\n\tcase 's': keys = keys_s; break;\n\tcase 't': keys = keys_t; break;\n\tcase 'u': keys = keys_u; break;\n\tdefault: return (0);/* Unknown key */\n\t}\n\n\tfor (i = 0; keys[i] != NULL; i++) {\n\t\tint l = bid_keycmp(p, keys[i], len);\n\t\tif (l > 0)\n\t\t\treturn (l);\n\t}\n\treturn (0);/* Unknown key */\n}\n\n/*\n * Test whether there is a set of mtree keywords.\n * Returns the number of keyword.\n * Returns -1 if we got incorrect sequence.\n * This function expects a set of \"<space characters>keyword=value\".\n * When \"unset\" is specified, expects a set of \"<space characters>keyword\".\n */\nstatic int\nbid_keyword_list(const char *p,  ssize_t len, int unset, int last_is_path)\n{\n\tint l;\n\tint keycnt = 0;\n\n\twhile (len > 0 && *p) {\n\t\tint blank = 0;\n\n\t\t/* Test whether there are blank characters in the line. */\n\t\twhile (len >0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t++p;\n\t\t\t--len;\n\t\t\tblank = 1;\n\t\t}\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t\tbreak;\n\t\tif (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r'))\n\t\t\tbreak;\n\t\tif (!blank && !last_is_path) /* No blank character. */\n\t\t\treturn (-1);\n\t\tif (last_is_path && len == 0)\n\t\t\t\treturn (keycnt);\n\n\t\tif (unset) {\n\t\t\tl = bid_keycmp(p, \"all\", len);\n\t\t\tif (l > 0)\n\t\t\t\treturn (1);\n\t\t}\n\t\t/* Test whether there is a correct key in the line. */\n\t\tl = bid_keyword(p, len);\n\t\tif (l == 0)\n\t\t\treturn (-1);/* Unknown keyword was found. */\n\t\tp += l;\n\t\tlen -= l;\n\t\tkeycnt++;\n\n\t\t/* Skip value */\n\t\tif (*p == '=') {\n\t\t\tint value = 0;\n\t\t\t++p;\n\t\t\t--len;\n\t\t\twhile (len > 0 && *p != ' ' && *p != '\\t') {\n\t\t\t\t++p;\n\t\t\t\t--len;\n\t\t\t\tvalue = 1;\n\t\t\t}\n\t\t\t/* A keyword should have a its value unless\n\t\t\t * \"/unset\" operation. */ \n\t\t\tif (!unset && value == 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (keycnt);\n}\n\nstatic int\nbid_entry(const char *p, ssize_t len, ssize_t nl, int *last_is_path)\n{\n\tint f = 0;\n\tstatic const unsigned char safe_char[256] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 00 - 0F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 1F */\n\t\t/* !\"$%&'()*+,-./  EXCLUSION:( )(#) */\n\t\t0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 20 - 2F */\n\t\t/* 0123456789:;<>?  EXCLUSION:(=) */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, /* 30 - 3F */\n\t\t/* @ABCDEFGHIJKLMNO */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 40 - 4F */\n\t\t/* PQRSTUVWXYZ[\\]^_  */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 50 - 5F */\n\t\t/* `abcdefghijklmno */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 60 - 6F */\n\t\t/* pqrstuvwxyz{|}~ */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, /* 70 - 7F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 80 - 8F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 90 - 9F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* A0 - AF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* B0 - BF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* C0 - CF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* D0 - DF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* E0 - EF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* F0 - FF */\n\t};\n\tssize_t ll;\n\tconst char *pp = p;\n\tconst char * const pp_end = pp + len;\n\n\t*last_is_path = 0;\n\t/*\n\t * Skip the path-name which is quoted.\n\t */\n\tfor (;pp < pp_end; ++pp) {\n\t\tif (!safe_char[*(const unsigned char *)pp]) {\n\t\t\tif (*pp != ' ' && *pp != '\\t' && *pp != '\\r'\n\t\t\t    && *pp != '\\n')\n\t\t\t\tf = 0;\n\t\t\tbreak;\n\t\t}\n\t\tf = 1;\n\t}\n\tll = pp_end - pp;\n\n\t/* If a path-name was not found at the first, try to check\n\t * a mtree format(a.k.a form D) ``NetBSD's mtree -D'' creates,\n\t * which places the path-name at the last. */\n\tif (f == 0) {\n\t\tconst char *pb = p + len - nl;\n\t\tint name_len = 0;\n\t\tint slash;\n\n\t\t/* The form D accepts only a single line for an entry. */\n\t\tif (pb-2 >= p &&\n\t\t    pb[-1] == '\\\\' && (pb[-2] == ' ' || pb[-2] == '\\t'))\n\t\t\treturn (-1);\n\t\tif (pb-1 >= p && pb[-1] == '\\\\')\n\t\t\treturn (-1);\n\n\t\tslash = 0;\n\t\twhile (p <= --pb && *pb != ' ' && *pb != '\\t') {\n\t\t\tif (!safe_char[*(const unsigned char *)pb])\n\t\t\t\treturn (-1);\n\t\t\tname_len++;\n\t\t\t/* The pathname should have a slash in this\n\t\t\t * format. */\n\t\t\tif (*pb == '/')\n\t\t\t\tslash = 1;\n\t\t}\n\t\tif (name_len == 0 || slash == 0)\n\t\t\treturn (-1);\n\t\t/* If '/' is placed at the first in this field, this is not\n\t\t * a valid filename. */\n\t\tif (pb[1] == '/')\n\t\t\treturn (-1);\n\t\tll = len - nl - name_len;\n\t\tpp = p;\n\t\t*last_is_path = 1;\n\t}\n\n\treturn (bid_keyword_list(pp, ll, 0, *last_is_path));\n}\n\n#define MAX_BID_ENTRY\t3\n\nstatic int\nmtree_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *signature = \"#mtree\";\n\tconst char *p;\n\n\t(void)best_bid; /* UNUSED */\n\n\t/* Now let's look at the actual header and see if it matches. */\n\tp = __archive_read_ahead(a, strlen(signature), NULL);\n\tif (p == NULL)\n\t\treturn (-1);\n\n\tif (memcmp(p, signature, strlen(signature)) == 0)\n\t\treturn (8 * (int)strlen(signature));\n\n\t/*\n\t * There is not a mtree signature. Let's try to detect mtree format.\n\t */\n\treturn (detect_form(a, NULL));\n}\n\nstatic int\ndetect_form(struct archive_read *a, int *is_form_d)\n{\n\tconst char *p;\n\tssize_t avail, ravail;\n\tssize_t detected_bytes = 0, len, nl;\n\tint entry_cnt = 0, multiline = 0;\n\tint form_D = 0;/* The archive is generated by `NetBSD mtree -D'\n\t\t\t* (In this source we call it `form D') . */\n\n\tif (is_form_d != NULL)\n\t\t*is_form_d = 0;\n\tp = __archive_read_ahead(a, 1, &avail);\n\tif (p == NULL)\n\t\treturn (-1);\n\travail = avail;\n\tfor (;;) {\n\t\tlen = next_line(a, &p, &avail, &ravail, &nl);\n\t\t/* The terminal character of the line should be\n\t\t * a new line character, '\\r\\n' or '\\n'. */\n\t\tif (len <= 0 || nl == 0)\n\t\t\tbreak;\n\t\tif (!multiline) {\n\t\t\t/* Leading whitespace is never significant,\n\t\t\t * ignore it. */\n\t\t\twhile (len > 0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t\t++p;\n\t\t\t\t--avail;\n\t\t\t\t--len;\n\t\t\t}\n\t\t\t/* Skip comment or empty line. */ \n\t\t\tif (p[0] == '#' || p[0] == '\\n' || p[0] == '\\r') {\n\t\t\t\tp += len;\n\t\t\t\tavail -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* A continuance line; the terminal\n\t\t\t * character of previous line was '\\' character. */\n\t\t\tif (bid_keyword_list(p, len, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (multiline == 1)\n\t\t\t\tdetected_bytes += len;\n\t\t\tif (p[len-nl-1] != '\\\\') {\n\t\t\t\tif (multiline == 1 &&\n\t\t\t\t    ++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\tbreak;\n\t\t\t\tmultiline = 0;\n\t\t\t}\n\t\t\tp += len;\n\t\t\tavail -= len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p[0] != '/') {\n\t\t\tint last_is_path, keywords;\n\n\t\t\tkeywords = bid_entry(p, len, nl, &last_is_path);\n\t\t\tif (keywords >= 0) {\n\t\t\t\tdetected_bytes += len;\n\t\t\t\tif (form_D == 0) {\n\t\t\t\t\tif (last_is_path)\n\t\t\t\t\t\tform_D = 1;\n\t\t\t\t\telse if (keywords > 0)\n\t\t\t\t\t\t/* This line is not `form D'. */\n\t\t\t\t\t\tform_D = -1;\n\t\t\t\t} else if (form_D == 1) {\n\t\t\t\t\tif (!last_is_path && keywords > 0)\n\t\t\t\t\t\t/* This this is not `form D'\n\t\t\t\t\t\t * and We cannot accept mixed\n\t\t\t\t\t\t * format. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!last_is_path && p[len-nl-1] == '\\\\')\n\t\t\t\t\t/* This line continues. */\n\t\t\t\t\tmultiline = 1;\n\t\t\t\telse {\n\t\t\t\t\t/* We've got plenty of correct lines\n\t\t\t\t\t * to assume that this file is a mtree\n\t\t\t\t\t * format. */\n\t\t\t\t\tif (++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (bid_keyword_list(p+4, len-4, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\t/* This line continues. */\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (bid_keyword_list(p+6, len-6, 1, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\t/* This line continues. */\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else\n\t\t\tbreak;\n\n\t\t/* Test next line. */\n\t\tp += len;\n\t\tavail -= len;\n\t}\n\tif (entry_cnt >= MAX_BID_ENTRY || (entry_cnt > 0 && len == 0)) {\n\t\tif (is_form_d != NULL) {\n\t\t\tif (form_D == 1)\n\t\t\t\t*is_form_d = 1;\n\t\t}\n\t\treturn (32);\n\t}\n\n\treturn (0);\n}\n\n/*\n * The extended mtree format permits multiple lines specifying\n * attributes for each file.  For those entries, only the last line\n * is actually used.  Practically speaking, that means we have\n * to read the entire mtree file into memory up front.\n *\n * The parsing is done in two steps.  First, it is decided if a line\n * changes the global defaults and if it is, processed accordingly.\n * Otherwise, the options of the line are merged with the current\n * global options.\n */\nstatic int\nadd_option(struct archive_read *a, struct mtree_option **global,\n    const char *value, size_t len)\n{\n\tstruct mtree_option *opt;\n\n\tif ((opt = malloc(sizeof(*opt))) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((opt->value = malloc(len + 1)) == NULL) {\n\t\tfree(opt);\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemcpy(opt->value, value, len);\n\topt->value[len] = '\\0';\n\topt->next = *global;\n\t*global = opt;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nremove_option(struct mtree_option **global, const char *value, size_t len)\n{\n\tstruct mtree_option *iter, *last;\n\n\tlast = NULL;\n\tfor (iter = *global; iter != NULL; last = iter, iter = iter->next) {\n\t\tif (strncmp(iter->value, value, len) == 0 &&\n\t\t    (iter->value[len] == '\\0' ||\n\t\t     iter->value[len] == '='))\n\t\t\tbreak;\n\t}\n\tif (iter == NULL)\n\t\treturn;\n\tif (last == NULL)\n\t\t*global = iter->next;\n\telse\n\t\tlast->next = iter->next;\n\n\tfree(iter->value);\n\tfree(iter);\n}\n\nstatic int\nprocess_global_set(struct archive_read *a,\n    struct mtree_option **global, const char *line)\n{\n\tconst char *next, *eq;\n\tsize_t len;\n\tint r;\n\n\tline += 4;\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tnext = line + strcspn(line, \" \\t\\r\\n\");\n\t\teq = strchr(line, '=');\n\t\tif (eq > next)\n\t\t\tlen = next - line;\n\t\telse\n\t\t\tlen = eq - line;\n\n\t\tremove_option(global, line, len);\n\t\tr = add_option(a, global, line, next - line);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tline = next;\n\t}\n}\n\nstatic int\nprocess_global_unset(struct archive_read *a,\n    struct mtree_option **global, const char *line)\n{\n\tconst char *next;\n\tsize_t len;\n\n\tline += 6;\n\tif (strchr(line, '=') != NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"/unset shall not contain `='\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tlen = strcspn(line, \" \\t\\r\\n\");\n\n\t\tif (len == 3 && strncmp(line, \"all\", 3) == 0) {\n\t\t\tfree_options(*global);\n\t\t\t*global = NULL;\n\t\t} else {\n\t\t\tremove_option(global, line, len);\n\t\t}\n\n\t\tline += len;\n\t}\n}\n\nstatic int\nprocess_add_entry(struct archive_read *a, struct mtree *mtree,\n    struct mtree_option **global, const char *line, ssize_t line_len,\n    struct mtree_entry **last_entry, int is_form_d)\n{\n\tstruct mtree_entry *entry;\n\tstruct mtree_option *iter;\n\tconst char *next, *eq, *name, *end;\n\tsize_t name_len, len;\n\tint r, i;\n\n\tif ((entry = malloc(sizeof(*entry))) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tentry->next = NULL;\n\tentry->options = NULL;\n\tentry->name = NULL;\n\tentry->used = 0;\n\tentry->full = 0;\n\n\t/* Add this entry to list. */\n\tif (*last_entry == NULL)\n\t\tmtree->entries = entry;\n\telse\n\t\t(*last_entry)->next = entry;\n\t*last_entry = entry;\n\n\tif (is_form_d) {\n\t\t/* Filename is last item on line. */\n\t\t/* Adjust line_len to trim trailing whitespace */\n\t\twhile (line_len > 0) {\n\t\t\tchar last_character = line[line_len - 1];\n\t\t\tif (last_character == '\\r'\n\t\t\t    || last_character == '\\n'\n\t\t\t    || last_character == '\\t'\n\t\t\t    || last_character == ' ') {\n\t\t\t\tline_len--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Name starts after the last whitespace separator */\n\t\tname = line;\n\t\tfor (i = 0; i < line_len; i++) {\n\t\t\tif (line[i] == '\\r'\n\t\t\t    || line[i] == '\\n'\n\t\t\t    || line[i] == '\\t'\n\t\t\t    || line[i] == ' ') {\n\t\t\t\tname = line + i + 1;\n\t\t\t}\n\t\t}\n\t\tname_len = line + line_len - name;\n\t\tend = name;\n\t} else {\n\t\t/* Filename is first item on line */\n\t\tname_len = strcspn(line, \" \\t\\r\\n\");\n\t\tname = line;\n\t\tline += name_len;\n\t\tend = line + line_len;\n\t}\n\t/* name/name_len is the name within the line. */\n\t/* line..end brackets the entire line except the name */\n\n\tif ((entry->name = malloc(name_len + 1)) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tmemcpy(entry->name, name, name_len);\n\tentry->name[name_len] = '\\0';\n\tparse_escapes(entry->name, entry);\n\n\tfor (iter = *global; iter != NULL; iter = iter->next) {\n\t\tr = add_option(a, &entry->options, iter->value,\n\t\t    strlen(iter->value));\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tif (next >= end)\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tnext = line + strcspn(line, \" \\t\\r\\n\");\n\t\teq = strchr(line, '=');\n\t\tif (eq == NULL || eq > next)\n\t\t\tlen = next - line;\n\t\telse\n\t\t\tlen = eq - line;\n\n\t\tremove_option(&entry->options, line, len);\n\t\tr = add_option(a, &entry->options, line, next - line);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tline = next;\n\t}\n}\n\nstatic int\nread_mtree(struct archive_read *a, struct mtree *mtree)\n{\n\tssize_t len;\n\tuintmax_t counter;\n\tchar *p;\n\tstruct mtree_option *global;\n\tstruct mtree_entry *last_entry;\n\tint r, is_form_d;\n\n\tmtree->archive_format = ARCHIVE_FORMAT_MTREE;\n\tmtree->archive_format_name = \"mtree\";\n\n\tglobal = NULL;\n\tlast_entry = NULL;\n\n\t(void)detect_form(a, &is_form_d);\n\n\tfor (counter = 1; ; ++counter) {\n\t\tlen = readline(a, mtree, &p, 65536);\n\t\tif (len == 0) {\n\t\t\tmtree->this_entry = mtree->entries;\n\t\t\tfree_options(global);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tif (len < 0) {\n\t\t\tfree_options(global);\n\t\t\treturn ((int)len);\n\t\t}\n\t\t/* Leading whitespace is never significant, ignore it. */\n\t\twhile (*p == ' ' || *p == '\\t') {\n\t\t\t++p;\n\t\t\t--len;\n\t\t}\n\t\t/* Skip content lines and blank lines. */\n\t\tif (*p == '#')\n\t\t\tcontinue;\n\t\tif (*p == '\\r' || *p == '\\n' || *p == '\\0')\n\t\t\tcontinue;\n\t\tif (*p != '/') {\n\t\t\tr = process_add_entry(a, mtree, &global, p, len,\n\t\t\t    &last_entry, is_form_d);\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (p[4] != ' ' && p[4] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_set(a, &global, p);\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (p[6] != ' ' && p[6] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_unset(a, &global, p);\n\t\t} else\n\t\t\tbreak;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tfree_options(global);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Can't parse line %ju\", counter);\n\tfree_options(global);\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Read in the entire mtree file into memory on the first request.\n * Then use the next unused file to satisfy each header request.\n */\nstatic int\nread_header(struct archive_read *a, struct archive_entry *entry)\n{\n\tstruct mtree *mtree;\n\tchar *p;\n\tint r, use_next;\n\n\tmtree = (struct mtree *)(a->format->data);\n\n\tif (mtree->fd >= 0) {\n\t\tclose(mtree->fd);\n\t\tmtree->fd = -1;\n\t}\n\n\tif (mtree->entries == NULL) {\n\t\tmtree->resolver = archive_entry_linkresolver_new();\n\t\tif (mtree->resolver == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tarchive_entry_linkresolver_set_strategy(mtree->resolver,\n\t\t    ARCHIVE_FORMAT_MTREE);\n\t\tr = read_mtree(a, mtree);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\ta->archive.archive_format = mtree->archive_format;\n\ta->archive.archive_format_name = mtree->archive_format_name;\n\n\tfor (;;) {\n\t\tif (mtree->this_entry == NULL)\n\t\t\treturn (ARCHIVE_EOF);\n\t\tif (strcmp(mtree->this_entry->name, \"..\") == 0) {\n\t\t\tmtree->this_entry->used = 1;\n\t\t\tif (archive_strlen(&mtree->current_dir) > 0) {\n\t\t\t\t/* Roll back current path. */\n\t\t\t\tp = mtree->current_dir.s\n\t\t\t\t    + mtree->current_dir.length - 1;\n\t\t\t\twhile (p >= mtree->current_dir.s && *p != '/')\n\t\t\t\t\t--p;\n\t\t\t\tif (p >= mtree->current_dir.s)\n\t\t\t\t\t--p;\n\t\t\t\tmtree->current_dir.length\n\t\t\t\t    = p - mtree->current_dir.s + 1;\n\t\t\t}\n\t\t}\n\t\tif (!mtree->this_entry->used) {\n\t\t\tuse_next = 0;\n\t\t\tr = parse_file(a, entry, mtree, mtree->this_entry,\n\t\t\t\t&use_next);\n\t\t\tif (use_next == 0)\n\t\t\t\treturn (r);\n\t\t}\n\t\tmtree->this_entry = mtree->this_entry->next;\n\t}\n}\n\n/*\n * A single file can have multiple lines contribute specifications.\n * Parse as many lines as necessary, then pull additional information\n * from a backing file on disk as necessary.\n */\nstatic int\nparse_file(struct archive_read *a, struct archive_entry *entry,\n    struct mtree *mtree, struct mtree_entry *mentry, int *use_next)\n{\n\tconst char *path;\n\tstruct stat st_storage, *st;\n\tstruct mtree_entry *mp;\n\tstruct archive_entry *sparse_entry;\n\tint r = ARCHIVE_OK, r1, parsed_kws;\n\n\tmentry->used = 1;\n\n\t/* Initialize reasonable defaults. */\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tarchive_string_empty(&mtree->contents_name);\n\n\t/* Parse options from this line. */\n\tparsed_kws = 0;\n\tr = parse_line(a, entry, mtree, mentry, &parsed_kws);\n\n\tif (mentry->full) {\n\t\tarchive_entry_copy_pathname(entry, mentry->name);\n\t\t/*\n\t\t * \"Full\" entries are allowed to have multiple lines\n\t\t * and those lines aren't required to be adjacent.  We\n\t\t * don't support multiple lines for \"relative\" entries\n\t\t * nor do we make any attempt to merge data from\n\t\t * separate \"relative\" and \"full\" entries.  (Merging\n\t\t * \"relative\" and \"full\" entries would require dealing\n\t\t * with pathname canonicalization, which is a very\n\t\t * tricky subject.)\n\t\t */\n\t\tfor (mp = mentry->next; mp != NULL; mp = mp->next) {\n\t\t\tif (mp->full && !mp->used\n\t\t\t    && strcmp(mentry->name, mp->name) == 0) {\n\t\t\t\t/* Later lines override earlier ones. */\n\t\t\t\tmp->used = 1;\n\t\t\t\tr1 = parse_line(a, entry, mtree, mp,\n\t\t\t\t    &parsed_kws);\n\t\t\t\tif (r1 < r)\n\t\t\t\t\tr = r1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Relative entries require us to construct\n\t\t * the full path and possibly update the\n\t\t * current directory.\n\t\t */\n\t\tsize_t n = archive_strlen(&mtree->current_dir);\n\t\tif (n > 0)\n\t\t\tarchive_strcat(&mtree->current_dir, \"/\");\n\t\tarchive_strcat(&mtree->current_dir, mentry->name);\n\t\tarchive_entry_copy_pathname(entry, mtree->current_dir.s);\n\t\tif (archive_entry_filetype(entry) != AE_IFDIR)\n\t\t\tmtree->current_dir.length = n;\n\t}\n\n\tif (mtree->checkfs) {\n\t\t/*\n\t\t * Try to open and stat the file to get the real size\n\t\t * and other file info.  It would be nice to avoid\n\t\t * this here so that getting a listing of an mtree\n\t\t * wouldn't require opening every referenced contents\n\t\t * file.  But then we wouldn't know the actual\n\t\t * contents size, so I don't see a really viable way\n\t\t * around this.  (Also, we may want to someday pull\n\t\t * other unspecified info from the contents file on\n\t\t * disk.)\n\t\t */\n\t\tmtree->fd = -1;\n\t\tif (archive_strlen(&mtree->contents_name) > 0)\n\t\t\tpath = mtree->contents_name.s;\n\t\telse\n\t\t\tpath = archive_entry_pathname(entry);\n\n\t\tif (archive_entry_filetype(entry) == AE_IFREG ||\n\t\t\t\tarchive_entry_filetype(entry) == AE_IFDIR) {\n\t\t\tmtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(mtree->fd);\n\t\t\tif (mtree->fd == -1 &&\n\t\t\t\t(errno != ENOENT ||\n\t\t\t\t archive_strlen(&mtree->contents_name) > 0)) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Can't open %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\n\t\tst = &st_storage;\n\t\tif (mtree->fd >= 0) {\n\t\t\tif (fstat(mtree->fd, st) == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Could not fstat %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\t/* If we can't stat it, don't keep it open. */\n\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tst = NULL;\n\t\t\t}\n\t\t} else if (lstat(path, st) == -1) {\n\t\t\tst = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Check for a mismatch between the type in the specification\n\t\t * and the type of the contents object on disk.\n\t\t */\n\t\tif (st != NULL) {\n\t\t\tif (((st->st_mode & S_IFMT) == S_IFREG &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFREG)\n#ifdef S_IFLNK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFLNK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFLNK)\n#endif\n#ifdef S_IFSOCK\n\t\t\t  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFSOCK)\n#endif\n#ifdef S_IFCHR\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFCHR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFCHR)\n#endif\n#ifdef S_IFBLK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFBLK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFBLK)\n#endif\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFDIR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFDIR)\n#ifdef S_IFIFO\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFIFO &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFIFO)\n#endif\n\t\t\t) {\n\t\t\t\t/* Types match. */\n\t\t\t} else {\n\t\t\t\t/* Types don't match; bail out gracefully. */\n\t\t\t\tif (mtree->fd >= 0)\n\t\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tif (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t\t\t/* It's not an error for an optional\n\t\t\t\t\t * entry to not match disk. */\n\t\t\t\t\t*use_next = 1;\n\t\t\t\t} else if (r == ARCHIVE_OK) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"mtree specification has different\"\n\t\t\t\t\t    \" type for %s\",\n\t\t\t\t\t    archive_entry_pathname(entry));\n\t\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\t}\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there is a contents file on disk, pick some of the\n\t\t * metadata from that file.  For most of these, we only\n\t\t * set it from the contents if it wasn't already parsed\n\t\t * from the specification.\n\t\t */\n\t\tif (st != NULL) {\n\t\t\tif (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||\n\t\t\t\t(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&\n\t\t\t\t(archive_entry_filetype(entry) == AE_IFCHR ||\n\t\t\t\t archive_entry_filetype(entry) == AE_IFBLK))\n\t\t\t\tarchive_entry_set_rdev(entry, st->st_rdev);\n\t\t\tif ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_gid(entry, st->st_gid);\n\t\t\tif ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_uid(entry, st->st_uid);\n\t\t\tif ((parsed_kws & MTREE_HAS_MTIME) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtimespec.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtim.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIME_N\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_n);\n#elif HAVE_STRUCT_STAT_ST_UMTIME\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_umtime*1000);\n#elif HAVE_STRUCT_STAT_ST_MTIME_USEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_usec*1000);\n#else\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime, 0);\n#endif\n\t\t\t}\n\t\t\tif ((parsed_kws & MTREE_HAS_NLINK) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_nlink(entry, st->st_nlink);\n\t\t\tif ((parsed_kws & MTREE_HAS_PERM) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_perm(entry, st->st_mode);\n\t\t\tif ((parsed_kws & MTREE_HAS_SIZE) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_size(entry, st->st_size);\n\t\t\tarchive_entry_set_ino(entry, st->st_ino);\n\t\t\tarchive_entry_set_dev(entry, st->st_dev);\n\n\t\t\tarchive_entry_linkify(mtree->resolver, &entry,\n\t\t\t\t&sparse_entry);\n\t\t} else if (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t/*\n\t\t\t * Couldn't open the entry, stat it or the on-disk type\n\t\t\t * didn't match.  If this entry is optional, just\n\t\t\t * ignore it and read the next header entry.\n\t\t\t */\n\t\t\t*use_next = 1;\n\t\t\treturn ARCHIVE_OK;\n\t\t}\n\t}\n\n\tmtree->cur_size = archive_entry_size(entry);\n\tmtree->offset = 0;\n\n\treturn r;\n}\n\n/*\n * Each line contains a sequence of keywords.\n */\nstatic int\nparse_line(struct archive_read *a, struct archive_entry *entry,\n    struct mtree *mtree, struct mtree_entry *mp, int *parsed_kws)\n{\n\tstruct mtree_option *iter;\n\tint r = ARCHIVE_OK, r1;\n\n\tfor (iter = mp->options; iter != NULL; iter = iter->next) {\n\t\tr1 = parse_keyword(a, mtree, entry, iter, parsed_kws);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\tif (r == ARCHIVE_OK && (*parsed_kws & MTREE_HAS_TYPE) == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Missing type keyword in mtree specification\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (r);\n}\n\n/*\n * Device entries have one of the following forms:\n *  - raw dev_t\n *  - format,major,minor[,subdevice]\n * When parsing succeeded, `pdev' will contain the appropriate dev_t value.\n */\n\n/* strsep() is not in C90, but strcspn() is. */\n/* Taken from http://unixpapa.com/incnote/string.html */\nstatic char *\nla_strsep(char **sp, const char *sep)\n{\n\tchar *p, *s;\n\tif (sp == NULL || *sp == NULL || **sp == '\\0')\n\t\treturn(NULL);\n\ts = *sp;\n\tp = s + strcspn(s, sep);\n\tif (*p != '\\0')\n\t\t*p++ = '\\0';\n\t*sp = p;\n\treturn(s);\n}\n\nstatic int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}\n\n/*\n * Parse a single keyword and its value.\n */\nstatic int\nparse_keyword(struct archive_read *a, struct mtree *mtree,\n    struct archive_entry *entry, struct mtree_option *opt, int *parsed_kws)\n{\n\tchar *val, *key;\n\n\tkey = opt->value;\n\n\tif (*key == '\\0')\n\t\treturn (ARCHIVE_OK);\n\n\tif (strcmp(key, \"nochange\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_NOCHANGE;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"optional\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_OPTIONAL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"ignore\") == 0) {\n\t\t/*\n\t\t * The mtree processing is not recursive, so\n\t\t * recursion will only happen for explicitly listed\n\t\t * entries.\n\t\t */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tval = strchr(key, '=');\n\tif (val == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed attribute \\\"%s\\\" (%d)\", key, key[0]);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t*val = '\\0';\n\t++val;\n\n\tswitch (key[0]) {\n\tcase 'c':\n\t\tif (strcmp(key, \"content\") == 0\n\t\t    || strcmp(key, \"contents\") == 0) {\n\t\t\tparse_escapes(val, NULL);\n\t\t\tarchive_strcpy(&mtree->contents_name, val);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"cksum\") == 0)\n\t\t\tbreak;\n\tcase 'd':\n\t\tif (strcmp(key, \"device\") == 0) {\n\t\t\t/* stat(2) st_rdev field, e.g. the major/minor IDs\n\t\t\t * of a char/block special file */\n\t\t\tint r;\n\t\t\tdev_t dev;\n\n\t\t\t*parsed_kws |= MTREE_HAS_DEVICE;\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_rdev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\tcase 'f':\n\t\tif (strcmp(key, \"flags\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_FFLAGS;\n\t\t\tarchive_entry_copy_fflags_text(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'g':\n\t\tif (strcmp(key, \"gid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GID;\n\t\t\tarchive_entry_set_gid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"gname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GNAME;\n\t\t\tarchive_entry_copy_gname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'i':\n\t\tif (strcmp(key, \"inode\") == 0) {\n\t\t\tarchive_entry_set_ino(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'l':\n\t\tif (strcmp(key, \"link\") == 0) {\n\t\t\tarchive_entry_copy_symlink(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'm':\n\t\tif (strcmp(key, \"md5\") == 0 || strcmp(key, \"md5digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"mode\") == 0) {\n\t\t\tif (val[0] >= '0' && val[0] <= '9') {\n\t\t\t\t*parsed_kws |= MTREE_HAS_PERM;\n\t\t\t\tarchive_entry_set_perm(entry,\n\t\t\t\t    (mode_t)mtree_atol8(&val));\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Symbolic mode \\\"%s\\\" unsupported\", val);\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase 'n':\n\t\tif (strcmp(key, \"nlink\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_NLINK;\n\t\t\tarchive_entry_set_nlink(entry,\n\t\t\t\t(unsigned int)mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'r':\n\t\tif (strcmp(key, \"resdevice\") == 0) {\n\t\t\t/* stat(2) st_dev field, e.g. the device ID where the\n\t\t\t * inode resides */\n\t\t\tint r;\n\t\t\tdev_t dev;\n\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_dev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\t\tif (strcmp(key, \"rmd160\") == 0 ||\n\t\t    strcmp(key, \"rmd160digest\") == 0)\n\t\t\tbreak;\n\tcase 's':\n\t\tif (strcmp(key, \"sha1\") == 0 || strcmp(key, \"sha1digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha256\") == 0 ||\n\t\t    strcmp(key, \"sha256digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha384\") == 0 ||\n\t\t    strcmp(key, \"sha384digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha512\") == 0 ||\n\t\t    strcmp(key, \"sha512digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"size\") == 0) {\n\t\t\tarchive_entry_set_size(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 't':\n\t\tif (strcmp(key, \"tags\") == 0) {\n\t\t\t/*\n\t\t\t * Comma delimited list of tags.\n\t\t\t * Ignore the tags for now, but the interface\n\t\t\t * should be extended to allow inclusion/exclusion.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"time\") == 0) {\n\t\t\tint64_t m;\n\t\t\tint64_t my_time_t_max = get_time_t_max();\n\t\t\tint64_t my_time_t_min = get_time_t_min();\n\t\t\tlong ns = 0;\n\n\t\t\t*parsed_kws |= MTREE_HAS_MTIME;\n\t\t\tm = mtree_atol10(&val);\n\t\t\t/* Replicate an old mtree bug:\n\t\t\t * 123456789.1 represents 123456789\n\t\t\t * seconds and 1 nanosecond. */\n\t\t\tif (*val == '.') {\n\t\t\t\t++val;\n\t\t\t\tns = (long)mtree_atol10(&val);\n\t\t\t} else\n\t\t\t\tns = 0;\n\t\t\tif (m > my_time_t_max)\n\t\t\t\tm = my_time_t_max;\n\t\t\telse if (m < my_time_t_min)\n\t\t\t\tm = my_time_t_min;\n\t\t\tarchive_entry_set_mtime(entry, (time_t)m, ns);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"type\") == 0) {\n\t\t\tswitch (val[0]) {\n\t\t\tcase 'b':\n\t\t\t\tif (strcmp(val, \"block\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry, AE_IFBLK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'c':\n\t\t\t\tif (strcmp(val, \"char\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFCHR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'd':\n\t\t\t\tif (strcmp(val, \"dir\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFDIR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'f':\n\t\t\t\tif (strcmp(val, \"fifo\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFIFO);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strcmp(val, \"file\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFREG);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'l':\n\t\t\t\tif (strcmp(val, \"link\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFLNK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Unrecognized file type \\\"%s\\\"; \"\n\t\t\t\t    \"assuming \\\"file\\\"\", val);\n\t\t\t\tarchive_entry_set_filetype(entry, AE_IFREG);\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\t*parsed_kws |= MTREE_HAS_TYPE;\n\t\t\tbreak;\n\t\t}\n\tcase 'u':\n\t\tif (strcmp(key, \"uid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UID;\n\t\t\tarchive_entry_set_uid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"uname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UNAME;\n\t\t\tarchive_entry_copy_uname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unrecognized key %s=%s\", key, val);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nread_data(struct archive_read *a, const void **buff, size_t *size,\n    int64_t *offset)\n{\n\tsize_t bytes_to_read;\n\tssize_t bytes_read;\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd < 0) {\n\t\t*buff = NULL;\n\t\t*offset = 0;\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tif (mtree->buff == NULL) {\n\t\tmtree->buffsize = 64 * 1024;\n\t\tmtree->buff = malloc(mtree->buffsize);\n\t\tif (mtree->buff == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t*buff = mtree->buff;\n\t*offset = mtree->offset;\n\tif ((int64_t)mtree->buffsize > mtree->cur_size - mtree->offset)\n\t\tbytes_to_read = (size_t)(mtree->cur_size - mtree->offset);\n\telse\n\t\tbytes_to_read = mtree->buffsize;\n\tbytes_read = read(mtree->fd, mtree->buff, bytes_to_read);\n\tif (bytes_read < 0) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't read\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (bytes_read == 0) {\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tmtree->offset += bytes_read;\n\t*size = bytes_read;\n\treturn (ARCHIVE_OK);\n}\n\n/* Skip does nothing except possibly close the contents file. */\nstatic int\nskip(struct archive_read *a)\n{\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd >= 0) {\n\t\tclose(mtree->fd);\n\t\tmtree->fd = -1;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Since parsing backslash sequences always makes strings shorter,\n * we can always do this conversion in-place.\n */\nstatic void\nparse_escapes(char *src, struct mtree_entry *mentry)\n{\n\tchar *dest = src;\n\tchar c;\n\n\tif (mentry != NULL && strcmp(src, \".\") == 0)\n\t\tmentry->full = 1;\n\n\twhile (*src != '\\0') {\n\t\tc = *src++;\n\t\tif (c == '/' && mentry != NULL)\n\t\t\tmentry->full = 1;\n\t\tif (c == '\\\\') {\n\t\t\tswitch (src[0]) {\n\t\t\tcase '0':\n\t\t\t\tif (src[1] < '0' || src[1] > '7') {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tif (src[1] >= '0' && src[1] <= '7' &&\n\t\t\t\t    src[2] >= '0' && src[2] <= '7') {\n\t\t\t\t\tc = (src[0] - '0') << 6;\n\t\t\t\t\tc |= (src[1] - '0') << 3;\n\t\t\t\t\tc |= (src[2] - '0');\n\t\t\t\t\tsrc += 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tc = '\\a';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tc = ' ';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tc = '\\v';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*dest++ = c;\n\t}\n\t*dest = '\\0';\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol8(char **p)\n{\n\tint64_t\tl, limit, last_digit_limit;\n\tint digit, base;\n\n\tbase = 8;\n\tlimit = INT64_MAX / base;\n\tlast_digit_limit = INT64_MAX % base;\n\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l>limit || (l == limit && digit > last_digit_limit)) {\n\t\t\tl = INT64_MAX; /* Truncate on overflow. */\n\t\t\tbreak;\n\t\t}\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (l);\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol10(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\n\tbase = 10;\n\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (sign < 0) ? -l : l;\n}\n\n/* Parse a hex digit. */\nstatic int\nparsehex(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\telse if (c >= 'a' && c <= 'f')\n\t\treturn c - 'a';\n\telse if (c >= 'A' && c <= 'F')\n\t\treturn c - 'A';\n\telse\n\t\treturn -1;\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol16(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\n\tbase = 16;\n\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\n\tl = 0;\n\tdigit = parsehex(**p);\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = parsehex(*++(*p));\n\t}\n\treturn (sign < 0) ? -l : l;\n}\n\nstatic int64_t\nmtree_atol(char **p)\n{\n\tif (**p != '0')\n\t\treturn mtree_atol10(p);\n\tif ((*p)[1] == 'x' || (*p)[1] == 'X') {\n\t\t*p += 2;\n\t\treturn mtree_atol16(p);\n\t}\n\treturn mtree_atol8(p);\n}\n\n/*\n * Returns length of line (including trailing newline)\n * or negative on error.  'start' argument is updated to\n * point to first character of line.\n */\nstatic ssize_t\nreadline(struct archive_read *a, struct mtree *mtree, char **start,\n    ssize_t limit)\n{\n\tssize_t bytes_read;\n\tssize_t total_size = 0;\n\tssize_t find_off = 0;\n\tconst void *t;\n\tvoid *nl;\n\tchar *u;\n\n\t/* Accumulate line in a line buffer. */\n\tfor (;;) {\n\t\t/* Read some more. */\n\t\tt = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (t == NULL)\n\t\t\treturn (0);\n\t\tif (bytes_read < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tnl = memchr(t, '\\n', bytes_read);\n\t\t/* If we found '\\n', trim the read to end exactly there. */\n\t\tif (nl != NULL) {\n\t\t\tbytes_read = ((const char *)nl) - ((const char *)t) + 1;\n\t\t}\n\t\tif (total_size + bytes_read + 1 > limit) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Line too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (archive_string_ensure(&mtree->line,\n\t\t\ttotal_size + bytes_read + 1) == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate working buffer\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Append new bytes to string. */\n\t\tmemcpy(mtree->line.s + total_size, t, bytes_read);\n\t\t__archive_read_consume(a, bytes_read);\n\t\ttotal_size += bytes_read;\n\t\tmtree->line.s[total_size] = '\\0';\n\n\t\tfor (u = mtree->line.s + find_off; *u; ++u) {\n\t\t\tif (u[0] == '\\n') {\n\t\t\t\t/* Ends with unescaped newline. */\n\t\t\t\t*start = mtree->line.s;\n\t\t\t\treturn total_size;\n\t\t\t} else if (u[0] == '#') {\n\t\t\t\t/* Ends with comment sequence #...\\n */\n\t\t\t\tif (nl == NULL) {\n\t\t\t\t\t/* But we've not found the \\n yet */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (u[0] == '\\\\') {\n\t\t\t\tif (u[1] == '\\n') {\n\t\t\t\t\t/* Trim escaped newline. */\n\t\t\t\t\ttotal_size -= 2;\n\t\t\t\t\tmtree->line.s[total_size] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (u[1] != '\\0') {\n\t\t\t\t\t/* Skip the two-char escape sequence */\n\t\t\t\t\t++u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind_off = u - mtree->line.s;\n\t}\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2007 Tim Kientzle\n * Copyright (c) 2008 Joerg Sonnenberger\n * Copyright (c) 2011-2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_read_support_format_mtree.c 201165 2009-12-29 05:52:13Z kientzle $\");\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#include <stddef.h>\n/* #include <stdint.h> */ /* See archive_platform.h */\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_string.h\"\n#include \"archive_pack_dev.h\"\n\n#ifndef O_BINARY\n#define\tO_BINARY 0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC\t0\n#endif\n\n#define\tMTREE_HAS_DEVICE\t0x0001\n#define\tMTREE_HAS_FFLAGS\t0x0002\n#define\tMTREE_HAS_GID\t\t0x0004\n#define\tMTREE_HAS_GNAME\t\t0x0008\n#define\tMTREE_HAS_MTIME\t\t0x0010\n#define\tMTREE_HAS_NLINK\t\t0x0020\n#define\tMTREE_HAS_PERM\t\t0x0040\n#define\tMTREE_HAS_SIZE\t\t0x0080\n#define\tMTREE_HAS_TYPE\t\t0x0100\n#define\tMTREE_HAS_UID\t\t0x0200\n#define\tMTREE_HAS_UNAME\t\t0x0400\n\n#define\tMTREE_HAS_OPTIONAL\t0x0800\n#define\tMTREE_HAS_NOCHANGE\t0x1000 /* FreeBSD specific */\n\nstruct mtree_option {\n\tstruct mtree_option *next;\n\tchar *value;\n};\n\nstruct mtree_entry {\n\tstruct mtree_entry *next;\n\tstruct mtree_option *options;\n\tchar *name;\n\tchar full;\n\tchar used;\n};\n\nstruct mtree {\n\tstruct archive_string\t line;\n\tsize_t\t\t\t buffsize;\n\tchar\t\t\t*buff;\n\tint64_t\t\t\t offset;\n\tint\t\t\t fd;\n\tint\t\t\t archive_format;\n\tconst char\t\t*archive_format_name;\n\tstruct mtree_entry\t*entries;\n\tstruct mtree_entry\t*this_entry;\n\tstruct archive_string\t current_dir;\n\tstruct archive_string\t contents_name;\n\n\tstruct archive_entry_linkresolver *resolver;\n\n\tint64_t\t\t\t cur_size;\n\tchar checkfs;\n};\n\nstatic int\tbid_keycmp(const char *, const char *, ssize_t);\nstatic int\tcleanup(struct archive_read *);\nstatic int\tdetect_form(struct archive_read *, int *);\nstatic int\tmtree_bid(struct archive_read *, int);\nstatic int\tparse_file(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic void\tparse_escapes(char *, struct mtree_entry *);\nstatic int\tparse_line(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic int\tparse_keyword(struct archive_read *, struct mtree *,\n\t\t    struct archive_entry *, struct mtree_option *, int *);\nstatic int\tread_data(struct archive_read *a,\n\t\t    const void **buff, size_t *size, int64_t *offset);\nstatic ssize_t\treadline(struct archive_read *, struct mtree *, char **, ssize_t);\nstatic int\tskip(struct archive_read *a);\nstatic int\tread_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int64_t\tmtree_atol10(char **);\nstatic int64_t\tmtree_atol8(char **);\nstatic int64_t\tmtree_atol(char **);\n\n/*\n * There's no standard for TIME_T_MAX/TIME_T_MIN.  So we compute them\n * here.  TODO: Move this to configure time, but be careful\n * about cross-compile environments.\n */\nstatic int64_t\nget_time_t_max(void)\n{\n#if defined(TIME_T_MAX)\n\treturn TIME_T_MAX;\n#else\n\t/* ISO C allows time_t to be a floating-point type,\n\t   but POSIX requires an integer type.  The following\n\t   should work on any system that follows the POSIX\n\t   conventions. */\n\tif (((time_t)0) < ((time_t)-1)) {\n\t\t/* Time_t is unsigned */\n\t\treturn (~(time_t)0);\n\t} else {\n\t\t/* Time_t is signed. */\n\t\t/* Assume it's the same as int64_t or int32_t */\n\t\tif (sizeof(time_t) == sizeof(int64_t)) {\n\t\t\treturn (time_t)INT64_MAX;\n\t\t} else {\n\t\t\treturn (time_t)INT32_MAX;\n\t\t}\n\t}\n#endif\n}\n\nstatic int64_t\nget_time_t_min(void)\n{\n#if defined(TIME_T_MIN)\n\treturn TIME_T_MIN;\n#else\n\tif (((time_t)0) < ((time_t)-1)) {\n\t\t/* Time_t is unsigned */\n\t\treturn (time_t)0;\n\t} else {\n\t\t/* Time_t is signed. */\n\t\tif (sizeof(time_t) == sizeof(int64_t)) {\n\t\t\treturn (time_t)INT64_MIN;\n\t\t} else {\n\t\t\treturn (time_t)INT32_MIN;\n\t\t}\n\t}\n#endif\n}\n\nstatic int\narchive_read_format_mtree_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (strcmp(key, \"checkfs\")  == 0) {\n\t\t/* Allows to read information missing from the mtree from the file system */\n\t\tif (val == NULL || val[0] == 0) {\n\t\t\tmtree->checkfs = 0;\n\t\t} else {\n\t\t\tmtree->checkfs = 1;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nstatic void\nfree_options(struct mtree_option *head)\n{\n\tstruct mtree_option *next;\n\n\tfor (; head != NULL; head = next) {\n\t\tnext = head->next;\n\t\tfree(head->value);\n\t\tfree(head);\n\t}\n}\n\nint\narchive_read_support_format_mtree(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct mtree *mtree;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_mtree\");\n\n\tmtree = (struct mtree *)malloc(sizeof(*mtree));\n\tif (mtree == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate mtree data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemset(mtree, 0, sizeof(*mtree));\n\tmtree->fd = -1;\n\n\tr = __archive_read_register_format(a, mtree, \"mtree\",\n           mtree_bid, archive_read_format_mtree_options, read_header, read_data, skip, NULL, cleanup, NULL, NULL);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(mtree);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ncleanup(struct archive_read *a)\n{\n\tstruct mtree *mtree;\n\tstruct mtree_entry *p, *q;\n\n\tmtree = (struct mtree *)(a->format->data);\n\n\tp = mtree->entries;\n\twhile (p != NULL) {\n\t\tq = p->next;\n\t\tfree(p->name);\n\t\tfree_options(p->options);\n\t\tfree(p);\n\t\tp = q;\n\t}\n\tarchive_string_free(&mtree->line);\n\tarchive_string_free(&mtree->current_dir);\n\tarchive_string_free(&mtree->contents_name);\n\tarchive_entry_linkresolver_free(mtree->resolver);\n\n\tfree(mtree->buff);\n\tfree(mtree);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nget_line_size(const char *b, ssize_t avail, ssize_t *nlsize)\n{\n\tssize_t len;\n\n\tlen = 0;\n\twhile (len < avail) {\n\t\tswitch (*b) {\n\t\tcase '\\0':/* Non-ascii character or control character. */\n\t\t\tif (nlsize != NULL)\n\t\t\t\t*nlsize = 0;\n\t\t\treturn (-1);\n\t\tcase '\\r':\n\t\t\tif (avail-len > 1 && b[1] == '\\n') {\n\t\t\t\tif (nlsize != NULL)\n\t\t\t\t\t*nlsize = 2;\n\t\t\t\treturn (len+2);\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase '\\n':\n\t\t\tif (nlsize != NULL)\n\t\t\t\t*nlsize = 1;\n\t\t\treturn (len+1);\n\t\tdefault:\n\t\t\tb++;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nlsize != NULL)\n\t\t*nlsize = 0;\n\treturn (avail);\n}\n\nstatic ssize_t\nnext_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\t/*\n\t * Read bytes more while it does not reach the end of line.\n\t */\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\t/* Increase reading bytes if it is not enough to at least\n\t\t * new two lines. */\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t/* Reading bytes reaches the end of file. */\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;/* Skip some bytes we already determinated. */\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}\n\n/*\n * Compare characters with a mtree keyword.\n * Returns the length of a mtree keyword if matched.\n * Returns 0 if not matched.\n */\nstatic int\nbid_keycmp(const char *p, const char *key, ssize_t len)\n{\n\tint match_len = 0;\n\n\twhile (len > 0 && *p && *key) {\n\t\tif (*p == *key) {\n\t\t\t--len;\n\t\t\t++p;\n\t\t\t++key;\n\t\t\t++match_len;\n\t\t\tcontinue;\n\t\t}\n\t\treturn (0);/* Not match */\n\t}\n\tif (*key != '\\0')\n\t\treturn (0);/* Not match */\n\n\t/* A following character should be specified characters */\n\tif (p[0] == '=' || p[0] == ' ' || p[0] == '\\t' ||\n\t    p[0] == '\\n' || p[0] == '\\r' ||\n\t   (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r')))\n\t\treturn (match_len);\n\treturn (0);/* Not match */\n}\n\n/*\n * Test whether the characters 'p' has is mtree keyword.\n * Returns the length of a detected keyword.\n * Returns 0 if any keywords were not found.\n */\nstatic int\nbid_keyword(const char *p,  ssize_t len)\n{\n\tstatic const char *keys_c[] = {\n\t\t\"content\", \"contents\", \"cksum\", NULL\n\t};\n\tstatic const char *keys_df[] = {\n\t\t\"device\", \"flags\", NULL\n\t};\n\tstatic const char *keys_g[] = {\n\t\t\"gid\", \"gname\", NULL\n\t};\n\tstatic const char *keys_il[] = {\n\t\t\"ignore\", \"inode\", \"link\", NULL\n\t};\n\tstatic const char *keys_m[] = {\n\t\t\"md5\", \"md5digest\", \"mode\", NULL\n\t};\n\tstatic const char *keys_no[] = {\n\t\t\"nlink\", \"nochange\", \"optional\", NULL\n\t};\n\tstatic const char *keys_r[] = {\n\t\t\"resdevice\", \"rmd160\", \"rmd160digest\", NULL\n\t};\n\tstatic const char *keys_s[] = {\n\t\t\"sha1\", \"sha1digest\",\n\t\t\"sha256\", \"sha256digest\",\n\t\t\"sha384\", \"sha384digest\",\n\t\t\"sha512\", \"sha512digest\",\n\t\t\"size\", NULL\n\t};\n\tstatic const char *keys_t[] = {\n\t\t\"tags\", \"time\", \"type\", NULL\n\t};\n\tstatic const char *keys_u[] = {\n\t\t\"uid\", \"uname\",\tNULL\n\t};\n\tconst char **keys;\n\tint i;\n\n\tswitch (*p) {\n\tcase 'c': keys = keys_c; break;\n\tcase 'd': case 'f': keys = keys_df; break;\n\tcase 'g': keys = keys_g; break;\n\tcase 'i': case 'l': keys = keys_il; break;\n\tcase 'm': keys = keys_m; break;\n\tcase 'n': case 'o': keys = keys_no; break;\n\tcase 'r': keys = keys_r; break;\n\tcase 's': keys = keys_s; break;\n\tcase 't': keys = keys_t; break;\n\tcase 'u': keys = keys_u; break;\n\tdefault: return (0);/* Unknown key */\n\t}\n\n\tfor (i = 0; keys[i] != NULL; i++) {\n\t\tint l = bid_keycmp(p, keys[i], len);\n\t\tif (l > 0)\n\t\t\treturn (l);\n\t}\n\treturn (0);/* Unknown key */\n}\n\n/*\n * Test whether there is a set of mtree keywords.\n * Returns the number of keyword.\n * Returns -1 if we got incorrect sequence.\n * This function expects a set of \"<space characters>keyword=value\".\n * When \"unset\" is specified, expects a set of \"<space characters>keyword\".\n */\nstatic int\nbid_keyword_list(const char *p,  ssize_t len, int unset, int last_is_path)\n{\n\tint l;\n\tint keycnt = 0;\n\n\twhile (len > 0 && *p) {\n\t\tint blank = 0;\n\n\t\t/* Test whether there are blank characters in the line. */\n\t\twhile (len >0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t++p;\n\t\t\t--len;\n\t\t\tblank = 1;\n\t\t}\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t\tbreak;\n\t\tif (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r'))\n\t\t\tbreak;\n\t\tif (!blank && !last_is_path) /* No blank character. */\n\t\t\treturn (-1);\n\t\tif (last_is_path && len == 0)\n\t\t\t\treturn (keycnt);\n\n\t\tif (unset) {\n\t\t\tl = bid_keycmp(p, \"all\", len);\n\t\t\tif (l > 0)\n\t\t\t\treturn (1);\n\t\t}\n\t\t/* Test whether there is a correct key in the line. */\n\t\tl = bid_keyword(p, len);\n\t\tif (l == 0)\n\t\t\treturn (-1);/* Unknown keyword was found. */\n\t\tp += l;\n\t\tlen -= l;\n\t\tkeycnt++;\n\n\t\t/* Skip value */\n\t\tif (*p == '=') {\n\t\t\tint value = 0;\n\t\t\t++p;\n\t\t\t--len;\n\t\t\twhile (len > 0 && *p != ' ' && *p != '\\t') {\n\t\t\t\t++p;\n\t\t\t\t--len;\n\t\t\t\tvalue = 1;\n\t\t\t}\n\t\t\t/* A keyword should have a its value unless\n\t\t\t * \"/unset\" operation. */ \n\t\t\tif (!unset && value == 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (keycnt);\n}\n\nstatic int\nbid_entry(const char *p, ssize_t len, ssize_t nl, int *last_is_path)\n{\n\tint f = 0;\n\tstatic const unsigned char safe_char[256] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 00 - 0F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 1F */\n\t\t/* !\"$%&'()*+,-./  EXCLUSION:( )(#) */\n\t\t0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 20 - 2F */\n\t\t/* 0123456789:;<>?  EXCLUSION:(=) */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, /* 30 - 3F */\n\t\t/* @ABCDEFGHIJKLMNO */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 40 - 4F */\n\t\t/* PQRSTUVWXYZ[\\]^_  */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 50 - 5F */\n\t\t/* `abcdefghijklmno */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 60 - 6F */\n\t\t/* pqrstuvwxyz{|}~ */\n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, /* 70 - 7F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 80 - 8F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 90 - 9F */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* A0 - AF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* B0 - BF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* C0 - CF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* D0 - DF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* E0 - EF */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* F0 - FF */\n\t};\n\tssize_t ll;\n\tconst char *pp = p;\n\tconst char * const pp_end = pp + len;\n\n\t*last_is_path = 0;\n\t/*\n\t * Skip the path-name which is quoted.\n\t */\n\tfor (;pp < pp_end; ++pp) {\n\t\tif (!safe_char[*(const unsigned char *)pp]) {\n\t\t\tif (*pp != ' ' && *pp != '\\t' && *pp != '\\r'\n\t\t\t    && *pp != '\\n')\n\t\t\t\tf = 0;\n\t\t\tbreak;\n\t\t}\n\t\tf = 1;\n\t}\n\tll = pp_end - pp;\n\n\t/* If a path-name was not found at the first, try to check\n\t * a mtree format(a.k.a form D) ``NetBSD's mtree -D'' creates,\n\t * which places the path-name at the last. */\n\tif (f == 0) {\n\t\tconst char *pb = p + len - nl;\n\t\tint name_len = 0;\n\t\tint slash;\n\n\t\t/* The form D accepts only a single line for an entry. */\n\t\tif (pb-2 >= p &&\n\t\t    pb[-1] == '\\\\' && (pb[-2] == ' ' || pb[-2] == '\\t'))\n\t\t\treturn (-1);\n\t\tif (pb-1 >= p && pb[-1] == '\\\\')\n\t\t\treturn (-1);\n\n\t\tslash = 0;\n\t\twhile (p <= --pb && *pb != ' ' && *pb != '\\t') {\n\t\t\tif (!safe_char[*(const unsigned char *)pb])\n\t\t\t\treturn (-1);\n\t\t\tname_len++;\n\t\t\t/* The pathname should have a slash in this\n\t\t\t * format. */\n\t\t\tif (*pb == '/')\n\t\t\t\tslash = 1;\n\t\t}\n\t\tif (name_len == 0 || slash == 0)\n\t\t\treturn (-1);\n\t\t/* If '/' is placed at the first in this field, this is not\n\t\t * a valid filename. */\n\t\tif (pb[1] == '/')\n\t\t\treturn (-1);\n\t\tll = len - nl - name_len;\n\t\tpp = p;\n\t\t*last_is_path = 1;\n\t}\n\n\treturn (bid_keyword_list(pp, ll, 0, *last_is_path));\n}\n\n#define MAX_BID_ENTRY\t3\n\nstatic int\nmtree_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *signature = \"#mtree\";\n\tconst char *p;\n\n\t(void)best_bid; /* UNUSED */\n\n\t/* Now let's look at the actual header and see if it matches. */\n\tp = __archive_read_ahead(a, strlen(signature), NULL);\n\tif (p == NULL)\n\t\treturn (-1);\n\n\tif (memcmp(p, signature, strlen(signature)) == 0)\n\t\treturn (8 * (int)strlen(signature));\n\n\t/*\n\t * There is not a mtree signature. Let's try to detect mtree format.\n\t */\n\treturn (detect_form(a, NULL));\n}\n\nstatic int\ndetect_form(struct archive_read *a, int *is_form_d)\n{\n\tconst char *p;\n\tssize_t avail, ravail;\n\tssize_t detected_bytes = 0, len, nl;\n\tint entry_cnt = 0, multiline = 0;\n\tint form_D = 0;/* The archive is generated by `NetBSD mtree -D'\n\t\t\t* (In this source we call it `form D') . */\n\n\tif (is_form_d != NULL)\n\t\t*is_form_d = 0;\n\tp = __archive_read_ahead(a, 1, &avail);\n\tif (p == NULL)\n\t\treturn (-1);\n\travail = avail;\n\tfor (;;) {\n\t\tlen = next_line(a, &p, &avail, &ravail, &nl);\n\t\t/* The terminal character of the line should be\n\t\t * a new line character, '\\r\\n' or '\\n'. */\n\t\tif (len <= 0 || nl == 0)\n\t\t\tbreak;\n\t\tif (!multiline) {\n\t\t\t/* Leading whitespace is never significant,\n\t\t\t * ignore it. */\n\t\t\twhile (len > 0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t\t++p;\n\t\t\t\t--avail;\n\t\t\t\t--len;\n\t\t\t}\n\t\t\t/* Skip comment or empty line. */ \n\t\t\tif (p[0] == '#' || p[0] == '\\n' || p[0] == '\\r') {\n\t\t\t\tp += len;\n\t\t\t\tavail -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* A continuance line; the terminal\n\t\t\t * character of previous line was '\\' character. */\n\t\t\tif (bid_keyword_list(p, len, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (multiline == 1)\n\t\t\t\tdetected_bytes += len;\n\t\t\tif (p[len-nl-1] != '\\\\') {\n\t\t\t\tif (multiline == 1 &&\n\t\t\t\t    ++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\tbreak;\n\t\t\t\tmultiline = 0;\n\t\t\t}\n\t\t\tp += len;\n\t\t\tavail -= len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p[0] != '/') {\n\t\t\tint last_is_path, keywords;\n\n\t\t\tkeywords = bid_entry(p, len, nl, &last_is_path);\n\t\t\tif (keywords >= 0) {\n\t\t\t\tdetected_bytes += len;\n\t\t\t\tif (form_D == 0) {\n\t\t\t\t\tif (last_is_path)\n\t\t\t\t\t\tform_D = 1;\n\t\t\t\t\telse if (keywords > 0)\n\t\t\t\t\t\t/* This line is not `form D'. */\n\t\t\t\t\t\tform_D = -1;\n\t\t\t\t} else if (form_D == 1) {\n\t\t\t\t\tif (!last_is_path && keywords > 0)\n\t\t\t\t\t\t/* This this is not `form D'\n\t\t\t\t\t\t * and We cannot accept mixed\n\t\t\t\t\t\t * format. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!last_is_path && p[len-nl-1] == '\\\\')\n\t\t\t\t\t/* This line continues. */\n\t\t\t\t\tmultiline = 1;\n\t\t\t\telse {\n\t\t\t\t\t/* We've got plenty of correct lines\n\t\t\t\t\t * to assume that this file is a mtree\n\t\t\t\t\t * format. */\n\t\t\t\t\tif (++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (bid_keyword_list(p+4, len-4, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\t/* This line continues. */\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (bid_keyword_list(p+6, len-6, 1, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\t/* This line continues. */\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else\n\t\t\tbreak;\n\n\t\t/* Test next line. */\n\t\tp += len;\n\t\tavail -= len;\n\t}\n\tif (entry_cnt >= MAX_BID_ENTRY || (entry_cnt > 0 && len == 0)) {\n\t\tif (is_form_d != NULL) {\n\t\t\tif (form_D == 1)\n\t\t\t\t*is_form_d = 1;\n\t\t}\n\t\treturn (32);\n\t}\n\n\treturn (0);\n}\n\n/*\n * The extended mtree format permits multiple lines specifying\n * attributes for each file.  For those entries, only the last line\n * is actually used.  Practically speaking, that means we have\n * to read the entire mtree file into memory up front.\n *\n * The parsing is done in two steps.  First, it is decided if a line\n * changes the global defaults and if it is, processed accordingly.\n * Otherwise, the options of the line are merged with the current\n * global options.\n */\nstatic int\nadd_option(struct archive_read *a, struct mtree_option **global,\n    const char *value, size_t len)\n{\n\tstruct mtree_option *opt;\n\n\tif ((opt = malloc(sizeof(*opt))) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((opt->value = malloc(len + 1)) == NULL) {\n\t\tfree(opt);\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemcpy(opt->value, value, len);\n\topt->value[len] = '\\0';\n\topt->next = *global;\n\t*global = opt;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nremove_option(struct mtree_option **global, const char *value, size_t len)\n{\n\tstruct mtree_option *iter, *last;\n\n\tlast = NULL;\n\tfor (iter = *global; iter != NULL; last = iter, iter = iter->next) {\n\t\tif (strncmp(iter->value, value, len) == 0 &&\n\t\t    (iter->value[len] == '\\0' ||\n\t\t     iter->value[len] == '='))\n\t\t\tbreak;\n\t}\n\tif (iter == NULL)\n\t\treturn;\n\tif (last == NULL)\n\t\t*global = iter->next;\n\telse\n\t\tlast->next = iter->next;\n\n\tfree(iter->value);\n\tfree(iter);\n}\n\nstatic int\nprocess_global_set(struct archive_read *a,\n    struct mtree_option **global, const char *line)\n{\n\tconst char *next, *eq;\n\tsize_t len;\n\tint r;\n\n\tline += 4;\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tnext = line + strcspn(line, \" \\t\\r\\n\");\n\t\teq = strchr(line, '=');\n\t\tif (eq > next)\n\t\t\tlen = next - line;\n\t\telse\n\t\t\tlen = eq - line;\n\n\t\tremove_option(global, line, len);\n\t\tr = add_option(a, global, line, next - line);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tline = next;\n\t}\n}\n\nstatic int\nprocess_global_unset(struct archive_read *a,\n    struct mtree_option **global, const char *line)\n{\n\tconst char *next;\n\tsize_t len;\n\n\tline += 6;\n\tif (strchr(line, '=') != NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"/unset shall not contain `='\");\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tlen = strcspn(line, \" \\t\\r\\n\");\n\n\t\tif (len == 3 && strncmp(line, \"all\", 3) == 0) {\n\t\t\tfree_options(*global);\n\t\t\t*global = NULL;\n\t\t} else {\n\t\t\tremove_option(global, line, len);\n\t\t}\n\n\t\tline += len;\n\t}\n}\n\nstatic int\nprocess_add_entry(struct archive_read *a, struct mtree *mtree,\n    struct mtree_option **global, const char *line, ssize_t line_len,\n    struct mtree_entry **last_entry, int is_form_d)\n{\n\tstruct mtree_entry *entry;\n\tstruct mtree_option *iter;\n\tconst char *next, *eq, *name, *end;\n\tsize_t name_len, len;\n\tint r, i;\n\n\tif ((entry = malloc(sizeof(*entry))) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tentry->next = NULL;\n\tentry->options = NULL;\n\tentry->name = NULL;\n\tentry->used = 0;\n\tentry->full = 0;\n\n\t/* Add this entry to list. */\n\tif (*last_entry == NULL)\n\t\tmtree->entries = entry;\n\telse\n\t\t(*last_entry)->next = entry;\n\t*last_entry = entry;\n\n\tif (is_form_d) {\n\t\t/* Filename is last item on line. */\n\t\t/* Adjust line_len to trim trailing whitespace */\n\t\twhile (line_len > 0) {\n\t\t\tchar last_character = line[line_len - 1];\n\t\t\tif (last_character == '\\r'\n\t\t\t    || last_character == '\\n'\n\t\t\t    || last_character == '\\t'\n\t\t\t    || last_character == ' ') {\n\t\t\t\tline_len--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Name starts after the last whitespace separator */\n\t\tname = line;\n\t\tfor (i = 0; i < line_len; i++) {\n\t\t\tif (line[i] == '\\r'\n\t\t\t    || line[i] == '\\n'\n\t\t\t    || line[i] == '\\t'\n\t\t\t    || line[i] == ' ') {\n\t\t\t\tname = line + i + 1;\n\t\t\t}\n\t\t}\n\t\tname_len = line + line_len - name;\n\t\tend = name;\n\t} else {\n\t\t/* Filename is first item on line */\n\t\tname_len = strcspn(line, \" \\t\\r\\n\");\n\t\tname = line;\n\t\tline += name_len;\n\t\tend = line + line_len;\n\t}\n\t/* name/name_len is the name within the line. */\n\t/* line..end brackets the entire line except the name */\n\n\tif ((entry->name = malloc(name_len + 1)) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tmemcpy(entry->name, name, name_len);\n\tentry->name[name_len] = '\\0';\n\tparse_escapes(entry->name, entry);\n\n\tfor (iter = *global; iter != NULL; iter = iter->next) {\n\t\tr = add_option(a, &entry->options, iter->value,\n\t\t    strlen(iter->value));\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tif (next >= end)\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tnext = line + strcspn(line, \" \\t\\r\\n\");\n\t\teq = strchr(line, '=');\n\t\tif (eq == NULL || eq > next)\n\t\t\tlen = next - line;\n\t\telse\n\t\t\tlen = eq - line;\n\n\t\tremove_option(&entry->options, line, len);\n\t\tr = add_option(a, &entry->options, line, next - line);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tline = next;\n\t}\n}\n\nstatic int\nread_mtree(struct archive_read *a, struct mtree *mtree)\n{\n\tssize_t len;\n\tuintmax_t counter;\n\tchar *p;\n\tstruct mtree_option *global;\n\tstruct mtree_entry *last_entry;\n\tint r, is_form_d;\n\n\tmtree->archive_format = ARCHIVE_FORMAT_MTREE;\n\tmtree->archive_format_name = \"mtree\";\n\n\tglobal = NULL;\n\tlast_entry = NULL;\n\n\t(void)detect_form(a, &is_form_d);\n\n\tfor (counter = 1; ; ++counter) {\n\t\tlen = readline(a, mtree, &p, 65536);\n\t\tif (len == 0) {\n\t\t\tmtree->this_entry = mtree->entries;\n\t\t\tfree_options(global);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tif (len < 0) {\n\t\t\tfree_options(global);\n\t\t\treturn ((int)len);\n\t\t}\n\t\t/* Leading whitespace is never significant, ignore it. */\n\t\twhile (*p == ' ' || *p == '\\t') {\n\t\t\t++p;\n\t\t\t--len;\n\t\t}\n\t\t/* Skip content lines and blank lines. */\n\t\tif (*p == '#')\n\t\t\tcontinue;\n\t\tif (*p == '\\r' || *p == '\\n' || *p == '\\0')\n\t\t\tcontinue;\n\t\tif (*p != '/') {\n\t\t\tr = process_add_entry(a, mtree, &global, p, len,\n\t\t\t    &last_entry, is_form_d);\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (p[4] != ' ' && p[4] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_set(a, &global, p);\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (p[6] != ' ' && p[6] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_unset(a, &global, p);\n\t\t} else\n\t\t\tbreak;\n\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tfree_options(global);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Can't parse line %ju\", counter);\n\tfree_options(global);\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Read in the entire mtree file into memory on the first request.\n * Then use the next unused file to satisfy each header request.\n */\nstatic int\nread_header(struct archive_read *a, struct archive_entry *entry)\n{\n\tstruct mtree *mtree;\n\tchar *p;\n\tint r, use_next;\n\n\tmtree = (struct mtree *)(a->format->data);\n\n\tif (mtree->fd >= 0) {\n\t\tclose(mtree->fd);\n\t\tmtree->fd = -1;\n\t}\n\n\tif (mtree->entries == NULL) {\n\t\tmtree->resolver = archive_entry_linkresolver_new();\n\t\tif (mtree->resolver == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tarchive_entry_linkresolver_set_strategy(mtree->resolver,\n\t\t    ARCHIVE_FORMAT_MTREE);\n\t\tr = read_mtree(a, mtree);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\ta->archive.archive_format = mtree->archive_format;\n\ta->archive.archive_format_name = mtree->archive_format_name;\n\n\tfor (;;) {\n\t\tif (mtree->this_entry == NULL)\n\t\t\treturn (ARCHIVE_EOF);\n\t\tif (strcmp(mtree->this_entry->name, \"..\") == 0) {\n\t\t\tmtree->this_entry->used = 1;\n\t\t\tif (archive_strlen(&mtree->current_dir) > 0) {\n\t\t\t\t/* Roll back current path. */\n\t\t\t\tp = mtree->current_dir.s\n\t\t\t\t    + mtree->current_dir.length - 1;\n\t\t\t\twhile (p >= mtree->current_dir.s && *p != '/')\n\t\t\t\t\t--p;\n\t\t\t\tif (p >= mtree->current_dir.s)\n\t\t\t\t\t--p;\n\t\t\t\tmtree->current_dir.length\n\t\t\t\t    = p - mtree->current_dir.s + 1;\n\t\t\t}\n\t\t}\n\t\tif (!mtree->this_entry->used) {\n\t\t\tuse_next = 0;\n\t\t\tr = parse_file(a, entry, mtree, mtree->this_entry,\n\t\t\t\t&use_next);\n\t\t\tif (use_next == 0)\n\t\t\t\treturn (r);\n\t\t}\n\t\tmtree->this_entry = mtree->this_entry->next;\n\t}\n}\n\n/*\n * A single file can have multiple lines contribute specifications.\n * Parse as many lines as necessary, then pull additional information\n * from a backing file on disk as necessary.\n */\nstatic int\nparse_file(struct archive_read *a, struct archive_entry *entry,\n    struct mtree *mtree, struct mtree_entry *mentry, int *use_next)\n{\n\tconst char *path;\n\tstruct stat st_storage, *st;\n\tstruct mtree_entry *mp;\n\tstruct archive_entry *sparse_entry;\n\tint r = ARCHIVE_OK, r1, parsed_kws;\n\n\tmentry->used = 1;\n\n\t/* Initialize reasonable defaults. */\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tarchive_string_empty(&mtree->contents_name);\n\n\t/* Parse options from this line. */\n\tparsed_kws = 0;\n\tr = parse_line(a, entry, mtree, mentry, &parsed_kws);\n\n\tif (mentry->full) {\n\t\tarchive_entry_copy_pathname(entry, mentry->name);\n\t\t/*\n\t\t * \"Full\" entries are allowed to have multiple lines\n\t\t * and those lines aren't required to be adjacent.  We\n\t\t * don't support multiple lines for \"relative\" entries\n\t\t * nor do we make any attempt to merge data from\n\t\t * separate \"relative\" and \"full\" entries.  (Merging\n\t\t * \"relative\" and \"full\" entries would require dealing\n\t\t * with pathname canonicalization, which is a very\n\t\t * tricky subject.)\n\t\t */\n\t\tfor (mp = mentry->next; mp != NULL; mp = mp->next) {\n\t\t\tif (mp->full && !mp->used\n\t\t\t    && strcmp(mentry->name, mp->name) == 0) {\n\t\t\t\t/* Later lines override earlier ones. */\n\t\t\t\tmp->used = 1;\n\t\t\t\tr1 = parse_line(a, entry, mtree, mp,\n\t\t\t\t    &parsed_kws);\n\t\t\t\tif (r1 < r)\n\t\t\t\t\tr = r1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Relative entries require us to construct\n\t\t * the full path and possibly update the\n\t\t * current directory.\n\t\t */\n\t\tsize_t n = archive_strlen(&mtree->current_dir);\n\t\tif (n > 0)\n\t\t\tarchive_strcat(&mtree->current_dir, \"/\");\n\t\tarchive_strcat(&mtree->current_dir, mentry->name);\n\t\tarchive_entry_copy_pathname(entry, mtree->current_dir.s);\n\t\tif (archive_entry_filetype(entry) != AE_IFDIR)\n\t\t\tmtree->current_dir.length = n;\n\t}\n\n\tif (mtree->checkfs) {\n\t\t/*\n\t\t * Try to open and stat the file to get the real size\n\t\t * and other file info.  It would be nice to avoid\n\t\t * this here so that getting a listing of an mtree\n\t\t * wouldn't require opening every referenced contents\n\t\t * file.  But then we wouldn't know the actual\n\t\t * contents size, so I don't see a really viable way\n\t\t * around this.  (Also, we may want to someday pull\n\t\t * other unspecified info from the contents file on\n\t\t * disk.)\n\t\t */\n\t\tmtree->fd = -1;\n\t\tif (archive_strlen(&mtree->contents_name) > 0)\n\t\t\tpath = mtree->contents_name.s;\n\t\telse\n\t\t\tpath = archive_entry_pathname(entry);\n\n\t\tif (archive_entry_filetype(entry) == AE_IFREG ||\n\t\t\t\tarchive_entry_filetype(entry) == AE_IFDIR) {\n\t\t\tmtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(mtree->fd);\n\t\t\tif (mtree->fd == -1 &&\n\t\t\t\t(errno != ENOENT ||\n\t\t\t\t archive_strlen(&mtree->contents_name) > 0)) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Can't open %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\n\t\tst = &st_storage;\n\t\tif (mtree->fd >= 0) {\n\t\t\tif (fstat(mtree->fd, st) == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Could not fstat %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\t/* If we can't stat it, don't keep it open. */\n\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tst = NULL;\n\t\t\t}\n\t\t} else if (lstat(path, st) == -1) {\n\t\t\tst = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Check for a mismatch between the type in the specification\n\t\t * and the type of the contents object on disk.\n\t\t */\n\t\tif (st != NULL) {\n\t\t\tif (((st->st_mode & S_IFMT) == S_IFREG &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFREG)\n#ifdef S_IFLNK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFLNK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFLNK)\n#endif\n#ifdef S_IFSOCK\n\t\t\t  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFSOCK)\n#endif\n#ifdef S_IFCHR\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFCHR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFCHR)\n#endif\n#ifdef S_IFBLK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFBLK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFBLK)\n#endif\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFDIR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFDIR)\n#ifdef S_IFIFO\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFIFO &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFIFO)\n#endif\n\t\t\t) {\n\t\t\t\t/* Types match. */\n\t\t\t} else {\n\t\t\t\t/* Types don't match; bail out gracefully. */\n\t\t\t\tif (mtree->fd >= 0)\n\t\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tif (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t\t\t/* It's not an error for an optional\n\t\t\t\t\t * entry to not match disk. */\n\t\t\t\t\t*use_next = 1;\n\t\t\t\t} else if (r == ARCHIVE_OK) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"mtree specification has different\"\n\t\t\t\t\t    \" type for %s\",\n\t\t\t\t\t    archive_entry_pathname(entry));\n\t\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\t}\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there is a contents file on disk, pick some of the\n\t\t * metadata from that file.  For most of these, we only\n\t\t * set it from the contents if it wasn't already parsed\n\t\t * from the specification.\n\t\t */\n\t\tif (st != NULL) {\n\t\t\tif (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||\n\t\t\t\t(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&\n\t\t\t\t(archive_entry_filetype(entry) == AE_IFCHR ||\n\t\t\t\t archive_entry_filetype(entry) == AE_IFBLK))\n\t\t\t\tarchive_entry_set_rdev(entry, st->st_rdev);\n\t\t\tif ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_gid(entry, st->st_gid);\n\t\t\tif ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_uid(entry, st->st_uid);\n\t\t\tif ((parsed_kws & MTREE_HAS_MTIME) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtimespec.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtim.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIME_N\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_n);\n#elif HAVE_STRUCT_STAT_ST_UMTIME\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_umtime*1000);\n#elif HAVE_STRUCT_STAT_ST_MTIME_USEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_usec*1000);\n#else\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime, 0);\n#endif\n\t\t\t}\n\t\t\tif ((parsed_kws & MTREE_HAS_NLINK) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_nlink(entry, st->st_nlink);\n\t\t\tif ((parsed_kws & MTREE_HAS_PERM) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_perm(entry, st->st_mode);\n\t\t\tif ((parsed_kws & MTREE_HAS_SIZE) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_size(entry, st->st_size);\n\t\t\tarchive_entry_set_ino(entry, st->st_ino);\n\t\t\tarchive_entry_set_dev(entry, st->st_dev);\n\n\t\t\tarchive_entry_linkify(mtree->resolver, &entry,\n\t\t\t\t&sparse_entry);\n\t\t} else if (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t/*\n\t\t\t * Couldn't open the entry, stat it or the on-disk type\n\t\t\t * didn't match.  If this entry is optional, just\n\t\t\t * ignore it and read the next header entry.\n\t\t\t */\n\t\t\t*use_next = 1;\n\t\t\treturn ARCHIVE_OK;\n\t\t}\n\t}\n\n\tmtree->cur_size = archive_entry_size(entry);\n\tmtree->offset = 0;\n\n\treturn r;\n}\n\n/*\n * Each line contains a sequence of keywords.\n */\nstatic int\nparse_line(struct archive_read *a, struct archive_entry *entry,\n    struct mtree *mtree, struct mtree_entry *mp, int *parsed_kws)\n{\n\tstruct mtree_option *iter;\n\tint r = ARCHIVE_OK, r1;\n\n\tfor (iter = mp->options; iter != NULL; iter = iter->next) {\n\t\tr1 = parse_keyword(a, mtree, entry, iter, parsed_kws);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\tif (r == ARCHIVE_OK && (*parsed_kws & MTREE_HAS_TYPE) == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Missing type keyword in mtree specification\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (r);\n}\n\n/*\n * Device entries have one of the following forms:\n *  - raw dev_t\n *  - format,major,minor[,subdevice]\n * When parsing succeeded, `pdev' will contain the appropriate dev_t value.\n */\n\n/* strsep() is not in C90, but strcspn() is. */\n/* Taken from http://unixpapa.com/incnote/string.html */\nstatic char *\nla_strsep(char **sp, const char *sep)\n{\n\tchar *p, *s;\n\tif (sp == NULL || *sp == NULL || **sp == '\\0')\n\t\treturn(NULL);\n\ts = *sp;\n\tp = s + strcspn(s, sep);\n\tif (*p != '\\0')\n\t\t*p++ = '\\0';\n\t*sp = p;\n\treturn(s);\n}\n\nstatic int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}\n\n/*\n * Parse a single keyword and its value.\n */\nstatic int\nparse_keyword(struct archive_read *a, struct mtree *mtree,\n    struct archive_entry *entry, struct mtree_option *opt, int *parsed_kws)\n{\n\tchar *val, *key;\n\n\tkey = opt->value;\n\n\tif (*key == '\\0')\n\t\treturn (ARCHIVE_OK);\n\n\tif (strcmp(key, \"nochange\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_NOCHANGE;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"optional\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_OPTIONAL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"ignore\") == 0) {\n\t\t/*\n\t\t * The mtree processing is not recursive, so\n\t\t * recursion will only happen for explicitly listed\n\t\t * entries.\n\t\t */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tval = strchr(key, '=');\n\tif (val == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed attribute \\\"%s\\\" (%d)\", key, key[0]);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t*val = '\\0';\n\t++val;\n\n\tswitch (key[0]) {\n\tcase 'c':\n\t\tif (strcmp(key, \"content\") == 0\n\t\t    || strcmp(key, \"contents\") == 0) {\n\t\t\tparse_escapes(val, NULL);\n\t\t\tarchive_strcpy(&mtree->contents_name, val);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"cksum\") == 0)\n\t\t\tbreak;\n\tcase 'd':\n\t\tif (strcmp(key, \"device\") == 0) {\n\t\t\t/* stat(2) st_rdev field, e.g. the major/minor IDs\n\t\t\t * of a char/block special file */\n\t\t\tint r;\n\t\t\tdev_t dev;\n\n\t\t\t*parsed_kws |= MTREE_HAS_DEVICE;\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_rdev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\tcase 'f':\n\t\tif (strcmp(key, \"flags\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_FFLAGS;\n\t\t\tarchive_entry_copy_fflags_text(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'g':\n\t\tif (strcmp(key, \"gid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GID;\n\t\t\tarchive_entry_set_gid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"gname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GNAME;\n\t\t\tarchive_entry_copy_gname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'i':\n\t\tif (strcmp(key, \"inode\") == 0) {\n\t\t\tarchive_entry_set_ino(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'l':\n\t\tif (strcmp(key, \"link\") == 0) {\n\t\t\tarchive_entry_copy_symlink(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'm':\n\t\tif (strcmp(key, \"md5\") == 0 || strcmp(key, \"md5digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"mode\") == 0) {\n\t\t\tif (val[0] >= '0' && val[0] <= '9') {\n\t\t\t\t*parsed_kws |= MTREE_HAS_PERM;\n\t\t\t\tarchive_entry_set_perm(entry,\n\t\t\t\t    (mode_t)mtree_atol8(&val));\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Symbolic mode \\\"%s\\\" unsupported\", val);\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase 'n':\n\t\tif (strcmp(key, \"nlink\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_NLINK;\n\t\t\tarchive_entry_set_nlink(entry,\n\t\t\t\t(unsigned int)mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'r':\n\t\tif (strcmp(key, \"resdevice\") == 0) {\n\t\t\t/* stat(2) st_dev field, e.g. the device ID where the\n\t\t\t * inode resides */\n\t\t\tint r;\n\t\t\tdev_t dev;\n\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_dev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\t\tif (strcmp(key, \"rmd160\") == 0 ||\n\t\t    strcmp(key, \"rmd160digest\") == 0)\n\t\t\tbreak;\n\tcase 's':\n\t\tif (strcmp(key, \"sha1\") == 0 || strcmp(key, \"sha1digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha256\") == 0 ||\n\t\t    strcmp(key, \"sha256digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha384\") == 0 ||\n\t\t    strcmp(key, \"sha384digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha512\") == 0 ||\n\t\t    strcmp(key, \"sha512digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"size\") == 0) {\n\t\t\tarchive_entry_set_size(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 't':\n\t\tif (strcmp(key, \"tags\") == 0) {\n\t\t\t/*\n\t\t\t * Comma delimited list of tags.\n\t\t\t * Ignore the tags for now, but the interface\n\t\t\t * should be extended to allow inclusion/exclusion.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"time\") == 0) {\n\t\t\tint64_t m;\n\t\t\tint64_t my_time_t_max = get_time_t_max();\n\t\t\tint64_t my_time_t_min = get_time_t_min();\n\t\t\tlong ns = 0;\n\n\t\t\t*parsed_kws |= MTREE_HAS_MTIME;\n\t\t\tm = mtree_atol10(&val);\n\t\t\t/* Replicate an old mtree bug:\n\t\t\t * 123456789.1 represents 123456789\n\t\t\t * seconds and 1 nanosecond. */\n\t\t\tif (*val == '.') {\n\t\t\t\t++val;\n\t\t\t\tns = (long)mtree_atol10(&val);\n\t\t\t} else\n\t\t\t\tns = 0;\n\t\t\tif (m > my_time_t_max)\n\t\t\t\tm = my_time_t_max;\n\t\t\telse if (m < my_time_t_min)\n\t\t\t\tm = my_time_t_min;\n\t\t\tarchive_entry_set_mtime(entry, (time_t)m, ns);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"type\") == 0) {\n\t\t\tswitch (val[0]) {\n\t\t\tcase 'b':\n\t\t\t\tif (strcmp(val, \"block\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry, AE_IFBLK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'c':\n\t\t\t\tif (strcmp(val, \"char\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFCHR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'd':\n\t\t\t\tif (strcmp(val, \"dir\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFDIR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'f':\n\t\t\t\tif (strcmp(val, \"fifo\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFIFO);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strcmp(val, \"file\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFREG);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'l':\n\t\t\t\tif (strcmp(val, \"link\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFLNK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Unrecognized file type \\\"%s\\\"; \"\n\t\t\t\t    \"assuming \\\"file\\\"\", val);\n\t\t\t\tarchive_entry_set_filetype(entry, AE_IFREG);\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\t*parsed_kws |= MTREE_HAS_TYPE;\n\t\t\tbreak;\n\t\t}\n\tcase 'u':\n\t\tif (strcmp(key, \"uid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UID;\n\t\t\tarchive_entry_set_uid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"uname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UNAME;\n\t\t\tarchive_entry_copy_uname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unrecognized key %s=%s\", key, val);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nread_data(struct archive_read *a, const void **buff, size_t *size,\n    int64_t *offset)\n{\n\tsize_t bytes_to_read;\n\tssize_t bytes_read;\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd < 0) {\n\t\t*buff = NULL;\n\t\t*offset = 0;\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tif (mtree->buff == NULL) {\n\t\tmtree->buffsize = 64 * 1024;\n\t\tmtree->buff = malloc(mtree->buffsize);\n\t\tif (mtree->buff == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t*buff = mtree->buff;\n\t*offset = mtree->offset;\n\tif ((int64_t)mtree->buffsize > mtree->cur_size - mtree->offset)\n\t\tbytes_to_read = (size_t)(mtree->cur_size - mtree->offset);\n\telse\n\t\tbytes_to_read = mtree->buffsize;\n\tbytes_read = read(mtree->fd, mtree->buff, bytes_to_read);\n\tif (bytes_read < 0) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't read\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (bytes_read == 0) {\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tmtree->offset += bytes_read;\n\t*size = bytes_read;\n\treturn (ARCHIVE_OK);\n}\n\n/* Skip does nothing except possibly close the contents file. */\nstatic int\nskip(struct archive_read *a)\n{\n\tstruct mtree *mtree;\n\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd >= 0) {\n\t\tclose(mtree->fd);\n\t\tmtree->fd = -1;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Since parsing backslash sequences always makes strings shorter,\n * we can always do this conversion in-place.\n */\nstatic void\nparse_escapes(char *src, struct mtree_entry *mentry)\n{\n\tchar *dest = src;\n\tchar c;\n\n\tif (mentry != NULL && strcmp(src, \".\") == 0)\n\t\tmentry->full = 1;\n\n\twhile (*src != '\\0') {\n\t\tc = *src++;\n\t\tif (c == '/' && mentry != NULL)\n\t\t\tmentry->full = 1;\n\t\tif (c == '\\\\') {\n\t\t\tswitch (src[0]) {\n\t\t\tcase '0':\n\t\t\t\tif (src[1] < '0' || src[1] > '7') {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tif (src[1] >= '0' && src[1] <= '7' &&\n\t\t\t\t    src[2] >= '0' && src[2] <= '7') {\n\t\t\t\t\tc = (src[0] - '0') << 6;\n\t\t\t\t\tc |= (src[1] - '0') << 3;\n\t\t\t\t\tc |= (src[2] - '0');\n\t\t\t\t\tsrc += 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tc = '\\a';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tc = ' ';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tc = '\\v';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*dest++ = c;\n\t}\n\t*dest = '\\0';\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol8(char **p)\n{\n\tint64_t\tl, limit, last_digit_limit;\n\tint digit, base;\n\n\tbase = 8;\n\tlimit = INT64_MAX / base;\n\tlast_digit_limit = INT64_MAX % base;\n\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l>limit || (l == limit && digit > last_digit_limit)) {\n\t\t\tl = INT64_MAX; /* Truncate on overflow. */\n\t\t\tbreak;\n\t\t}\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (l);\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol10(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\n\tbase = 10;\n\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (sign < 0) ? -l : l;\n}\n\n/* Parse a hex digit. */\nstatic int\nparsehex(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\telse if (c >= 'a' && c <= 'f')\n\t\treturn c - 'a';\n\telse if (c >= 'A' && c <= 'F')\n\t\treturn c - 'A';\n\telse\n\t\treturn -1;\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\nstatic int64_t\nmtree_atol16(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\n\tbase = 16;\n\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\n\tl = 0;\n\tdigit = parsehex(**p);\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = parsehex(*++(*p));\n\t}\n\treturn (sign < 0) ? -l : l;\n}\n\nstatic int64_t\nmtree_atol(char **p)\n{\n\tif (**p != '0')\n\t\treturn mtree_atol10(p);\n\tif ((*p)[1] == 'x' || (*p)[1] == 'X') {\n\t\t*p += 2;\n\t\treturn mtree_atol16(p);\n\t}\n\treturn mtree_atol8(p);\n}\n\n/*\n * Returns length of line (including trailing newline)\n * or negative on error.  'start' argument is updated to\n * point to first character of line.\n */\nstatic ssize_t\nreadline(struct archive_read *a, struct mtree *mtree, char **start,\n    ssize_t limit)\n{\n\tssize_t bytes_read;\n\tssize_t total_size = 0;\n\tssize_t find_off = 0;\n\tconst void *t;\n\tvoid *nl;\n\tchar *u;\n\n\t/* Accumulate line in a line buffer. */\n\tfor (;;) {\n\t\t/* Read some more. */\n\t\tt = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (t == NULL)\n\t\t\treturn (0);\n\t\tif (bytes_read < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tnl = memchr(t, '\\n', bytes_read);\n\t\t/* If we found '\\n', trim the read to end exactly there. */\n\t\tif (nl != NULL) {\n\t\t\tbytes_read = ((const char *)nl) - ((const char *)t) + 1;\n\t\t}\n\t\tif (total_size + bytes_read + 1 > limit) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Line too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (archive_string_ensure(&mtree->line,\n\t\t\ttotal_size + bytes_read + 1) == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate working buffer\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* Append new bytes to string. */\n\t\tmemcpy(mtree->line.s + total_size, t, bytes_read);\n\t\t__archive_read_consume(a, bytes_read);\n\t\ttotal_size += bytes_read;\n\t\tmtree->line.s[total_size] = '\\0';\n\n\t\tfor (u = mtree->line.s + find_off; *u; ++u) {\n\t\t\tif (u[0] == '\\n') {\n\t\t\t\t/* Ends with unescaped newline. */\n\t\t\t\t*start = mtree->line.s;\n\t\t\t\treturn total_size;\n\t\t\t} else if (u[0] == '#') {\n\t\t\t\t/* Ends with comment sequence #...\\n */\n\t\t\t\tif (nl == NULL) {\n\t\t\t\t\t/* But we've not found the \\n yet */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (u[0] == '\\\\') {\n\t\t\t\tif (u[1] == '\\n') {\n\t\t\t\t\t/* Trim escaped newline. */\n\t\t\t\t\ttotal_size -= 2;\n\t\t\t\t\tmtree->line.s[total_size] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (u[1] != '\\0') {\n\t\t\t\t\t/* Skip the two-char escape sequence */\n\t\t\t\t\t++u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind_off = u - mtree->line.s;\n\t}\n}\n"], "filenames": ["libarchive/archive_read_support_format_mtree.c"], "buggy_code_start_loc": [1388], "buggy_code_end_loc": [1393], "fixing_code_start_loc": [1388], "fixing_code_end_loc": [1394], "type": "CWE-119", "message": "Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.", "other": {"cve": {"id": "CVE-2016-4301", "sourceIdentifier": "cret@cert.org", "published": "2016-09-21T14:25:03.377", "lastModified": "2017-07-01T01:29:46.733", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en pila en la funci\u00f3n parse_device en archive_read_support_format_mtree.c en libarchive en versiones anteriores a 3.2.1 permite a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de un archivo mtree manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.0", "matchCriteriaId": "6A6EFED3-4FD3-413D-85C2-73F746F346E8"}]}]}], "references": [{"url": "http://blog.talosintel.com/2016/06/the-poisoned-archives.html", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html", "source": "cret@cert.org"}, {"url": "http://www.securityfocus.com/bid/91328", "source": "cret@cert.org"}, {"url": "http://www.talosintel.com/reports/TALOS-2016-0153/", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1348441", "source": "cret@cert.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libarchive/libarchive/issues/715", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-03", "source": "cret@cert.org"}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77"}}